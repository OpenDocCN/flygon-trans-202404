- en: 'Recitation 4: Datatypes review'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Datatype constructors, binding and use occurrences
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By convention, data constructors (`Penny`, `Nickel`, etc. in the example below)
    start with capital letters. There are a few exceptions, such as `true` and `false`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By convention, variables (`value` and `c` in the example) start with lower case
    letters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The example above is a typical `match` expression. But consider the following
    variant. It looks like it should be the same, but when we compile this function,
    OCaml complains about redundant patterns.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Why? After all, isn't this equivalent to the following?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: No! Actually, it's more like
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: or even
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In a match expression, if there is a data constructor *C* on the left-hand side
    of the `->` in one of the patterns, then we are comparing to see if the value
    of the expression *e* we are trying to match is *C*. But if it is a variable name,
    then we're declaring a new, fresh instance of the variable and binding it to the
    value of *e*. So any patterns below this are redundant, because this match will
    never fail.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'An occurrence of an identifier in an expression can be either a *binding* occurrence
    or a *use* occurrence. For example, the following are all examples of binding
    occurrences of the identifier `id`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In contrast, just about anything else, for example
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: is a use occurrence of `id`. In these occurrences, `id` is evaluated, and its
    value is the value that was bound to it in the nearest binding occurrence of `id`,
    be it as a function argument, function declaration, value declaration, or pattern
    match.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: In the example
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: in the first pattern of the match, OCaml does not look to see that `penny` was
    previously bound to `Penny`. The occurrence of `penny` in the match expression
    is also a binding occurrence. The match will succeed, and it will bind `penny`
    anew to the value of `c`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Why do things this way? The most important reason is that binding identifiers
    in patterns is an extremely useful device that allows concise, elegant code. It
    is possible to simultaneously bind several identifiers in one pattern. For example,
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: simultaneously binds the three identifiers `x`, `y`, and `t`, which can then
    be used in the expression on the right-hand side. If you do not need a value,
    use the wildcard `_` in the pattern, which matches anything. For example,
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If we wanted to allow use occurrences of identifiers in patterns, we would need
    a way to distinguish them from binding occurrences. Currently there is no way
    to do this in OCaml.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Here is a puzzle to illustrate the difference between binding and use occurrences.
    What is the value of the following expression?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Figuring this out isn't easy, but here's how to think about it. Let's refer
    to the values bound to the different binding occurrences of the variables by their
    line numbers. So *x*[1] means the value bound to `x` in line 1.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Line 1 binds three identifiers `f`, `x`, and `y`. The identifiers `x`, and `y`
    are bound to the arguments to `f` supplied in line 8\. So *x*[1] = 2 and *y*[1]
    = 3\. The identifier `f` is bound to the function whose body is given in lines
    2–7.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 2 contains a binding occurrence of `x` and a use occurrence of `y`. So
    *x*[2] = *y*[1] = 3.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 3 contains a binding occurrence of `y` and a use occurrence of `x`. The
    closest binding of `x` is in line 2\. So *y*[3] = *x*[2] = 3.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 4 contains binding occurrences of `x` and `y` to the left of the `=` and
    use occurrences of both identifiers to the right of the `=`. The use occurrences
    take their values from the most recent previous bindings. So *y*[4] = *x*[2] =
    3 and *x*[4] = *y*[3] * *y*[3] = 9.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 5 contains only use occurrences of `x` and `y`. The values are *x*[4] =
    9 and *y*[4] = 3, respectively. It initiates a pattern match on the tuple (*y*[4],
    *x*[4]) = (3, 9).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 6 binds *x*[6] to *y*[4] = 3 and attempts to match (3, 9) with (3, 1).
    The match fails, so we proceed to the next pattern.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line 7 binds *x*[7] to *y*[4] = 3 and *y*[7] to *x*[4] = 9 and attempts to match
    (3, 9) with (3, 9). The match succeeds, and the value on the right-hand side of
    the `->` is *x*[7] = 3, which is also the value of the whole expression.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Using Polymorphism
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The list type
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because lists are so useful, OCaml provides a builtin parameterized list type
    called `list`. It acts just like the `List` type that we defined in lecture except
    that the names of the constructors are changed. The constructor `[]` makes an
    empty list (compare to `Nil`) and the constructor `::` builds a new list by prepending
    a first element to another list (compare to `Cons`). It is as if `list` were declared
    as:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '(although we can''t really do this because of OCaml naming conventions). The
    constructor `::` is an infix operator, which is notationally convenient. The OCaml
    interpreter knows how to print out lists nicely as well. The empty list is printed
    as `[]`, and nonempty lists are printed using brackets with semicolon-separated
    items. These forms may be used to write lists as well. Note that `[]` is a polymorphic
    value of type `''a list`; it serves as the empty list for all types `T list`.
    Here are some examples that show how lists work:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Just like with types, we have to make sure that we write exhaustive patterns
    in `match` expressions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Built-in lists come with [lots of useful predefined OCaml library functions](http://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html),
    such as the following and many more:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Of course, all of these functions could also be easily implemented for the `List`
    type that we defined ourselves.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Multiple type parameters
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We saw two related features of OCaml in class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: the ability to produce polymorphic values whose type mentions a type variable,
    and
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the ability to parameterize types with respect to an arbitrary type variable.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Polymorphic values are typically function values, but other polymorphic values
    exist, such as `[]` (and also `Nil`, as we defined it). Datatypes can actually
    be parameterized with respect to multiple type parameters. For example, the following
    type, `ortype`, is a type-level function that accepts a pair of types and yields
    a new type:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 多态值通常是函数值，但也存在其他多态值，比如 `[]`（以及我们定义的 `Nil`）。实际上，数据类型可以根据多个类型参数进行参数化。例如，以下类型 `ortype`
    是一个类型级函数，接受一对类型并产生一个新类型：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that the values `Left 2` and `Right "hello"` are still polymorphic with
    respect to one type. OCaml always starts counting type variables from `''a`, hence
    the `*- : (int, ''a) ortype*` rather than `*- : (int, ''b) ortype*` in the match
    for `Left 2` above.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '注意值 `Left 2` 和 `Right "hello"` 在一种类型上仍然是多态的。OCaml 总是从 `''a` 开始计算类型变量，因此上面 `Left
    2` 匹配中的 `*- : (int, ''a) ortype*` 而不是 `*- : (int, ''b) ortype*`。'
- en: The option parameterized type
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数化类型选项
- en: 'Another important standard parameterized type is `option`, which represents
    the *possible* presence of a value. It is defined as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的标准参数化类型是`option`，它表示值的*可能*存在性。其定义如下：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Options are commonly used when no useful value of a particular type makes sense.
    This corresponds to some uses of the value `null` in Java (`None` acts like `null`).
    The difference is that the use of `option` is type-safe. There is no danger of
    a runtime null pointer exception as long as you use pattern-matching with `option`,
    because the type system forces you to account for the possibility of `None`. Pattern
    matching should be used to check for and extract the value. [A more detailed description
    of option](http://ocaml-lib.sourceforge.net/doc/Option.html) is available in the
    OCaml Library documentation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 选项在某种类型的有用值没有意义时通常被使用。这对应于 Java 中 `null` 的一些用法（`None`的行为类似于`null`）。不同之处在于，使用
    `option` 是类型安全的。只要你使用模式匹配与 `option`，就不会出现运行时空指针异常的危险，因为类型系统强制你考虑到`None`的可能性。应该使用模式匹配来检查并提取值。[更详细的选项描述](http://ocaml-lib.sourceforge.net/doc/Option.html)在
    OCaml 库文档中可用。
