["```\n// Bad Idea\nclass MyClass\n{\npublic:\n  void do_something(int i);\n  void do_something(std::string str);\n};\n\n// Good Idea\nclass MyClass\n{\npublic:\n  void do_something(const int i);\n  void do_something(const std::string &str);\n}; \n```", "```\n// Very Bad Idea\nclass MyClass\n{\npublic:\n  explicit MyClass(const int& t_int_value)\n    : m_int_value(t_int_value)\n  {\n  }\n\n  const int& get_int_value() const\n  {\n    return m_int_value;\n  }\n\nprivate:\n  int m_int_value;\n} \n```", "```\n// Good Idea\nclass MyClass\n{\npublic:\n  explicit MyClass(const int t_int_value)\n    : m_int_value(t_int_value)\n  {\n  }\n\n  int get_int_value() const\n  {\n    return m_int_value;\n  }\n\nprivate:\n  int m_int_value;\n} \n```", "```\n// Bad Idea\nMyClass *myobj = new MyClass;\n\n// ...\ndelete myobj;\n\n// Good Idea\nauto myobj = std::make_unique<MyClass>(constructor_param1, constructor_param2); // C++14\nauto myobj = std::unique_ptr<MyClass>(new MyClass(constructor_param1, constructor_param2)); // C++11\nauto mybuffer = std::make_unique<char[]>(length); // C++14\nauto mybuffer = std::unique_ptr<char[]>(new char[length]); // C++11\n\n// or for reference counted objects\nauto myobj = std::make_shared<MyClass>(); \n\n// ...\n// myobj is automatically freed for you whenever it is no longer used. \n```", "```\n// Bad Idea\ndouble x = getX();\nint i = (int) x;\n\n// Not a Bad Idea\nint i = static_cast<int>(x); \n```"]