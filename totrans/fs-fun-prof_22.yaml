- en: A functional approach to error handling (Railway oriented programming)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个处理错误的函数式方法（铁路导向编程）
- en: Railway oriented programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 铁路导向编程
- en: '*UPDATE: [Slides and video from a more comprehensive presentation available
    here](http://fsharpforfunandprofit.com/rop/) (and if you understand the Either
    monad, [read this first](http://fsharpforfunandprofit.com/rop/#monads)!)*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*更新：[更全面演示的幻灯片和视频在这里](http://fsharpforfunandprofit.com/rop/)（如果你理解 Either monad，请[先读这篇](http://fsharpforfunandprofit.com/rop/#monads)）！*'
- en: 'In the previous post, we saw how a use case could be broken into steps, and
    all the errors shunted off onto a separate error track, like this:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇文章中，我们看到一个用例是如何被分解成步骤的，并且所有的错误都被分流到一个单独的错误轨道上，就像这样：
- en: '![A function with two outputs](Recipe_Function_ErrorTrack.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![一个带有两个输出的函数](Recipe_Function_ErrorTrack.png)'
- en: In this post, we'll look at various ways of connecting these step functions
    into a single unit. The detailed internal design of the functions will be described
    in a later post.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将看看连接这些步骤函数成一个单一单元的各种方法。函数的详细内部设计将在后续文章中描述。
- en: Designing a function that represents a step
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计代表一个步骤的函数
- en: Let's have a closer look at these steps. For example, consider the validation
    function. How would it work? Some data goes in, but what comes out?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这些步骤。例如，考虑验证函数。它是如何工作的？一些数据输入，但是输出是什么？
- en: 'Well, there are two possible cases: either the data is valid (the happy path),
    or something is wrong, in which case we go onto the failure path and bypass the
    rest of the steps, like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，有两种可能的情况：要么数据是有效的（正常路径），要么有些问题，这种情况下我们进入失败路径并绕过其余的步骤，就像这样：
- en: '![The validation function with a two outputs](Recipe_Validation_Paths.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![带有两个输出的验证函数](Recipe_Validation_Paths.png)'
- en: 'But as before, this would not be a valid function. A function can only have
    one output, so we must use the `Result` type we defined last time:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但是和以前一样，这不会是一个有效的函数。一个函数只能有一个输出，所以我们必须使用我们上次定义的`Result`类型：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And the diagram now looks like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在图表看起来像这样：
- en: '![The validation function with a success/failure output](Recipe_Validation_Union2.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![带有成功/失败输出的验证函数](Recipe_Validation_Union2.png)'
- en: 'To show you how this works in practice, here is an example of what an actual
    validation function might look like:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向你展示这在实践中是如何工作的，这里是一个实际验证函数可能看起来像的例子：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you look at the type of the function, the compiler has deduced that it takes
    a `Request` and spits out a `Result` as output, with a `Request` for the success
    case and a `string` for the failure case:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下函数的类型，编译器已经推断出它接受一个`Request`并输出一个`Result`，成功情况下是一个`Request`，失败情况下是一个`string`：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can analyze the other steps in the flow in the same way. We will find that
    each one will have the same "shape" -- some sort of input and then this Success/Failure
    output.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以同样的方式分析流程中的其他步骤。我们会发现每一个步骤都有相同的“形状” —— 一些输入，然后是这个成功/失败输出。
- en: '*A pre-emptive apology: Having just said that a function can''t have two outputs,
    I may occasionally refer to them hereafter as "two output" functions! Of course,
    what I mean is that the shape of the function output has two cases.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*提前道歉：刚刚说过函数不能有两个输出，我可能偶尔在此之后提到它们作为“两个输出”的函数！当然，我指的是函数输出的形状有两种情况。*'
- en: Railway oriented programming
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 铁路导向编程
- en: So we have a lot of these "one input -> Success/Failure output" functions --
    how do we connect them together?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们有很多这样的“一个输入 -> 成功/失败输出”的函数 —— 我们如何将它们连接起来？
- en: 'What we want to do is connect the `Success` output of one to the input of the
    next, but somehow bypass the second function in case of a `Failure` output. This
    diagram gives the general idea:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想做的是将一个的`Success`输出连接到下一个的输入，但是在`Failure`输出的情况下绕过第二个函数。这张图表给出了一般的想法：
- en: '![Connecting validation function with update function](Recipe_Validation_Update.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![将验证函数与更新函数连接起来](Recipe_Validation_Update.png)'
- en: There is a great analogy for doing this -- something you are probably already
    familiar with. Railways!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个很好的类比 —— 你可能已经很熟悉了。铁路！
- en: 'Railways have switches ("points" in the UK) for directing trains onto a different
    track. We can think of these "Success/Failure" functions as railway switches,
    like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 铁路有用于将火车引导到不同轨道的转换器（在英国称为“points”）。我们可以将这些“成功/失败”函数视为铁路转换器，就像这样：
- en: '![A railway switch](Recipe_RailwaySwitch.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![一个铁路转换器](Recipe_RailwaySwitch.png)'
- en: And here we have two in a row.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有两个连续的。
- en: '![2 railway switches disconnected](Recipe_RailwaySwitch1.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![2个断开的铁路转换器](Recipe_RailwaySwitch1.png)'
- en: How do we combine them so that both failure tracks are connected? It's obvious
    -- like this!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何组合它们以连接两个失败轨道？很明显——像这样！
- en: '![2 railway switches connected](Recipe_RailwaySwitch2.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![连接了2个铁路开关](Recipe_RailwaySwitch2.png)'
- en: 'And if we have a whole series of switches, we will end up with a two track
    system, looking something like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一系列开关，我们将得到一个双轨系统，看起来像这样：
- en: '![3 railway switches connected](Recipe_RailwaySwitch3.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![连接了3个铁路开关](Recipe_RailwaySwitch3.png)'
- en: The top track is the happy path, and the bottom track is the failure path.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部轨道是顺利路径，底部轨道是失败路径。
- en: 'Now stepping back and looking at the big picture, we can see that we will have
    a series of black box functions that appear to be straddling a two-track railway,
    each function processing data and passing it down the track to the next function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在退一步，审视整体情况，我们可以看到我们将会有一系列黑盒函数，看起来像是横跨着双轨铁路，每个函数都处理数据并将其传递到下一个函数的轨道上：
- en: '![Opaque functions](Recipe_Railway_Opaque.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![不透明函数](Recipe_Railway_Opaque.png)'
- en: 'But if we look inside the functions, we can see that there is actually a switch
    inside each one, for shunting bad data onto the failure track:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们查看函数内部，我们会看到实际上每个函数内部都有一个开关，用于将坏数据转移到失败轨道上：
- en: '![Transparent functions](Recipe_Railway_Transparent.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![透明函数](Recipe_Railway_Transparent.png)'
- en: Note that once we get on the failure path, we never (normally) get back onto
    the happy path. We just bypass the rest of the functions until we reach the end.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦我们进入失败路径，我们就再也（通常）不会回到顺利路径上。我们只是绕过剩下的函数直到达到末端。
- en: Basic composition
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本的组合
- en: Before we discuss how to "glue" the step functions together, let's review how
    composition works.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何"粘合"步骤函数之前，让我们回顾一下组合是如何工作的。
- en: Imagine that a standard function is a black box (a tunnel, say) sitting on a
    one-track railway. It has one input and one output.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个标准函数是一个黑盒子（比如说一个隧道），坐落在一条单轨铁路上。它有一个输入和一个输出。
- en: If we want to connect a series of these one-track functions, we can use the
    left-to-right composition operator, with the symbol `>>`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想连接一系列这些单轨函数，我们可以使用从左到右的组合运算符，使用符号`>>`。
- en: '![Composition of one-track functions](Recipe_Railway_Compose1.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![一轨函数的组合](Recipe_Railway_Compose1.png)'
- en: 'The same composition operation also works with two-track functions as well:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的组合操作也适用于双轨函数：
- en: '![Composition of two-track functions](Recipe_Railway_Compose2.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![两轨函数的组合](Recipe_Railway_Compose2.png)'
- en: The only constraint on composition is that the output type of the left-hand
    function has to match the input type of the right-hand function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 组合的唯一约束是左侧函数的输出类型必须与右侧函数的输入类型匹配。
- en: In our railway analogy, this means that you can connect one-track output to
    one-track input, or two-track output to two-track input, but you *can't* directly
    connect two-track output to one-track input.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的铁路类比中，这意味着你可以连接单轨输出到单轨输入，或双轨输出到双轨输入，但*不能*直接连接双轨输出到单轨输入。
- en: '![Composition of two-track functions](Recipe_Railway_Compose3.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![两轨函数的组合](Recipe_Railway_Compose3.png)'
- en: Converting switches to two-track inputs
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将开关转换为双轨输入
- en: So now we have run into a problem.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们遇到了一个问题。
- en: The function for each step is going to be a switch, with *one* input track.
    But the overall flow requires a *two-track* system, with each function straddling
    *both* tracks, meaning that each function must have a two-track input (the `Result`
    output by the previous function), not just a simple one-track input (`Request`).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每一步的函数都将是一个开关，具有*一个*输入轨道。但总体流程需要一个*双轨*系统，每个函数都横跨*两条*轨道，这意味着每个函数必须具有双轨输入（由上一个函数输出的`Result`），而不仅仅是一个简单的单轨输入（`Request`）。
- en: How can we insert the switches into the two track system?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将开关插入双轨系统中？
- en: 'The answer is simple. We can create an "adapter" function that has a "hole"
    or "slot" for a switch function and converts it into a proper two-track function.
    Here''s an illustration:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单。我们可以创建一个"适配器"函数，它有一个用于开关函数的"孔"或"槽"，并将其转换为一个合适的双轨函数。下面是一个示例：
- en: '![Bind adapter](Recipe_Railway_BindAdapter.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![绑定适配器](Recipe_Railway_BindAdapter.png)'
- en: And here's what the actual code looks like. I'm going to name the adapter function
    `bind`, which is the standard name for it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是实际代码的样子。我将适配器函数命名为`bind`，这是它的标准名称。
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The bind function takes a switch function as a parameter and returns a new function.
    The new function takes a two-track input (which is of type `Result`) and then
    checks each case. If the input is a `Success` it calls the `switchFunction` with
    the value. But if the input is a `Failure`, then the switch function is bypassed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`函数接受一个开关函数作为参数并返回一个新函数。新函数接受一个双轨输入（类型为`Result`），然后检查每种情况。如果输入是`Success`，它将调用带有该值的`switchFunction`。但如果输入是`Failure`，则绕过开关函数。'
- en: 'Compile it and then look at the function signature:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 编译它，然后查看函数签名：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: One way of interpreting this signature is that the `bind` function has one parameter,
    a switch function (`'a -> Result<..>`) and it returns a fully two-track function
    (`Result<..> -> Result<..>`) as output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 解释这个签名的一种方式是，`bind`函数有一个参数，一个开关函数(`'a -> Result<..>`)，并将一个完全双轨函数(`Result<..>
    -> Result<..>`)作为输出返回。
- en: 'To be even more specific:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说：
- en: The parameter (`switchFunction`) of bind takes some type `'a` and emits a `Result`
    of type `'b` (for the success track) and `'c` (for the failure track)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bind`的参数(`switchFunction`)接受某种类型`''a`并发出类型为`''b`（成功路径）和`''c`（失败路径）的`Result`'
- en: The returned function itself has a parameter (`twoTrackInput`) which is a `Result`
    of type `'a` (for success) and `'c` (for failure). The type `'a` has to be the
    same as what the `switchFunction` is expecting on its one track.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的函数本身有一个参数(`twoTrackInput`)，它是类型为`'a`（成功）和`'c`（失败）的`Result`。类型`'a`必须与`switchFunction`在其单轨上期望的类型相同。
- en: The output of the returned function is another `Result`, this time of type `'b`
    (for success) and `'c` (for failure) -- the same type as the switch function output.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回函数的输出是另一个`Result`，这次是类型为`'b`（成功）和`'c`（失败）的 -- 与开关函数输出相同的类型。
- en: If you think about it, this type signature is exactly what we would expect.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，这个类型签名正是我们所期望的。
- en: Note that this function is completely generic -- it will work with *any* switch
    function and *any* types. All it cares about is the "shape" of the `switchFunction`,
    not the actual types involved.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个函数是完全通用的 -- 它将适用于*任何*开关函数和*任何*类型。它只关心`switchFunction`的“形状”，而不关心实际涉及的类型。
- en: Other ways of writing the bind function
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写`bind`函数的其他方法
- en: Just as an aside, there are some other ways of writing functions like this.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，还有一些其他编写这种函数的方法。
- en: 'One way is to use an explicit second parameter for the `twoTrackInput` rather
    than defining an internal function, like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用显式的第二个参数`twoTrackInput`而不是定义一个内部函数，就像这样：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is exactly the same as the first definition. And if you are wondering how
    a two parameter function can be exactly the same as a one parameter function,
    you need to read the post on [currying](currying.html)!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这与第一个定义完全相同。如果你想知道一个有两个参数的函数如何与一个有一个参数的函数完全相同，你需要阅读关于[currying](currying.html)的文章！
- en: 'Yet another way of writing it is to replace the `match..with` syntax with the
    more concise `function` keyword, like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种写法是用更简洁的`function`关键字替换`match..with`语法，就像这样：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You might see all three styles in other code, but I personally prefer to use
    the second style (`let bind switchFunction twoTrackInput =`), because I think
    that having explicit parameters makes the code more readable for non-experts.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在其他代码中看到这三种风格，但我个人更喜欢使用第二种风格(`let bind switchFunction twoTrackInput =`)，因为我认为明确的参数使得代码对非专家更易读。
- en: 'Example: Combining some validation functions'
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子：结合一些验证函数
- en: Let's write a little bit of code now, to test the concepts.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们写一点代码来测试这些概念。
- en: 'Let''s start with what we already have defined. `Request`, `Result` and `bind`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们已经定义的东西开始。`Request`、`Result`和`bind`：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next we''ll create three validation functions, each of which is a "switch"
    function, with the goal of combining them into one bigger function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将创建三个验证函数，每个都是一个“开关”函数，目标是将它们组合成一个更大的函数：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now to combine them, we apply `bind` to each validation function to create a
    new alternative function that is two-tracked.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要将它们组合起来，我们将`bind`应用于每个验证函数，以创建一个新的双轨函数。
- en: 'Then we can connect the two-tracked functions using standard function composition,
    like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用标准函数组合连接这两个双轨函数，就像这样：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The functions `validate2'` and `validate3'` are new functions that take two-track
    input. If you look at their signatures you will see that they take a `Result`
    and return a `Result`. But note that `validate1` does not need to be converted
    to two track input. Its input is left as one-track, and its output is two-track
    already, as needed for composition to work.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`validate2'`和`validate3'`是新函数，它们接受两轨道输入。如果你看一下它们的签名，你会发现它们接受一个`Result`并返回一个`Result`。但请注意，`validate1`不需要转换为两轨道输入。它的输入保持为单轨道，而其输出已经是双轨道的，正如组合所需的那样。
- en: Here's a diagram showing the `Validate1` switch (unbound) and the `Validate2`
    and `Validate3` switches, together with the `Validate2'` and `Validate3'` adapters.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个显示`Validate1`开关（未绑定）以及`Validate2`和`Validate3`开关的图表，以及`Validate2'`和`Validate3'`适配器的图表。
- en: '![Validate2 and Validate3 connected](Recipe_Railway_Validator2and3.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Validate2和Validate3连接](Recipe_Railway_Validator2and3.png)'
- en: 'We could have also "inlined" the `bind`, like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以像这样“内联”`bind`：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s test it with two bad inputs and a good input:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用两个错误的输入和一个良好的输入来测试它：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I would encourage you to try it for yourself and play around with the validation
    functions and test input.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你自己尝试并玩弄验证函数和测试输入。
- en: '*You might be wondering if there is a way to run all three validations in parallel,
    rather than serially, so that you can get back all the validation errors at once.
    Yes, there is a way, which I''ll explain later in this post.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能会想知道是否有一种方法可以并行运行所有三个验证，而不是串行运行，这样你就可以一次性得到所有的验证错误。是的，有一种方法，我稍后会在本文中解释。*'
- en: Bind as a piping operation
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为管道操作的绑定
- en: While we are discussing the `bind` function, there is a common symbol for it,
    `>>=`, which is used to pipe values into switch functions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论`bind`函数时，有一个常用的符号，`>>=`，用于将值传输到开关函数中。
- en: 'Here''s the definition, which switches around the two parameters to make them
    easier to chain together:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是定义，将两个参数调换以使它们更容易连锁在一起的方法：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*One way to remember the symbol is to think of it as the composition symbol,
    `>>`, followed by a two-track railway symbol, `=`.*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*记住这个符号的一种方法是将其视为组合符号`>>`，后跟双轨道铁路符号`=`。*'
- en: When used like this, the `>>=` operator is sort of like a pipe (`|>`) but for
    switch functions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当像这样使用时，`>>=`运算符有点像一个管道（`|>`）但对于开关函数而言。
- en: In a normal pipe, the left hand side is a one-track value, and the right hand
    value is a normal function. But in a "bind pipe" operation, the left hand side
    is a *two-track* value, and the right hand value is a *switch function*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的管道中，左边是一个单轨道值，右边是一个普通函数。 但在“绑定管道”操作中，左边是一个*双轨道*值，右边是一个*开关函数*。
- en: Here it is in use to create another implementation of the `combinedValidation`
    function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是将其用于创建`combinedValidation`函数的另一个实现。
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The difference between this implementation and the previous one is that this
    definition is *data-oriented* rather than *function-oriented*. It has an explicit
    parameter for the initial data value, namely `x`. `x` is passed to the first function,
    and then the output of that is passed to the second function, and so on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现与之前的实现的区别在于，这个定义是*数据导向*而不是*函数导向*。 它有一个明确的参数用于初始数据值，即`x`。 `x`被传递给第一个函数，然后将其输出传递给第二个函数，依此类推。
- en: In the previous implementation (repeated below), there was no data parameter
    at all! The focus was on the functions themselves, not the data that flows through
    them.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的实现中（下面重复显示），根本没有数据参数！重点是函数本身，而不是流经它们的数据。
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: An alternative to bind
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定的另一种选择
- en: Another way to combine switches is not by adapting them to a two track input,
    but simply by joining them directly together to make a new, bigger switch.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种组合开关的方式不是将它们适应为两个轨道输入，而是直接将它们连接在一起以制作一个新的更大的开关。
- en: 'In other words, this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这个：
- en: '![2 railway switches disconnected](Recipe_RailwaySwitch1.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![2个铁路开关断开连接](Recipe_RailwaySwitch1.png)'
- en: 'becomes this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 变成这样：
- en: '![2 railway switches connected](Recipe_RailwaySwitch2.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![2个铁路开关连接](Recipe_RailwaySwitch2.png)'
- en: 'But if you think about it, this combined track is actually just another switch!
    You can see this if you cover up the middle bit. There''s one input and two outputs:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你仔细想一想，这个组合轨道实际上只是另一个开关！如果你遮住中间部分，你就会看到一个输入和两个输出：
- en: '![2 railway switches connected](Recipe_RailwaySwitch2a.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![2个铁路开关连接](Recipe_RailwaySwitch2a.png)'
- en: 'So what we have really done is a form of composition for switches, like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们真正做的是一种开关的组合，像这样：
- en: '![switches composition](Recipe_Railway_MComp.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![开关组合](Recipe_Railway_MComp.png)'
- en: Because each composition results in just another switch, we can always add another
    switch again, resulting in an even bigger thing that is still a switch, and so
    on.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个组合结果只是另一个开关，我们总是可以再次添加另一个开关，从而得到一个更大的仍然是开关的东西，依此类推。
- en: Here's the code for switch composition. The standard symbol used is `>=>`, a
    bit like the normal composition symbol, but with a railway track between the angles.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`switch`组合的代码。标准符号是`>=>`，有点像正常的组合符号，但在角之间有一条铁路轨道。
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Again, the actual implementation is very straightforward. Pass the single track
    input `x` through the first switch. On success, pass the result into the second
    switch, otherwise bypass the second switch completely.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，实际实现非常简单。将单轨输入`x`通过第一个开关。成功后，将结果传递给第二个开关，否则完全绕过第二个开关。
- en: 'Now we can rewrite the `combinedValidation` function to use switch composition
    rather than bind:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以重写`combinedValidation`函数，使用`switch`组合而不是`bind`：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This one is the simplest yet, I think. It's very easy to extend of course, if
    we have a fourth validation function, we can just append it to the end.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这是最简单的一个。当然，如果我们有第四个验证函数，我们可以简单地将其附加到末尾。
- en: Bind vs. switch composition
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Bind` vs. `switch`组合'
- en: We have two different concepts that at first glance seem quite similar. What's
    the difference?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个乍看起来相似的不同概念。有什么区别？
- en: 'To recap:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：
- en: '**Bind** has *one* switch function parameter. It is an adapter that converts
    the switch function into a fully two-track function (with two-track input and
    two-track output).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Bind`**有*一个*开关函数参数。它是一个适配器，将开关函数转换为完全双轨函数（具有双轨输入和双轨输出）。'
- en: '**Switch composition** has *two* switch function parameters. It combines them
    in series to make another switch function.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Switch`组合**有*两个*开关函数参数。它将它们串联起来形成另一个开关函数。'
- en: So why would you use bind rather than switch composition? It depends on the
    context. If you have an existing two-track system, and you need to insert a switch,
    then you have to use bind as an adapter to convert the switch into something that
    takes two-track input.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要使用`bind`而不是`switch`组合？这取决于上下文。如果你有一个现有的双轨系统，并且需要插入一个开关，那么你必须使用`bind`作为适配器，将开关转换为接受双轨输入的东西。
- en: '![switches composition](Recipe_Railway_WhyBind.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![开关组合](Recipe_Railway_WhyBind.png)'
- en: On the other hand, if your entire data flow consists of a chain of switches,
    then switch composition can be simpler.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你的整个数据流由一系列开关组成，那么`switch`组合可能更简单。
- en: '![switches composition](Recipe_Railway_WhyCompose.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![开关组合](Recipe_Railway_WhyCompose.png)'
- en: Switch composition in terms of bind
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用`bind`来解释`switch`组合
- en: 'As it happens, switch composition can be written in terms of bind. If you connect
    the first switch with a bind-adapted second switch, you get the same thing as
    switch composition:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 突然间，`switch`组合可以用`bind`来写。如果你将第一个开关与一个适配为`bind`的第二个开关连接起来，你会得到与`switch`组合相同的东西：
- en: 'Here are two separate switches:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个独立的开关：
- en: '![2 railway switches disconnected](Recipe_RailwaySwitch1.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![2个铁路开关断开连接](Recipe_RailwaySwitch1.png)'
- en: 'And then here are the switches composed together to make a new bigger switch:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这些开关组合在一起形成一个更大的新开关：
- en: '![2 railway switches disconnected](Recipe_RailwaySwitch2.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![2个铁路开关断开连接](Recipe_RailwaySwitch2.png)'
- en: 'And here''s the same thing done by using `bind` on the second switch:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过在第二个开关上使用`bind`来完成相同的事情：
- en: '![bind as switch composition](Recipe_Railway_BindIsCompose.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![bind作为switch组合](Recipe_Railway_BindIsCompose.png)'
- en: 'Here''s the switch composition operator rewritten using this way of thinking:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用这种思维方式重写的`switch`组合运算符：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This implementation of switch composition is much simpler than the first one,
    but also more abstract. Whether it is easier to comprehend for a beginner is another
    matter! I find that if you think of functions as things in their own right, rather
    than just as conduits for data, this approach becomes easier to understand.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`switch`组合的实现比第一种简单得多，但也更抽象。对于初学者来说是否更容易理解是另一回事！我发现，如果你将函数看作是独立的事物，而不仅仅是数据的传输通道，这种方法就变得更容易理解。
- en: Converting simple functions to the railway-oriented programming model
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将简单函数转换为铁路导向的编程模型
- en: Once you get the hang of it, you can fit all sorts of other things into this
    model.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了它，你可以将各种其他东西适应到这个模型中。
- en: For example, let's say we have a function that is *not* a switch, just a regular
    function. And say that we want to insert it into our flow.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个*不是*开关的函数，只是一个常规函数。假设我们想要将其插入到我们的流程中。
- en: 'Here''s a real example - say that we want to trim and lowercase the email address
    after the validation is complete. Here''s some code to do this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个真实的例子 - 假设我们想要在验证完成后修剪和转换电子邮件地址为小写。以下是一些代码来实现这一点：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code takes a (single-track) `Request` and returns a (single-track) `Request`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码接受一个（单轨）`Request`并返回一个（单轨）`Request`。
- en: How can we insert this after the validation steps but before the update step?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在验证步骤之后但在更新步骤之前插入这个功能？
- en: Well, if we can turn this simple function into a switch function, then we can
    use the switch composition we just talked about above.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果我们可以将这个简单功能转换为开关功能，那么我们就可以使用我们上面讨论过的开关组合。
- en: In other words, we need an adapter block. It the same concept that we used for
    `bind`, except that this time our adapter block will have a slot for one-track
    function, and the overall "shape" of the adapter block is a switch.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们需要一个适配器块。这与我们用于`bind`的概念相同，只是这次我们的适配器块将有一个单轨功能插槽，并且适配器块的整体“形状”是一个开关。
- en: '![lifting a simple function](Recipe_Railway_SwitchAdapter.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![提升简单功能](Recipe_Railway_SwitchAdapter.png)'
- en: The code to do this is trivial. All we need to do is take the output of the
    one track function and turn it into a two-track result. In this case, the result
    will *always* be Success.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的代码非常简单。我们只需要取出单轨功能的输出并将其转换为双轨结果。在这种情况下，���果将*始终*是Success。
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In railway terms, we have added a bit of failure track. Taken as a whole, it
    *looks* like a switch function (one-track input, two-track output), but of course,
    the failure track is just a dummy and the switch never actually gets used.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在铁路术语中，我们增加了一点失败轨道。整体上看，它*看起来*像一个开关功能（单轨输入，双轨输出），但当然，失败轨道只是一个虚拟的，开关实际上从未被使用。
- en: '![lifting a simple function](Recipe_Railway_SwitchAdapter2.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![提升简单功能](Recipe_Railway_SwitchAdapter2.png)'
- en: Once `switch` is available, we can easily append the `canonicalizeEmail` function
    to the end of the chain. Since we are beginning to extend it, let's rename the
    function to `usecase`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`switch`可用，我们就可以轻松地将`canonicalizeEmail`函数附加到链的末尾。由于我们开始扩展它，让我们将函数重命名为`usecase`。
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Try testing it to see what happens:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试测试它看看会发生什么：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating two-track functions from one-track functions
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从单轨功能创建双轨功能
- en: In the previous example, we took a one-track function and created a switch from
    it. This enabled us to use switch composition with it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们拿到了一个单轨功能，并从中创建了一个开关。这使我们能够与其一起使用开关组合。
- en: Sometimes though, you want to use the two-track model directly, in which case
    you want to turn a one-track function into a two-track function directly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，您想直接使用双轨模型，这种情况下，您希望直接将单轨功能转换为双轨功能。
- en: '![mapping a simple function](Recipe_Railway_MapAdapter2.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![映射简单功能](Recipe_Railway_MapAdapter2.png)'
- en: Again, we just need an adapter block with a slot for the simple function. We
    typically call this adapter `map`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们只需要一个带有简单功能插槽的适配器块。我们通常称这个适配器为`map`。
- en: '![mapping a simple function](Recipe_Railway_MapAdapter.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![映射简单功能](Recipe_Railway_MapAdapter.png)'
- en: And again, the actual implementation is very straightforward. If the two-track
    input is `Success`, call the function, and turn its output into Success. On the
    other hand, if the two-track input is `Failure` bypass the function completely.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，实际实现非常简单。如果双轨输入是`Success`，则调用该函数，并将其输出转换为Success。另一方面，如果双轨输入是`Failure`，则完全绕过该函数。
- en: 'Here''s the code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And here it is in use with `canonicalizeEmail`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与`canonicalizeEmail`一起使用的情况：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that *normal* composition is now used because `map canonicalizeEmail` is
    a fully two-track function and can be connected to the output of the `validate3`
    switch directly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*正常*组合现在被使用，因为`map canonicalizeEmail`是一个完全双轨功能，可以直接连接到`validate3`开关的输出。
- en: In other words, for one-track functions, `>=> switch` is exactly the same as
    `>> map`. Your choice.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，对于单轨功能，`>=> switch`与`>> map`完全相同。你的选择。
- en: Converting dead-end functions to two-track functions
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将死胡同函数转换为双轨功能
- en: Another function we will often want to work with is a "dead-end" function --
    a function that accepts input but has no useful output.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常想要使用的另一个函数是“死胡同”函数--一个接受输入但没有有用输出的函数。
- en: For example, consider a function that updates a database record. It is useful
    only for its side-effects -- it doesn't normally return anything.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个更新数据库记录的函数。它仅用于其副作用 -- 通常不返回任何内容。
- en: How can we incorporate this kind of function into the flow?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将这种类型的函数纳入流程中？
- en: 'What we need to do is:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是：
- en: Save a copy of the input.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存输入的副本。
- en: Call the function and ignore its output, if any.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用函数并忽略其输出，如果有的话。
- en: Return the original input for passing on to the next function in the chain.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回原始输入，以传递给链中的下一个函数。
- en: From a railway point of view, this is equivalent to creating a dead-end siding,
    like this.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从铁路的角度来看，这相当于创建一个死胡同的侧线，就像这样。
- en: '![tee for a dead end function](Recipe_Railway_Tee.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![死胡同函数的分歧](Recipe_Railway_Tee.png)'
- en: To make this work, we need another adapter function, like `switch`, except that
    this time it has a slot for one-track dead-end function, and converts it into
    a single-track pass through function, with a one-track output.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个工作起来，我们需要另一个适配器函数，类似于`switch`，只是这次它有一个用于单轨死胡同函数的插槽，并将其转换为具有单轨输出的单轨直通函数。
- en: '![tee for a dead end function](Recipe_Railway_TeeAdapter.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![死胡同函数的分歧](Recipe_Railway_TeeAdapter.png)'
- en: 'Here''s the code, which I will call `tee`, after the UNIX tee command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码，我将其称为`tee`，以UNIX tee命令命名：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once we have converted the dead-end function to a simple one-track pass through
    function, we can then use it in the data flow by converting it using `switch`
    or `map` as described above.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将死胡同函数转换为简单的单轨直通函数，我们就可以通过使用上述的`switch`或`map`将其用于数据流中。
- en: 'Here''s the code in use with the "switch composition" style:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用“switch组合”风格的代码：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Or alternatively, rather than using `switch` and then connecting with `>=>`,
    we can use `map` and connect with `>>`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，与其使用`switch`然后连接`>=>`，我们可以使用`map`并连接`>>`。
- en: Here's a variant implementation which is exactly the same but uses the "two-track"
    style with normal composition
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个变体实现，完全相同，但使用了“两轨”风格与正常组合
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Handling exceptions
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理异常
- en: Our dead end database update might not return anything, but that doesn't mean
    that it might not throw an exception. Rather than crashing, we want to catch that
    exception and turn it into a failure.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的死胡同数据库更新可能不会返回任何内容，但这并不意味着它不会抛���异常。与其崩溃，我们希望捕获该异常并将其转换为失败。
- en: 'The code is similar to the `switch` function, except that it catches exceptions.
    I''ll call it `tryCatch`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 代码类似于`switch`函数，只是它捕获异常。我将其称为`tryCatch`：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And here is a modified version of the data flow, using `tryCatch` rather than
    `switch` for the update database code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是修改后的数据流代码，使用`tryCatch`而不是`switch`来更新数据库代码。
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Functions with two-track input
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有两轨输入的函数
- en: All the functions we have seen so far have only one input, because they always
    just work with data travelling along the happy path.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所见过的所有函数都只有一个输入，因为它们总是沿着正常路径处理数据。
- en: Sometimes though, you *do* need a function that handles both tracks. For example,
    a logging function that logs errors as well as successes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，*确实*需要一个处理两个轨道的函数。例如，一个记录错误和成功的日志函数。
- en: As we have done previously, we will create an adapter block, but this time it
    will have slots for *two* separate one-track functions.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所做的那样，我们将创建一个适配器块，但这次它将有*两个*单独的单轨函数插槽。
- en: '![double map adapter](Recipe_Railway_DoubleMapAdapter.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![双重映射适配器](Recipe_Railway_DoubleMapAdapter.png)'
- en: 'Here''s the code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As an aside, we can use this function to create a simpler version of `map`,
    using `id` for the failure function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们可以使用这个函数创建`map`的一个更简单的版本，使用`id`作为失败函数：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s use `doubleMap` to insert some logging into the data flow:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`doubleMap`将一些日志插入到数据流中：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here''s some test code, with the results:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些测试代码，以及结果：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Converting a single value to a two-track value
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将单个值转换为两轨值
- en: For completeness, we should also create simple functions that turn a single
    simple value into a two-track value, either success or failure.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我们还应该创建简单的函数，将单个简单值转换为两轨值，成功或失败。
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Right now these are trivial, just calling the constructor of the `Result` type,
    but when we get down to some proper coding we'll see that by using these rather
    than the union case constructor directly, we can isolate ourselves from changes
    behind the scenes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些都很简单，只是调用`Result`类型的构造函数，但当我们开始进行一些真正的编码时，我们会看到，通过使用这些而不是直接使用联合案例构造函数，我们可以使自己与幕后的更改隔离开来。
- en: Combining functions in parallel
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行组合函数
- en: 'So far, we have combined functions in series. But with something like validation,
    we might want to run multiple switches in parallel, and combine the results, like
    this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经按顺序组合了函数。但对于诸如验证之类的事情，我们可能希望同时运行多个开关，并组合结果，就像这样：
- en: '![switches in parallel](Recipe_Railway_Parallel.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![并行开关](Recipe_Railway_Parallel.png)'
- en: 'To make this easier, we can reuse the same trick that we did for switch composition.
    Rather than doing many at once, if we just focus on a single pair, and "add" them
    to make a new switch, we can then easily chain the "addition" together so that
    we can add as many as we want. In other words, we just need to implement this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易实现这一点，我们可以重用我们用于开关组合的相同技巧。与其一次性做很多，如果我们只关注一个配对，并将它们“相加”以创建一个新的开关，那么我们就可以轻松地将“加法”链接在一起，以便我们可以添加任意数量。换句话说，我们只需要实现这个：
- en: '![add two switches in parallel](Recipe_Railway_MPlus.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![并行添加两个开关](Recipe_Railway_MPlus.png)'
- en: So, what is the logic for adding two switches in parallel?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，并行添加两个开关的逻辑是什么？
- en: First, take the input and apply it to each switch.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，获取输入并将其应用于每个开关。
- en: Next look at the outputs of both switches, and if both are successful, the overall
    result is `Success`.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来看看两个开关的输出，如果两者都成功，则整体结果为`成功`。
- en: If either output is a failure, then the overall result is `Failure` as well.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何一个输出是失败，则整体结果也是`失败`。
- en: 'Here''s the function, which I will call `plus`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是函数，我将其称为`plus`：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: But we now have a new problem. What do we do with two successes, or two failures?
    How do we combine the inner values?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们有了一个新问题。两个成功，或两个失败，我们应该怎么处理内部值的组合？
- en: I used `s1 + s2` and `f1 + f2` in the example above, but that implies that there
    is some sort of `+` operator we can use. That may be true for strings and ints,
    but it is not true in general.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我在上面的示例中使用了`s1 + s2`和`f1 + f2`，但这意味着我们可以使用某种形式的`+`运算符。这对于字符串和整数来说可能是正确的，但一般情况下并非如此。
- en: The method of combining values might change in different contexts, so rather
    than trying to solve it once and for all, let's punt by letting the caller pass
    in the functions that are needed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的上下文中，组合值的方法可能会改变，因此与其试图一劳永逸地解决它，不如让调用者通过传入所需的函数来解决。
- en: 'Here''s a rewritten version:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是重写的版本：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: I have put these new functions first in the parameter list, to aid partial application.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '我将这些新函数放在参数列表的前面，以帮助部分应用。 '
- en: An implementation for parallel validation
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于并行验证的实现
- en: Now let's create a implementation of "plus" for the validation functions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为验证函数创建一个“plus”的实现。
- en: When both functions succeed, they will return the request unchanged, so the
    `addSuccess` function can return either parameter.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当两个函数都成功时，它们将返回未更改的请求，因此`addSuccess`函数可以返回任一参数。
- en: When both functions fail, they will return different strings, so the `addFailure`
    function should concatenate them.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当两个函数都失败时，它们将返回不同的字符串，因此`addFailure`函数应该将它们连接起来。
- en: For validation then, the "plus" operation that we want is like an "AND" function.
    Only if both parts are "true" is the result "true".
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于验证来说，我们想要的“plus”操作就像一个“AND”函数。只有两个部分都是“true”才是结果“true”。
- en: 'That naturally leads to wanting to use `&&` as the operator symbol. Unfortunately,
    `&&` is reserved, but we can use `&&&`, like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这自然会让人想要使用`&&`作为操作符号。不幸的是，`&&`是保留字，但我们可以使用`&&&`，就像这样：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And now using `&&&`, we can create a single validation function that combines
    the three smaller validations:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用`&&&`，我们可以创建一个组合三个较小验证的单个验证函数：
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now let''s try it with the same tests we had earlier:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用之前相同的测试来尝试一下：
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first test now has *two* validation errors combined into a single string,
    just as we wanted.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在第一个测试有了*两个*验证错误合并为一个字符串，就像我们想要的那样。
- en: 'Next, we can tidy up the main dataflow function by using the `usecase` function
    now instead of the three separate validation functions we had before:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过现在使用`usecase`函数来整理主数据流函数，而不是之前的三个单独的验证函数：
- en: '[PRE39]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And if we test that now, we can see that a success flows all the way to the
    end and that the email is lowercased and trimmed:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在测试一下，我们会发现成功一直流到最后，并且电子邮件已经转换为小写并且已修剪：
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*You might be asking, can we create a way of OR-ing validation functions as
    well? That is, the overall result is valid if either part is valid? The answer
    is yes, of course. Try it! I suggest that you use the symbol `|||` for this.*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*也许你会问，我们是否可以创建一种方式来进行验证函数的OR操作？也就是说，如果任何一部分有效，则整体结果有效？答案是肯定的，当然可以。试试看！我建议您使用符号`|||`。*'
- en: Dynamic injection of functions
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态函数注入
- en: Another thing we might want to do is add or remove functions into the flow dynamically,
    based on configuration settings, or even the content of the data.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要做的另一件事是基于配置设置或甚至数据内容动态地添加或删除函数到流中。
- en: The simplest way to do this is to create a two-track function to be injected
    into the stream, and replace it with the `id` function if not needed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的最简单方法是创建一个要注入到流中的双轨道函数，并在不需要时用`id`函数替换它。
- en: 'Here''s the idea:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个想法：
- en: '[PRE41]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s try it with some real code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些真实的代码试试：
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And here is it in use:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的使用方式：
- en: '[PRE43]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The railway track functions: A toolkit'
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 铁路轨道函数：一个工具包
- en: Let's step back and review what we have done so far.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退后一步，回顾一下我们到目前为止所做的事情。
- en: Using railway track as a metaphor, we have created a number of useful building
    blocks that will work with *any* data-flow style application.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用铁路轨道作为隐喻，我们创建了一些有用的构建块，可以与*任何*数据流应用程序一起使用。
- en: 'We can classify our functions roughly like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的函数大致分类如下：
- en: '**"constructors"** are used to create new track.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**“构造函数”** 用于创建新的轨道。'
- en: '**"adapters"** convert one kind of track into another.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**“适配器”** 将一种轨道转换为另一种轨道。'
- en: '**"combiners"** link sections of track together to make a bigger piece of track.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**“组合器”** 将轨道段连接在一起，以形成更大的轨道。'
- en: These functions form what can be loosely called a *combinator library*, that
    is, a group of functions that are designed to work with a type (here represented
    by railway track), with the design goal that bigger pieces can be built by adapting
    and combining smaller pieces.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数构成了一个可以粗略称为*组合器库*的东西，即一组旨在与类型（这里以铁路轨道表示）一起工作的函数，其设计目标是通过调整和组合较小的部分来构建更大的部分。
- en: Functions like `bind`, `map`, `plus`, etc., crop up in all sorts of functional
    programming scenarios, and so you can think of them as functional patterns --
    similar to, but not the same as, the OO patterns such as "visitor", "singleton",
    "facade", etc.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`、`map`、`plus`等函数在各种函数式编程场景中都会出现，因此您可以将它们视为函数模式 -- 与面向对象的模式（如“visitor”、“singleton”、“facade”等）类似，但不同。'
- en: 'Here they all are together:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它们全部在一起的样子：
- en: '| Concept | Description |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 概念 | 描述 |'
- en: '| `succeed` | A constructor that takes a one-track value and creates a two-track
    value on the Success branch. In other contexts, this might also be called `return`
    or `pure`. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `succeed` | 一个构造函数，将一个单轨道值转换为成功分支上的双轨道值。在其他上下文中，这也可能被称为`return`或`pure`。 |'
- en: '| `fail` | A constructor that takes a one-track value and creates a two-track
    value on the Failure branch. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `fail` | 一个构造函数，将一个单轨道值转换为失败分支上的双轨道值。 |'
- en: '| `bind` | An adapter that takes a switch function and creates a new function
    that accepts two-track values as input. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `bind` | 一个适配器，接受开关函数并创建一个接受双轨道值作为输入的新函数。 |'
- en: '| `>>=` | An infix version of bind for piping two-track values into switch
    functions. |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `>>=` | bind 的中缀版本，将双轨道值传输到开关函数中。 |'
- en: '| `>>` | Normal composition. A combiner that takes two normal functions and
    creates a new function by connecting them in series. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `>>` | 正常的组合。一个组合器，接受两个普通函数，并通过连接它们串联起来创建一个新函数。 |'
- en: '| `>=>` | Switch composition. A combiner that takes two switch functions and
    creates a new switch function by connecting them in series. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `>=>` | 开关组合。一个组合器，它接受两个开关函数，并通过连接它们串联起来创建一个新的开关函数。 |'
- en: '| `switch` | An adapter that takes a normal one-track function and turns it
    into a switch function. (Also known as a "lift" in some contexts.) |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `switch` | 一个适配器，将普通的单轨道函数转换为开关函数。（在某些情况下也称为“提升”） |'
- en: '| `map` | An adapter that takes a normal one-track function and turns it into
    a two-track function. (Also known as a "lift" in some contexts.) |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `map` | 一个适配器，将普通的单轨道函数转换为双轨道函数。（在某些情况下也称为“提升”） |'
- en: '| `tee` | An adapter that takes a dead-end function and turns it into a one-track
    function that can be used in a data flow. (Also known as `tap`.) |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `tee` | 一个适配器，将一个死胡同函数转换为可以在数据流中使用的单轨道函数。（也称为`tap`。） |'
- en: '| `tryCatch` | An adapter that takes a normal one-track function and turns
    it into a switch function, but also catches exceptions. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `tryCatch` | 一个适配器，将普通的单轨道函数转换为开关函数，但也捕获异常。 |'
- en: '| `doubleMap` | An adapter that takes two one-track functions and turns them
    into a single two-track function. (Also known as `bimap`.) |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `doubleMap` | 一个适配器，将两个单轨道函数转换为单个双轨道函数。（也称为`bimap`。） |'
- en: '| `plus` | A combiner that takes two switch functions and creates a new switch
    function by joining them in "parallel" and "adding" the results. (Also known as
    `++` and `in other contexts.)` |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `plus` | 一个组合器，接受两个开关函数，并通过“并行”连接它们并“添加”结果来创建一个新的开关函数。（在其他上下文中也称为`++`。） |'
- en: '| `&&&` | The "plus" combiner tweaked specifically for the validation functions,
    modelled on a binary AND. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `&&&` | 专门为验证函数调整的“加法”组合器，模拟二进制AND。 |'
- en: 'The railway track functions: complete code'
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 铁路轨道函数：完整代码
- en: Here is the complete code for all the functions in one place.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是所有函数的完整代码。
- en: 'I have made some minor tweaks from the original code presented above:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我对上面呈现的原始代码进行了一些微小的调整：
- en: Most functions are now defined in terms of a core function called `either`.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数函数现在都是根据一个称为`either`的核心函数定义的。
- en: '`tryCatch` has been given an extra parameter for the exception handler.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tryCatch`已经为异常处理程序添加了一个额外的参数。'
- en: '[PRE44]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Types vs. shapes
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型 vs. 形状
- en: So far, we have focused entirely on the shape of the track, not the cargo on
    the trains.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们完全专注于轨道的形状，而不是列车上的货物。
- en: This is a magical railway, where the goods being carried can change as they
    go along each length of track.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个神奇的铁路，随着每段轨道的前进，携带的货物会发生变化。
- en: For example, a cargo of pineapples will magically transform into apples when
    it goes through the tunnel called `function1`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一车菠萝经过名为`function1`的隧道时会神奇地变成苹果。
- en: '![pineapples to apples](Recipe_Railway_Cargo1.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![菠萝变苹果](Recipe_Railway_Cargo1.png)'
- en: And a cargo of apples will transform into bananas when it goes through the tunnel
    called `function2`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当经过名为`function2`的隧道时，一车苹果将变成香蕉。
- en: '![apples to bananas](Recipe_Railway_Cargo2.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![苹果变香蕉](Recipe_Railway_Cargo2.png)'
- en: This magical railway has an important rule, namely that you can only connect
    tracks which carry the same type of cargo. In this case we *can* connect `function1`
    to `function2` because the cargo coming out of `function1` (apples) is the same
    as the cargo going into `function2` (also apples).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这条神奇的铁路有一个重要规则，即只能连接携带相同类型货物的轨道。在这种情况下，我们*可以*将`function1`连接到`function2`，因为从`function1`出来的货物（苹果）与进入`function2`的货物（同样是苹果）相同。
- en: '![connecting functions](Recipe_Railway_Cargo3.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![连接函数](Recipe_Railway_Cargo3.png)'
- en: Of course, it is not always true that the tracks carry the same cargo, and a
    mismatch in the kind of cargo will cause an error.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并不总是轨道携带相同的货物，货物种类不匹配会导致错误。
- en: But you'll notice that in this discussion so far, we haven't mentioned the cargo
    once! Instead, we have spent all our time talking about one-track vs. two track
    functions.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 但你会注意到，到目前为止我们讨论中一次也没有提到货物！相反，我们花了所有时间讨论单轨道与双轨道函数。
- en: Of course, it goes without saying that the cargo must match up. But I hope you
    can see that it is the *shape* of the track that is really the important thing,
    not the cargo that is carried.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，不言而喻，货物必须匹配。但我希望你能看到，真正重要的是轨道的*形状*，而不是携带的货物。
- en: Generic types are powerful
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用类型是强大的
- en: Why have we not worried about the type of cargo? Because all the "adapter" and
    "combiner" functions are completely generic! The `bind` and `map` and `switch`
    and `plus` functions do not care about the type of the cargo, only the *shape*
    of the track.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不担心货物的类型？因为所有的“适配器”和“组合器”函数都是完全通用的！`bind`、`map`、`switch`和`plus`函数不关心货物的类型，只关心轨道的*形状*。
- en: 'Having extremely generic functions is a benefit in two ways. The first way
    is obvious: the more generic a function is, the more reusable it is. The implementation
    of `bind` will work with any types (as long as the shape is right).'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有极其通用的函数有两方面的好处。第一种方式很明显：函数越通用，可重用性就越高。`bind`的实现将适用于任何类型（只要形状正确）。
- en: But there is another, more subtle aspect of generic functions that is worth
    pointing out. Because we generally know *nothing* about the types involved, we
    are very constrained in what we can and can't do. As a result, we can't introduce
    bugs!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有另一个更微妙的通用函数方面值得指出。因为我们通常对涉及的类型一无所知，所以我们在能做和不能做的事情上受到很大限制。因此，我们无法引入错误！
- en: 'To see what I mean, let''s look at the signature for `map`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解我的意思，让我们看一下`map`的签名：
- en: '[PRE45]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It takes a function parameter `'a -> 'b` and a value `Result<'a,'c>` and returns
    a value `Result<'b,'c>`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个函数参数`'a -> 'b`和一个值`Result<'a,'c>`，并返回一个值`Result<'b,'c>`。
- en: 'We don''t know anything about the types `''a`, `''b`, and `''c`. The only things
    we know are that:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`'a`、`'b`和`'c`类型一无所知。我们唯一知道的是：
- en: The *same* type `'a` shows up in both the function parameter and the `Success`
    case of the first `Result`.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*相同*类型`''a`同时出现在函数参数和第一个`Result`的`Success`情况中。'
- en: The *same* type `'b` shows up in both the function parameter and the `Success`
    case of the second `Result`.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*相同*类型`''b`同时出现在函数参数和第二个`Result`的`Success`情况中。'
- en: The *same* type `'c` shows up in the `Failure` cases of both the first and second
    `Result`s, but doesn't show up in the function parameter at all.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*相同*类型`''c`同时出现在第一个和第二个`Result`的`Failure`情况中，但在函数参数中根本没有出现。'
- en: What can we deduce from this?
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从中推断出什么？
- en: The return value has a type `'b` in it. But where does it come from? We don't
    know what type `'b` is, so we don't know how to make one. But the function parameter
    knows how to make one! Give it an `'a` and it will make a `'b` for us.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值中包含一个`'b`类型。但它是从哪里来的？我们不知道`'b`是什么类型，所以我们不知道如何创建一个。但函数参数知道如何创建一个！给它一个`'a`，它就会为我们创建一个`'b`。
- en: But where can we get an `'a` from? We don't know what type `'a` is either, so
    again we don't know how to make one. But the first result parameter has an `'a`
    we can use, so you can see that we are *forced* to get the `Success` value from
    the `Result<'a,'c>` parameter and pass it to the function parameter. And then
    the `Success` case of the `Result<'b,'c>` return value *must* be constructed from
    the result of the function.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们从哪里可以得到一个`'a`？我们也不知道`'a`是什么类型，所以我们也不知道如何创建一个。但第一个结果参数有一个`'a`我们可以使用，所以你可以看到我们*被迫*从`Result<'a,'c>`参数的`Success`值中获取，并将其传递给函数参数。然后`Result<'b,'c>`返回值的`Success`情况*必须*从函数的结果构造。
- en: Finally, the same logic applies to `'c`. We are forced to get the `Failure`
    value from the `Result<'a,'c>` input parameter and use it to construct the `Failure`
    case of the `Result<'a,'c>` return value.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，同样的逻辑适用于`'c`。我们被迫从`Result<'a,'c>`输入参数中获取`Failure`值，并将其用于构造`Result<'a,'c>`返回值的`Failure`情况。
- en: In other words, there is basically *only one way to implement the `map` function*!
    The type signature is so generic that we have no choice.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*只有一种实现`map`函数的方式*！类型签名是如此通用，我们别无选择。
- en: 'On the other hand, imagine that the `map` function had been very specific about
    the types it needed, like this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，想象一下，如果`map`函数对所需的类型非常具体，像这样：
- en: '[PRE46]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In this case, we can come up a huge number of different implementations. To
    list a few:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以想出大量不同的实现。列举几种：
- en: We could have swapped the success and failure tracks.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们本可以交换成功和失败轨迹。
- en: We could have added a random number to the success track.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们本可以在成功轨迹上添加一个随机数。
- en: We could have ignored the function parameter altogether, and returned zero on
    both the success and failure tracks.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们本可以完全忽略函数参数，并在成功和失败轨迹上都返回零。
- en: All of these implementations are "buggy" in the sense that they don't do what
    we expect. But they are all only possible because we know in advance that the
    type is `int`, and therefore we can manipulate the values in ways we are not supposed
    to. The less we know about the types, the less likely we are to make a mistake.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些实现都是“有缺陷”的，因为它们不符合我们的期望。但它们之所以可能，是因为我们事先知道类型是`int`，因此我们可以以不应该的方式操纵值。我们对类型了解得越少，犯错的可能性就越小。
- en: The failure type
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 失败类型
- en: In most of our functions, the transformation only applies to the success track.
    The failure track is left alone (`map`), or merged with an incoming failure (`bind`).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数函数中，转换仅适用于成功轨迹。失败轨迹保持不变（`map`），或与传入的失败合并（`bind`）。
- en: This implies that the failure track must be *same type* all the way through.
    In this post we have just used `string`, but in the next post we'll change the
    failure type to be something more useful.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着失败轨迹必须始终是*相同类型*。在本文中，我们只使用了`string`，但在下一篇文章中，我们将把失败类型更改为更有用的内容。
- en: Summary and guidelines
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结和指导方针
- en: At the beginning of this series, I promised to give you a simple recipe that
    you could follow.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本系列的开始，我承诺给你一个简单的配方，你可以遵循。
- en: But you might be feeling a bit overwhelmed now. Instead of making things simpler,
    I seem to have made things more complicated. I have shown you lots of different
    ways of doing the same thing! Bind vs. compose. Map vs. switch. Which approach
    should you use? Which way is best?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在您可能感到有点不知所措。我似乎并没有让事情变得简单，反而使事情变得更加复杂。我向您展示了许多完成同一件事的不同方式！Bind与compose。Map与switch。您应该使用哪种方法？哪种方式最好？
- en: Of course, there is never one "right way" for all scenarios, but nevertheless,
    as promised, here are some guidelines that can be used as the basis of a reliable
    and repeatable recipe.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并不存在适用于所有情景的“正确方式”，但是正如承诺的那样，这里有一些可作为可靠和可重复配方基础的准则。
- en: '*Guidelines*'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '*准则*'
- en: Use double-track railway as your underlying model for dataflow situations.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将双轨铁路作为数据流场景的基础模型。
- en: Create a function for each step in the use case. The function for each step
    can in turn be built from smaller functions (e.g. the validation functions).
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用例中的每个步骤创建一个函数。每个步骤的函数可以依次由较小的函数构建（例如，验证函数）。
- en: Use standard composition (`>>`) to connect the functions.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准组合（`>>`）连接这些函数。
- en: If you need to insert a switch into the flow, use `bind`.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要在流程中插入一个开关，请使用`bind`。
- en: If you need to insert a single-track function into the flow, use `map`.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要在流程中插入一个单轨函数，请使用`map`。
- en: If you need to insert other types of functions into the flow, create an appropriate
    adapter block and use it.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要在流程中插入其他类型的函数，请创建一个适当的适配器块并使用它。
- en: These guidelines may result in code that is not particularly concise or elegant,
    but on the other hand, you will be using a consistent model, and it should be
    understandable to other people when it needs to be maintained.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这些准则可能导致代码不够简洁或优雅，但另一方面，您将使用一致的模型，当需要维护时应该能够让其他人理解。
- en: So with these guidelines, here are the main bits of the implementation so far.
    Note especially the use of `>>` everywhere in the final `usecase` function.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据这些准则，目前的实现主要内容如下。特别注意最终的`usecase`函数中到处都使用了`>>`。
- en: '[PRE47]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'One final suggestion. If you are working with a team of non-experts, unfamiliar
    operator symbols will put people off. So here some extra guidelines with respect
    to operators:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个建议。如果您正在与非专家团队合作，不熟悉的操作符号会让人望而却步。因此，这里有一些额外的操作符号准则：
- en: Don't use any "strange" operators other than `>>` and `|>`.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了`>>`和`|>`之外，请不要使用任何“奇怪”的操作符。
- en: In particular, that means you should *not* use operators like `>>=` or `>=>`
    unless everyone is aware of them.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别是这意味着除非所有人都知道它们，否则不应该使用像`>>=`或`>=>`这样的操作符。
- en: An exception can be made if you define the operator at the top of the module
    or function where it is used. For example, the `&&&` operator could be defined
    at the top of the validation module and then used later in that same module.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在使用的模块或函数顶部定义了操作符，则可以例外。例如，`&&&`操作符可以在验证模块的顶部定义，然后在该模块的后续部分中使用。
- en: Further reading
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: If you like this "railway oriented" approach, you can also [see it applied to
    FizzBuzz](railway-oriented-programming-carbonated.html).
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您喜欢这种“铁路导向”方法，您还可以[看到它应用于FizzBuzz](railway-oriented-programming-carbonated.html)。
- en: I also have some [slides and video](http://fsharpforfunandprofit.com/rop/) that
    show how take this approach further. (At some point I will turn these into a proper
    blog post)
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我还有一些[幻灯片和视频](http://fsharpforfunandprofit.com/rop/)展示了如何进一步应用这种方法。（我将把这些内容转化为一篇正式的博文）
- en: I presented on this topic at NDC Oslo 2014 (click image to view video)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾在2014年的NDC Oslo上就这个主题做过演讲（点击图片查看视频）
- en: '[![Video from NDC Oslo 2014](../assets/img/rop-ndcoslo.jpg)](http://vimeo.com/97344498)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '[![NDC Oslo 2014的视频](../assets/img/rop-ndcoslo.jpg)](http://vimeo.com/97344498)'
- en: 'And here are the slides I used:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我使用的幻灯片：
- en: '[//www.slideshare.net/slideshow/embed_code/32242318](//www.slideshare.net/slideshow/embed_code/32242318)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[//www.slideshare.net/slideshow/embed_code/32242318](//www.slideshare.net/slideshow/embed_code/32242318)'
- en: '**[Railway Oriented Programming](https://www.slideshare.net/ScottWlaschin/railway-oriented-programming
    "Railway Oriented Programming")** from **[my slideshare page](http://www.slideshare.net/ScottWlaschin)**'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**[铁路导向编程](https://www.slideshare.net/ScottWlaschin/railway-oriented-programming
    "铁路导向编程")** 来自 **[我的slideshare页面](http://www.slideshare.net/ScottWlaschin)** '
- en: 'Railway oriented programming: Carbonated edition'
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 铁路导向编程：碳酸版
- en: 'Railway oriented programming: Carbonated edition'
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 铁路导向编程：碳酸版
- en: As a follow up to the [Railway Oriented Programming](recipe-part2.html) post,
    I thought I'd apply the same technique to the [FizzBuzz](http://imranontech.com/2007/01/24/using-fizzbuzz-to-find-developers-who-grok-coding/)
    problem, and compare it with other implementations.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对[Railway Oriented Programming](recipe-part2.html) 文章的后续，我想将相同的技术应用到[FizzBuzz](http://imranontech.com/2007/01/24/using-fizzbuzz-to-find-developers-who-grok-coding/)问题中，并将其与其他实现进行比较。
- en: A large part of this post was directly ~~stolen from~~ inspired by [Dave Fayram's
    post on FizzBuzz](http://dave.fayr.am/posts/2012-10-4-finding-fizzbuzz.html),
    with some additional ideas from [raganwald](http://weblog.raganwald.com/2007/01/dont-overthink-fizzbuzz.html).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇文章的很大一部分直接~~抄袭自~~受到了 [戴夫·法伦（Dave Fayram）关于 FizzBuzz 的文章](http://dave.fayr.am/posts/2012-10-4-finding-fizzbuzz.html)
    的启发，还有一些额外的想法来自 [raganwald](http://weblog.raganwald.com/2007/01/dont-overthink-fizzbuzz.html)。
- en: 'FizzBuzz: The imperative version'
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FizzBuzz：命令式版本
- en: 'As a reminder, here are the requirements for the FizzBuzz problem:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，这里是 FizzBuzz 问题的要求：
- en: '[PRE48]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And here is a basic F# solution:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个基本的 F# 解决方案：
- en: '[PRE49]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: I have defined a function `fizzBuzz` that, given an integer `i`, uses `match`
    with `when` clauses to do the various tests, and then prints the appropriate value.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一个函数 `fizzBuzz`，给定一个整数 `i`，使用 `match` 和 `when` 子句来执行各种测试，然后打印出适当的值。
- en: Simple and straightforward, and fine for a quick hack, but there are a number
    of problems with this implementation.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 简单直接，对于快速的 hack 来说还可以，但是这种实现存在一些问题。
- en: First, note that we had to have a special case for "fifteen". We couldn't just
    reuse the code from the "three" and "five" cases. And this means that if we want
    to add another case, such as "seven", we also need to add special cases for all
    the combinations as well (that is "21", "35" and "105"). And of course, adding
    more numbers would lead to a combinatorial explosion of cases.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意我们必须对“十五”有一个特殊情况。我们不能简单地重用“三”和“五”情况的代码。这意味着如果我们想添加另一个情况，比如“七”，我们还需要添加所有组合的特殊情况（即“21”、“35”和“105”）。当然，添加更多数字会导致情况的组合爆炸。
- en: Second, the order of matching is important. If the "fifteen" case had come last
    in the list of patterns, the code would have run correctly, but not actually met
    the requirements. And again, if we need to add new cases, we must always remember
    to put the largest ones first to ensure correctness. This is just the kind of
    thing that causes subtle bugs.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，匹配的顺序很重要。如果“十五”的情况出现在模式列表的最后，代码会正确运行，但实际上不符合要求。再次强调，如果我们需要添加新的情况，我们必须始终记住将最大的情况放在首位，以确保正确性。这就是导致难以察觉的
    bug 的原因。
- en: 'Let''s try another implementation, where we reuse the code for the "three"
    and "five" case, and eliminate the need for a "fifteen" case altogether:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一个实现，其中我们重用了“三”和“五”情况的代码，并完全消除了“十五”情况的需要：
- en: '[PRE50]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this implementation, the printed value for "15" will be correct, because
    both the "3" and "5" cases will be used. And also we don't have to worry about
    order -- as much, anyway.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，“15”的打印值将是正确的，因为“3”和“5”的情况都将被使用。而且我们不必担心顺序 -- 至少在某种程度上是这样的。
- en: But -- these branches are no longer independent, so we have to track whether
    *any* branch has been used at all, so that we can handle the default case. And
    that has led to the mutable variable. Mutables are a code smell in F#, so this
    implementation is not ideal.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 -- 这些分支不再是独立的，所以我们必须跟踪是否*任何*分支已被使用，以便我们可以处理默认情况。这导致了可变变量。在 F# 中，可变变量是一种代码异味，所以这个实现并不理想。
- en: However, this version *does* have the advantage that it can be easily refactored
    to support multiple factors, not just 3 and 5\.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个版本*确实*有一个优点，就是它可以轻松重构以支持多个因子，而不仅仅是 3 和 5。
- en: Below is a version that does just this. We pass in a list of "rules" to `fizzBuzz`.
    Each rule consists of a factor and a corresponding label to print out. The `fizzBuzz`
    function then just iterates through these rules, processing each in turn.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个这样做的版本。我们将一个“规则”列表传递给 `fizzBuzz`。每个规则都包括一个因子和一个相应的要打印出的标签。然后 `fizzBuzz`
    函数只是依次处理这些规则。
- en: '[PRE51]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we want additional numbers to be processed, we just add them to the list
    of rules, like this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要处理更多的数字，我们只需要将它们添加到规则列表中，就像这样：
- en: '[PRE52]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: To sum up, we have created a very imperative implementation that would be almost
    the same in C#. It's flexible, but the mutable variable is a bit of a code smell.
    Is there another way?
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们创建了一个非常命令式的实现，几乎与 C# 中的相同。它很灵活，但可变变量有点像代码异味。还有其他方法吗？
- en: 'FizzBuzz: The pipeline version'
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FizzBuzz：管道版本
- en: In this next version, we'll look at using the "pipeline" model, where data is
    fed through a series of functions to arrive at a final result.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个版本中，我们将使用“pipeline”模型，其中数据通过一系列函数传递以得到最终结果。
- en: In this design, I envision a pipeline of functions, one to handle the "three"
    case, one to handle the "five" case, and so on. And at the end, the appropriate
    label is spat out, ready to be printed.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，我设想了一系列函数的流水线，一个用来处理“three”情况，一个用来处理“five”情况，依此类推。最后，适当的标签被吐出来，准备打印。
- en: 'Here is some pseudocode to demonstrate the concept:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些伪代码，以演示该概念：
- en: '[PRE53]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As an additional requirement, we want the pipeline to have *no* side effects.
    This means that the intermediate functions must *not* print anything. They must
    instead pass any generated labels down the pipe to the end, and only at that point
    print the results.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的要求，我们希望管道*没有*副作用。这意味着中间函数不能打印任何内容。它们必须将任何生成的标签传递到管道的末端，只有在那一点上才打印结果。
- en: Designing the pipeline
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计流水线
- en: As a first step, we need to define what data will be fed down the pipe.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们需要定义将通过管道传送的数据。
- en: Let's start with the first function, called `handleThreeCase` in the pseudocode
    above. What is its input, and what is its output?
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上面伪代码中称为`handleThreeCase`的第一个函数开始。它的输入是什么，输出是什么？
- en: Obviously, the input is the integer being processed. But the output could be
    the string "Fizz" if we're lucky. Or the original integer if we're not.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，输入是正在处理的整数。但如果我们幸运的话，输出可能是字符串“Fizz”。或者如果我们不幸的话，原始整数。
- en: So now let's think about the input to the second function, `handleFiveCase`.
    It needs the integer as well. But in the case of "15" it *also* needs the string
    "Fizz" as well, so it can append "Buzz" to it.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑第二个函数`handleFiveCase`的输入。它也需要整数。但在“15”的情况下，它还需要字符串“Fizz”，这样它就可以将“Buzz”附加到它上面。
- en: Finally, the `handleAllOtherCases` function converts the int to a string, but
    *only* if "Fizz" or "Buzz" have not been generated yet.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`handleAllOtherCases`函数将整数转换为字符串，但*仅当*尚未生成“Fizz”或“Buzz”时。
- en: It's quite obvious then, that the data structure needs to contain both the integer
    being processed *and* the "label so far".
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 那么现在显然，数据结构需要包含正在处理的整数*和*“迄今为止的标签”。
- en: 'The next question is: how do we know if an upstream function has created a
    label? The `handleAllOtherCases` needs to know this in order to determine whether
    it needs to do anything.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是：我们如何知道上游函数是否创建了一个标签？`handleAllOtherCases`需要知道这一点，以确定是否需要执行任何操作。
- en: One way would be to use an empty string (or, horrors, a null string), but let's
    be good and use a `string option`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用空字符串（或者，可怕的是，空字符串），但我们要做得好一点，使用`string option`。
- en: 'So, here''s the final data type that we will be using:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们将使用的最终数据类型：
- en: '[PRE54]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Pipeline version 1
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管道版本1
- en: With this data structure, we can define how `handleThreeCase` and `handleFiveCase`
    will work.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个数据结构，我们可以定义`handleThreeCase`和`handleFiveCase`将如何工作。
- en: First, test the input int `i` to see if it is divisible by the factor.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，测试输入的整数`i`是否可被因子整除。
- en: If it is divisible, look at the `label` -- if it is `None`, then replace it
    with `Some "Fizz"` or `Some "Buzz"`.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它可被整除，查看`label`--如果它是`None`，则用`Some "Fizz"`或`Some "Buzz"`替换它。
- en: If the label already has a value, then append "Buzz" (or whatever) to it.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果标签已经有值，则附加“Buzz”（或其他内容）到它。
- en: If the input is not divisible by the factor, just pass on the data unchanged.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入不能被因子整除，则原样传递数据。
- en: 'Given this design, here''s the implementation. It''s a generic function that
    I will call `carbonate` (after [raganwald](http://weblog.raganwald.com/2007/01/dont-overthink-fizzbuzz.html))
    because it works with both "Fizz" and "Buzz":'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这一设计，以下是实现。这是一个通用函数，我将其称为`carbonate`（来自[raganwald](http://weblog.raganwald.com/2007/01/dont-overthink-fizzbuzz.html)），因为它既适用于“Fizz”又适用于“Buzz”：
- en: '[PRE55]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The design for the `handleAllOtherCases` function is slightly different:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleAllOtherCases`函数的设计略有不同：'
- en: Look at the label -- if it is not `None`, then a previous function has created
    a label, so do nothing.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看标签--如果不是`None`，那么先前的函数已经创建了一个标签，因此什么也不做。
- en: But if the label is `None`, replace it with the string representation of the
    integer.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但如果标签是`None`，则用整数的字符串表示替换它。
- en: 'Here''s the code -- I will call it `labelOrDefault`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码--我将其称为`labelOrDefault`：
- en: '[PRE56]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now that we have the components, we can assemble the pipeline:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了组件，我们可以组装流水线了：
- en: '[PRE57]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that we have to create an initial record using `{i=i; label=None}` for
    passing into the first function (`carbonate 3 "Fizz"`).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须使用`{i=i; label=None}`创建一个初始记录，以便传递给第一个函数(`carbonate 3 "Fizz"`)。
- en: 'Finally, here is all the code put together:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是所有代码放在一起：
- en: '[PRE58]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Pipeline version 2
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管道版本2
- en: Creating a new record type can be useful as a form of documentation, but in
    a case like this, it would probably be more idiomatic to just use a tuple rather
    than creating a special data structure.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的记录类型可能会作为一种文档形式很有用，但在这种情况下，与其创建一个特殊的数据结构，不如只使用一个元组更符合惯例。
- en: So here's a modified implementation that uses tuples.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是一个使用元组的修改实现。
- en: '[PRE59]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As an exercise, try to find all the code that had to be changed.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试找出所有必须更改的代码。
- en: Eliminating explicit tests for Some and None
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消除对Some和None的显式测试
- en: In the tuple code above, I have also replaced the explicit Option matching code
    `match .. Some .. None` with some built-in Option functions, `map` and `defaultArg`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的元组代码中，我还用一些内置的Option函数`map`和`defaultArg`替换了显式的Option匹配代码`match .. Some ..
    None`。
- en: 'Here are the changes in `carbonate` :'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`carbonate`中的更改：
- en: '[PRE60]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'and in `labelOrDefault`:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在`labelOrDefault`中：
- en: '[PRE61]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You might be wondering about the strange looking `|> defaultArg <|` idiom.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对奇怪的`|> defaultArg <|`习语感到疑惑。
- en: I am using it because the option is the *first* parameter to `defaultArg`, not
    the *second*, so a normal partial application won't work. But "bi-directional"
    piping does work, hence the strange looking code.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用它，因为选项是`defaultArg`的*第一个*参数，而不是*第二*个参数，因此正常的部分应用不起作用。但是“双向”管道确实有效，因此代码看起来很奇怪。
- en: 'Here''s what I mean:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的意思：
- en: '[PRE62]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Pipeline version 3
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管道版本3
- en: Our `carbonate` function is generic for any factor, so we can easily extend
    the code to support "rules" just as in the earlier imperative version.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`carbonate`函数对于任何因子都是通用的，因此我们可以轻松地扩展代码以支持像之前的命令式版本中那样的“规则”。
- en: 'But one issue seems to be that we have hard-coded the "3" and "5" cases into
    the pipeline, like this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 但一个问题似乎是我们已经将“3”和“5”案例硬编码到管道中，就像这样：
- en: '[PRE63]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How can we dynamically add new functions into the pipeline?
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何动态地将新函数添加到管道中？
- en: The answer is quite simple. We dynamically create a function for each rule,
    and then combine all these functions into one using composition.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 答案非常简单。我们为每个规则动态创建一个函数，然后使用组合将所有这些函数合并为一个。
- en: 'Here''s a snippet to demonstrate:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个片段来演示：
- en: '[PRE64]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Each rule is mapped into a function. And then the list of functions is combined
    into one single function using `>>`.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 每个规则都映射到一个函数。然后使用`>>`将函数列表组合成一个单一函数。
- en: 'Putting it all together, we have this final implementation:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容放在一起，我们有这个最终实现：
- en: '[PRE65]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Comparing this "pipeline" version with the previous imperative version, the
    design is much more functional. There are no mutables and there are no side-effects
    anywhere (except in the final `printf` statement).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个“管道”版本与之前的命令式版本进行比较，设计更加功能性。没有可变的东西，也没有任何副作用（除了最后的`printf`语句）。
- en: There is a subtle bug in the use of `List.reduce`, however. Can you see what
    it is?** For a discussion of the problem and the fix, see the postscript at the
    bottom of this page.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用`List.reduce`时存在一个微妙的错误。你能看出是什么吗？**有关问题和修复的讨论，请参见本页底部的附录。
- en: '[** Hint: try an empty list of rules.]'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[**提示：尝试一个空的规则列表。]'
- en: 'FizzBuzz: The railway oriented version'
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FizzBuzz：面向铁路的版本
- en: The pipeline version is a perfectly adequate functional implementation of FizzBuzz,
    but for fun, let's see if we can use the "two-track" design described in the [railway
    oriented programming](recipe-part2.html) post.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 管道版本是FizzBuzz的一个完全足够的功能实现，但是为了好玩，让我们看看是否可以使用[面向铁路编程](recipe-part2.html)帖子中描述的“双轨道”设计。
- en: 'As a quick reminder, in "railway oriented programming" (a.k.a the "Either"
    monad), we define a union type with two cases: "Success" and "Failure", each representing
    a different "track". We then connect a set of "two-track" functions together to
    make the railway.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速提醒，在“铁路导向编程”（又称“Either”单子）中，我们定义一个具有两种情况的联合类型：“成功”和“失败”，每种情况代表不同的“轨道”。然后，我们将一组“双轨道”函数连接在一起，以构建铁路。
- en: Most of the functions we actually use are what I called "switch" or "points"
    functions, with a *one* track input, but a two-track output, one for the Success
    case, and one for the Failure case. These switch functions are converted into
    two-track functions using a glue function called "bind".
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际使用的大多数函数都是我称之为“开关”或“点”函数，其输入为 *一个* 轨道，但输出为两个轨道，一个用于成功案例，另一个用于失败案例。这些开关函数通过一个称为“绑定”的粘合函数转换为双轨道函数。
- en: Here is a module containing definitions of the functions we will need.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是包含我们将需要的函数定义的模块。
- en: '[PRE66]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'I am using the `Choice` type here, which is built into the F# core library.
    But I have created some helpers to make it look like the Success/Failure type:
    an active pattern and two constructors.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用的 `Choice` 类型是内置于 F# 核心库中的。但我创建了一些帮助程序，使其看起来像 Success/Failure 类型：一个活动模式和两个构造函数。
- en: Now, how will we adapt FizzBuzz to this?
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将如何调整 FizzBuzz？
- en: 'Let''s start by doing the obvious thing: defining "carbonation" as success,
    and an unmatched integer as a failure.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先做一个明显的事情：将“碳酸化”定义为成功，而不匹配的整数定义为失败。
- en: In other words, the Success track contains the labels, and the Failure track
    contains the ints.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，成功轨道包含标签，而失败轨道包含整数。
- en: 'Our `carbonate` "switch" function will therefore look like this:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的 `carbonate` “开关”函数将如下所示：
- en: '[PRE67]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This implementation is similar to the one used in the pipeline design discussed
    above, but it is cleaner because the input is just an int, not a record or a tuple.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现与上面讨论过的管道设计中使用的实现类似，但更清洁，因为输入只是一个整数，而不是记录或元组。
- en: 'Next, we need to connect the components together. The logic will be:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要连接这些组件。逻辑将是：
- en: if the int is already carbonated, ignore it
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果整数已经被碳酸化，请忽略它
- en: if the int is not carbonated, connect it to the input of the next switch function
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果整数没有碳酸化，请将其连接到下一个开关函数的输入
- en: 'Here is the implementation:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现：
- en: '[PRE68]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Another way of writing this is to use the `either` function we defined in the
    library module:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种编写这个函数的方法是使用我们在库模块中定义的 `either` 函数：
- en: '[PRE69]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Make sure you understand that both of these implementations do exactly the same
    thing!
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您理解这两种实现完全相同！
- en: 'Next, we can create our "two-track" pipeline, like this:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建我们的“双轨道”管道，就像这样：
- en: '[PRE70]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is superficially similar to the "one-track" pipeline, but actually uses
    a different technique. The switches are connected together through composition
    (`>>`) rather than piping (`|>`).
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这在表面上与“单轨道”管道类似，但实际上使用了不同的技术。这些开关通过组合（`>>`）而不是管道（`|>`）连接在一起。
- en: As a result, the `fizzBuzz` function does not have an int parameter -- we are
    defining a function by combining other functions. There is no data anywhere.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`fizzBuzz` 函数没有 int 参数——我们正在通过组合其他函数来定义函数。数据不存在。
- en: 'A few other things have changed as well:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他的变化：
- en: We have had to reintroduce the explicit test for the "15" case. This is because
    we have only two tracks (success or failure). There is no "half-finished track"
    that allows the "5" case to add to the output of the "3" case.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不得不重新引入“15”情况的显式测试。这是因为我们只有两个轨道（成功或失败）。没有“半完成的轨道”允许“5”情况添加到“3”情况的输出中。
- en: The `labelOrDefault` function from the previous example has been replaced with
    `either`. In the Success case, a string is printed. In the Failure case, an int
    is printed.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一个示例中的 `labelOrDefault` 函数已被替换为 `either`。在成功案例中，打印字符串。在失败案例中，打印整数。
- en: 'Here is the complete implementation:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的实现：
- en: '[PRE71]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Carbonation as failure?
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 碳酸化作为失败？
- en: We defined carbonation as "success"in the example above -- it seems the natural
    thing to do, surely. But if you recall, in the railway oriented programming model,
    "success" means that data should be passed on to the next function, while "failure"
    means to bypass all the intermediate functions and go straight to the end.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上面的示例中将碳酸化定义为“成功”——这似乎是自然而然的事情。但是如果你回想起来，在铁路导向的编程模型中，“成功”意味着数据应该传递给下一个函数，而“失败”意味着绕过所有中间函数直接到达末尾。
- en: For FizzBuzz, the "bypass all the intermediate functions" track is the track
    with the carbonated labels, while the "pass on to next function" track is the
    one with integers.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 FizzBuzz，绕过所有中间函数的轨道是带有碳酸标签的轨道，而将数据传递给下一个函数的轨道是带有整数的轨道。
- en: 'So we should really reverse the tracks: "Failure" now means carbonation, while
    "Success" means no carbonation.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们应该真正颠倒轨道：“失败”现在意味着碳酸化，而“成功”意味着没有碳酸化。
- en: By doing this, we also get to reuse the pre-defined `bind` function, rather
    than having to write our own `connect` function.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，我们还可以重用预定义的 `bind` 函数，而不必编写自己的 `connect` 函数。
- en: 'Here''s the code with the tracks switched around:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是轨道切换后的代码：
- en: '[PRE72]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: What are the two tracks anyway?
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两个轨道到底是什么？
- en: The fact that we can swap the tracks so easily implies that that maybe there
    is a weakness in the design. Are we trying to use a design that doesn't fit?
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 能够如此轻松地交换轨道暗示着设计可能存在弱点。我们是不是试图使用不合适的设计？
- en: Why does one track have to be "Success" and another track "Failure" anyway?
    It doesn't seem to make much difference.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么一个轨道必须是 "成功"，另一个轨道必须是 "失败" 呢？似乎并没有太大的区别。
- en: So, why don't we *keep* the two-track idea, but get rid of the "Success" and
    "Failure" labels.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们不 *保留* 两轨道的想法，但摆脱 "成功" 和 "失败" 标签呢。
- en: Instead, we can call one track "Carbonated" and the other "Uncarbonated".
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以将一个轨道称为 "碳酸化"，另一个称为 "非碳酸化"。
- en: To make this work, we can define an active pattern and constructor methods,
    just as we did for "Success/Failure".
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个工作起效，我们可以定义一个活动模式和构造方法，就像我们为 "成功/失败" 所做的那样。
- en: '[PRE73]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: If you are doing domain driven design, it is good practice to write code that
    uses the appropriate [Ubiquitous Language](http://martinfowler.com/bliki/UbiquitousLanguage.html)
    rather than language that is not applicable.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在进行领域驱动设计，最好编写使用适当的 [Ubiquitous Language](http://martinfowler.com/bliki/UbiquitousLanguage.html)
    而不是不适用的语言的代码。
- en: In this case, if FizzBuzz was our domain, then our functions could now use the
    domain-friendly terminology of `carbonated` and `uncarbonated` rather than "success"
    or "failure".
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果 FizzBuzz 是我们的领域，那么我们的函数现在可以使用领域友好的术语 `carbonated` 和 `uncarbonated`
    而不是 "成功" 或 "失败"。
- en: '[PRE74]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Note that, as before, the `connect` function can be rewritten using `either`
    (or we can just use the predefined `bind` as before):'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与以前一样，`connect` 函数可以使用 `either` 重写（或者我们可以像以前一样使用预定义的 `bind`）：
- en: '[PRE75]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Here''s all the code in one module:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个模块中的所有代码：
- en: '[PRE76]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Adding rules
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加规则
- en: 'There are some problems with the version we have so far:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的版本存在一些问题：
- en: The "15" test is ugly. Can we get rid of it and reuse the "3" and "5" cases?
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"15" 测试很丑陋。我们能否摆脱它并重用 "3" 和 "5" 的情况？'
- en: The "3" and "5" cases are hard-coded. Can we make this more dynamic?
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"3" 和 "5" 的情况是硬编码的。我们能否使其更加动态？'
- en: As it happens, we can kill two birds with one stone and address both of these
    issues at once.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 碰巧，我们可以一举两得，同时解决这两个问题。
- en: Instead of combining all the "switch" functions in *series*, we can "add" them
    together in *parallel*. In the [railway oriented programming](recipe-part2.html)
    post, we used this technique for combining validation functions. For FizzBuzz
    we are going to use it for doing all the factors at once.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 与其将所有 "开关" 函数 *串联*在一起，不如在 *并行* 中将它们 "相加" 在一起。在 [铁路导向编程](recipe-part2.html) 文章中，我们使用了这种技术来组合验证函数。对于
    FizzBuzz，我们将用它来一次性处理所有因子。
- en: The trick is to define a "append" or "concat" function for combining two functions.
    Once we can add two functions this way, we can continue and add as many as we
    like.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是为组合两个函数定义一个 "append" 或 "concat" 函数。一旦我们可以这样添加两个函数，我们就可以继续添加任意数量的函数。
- en: So given that we have two carbonation functions, how do we concat them?
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，鉴于我们���两个碳化函数，我们如何将它们连接起来？
- en: 'Well, here are the possible cases:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里是可能的情况：
- en: If they both have carbonated outputs, we concatenate the labels into a new carbonated
    label.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们都有碳酸化输出，我们将标签连接成一个新的碳酸化标签。
- en: If one has a carbonated output and the other doesn't, then we use the carbonated
    one.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个有碳酸化输出，另一个没有，那么我们使用碳酸化的那个。
- en: If neither has a carbonated output, then we use either uncarbonated one (they
    will be the same).
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两者都没有碳酸化输出，那么我们使用任意一个非碳酸化的（它们将是相同的）。
- en: 'Here''s the code:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '[PRE77]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As an aside, notice that this code is almost like math, with `uncarbonated`
    playing the role of "zero", like this:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，注意到这段代码几乎像数学一样，`uncarbonated` 扮演 "零" 的角色，就像这样：
- en: '[PRE78]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This is not a coincidence! We will see this kind of thing pop up over and over
    in functional code. I'll be talking about this in a future post.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是巧合！我们将在函数式代码中一次又一次看到这种情况。我将在未来的文章中谈到这一点。
- en: 'Anyway, with this "concat" function in place, we can rewrite the main `fizzBuzz`
    like this:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，有了这个 "concat" 函数，我们可以像这样重写主 `fizzBuzz`：
- en: '[PRE79]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The two `carbonate` functions are added and then passed to `either` as before.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `carbonate` 函数被添加，然后像以前一样传递给 `either`。
- en: 'Here is the complete code:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的代码：
- en: '[PRE80]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: With this addition logic available, we can easily refactor the code to use rules.
    Just as with the earlier "pipeline" implementation, we can use `reduce` to add
    all the rules together at once.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个附加逻辑，我们可以轻松地重构代码以使用规则。就像之前的“管道”实现一样，我们可以使用`reduce`一次性将所有规则加在一起。
- en: 'Here''s the version with rules:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有规则的版本：
- en: '[PRE81]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Summary
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this post, we''ve seen three different implementations:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们看到了三种不同的实现：
- en: An imperative version that used mutable values and mixed side-effects with logic.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用可变值和混合副作用与逻辑的命令式版本。
- en: A "pipeline" version that passed a data structure through a series of functions.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“管道”版本，通过一系列函数传递数据结构。
- en: A "railway oriented" version that had two separate tracks, and used "addition"
    to combine functions in parallel.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“铁路导向”版本，有两条独立的轨道，并使用“加法”将函数并行组合。
- en: In my opinion, the imperative version is the worst design. Even though it was
    easy to hack out quickly, it has a number of problems that make it brittle and
    error-prone.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，命令式版本是最糟糕的设计。即使很容易快速地编写出来，但它有许多问题，使其脆弱且容易出错。
- en: Of the two functional versions, I think the "railway oriented" version is cleaner,
    for this problem at least.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个函数式版本中，我认为“铁路导向”版本至少对于这个问题更清晰。
- en: By using the `Choice` type rather than a tuple or special record, we made the
    code more elegant thoughout. You can see the difference if you compare the pipeline
    version of `carbonate` with the railway oriented version of `carbonate`.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`Choice`类型而不是元组或特殊记录，我们使代码更加优雅。如果你比较`carbonate`的管道版本和`carbonate`的铁路导向版本，你就能看到区别。
- en: In other situations, of course, the railway oriented approach might not work,
    and the pipeline approach might be better. I hope this post has given some useful
    insight into both.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，当然，铁路导向的方法可能不起作用，管道方法可能更好。希望本文对两者都提供了一些有用的见解。
- en: '*If you''re a FizzBuzz fan, check out the [Functional Reactive Programming](concurrency-reactive.html)
    page, which has yet another variant of the problem.*'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你是FizzBuzz的粉丝，请查看[函数式响应式编程](concurrency-reactive.html)页面，这里有另一种变体的问题。*'
- en: 'Postscript: Be careful when using List.reduce'
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后记：在使用List.reduce时要小心
- en: Be careful with `List.reduce` -- it will fail with empty lists. So if you have
    an empty rule set, the code will throw a `System.ArgumentException`.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`List.reduce`时要小心--如果列表为空，它将失败。因此，如果你有一个空的规则集，代码将抛出`System.ArgumentException`。
- en: 'In the pipeline case, you can see this by adding the following snippet to the
    module:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道情况下，通过将以下代码片段添加到模块中，你可以看到这一点：
- en: '[PRE82]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The fix is to replace `List.reduce` with `List.fold`. `List.fold` requires
    an additional parameter: the initial (or "zero") value. In this case, we can use
    the identity function, `id`, as the initial value.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是用`List.fold`替换`List.reduce`。`List.fold`需要一个额外的参数：初始（或“零”）值。在这种情况下，我们可以使用恒等函数`id`作为初始值。
- en: 'Here is the fixed version of the code:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修复后的代码版本：
- en: '[PRE83]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Similarly, in the railway oriented example, we had:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在铁路导向的例子中，我们有：
- en: '[PRE84]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'which should be corrected to:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 应该更正为：
- en: '[PRE85]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: where `zero` is the "default" function to use if the list is empty.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`zero`是如果列表为空时要使用的“默认”函数。
- en: 'As an exercise, define the zero function for this case. (Hint: we have actually
    already defined it under another name).'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，为这种情况定义零函数。（提示：我们实际上已经用另一个名称定义了它）。
