["```\ntype alias State = (Int, RunState)\ntype RunState    = Paused | Playing Time \n```", "```\ntype Msg         = Start | Stop\ntype Event       = NewTime Time | NewMsg (Time, Msg) \n```", "```\ntype TickOr msg  = Tick | M msg\ntype alias Event = (Time, TickOr Msg) \n```", "```\nmergeWithTicker : Time -> Signal msg -> Signal (Time, TickOr msg)\nmergeWithTicker t sig =\n  let time = every t in\n  Signal.merge\n    ((\\t   -> (t, Tick)) <~ time)\n    ((\\t m -> (t, M m))  <~ Signal.sampleOn sig time ~ sig) \n```", "```\nch : Signal.Channel Msg\nch = Signal.channel Start\n\nmain =\n  view <~ Window.dimensions\n        ~ Signal.foldp upstate (0, Paused)\n            (mergeWithTicker (100 * millisecond) (Signal.subscribe ch)) \n```", "```\ndelay = 1 * second\n\nupstate : Event -> State -> State\nupstate (now,tm) (n,p) = case (tm,p) of\n  (M Start, Paused)      -> (n, Playing (now + delay))\n  (M Stop,  Playing _)   -> (n, Paused)\n  (Tick,    Paused)      -> (n, Paused)\n  (Tick,    Playing end) -> if now < end then (n,p)\n                            else (n+1, Playing (end + delay)) \n```", "```\nview (w,h) (n,p) =\n     E.color Color.gray\n  <| E.container (w-1) (h-1) E.middle\n  <| E.flow E.down\n  <| List.intersperse vspace\n       [ n |> toString |> strStyle |> E.container btnW btnH E.middle\n       , case (n,p) of \n           (0, Paused)    -> myButton (Signal.send ch Start) \"Start\" \n           (_, Paused)    -> myButton (Signal.send ch Start) \"Resume\" \n           (_, Playing _) -> myButton (Signal.send ch Stop)  \"Pause\" \n       ] \n```", "```\nvspace = E.spacer 0 10\n\nstrStyle : String -> E.Element\nstrStyle = T.fromString >> T.height 30 >> T.centered\n\nlineStyle =\n  let ls = C.defaultLine in\n    { ls | color <- Color.darkCharcoal,\n           width <- 10 }\n\nbtnW = 200\nbtnH = 60\n\nmyButton evt s =\n  let mkBtn c =\n    C.collage btnW btnH\n        C.filled c (C.rect btnW btnH)\n      , C.outlined lineStyle (C.rect btnW btnH)\n      , strStyle s |> C.toForm\n    ]\n  in\n  customButton evt\n    (mkBtn Color.lightYellow)\n    (mkBtn Color.lightOrange)\n    (mkBtn Color.lightBlue) \n```", "```\ntype alias State = (Int, RunState)\ntype RunState    = Paused | Playing Time \n```", "```\ntype alias Msg   = (Time -> State -> State)\ntype alias Event = (Time, Msg) \n```", "```\nupstate : Event -> State -> State\nupstate (now, f) st = f now st\n\nstart now (n,p) = case p of Paused    -> (n, Playing (now + delay))\nstop  now (n,p) = case p of Playing _ -> (n, Paused)\ntick  now (n,p) = case p of\n                    Paused      -> (n, Paused)\n                    Playing end -> if now < end then (n,p)\n                                   else (n+1, Playing (end + delay)) \n```", "```\nch = Signal.channel start\n\n...\n\n   ...\n   , case (n,p) of \n       (0, Paused)    -> myButton (Signal.send ch start) \"Start\" \n       (_, Paused)    -> myButton (Signal.send ch start) \"Resume\" \n       (_, Playing _) -> myButton (Signal.send ch stop)  \"Pause\" \n   ... \n```", "```\nmergeWithTicker : Time -> Signal Msg -> Signal Event\nmergeWithTicker t sig =\n  let time = every t in\n  Signal.merge\n    ((\\t   -> (t, tick)) <~ time)\n    ((\\t m -> (t, m))    <~ Signal.sampleOn sig time ~ sig) \n```", "```\nnumRows = 5 \n```", "```\ntype alias State = (List String, RunState)\ntype RunState    = Steady | Pushing Time Time Time | Popping Time Time Time \n```", "```\ninitState  = ([], Steady) \n```", "```\ntype Msg         = Push String | Pop | Noop\ntype TickOr msg  = Tick | M msg\ntype alias Event = (Time, TickOr Msg) \n```", "```\npop    = Signal.send ch Pop\npush s = Signal.send ch (Push s)\nnoop   = Signal.send ch Noop \n```", "```\nmergeWithTicker : Time -> Signal msg -> Signal (Time, TickOr msg)\nmergeWithTicker t sig =\n  let time = every t in\n  Signal.merge\n    ((\\t   -> (t, Tick)) <~ time)\n    ((\\t m -> (t, M m))  <~ Signal.sampleOn sig time ~ sig)\n\nmain =\n  view <~ Window.dimensions\n        ~ Signal.foldp upstate initState\n            (mergeWithTicker (100 * millisecond) (Signal.subscribe ch)) \n```", "```\nupstate : Event -> State -> State\nupstate (now,tm) (stack,rs) = case (tm, rs) of\n  (M Noop, _)          -> (stack, rs)\n  (Tick, Steady)       -> (stack, rs)\n  (M Pop, Steady)      -> (List.tail stack, Steady)\n  (M (Push s), Steady) -> if | List.length stack < numRows -> (s::stack, Steady) \n```", "```\nmyButton enabled evt s =\n  let mkBtn c =\n    C.collage wBtn hBtn [\n        C.filled c (C.rect wBtn hBtn)\n      , C.outlined lineStyle (C.rect wBtn hBtn)\n      , strStyle s |> C.toForm\n    ]\n  in\n  let (x,y,z) =\n    if | enabled   -> (Color.lightYellow, Color.lightOrange, Color.lightBlue)\n       | otherwise -> (Color.white, Color.white, Color.white)\n  in\n  customButton evt (mkBtn x) (mkBtn y) (mkBtn z) \n```", "```\nmaybeButton b evt s = if\n  | b         -> myButton True evt s\n  | otherwise -> myButton False noop s \n```", "```\nview : (Int,Int) -> State -> E.Element\nview (w,h) (stack_,rs) =\n  let stack = List.reverse stack_\n      n     = List.length stack\n  in\n  let eButtons =\n       E.flow E.down\n    <| List.intersperse vSep\n         [ maybeButton (rs == Steady && n < 5) (push \"BLAH\") \"Push\"\n         , maybeButton (rs == Steady && n > 0) pop \"Pop\"\n         ]\n  in\n  let eStack =\n    let stackRect = C.rect wStackArea hStackArea\n        stackBack = [ stackRect |> C.filled Color.lightGray ]\n        stackFore = [ stackRect |> C.outlined lineStyle ]\n        stackElts =\n          stack |> List.indexedMap (\\i s ->\n            let\n              rect = C.rect wBtn hRow\n              box =\n                [ rect |> C.filled Color.lightCharcoal\n                , rect |> C.outlined C.defaultLine\n                , s |> strStyle |> E.container wBtn hRow E.middle |> C.toForm\n                ]\n              move = C.move (0, center0 + toFloat (i*hRow))\n              center0 = if\n                | numRows % 2 == 1 -> -(((numRows-1)/2)*hRow)\n                | otherwise        -> -(((numRows-1)/2)*hRow) - (hRow/2)\n            in\n            List.map move box\n          )\n    in\n       C.collage wStackArea hStackArea\n         (stackBack ++ List.concat stackElts ++ stackFore)\n  in\n  E.container (w-1) (h-1) E.middle\n    (E.flow E.right [eStack, hSep, eButtons]) \n```", "```\nfield : Style -> (Content -> Signal.Message) -> String -> Content -> Element \n```", "```\ntype alias Content = { string : String, selection : Selection } \n```", "```\nsend : Channel a -> a -> Message \n```", "```\ntextbox : Signal.Channel F.Content\ntextbox = Signal.channel F.noContent \n```", "```\nmain =\n  view <~ Window.dimensions\n        ~ Signal.subscribe textbox\n        ~ Signal.foldp upstate initState\n            (mergeWithTicker (100 * millisecond) (Signal.subscribe ch)) \n```", "```\nview : (Int,Int) -> F.Content -> State -> E.Element\nview (w,h) con state =\n  ...\n         [ F.field fieldStyle (Signal.send textbox) \"\" con\n         , maybeButton (rs == Steady && n < 5) (push con.string) \"Push\"\n         , maybeButton (rs == Steady && n > 0) pop \"Pop\"\n         ]\n  ...\n\nfieldStyle : F.Style\nfieldStyle =\n  let fs = F.defaultStyle in\n  let ts = T.defaultStyle in\n    { fs | style <- { ts | height <- Just 20 }} \n```", "```\nupstate (now,tm) (stack,rs) = case (tm, rs) of\n\n  (M Noop, _)    -> (stack, rs)\n  (Tick, Steady) -> (stack, rs)\n\n  (M Pop, Steady) ->\n    (stack, Popping now now (now + delay))\n\n  (M (Push s), Steady) -> if\n    | List.length stack < numRows -> (s::stack, Pushing now now (now + delay))\n\n  (Tick, Popping _ start end) -> if\n    | now > end -> (List.tail stack, Steady)\n    | otherwise -> (stack, Popping now start end)\n\n  (Tick, Pushing _ start end) -> if\n    | now > end -> (stack, Steady)\n    | otherwise -> (stack, Pushing now start end) \n```", "```\nsetAlpha : Float -> Color.Color -> Color.Color\nsetAlpha a c =\n  let rgb = Color.toRgb c in\n  Color.rgba rgb.red rgb.green rgb.blue a\n\nsetAlphaLS a ls = { ls | color <- setAlpha a ls.color } \n```", "```\n...\nlet a =\n  case (rs, i == n - 1) of\n    (Popping now start end, True) -> (end-now)   / (end-start)\n    (Pushing now start end, True) -> (now-start) / (end-start)\n    _ -> 1.0\nin\n  [ rect |> C.filled (setAlpha a Color.lightCharcoal) |> move\n  , rect |> C.outlined (setAlphaLS a C.defaultLine) |> move\n  , s |> T.fromString |> T.height 30 |> T.color (setAlpha a Color.black)\n      |> T.centered |> C.toForm |> move\n  ])\n... \n```"]