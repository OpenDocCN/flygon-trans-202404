- en: 'Reading 19: Concurrency'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读 19：并发性
- en: Software in 6.005
  id: totrans-1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.005 中的软件
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| 免受错误影响 | 易于理解 | 为变化做好准备 |'
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 今天正确，未来也正确。 | 与未来的程序员清晰沟通，包括未来的自己。 | 设计以适应变化而无需重写。 |'
- en: Objectives
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目标
- en: The message passing and shared memory models of concurrency
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息传递和共享内存并发模型
- en: Concurrent processes and threads, and time slicing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发进程和线程，以及时间片
- en: The danger of race conditions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞争条件的危险
- en: Concurrency
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发性
- en: '*Concurrency* means multiple computations are happening at the same time. Concurrency
    is everywhere in modern programming, whether we like it or not:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*并发* 意味着多个计算同时进行。并发在现代编程中随处可见，无论我们是否喜欢：'
- en: Multiple computers in a network
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络中的多台计算机
- en: Multiple applications running on one computer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一台计算机上运行的多个应用程序
- en: Multiple processors in a computer (today, often multiple processor cores on
    a single chip)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机中的多个处理器（今天，通常是单个芯片上的多个处理器核心）
- en: 'In fact, concurrency is essential in modern programming:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，并发在现代编程中是必不可少的：
- en: Web sites must handle multiple simultaneous users.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站必须处理多个同时在线的用户。
- en: Mobile apps need to do some of their processing on servers (“in the cloud”).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动应用程序需要在服务器上进行一些处理（“在云端”）。
- en: Graphical user interfaces almost always require background work that does not
    interrupt the user. For example, Eclipse compiles your Java code while you’re
    still editing it.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形用户界面几乎总是需要在不打扰用户的情况下进行后台工作。例如，Eclipse 在您编辑代码时编译您的 Java 代码。
- en: Being able to program with concurrency will still be important in the future.
    Processor clock speeds are no longer increasing. Instead, we’re getting more cores
    with each new generation of chips. So in the future, in order to get a computation
    to run faster, we’ll have to split up a computation into concurrent pieces.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 未来仍然能够使用并发编程将是重要的。处理器时钟速度不再增加。相反，每一代新芯片都会获得更多的核心。因此，在未来，为了使计算运行更快，我们将不得不将计算分割成并发片段。
- en: Two Models for Concurrent Programming
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 两种并发编程模型
- en: 'There are two common models for concurrent programming: *shared memory* and
    *message passing*.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程有两种常见模型：*共享内存* 和 *消息传递*。
- en: '![shared memory](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/shared-memory.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![共享内存](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/shared-memory.png)'
- en: '**Shared memory.** In the shared memory model of concurrency, concurrent modules
    interact by reading and writing shared objects in memory.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**共享内存。** 在共享内存并发模型中，并发模块通过读取和写入内存中的共享对象进行交互。'
- en: 'Examples of the shared-memory model:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存模型的示例：
- en: A and B might be two processors (or processor cores) in the same computer, sharing
    the same physical memory.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A 和 B 可能是同一台计算机中的两个处理器（或处理器核心），共享相同的物理内存。
- en: A and B might be two programs running on the same computer, sharing a common
    filesystem with files they can read and write.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A 和 B 可能是在同一台计算机上运行的两个程序，共享一个可以读写文件的公共文件系统。
- en: A and B might be two threads in the same Java program (we’ll explain what a
    thread is below), sharing the same Java objects.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A 和 B 可能是同一个 Java 程序中的两个线程（我们将在下面解释什么是线程），共享相同的 Java 对象。
- en: '![message passing](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/message-passing.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![消息传递](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/message-passing.png)'
- en: '**Message passing.** In the message-passing model, concurrent modules interact
    by sending messages to each other through a communication channel. Modules send
    off messages, and incoming messages to each module are queued up for handling.
    Examples include:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息传递。** 在消息传递模型中，并发模块通过通过通信通道向彼此发送消息来进行交互。模块发送消息，每个模块的传入消息都会排队等待处理。示例包括：'
- en: A and B might be two computers in a network, communicating by network connections.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A 和 B 可能是通过网络连接进行通信的网络中的两台计算机。
- en: A and B might be a web browser and a web server – A opens a connection to B
    and asks for a web page, and B sends the web page data back to A.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A 和 B 可能是一个网络浏览器和一个网络服务器 - A 打开到 B 的连接并请求一个网页，B 将网页数据发送回 A。
- en: A and B might be an instant messaging client and server.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A 和 B 可能是即时通讯客户端和服务器。
- en: A and B might be two programs running on the same computer whose input and output
    have been connected by a pipe, like `ls | grep` typed into a command prompt.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes, Threads, Time-slicing
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The message-passing and shared-memory models are about how concurrent modules
    communicate. The concurrent modules themselves come in two different kinds: processes
    and threads.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**Process**. A process is an instance of a running program that is *isolated*
    from other processes on the same machine. In particular, it has its own private
    section of the machine’s memory.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The process abstraction is a *virtual computer*. It makes the program feel like
    it has the entire machine to itself – like a fresh computer has been created,
    with fresh memory, just to run that program.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Just like computers connected across a network, processes normally share no
    memory between them. A process can’t access another process’s memory or objects
    at all. Sharing memory between processes is *possible* on most operating systems,
    but it needs special effort. By contrast, a new process is automatically ready
    for message passing, because it is created with standard input & output streams,
    which are the `System.out` and `System.in` streams you’ve used in Java.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '**Thread**. A thread is a locus of control inside a running program. Think
    of it as a place in the program that is being run, plus the stack of method calls
    that led to that place (so the thread can go back up the stack when it reaches
    `return` statements).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Just as a process represents a virtual computer, the thread abstraction represents
    a *virtual processor*. Making a new thread simulates making a fresh processor
    inside the virtual computer represented by the process. This new virtual processor
    runs the same program and shares the same memory as other threads in the process.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Threads are automatically ready for shared memory, because threads share all
    the memory in the process. It takes special effort to get “thread-local” memory
    that’s private to a single thread. It’s also necessary to set up message-passing
    explicitly, by creating and using queue data structures. We’ll talk about how
    to do that in a future reading.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![time-slicing](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/time-slicing.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: How can I have many concurrent threads with only one or two processors in my
    computer? When there are more threads than processors, concurrency is simulated
    by **time slicing**, which means that the processor switches between threads.
    The figure on the right shows how three threads T1, T2, and T3 might be time-sliced
    on a machine that has only two actual processors. In the figure, time proceeds
    downward, so at first one processor is running thread T1 and the other is running
    thread T2, and then the second processor switches to run thread T3\. Thread T2
    simply pauses, until its next time slice on the same processor or another processor.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: On most systems, time slicing happens unpredictably and nondeterministically,
    meaning that a thread may be paused or resumed at any time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Java Tutorials, read:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '**[Processes & Threads](http://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html)**
    (just 1 page)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Defining and Starting a Thread](http://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html)**
    (just 1 page)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second Java Tutorials reading shows two ways to create a thread.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Never use their second way (subclassing `Thread`).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always implement the [`Runnable`](http://docs.oracle.com/javase/8/docs/api/?java/lang/Runnable.html)
    interface and use the `new Thread(..)` constructor.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Their example declares a named class that implements `Runnable`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A very common idiom is starting a thread with an [anonymous](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html)
    `Runnable`, which eliminates the named class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Read: [using an anonymous `Runnable` to start a thread](anonymous-runnable/)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Processes and threads 1
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: When you run a Java program (for example, using the Run button in Eclipse),
    how many processors, processes, and threads are created at first?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Processors:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: <select class="form-control"><option>no processors</option>,<option>one processor</option>,<option>one
    processor for each class in the program</option></select>(missing answer)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Processes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: <select class="form-control"><option>no processes</option>,<option>one process</option>,<option>one
    process for each class in the program</option></select>(missing answer)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Threads:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: <select class="form-control"><option>no threads</option>,<option>one thread</option>,<option>one
    thread for each class in the program</option></select>(missing answer)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Processes and threads 2
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we run `main` in this program, which contains bugs:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How many new `Thread` objects are created?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: How many new threads are run?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: What is the maximum number of threads that might be running at the same time?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Processes and threads 3
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we run `main` in this program, which demonstrates two common bugs:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How many new `Thread` objects are created?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: How many new threads are run?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Shared Memory Example
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at an example of a shared memory system. The point of this example
    is to show that concurrent programming is hard, because it can have subtle bugs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![shared memory model for bank accounts](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/shared-memory-bank-account.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: Imagine that a bank has cash machines that use a shared memory model, so all
    the cash machines can read and write the same account objects in memory.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate what can go wrong, let’s simplify the bank down to a single account,
    with a dollar balance stored in the `balance` variable, and two operations `deposit`
    and `withdraw` that simply add or remove a dollar:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明可能出现的问题，让我们简化银行为一个单一账户，其中存储在 `balance` 变量中的一美元余额，并且有两个操作 `deposit` 和 `withdraw`，它们只是简单地添加或移除一美元：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Customers use the cash machines to do transactions like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 客户使用取款机进行如下交易：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this simple example, every transaction is just a one dollar deposit followed
    by a one-dollar withdrawal, so it should leave the balance in the account unchanged.
    Throughout the day, each cash machine in our network is processing a sequence
    of deposit/withdraw transactions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，每笔交易只是一个一美元存款，然后是一美元取款，所以它应该不会改变账户余额。在一天中，我们网络中的每台取款机都在处理一系列存款/取款交易。
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So at the end of the day, regardless of how many cash machines were running,
    or how many transactions we processed, we should expect the account balance to
    still be 0.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论一天结束时有多少台取款机在运行，或者我们处理了多少笔交易，我们应该期望账户余额仍然是0。
- en: But if we run this code, we discover frequently that the balance at the end
    of the day is *not* 0\. If more than one `cashMachine()` call is running at the
    same time – say, on separate processors in the same computer – then `balance`
    may not be zero at the end of the day. Why not?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们运行这段代码，我们会经常发现一天结束时余额*不是*0。如果多个 `cashMachine()` 调用同时运行 - 比如，在同一台计算机的不同处理器上
    - 那么 `balance` 在一天结束时可能不为零。为什么呢？
- en: Interleaving
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交错
- en: 'Here’s one thing that can happen. Suppose two cash machines, A and B, are both
    working on a deposit at the same time. Here’s how the `deposit()` step typically
    breaks down into low-level processor instructions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能发生的一种情况。假设两台取款机 A 和 B 同时在进行存款操作。这是 `deposit()` 步骤通常分解为低级处理器指令的方式：
- en: '| get balance (balance=0) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 获取余额 (余额=0) |'
- en: '| add 1 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 加 1 |'
- en: '| write back the result (balance=1) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 写回结果（余额=1） |'
- en: 'When A and B are running concurrently, these low-level instructions interleave
    with each other (some might even be simultaneous in some sense, but let’s just
    worry about interleaving for now):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当 A 和 B 同时运行时，这些低级指令会相互交错（在某种意义上甚至可能同时进行，但现在让我们只关注交错）：
- en: '| A | B |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| A | B |'
- en: '| --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| A get balance (balance=0) |  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| A 获取余额 (余额=0) |  |'
- en: '| A add 1 |  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| A 加 1 |  |'
- en: '| A write back the result (balance=1) |  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| A 写回结果（余额=1） |  |'
- en: '|  | B get balance (balance=1) |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  | B 获取余额 (余额=1) |'
- en: '|  | B add 1 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|  | B 加 1 |'
- en: '|  | B write back the result (balance=2) |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|  | B 写回结果（余额=2） |'
- en: 'This interleaving is fine – we end up with balance 2, so both A and B successfully
    put in a dollar. But what if the interleaving looked like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种交错是可以接受的 - 我们最终得到了余额2，因此 A 和 B 都成功存入了一美元。但如果交错看起来像这样呢：
- en: '| A | B |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| A | B |'
- en: '| --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| A get balance (balance=0) |  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| A 获取余额 (余额=0) |  |'
- en: '|  | B get balance (balance=0) |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|  | B 获取余额 (余额=0) |'
- en: '| A add 1 |  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| A 加 1 |  |'
- en: '|  | B add 1 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  | B 加 1 |'
- en: '| A write back the result (balance=1) |  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| A 写回结果（余额=1） |  |'
- en: '|  | B write back the result (balance=1) |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  | B 写回结果（余额=1） |'
- en: The balance is now 1 – A’s dollar was lost! A and B both read the balance at
    the same time, computed separate final balances, and then raced to store back
    the new balance – which failed to take the other’s deposit into account.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在余额是1 - A 的一美元丢失了！A 和 B 同时读取余额，计算出各自的最终余额，然后争先存储新余额 - 但未考虑对方的存款。
- en: Race Condition
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 竞争条件
- en: This is an example of a **race condition**. A race condition means that the
    correctness of the program (the satisfaction of postconditions and invariants)
    depends on the relative timing of events in concurrent computations A and B. When
    this happens, we say “A is in a race with B.”
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个**竞争条件**的例子。竞争条件意味着程序的正确性（后置条件和不变量的满足）取决于并发计算 A 和 B 中事件的相对时间。当这种情况发生时，我们说“A
    与 B 在竞争中”。
- en: Some interleavings of events may be OK, in the sense that they are consistent
    with what a single, nonconcurrent process would produce, but other interleavings
    produce wrong answers – violating postconditions or invariants.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一些事件的交错可能是可以接受的，因为它们与单个、非并发进程产生的结果一致，但其他交错会产生错误答案 - 违反后置条件或不变量。
- en: Tweaking the Code Won’t Help
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整代码不会有帮助
- en: 'All these versions of the bank-account code exhibit the same race condition:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些版本的银行账户代码都表现出相同的竞争条件：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can’t tell just from looking at Java code how the processor is going to
    execute it. You can’t tell what the indivisible operations – the atomic operations
    – will be. It isn’t atomic just because it’s one line of Java. It doesn’t touch
    balance only once just because the balance identifier occurs only once in the
    line. The Java compiler, and in fact the processor itself, makes no commitments
    about what low-level operations it will generate from your code. In fact, a typical
    modern Java compiler produces exactly the same code for all three of these versions!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The key lesson is that you can’t tell by looking at an expression whether it
    will be safe from race conditions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Read: **[Thread Interference](http://docs.oracle.com/javase/tutorial/essential/concurrency/interfere.html)**
    (just 1 page)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Reordering
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s even worse than that, in fact. The race condition on the bank account balance
    can be explained in terms of different interleavings of sequential operations
    on different processors. But in fact, when you’re using multiple variables and
    multiple processors, you can’t even count on changes to those variables appearing
    in the same order.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example. Note that it uses a loop that continuously checks for a
    concurrent condition; this is called [busy waiting](https://en.wikipedia.org/wiki/Busy_waiting)
    and it is not a good pattern. In this case, the code is also broken:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have two methods that are being run in different threads. `computeAnswer`
    does a long calculation, finally coming up with the answer 42, which it puts in
    the answer variable. Then it sets the `ready` variable to true, in order to signal
    to the method running in the other thread, `useAnswer`, that the answer is ready
    for it to use. Looking at the code, `answer` is set before `ready` is set, so
    once `useAnswer` sees `ready` as true, then it seems reasonable that it can assume
    that the `answer` will be 42, right? Not so.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that modern compilers and processors do a lot of things to make
    the code fast. One of those things is making temporary copies of variables like
    answer and ready in faster storage (registers or caches on a processor), and working
    with them temporarily before eventually storing them back to their official location
    in memory. The storeback may occur in a different order than the variables were
    manipulated in your code. Here’s what might be going on under the covers (but
    expressed in Java syntax to make it clear). The processor is effectively creating
    two temporary variables, `tmpr` and `tmpa`, to manipulate the fields `ready` and
    `answer`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: reading exercises
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Interleaving 1
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the buggy code from our earlier exercise where two new threads are started:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Which of the following are possible outputs from this program:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Interleaving 2
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the buggy code from our earlier exercise where no new threads are started:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Which of the following are possible outputs from this program:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Race conditions 1
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Suppose `methodA` and `methodB` run **sequentially**, i.e. first one and then
    the other. What is the final value of `x`?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Race conditions 2
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose `methodA` and `methodB` run **concurrently**, so that their instructions
    might interleave arbitrarily. Which of the following are possible final values
    of `x`?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Message Passing Example
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![message passing bank account example](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/message-passing-bank-account.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: Now let’s look at the message-passing approach to our bank account example.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Now not only are the cash machine modules, but the accounts are modules, too.
    Modules interact by sending messages to each other. Incoming requests are placed
    in a queue to be handled one at a time. The sender doesn’t stop working while
    waiting for an answer to its request. It handles more requests from its own queue.
    The reply to its request eventually comes back as another message.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, message passing doesn’t eliminate the possibility of race conditions.
    Suppose each account supports `get-balance` and `withdraw` operations, with corresponding
    messages. Two users, at cash machines A and B, are both trying to withdraw a dollar
    from the same account. They check the balance first to make sure they never withdraw
    more than the account holds, because overdrafts trigger big bank penalties:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The problem is again interleaving, but this time interleaving of the *messages*
    sent to the bank account, rather than the *instructions* executed by A and B.
    If the account starts with a dollar in it, then what interleaving of messages
    will fool A and B into thinking they can both withdraw a dollar, thereby overdrawing
    the account?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: One lesson here is that you need to carefully choose the operations of a message-passing
    model. `withdraw-if-sufficient-funds` would be a better operation than just `withdraw`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency is Hard to Test and Debug
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we haven’t persuaded you that concurrency is tricky, here’s the worst of
    it. It’s very hard to discover race conditions using testing. And even once a
    test has found a bug, it may be very hard to localize it to the part of the program
    causing it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency bugs exhibit very poor reproducibility. It’s hard to make them happen
    the same way twice. Interleaving of instructions or messages depends on the relative
    timing of events that are strongly influenced by the environment. Delays can be
    caused by other running programs, other network traffic, operating system scheduling
    decisions, variations in processor clock speed, etc. Each time you run a program
    containing a race condition, you may get different behavior.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of bugs are *heisenbugs*, which are nondeterministic and hard to
    reproduce, as opposed to a *bohrbug*, which shows up repeatedly whenever you look
    at it. Almost all bugs in sequential programming are bohrbugs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的错误是*海森堡错误*，它们是不确定性的，难以复现，与*玻尔错误*相对，后者每次查看时都会出现。几乎所有的顺序编程中的错误都是玻尔错误。
- en: 'A heisenbug may even disappear when you try to look at it with `println` or
    `debugger`! The reason is that printing and debugging are so much slower than
    other operations, often 100-1000x slower, that they dramatically change the timing
    of operations, and the interleaving. So inserting a simple print statement into
    the cashMachine():'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至当你尝试用`println`或`debugger`查看时，海森堡错误可能会消失！原因是打印和调试比其他操作慢得多，通常慢100-1000倍，它们会显著改变操作的时间和交错。因此，在cashMachine()中插入一个简单的打印语句：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: …and suddenly the balance is always 0, as desired, and the bug appears to disappear.
    But it’s only masked, not truly fixed. A change in timing somewhere else in the
    program may suddenly make the bug come back.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: …突然之间，余额总是0，正如所期望的那样，错误似乎消失了。但这只是掩盖了，而不是真正修复了。程序中其他地方的时间变化可能会突然使错误再次出现。
- en: Concurrency is hard to get right. Part of the point of this reading is to scare
    you a bit. Over the next several readings, we’ll see principled ways to design
    concurrent programs so that they are safer from these kinds of bugs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 并发很难做到正确。阅读的一部分目的是让你有点害怕。在接下来的几篇阅读中，我们将看到设计并发程序的原则性方法，使其更安全，避免这些类型的错误。
- en: reading exercises
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Testing concurrency
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 测试并发性
- en: You’re running a JUnit test suite (for code written by somebody else), and some
    of the tests are failing. You add `System.out.println` statements to the one method
    called by all the failing test cases, in order to display some of its local variables,
    and the test cases suddenly start passing. Which of the following are likely reasons
    for this?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在运行一个Junit测试套件（由其他人编写的代码），一些测试失败了。你在所有失败测试用例中调用的一个方法中添加了`System.out.println`语句，以显示一些局部变量，结果测试用例突然通过了。以下哪些是可能的原因？
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'Concurrency: multiple computations running simultaneously'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发：多个计算同时运行
- en: Shared-memory & message-passing paradigms
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享内存和消息传递范式
- en: Processes & threads
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程和线程
- en: Process is like a virtual computer; thread is like a virtual processor
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程就像一个虚拟计算机；线程就像一个虚拟处理器
- en: Race conditions
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞争条件
- en: When correctness of result (postconditions and invariants) depends on the relative
    timing of events
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当结果的正确性（后置条件和不变性）取决于事件的相对时间
- en: These ideas connect to our three key properties of good software mostly in bad
    ways. Concurrency is necessary but it causes serious problems for correctness.
    We’ll work on fixing those problems in the next few readings.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些想法与我们的好软件三个关键属性大多以不好的方式连接。并发是必要的，但它会给正确性带来严重问题。我们将在接下来的几篇阅读中努力解决这些问题。
- en: '**Safe from bugs.** Concurrency bugs are some of the hardest bugs to find and
    fix, and require careful design to avoid.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免受错误困扰。** 并发错误是最难找到和修复的错误之一，需要仔细设计以避免。'
- en: '**Easy to understand.** Predicting how concurrent code might interleave with
    other concurrent code is very hard for programmers to do. It’s best to design
    your code in such a way that programmers don’t have to think about interleaving
    at all.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于理解。** 预测并发代码如何与其他并发代码交错对程序员来说非常困难。最好设计你的代码，使程序员根本不必考虑交错。'
- en: '**Ready for change.** Not particularly relevant here.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为变化做好准备。** 在这里并不特别相关。'
