- en: 'Reading 19: Concurrency'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software in 6.005
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  prefs: []
  type: TYPE_TB
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  prefs: []
  type: TYPE_TB
- en: Objectives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The message passing and shared memory models of concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent processes and threads, and time slicing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The danger of race conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Concurrency* means multiple computations are happening at the same time. Concurrency
    is everywhere in modern programming, whether we like it or not:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple computers in a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple applications running on one computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple processors in a computer (today, often multiple processor cores on
    a single chip)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In fact, concurrency is essential in modern programming:'
  prefs: []
  type: TYPE_NORMAL
- en: Web sites must handle multiple simultaneous users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile apps need to do some of their processing on servers (“in the cloud”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphical user interfaces almost always require background work that does not
    interrupt the user. For example, Eclipse compiles your Java code while you’re
    still editing it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being able to program with concurrency will still be important in the future.
    Processor clock speeds are no longer increasing. Instead, we’re getting more cores
    with each new generation of chips. So in the future, in order to get a computation
    to run faster, we’ll have to split up a computation into concurrent pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Two Models for Concurrent Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two common models for concurrent programming: *shared memory* and
    *message passing*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![shared memory](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/shared-memory.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Shared memory.** In the shared memory model of concurrency, concurrent modules
    interact by reading and writing shared objects in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of the shared-memory model:'
  prefs: []
  type: TYPE_NORMAL
- en: A and B might be two processors (or processor cores) in the same computer, sharing
    the same physical memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A and B might be two programs running on the same computer, sharing a common
    filesystem with files they can read and write.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A and B might be two threads in the same Java program (we’ll explain what a
    thread is below), sharing the same Java objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![message passing](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/message-passing.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Message passing.** In the message-passing model, concurrent modules interact
    by sending messages to each other through a communication channel. Modules send
    off messages, and incoming messages to each module are queued up for handling.
    Examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: A and B might be two computers in a network, communicating by network connections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A and B might be a web browser and a web server – A opens a connection to B
    and asks for a web page, and B sends the web page data back to A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A and B might be an instant messaging client and server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A and B might be two programs running on the same computer whose input and output
    have been connected by a pipe, like `ls | grep` typed into a command prompt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes, Threads, Time-slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The message-passing and shared-memory models are about how concurrent modules
    communicate. The concurrent modules themselves come in two different kinds: processes
    and threads.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process**. A process is an instance of a running program that is *isolated*
    from other processes on the same machine. In particular, it has its own private
    section of the machine’s memory.'
  prefs: []
  type: TYPE_NORMAL
- en: The process abstraction is a *virtual computer*. It makes the program feel like
    it has the entire machine to itself – like a fresh computer has been created,
    with fresh memory, just to run that program.
  prefs: []
  type: TYPE_NORMAL
- en: Just like computers connected across a network, processes normally share no
    memory between them. A process can’t access another process’s memory or objects
    at all. Sharing memory between processes is *possible* on most operating systems,
    but it needs special effort. By contrast, a new process is automatically ready
    for message passing, because it is created with standard input & output streams,
    which are the `System.out` and `System.in` streams you’ve used in Java.
  prefs: []
  type: TYPE_NORMAL
- en: '**Thread**. A thread is a locus of control inside a running program. Think
    of it as a place in the program that is being run, plus the stack of method calls
    that led to that place (so the thread can go back up the stack when it reaches
    `return` statements).'
  prefs: []
  type: TYPE_NORMAL
- en: Just as a process represents a virtual computer, the thread abstraction represents
    a *virtual processor*. Making a new thread simulates making a fresh processor
    inside the virtual computer represented by the process. This new virtual processor
    runs the same program and shares the same memory as other threads in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Threads are automatically ready for shared memory, because threads share all
    the memory in the process. It takes special effort to get “thread-local” memory
    that’s private to a single thread. It’s also necessary to set up message-passing
    explicitly, by creating and using queue data structures. We’ll talk about how
    to do that in a future reading.
  prefs: []
  type: TYPE_NORMAL
- en: '![time-slicing](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/time-slicing.png)'
  prefs: []
  type: TYPE_IMG
- en: How can I have many concurrent threads with only one or two processors in my
    computer? When there are more threads than processors, concurrency is simulated
    by **time slicing**, which means that the processor switches between threads.
    The figure on the right shows how three threads T1, T2, and T3 might be time-sliced
    on a machine that has only two actual processors. In the figure, time proceeds
    downward, so at first one processor is running thread T1 and the other is running
    thread T2, and then the second processor switches to run thread T3\. Thread T2
    simply pauses, until its next time slice on the same processor or another processor.
  prefs: []
  type: TYPE_NORMAL
- en: On most systems, time slicing happens unpredictably and nondeterministically,
    meaning that a thread may be paused or resumed at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Java Tutorials, read:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Processes & Threads](http://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html)**
    (just 1 page)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Defining and Starting a Thread](http://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html)**
    (just 1 page)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second Java Tutorials reading shows two ways to create a thread.
  prefs: []
  type: TYPE_NORMAL
- en: Never use their second way (subclassing `Thread`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always implement the [`Runnable`](http://docs.oracle.com/javase/8/docs/api/?java/lang/Runnable.html)
    interface and use the `new Thread(..)` constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Their example declares a named class that implements `Runnable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A very common idiom is starting a thread with an [anonymous](https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html)
    `Runnable`, which eliminates the named class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Read: [using an anonymous `Runnable` to start a thread](anonymous-runnable/)'
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Processes and threads 1
  prefs: []
  type: TYPE_NORMAL
- en: When you run a Java program (for example, using the Run button in Eclipse),
    how many processors, processes, and threads are created at first?
  prefs: []
  type: TYPE_NORMAL
- en: 'Processors:'
  prefs: []
  type: TYPE_NORMAL
- en: <select class="form-control"><option>no processors</option>,<option>one processor</option>,<option>one
    processor for each class in the program</option></select>(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: 'Processes:'
  prefs: []
  type: TYPE_NORMAL
- en: <select class="form-control"><option>no processes</option>,<option>one process</option>,<option>one
    process for each class in the program</option></select>(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: 'Threads:'
  prefs: []
  type: TYPE_NORMAL
- en: <select class="form-control"><option>no threads</option>,<option>one thread</option>,<option>one
    thread for each class in the program</option></select>(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Processes and threads 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we run `main` in this program, which contains bugs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How many new `Thread` objects are created?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: How many new threads are run?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: What is the maximum number of threads that might be running at the same time?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Processes and threads 3
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we run `main` in this program, which demonstrates two common bugs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How many new `Thread` objects are created?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: How many new threads are run?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Shared Memory Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at an example of a shared memory system. The point of this example
    is to show that concurrent programming is hard, because it can have subtle bugs.
  prefs: []
  type: TYPE_NORMAL
- en: '![shared memory model for bank accounts](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/shared-memory-bank-account.png)'
  prefs: []
  type: TYPE_IMG
- en: Imagine that a bank has cash machines that use a shared memory model, so all
    the cash machines can read and write the same account objects in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate what can go wrong, let’s simplify the bank down to a single account,
    with a dollar balance stored in the `balance` variable, and two operations `deposit`
    and `withdraw` that simply add or remove a dollar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Customers use the cash machines to do transactions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this simple example, every transaction is just a one dollar deposit followed
    by a one-dollar withdrawal, so it should leave the balance in the account unchanged.
    Throughout the day, each cash machine in our network is processing a sequence
    of deposit/withdraw transactions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So at the end of the day, regardless of how many cash machines were running,
    or how many transactions we processed, we should expect the account balance to
    still be 0.
  prefs: []
  type: TYPE_NORMAL
- en: But if we run this code, we discover frequently that the balance at the end
    of the day is *not* 0\. If more than one `cashMachine()` call is running at the
    same time – say, on separate processors in the same computer – then `balance`
    may not be zero at the end of the day. Why not?
  prefs: []
  type: TYPE_NORMAL
- en: Interleaving
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s one thing that can happen. Suppose two cash machines, A and B, are both
    working on a deposit at the same time. Here’s how the `deposit()` step typically
    breaks down into low-level processor instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| get balance (balance=0) |'
  prefs: []
  type: TYPE_TB
- en: '| add 1 |'
  prefs: []
  type: TYPE_TB
- en: '| write back the result (balance=1) |'
  prefs: []
  type: TYPE_TB
- en: 'When A and B are running concurrently, these low-level instructions interleave
    with each other (some might even be simultaneous in some sense, but let’s just
    worry about interleaving for now):'
  prefs: []
  type: TYPE_NORMAL
- en: '| A | B |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A get balance (balance=0) |  |'
  prefs: []
  type: TYPE_TB
- en: '| A add 1 |  |'
  prefs: []
  type: TYPE_TB
- en: '| A write back the result (balance=1) |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | B get balance (balance=1) |'
  prefs: []
  type: TYPE_TB
- en: '|  | B add 1 |'
  prefs: []
  type: TYPE_TB
- en: '|  | B write back the result (balance=2) |'
  prefs: []
  type: TYPE_TB
- en: 'This interleaving is fine – we end up with balance 2, so both A and B successfully
    put in a dollar. But what if the interleaving looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| A | B |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A get balance (balance=0) |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | B get balance (balance=0) |'
  prefs: []
  type: TYPE_TB
- en: '| A add 1 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | B add 1 |'
  prefs: []
  type: TYPE_TB
- en: '| A write back the result (balance=1) |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | B write back the result (balance=1) |'
  prefs: []
  type: TYPE_TB
- en: The balance is now 1 – A’s dollar was lost! A and B both read the balance at
    the same time, computed separate final balances, and then raced to store back
    the new balance – which failed to take the other’s deposit into account.
  prefs: []
  type: TYPE_NORMAL
- en: Race Condition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an example of a **race condition**. A race condition means that the
    correctness of the program (the satisfaction of postconditions and invariants)
    depends on the relative timing of events in concurrent computations A and B. When
    this happens, we say “A is in a race with B.”
  prefs: []
  type: TYPE_NORMAL
- en: Some interleavings of events may be OK, in the sense that they are consistent
    with what a single, nonconcurrent process would produce, but other interleavings
    produce wrong answers – violating postconditions or invariants.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking the Code Won’t Help
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All these versions of the bank-account code exhibit the same race condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can’t tell just from looking at Java code how the processor is going to
    execute it. You can’t tell what the indivisible operations – the atomic operations
    – will be. It isn’t atomic just because it’s one line of Java. It doesn’t touch
    balance only once just because the balance identifier occurs only once in the
    line. The Java compiler, and in fact the processor itself, makes no commitments
    about what low-level operations it will generate from your code. In fact, a typical
    modern Java compiler produces exactly the same code for all three of these versions!
  prefs: []
  type: TYPE_NORMAL
- en: The key lesson is that you can’t tell by looking at an expression whether it
    will be safe from race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read: **[Thread Interference](http://docs.oracle.com/javase/tutorial/essential/concurrency/interfere.html)**
    (just 1 page)'
  prefs: []
  type: TYPE_NORMAL
- en: Reordering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s even worse than that, in fact. The race condition on the bank account balance
    can be explained in terms of different interleavings of sequential operations
    on different processors. But in fact, when you’re using multiple variables and
    multiple processors, you can’t even count on changes to those variables appearing
    in the same order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example. Note that it uses a loop that continuously checks for a
    concurrent condition; this is called [busy waiting](https://en.wikipedia.org/wiki/Busy_waiting)
    and it is not a good pattern. In this case, the code is also broken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have two methods that are being run in different threads. `computeAnswer`
    does a long calculation, finally coming up with the answer 42, which it puts in
    the answer variable. Then it sets the `ready` variable to true, in order to signal
    to the method running in the other thread, `useAnswer`, that the answer is ready
    for it to use. Looking at the code, `answer` is set before `ready` is set, so
    once `useAnswer` sees `ready` as true, then it seems reasonable that it can assume
    that the `answer` will be 42, right? Not so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that modern compilers and processors do a lot of things to make
    the code fast. One of those things is making temporary copies of variables like
    answer and ready in faster storage (registers or caches on a processor), and working
    with them temporarily before eventually storing them back to their official location
    in memory. The storeback may occur in a different order than the variables were
    manipulated in your code. Here’s what might be going on under the covers (but
    expressed in Java syntax to make it clear). The processor is effectively creating
    two temporary variables, `tmpr` and `tmpa`, to manipulate the fields `ready` and
    `answer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Interleaving 1
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the buggy code from our earlier exercise where two new threads are started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Which of the following are possible outputs from this program:'
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Interleaving 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the buggy code from our earlier exercise where no new threads are started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Which of the following are possible outputs from this program:'
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Race conditions 1
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Suppose `methodA` and `methodB` run **sequentially**, i.e. first one and then
    the other. What is the final value of `x`?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Race conditions 2
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose `methodA` and `methodB` run **concurrently**, so that their instructions
    might interleave arbitrarily. Which of the following are possible final values
    of `x`?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Message Passing Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![message passing bank account example](http://web.mit.edu/6.005/www/fa16/classes/19-concurrencyfigures/message-passing-bank-account.png)'
  prefs: []
  type: TYPE_IMG
- en: Now let’s look at the message-passing approach to our bank account example.
  prefs: []
  type: TYPE_NORMAL
- en: Now not only are the cash machine modules, but the accounts are modules, too.
    Modules interact by sending messages to each other. Incoming requests are placed
    in a queue to be handled one at a time. The sender doesn’t stop working while
    waiting for an answer to its request. It handles more requests from its own queue.
    The reply to its request eventually comes back as another message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, message passing doesn’t eliminate the possibility of race conditions.
    Suppose each account supports `get-balance` and `withdraw` operations, with corresponding
    messages. Two users, at cash machines A and B, are both trying to withdraw a dollar
    from the same account. They check the balance first to make sure they never withdraw
    more than the account holds, because overdrafts trigger big bank penalties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The problem is again interleaving, but this time interleaving of the *messages*
    sent to the bank account, rather than the *instructions* executed by A and B.
    If the account starts with a dollar in it, then what interleaving of messages
    will fool A and B into thinking they can both withdraw a dollar, thereby overdrawing
    the account?
  prefs: []
  type: TYPE_NORMAL
- en: One lesson here is that you need to carefully choose the operations of a message-passing
    model. `withdraw-if-sufficient-funds` would be a better operation than just `withdraw`.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency is Hard to Test and Debug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we haven’t persuaded you that concurrency is tricky, here’s the worst of
    it. It’s very hard to discover race conditions using testing. And even once a
    test has found a bug, it may be very hard to localize it to the part of the program
    causing it.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency bugs exhibit very poor reproducibility. It’s hard to make them happen
    the same way twice. Interleaving of instructions or messages depends on the relative
    timing of events that are strongly influenced by the environment. Delays can be
    caused by other running programs, other network traffic, operating system scheduling
    decisions, variations in processor clock speed, etc. Each time you run a program
    containing a race condition, you may get different behavior.
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of bugs are *heisenbugs*, which are nondeterministic and hard to
    reproduce, as opposed to a *bohrbug*, which shows up repeatedly whenever you look
    at it. Almost all bugs in sequential programming are bohrbugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'A heisenbug may even disappear when you try to look at it with `println` or
    `debugger`! The reason is that printing and debugging are so much slower than
    other operations, often 100-1000x slower, that they dramatically change the timing
    of operations, and the interleaving. So inserting a simple print statement into
    the cashMachine():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: …and suddenly the balance is always 0, as desired, and the bug appears to disappear.
    But it’s only masked, not truly fixed. A change in timing somewhere else in the
    program may suddenly make the bug come back.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency is hard to get right. Part of the point of this reading is to scare
    you a bit. Over the next several readings, we’ll see principled ways to design
    concurrent programs so that they are safer from these kinds of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Testing concurrency
  prefs: []
  type: TYPE_NORMAL
- en: You’re running a JUnit test suite (for code written by somebody else), and some
    of the tests are failing. You add `System.out.println` statements to the one method
    called by all the failing test cases, in order to display some of its local variables,
    and the test cases suddenly start passing. Which of the following are likely reasons
    for this?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Concurrency: multiple computations running simultaneously'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared-memory & message-passing paradigms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processes & threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process is like a virtual computer; thread is like a virtual processor
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Race conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When correctness of result (postconditions and invariants) depends on the relative
    timing of events
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These ideas connect to our three key properties of good software mostly in bad
    ways. Concurrency is necessary but it causes serious problems for correctness.
    We’ll work on fixing those problems in the next few readings.
  prefs: []
  type: TYPE_NORMAL
- en: '**Safe from bugs.** Concurrency bugs are some of the hardest bugs to find and
    fix, and require careful design to avoid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to understand.** Predicting how concurrent code might interleave with
    other concurrent code is very hard for programmers to do. It’s best to design
    your code in such a way that programmers don’t have to think about interleaving
    at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ready for change.** Not particularly relevant here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
