["```\nempty     : Heap\nisEmpty   : Heap -> Bool\nfindMin   : Heap -> Maybe Int\ninsert    : Int -> Heap -> Heap\ndeleteMin : Heap -> Maybe Heap\nmerge     : Heap -> Heap -> Heap \n```", "```\n Level 1              0\n\n    Level 2        1           2\n\n    Level 3     3     4     5     6\n\n               . .   . .   . .   . . \n```", "```\n i:     0   1   2   3   4   5   6   ...\n           ----------------------------------\n   a[i]:   | 0 | 1 | 2 | 3 | 4 | 5 | 7 | ...\n           ---------------------------------- \n```", "```\ntype alias Heap = A.Array Int \n```", "```\ntype Heap = WrapHeap (A.Array Int) \n```", "```\nmodule Heaps\n  (Heap, empty, isEmpty, findMin, insert, deleteMin, merge) where\n  ... \n```", "```\nA.empty  : Array a\nA.length : Array a -> Int\nA.push   : a -> Array a -> Array a\nA.get    : Int -> Array a -> Maybe a\nA.set    : Int -> a -> Array a -> Array a\nA.slice  : Int -> Int -> Array a -> Array a \n```", "```\npop : A.Array a -> A.Array a\npop a = A.slice 0 (A.length a - 1) a \n```", "```\nempty : Heap\nempty = WrapHeap A.empty\n\nisEmpty : Heap -> Bool\nisEmpty (WrapHeap a) = A.length a == 0 \n```", "```\nisEmpty h = case h of {WrapHeap a -> A.length a == 0}\n\nisEmpty = \\h -> case h of {WrapHeap a -> A.length a == 0}\n\nisEmpty = \\h -> let (WrapHeap a) = h in A.length a == 0\n\nisEmpty = \\(WrapHeap a) -> A.length a == 0 \n```", "```\nfindMin : Heap -> Maybe Int\nfindMin (WrapHeap a) = A.get 0 a \n```", "```\ninsert : Int -> Heap -> Heap\ninsert x (WrapHeap a) =\n  let n  = A.length a\n      a' = A.push x a in\n    Heap (bubbleUp n a') \n```", "```\nfromJust : Maybe a -> a\nfromJust mx = case mx of Just x -> x\n\njustGet : Int -> A.Array a -> a\njustGet i a = fromJust (A.get i a) \n```", "```\nswap : Int -> Int -> A.Array a -> A.Array a\nswap i j a =\n  a |> A.set i (justGet j a) |> A.set j (justGet i a) \n```", "```\nbubbleUp : Int -> InternalHeap -> InternalHeap\nbubbleUp i a = if\n  | i == 0 -> a\n  | otherwise ->\n      let j   = (i-1) // 2\n          ch  = justGet i a\n          par = justGet j a in\n      if par <= ch\n      then a\n      else a |> swap i j |> bubbleUp j \n```", "```\ndeleteMin : Heap -> Maybe Heap\ndeleteMin (WrapHeap a) =\n  let n = A.length a in if\n    | n == 0    -> Nothing\n    | otherwise -> let x = justGet (n-1) a in\n                     a |> pop\n                       |> A.set 0 x\n                       |> bubbleDown 0\n                       |> WrapHeap\n                       |> Just \n```", "```\nbubbleDown : Int -> InternalHeap -> InternalHeap\nbubbleDown i a =\n  let n = A.length a in\n  if | i >= n -> a\n     | otherwise ->\n         let (j, k) = (2*i + 1, 2*i + 2) in\n         let i'  = if j < n && justGet j a < justGet i  a then j else i  in\n         let i'' = if k < n && justGet k a < justGet i' a then k else i' in\n         if | i == i''  -> a\n            | otherwise -> a |> swap i i'' |> bubbleDown i'' \n```", "```\nmerge _ _ = if\n  | False -> empty \n```", "```\ntype Heap comparable = WrapHeap (A.Array comparable)\n\nempty     : Heap comparable\nisEmpty   : Heap comparable -> Bool\nfindMin   : Heap comparable -> Maybe comparable\ninsert    : comparable -> Heap comparable -> Heap comparable\ndeleteMin : Heap comparable -> Maybe (Heap comparable)\nmerge     : Heap comparable -> Heap comparable -> Heap comparable \n```", "```\nclass Ord a where\n  (<)  :: a -> a -> Bool\n  (>=) :: a -> a -> Bool\n  (>)  :: a -> a -> Bool\n  (<=) :: a -> a -> Bool\n  max  :: a -> a -> a\n  min  :: a -> a -> a\n\nclass Ord a => Heap a where\n  empty     : Heap a\n  isEmpty   : Heap a -> Bool\n  findMin   : Heap a -> Maybe a\n  insert    : a -> Heap a -> Heap a\n  deleteMin : Heap a -> Maybe (Heap a)\n  merge     : Heap a -> Heap a -> Heap a \n```", "```\ntype MyHeap a = WrapHeap (Array a)\n\ninstance Heap (MyHeap a) where\n  insert = ...\n  ... \n```", "```\nsignature ORDERED =\nsig\n  type T\n\n  val eq  : T -> T -> bool\n  val lt  : T -> T -> bool\n  val leq : T -> T -> bool\nend\n\nsignature HEAP =\nsig\n  structure Elem : ORDERED\n\n  type H\n\n  val empty     : H\n  val isEmpty   : H -> bool\n  val insert    : Elem.T -> H -> H\n  val merge     : H -> H -> H\n  val findMin   : H -> Elem.t option\n  val deleteMin : H -> H option\nend \n```", "```\nfunctor MyHeap (Element : ORDERED) : HEAP =\nstruct\n  structure Elem = Element\n\n  datatype H = ...\n\n  fun insert = ...\n  ...\nend \n```"]