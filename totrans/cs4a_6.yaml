- en: 'Chapter 6: Fun and Games with OOPs: Object-Oriented Programs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：通过OOPs玩乐：面向对象的程序
- en: '*I paint objects as I think them, not as I see them.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我把物体描绘成我所思考的样子，而不是我所看到的。*'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Pablo Picasso
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —巴勃罗·毕加索
- en: 6.1 Introduction
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1介绍
- en: 'In this chapter we’ll develop our own “killer app”: A 3D video game called
    “Robot versus Zombies.” By the end of this chapter you’ll have the tools to develop
    all kinds of interactive 3D programs for games, scientific simulations, or whatever
    else you can imagine.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发我们自己的“杀手级应用”：一款名为“机器人对僵尸”的3D视频游戏。通过本章的学习，您将拥有开发各种交互式3D程序的工具，用于游戏、科学模拟或您能想象到的任何其他用途。
- en: We’re sneaky! The *true* objective of this chapter is to demonstrate a beautiful
    and fundamental concept called *object-oriented programming*. Object-oriented
    programming is not only the secret sauce in 3D graphics and video games, it’s
    widely used in most modern large-scale software projects. In this chapter, you’ll
    learn about some of the fundamental ideas in object-oriented programming. And,
    yes, we’ll write that video game too!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很狡猾！本章的*真正*目标是展示一个美丽而基本的概念，称为*面向对象编程*。面向对象编程不仅是3D图形和视频游戏中的秘密武器，它广泛用于大多数现代大型软件项目中。在本章中，您将了解一些面向对象编程的基本思想。是的，我们也会写那个视频游戏！
- en: 6.2 Thinking Objectively
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2客观思考
- en: Before we get to the Robot versus Zombies video game, let’s imagine the following
    scenario. You’re a summer intern at Lunatix Games, a major video game developer.
    One of their popular games, Lunatix Lander, has the player try to land a spaceship
    on the surface of a planet. This requires the player to fire thrusters to align
    the spaceship with the landing site and slow it down to a reasonable landing speed.
    The game shows the player how much fuel remains and how much fuel is required
    for certain maneuvers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始《机器人对僵尸》视频游戏之前，让我们想象一下以下情景。你是Lunatix Games的一名暑期实习生，这是一家主要的视频游戏开发商。他们其中一款热门游戏《Lunatix
    Lander》让玩家试图将太空飞船降落到行星表面。这需要玩家点火推进器以将太空飞船与着陆点对准，并减缓速度以达到合理的着陆速度。游戏会显示玩家剩余燃料量以及执行某些操作所需的燃料量。
- en: As you test the game, you notice that it often reports that there is not enough
    fuel to perform a key maneuver when, in fact, you are certain there should be
    just the right amount of fuel. Your task is to figure out what’s wrong and find
    a way to fix it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你测试游戏时，你会注意到它经常报告说没有足够的燃料来执行关键操作，而事实上，你确定应该有足够的燃料。你的任务是找出问题所在并找到解决方法。
- en: Each of the rocket’s two fuel tanks has a capacity of 1000 units; the fuel gauge
    for each tank reports a value between 0 and 1.0, indicating the fraction of the
    capacity remaining in that tank. Here is an example of one of your tests, where
    `fuelNeeded` represents the fraction of a 1000 unit tank required to perform the
    maneuver, and `tank1` and `tank2` indicate the fraction of the capacity of each
    of the two tanks. The last statement is checking to see if the total amount of
    fuel in the two tanks equals or exceeds the fuel needed for the maneuver.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 火箭的两个燃料箱各自容量为1000单位；每个燃料箱的燃料计显示一个0到1.0之间的值，表示该箱中剩余容量与总容量的比例。这是你测试的一个示例，其中`fuelNeeded`表示执行操作所需的1000单位箱的比例，`tank1`和`tank2`表示两个燃料箱中各自容量的比例。最后一个语句是检查两个燃料箱中的燃料总量是否等于或超过执行操作所需的燃料量。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*Bummer!*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*糟糕！*'
- en: Notice that \(\frac{36}{1000} + \frac{6}{1000} = \frac{42}{1000}\) and the fuel
    needed is exactly \(\frac{42}{1000}\). Strangely though, the code reports that
    there is not enough fuel to perform the maneuver, dooming the ship to crash.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到\(\frac{36}{1000} + \frac{6}{1000} = \frac{42}{1000}\)，而所需的燃料正好是\(\frac{42}{1000}\)。但奇怪的是，代码报告说没有足够的燃料来执行操作，导致飞船坠毁。
- en: 'When you print the values of `fuelNeeded`, `tank1`, `tank2`, and `tank1 + tank2`
    you see the problem:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印出`fuelNeeded`、`tank1`、`tank2`和`tank1 + tank2`的值时，你会发现问题所在：
- en: '[![../Images/Alien8.PNG](../Images/Alien8.PNG)](../Images/Alien8.PNG)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien8.PNG](../Images/Alien8.PNG)](../Images/Alien8.PNG)'
- en: '*To be precise, imprecision occurs because computers use only a fixed number
    of bits of data to represent data. Therefore, only a finite number of different
    quantities can be stored. In particular, the fractional part of a floating-point
    number, the* mantissa, *must be rounded to the nearest one of the finite number
    of values that the computer can store, resulting in the kinds of unexpected behavior
    that we see here.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*准确地说，不精确性是因为计算机仅使用固定数量的数据位来表示数据。因此，只能存储有限数量的不同量。特别是，浮点数的小数部分，即*尾数*，必须舍入为计算机可以存储的有限数量的值之一，导致我们在这里看到的意外行为类型的结果。*'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*A rational thing to have!*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个理性的事情！*'
- en: This example of *numerical imprecision* is the result of the inherent error
    that arises when computers try to convert fractions into floating-point numbers
    (numbers with a decimal-point representation). However, assuming that all of the
    quantities that you measure on your rocket are always rational numbers—that is
    fractions with integer numerators and denominators—this imprecision problem can
    be avoided! How? Integers don’t suffer from imprecision. So, for each rational
    number, we can store its integer numerator and denominator and then do all of
    our arithmetic with integers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关于*数字不精确性*的例子是计算机试图将分数转换为浮点数（具有十进制表示的数字）时产生的固有误差的结果。然而，假设你的火箭上测量的所有量都是有理数——即分子和分母都是整数的分数——这个不精确性问题就可以避免！怎么做呢？整数不会受到不精确性的影响。因此，对于每个有理数，我们可以存储其整数分子和分母，然后使用整数进行所有算术运算。
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*Or even a* fraction *of them all*.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*甚至是*它们全部的*一部分*。'
- en: For example, the rational number \(\frac{36}{1000}\) can be stored as the pair
    of integers \(36\) and \(1000\) rather than converting it into a floating-point
    number. To compute \(\frac{36}{1000} + \frac{6}{1000}\) we can compute \(36+6
    = 42\) as the numerator and \(1000\) as the denominator. Comparing this to the
    `fuelNeeded` value of \(\frac{42}{1000}\) involves separately comparing the numerators
    and denominators, which involves comparing integers and is thus free from numerical
    imprecision.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有理数\(\frac{36}{1000}\)可以存储为整数对\(36\)和\(1000\)，而不是将其转换为浮点数。要计算\(\frac{36}{1000}
    + \frac{6}{1000}\)，我们可以计算分子为\(36+6 = 42\)，分母为\(1000\)。将这与\(\frac{42}{1000}\)的`fuelNeeded`值进行比较，涉及分别比较分子和分母，涉及比较整数，因此不受数值不精确性的影响。
- en: So, it would be great if Python had a way of dealing with rational numbers as
    pairs of integers. That is, we would like to have a “rational numbers” type of
    data (or *data type*, as computer scientists like to call it) just as Python has
    an integer data type, a string data type, and a list data type (among others).
    Moreover, it would be great if we could do arithmetic and comparisons of these
    rational numbers just as easily as we can do with integers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果Python有一种处理有理数的方法，将其作为整数对处理将会很好。也就是说，我们希望有一种“有理数”类型的数据（或*数据类型*，计算机科学家们喜欢这样称呼它），就像Python有整数数据类型、字符串数据类型和列表数据类型（以及其他类型）一样。此外，如果我们能够像处理整数一样轻松地进行这些有理数的算术和比较，那将会很好。
- en: The designers of Python couldn’t possibly predict all of the different data
    types that one might want. Instead, Python (like many other languages) has a nice
    way to let you, the programmer, define your own new types and then use them nearly
    as easily as you use the built-in types such as integers, strings, and lists.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Python的设计者不可能预测到程序员可能想要的所有不同数据类型。相反，Python（像许多其他语言一样）有一种很好的方式让你，程序员，定义自己的新类型，然后几乎和使用内置类型（如整数、字符串和列表）一样轻松地使用它们。
- en: This facility to define new types of data is called *object-oriented programming*
    or OOP and is the topic of this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 定义新类型数据的这种能力被称为*面向对象编程*或OOP，这是本章的主题。
- en: 6.3 The Rational Solution
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 有理解决方案
- en: 'Let’s get started by defining a rational number type. To do this, we build
    a Python “factory” for constructing rational numbers. This factory is called a
    *class* and it looks like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义有理数类型开始。为此，我们构建一个用于构造有理数的Python“工厂”。这个工厂被称为*类*，看起来像这样：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Don’t worry about the weird syntax; we’ll come back to that in a moment when
    we take a closer look at the details. For now, the big idea is that once we’ve
    written this `Rational` class (and saved it in a file with the same name but with
    the suffix `.py` at the end, in this case `Rational.py`) we can “manufacture”
    – or more technically *instantiate* – new rational numbers to our heart’s content.
    Here’s an example of calling this “factory” to instantiate two rational numbers
    \(\frac{36}{1000}\) and \(\frac{6}{1000}\):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心奇怪的语法；我们稍后将再次详细查看这一点。现在，大致的想法是一旦我们编写了这个 `Rational` 类（并将其保存在与文件名相同但以 `.py`
    作为后缀的文件中，本例中为 `Rational.py`），我们就可以随心所欲地“制造”——或更准确地说是*实例化*——新的有理数。以下是调用此“工厂”来实例化两个有理数
    \(\frac{36}{1000}\) 和 \(\frac{6}{1000}\) 的示例：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What’s going on here? When Python sees the instruction
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？当 Python 看到指令
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*Perhaps this is* `self` *-ish of Python.*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*也许这是* Python 的 `self` *-ish。*'
- en: it does two things. First, it instantiates an empty object which we’ll call
    `self`. Actually, `self` is a *reference* to this empty object as shown in Figure
    6.1.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了两件事。首先，它实例化一个空对象，我们将其称为 `self`。实际上，`self` 是对此空对象的 *引用*，如图 6.1 所示。
- en: '[![](../Images/self.svg)](../Images/self.svg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](../Images/self.svg)](../Images/self.svg)'
- en: 'Figure 6.1: `self` refers to a new empty object. It’s only empty for a moment!'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：`self` 指的是一个新的空对象。只是空了一会儿而已！
- en: Next, Python looks through the `Rational` class definition for a function named
    `__init__` (notice that there are two underscore characters before and after the
    word “init”). That’s a funny name, but it’s a convention in Python. Notice that
    in the definition of `__init__` above, that function seems to take *three* arguments,
    but the line `r1 = Rational(36, 1000)` has only supplied *two*. That’s weird,
    but—as you may have guessed—the first argument is passed in automatically by Python
    and is a reference to the new empty `self` object that we’ve just had instantiated
    for us.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Python 查找名为 `__init__` 的函数的 `Rational` 类定义（请注意，“init” 一词之前和之后都有两个下划线字符）。这是一个有趣的名称，但这是
    Python 中的一种约定。请注意，在上面的 `__init__` 定义中，该函数似乎接受 *三个* 参数，但是行 `r1 = Rational(36, 1000)`
    只提供了 *两个*。这很奇怪，但是——您可能已经猜到——第一个参数由 Python 自动传递，并且是对我们刚刚实例化的新空 `self` 对象的引用。
- en: The `__init__` function takes the reference to our new empty object called `self`,
    and it’s going to add some data to that object. The values \(36\) and \(1000\)
    are passed in to `__init__` as `num` and `denom`, respectively. Now, when the
    `__init__` function executes the line `self.numerator = num`, it says, “go into
    the object referenced by `self` , give it a variable called `numerator`, and give
    that variable the value that was passed in as `num`.” Similarly, the line `self.denominator
    = denom` says “go into the object referenced by `self`, give it a variable called
    `denominator`, and give that variable the value that was passed in as `denom`.”
    Note that the the names `num`, `denom`, `numerator`, and `denominator` are not
    special—they are just the names that we chose.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__` 函数获取我们称之为 `self` 的新空对象的引用，然后将一些数据添加到该对象中。值 \(36\) 和 \(1000\) 作为
    `num` 和 `denom` 分别传递给 `__init__`。现在，当 `__init__` 函数执行行 `self.numerator = num`
    时，它说：“进入由 `self` 引用的对象中，给它一个名为 `numerator` 的变量，并将该变量赋予作为 `num` 传入的值。” 类似地，行 `self.denominator
    = denom` 表示“进入由 `self` 引用的对象中，给它一个名为 `denominator` 的变量，并将该变量赋予作为 `denom` 传入的值。”
    请注意，名称 `num`、`denom`、`numerator` 和 `denominator` 并不特殊——它们只是我们选择的名称。'
- en: '[![../Images/Alien8.PNG](../Images/Alien8.PNG)](../Images/Alien8.PNG)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien8.PNG](../Images/Alien8.PNG)](../Images/Alien8.PNG)'
- en: '*Python uses the name “attributes” for the variables that belong to a class.
    Some other languages use names like “data members”, “properties”, “fields”, and
    “instance variables” for the same idea.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python 使用“attributes”这个名称来表示属于类的变量。其他一些语言使用“数据成员”、“属性”、“字段”和“实例变量”等名称来表示相同的概念。*'
- en: The variables `numerator` and `denominator` in the `__init__` function are called
    `attributes` of the `Rational` class. A class can have as many attributes as you
    wish to define for it. It’s pretty clear that a rational number class would have
    to have at least these two attributes!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__` 函数中的变量 `numerator` 和 `denominator` 被称为 `Rational` 类的 `attributes`。一个类可以拥有您想为其定义的任意多个属性。很明显，有理数类至少必须有这两个属性！'
- en: The last thing that happens in the line
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 行末的最后一件事
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'is that the variable `r1` is now assigned to be a reference to the object that
    Python just created and we initialized. We can see the contents of the rational
    numbers as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在变量`r1`被分配为对Python刚刚创建并初始化的对象的引用。我们可以如下查看有理数的内容：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We used the “dot” in the function `__init__` as well, when we said `self.numerator
    = num`. The “dot” was doing the same thing there. It said, “go into the `self`
    object and look at the attribute named `numerator`.” Figure 6.2 shows the situation
    now.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说`self.numerator = num`时，我们也在函数`__init__`中使用了“点”。在那里，“点”也在做同样的事情。它说，“进入`self`对象并查看名为`numerator`的属性。”图6.2现在显示了这种情况。
- en: '[![](../Images/r1.svg)](../Images/r1.svg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](../Images/r1.svg)](../Images/r1.svg)'
- en: 'Figure 6.2: `r1` refers to the `Rational` object with its `numerator` and `denominator`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：`r1`指向具有其`numerator`和`denominator`的`Rational`对象。
- en: We note that in our figures in this chapter, we’re representing memory in a
    somewhat different (and simpler) way than we used in Chapter 5\. For example,
    Figure 6.2 shows the values of numerator and denominator as if they were stored
    inside the variables. In reality, as we saw in Chapter 5, the integer values would
    be somewhere else in memory, and the variables would store references to those
    values.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，在本章的图中，我们以一种有些不同（更简单）的方式表示内存，而不是我们在第5章中使用的方式。例如，图6.2显示了分子和分母的值，就好像它们存储在变量内部一样。实际上，正如我们在第5章中看到的那样，整数值会存储在内存的其他位置，而变量将存储对这些值的引用。
- en: 'In our earlier example, we “called” the `Rational` “factory” twice to instantiate
    two different rational numbers in the example below:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们两次“调用”`Rational`“工厂”来实例化下面示例中的两个不同有理数：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first call, `Rational(36, 1000)` instantiated a rational number, `self`,
    with `numerator` \(36\) and `denominator` \(1000\). This was called `self`, but
    then we assigned `r1` to refer to this object. Similarly, the line `r2.numerator`
    is saying, “go to the object called `r2` and look at its attribute named `numerator`.”
    It’s important to keep in mind that since `r1` and `r2` are referring to two different
    objects, each one has its “personal” `numerator` and `denominator`. This is shown
    in Figure 6.3.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个调用，`Rational(36, 1000)`实例化了一个有理数，`self`，具有`numerator` \(36\) 和 `denominator`
    \(1000\)。这被称为`self`，但然后我们将`r1`赋给这个对象。同样，`r2.numerator`这一行是在说，“去到名为`r2`的对象并查看其名为`numerator`的属性。”重要的是要记住，由于`r1`和`r2`指向两个不同的对象，每个对象都有其“个人”的`numerator`和`denominator`。这在图6.3中显示。
- en: '[![](../Images/r1andr2.svg)](../Images/r1andr2.svg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](../Images/r1andr2.svg)](../Images/r1andr2.svg)'
- en: 'Figure 6.3: Two `Rational` numbers with references `r1` and `r2`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：具有引用`r1`和`r2`的两个`Rational`数。
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*This would be a short chapter if that was the whole story!*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果这就是整个故事，那这将是一个简短的章节！*'
- en: Let’s take stock of what we’ve just seen. First, we defined a factory—technically
    known as a *class*–called `Rational`. This `Rational` class describes a template
    for manufacturing a new type of data. That factory can now be used to instantiate
    a multitude of items—technically known as *objects*–of that type. Each object
    will have its own variables – or “attributes” – in this case `numerator` and `denominator`,
    each with their own values.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们刚刚看到的内容。首先，我们定义了一个工厂——在技术上称为*类*——名为`Rational`。这个`Rational`类描述了制造一种新数据类型的模板。这个工厂现在可以用来实例化多种项目——在技术上称为*对象*——属于这种类型。每个对象都有自己的变量——或“属性”——在这种情况下是`numerator`和`denominator`，每个都有自己的值。
- en: That’s cute, but is that it? Remember that our motivation for defining the `Rational`
    numbers was to have a way to manipulate (add, compare, etc.) rational numbers
    without having to convert them to the floating-point world where numerical imprecision
    can cause headaches (and rocket failures, and worse).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这很可爱，但这就是全部吗？记住，我们定义`Rational`数的动机是为了有一种方法来操作（相加、比较等）有理数，而不必将它们转换为浮点数世界，其中数值不精确可能会引起头痛（以及火箭失败等）。
- en: Python’s built-in data types (such as integers, floating-point numbers, and
    strings) have the ability to be added, compared for equality, etc. We’d like our
    `Rational` numbers to have these abilities too! We’ll begin by adding a function
    to the `Rational` class that will allow us to add one Rational to another and
    return the sum, which will be a `Rational` as well. A function defined inside
    a class has a special fancy name—it’s called a *method* of that class. The `__init__`
    method is known as the *constructor* method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Python的内置数据类型（如整数、浮点数和字符串）具有可以相加、比较相等等功能。我们希望我们的`Rational`数也具有这些功能！我们将首先向`Rational`类添加一个函数，允许我们将一个Rational加到另一个上并返回和，这个和也将是一个`Rational`。在类内定义的函数有一个特殊的花哨名称——它被称为该类的*方法*。`__init__`方法被称为*构造方法*。
- en: 'Our `add` method in the `Rational` class will be used like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Rational`类中的`add`方法将像这样使用：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This should return a `Rational` number that is the result of adding `r1` and
    `r2`. So, we should be able to write:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回一个`Rational`数，即`r1`和`r2`相加的结果。因此，我们应该能够写：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, `r3` will refer to the new `Rational` number returned by the `add` method.
    The syntax here may struck you as funny at first, but humor us; we’ll see in a
    moment why this syntax is sensible.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`r3`将引用`add`方法返回的新`Rational`数。这里的语法可能一开始让你觉得有趣，但请容许我们；我们马上就会看到为什么这种语法是合理的。
- en: 'Let’s write this `add` method! If `r1` \(= \frac{a}{b}\) and `r2` \(= \frac{c}{d}\)
    then `r1+r2` \(= \frac{ad+bc}{bd}\). Note that the resulting fraction might be
    simplified by dividing out by terms that are common to the numerator and the denominator,
    but let’s not worry about that for now. Here is the `Rational` class with its
    shiny new `add` method:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写这个`add`方法！如果`r1` \(= \frac{a}{b}\) 和 `r2` \(= \frac{c}{d}\) 那么 `r1+r2` \(=
    \frac{ad+bc}{bd}\)。请注意，由于分子和分母中可能有共同项，导致的结果分数可能会被简化，但现在我们不用担心这个。这里是带有全新`add`方法的`Rational`类：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What’s going on here!? Notice that the `add` method takes in two arguments,
    `self` and `other`, while our examples above showed this method taking in a single
    argument. (Stop here and think about this. This is analogous to what we saw earlier
    with the `__init__` method.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么！？注意`add`方法接受两个参数，`self`和`other`，而我们上面的例子显示这个方法接受一个参数。 （停下来思考一下。这类似于我们之前看到的`__init__`方法。）
- en: 'To sort this all out, let’s consider the following sequence:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了搞清楚这一切，让我们考虑以下顺序：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The instruction `r1.add(r2)` does something funky: It calls the `Rational`
    class’s `add` method. It seems to pass in just `r2` to the `add` method but that’s
    an optical illusion! In fact, it passes in two values: *first* it *automatically*
    passes a reference to `r1` and *then* it passes in `r2`. This is great, because
    our code for the `add` method is expecting two arguments: `self` and `other`.
    So, `r1` goes into the `self` “slot” and `r2` goes into the `other` slot. Now,
    the `add` method can operate on those two `Rational` numbers, add them, construct
    a new `Rational` number representing their sum, and then return that new object.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 指令`r1.add(r2)`做了一些有趣的事情：它调用了`Rational`类的`add`方法。它似乎只传入`r2`到`add`方法，但这是一种视觉错觉！实际上，它传入了两个值：*首先*它*自动*传入了对`r1`的引用，*然后*传入了`r2`。这很棒，因为我们的`add`方法的代码期望两个参数：`self`和`other`。因此，`r1`进入`self`“槽”，`r2`进入`other`槽。现在，`add`方法可以对这两个`Rational`数进行操作，将它们相加，构造一个代表它们和的新`Rational`数，然后返回该新对象。
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*“Snazzy” is a technical term.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*“时髦”是一个技术术语。*'
- en: 'Here’s the key: Consider some arbitrary class `Blah`. If we have an object
    `myBlah` of type `Blah`, then `myBlah` can invoke a method `foo` with the notation
    `myBlah.foo(arg1, arg2, ..., argN)`. The method `foo` will receive *first* a reference
    to the object `myBlah` followed by all of the `N` arguments that are passed in
    explicitly. Python just knows that the first argument is always the automatically-passed-in
    reference to the object before the “dot”. The beauty of this seemingly weird system
    is that the method is invoked by an object and the method “knows” which object
    invoked it. Snazzy!'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关键：考虑一些任意的类`Blah`。如果我们有一个类型为`Blah`的对象`myBlah`，那么`myBlah`可以使用`myBlah.foo(arg1,
    arg2, ..., argN)`的表示法调用一个名为`foo`的方法。方法`foo`将*首先*接收到对对象`myBlah`的引用，然后是所有显式传入的`N`个参数。Python只知道第一个参数始终是自动传入的引用到“点”之前的对象。这种看似奇怪的系统之美在于方法由对象调用，方法“知道”哪个对象调用了它。时髦！
- en: 'After performing the above sequence of instructions, we could type:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行上述一系列指令后，我们可以输入：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What we would we see? We’d see the numerator and denominator of the `Rational`
    number `r3`. In this case, the numerator would be \(5\) and the denominator would
    be \(6\).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会看到什么？我们会看到`Rational`数`r3`的分子和分母。在这种情况下，分子将是\(5\)，分母将是\(6\)。
- en: Notice that instead of typing `r3 = r1.add(r2)` above, we could have instead
    have typed `r3 = r2.add(r1)`. What would have happened here? Now, `r2` would have
    called the `add` method, passing `r2` in for `self` and `r1` in for `other`. We
    would have gotten the same result as before because addition of rationals is commutative.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与其在上面输入`r3 = r1.add(r2)`，我们可以输入`r3 = r2.add(r1)`。这里会发生什么？现在，`r2`将调用`add`方法，将`r2`传递给`self`，将`r1`传递给`other`。我们会得到与之前相同的结果，因为有理数的加法是可交换的。
- en: 6.4 Overloading
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 重载
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*“Spiffy” is yet another technical term.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*“时髦”是另一个技术术语。*'
- en: So far, we have built a basic class for representing rational numbers. It’s
    neat and useful, but now we’re about to make it even spiffier.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了一个表示有理数的基本类。它既整洁又有用，但现在我们将使它更加时髦。
- en: You probably noticed that the syntax for adding two `Rational` numbers is a
    bit awkward. When we add two integers, like \(42\) and \(47\), we certainly don’t
    type `42.add(47)`, we type `42+47` instead.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，添加两个`Rational`数的语法有点奇怪。当我们添加两个整数，比如\(42\)和\(47\)时，我们当然不会输入`42.add(47)`，而是输入`42+47`。
- en: 'It turns out that we can use the operator “`+`” to add `Rational` numbers too!
    Here’s how: We simply change the name of our `add` method to `__add__`. Those
    are two underscore characters before and two underscore characters after the word
    `add`. Python has a feature that says “if a function is named `__add__` then when
    the user types `r1 + r2`, I will translate that into `r1.__add__(r2)`.” How does
    Python know that the addition here is addition of `Rational` numbers rather than
    addition of integers (which is built-in)? It simply sees that `r1` is a `Rational`,
    so the “`+`” symbol must represent the `__add__` method in the `Rational` class.
    We could similarly define `__add__` methods for other classes and Python will
    figure out which one applies based on the type of data in front of the “`+`” symbol.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们也可以使用运算符“`+`”来相加`Rational`数！方法是：我们只需将我们的`add`方法更改为`__add__`。在单词`add`之前和之后有两个下划线字符。Python有一个功能，它说“如果一个函数命名为`__add__`，那么当用户输入`r1
    + r2`时，我将把它翻译成`r1.__add__(r2)`。” Python如何知道这里的加法是`Rational`数的加法而不是整数的加法（这是内置的）？它只是看到`r1`是一个`Rational`，所以“`+`”符号必须表示`Rational`类中的`__add__`方法。我们也可以为其他类定义`__add__`方法，Python将根据“`+`”符号前面的数据类型来确定应用哪个方法。
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*This is “good” overloading. “Bad” overloading involves taking more than 18
    credits in a term.*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是“好”的重载。在一个学期中选修超过18学分则是“坏”的重载。*'
- en: This feature is called *overloading*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性被称为*重载*。
- en: We have overloaded the “`+`” symbol to give it a meaning that depends on the
    context in which it is used. Many, though not all, object-oriented programming
    languages support overloading. In Python, overloading addition is just the tip
    of the iceberg. Python allows us to overload all of the normal arithmetic operators
    and all of the comparison operators such as “`==`”, “`!=`”, “`<`”, among others.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经重载了“`+`”符号，赋予它根据使用环境而变化的含义。许多面向对象的编程语言支持重载，尽管不是所有的语言都支持。在Python中，重载加法只是冰山一角。Python允许我们重载所有常规算术运算符以及所有比较运算符，如“`==`”、“`!=`”、“`<`”等等。
- en: 'Let’s think for a moment about comparing rational numbers for equality. Consider
    the following scenario, in which we have two different `Rational` objects and
    we compare them for equality:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下关于比较有理数是否相等的问题。考虑以下情景，我们有两个不同的`Rational`对象，并将它们进行相等比较：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*“Blob” really* is *a technical term!*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*“Blob”真的*是*一个技术术语！*'
- en: Why did Python say “`False`”? The reason is that even though `r1` and `r2` *look*
    the same to us, each one is a reference to a *different* object. The two objects
    have identical contents, but they are different nonetheless, just as two identical
    twins are two different people. Another way of seeing this is that `r1` and `r2`
    refer to different blobs of memory, and when Python sees them ask if `r1 == r2`
    it says “Nope! Those two references are not to the same memory location.” Since
    we haven’t told Python how to compare `Rational`s in any other way, it simply
    compares `r1` and `r2` to see if they are referring to the very same object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么Python说“`False`”？原因是尽管对于我们来说`r1`和`r2`*看起来*是一样的，但每一个都是指向*不同*对象的引用。这两个对象具有相同的内容，但它们仍然是不同的，就像两个相同的双胞胎是两个不同的人一样。另一种看待这个问题的方式是`r1`和`r2`指向不同的内存块，当Python看到它们询问`r1
    == r2`时，它会说“不！这两个引用不是指向同一个内存位置的。”由于我们没有告诉Python如何以其他方式比较`Rational`，它只是比较`r1`和`r2`看它们是否指向完全相同的对象。
- en: 'So let’s “overload” the “`==`” symbol to correspond to a function that will
    do the comparison as we intend. We’d like for two rational numbers to be considered
    equal if their ratios are the same, even if their numerators and denominators
    are not the same. For example \(\frac{1}{2} = \frac{42}{84}\). One way to test
    for equality is to use the “cross-multiplying” method that we learned in grade
    school: Multiply the numerator of one of the fractions by the denominator of the
    other and check if this is equal to the other numerator-denominator product. Let’s
    first write a method called `__eq__` to include in our `Rational` number class
    to test for equality.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们“重载”“`==`”符号，使其对应于我们想要的比较函数。我们希望如果两个有理数的比值相同，即使它们的分子和分母不同，也被视为相等。例如\(\frac{1}{2}
    = \frac{42}{84}\)。一个测试相等的方法是使用我们在小学学到的“交叉乘法”方法：将一个分数的分子乘以另一个的分母，并检查这是否等于另一个分子乘以分母的乘积。让我们首先编写一个名为`__eq__`的方法，包含在我们的`Rational`数类中以测试相等性。
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, if we have two rational numbers such as `r1` and `r2`, we could invoke
    this method with `r1.__eq__(r2)` or with `r2.__eq__(r1)`. But because we’ve used
    the special name `__eq__` for this method, Python will know that when we write
    `r1 == r2` it should be translated into `r1.__eq__(r2)`. There are many other
    symbols that can be overloaded. (To see a complete list of the methods that Python
    is happy to have you overload, go to [http://docs.python.org/2/reference/datamodel.html#special-method-names](http://docs.python.org/2/reference/datamodel.html#special-method-names).)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们有两个有理数，比如`r1`和`r2`，我们可以用`r1.__eq__(r2)`或者`r2.__eq__(r1)`来调用这个方法。但是因为我们用了特殊名称`__eq__`来命名这个方法，Python会知道当我们写`r1
    == r2`时，它应该被翻译成`r1.__eq__(r2)`。还有许多其他可以被重载的符号。（要查看Python乐意让你重载的方法的完整列表，请访问[http://docs.python.org/2/reference/datamodel.html#special-method-names](http://docs.python.org/2/reference/datamodel.html#special-method-names)。）
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*This example serves to doubly underscore the beauty of overloading!*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个例子再次强调了重载的美妙之处！*'
- en: 'For example, we can overload the “`>=`” symbol by defining a method called
    `__ge__` (which stands for **g**reater than or **e**qual). Just like `__eq__`,
    this method takes two arguments: A reference to the *calling object* that is passed
    in automatically (`self`) and a reference to another object to which we are making
    the comparison. So, we could write our `__ge__` method as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过定义一个名为`__ge__`的方法（代表**g**reater than或**e**qual）来重载“`>=`”符号。就像`__eq__`一样，这个方法接受两个参数：自动传入的调用对象的引用（`self`）和我们要进行比较的另一个对象的引用。因此，我们可以将我们的`__ge__`方法写成如下形式：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that there is only a tiny difference between how we implemented our `__eq__`
    and `__ge__` methods. Take a moment to make sure you understand why `__ge__` works.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们实现`__eq__`和`__ge__`方法之间只有微小的差异。花点时间确保您理解为什么`__ge__`起作��。
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*We hope that you aren’t feeling overloaded at this point. We’d feel bad if
    you “object”ed to what we’ve done here.*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们希望您此时不感到过载。如果您对我们在这里所做的事情提出异议，我们会感到抱歉。*'
- en: 'Finally, let’s revisit the original fuel problem with which we started the
    chapter. Recall that due to numerical imprecision with floating-point numbers,
    we had experienced mission failure:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们重新审视我们在本章开始时遇到的原始燃料问题。回想一下，由于浮点数的数值不精确，我们曾经经历过任务失败：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In contrast, we can now use our slick new `Rational` class to save the mission!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，我们现在可以使用我们新的`Rational`类来拯救任务！
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Mission accomplished!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成！
- en: 6.5 Printing an Object
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 打印一个对象
- en: 'Our `Rational` class is quite useful now. But check this out:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Rational`类现在非常有用。但是看看这个：
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*0x6b918!? What the heck is that?!*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*0x6b918!? 这是什么鬼？！*'
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice the strange output when we asked for `r3` or when we tried to `print(r3)`.
    In both cases, Python is telling us, “`r3` is a `Rational` object and I’ve given
    it a special internal name called `0x` blah, blah, blah.”
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当我们要求`r3`或尝试`print(r3)`时的奇怪输出。在这两种情况下，Python告诉我们，“`r3`是一个`Rational`对象，我给它一个名为`0x`的特殊内部名称，等等，等等。”
- en: 'What we’d really like, at least when we `print(r3)`, is for Python to display
    the number in some nice way so that we can see it! You may recall that Python
    has a way to “convert” integers and floating-point numbers into strings using
    the built-in function `str`. For example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，至少当我们`print(r3)`时，我们希望Python以一种好看的方式显示数字，以便我们可以看到它！你可能还记得Python有一种方法，可以使用内置函数`str`将整数和浮点数转换为字符串。例如：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So, since the `print` function wants to print strings, we can print numbers
    this way:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，由于`print`函数想要打印字符串，我们可以这样打印数字：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In fact, other Python types such as lists and dictionaries also have `str`
    functions:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，其他Python类型如列表和字典也有`str`函数：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Python lets us define a `str` function for our own classes by overloading a
    special method called `__str__`. For example, for the `Rational` class, we might
    write the following `__str__` method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许我们通过重载一个名为`__str__`的特殊方法为我们自己的类定义`str`函数。例如，对于`Rational`类，我们可以编写以下`__str__`方法：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What is this function returning? It’s a string that contains the numerator
    followed by a forward slash followed by the denominator. When we type `print(str(r3))`,
    Python will invoke this `__str__` method. That function first calls the `str`
    function on `self.numerator`. Is the call `str(self.numerator)` recursive? It’s
    not! Since `self.numerator` is an integer, Python knows to call the `str` method
    for integers here to get the string representation of that integer. Then, it concatenates
    to that string a another string containing the forward slash, `/`, indicating
    the fraction line. Finally, to that string it concatenates the string representation
    of the denominator. Now, this string is returned. So, in our running example from
    above where `r3` is the rational number \(\frac{5}{6}\), we could use our `str`
    method as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回什么？这是一个包含分子后跟分母的字符串。当我们输入`print(str(r3))`时，Python将调用这个`__str__`方法。该函数首先调用`self.numerator`的`str`函数。这个调用`str(self.numerator)`是递归的吗？不是！由于`self.numerator`是一个整数，Python知道在这里调用整数的`str`方法以获得该整数的字符串表示。然后，它将这个字符串与另一个包含斜杠`/`的字符串连接起来，表示分数线。最后，将分母的字符串表示连接到该字符串。现在，返回这个字符串。因此，在我们上面的运行示例中，`r3`是有理数\(\frac{5}{6}\)，我们可以如下使用我们的`str`方法：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that in the first line when we ask for `r3`, Python just tells us that
    it is a reference to `Rational` object. In the third line, we ask to convert `r3`
    into a string for use in the `print` function. By the way, the `__str__` method
    has a closely related method named `__repr__` that you can read about on the Web.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第一行当我们要求`r3`时，Python只告诉我们它是一个`Rational`对象的引用。在第三行，我们要求将`r3`转换为字符串以在`print`函数中使用。顺便说一句，`__str__`方法有一个密切相关的名为`__repr__`的方法，你可以在网上阅读相关信息。
- en: 6.6 A Few More Words on the Subject of Objects
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 关于对象的一些补充说明
- en: Let’s say that we wanted (for some reason) to change the numerator of `r1` from
    its current value to 42\. We could simply type
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要（出于某种原因）将`r1`的分子从当前值更改为42。我们可以简单地输入
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In other words, the internals of a `Rational` object can be changed. Said another
    way, the `Rational` class is mutable. (Recall our discussion of mutability in
    Chapter 5.) *In Python, classes that we define ourselves are mutable (unless we
    add fancy special features to make them immutable).* To fully appreciate the significance
    of mutability of objects, consider the following pair of functions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`Rational`对象的内部可以被改变。换句话说，`Rational`类是可变的。（回想一下我们在第5章讨论的可变性。）*在Python中，我们自己定义的类是可变的（除非我们添加了特殊功能使其不可变）。*为了充分理解对象的可变性的重要性，请考虑以下一对函数：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What happens when we invoke function `foo`? Notice that function `bar` is not
    returning anything. However, the variable `number` that it receives is presumably
    a `Rational` number, and `foo` increments the value of this variable’s `numerator`.
    Since user-defined classes such as `Rational` are mutable, this means that the
    `Rational` object that was passed in will have its numerator changed!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用函数 `foo` 时会发生什么？注意，函数 `bar` 并不返回任何东西。然而，它接收到的变量 `number` 可能是一个 `Rational`
    数，而 `foo` 会增加这个变量的 `numerator` 值。由于用户定义的类（如 `Rational`）是可变的，这意味着传入的 `Rational`
    对象的 `numerator` 将被更改！
- en: How does this actually work? Notice that in the function `foo`, the variable
    `r` is a reference to the `Rational` number \(\frac{1}{3}\). In other words, this
    `Rational` object is somewhere in the computer’s memory and `r` is the address
    where this blob of memory resides. When `foo` calls `bar(r)` it is passing the
    reference (the memory location) `r` to `foo`. Now, the variable `number` is referring
    to that memory location. When Python sees `number.numerator += 1` it first goes
    to the memory address referred to by `number`, then uses the “dot” to look at
    the `numerator` part of that object, and increments that value by 1\. When `bar`
    eventually returns control to the calling function, `foo`, the variable `r` in
    `foo` is still referring to that same memory location, but now the `numerator`
    in that memory location has the new value that `bar` set.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是如何工作的呢？注意，在函数 `foo` 中，变量 `r` 是对有理数 \(\frac{1}{3}\) 的引用。换句话说，这个 `Rational`
    对象在计算机内存中的某个位置，而 `r` 是这块内存所在的地址。当 `foo` 调用 `bar(r)` 时，它将引用（内存位置）`r` 传递给 `foo`。现在，变量
    `number` 引用了那个内存位置。当 Python 看到 `number.numerator += 1` 时，它首先访问 `number` 引用的内存地址，然后使用“点”来查看该对象的
    `numerator` 部分，并将该值增加 1。当 `bar` 最终将控制权返回给调用函数 `foo` 时，`foo` 中的变量 `r` 仍然引用同一内存位置，但现在该内存位置的
    `numerator` 已经被 `bar` 设置为新值。
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*Our legal team objected to us using the word “everything” here, but it’s close
    enough to the truth that we’ll go with it.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们的法律团队反对我们在这里使用“一切”这个词，但它已经足够接近事实，所以我们就接受了。*'
- en: 'This brings us to a surprising fact: *Everything in Python is an object!* For
    example, Python’s list datatype is an object. “Wait a second!” we hear you exclaim.
    “The syntax for using lists doesn’t look anything like the syntax that we used
    for using `Rational`s!” You have a good point, but let’s take a closer look.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来了一个令人惊讶的事实：*Python 中的一切都是对象！*例如，Python 的列表数据类型就是一个对象。“等一下！”我们听到你惊叹道。“使用列表的语法看起来完全不像我们用于使用
    `Rational` 的语法！”你说得有道理，但让我们仔细看看。
- en: 'For the case of `Rational`s, we had to make a new object this way:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Rational` 的���况，我们必须通过以下方式创建一个新对象：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On the other hand, we can make a new list more simply:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以更简单地创建一个新列表：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In fact, though, this list notation that you’ve grown to know and love is just
    a convenience that the designers of Python have provided for us. It’s actually
    a shorthand for this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你已经熟悉并喜爱的这种列表表示法只是 Python 设计者为我们提供的一种便利。实际上，这只是一个缩写：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, if we ask Python to show us `myList` it will show us that it is the list
    `[42, 1, 3]`. Notice that the line `myList = list()` is analogous to `r = Rational(1,
    3)` except that we do not provide any initial values for the list. Then, the `append`
    method of the list class is used to append items onto the end of our list. Lists
    are mutable, so each of these `append`s changes the list!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们要求 Python 显示 `myList`，它会显示我们的列表是 `[42, 1, 3]`。注意，`myList = list()` 这一行类似于
    `r = Rational(1, 3)`，只是我们没有为列表提供任何初始值。然后，列表类的 `append` 方法用于将项目附加到列表的末尾。列表是可变的，因此每个
    `append` 都会改变列表！
- en: 'Indeed, the list class has many other methods that you can learn about online.
    For example, the `reverse` method reverses a list. Here’s an example, based on
    the `myList` list object that we created above:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，列表类还有许多其他方法，你可以在网上了解到。例如，`reverse` 方法可以反转一个列表。以下是一个示例，基于我们之前创建的 `myList`
    列表对象：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that this `reverse` method is not returning a new list but rather mutating
    the list on which it is being invoked.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个 `reverse` 方法并不返回一个新列表，而是改变了被调用的列表。
- en: 'Before moving on, let’s reflect for a moment on the notation that we’ve seen
    for combining two lists:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们稍微思考一下我们已经看到的关于合并两个列表的表示法：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How do you think that the “`+`” symbol works here? You got it–it’s an overloaded
    method in the list class! That is, it’s the `__add__` method in that class!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为这里的“`+`”符号是如何工作的？你猜对了 - 这是列表类中的一个重载方法！也就是说，这是该类中的`__add__`方法！
- en: Strings, dictionaries, and even integers and floats are all objects in Python!
    However, a few of these built-in types - such as strings, integers, and floats
    - were designed to be immutable. Recall from the previous chapter that this means
    that their internals cannot be changed. You can define your own objects to be
    immutable as well, but it requires some effort and it’s rarely necessary, so we
    won’t go there.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串、字典，甚至整数和浮点数在Python中都是对象！然而，其中一些内置类型 - 如字符串、整数和浮点数 - 被设计为不可变的。回想一下前一章节中提到的，这意味着它们的内部不能被改变。你也可以定义自己的不可变对象，但这需要一些努力，而且很少是必要的，所以我们不会深入讨论。
- en: 6.7 Getting Graphical with OOPs
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 使用面向对象编程进行图形化
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*Warning! This section contains graphical language!*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*警告！本节包含图形化语言！*'
- en: We’ve seen that object-oriented programming is elegant and, hopefully, you now
    believe that it’s useful. But what about 3D graphics and our video game? That’s
    where we’re headed next!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到面向对象编程是优雅的，希望你现在相信它是有用的。但是关于3D图形和我们的视频游戏呢？那就是我们接下来要去的地方！
- en: To get started, you’ll need to get the “Jupyter VPython” 3D graphics system
    for Python 3\. You can install it by running `pip install vpython` at the command
    prompt. You should also make sure you have the most recent version of Anaconda
    installed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，你需要获取“Jupyter VPython” Python 3D 图形系统。你可以通过在命令提示符下运行`pip install vpython`来安装它。你还应该确保你安装了最新版本的Anaconda。
- en: Once you have VPython installed, run `jupyter notebook` from the command prompt.
    A window should pop up in your browser. In that window, select the New button
    on the upper right, then select VPython under Notebooks.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了VPython后，从命令提示符运行`jupyter notebook`。一个窗口应该会在你的浏览器中弹出。在那个窗口中，选择右上角的新建按钮，然后在笔记本下选择VPython。
- en: 'In the new window that pops up, you’ll need to import [``](#id1)vpython as
    follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹出的新窗口中，你需要按照以下方式导入[``](#id1)vpython：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, in the same cell, type:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在同一个单元格中，输入：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Then hit the Run button. A white box should pop up in a small window below the
    cell (the box you typed into). If you change your code and want to re-run your
    code, you will need to click the Restart the Kernel button (near the Run button),
    then click the red Restart button in the box that pops up. Then wait for a blue
    Kernel Ready message to flash in the upper right hand corner, and then press Run.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后点击运行按钮。一个白色框应该会在单元格下方的一个小窗口中弹出（你输入的框）。如果你改变了代码并想要重新运行代码，你需要点击重新启动内核按钮（在运行按钮附近），然后点击弹出框中的红色重新启动按钮。然后等待右上角出现蓝色内核就绪消息，然后按运行。
- en: '[![../Images/Alien8.PNG](../Images/Alien8.PNG)](../Images/Alien8.PNG)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien8.PNG](../Images/Alien8.PNG)](../Images/Alien8.PNG)'
- en: '*In the display window (where the box is displayed), click and drag with the
    right mouse button (hold down the command key on a Macintosh). Drag left or right,
    and you rotate around the scene. To rotate around a horizontal axis, drag up or
    down. Click and drag up or down with the middle mouse button to move closer to
    the scene or farther away (on a 2-button mouse, hold down the left and right buttons;
    on a 1-button mouse, hold down the Option key).*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*在显示窗口（显示盒子的地方），用鼠标右键点击并拖动（在Macintosh上按住命令键）。向左或向右拖动，你会围绕场景旋转。要围绕水平轴旋转，向上或向下拖动。用鼠标中键向上或向下拖动，可以使场景更近或更远（在2按钮鼠标上，按住左右按钮；在1按钮鼠标上，按住Option键）。*'
- en: What you’ll see now on the screen is a white box. It might look more like a
    white square, so rotate it around to see that it’s actually a 3D object.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你在屏幕上看到的是一个白色的盒子。它可能看起来更像一个白色的正方形，所以旋转它看看它实际上是一个3D对象。
- en: As you may have surmised, `box` is a class defined in the `vpython` module.
    The command
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，`box`是在`vpython`模块中定义的一个类。命令
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: invoked the constructor to create a new `box` object and we made `b` be the
    name, or more precisely “a reference”, to that box.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 调用构造函数来创建一个新的`box`对象，我们让`b`成为该盒子的名称，或者更准确地说是“一个引用”。
- en: 'Just like our `Rational` number class had `numerator` and `denominator` attributes,
    the `box` class has a number of attributes as well. Among these are the box’s
    length, height, and width; its position, its color, and even its material properties.
    Try changing these attributes at the command line as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的 `Rational` 数字类有 `numerator` 和 `denominator` 属性一样，`box` 类也有许多属性。其中包括盒子的长度、高度和宽度；它的位置、颜色，甚至材质属性。尝试在命令行中更改这些属性如下：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we initially made our `b = box()` it had “default” values for all of these
    attributes. The `length`, `width`, and `height` attributes were all 1.0, the `color`
    attribute was white, and the `textures` attribute was a boring basic one. Notice
    that some of the attributes of a `box` are fairly obvious: `length`, `width`,
    and `height` are all numbers. However, the `color` attribute is weird. Similarly,
    the `texture` property was set in a strange way. Let’s take a closer look at just
    one of these attributes and you can read more about others later on the VPython
    documentation website. (You will want to look up ‘Glowscript documentation’. If
    you only search for ‘vpython documentation’, you will only find the documentation
    for Classic VPython, the predecessor of Jupyter VPython.)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最初创建 `b = box()` 时，所有这些属性都具有“默认”值。`length`、`width` 和 `height` 属性都是 1.0，`color`
    属性是白色，`textures` 属性是一个无聊的基本纹理。请注意，`box` 的一些属性相当明显：`length`、`width` 和 `height`
    都是数字。然而，`color` 属性很奇怪。同样，`texture` 属性设置方式也很奇怪。让我们仔细看看其中一个属性，稍后您可以在VPython文档网站上阅读更多关于其他属性的信息。（您需要查阅‘Glowscript文档’。如果您只搜索‘vpython文档’，您只会找到Classic
    VPython的文档，这是Jupyter VPython的前身。）
- en: 'Clear the cell you are in (except for the import statement). Let’s make a new
    box and ask Python for its color attribute by running the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 清除您所在的单元格（除了导入语句）。让我们创建一个新的盒子，并通过运行以下代码询问Python其颜色属性：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: VPython represents color using a tuple with three values, each between \(0.0\)
    and \(1.0\). The three elements in this tuple indicate how much red (from \(0.0\),
    which is none, to \(1.0\), which is maximum), green, and blue, respectively, is
    in the color of the object.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: VPython 使用一个包含三个值的元组来表示颜色，每个值都介于 \(0.0\) 和 \(1.0\) 之间。元组中的三个元素分别表示对象颜色中的红色（从
    \(0.0\)，即无色，到 \(1.0\)，即最大值），绿色和蓝色的量。
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*If your roommate sees you staring at your fingers, just explain that you are
    doing something very technical.*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您的室友看到您盯着手指看，只需解释您在做一些非常技术性的事情。*'
- en: So, \((1.0, 1.0, 1.0)\) means that we are at maximum of each color, which amounts
    to bright white. The tuple \((1.0, 0.0, 0.0)\) is bright red and the tuple \((0.7,
    0.0, 0.4)\) is a mixture of quite a bit of red and somewhat less blue.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，\((1.0, 1.0, 1.0)\) 意味着我们每种颜色都达到最大值，这相当于明亮的白色。元组 \((1.0, 0.0, 0.0)\) 是明亮的红色，元组
    \((0.7, 0.0, 0.4)\) 是相当多的红色和较少的蓝色的混合。
- en: 'The `box` class has another attribute called `pos` that stores the position
    of the center of the box. The coordinate system used by VPython is what’s called
    a “right-handed” coordinate system: If you take your right hand and stick out
    your thumb, index finger, and middle finger so that they are perpendicular to
    one another with your palm facing you, the positive \(x\) axis is your thumb,
    the positive \(y\) axis is your index finger, and the positive \(z\) axis is your
    middle finger.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`box` 类还有一个名为 `pos` 的属性，用于存储盒子中心的位置。VPython 使用的坐标系是所谓的“右手”坐标系：如果你伸出右手，将拇指、食指和中指垂直放置，手掌朝向你，正
    \(x\) 轴是你的拇指，正 \(y\) 轴是你的食指，正 \(z\) 轴是你的中指。'
- en: '[![../Images/Alien8.PNG](../Images/Alien8.PNG)](../Images/Alien8.PNG)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien8.PNG](../Images/Alien8.PNG)](../Images/Alien8.PNG)'
- en: '*When you used your mouse to rotate the scene, that actually rotated the entire
    coordinate system.*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*当您使用鼠标旋转场景时，实际上是在旋转整个坐标系。*'
- en: Said another way, before you start rotating in the display window with your
    mouse, the horizontal axis is the \(x\) axis, the vertical axis is the \(y\) axis,
    and the \(z\) axis points out of the screen.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在您用鼠标开始在显示窗口中旋转之前，水平轴是 \(x\) 轴，垂直轴是 \(y\) 轴，\(z\) 轴指向屏幕外。
- en: 'Take a look at the position of the box by adding a call to `c.pos`. When you
    re-run the code, you’ll see this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加对 `c.pos` 的调用来查看盒子的位置。当您重新运行代码时，您会看到这个：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*Is vector class also called linear algebra?*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*向量类也被称为线性代数吗？*'
- en: 'VPython has a class called `vector`, and `pos` is an object of this type, as
    we can tell by the vector notation. Nice! The `box` class is defined using the
    `vector` class. Using a `vector` class inside the `box` class is, well, very classy!
    “OK,” we hear you concede grudgingly, “but what’s the point of a `vector`? Why
    couldn’t we just use a tuple or a list instead?” Here’s the thing: The `vector`
    class has some methods defined in it for performing vector operations. For example,
    the `vector` class has an overloaded addition operator for adding two vectors:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: VPython 有一个名为 `vector` 的类，而 `pos` 是这种类型的对象，我们可以通过向量表示法得知。好极了！`box` 类是使用 `vector`
    类定义的。在 `box` 类内部使用 `vector` 类非常优雅！“好吧，”我们听到你勉强承认，“但是`vector` 有什么用？我们为什么不能只使用元组或列表呢？”事实是：`vector`
    类中定义了一些用于执行向量操作的方法。例如，`vector` 类有一个重载的加法运算符用于将两个向量相加：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This class has many other vector operations as well. For example, the `norm()`
    method returns a `vector` that points in the same direction but has magnitude
    (length) 1:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类还有许多其他向量操作。例如，`norm()`方法返回一个指向相同方向但大小（长度）为1的`vector`：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[![../Images/Alien8.PNG](../Images/Alien8.PNG)](../Images/Alien8.PNG)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien8.PNG](../Images/Alien8.PNG)](../Images/Alien8.PNG)'
- en: '*Take a look at the rich set of other vector operations on the VPython web
    site in order to dot your i’s and cross your t’s or, more precisely, to dot your
    scalars and cross your vectors!*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*请查看 VPython 网站上丰富的其他向量操作，以便对你的i加点和你的t划线，或者更准确地说，对你的标量加点和你的向量划线！*'
- en: So, while we *could* have represented vectors using lists, we wouldn’t have
    a nice way of adding them, `norm`alizing them, and doing all kinds of other things
    that vectors like to do.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，虽然我们*可以*用列表表示向量，但我们没有一个好方法来进行添加、`norm`化和执行向量喜欢做的所有其他操作。
- en: 'But, our objective for now is to change our box’s `pos` vector in order to
    move it. We can do this, for example, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们现在的目标是改变我们盒子的 `pos` 向量以便移动它。例如，我们可以这样做：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'While we can always create a box and change its attributes afterwards, sometimes
    it’s convenient to just set the attributes of the box at the time that the box
    is first instantiated. The `box` class constructor allows us to set the values
    of attributes at the time of construction like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们总是可以创建一个盒子然后稍后更改它的属性，但有时仅在盒子首次实例化时设置盒子的属性更方便。`box` 类构造函数允许我们在构造时设置属性值，像这样：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Whatever attributes we don’t specify will get their default values. For example,
    since we didn’t specify a vector value for `pos`, the box’s initial position will
    be the origin.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是否指定属性，它们都会得到默认值。例如，由于我们没有为 `pos` 指定一个向量值，盒子的初始位置将是原点。
- en: VPython has lots of other shape classes beyond boxes including spheres, cones,
    cylinders, among others. While these objects have their own particular attributes
    (for example a sphere has a radius), all VPython objects share some useful methods.
    One of these methods is called `rotate`. Not surprisingly, this method rotates
    its object. Let’s take `rotate` out for a spin!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: VPython 除了盒子外还有许多其他形状类，包括球体、圆锥体、圆柱体等。虽然这些对象有其自己特定的属性（例如球体有一个半径），但所有 VPython
    对象共享一些有用的方法。其中一个方法称为 `rotate`。毫不奇怪，这个方法旋转其对象。让我们试试 `rotate`！
- en: 'Try this with the box `b` that we defined above:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 试试将上面定义的盒子 `b` 用在这个上面：
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We are asking VPython to rotate the box `b` by \(\frac{\pi}{4}\) radians. The
    rotation is, by default, specified in radians about the \(x\) axis.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求 VPython 将盒子 `b` 旋转 \(\frac{\pi}{4}\) 弧度。默认情况下，旋转是关于 \(x\) 轴的弧度。
- en: 'Now, let’s put this all together to write a few short VPython programs just
    to flex our 3D graphics muscles. First, let’s write a *very* short program that
    rotates a red box forever (clean out your cell before copying this code in):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把这些组合起来，写几个简短的 VPython 程序，来展示我们的 3D 图形技能。首先，让我们写一个*非常*简短的程序，永远旋转一个红色的盒子（在复制此代码之前清空您的单元格）：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Second, take a look at the program below. Try to figure out what it’s doing
    before you run it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，请看下面的程序。在运行之前试着弄清楚它在做什么。
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is very cool! We now have a list of objects and we can go through that
    list and rotate each of them.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常酷！我们现在有一个对象列表，我们可以遍历该列表并旋转其中的每一个。
- en: 6.8 Robot and Zombies, Finally!
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8 机器人和僵尸，终于！
- en: 'It’s time to make our video game! The premise of our game is that we will control
    a robot that moves on the surface of a disk (a large flat cylinder) populated
    by zombies. The player will control the direction of the robot with a GUI (Graphical
    User Interface) that YOU will make! Our GUI should have the following: Two buttons
    to speed up and slow down the robot, two buttons to turn the robot left and right,
    and one button to quit the program. (We will give you the code for the GUI so
    that we can focus on making our robots and alien.) Meanwhile, the zombies will
    each move and turn independently by random amounts.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候制作我们的视频游戏了！我们游戏的前提是，我们将控制一个机器人在一个由僵尸群居住的圆盘表面（一个大平面圆柱体）上移动。玩家将通过一个由你制作的GUI（图形用户界面）控制机器人的方向！我们的GUI应该包括以下内容：两个按钮用于加速和减速机器人，两个按钮用于左右转动机器人，以及一个按钮用于退出程序。（我们将为您提供GUI的代码，以便我们可以专注于制作我们的机器人和外星人。）与此同时，每个僵尸将独立地移动和转向随机量。
- en: The program will be in an infinite loop. At each step, the player’s robot will
    take a small step forward. The buttons will simultaneously control the robot’s
    turn amounts. Similarly, each zombie will turn a random amount and then take a
    small step forward. Our game will have no particular objective, but you can add
    one later if you like. Perhaps, the objective is to run into as many zombies as
    possible – or perhaps avoid them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将处于一个无限循环中。在每一步中，玩家的机器人将向前迈出一小步。按钮将同时控制机器人的转向量。同样，每个僵尸将转动一个随机量，然后向前迈出一小步。我们的游戏没有特定的目标，但如果您愿意，可以稍后添加一个。也许，目标是尽可能撞到尽可能多的僵尸
    - 或者避开它们。
- en: To get started, we wish to define a player robot class that we’ll use to manufacture
    (“instantiate”) the player’s robot and another class that allows to instantiate
    zombies. It particularly makes sense to have a zombie *class* because a class
    allows us to instantiate many *objects* – and we indeed plan to have many zombies!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们希望定义一个玩家机器人类，我们将用它来制造（“实例化”）玩家的机器人，以及另一个类，允许实例化僵尸。定义一个僵尸*类*是特别有意义的，因为一个类允许我们实例化许多*对象*
    - 而我们确实计划有许多僵尸！
- en: In fact, the player’s robot and zombies have a lot in common. They are 3D entities
    that should be able to move forward and turn. Because of this commonality, we
    would be replicating a lot of effort if we were to define a robot class and a
    zombie class entirely separately. On the other hand, the two classes are not going
    to be identical because the player’s robot looks different from zombies (we hope)
    and because the robot will be controlled by the player while the zombies move
    on their own.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，玩家的机器人和僵尸有很多共同之处。它们都是3D实体，应该能够向前移动和转向。由于这种共性，如果我们完全分别定义一个机器人类和一个僵尸类，我们将会重复很多工作。另一方面，这两个类不会完全相同，因为玩家的机器人看起来与僵尸不同（我们希望如此），而且机器人将由玩家控制，而僵尸将自行移动。
- en: 'So, here’s the key idea: We’ll define a class – let’s call it `GenericBot`
    – that has all of the attributes that any entity in our game – a player robot
    or a zombie – should have. Then, we’ll define a `PlayerBot` class and a `ZombieBot`
    class both of which “inherit” all of the attributes and methods of the `GenericBot`
    and *add* the special extras (e.g., how their bodies look) that differentiate
    them.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里是关键思想：我们将定义一个类 - 让我们称之为`GenericBot` - 它具有我们游戏中任何实体 - 玩家机器人或僵尸 - 应该具有的所有属性。然后，我们将定义一个`PlayerBot`类和一个`ZombieBot`类，它们都“继承”了`GenericBot`的所有属性和方法，并*添加*了特殊的额外内容（例如，它们的外观如何）来区分它们。
- en: Our `GenericBot` class will have a constructor, an `__init__` method, that takes
    as input the initial position of the bot, its initial heading (the direction in
    which it is pointing), and its speed (the size of each step that it makes when
    we ask it to move forward). Here’s the code; we’ll dissect it below.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`GenericBot`类将有一个构造函数，一个`__init__`方法，它以机器人的初始位置、初始朝向（指向的方向）和速度（当我们要求它向前移动时每步移动的大小）作为输入。以下是代码；我们将在下面详细解释。
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let’s start with the `__init__` method – the so-called “constructor” method.
    It takes three input arguments: A `position` (a VPython `vector` object indicating
    the bot’s initial position), a `heading` (a vector indicating the direction that
    the bot is initially pointing), and `speed` (a number indicating how far the bot
    moves at each update step). Notice that the line:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`__init__`方法开始 - 所谓的“构造函数”方法。它接受三个输入参数：一个`position`（一个VPython `vector`对象，表示机器人的初始位置），一个`heading`（一个表示机器人初始指向的向量），和`speed`（一个表示机器人在每次更新步骤时移动多远的数字）。请注意以下行：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: provides *default values* for these inputs. This means that if the user doesn’t
    provide values for these input arguments, the inputs will be set to these values.
    (You may recall that the `box` class had default arguments as well. We could either
    define a new box with `b = box()` in which case we got the default values or we
    could specify our own values for these arguments.) If the user provides only some
    of the input arguments, Python will assume that they are the arguments from left-to-right.
    For example, if we type
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为这些输入提供了*默认值*。这意味着如果用户没有为这些输入参数提供值，输入将被设置为这些值。（您可能还记得 `box` 类也有默认参数。我们可以用 `b
    = box()` 来定义一个新的盒子，这样我们就得到了默认值，或者我们可以为这些参数指定我们自己的值。）如果用户只提供了一些输入参数，Python 将假定它们是从左到右的参数。例如，如果我们输入
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: then Python assumes that `vector(1, 2, 3)` should go into the `position` variable
    and it uses the default values for `heading` and `speed`. If we type
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 Python 假设 `vector(1, 2, 3)` 应该进入 `position` 变量，并使用 `heading` 和 `speed` 的默认值。如果我们输入
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'then the first vector goes into the `position` argument and the second goes
    into the `heading` argument. If we want to provide values in violation of the
    left-to-right order, we can always tell Python which value we are referring to
    like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后第一个向量进入 `position` 参数，第二个进入 `heading` 参数。如果我们想提供违反从左到右顺序的值，我们总是可以告诉 Python
    我们正在引用哪个值，就像这样：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*It was de-fault of de-authors for this de-gression!*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是作者的责任！*'
- en: Now, Python sets the `heading` to the given value and uses the default values
    for the other arguments.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Python 设置了给定值的 `heading` 并使用其他参数的默认值。
- en: OK, so much for defaults! The `__init__` method then sets its position (`self.position`),
    heading (`self.heading`), speed (`self.speed`), and parts (`self.parts`) attributes.
    The `self.heading` is normalized to make the length of the vector a unit vector
    (a vector of length 1) using the `vector` class’s `norm()` method. The `self.parts`
    list will be a list of VPython 3D objects – boxes, spheres, and so forth – that
    make up the body of the bot. Since the player bot and the zombie bots will look
    different, we haven’t placed any of these body parts into the list just yet. That’s
    coming soon!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，就这么多了！`__init__` 方法然后设置它的位置（`self.position`）、朝向（`self.heading`）、速度（`self.speed`）和部件（`self.parts`）属性。`self.heading`
    被规范化为使向量的长度成为单位向量（长度为1的向量），使用 `vector` 类的 `norm()` 方法。`self.parts` 列表将是由VPython
    3D对象组成的列表 - 盒子、球体等等 - 构成机器人的主体。因为玩家机器人和僵尸机器人看起来会有所不同，所以我们还没有将这些身体部件放入列表中。这很快就会到来！
- en: 'Notice that the `GenericBot` has three additional methods: `update`, `forward`,
    and `turn`. In fact, the `update` method simply calls the `turn` method to turn
    the bot 0 radians (we’ll probably change that later!) and then calls the `forward`
    method to move one step at the given speed. The `turn` method changes the bot’s
    `self.heading` so that it heads in the new direction induced by the turning angle
    and then rotates each of the parts in the bot’s `self.parts` list by that same
    angle.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `GenericBot` 还有三个额外的方法：`update`、`forward` 和 `turn`。事实上，`update` 方法简单地调用 `turn`
    方法将机器人转向 0 弧度（我们可能以后会更改！），然后调用 `forward` 方法以给定的速度移动一步。`turn` 方法改变机器人的 `self.heading`，使其朝着由转向角引起的新方向前进，然后旋转机器人的
    `self.parts` 列表中的每个部分相同的角度。
- en: Something **very lovely** and subtle is happening in the `for` loop of the `turn`
    method! Notice that each `part` is expected to be a VPython object, like a `box`
    or `sphere` or something else. Each of those objects has a `rotate` method. Python
    is saying here “hey `part`, figure out what kind of object you are and then call
    your `rotate` method to rotate yourself.” So, if the first `part` is a `box`,
    then this will call the `box` `rotate` method. If the next part is a `sphere`,
    the `sphere`‘s `rotate` method will be called here. This all works great, as long
    as each element in the `self.parts` list has a `rotate` method. Fortunately, all
    VPython shapes do have a `rotate` method.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `turn` 方法的 `for` 循环中发生了一些**非常可爱**和微妙的事情！注意每个 `part` 都预期是一个VPython对象，像一个 `box`
    或 `sphere` 或其他什么东西。每个对象都有一个 `rotate` 方法。Python 在这里说 “嘿 `part`，弄清楚你是什么类型的对象，然后调用你的
    `rotate` 方法来旋转自己。” 所以，如果第一个 `part` 是一个 `box`，那么这将调用 `box` 的 `rotate` 方法。如果下一个部分是一个
    `sphere`，那么这里将调用 `sphere` 的 `rotate` 方法。只要 `self.parts` 列表中的每个元素都有一个 `rotate`
    方法，这一切都会很好地运行。幸运的是，所有VPython形状都有一个 `rotate` 方法。
- en: We’ll also just point out quickly that the line
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也会快速指出一下这一行
- en: '[PRE49]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: is telling that `part` to rotate by an angle `theta` about a vector aligned
    with `vector` `(0, 1, 0)` (the \(y\)-axis) but starting at the vector given by
    `self.position`. Under our assumption that the \(y\)-axis is “up”, this effectively
    rotates the object about a line that runs through the center of its body from
    “its feet to its head”. That is, it rotates the body parts the way we would like
    it to rotate, as opposed to the default rotation which is about the \(x\)-axis.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉 `part` 绕与 `vector` `(0, 1, 0)`（即 \(y\)-轴）对齐的向量以 `theta` 角度旋转，但起始于 `self.position`
    给定的向量。在我们假设 \(y\)-轴为“上”的情况下，这实际上使对象围绕一条从“脚到头”的中心线旋转。也就是说，它使身体部件以我们希望的方式旋转，而不是默认的围绕
    \(x\)-轴旋转。
- en: The `forward` method changes the bot’s `self.position` vector by adding to it
    the `heading` vector scaled by the bot’s `self.speed`. Note that `self.position`
    is just the bot’s own self-concept of where it is located. We also need to physically
    move all of the parts of the bot’s body, which is done by changing the `pos` position
    vector of each VPython objects in the `self.parts` list, again by the `self.heading`
    vector scaled by `self.speed`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`forward` 方法通过将 `heading` 向量按照机器人的 `self.speed` 缩放添加到机器人的 `self.position` 向量中来改变机器人的位置。请注意，`self.position`
    只是机器人自己对自己所在位置的概念。我们还需要移动机器人身体的所有部件，这是通过将 `self.parts` 列表中每个 VPython 对象的 `pos`
    位置向量再次按照 `self.heading` 向量缩放 `self.speed` 来完成的。'
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*Drumroll, please!*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*请鼓掌！*'
- en: Next comes the most amazing part of this whole business! We now define the `ZombieBot`
    class that *inherits* all of the methods and attributes of the `GenericBot` but
    adds the components that are specific to a zombie. Here’s the code and we’ll discuss
    it in a moment.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是整个过程中最令人惊奇的部分！我们现在定义了 `ZombieBot` 类，*继承* 了 `GenericBot` 的所有方法和属性，但添加了特定于僵尸的组件。以下是代码，我们稍后会讨论它。
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The class definition begins with the line: `class ZombieBot(GenericBot)`. The
    `GenericBot` in parentheses is saying to Python “this class inherits from `GenericBot`.”
    Said another way, a `ZombieBot` “is a kind of” `GenericBot`. Specifically, this
    means that a `ZombieBot` has the `__init__`, `update`, `turn`, and `forward` methods
    of `GenericBot`. The class `GenericBot` is called the *superclass* of `ZombieBot`.
    Similarly, `ZombieBot` is called a *subclass* or *derived class* of `GenericBot`.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义以以下行开始：`class ZombieBot(GenericBot)`。括号中的 `GenericBot` 告诉 Python “这个类继承自
    `GenericBot`”。换句话说，`ZombieBot` “是一种” `GenericBot`。具体来说，这意味着 `ZombieBot` 具有 `GenericBot`
    的 `__init__`、`update`、`turn` 和 `forward` 方法。类 `GenericBot` 被称为 `ZombieBot` 的 *超类*。同样，`ZombieBot`
    被称为 `GenericBot` 的 *子类* 或 *派生类*。
- en: Note that `ZombieBot` has its own `__init__` constructor method. If we had not
    defined this `__init__` then each time we constructed a `ZombieBot` object, Python
    would automatically invoke the `__init__` from `GenericBot`, the superclass from
    which `ZombieBot` was derived. However, since we’ve defined an `__init__` method
    for `ZombieBot`, that method will get called when we instantiate a `ZombieBot`
    object. It’s not that the `GenericBot`‘s constructor isn’t useful to us, but we
    want to do some other things too. Specifically, we want to populate the list of
    body parts, `self.parts`, with the VPython shapes that constitute a zombie.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ZombieBot` 有自己的 `__init__` 构造方法。如果我们没有定义这个 `__init__`，那么每次我们构造一个 `ZombieBot`
    对象时，Python 会自动调用 `ZombieBot` 继承自的超类 `GenericBot` 中的 `__init__`。然而，由于我们为 `ZombieBot`
    定义了一个 `__init__` 方法，当我们实例化一个 `ZombieBot` 对象时，该方法将被调用。并不是说 `GenericBot` 的构造方法对我们没用，但我们还想做一些其他事情。具体来说，我们想用
    VPython 形状填充身体部件列表 `self.parts`，构成一个僵尸。
- en: We get two-for-the-price-of-one by first having the `ZombieBot`‘s `__init__`
    method call the `GenericBot`‘s `__init__` method to do what it can do for us.
    This is invoked via `GenericBot.__init__(self, position, heading)`. This is saying,
    “hey, I know that I’m a `ZombieBot`, but that means I’m a kind of `GenericBot`
    and, as such, I can call any `GenericBot` method for help. In particular, since
    the `GenericBot` already has an `__init__` method that does some useful things,
    I’ll call it to set my `position` and `heading` attributes.”
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过首先让 `ZombieBot` 的 `__init__` 方法调用 `GenericBot` 的 `__init__` 方法来一举两得。这是通过
    `GenericBot.__init__(self, position, heading)` 调用的。这是在说，“嘿，我知道我是一个 `ZombieBot`，但这意味着我是一种
    `GenericBot`，因此，我可以调用任何 `GenericBot` 方法来帮助。特别是，由于 `GenericBot` 已经有一个做一些有用事情的 `__init__`
    方法，我将调用它来设置我的 `position` 和 `heading` 属性。”
- en: After calling the `GenericBot` constructor, the `ZombieBot` constructor continues
    to do some things on its own. In particular, it defines some VPython objects and
    places them in the `parts` list of body parts. You might notice that all of those
    body parts are positioned relative to the `ZombieBot`‘s `position` – which is
    just a vector that we defined that keeps track of where the bot is located in
    space.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`GenericBot`构造函数之后，`ZombieBot`构造函数继续自己做一些事情。 特别是，它定义了一些 VPython 对象，并将它们放在身体部件的`parts`列表中。
    你可能注意到所有这些身体部位都是相对于`ZombieBot`的`position`定位的 - 这只是一个我们定义的向量，用于跟踪机器人在空间中的位置。
- en: Since `ZombieBot` inherited from `GenericBot`, it automatically has the `update`,
    `turn`, and `forward` methods defined in the `GenericBot` class. The `turn` and
    `forward` methods are fine, but the `update` method needs to be replaced to turn
    the `ZombieBot` at random. Thus, we provide a new `turn` method in the `ZombieBot`
    class.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ZombieBot`继承自`GenericBot`，它自动具有在`GenericBot`类中定义的`update`、`turn`和`forward`方法。
    `turn`和`forward`方法都很好，但是`update`方法需要替换为随机转动`ZombieBot`。 因此，我们在`ZombieBot`类中提供了一个新的`turn`方法。
- en: 'Now, imagine that we do the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象我们做了以下操作：
- en: '[PRE51]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first line creates a new `ZombieBot` object. Since we didn’t provide any
    inputs to the constructor, the default values are used and zephyr the zombie is
    at position (0, 0, 0) and heading in direction (0, 0, 1). The second line tells
    zephyr to update itself. Python checks to see if the `ZombieBot` class contains
    an `update` method. It does, so that method is invoked. That method then calls
    the `turn` method with a random angle between -5 and 5 degrees. Python checks
    to see if the `ZombieBot` class has its own `turn` method. Since it doesn’t, Python
    goes to the superclass, `GenericBot`, and looks for a `turn` method there. There
    is one there and that’s what’s used! Next, the `update` method calls the `forward`
    method. Since there’s no `forward` method defined in `ZombieBot`, Python again
    goes to the superclass and uses the `forward` method there.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个新的`ZombieBot`对象。 由于我们没有为构造函数提供任何输入，因此使用默认值，并且僵尸“zephyr”位于位置（0，0，0）并且朝向（0，0，1）。
    第二行告诉“zephyr”更新自己。 Python 检查`ZombieBot`类是否包含一个`update`方法。 它确实包含，因此调用该方法。 该方法然后使用随机角度调用`turn`方法，角度范围为-5至5度。
    Python 检查`ZombieBot`类是否有自己的`turn`方法。 由于没有，Python 转到超类`GenericBot`，并在那里查找一个`turn`方法。
    那里有一个，就是使用的！ 接下来，`update`方法调用`forward`方法。 由于在`ZombieBot`中没有定义`forward`方法，Python
    再次转到超类并在那里使用`forward`方法。
- en: The very nice thing here is that `ZombieBot` inherits many things from the superclass
    from which it is derived and only changes – or *overrides* – those methods that
    it needs to customize for zombies.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里非常好的一点是，`ZombieBot`从其派生的超类继承了许多东西，并且只更改了 - 或 *覆盖* - 那些它需要为僵尸自定义的方法。
- en: 'Now, we can do something similar for the player’s robot:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为玩家的机器人做类似的事情：
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `PlayerBot` class also inherits from the `GenericBot` class. It again calls
    the `GenericBot`‘s constructor for help initializing some attributes and then
    defines its own attributes. It uses the `turn` and `forward` methods from the
    superclass, and although the `update` method isn’t any different, it reminds us
    that the inputs for the robot come from the button handlers in the GUI section.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerBot`类也继承自`GenericBot`类。 它再次调用`GenericBot`的构造函数来帮助初始化一些属性，然后定义自己的属性。
    它使用超类的`turn`和`forward`方法，虽然`update`方法没有任何不同，但它提醒我们机器人的输入来自 GUI 部分的按钮处理程序。'
- en: Recall that a short awhile ago we noted that all Python shapes have a `rotate`
    method. That’s because all of these shapes – boxes, spheres, cylinders, cones,
    and others – inherit from a shape superclass that defines a `rotate` method. Therefore,
    they all “know” how to rotate because they inherited that “knowledge” from their
    parent class. That parent class has many features – methods and attributes – that
    its children need, just like our `GenericBot` class has features that are used
    by its children – the derived classes `ZombieBot` and `PlayerBot`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，不久之前我们注意到所有的 Python 形状都有一个`rotate`方法。 这是因为所有这些形状 - 矩形、球体、圆柱体、圆锥体和其他形状 -
    都继承自一个形状超类，该超类定义了一个`rotate`方法。 因此，它们都“知道”如何旋转，因为它们从它们的父类那里继承了那个“知识”。 那个父类有许多功能
    - 方法和属性 - 它的子类需要，就像我们的`GenericBot`类有子类`ZombieBot`和`PlayerBot`使用的功能一样。
- en: Finally, here’s our game! In this file, we import the `vpython` graphics package;
    the `robot.py` file containing the `GenericBot`, `ZombieBot`, and `PlayerBot`
    classes, and the `random` and `math` packages. The `main` function instantiates
    a large flat VPython cylinder object, that we name `ground`, that is the surface
    on which the bots will move. Its radius is given by a global variable `GROUND_RADIUS`.
    We then instantiate a single `PlayerBot` named `player` and call a helper function
    called `makeZombies` that instantiates many zombies (the number is given by the
    global variable `ZOMBIES`) and returns a list of `ZombieBot` objects at random
    positions on our cylindrical playing area. Finally, the `main` function enters
    an infinite loop. At each iteration, we check to see if the player’s location
    is beyond the radius of the playing area, and if so turn the robot 180 degrees
    so that its next step will hopefully be inside the player area. Now, each zombie
    is updated by calling its `update` method. Here too, if the zombie has stepped
    out of the playing area, we rotate it at random (180 degrees plus or minus 30
    degrees). We then also include code of our own to read user input (which we won’t
    detail here). And so, voilá!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是我们的游戏！在这个文件中，我们导入了`vpython`图形包；包含`GenericBot`、`ZombieBot`和`PlayerBot`类的`robot.py`文件，以及`random`和`math`包。`main`函数实例化了一个大的平面VPython圆柱体对象，我们将其命名为`ground`，这是机器人移动的表面。其半径由全局变量`GROUND_RADIUS`给出。然后我们实例化了一个名为`player`的单个`PlayerBot`，并调用一个名为`makeZombies`的辅助函数，该函数实例化了许多僵尸（数量由全局变量`ZOMBIES`给出），并返回一个在我们的圆柱形游戏区域上随机位置的`ZombieBot`对象列表。最后，`main`函数进入一个无限循环。在每次迭代中，我们检查玩家位置是否超出了游戏区域的半径，如果是，则将机器人旋转180度，以便其下一步有望在玩家区域内。现在，每个僵尸都通过调用其`update`方法进行更新。同样，在这里，如果僵尸走出了游戏区域，我们会随机旋转它（180度加减30度）。然后，我们还包括了自己的代码来读取用户输入（我们这里不详细介绍）。所以，大功告成！
- en: '[PRE53]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 6.9 Conclusion
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9 结论
- en: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien8.PNG](../Images/Alien8.PNG)'
- en: '*I suppose that “yucky” is yet another technical term.*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*我想“yucky”可能是另一个技术术语。*'
- en: This is all really neat, but why is object-oriented programming such a big deal?
    As we saw in our `Rational` example, one benefit of object-oriented programming
    is that it allows us to define new types of data. You might argue, “Sure, but
    I could have represented a rational number as a list or tuple of two items and
    then I could have written functions for doing comparisons, addition, and so forth
    without using any of this class stuff.” You’re absolutely right, but you then
    have exposed a lot of yucky details to the user that she or he doesn’t want to
    know about. For example, the user would need to know that rational numbers are
    represented as a list or a tuple and would need to remember the conventions for
    using your comparison and addition functions. One of the beautiful things about
    object-oriented programming is that all of this “yuckiness” (more technically,
    “implementation details”) is *hidden* from the user, providing a *layer of abstraction*
    between the use and the implementation of rational numbers.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都非常棒，但为什么面向对象编程如此重要呢？正如我们在`Rational`示例中看到的，面向对象编程的一个好处是它允许我们定义新的数据类型。你可能会说，“当然，但我可以将有理数表示为两个项目的列表或元组，然后我可以编写用于比较、加法等操作的函数，而不使用任何类的东西。”
    你是完全正确的，但这样一来，你就向用户暴露了很多不想知道的细节。例如，用户需要知道有理数被表示为列表或元组，并且需要记住使用您的比较和加法函数的约定。面向对象编程的一个美妙之处在于，所有这些“糟糕的”细节（更准确地说是“实现细节”）都被*隐藏*，为用户提供了在使用和实现有理数之间的*抽象层*。
- en: 'Layer of abstraction?! What does *that* mean? Imagine that every time you sat
    in the driver’s seat of a car you had to fully understand various components of
    the engine, transmission, steering system, and electronics just to operate the
    car. Fortunately, the designers of cars have presented us with a nice layer of
    abstraction: the steering wheel, pedals, and dashboard. We can now do interesting
    things with our car without having to think about the low-level details. As a
    driver, we don’t need to worry about whether the steering system uses a rack and
    pinion or something entirely different. This is precisely what classes provide
    for us. The inner workings of a class are securely “under the hood,” available
    if needed, but not the center of attention. The user of the class doesn’t need
    to worry about implementation details; she or he just uses the convenient and
    intuitive provided methods. By the way, the “user” of your class is most often
    you! You too don’t want to be bothered with implementation details when you use
    the class—you’d rather be thinking about bigger and better things at that point
    in your programming.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象层？！*那*是什么意思？想象一下，每次你坐在汽车驾驶座上时，你都必须完全了解发动机、变速箱、转向系统和电子设备的各种组件才能操作汽车。幸运的是，汽车设计师为我们提供了一个很好的抽象层：方向盘、踏板和仪表盘。现在我们可以在不必考虑低级细节的情况下对我们的汽车进行有趣的操作。作为驾驶员，我们不需要担心转向系统是否使用齿轮齿条或完全不同的东西。这正是类为我们提供的。类的内部工作安全地“藏在引擎盖下”，如果需要的话可以使用，但不是关注的中心。类的用户不需要担心实现细节；他或她只需使用提供的方便和直观的方法。顺便说一句，你的类的“用户”往往是你自己！当你使用类时，你也不想被实现细节所困扰——在那时，你更愿意思考更大更好的事情。
- en: Object-oriented design is the computer science version of *modular design*,
    an idea that engineers pioneered long ago and have used with great success. Classes
    are modules. They encapsulate logical functionality and allow us to reason about
    and use that functionality without having to keep track of every part of the program
    at all times. Moreover, once we have designed a good module/class we can reuse
    it in many different applications.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象设计是计算机科学版本的*模块化设计*，这是工程师们很早就开创并取得巨大成功的一个概念。类就是模块。它们封装了逻辑功能，使我们能够推理和使用该功能，而无需始终跟踪程序的每个部分。此外，一旦我们设计了一个良好的模块/类，我们可以在许多不同的应用程序中重复使用它。
- en: 'Finally, in our Robot and Zombies game, we saw the important idea of inheritance.
    Once we construct one class, we can write special versions that inherit all of
    the methods and attributes of the “parent” or superclass, but also add their own
    unique features. In large software systems, there can be a large and deep *hierarchy*
    of classes: One class has children classes that inherit from it which in turn
    have their own children classes, and so forth. This design methodology allows
    for great efficiencies in reusing rather than rewriting code.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的机器人和僵尸游戏中，我们看到了继承的重要概念。一旦我们构建了一个类，我们可以编写特殊版本，继承“父类”或超类的所有方法和属性，但也可以添加自己独特的特性。在大型软件系统中，类之间可以形成一个庞大而深入的*层次结构*：一个类有继承自它的子类，这些子类又有它们自己的子类，依此类推。这种设计方法允许我们在重用代码而不是重写代码方面效率极高。
- en: '**Takeaway message**: *Classes—the building blocks of object-oriented designs
    and programs—provide us with a way of providing abstraction that allows us to
    concentrate on using these building blocks without having to worry about the internal
    details of how they work. Moreover, once we have a good building block we can
    use it over and over in all different kinds of programs.*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**主要观点**：*类——面向对象设计和程序的构建模块——为我们提供了一种提供抽象的方式，使我们能够专注于使用这些构建模块，而不必担心它们的内部工作细节。此外，一旦我们拥有一个良好的构建模块，我们可以在各种不同类型的程序中反复使用它。*'
