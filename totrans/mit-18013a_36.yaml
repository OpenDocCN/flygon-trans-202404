- en: 'Chapter B: Fun with Determinants'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed the determinant in [Chapter 4](../chapter04/contents.html)
    and again in [Chapter 32](../chapter32/contents.html). We discussed several methods
    for computing determinants, which are not difficult in principle, but rather tedious
    to perform in practice, if you want to do them by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Here we give some ideas which allow us to deduce the determinant of several
    special types of matrices (but ones that are occasionally useful) with less effort
    than it takes to write down the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: We also present a curious formula involving determinants that was discovered
    by Lewis Carroll, the author of Alice in Wonderland, and a magical algorithm for
    computing determinants and even inverses based upon it, with almost no effort.
  prefs: []
  type: TYPE_NORMAL
- en: 1 Some Easily Calculated Determinants. The VanderMonde Determinant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a matrix has elements that are monomials or even polynomials in some set
    of variables, then its determinant will in general be a polynomial in those variables,
    and this is sometimes useful in evaluating it.
  prefs: []
  type: TYPE_NORMAL
- en: The prime example of this is what is called a VanderMonde matrix, whose rows
    (or if you prefer, columns) all have the form (1, x[j], x[j]², x[j]³, ..., x[j]^(n-1))
    for some x[j].
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of one
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/41f41b9d9296d71f9669b80965386c9f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By the basic property of a determinant, that it is 0 if two of its rows are
    the same, we can deduce that determinant of a VanderMonde matrix will be 0 when
    any two of its rows are the same.
  prefs: []
  type: TYPE_NORMAL
- en: But that means that, as a polynomial, it must have (x[i] - x[j]) as a factor,
    for every i and j.
  prefs: []
  type: TYPE_NORMAL
- en: This means that such a determinant must have ![](../Images/076a1de1ba2ff40d201747d2312fc823.jpg)
    as a factor, with the product here taken over all pairs of variables with i >
    j.
  prefs: []
  type: TYPE_NORMAL
- en: This factor is already a polynomial of degree ![](../Images/a9e4a3da23633229ed6a4034f5d70e66.jpg)
    (where we are dealing with an n by n matrix).
  prefs: []
  type: TYPE_NORMAL
- en: And what is the degree of our VanderMonde determinant as a polynomial?
  prefs: []
  type: TYPE_NORMAL
- en: Well, it is the sum of entries, each one of which has one factor from each column.
    Thus, as a polynomial, it has degrees 0 + 1 + ... + n - 1, which is ![](../Images/a9e4a3da23633229ed6a4034f5d70e66.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: And so, since we have seen that our determinant must have a factor of this degree,
    we have already evaluated our determinant as a polynomial, up to a constant factor.
  prefs: []
  type: TYPE_NORMAL
- en: 'And what is that constant? We can check it by looking at the main diagonal
    term: which is'
  prefs: []
  type: TYPE_NORMAL
- en: x[1]⁰x[2]¹x[3]²...x[n]^(n-1)
  prefs: []
  type: TYPE_NORMAL
- en: and this is exactly what you get if you take the first (positive) terms in each
    factor of our product above.
  prefs: []
  type: TYPE_NORMAL
- en: Since these two terms have the same coefficient, 1, in both the determinant
    and the product, the product is the determinant, and that is our answer.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we can deduce immediately that the determinant is 2*1*1, or
    2.
  prefs: []
  type: TYPE_NORMAL
- en: '2 Another Easy Case: Cauchy''s Determinant'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose we want the determinant of a matrix whose (j, k) entry is ![](../Images/ef08a37d5d1a2fa0c4adf099d477b95b.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example: for the x values 1, 2, 4 and y values 1, 2, 3'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/86569363f4ff6f687e3d398c37c9b4f5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we don't have a polynomial, but rather have a rational function of our variables.
  prefs: []
  type: TYPE_NORMAL
- en: What do we do? We make it into a polynomial by factoring out all the denominators!
  prefs: []
  type: TYPE_NORMAL
- en: Again, by the way, we know that it will be 0 if any two x variables are the
    same, or if any two y variables are the same since that would make two rows or
    columns identical.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, it must have factors of ![](../Images/2355580d2b919547609518c0f8d9bca0.jpg)
    in the numerator.
  prefs: []
  type: TYPE_NORMAL
- en: There is a product once for each pair with the larger index first.
  prefs: []
  type: TYPE_NORMAL
- en: In the denominator we will have ![](../Images/cb5887dcb32afa46d664804b43f4679d.jpg)
    for every pair of variables.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the numerator has already degree n(n - 1) in our variables and the
    denominator has degree n², which is n more than the that of the numerator.
  prefs: []
  type: TYPE_NORMAL
- en: This is also true of the determinant, all of whose terms are products of n factors,
    each having one term in the denominator and none in the numerator, for a net excess
    of n in the denominator.
  prefs: []
  type: TYPE_NORMAL
- en: In fact the formula we have so far
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4510acae1839b1f9a2d9d629c68d0151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where the first two products are over variable pairs with the first variable
    having greater index, while the product in the denominator is over all pairs,
    is the determinant we seek.
  prefs: []
  type: TYPE_NORMAL
- en: We can verify this by setting x[j] = -y[j], in which case the terms in the products
    in the numerator become the off diagonal terms in the matrix, and these cancel
    with similar terms in the denominator, and we are left with ![](../Images/d6dc10150640ffdb10b14b66b8de21d8.jpg)
    in the denominator, exactly what we get from the diagonal term in the determinant.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we can deduct that our determinant is ![](../Images/c0a20d41245db029098a2a0d6ece88cb.jpg)
    (which includes all the denominators except for a factor of 12 which cancels with
    the numerator).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise B.1 There is one more famous example, which we give you as an exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider a matrix whose (j, k) element is x[j] if j > k, and y[j] otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: For a 3 by 3 matrix this looks like**
  prefs: []
  type: TYPE_NORMAL
- en: '**![](../Images/4df550372dc2f2e56b9f1e1c83d5ed9e.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Find a formula for its determinant. (Notice that it is a polynomial, of what
    degree? in these variables. When will it be 0? You can read off the answer from
    your answer to these questions.)**'
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the matrix
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cc19a4422a8631d6595c00b51f389920.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can immediately deduce that its determinant is 6*4*3 or 72.
  prefs: []
  type: TYPE_NORMAL
- en: 3 Lewis Carroll's Theorem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The formula for a determinant of a matrix in two dimensions
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ee8568195dab9f94c46b94172e888229.jpg)'
  prefs: []
  type: TYPE_IMG
- en: is
  prefs: []
  type: TYPE_NORMAL
- en: a[11]*a[22] - a[12]*a[21]
  prefs: []
  type: TYPE_NORMAL
- en: Charles Dodgson (Lewis Carroll, author of Alice in Wonderland) found an analog
    of this formula in every dimension.
  prefs: []
  type: TYPE_NORMAL
- en: 'We introduce the following notation: let **A[i,j] be the determinant of the
    matrix obtained from A by removing its i-th row and j-th column. If we omit two
    rows and corresponding columns let A[ij,ij] be the determinant of what is left,**
    which in the two dimensional case is nothing (whose determinant we define to be
    1).'
  prefs: []
  type: TYPE_NORMAL
- en: Then for a two dimensional matrix, A, as above, we have A[2,2] = a[11], A[1,2]
    = a[21] and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Our two dimensional formula above can then be written as
  prefs: []
  type: TYPE_NORMAL
- en: (Det A) A[jk,jk] = A[kk]A[jj] - A[jk]A[kj]
  prefs: []
  type: TYPE_NORMAL
- en: (Remember that the factor A[ij,ij] was defined to be 1 in this case.)
  prefs: []
  type: TYPE_NORMAL
- en: It is this formula that Dodgson generalized. He noticed, and proved that if
    you pick any two distinct indices (say j and k) for an n by n matrix, you get
    the same result
  prefs: []
  type: TYPE_NORMAL
- en: (Det A) A[jk,jk] = A[kk]A[jj] - A[jk]A[kj]
  prefs: []
  type: TYPE_NORMAL
- en: This formula on dividing by A[jk,jk], gives an n by n determinant in terms of
    determinants of smaller size.
  prefs: []
  type: TYPE_NORMAL
- en: Thus it can be used as a recursive definition of the determinant. (If you define
    the 0 by 0 determinant to be 1, and the 1 by 1 determinant of a number to be itself,
    you can use this definition to define all higher dimensional determinants, as
    long as A[jk,jk] is not 0.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise B.2 Verify the correctness of this claim for 3 by 3 matrices by
    working out a general example.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Not only can you define the determinant this way, but you can compute it
    efficiently and with incredible ease on a spreadsheet using it.**'
  prefs: []
  type: TYPE_NORMAL
- en: I call the algorithm for doing this **the Mad Hatter's Algorithm.** It is wonderfully
    efficient, but has a problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the algorithm?**'
  prefs: []
  type: TYPE_NORMAL
- en: We build up the determinants of **all submatrices consisting of consecutive
    rows and columns.**
  prefs: []
  type: TYPE_NORMAL
- en: The matrix itself is the matrix of one by one determinants. There are n² of
    these.
  prefs: []
  type: TYPE_NORMAL
- en: From these we compute the (n - 1)² two by two consecutive row and column sub-determinants
    using the ordinary 2D determinant formula in Dodson's form.
  prefs: []
  type: TYPE_NORMAL
- en: And using the same rule, namely
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/012cf88e726dfcad496fbea76a347a0f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: we compute all the (n-2)² 3 by 3 consecutive row and column sub-determinants
    from the 2 by 2's and 1 by 1's;
  prefs: []
  type: TYPE_NORMAL
- en: and continue until we have the 4 n-1 by n-1 consecutive row and column sub-determinants,
    and finally the one full determinant.
  prefs: []
  type: TYPE_NORMAL
- en: This sounds like a huge project but if we start with **a square patch of 1's
    to represent the 0 by 0 determinants,** and then **enter our matrix** beneath
    it, **we can do everything with one instruction copied below our matrix and down.**
  prefs: []
  type: TYPE_NORMAL
- en: Suppose, **for example,** we insert 1 in box a2 and copy it into the rectangle
    with corners a2 and j10, and enter our matrix with upper left corner in a11.
  prefs: []
  type: TYPE_NORMAL
- en: (Its extremely boring to enter a 10 by 10 matrix. I advise trying 4 by 4 or
    5 by 5 or maybe even 3 by 3\. If you want to go beyond 10 by 10 you will need
    more 1's at the top.)
  prefs: []
  type: TYPE_NORMAL
- en: Now in box a21 enter =(a11*b12-a12*b11)/b2
  prefs: []
  type: TYPE_NORMAL
- en: And copy it down and across into the rectangle with corners a21 and i110.
  prefs: []
  type: TYPE_NORMAL
- en: '**If your determinant is j by j, it should appear magically in the box in column
    a and row 10j+1.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Not only that,**'
  prefs: []
  type: TYPE_NORMAL
- en: If you extend your **j by j matrix by copying the first j-1 rows after it, and
    then copying the first j-1 columns to its right,** the j by j box with upper left
    corner in column b and row 9j+2 will be **the cofactor matrix if j is odd,** and
    **the cofactor matrix with alternating signs reversed if j is even.**
  prefs: []
  type: TYPE_NORMAL
- en: '**Does this really work?**'
  prefs: []
  type: TYPE_NORMAL
- en: If your matrix is ugly enough, it will work. That is if it has no entries that
    are 0, and none of the relevant sub-determinants that you divide by are 0, it
    will work. But if you divide by 0 in forming your answer it will fail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Will this happen?**'
  prefs: []
  type: TYPE_NORMAL
- en: For a three by three matrix M it will only happen if the middle element, m[22],
    is 0.
  prefs: []
  type: TYPE_NORMAL
- en: If you have copied its first two rows to the right, it will only fail all three
    times, (you will have potential answers in a31, b31 and c31) only if the middle
    row consists entirely of zeroes, in which case the determinant is 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a four by four matrix, you will fail if any of the middle elements: m[22],
    m[23], m[32], m[33] are 0 or if their determinant is 0; and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Can we make it really work?**'
  prefs: []
  type: TYPE_NORMAL
- en: Yes! But it requires doing something, which is not so slick.
  prefs: []
  type: TYPE_NORMAL
- en: '**Do what?**'
  prefs: []
  type: TYPE_NORMAL
- en: I am not sure what the best thing to do is. One thing that will usually work
    is to replace the zeroes of your matrix (and any later 0's that turn up in subdeterminants)
    by something very small, and then you can let that very small thing go to 0.
  prefs: []
  type: TYPE_NORMAL
- en: For example you can put a tiny number like 10^(-8) in b1, keep a row index j
    and column index k and add $b$1*(j+k+1) to the original matrix. With luck this
    will eliminate all zeroes and everything should work.
  prefs: []
  type: TYPE_NORMAL
- en: Of course your answer will be slightly off. Then you can round your answer or
    change what is in b1 to figure out the answer (You can probably think of something
    better to do).
  prefs: []
  type: TYPE_NORMAL
- en: The suggestion above will eliminate 0's from your original matrix, but others
    may pop up in sub-determinants, though this should happen rarely. If you worry
    about this you should replace the basic instruction by
  prefs: []
  type: TYPE_NORMAL
- en: '**=if( a11*b12=a12*b11, $b$1, (a11*b12-a12*b11)/b2))**'
  prefs: []
  type: TYPE_NORMAL
- en: None of your friends will believe you can evaluate determinants so neatly, and
    they will not discover the divide by 0 flaw if you goad them to enter a matrix
    as ugly as they can make it. It will then not have annoying zeroes to divide by.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand you have the power to make the na?ve algorithm fail by creating
    a matrix for which the method will divide by 0.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise B.3 Set this up and get it to work and get the cofactor matrix for
    a 4 by 4 matrix using it.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**If you only want to evaluate 3 by 3 matrices and cross products, the set
    up is much simpler.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Here it is**'
  prefs: []
  type: TYPE_NORMAL
- en: Step 1
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter 1** in each of b1, b2, c1, c2, d1,d2, e1, e2 (this can be done by entering
    1 in b1 and copying to the rest).'
  prefs: []
  type: TYPE_NORMAL
- en: Step 2
  prefs: []
  type: TYPE_NORMAL
- en: '**Enter your matrix** in a3 a4 a5, b3 b4 b5 and c3 c4 and c5 or enter the two
    vectors you want the cross product of in a3 b3 c3 and a4 b4 and c4 (anything can
    be in the 5-th row).'
  prefs: []
  type: TYPE_NORMAL
- en: Step 3
  prefs: []
  type: TYPE_NORMAL
- en: '**Put =a3** in d3 and copy it to d3 d4 e3 and e4.'
  prefs: []
  type: TYPE_NORMAL
- en: Step 4
  prefs: []
  type: TYPE_NORMAL
- en: '**Put = (a3*b4-a4*b3)/b1** in a6 and copy it into a6 to d6 a7 to d7 a8 to d8
    a9 to d9.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The cross product will appear in b6 c6 d6.**'
  prefs: []
  type: TYPE_NORMAL
- en: And the **determinant in one or all of a9 b9 and c9.**
  prefs: []
  type: TYPE_NORMAL
- en: If no number appears then the determinant is 0.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, **if the determinant is 0,** then (b7, c7, d7) and (b6, c6, d6)
    if not all zeroes are **column eigenvectors** of your matrix, with **eigenvalue**
    0.
  prefs: []
  type: TYPE_NORMAL
- en: If you ever have to evaluate cross products or determinants, checking your answers
    using this method is a very good idea.
  prefs: []
  type: TYPE_NORMAL
