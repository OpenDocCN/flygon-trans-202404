["```\n # Lab 12 RNN\nimport torch\nimport torch.nn as nn\nfrom torch.autograd import Variable\n\ntorch.manual_seed(777)  # reproducibility\n\nidx2char = ['h', 'i', 'e', 'l', 'o']\n\n# Teach hihell -> ihello\nx_data = [[0, 1, 0, 2, 3, 3]]   # hihell\nx_one_hot = [[[1, 0, 0, 0, 0],   # h 0\n              [0, 1, 0, 0, 0],   # i 1\n              [1, 0, 0, 0, 0],   # h 0\n              [0, 0, 1, 0, 0],   # e 2\n              [0, 0, 0, 1, 0],   # l 3\n              [0, 0, 0, 1, 0]]]  # l 3\n\ny_data = [1, 0, 2, 3, 3, 4]    # ihello\n\n# As we have one batch of samples, we will change them to variables only once\ninputs = Variable(torch.Tensor(x_one_hot))\nlabels = Variable(torch.LongTensor(y_data))\n\nnum_classes = 5\ninput_size = 5  # one-hot size\nhidden_size = 5  # output from the LSTM. 5 to directly predict one-hot\nbatch_size = 1   # one sentence\nsequence_length = 6  # |ihello| == 6\nnum_layers = 1  # one-layer rnn\n\nclass RNN(nn.Module):\n\n    def __init__(self, num_classes, input_size, hidden_size, num_layers):\n        super(RNN, self).__init__()\n\n        self.num_classes = num_classes\n        self.num_layers = num_layers\n        self.input_size = input_size\n        self.hidden_size = hidden_size\n        self.sequence_length = sequence_length\n\n        self.rnn = nn.RNN(input_size=5, hidden_size=5, batch_first=True)\n\n    def forward(self, x):\n        # Initialize hidden and cell states\n        # (num_layers * num_directions, batch, hidden_size) for batch_first=True\n        h_0 = Variable(torch.zeros(\n            self.num_layers, x.size(0), self.hidden_size))\n\n        # Reshape input\n        x.view(x.size(0), self.sequence_length, self.input_size)\n\n        # Propagate input through RNN\n        # Input: (batch, seq_len, input_size)\n        # h_0: (num_layers * num_directions, batch, hidden_size)\n\n        out, _ = self.rnn(x, h_0)\n        return out.view(-1, num_classes)\n\n# Instantiate RNN model\nrnn = RNN(num_classes, input_size, hidden_size, num_layers)\nprint(rnn)\n\n# Set loss and optimizer function\n# CrossEntropyLoss = LogSoftmax + NLLLoss\ncriterion = torch.nn.CrossEntropyLoss()\noptimizer = torch.optim.Adam(rnn.parameters(), lr=0.1)\n\n# Train the model\nfor epoch in range(100):\n    outputs = rnn(inputs)\n    optimizer.zero_grad()\n    loss = criterion(outputs, labels)\n    loss.backward()\n    optimizer.step()\n    _, idx = outputs.max(1)\n    idx = idx.data.numpy()\n    result_str = [idx2char[c] for c in idx.squeeze()]\n    print(\"epoch: %d, loss: %1.3f\" % (epoch + 1, loss.data[0]))\n    print(\"Predicted string: \", ''.join(result_str))\n\nprint(\"Learning finished!\") \n```"]