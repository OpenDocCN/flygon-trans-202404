- en: BNF, Grammars, the AE LanguageTuesday, January 17th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getting back to the theme of the course: we want to investigate programming
    languages, and we want to do that *using* a programming language.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing when we design a language is to specify the language. For this
    we use BNF (Backus-Naur Form). For example, here is the definition of a simple
    arithmetic language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Explain the different parts. Specifically, this is a mixture of low-level (concrete)
    syntax definition with parsing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use this to derive expressions in some language. We start with `<AE>`, which
    should be one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: a number `<num>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an `<AE>`, the text “`+`”, and another `<AE>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the same but with “`-`”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<num>` is a terminal: when we reach it in the derivation, we’re done. `<AE>`
    is a non-terminal: when we reach it, we have to continue with one of the options.
    It should be clear that the “`+`” and the “`-`” are things we expect to find in
    the input — because they are not wrapped in `<>`s.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could specify what `<num>` is (turning it into a `<NUM>` non-terminal):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: But we don’t — why? Because in Racket we have numbers as primitives and we want
    to use Racket to implement our languages. This makes life a lot easier, and we
    get free stuff like floats, rationals etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a BNF formally, for example, to prove that `1-2+3` is a valid `<AE>`
    expression, we first label the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'and then we can use them as formal justifications for each derivation step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This would be one way of doing this. Alternatively, we can can visualize the
    derivation using a tree, with the rules used at the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'These specifications suffer from being ambiguous: an expression can be derived
    in multiple ways. Even the little syntax for a number is ambiguous — a number
    like `123` can be derived in two ways that result in trees that look different.
    This ambiguity is not a “real” problem now, but it will become one very soon.
    We want to get rid of this ambiguity, so that there is a single (= deterministic)
    way to derive all expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a standard way to resolve that — we add another non-terminal to the
    definition, and make it so that each rule can continue to exactly one of its alternatives.
    For example, this is what we can do with numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Similar solutions can be applied to the `<AE>` BNF — we either restrict the
    way derivations can happen or we come up with new non-terminals to force a deterministic
    derivation trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of restricting derivations, we look at the current grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'and instead of allowing an `<AE>` on both sides of the operation, we force
    one to be a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now there is a single way to derive any expression, and it is always associating
    operations to the right: an expression like `1+2+3` can only be derived as `1+(2+3)`.
    To change this to left-association, we would use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if we want to force precedence? Say that our AE syntax has addition
    and multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do that same thing as above and add new non-terminals — say one for
    “factors”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we must parse any AE expression as additions of multiplications (or numbers).
    First, note that if `<AE>` goes to `<PROD>` and that goes to `<num>`, then there
    is no need for an `<AE>` to go to a `<num>`, so this is the same syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we want to still be able to multiply additions, we can force them to
    appear in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, note that `<AE>` is still ambiguous about additions, which can be fixed
    by forcing the left hand side of an addition to be a factor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We still have an ambiguity for multiplications, so we do the same thing and
    add another non-terminal for “atoms”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: And you can try to derive several expressions to be convinced that derivation
    is always deterministic now.
  prefs: []
  type: TYPE_NORMAL
- en: But as you can see, this is exactly the cosmetics that we want to avoid — it
    will lead us to things that might be interesting, but unrelated to the principles
    behind programming languages. It will also become much much worse when we have
    a real language rather such a tiny one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Is there a good solution? — It is right in our face: do what Racket does —
    always use fully parenthesized expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent confusing Racket code with code in our language(s), we also change
    the parentheses to curly ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'But in Racket *everything* has a value — including those `+`s and `-`s, which
    makes this extremely convenient with future operations that might have either
    more or less arguments than 2 as well as treating these arithmetic operators as
    plain functions. In our toy language we will not do this initially (that is, `+`
    and `-` are second order operators: they cannot be used as values). But since
    we will get to it later, we’ll adopt the Racket solution and use a fully-parenthesized
    prefix notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: (Remember that in a sense, Racket code is written in a form of already-parsed
    syntax…)
  prefs: []
  type: TYPE_NORMAL
