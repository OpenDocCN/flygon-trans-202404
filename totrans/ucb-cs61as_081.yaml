- en: Local States
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Message Passing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way to get things to happen in OOP is to "ask" them to do something for
    you. The manner in which we do this is similar to the "message passing" that we
    did in Lesson 6\. How do we do it in OOP vocabulary?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have two objects: **`Matt-Account`** and **`Brian-Account`**,
    which are instances of `bank-account` classes. They hold the amount of money that
    **Matt** and **Brian** have, respectively. (You can''t type this into Scheme just
    yet! We are going to assume we made the objects previously.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`ask`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the **`ask`** procedure to tell objects to carry out a certain action.
    In the example above, the bank account objects accepts 3 messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`balance`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deposit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withdraw`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each of the 3 messsages, the bank account objects know what actions need
    to be carried out. Notice that some messages require additional information:'
  prefs: []
  type: TYPE_NORMAL
- en: For **balance**, it doesn't need any additional arguments. It returns the amount
    of money that account has.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For **deposit** and **withdraw**, we need one more argument to specify the amount
    we are depositing or withdrawing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The metaphor is that an object "knows how" to do certain tasks. These tasks
    are called **methods**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a bank account for Max, and we enter the following expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What is returned from the following expression?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What if, INSTEAD of the previous expression, we call this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: States
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider these calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: We called `(ask matt-account 'balance)` several times, each with different values.
    What does this tell us about OOP?
  prefs: []
  type: TYPE_NORMAL
- en: Both `matt-account` and `brian-account` returns how much money each person has.
    How does Matt's actions with his account (method calls to `matt-account`) affect
    Brian's account?
  prefs: []
  type: TYPE_NORMAL
- en: OOP Paradigm vs. Functional Programming Paradigm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first question, we see that Matt's balance changes with each withdraw
    and deposit. This feels natural for us because that is how bank accounts work.
    But, with the functional programming paradigm that we've been using so far, we
    would expect the same call to return the same value.
  prefs: []
  type: TYPE_NORMAL
- en: In the OOP paradigm, the objects have **state**. That is, they have some knowledge
    about what has happened to them in the past. In this example, a bank account has
    a balance, which changes when you deposit or withdraw some money.
  prefs: []
  type: TYPE_NORMAL
- en: Local State Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the second question, we see that although Matt has his 'balance' and Brian
    has his 'balance' that never interfere with each other.
  prefs: []
  type: TYPE_NORMAL
- en: In OOP jargon we say that 'balance' is a **local state variable **, or **instance
    variable**. An instance variable will have different values for different instances.
  prefs: []
  type: TYPE_NORMAL
- en: We can draw a parallel here with the definitions for
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Both definitions use x, but they are independent.
  prefs: []
  type: TYPE_NORMAL
