["```\ntrait Model {\n def score(input : AnyVal) : AnyVal\n def cleanup() : Unit\n def toBytes() : Array[Byte]\n def getType : Long\n}\n```", "```\nsyntax = \"proto3\";\n// Description of the trained model\nmessage ModelDescriptor {\n   // Model name\n   string name = 1;\n   // Human-readable description\n   string description = 2;\n   // Data type for which this model is applied\n   string dataType = 3;\n   // Model type\n   enum ModelType {\n       TENSORFLOW  = 0;\n       TENSORFLOWSAVED = 1;\n       PMML = 2;\n   };\n   ModelType modeltype = 4;\n   oneof MessageContent {\n       bytes data = 5;\n       string location = 6;\n   }\n}\n```", "```\nsyntax = \"proto3\";\n// Description of the wine parameters\nmessage WineRecord {\n   double fixed_acidity = 1;\n   double volatile_acidity = 2;\n   double citric_acid = 3;\n   double residual_sugar = 4;\n   double chlorides = 5;\n   double free_sulfur_dioxide = 6;\n   double total_sulfur_dioxide = 7;\n   double density = 8;\n   double pH = 9;\n   double sulphates = 10;\n   double alcohol = 11;\n   // Data type for this record\n   string dataType = 12;\n}\n```", "```\ntrait ModelFactory {\n def create(input : ModelDescriptor) : Model\n def restore(bytes : Array[Byte]) : Model\n}\n```", "```\nclass KafkaMessageSender (brokers: String, zookeeper : String){\n\n // Configure\n ...\n // Create producer\n val producer = new KafkaProducer[Array[Byte], Array[Byte]](props)\n val zkUtils = ZkUtils.apply(zookeeper, KafkaMessageSender\n   .sessionTimeout, KafkaMessageSender.connectionTimeout, false)\n\n // Write value to the queue\n def writeValue(topic:String, value:Array[Byte]): RecordMetadata = {\n   val result = producer.send(\n     new ProducerRecord[Array[Byte],\n       Array[Byte]](topic, null, value)).get\n       producer.flush()\n   result\n }\n\n // Close producer\n def close(): Unit = {\n   producer.close\n }\n\n def createTopic(topic : String, numPartitions: Int = 1,\n   replicationFactor : Int = 1): Unit = {\n   if (!AdminUtils.topicExists(zkUtils, topic)){\n     try {\n       AdminUtils.createTopic(...\n     }catch {\n       ...\n     }\n   }\n   else\n     println(s\"Topic $topic already exists\")\n }\n}\n\nobject KafkaMessageSender{\n ...\n private val senders : Map[String, KafkaMessageSender] = Map()\n\n def apply(brokers:String, zookeeper :String): KafkaMessageSender ={\n   senders.get(brokers) match {\n     case Some(sender) => sender\n     case _ => {\n       val sender = new KafkaMessageSender(brokers, zookeeper)\n       senders.put(brokers, sender)\n       sender\n     }\n   }\n }\n}\n```", "```\nDataProvider {\n\n ...\n\n def main(args: Array[String]) {\n   val sender = KafkaMessageSender(\n     ApplicationKafkaParameters.LOCAL_KAFKA_BROKER,\n     ApplicationKafkaParameters.LOCAL_ZOOKEEPER_HOST)\n   sender.createTopic(ApplicationKafkaParameters.DATA_TOPIC)\n   val bos = new ByteArrayOutputStream()\n   val records  = getListOfRecords(file)\n   while (true) {\n     var lineCounter = 0\n     records.foreach(r => {\n       bos.reset()\n       r.writeTo(bos)\n       sender.writeValue(ApplicationKafkaParameters.DATA_TOPIC,\n         bos.toByteArray)\n       pause()\n     })\n     pause()\n   }\n }\n ...\n def getListOfRecords(file: String): Seq[WineRecord] = {\n\n   var result = Seq.empty[WineRecord]\n   val bufferedSource = Source.fromFile(file)\n   for (line <- bufferedSource.getLines) {\n     val cols = line.split(\";\").map(_.trim)\n     val record = new WineRecord(\n       fixedAcidity = cols(0).toDouble,\n       volatileAcidity = cols(1).toDouble,\n       citricAcid = cols(2).toDouble,\n       residualSugar = cols(3).toDouble,\n       chlorides = cols(4).toDouble,\n       freeSulfurDioxide = cols(5).toDouble,\n       totalSulfurDioxide = cols(6).toDouble,\n       density = cols(7).toDouble,\n       pH = cols(8).toDouble,\n       sulphates = cols(9).toDouble,\n       alcohol = cols(10).toDouble,\n       dataType = \"wine\"\n     )\n     result = record +: result\n   }\n   bufferedSource.close\n   result\n }\n}\n```"]