["```\n\n```", "```\n\n# Simple Extensions to STLC\n\n    The simply typed lambda-calculus has enough structure to make its\n    theoretical properties interesting, but it is not much of a\n    programming language.\n\n    In this chapter, we begin to close the gap with real-world\n    languages by introducing a number of familiar features that have\n    straightforward treatments at the level of typing. \n\n## Numbers\n\n    As we saw in exercise stlc_arith at the end of the StlcProp\n    chapter, adding types, constants, and primitive operations for\n    natural numbers is easy \u2014 basically just a matter of combining\n    the [Types](Types.html) and [Stlc](Stlc.html) chapters.  Adding more realistic\n    numeric types like machine integers and floats is also\n    straightforward, though of course the specifications of the\n    numeric primitives become more fiddly. \n\n## Let Bindings\n\n    When writing a complex expression, it is useful to be able\n    to give names to some of its subexpressions to avoid repetition\n    and increase readability.  Most languages provide one or more ways\n    of doing this.  In OCaml (and Coq), for example, we can write let x=t[1] in t[2] to mean \"reduce the expression t[1] to a value and\n    bind the name x to this value while reducing t[2].\"\n\n    Our let-binder follows OCaml in choosing a standard\n    *call-by-value* evaluation order, where the let-bound term must\n    be fully reduced before reduction of the let-body can begin.\n    The typing rule T_Let tells us that the type of a let can be\n    calculated by calculating the type of the let-bound term,\n    extending the context with a binding with this type, and in this\n    enriched context calculating the type of the body (which is then\n    the type of the whole let expression).\n\n    At this point in the book, it's probably easier simply to look at\n    the rules defining this new feature than to wade through a lot of\n    English text conveying the same information.  Here they are: \n\n    Syntax:\n\n```", "```\n\n    Reduction:\n\n                        t[1]\u00a0\u21d2\u00a0t[1]'\n           |\n\n                        (ST_Let1) \u00a0\n           |\n\n* * *\n\n           |\n\n                        let\u00a0x=t[1]\u00a0in\u00a0t[2]\u00a0\u21d2\u00a0let\u00a0x=t[1]'\u00a0in\u00a0t[2]\n           |\n\n                     |\n\n           |\n\n                        (ST_LetValue) \u00a0\n           |\n\n* * *\n\n           |\n\n                        let\u00a0x=v[1]\u00a0in\u00a0t[2]\u00a0\u21d2\u00a0[x:=v[1]]t[2]\n           |\n\n                     |\n\n    Typing:\n\n                        \u0393\u00a0\u22a2\u00a0t[1]\u00a0:\u00a0T[1]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Gamma,\u00a0x:T[1]\u00a0\u22a2\u00a0t[2]\u00a0:\u00a0T[2]\n           |\n\n                        (T_Let) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0let\u00a0x=t[1]\u00a0in\u00a0t[2]\u00a0:\u00a0T[2]\n           |\n\n                     |\n\n## Pairs\n\n    Our functional programming examples in Coq have made\n    frequent use of *pairs* of values.  The type of such a pair is\n    called a *product type*.\n\n    The formalization of pairs is almost too simple to be worth\n    discussing.  However, let's look briefly at the various parts of\n    the definition to emphasize the common pattern. \n\n    In Coq, the primitive way of extracting the components of a pair\n    is *pattern matching*.  An alternative is to take fst and\n    snd \u2014 the first- and second-projection operators \u2014 as\n    primitives.  Just for fun, let's do our pairs this way.  For\n    example, here's how we'd write a function that takes a pair of\n    numbers and returns the pair of their sum and difference:\n\n```", "```\n\n    Adding pairs to the simply typed lambda-calculus, then, involves\n    adding two new forms of term \u2014 pairing, written (t[1],t[2]), and\n    projection, written t.fst for the first projection from t and\n    t.snd for the second projection \u2014 plus one new type constructor,\n    T[1]*T[2], called the *product* of T[1] and T[2].  \n\n    Syntax:\n\n```", "```\n\n    For reduction, we need several new rules specifying how pairs and\n    projection behave. \n\n                        t[1]\u00a0\u21d2\u00a0t[1]'\n           |\n\n                        (ST_Pair1) \u00a0\n           |\n\n* * *\n\n           |\n\n                        (t[1],t[2])\u00a0\u21d2\u00a0(t[1]',t[2])\n           |\n\n                     |\n\n                        t[2]\u00a0\u21d2\u00a0t[2]'\n           |\n\n                        (ST_Pair2) \u00a0\n           |\n\n* * *\n\n           |\n\n                        (v[1],t[2])\u00a0\u21d2\u00a0(v[1],t[2]')\n           |\n\n                     |\n\n                        t[1]\u00a0\u21d2\u00a0t[1]'\n           |\n\n                        (ST_Fst1) \u00a0\n           |\n\n* * *\n\n           |\n\n                        t[1].fst\u00a0\u21d2\u00a0t[1]'.fst\n           |\n\n                     |\n\n           |\n\n                        (ST_FstPair) \u00a0\n           |\n\n* * *\n\n           |\n\n                        (v[1],v[2]).fst\u00a0\u21d2\u00a0v[1]\n           |\n\n                     |\n\n                        t[1]\u00a0\u21d2\u00a0t[1]'\n           |\n\n                        (ST_Snd1) \u00a0\n           |\n\n* * *\n\n           |\n\n                        t[1].snd\u00a0\u21d2\u00a0t[1]'.snd\n           |\n\n                     |\n\n           |\n\n                        (ST_SndPair) \u00a0\n           |\n\n* * *\n\n           |\n\n                        (v[1],v[2]).snd\u00a0\u21d2\u00a0v[2]\n           |\n\n                     |\n\n    Rules ST_FstPair and ST_SndPair say that, when a fully\n    reduced pair meets a first or second projection, the result is\n    the appropriate component.  The congruence rules ST_Fst1 and\n    ST_Snd1 allow reduction to proceed under projections, when the\n    term being projected from has not yet been fully reduced.\n    ST_Pair1 and ST_Pair2 reduce the parts of pairs: first the\n    left part, and then \u2014 when a value appears on the left \u2014 the right\n    part.  The ordering arising from the use of the metavariables v\n    and t in these rules enforces a left-to-right evaluation\n    strategy for pairs.  (Note the implicit convention that\n    metavariables like v and v[1] can only denote values.)  We've\n    also added a clause to the definition of values, above, specifying\n    that (v[1],v[2]) is a value.  The fact that the components of a pair\n    value must themselves be values ensures that a pair passed as an\n    argument to a function will be fully reduced before the function\n    body starts executing. \n\n    The typing rules for pairs and projections are straightforward. \n\n                        \u0393\u00a0\u22a2\u00a0t[1]\u00a0:\u00a0T[1]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393\u00a0\u22a2\u00a0t[2]\u00a0:\u00a0T[2]\n           |\n\n                        (T_Pair) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0(t[1],t[2])\u00a0:\u00a0T[1]*T[2]\n           |\n\n                     |\n\n                        \u0393\u00a0\u22a2\u00a0t[1]\u00a0:\u00a0T[11]*T[12]\n           |\n\n                        (T_Fst) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0t[1].fst\u00a0:\u00a0T[11]\n           |\n\n                     |\n\n                        \u0393\u00a0\u22a2\u00a0t[1]\u00a0:\u00a0T[11]*T[12]\n           |\n\n                        (T_Snd) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0t[1].snd\u00a0:\u00a0T[12]\n           |\n\n                     |\n\n    T_Pair says that (t[1],t[2]) has type T[1]*T[2] if t[1] has\n   type T[1] and t[2] has type T[2].  Conversely, T_Fst and T_Snd\n   tell us that, if t[1] has a product type T[11]*T[12] (i.e., if it\n   will reduce to a pair), then the types of the projections from\n   this pair are T[11] and T[12]. \n\n## Unit\n\n    Another handy base type, found especially in languages in\n    the ML family, is the singleton type Unit.  It has a single element \u2014 the term constant unit (with a small\n    u) \u2014 and a typing rule making unit an element of Unit.  We\n    also add unit to the set of possible values \u2014 indeed, unit is\n    the *only* possible result of reducing an expression of type\n    Unit. \n\n    Syntax:\n\n```", "```\n\n    Typing:\n\n           |\n\n                        (T_Unit) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0unit\u00a0:\u00a0Unit\n           |\n\n                     |\n\n    It may seem a little strange to bother defining a type that\n    has just one element \u2014 after all, wouldn't every computation\n    living in such a type be trivial?\n\n    This is a fair question, and indeed in the STLC the Unit type is\n    not especially critical (though we'll see two uses for it below).\n    Where Unit really comes in handy is in richer languages with\n    *side effects* \u2014 e.g., assignment statements that mutate\n    variables or pointers, exceptions and other sorts of nonlocal\n    control structures, etc.  In such languages, it is convenient to\n    have a type for the (trivial) result of an expression that is\n    evaluated only for its effect. \n\n## Sums\n\n    Many programs need to deal with values that can take two distinct\n   forms.  For example, we might identify employees in an accounting\n   application using *either* their name *or* their id number.\n   A search function might return *either* a matching value *or* an\n   error code.\n\n    These are specific examples of a binary *sum type* (sometimes called\n   a *disjoint union*), which describes a set of values drawn from \n   one of two given types, e.g.:\n\n```", "```\n\n    We create elements of these types by *tagging* elements of\n    the component types.  For example, if n is a Nat then inl n\n    is an element of Nat+Bool; similarly, if b is a Bool then\n    inr b is a Nat+Bool.  The names of the tags inl and inr\n    arise from thinking of them as functions\n\n```", "```\n\n    that \"inject\" elements of Nat or Bool into the left and right\n    components of the sum type Nat+Bool.  (But note that we don't\n    actually treat them as functions in the way we formalize them:\n    inl and inr are keywords, and inl t and inr t are primitive\n    syntactic forms, not function applications.) \n\n    In general, the elements of a type T[1] + T[2] consist of the\n    elements of T[1] tagged with the token inl, plus the elements of\n    T[2] tagged with inr. \n\n    One important usage of sums is signaling errors:\n\n```", "```\n\n    The type Nat + Unit above is in fact isomorphic to option nat in Coq \u2014 i.e., it's easy to write functions that translate\n    back and forth. \n\n    To *use* elements of sum types, we introduce a case\n    construct (a very simplified form of Coq's match) to destruct\n    them. For example, the following procedure converts a Nat+Bool\n    into a Nat: \n\n```", "```\n\n    More formally... \n\n    Syntax:\n\n```", "```\n\n    Reduction:\n\n                        t[1]\u00a0\u21d2\u00a0t[1]'\n           |\n\n                        (ST_Inl) \u00a0\n           |\n\n* * *\n\n           |\n\n                        inl\u00a0T\u00a0t[1]\u00a0\u21d2\u00a0inl\u00a0T\u00a0t[1]'\n           |\n\n                     |\n\n                        t[1]\u00a0\u21d2\u00a0t[1]'\n           |\n\n                        (ST_Inr) \u00a0\n           |\n\n* * *\n\n           |\n\n                        inr\u00a0T\u00a0t[1]\u00a0\u21d2\u00a0inr\u00a0T\u00a0t[1]'\n           |\n\n                     |\n\n                        t[0]\u00a0\u21d2\u00a0t[0]'\n           |\n\n                        (ST_Case) \u00a0\n           |\n\n* * *\n\n           |\n\n                        case\u00a0t[0]\u00a0of\u00a0inl\u00a0x[1]\u00a0\u21d2\u00a0t[1]\u00a0&#124;\u00a0inr\u00a0x[2]\u00a0\u21d2\u00a0t[2]\u00a0\u21d2\n           |\n\n                     |\n\n                        case\u00a0t[0]'\u00a0of\u00a0inl\u00a0x[1]\u00a0\u21d2\u00a0t[1]\u00a0&#124;\u00a0inr\u00a0x[2]\u00a0\u21d2\u00a0t[2]\n           |\n\n                     |\n\n           |\n\n                        (ST_CaseInl) \u00a0\n           |\n\n* * *\n\n           |\n\n                        case\u00a0(inl\u00a0T\u00a0v[0])\u00a0of\u00a0inl\u00a0x[1]\u00a0\u21d2\u00a0t[1]\u00a0&#124;\u00a0inr\u00a0x[2]\u00a0\u21d2\u00a0t[2]\n           |\n\n                     |\n\n                        \u21d2\u00a0\u00a0[x[1]:=v[0]]t[1]\n           |\n\n                     |\n\n           |\n\n                        (ST_CaseInr) \u00a0\n           |\n\n* * *\n\n           |\n\n                        case\u00a0(inr\u00a0T\u00a0v[0])\u00a0of\u00a0inl\u00a0x[1]\u00a0\u21d2\u00a0t[1]\u00a0&#124;\u00a0inr\u00a0x[2]\u00a0\u21d2\u00a0t[2]\n           |\n\n                     |\n\n                        \u21d2\u00a0\u00a0[x[2]:=v[0]]t[2]\n           |\n\n                     |\n\n    Typing:\n\n                        \u0393\u00a0\u22a2\u00a0t[1]\u00a0:\u00a0\u00a0T[1]\n           |\n\n                        (T_Inl) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0inl\u00a0T[2]\u00a0t[1]\u00a0:\u00a0T[1]\u00a0+\u00a0T[2]\n           |\n\n                     |\n\n                        \u0393\u00a0\u22a2\u00a0t[1]\u00a0:\u00a0T[2]\n           |\n\n                        (T_Inr) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0inr\u00a0T[1]\u00a0t[1]\u00a0:\u00a0T[1]\u00a0+\u00a0T[2]\n           |\n\n                     |\n\n                        \u0393\u00a0\u22a2\u00a0t[0]\u00a0:\u00a0T[1]+T[2]\n           |\n\n                     |\n\n                        \u0393\u00a0,\u00a0x[1]:T[1]\u00a0\u22a2\u00a0t[1]\u00a0:\u00a0T\n           |\n\n                     |\n\n                        \u0393\u00a0,\u00a0x[2]:T[2]\u00a0\u22a2\u00a0t[2]\u00a0:\u00a0T\n           |\n\n                        (T_Case) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0case\u00a0t[0]\u00a0of\u00a0inl\u00a0x[1]\u00a0\u21d2\u00a0t[1]\u00a0&#124;\u00a0inr\u00a0x[2]\u00a0\u21d2\u00a0t[2]\u00a0:\u00a0T\n           |\n\n                     |\n\n    We use the type annotation in inl and inr to make the typing \n    relation simpler, similarly to what we did for functions. \n\n    Without this extra information, the typing rule T_Inl, for\n    example, would have to say that, once we have shown that t[1] is\n    an element of type T[1], we can derive that inl t[1] is an element\n    of T[1] + T[2] for *any* type T[2].  For example, we could derive both\n    inl 5 : Nat + Nat and inl 5 : Nat + Bool (and infinitely many\n    other types).  This peculiarity (technically, a failure of\n    uniqueness of types) would mean that we cannot build a\n    typechecking algorithm simply by \"reading the rules from bottom to\n    top\" as we could for all the other features seen so far.\n\n    There are various ways to deal with this difficulty.  One simple\n    one \u2014 which we've adopted here \u2014 forces the programmer to\n    explicitly annotate the \"other side\" of a sum type when performing\n    an injection.  This is a bit heavy for programmers (so real\n    languages adopt other solutions), but it is easy to understand and\n    formalize. \n\n## Lists\n\n    The typing features we have seen can be classified into *base types* like Bool, and *type constructors* like \u2192 and * that\n    build new types from old ones.  Another useful type constructor is\n    List.  For every type T, the type List T describes\n    finite-length lists whose elements are drawn from T.\n\n    In principle, we could encode lists using pairs, sums and\n    *recursive* types. But giving semantics to recursive types is\n    non-trivial. Instead, we'll just discuss the special case of lists\n    directly.\n\n    Below we give the syntax, semantics, and typing rules for lists.\n    Except for the fact that explicit type annotations are mandatory\n    on nil and cannot appear on cons, these lists are essentially\n    identical to those we built in Coq.  We use lcase to destruct\n    lists, to avoid dealing with questions like \"what is the head of\n    the empty list?\" \n\n    For example, here is a function that calculates the sum of\n    the first two elements of a list of numbers:\n\n```", "```\n\n    Syntax:\n\n```", "```\n\n    Reduction:\n\n                        t[1]\u00a0\u21d2\u00a0t[1]'\n           |\n\n                        (ST_Cons1) \u00a0\n           |\n\n* * *\n\n           |\n\n                        cons\u00a0t[1]\u00a0t[2]\u00a0\u21d2\u00a0cons\u00a0t[1]'\u00a0t[2]\n           |\n\n                     |\n\n                        t[2]\u00a0\u21d2\u00a0t[2]'\n           |\n\n                        (ST_Cons2) \u00a0\n           |\n\n* * *\n\n           |\n\n                        cons\u00a0v[1]\u00a0t[2]\u00a0\u21d2\u00a0cons\u00a0v[1]\u00a0t[2]'\n           |\n\n                     |\n\n                        t[1]\u00a0\u21d2\u00a0t[1]'\n           |\n\n                        (ST_Lcase1) \u00a0\n           |\n\n* * *\n\n           |\n\n                        (lcase\u00a0t[1]\u00a0of\u00a0nil\u00a0\u2192\u00a0t[2]\u00a0&#124;\u00a0xh::xt\u00a0\u2192\u00a0t[3])\u00a0\u21d2\n           |\n\n                     |\n\n                        (lcase\u00a0t[1]'\u00a0of\u00a0nil\u00a0\u2192\u00a0t[2]\u00a0&#124;\u00a0xh::xt\u00a0\u2192\u00a0t[3])\n           |\n\n                     |\n\n           |\n\n                        (ST_LcaseNil) \u00a0\n           |\n\n* * *\n\n           |\n\n                        (lcase\u00a0nil\u00a0T\u00a0of\u00a0nil\u00a0\u2192\u00a0t[2]\u00a0&#124;\u00a0xh::xt\u00a0\u2192\u00a0t[3])\n           |\n\n                     |\n\n                        \u21d2\u00a0t[2]\n           |\n\n                     |\n\n           |\n\n                        (ST_LcaseCons) \u00a0\n           |\n\n* * *\n\n           |\n\n                        (lcase\u00a0(cons\u00a0vh\u00a0vt)\u00a0of\u00a0nil\u00a0\u2192\u00a0t[2]\u00a0&#124;\u00a0xh::xt\u00a0\u2192\u00a0t[3])\n           |\n\n                     |\n\n                        \u21d2\u00a0[xh:=vh,xt:=vt]t[3]\n           |\n\n                     |\n\n    Typing:\n\n           |\n\n                        (T_Nil) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0nil\u00a0T\u00a0:\u00a0List\u00a0T\n           |\n\n                     |\n\n                        \u0393\u00a0\u22a2\u00a0t[1]\u00a0:\u00a0T\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393\u00a0\u22a2\u00a0t[2]\u00a0:\u00a0List\u00a0T\n           |\n\n                        (T_Cons) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0cons\u00a0t[1]\u00a0t[2]:\u00a0List\u00a0T\n           |\n\n                     |\n\n                        \u0393\u00a0\u22a2\u00a0t[1]\u00a0:\u00a0List\u00a0T[1]\n           |\n\n                     |\n\n                        \u0393\u00a0\u22a2\u00a0t[2]\u00a0:\u00a0T\n           |\n\n                     |\n\n                        \u0393\u00a0,\u00a0h:T[1],\u00a0t:List\u00a0T[1]\u00a0\u22a2\u00a0t[3]\u00a0:\u00a0T\n           |\n\n                        (T_Lcase) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0(lcase\u00a0t[1]\u00a0of\u00a0nil\u00a0\u2192\u00a0t[2]\u00a0&#124;\u00a0h::t\u00a0\u2192\u00a0t[3])\u00a0:\u00a0T\n           |\n\n                     |\n\n## General Recursion\n\n    Another facility found in most programming languages (including\n    Coq) is the ability to define recursive functions.  For example,\n    we might like to be able to define the factorial function like\n    this:\n\n```", "```\n\n    Note that the right-hand side of this binder mentions the variable\n   being bound \u2014 something that is not allowed by our formalization of\n   let above.  \n\n    Directly formalizing this \"recursive definition\" mechanism is possible, \n   but it requires a bit of extra effort: in particular, we'd have to \n   pass around an \"environment\" of recursive function definitions in \n   the definition of the step relation. \n\n    Here is another way of presenting recursive functions that is equally\n    powerful (though not quite as convenient for the programmer) and \n    more straightforward to formalize: instead of writing recursive \n    definitions, we define a *fixed-point operator* called fix \n    that performs the \"unfolding\" of the recursive definition in the \n    right-hand side as needed, during reduction.  \n\n    For example, instead of \n\n```", "```\n\n    we will write:\n\n```", "```\n\n    We can derive the latter from the former as follows:\n\n*   In the right-hand side of the definition of fact, replace recursive references to fact by a fresh variable f. \n\n*   Add an abstraction binding f at the front, with an appropriate type annotation. (Since we are using f in place of fact, which had type Nat\u2192Nat, we should require f to have the same type.) The new abstraction has type (Nat\u2192Nat) \u2192 (Nat\u2192Nat). \n\n*   Apply fix to this abstraction. This application has type Nat\u2192Nat. \n\n*   Use all of this as the right-hand side of an ordinary let-binding for fact.\n\n    The intuition is that the higher-order function f passed\n    to fix is a *generator* for the fact function: if f is\n    applied to a function that \"approximates\" the desired behavior of\n    fact up to some number n (that is, a function that returns\n    correct results on inputs less than or equal to n but we don't\n    care what it does on inputs greater than n), then f returns a\n    slightly better approximation to fact \u2014 a function that returns\n    correct results for inputs up to n+1.  Applying fix to this\n    generator returns its *fixed point*, which is a function that\n    gives the desired behavior for all inputs n.\n\n    (The term \"fixed point\" is used here in exactly the same sense as\n    in ordinary mathematics, where a fixed point of a function f is\n    an input x such that f(x) = x.  Here, a fixed point of a\n    function F of type (Nat\u2192Nat)->(Nat\u2192Nat) is a function f of\n    type Nat\u2192Nat such that F f behaves the same as f.) \n\n    Syntax:\n\n```", "```\n\n    Reduction:\n\n                        t[1]\u00a0\u21d2\u00a0t[1]'\n           |\n\n                        (ST_Fix1) \u00a0\n           |\n\n* * *\n\n           |\n\n                        fix\u00a0t[1]\u00a0\u21d2\u00a0fix\u00a0t[1]'\n           |\n\n                     |\n\n           |\n\n                        (ST_FixAbs) \u00a0\n           |\n\n* * *\n\n           |\n\n                        fix\u00a0(\u03bbxf:T[1].t2)\u00a0\u21d2\u00a0[xf:=fix\u00a0(\u03bbxf:T[1].t2)]\u00a0t[2]\n           |\n\n                     |\n\n    Typing:\n\n                        \u0393\u00a0\u22a2\u00a0t[1]\u00a0:\u00a0T[1]->T[1]\n           |\n\n                        (T_Fix) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0fix\u00a0t[1]\u00a0:\u00a0T[1]\n           |\n\n                     |\n\n    Let's see how ST_FixAbs works by reducing fact 3 = fix F 3,\n    where \n\n```", "```\n\n    (type annotations are omitted for brevity).\n\n```", "```\n\n    \u21d2 ST_FixAbs + ST_App1 \n\n```", "```\n\n    \u21d2 ST_AppAbs \n\n```", "```\n\n    \u21d2 ST_If0_Nonzero \n\n```", "```\n\n    \u21d2 ST_FixAbs + ST_Mult2 \n\n```", "```\n\n    \u21d2 ST_PredNat + ST_Mult2 + ST_App2 \n\n```", "```\n\n    \u21d2 ST_AppAbs + ST_Mult2 \n\n```", "```\n\n    \u21d2 ST_If0_Nonzero + ST_Mult2 \n\n```", "```\n\n    \u21d2 ST_FixAbs + 2 x ST_Mult2 \n\n```", "```\n\n    \u21d2 ST_PredNat + 2 x ST_Mult2 + ST_App2 \n\n```", "```\n\n    \u21d2 ST_AppAbs + 2 x ST_Mult2 \n\n```", "```\n\n    \u21d2 ST_If0_Nonzero + 2 x ST_Mult2 \n\n```", "```\n\n    \u21d2 ST_FixAbs + 3 x ST_Mult2 \n\n```", "```\n\n    \u21d2 ST_PredNat + 3 x ST_Mult2 + ST_App2 \n\n```", "```\n\n    \u21d2 ST_AppAbs + 3 x ST_Mult2 \n\n```", "```\n\n    \u21d2 ST_If0Zero + 3 x ST_Mult2 \n\n```", "```\n\n    \u21d2 ST_MultNats + 2 x ST_Mult2 \n\n```", "```\n\n    \u21d2 ST_MultNats + ST_Mult2 \n\n```", "```\n\n    \u21d2 ST_MultNats \n\n```", "```\n\n    One important point to note is that, unlike Fixpoint\n    definitions in Coq, there is nothing to prevent functions defined\n    using fix from diverging. \n\n#### Exercise: 1 star, optional (halve_fix)\n\n    Translate this informal recursive definition into one using fix:\n\n```", "```\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610 \n\n#### Exercise: 1 star, optional (fact_steps)\n\n    Write down the sequence of steps that the term fact 1 goes\n    through to reduce to a normal form (assuming the usual reduction\n    rules for arithmetic operations).\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610 \n\n    The ability to form the fixed point of a function of type T\u2192T\n    for any T has some surprising consequences.  In particular, it\n    implies that *every* type is inhabited by some term.  To see this,\n    observe that, for every type T, we can define the term\n\n```", "```\n    equal =\n      fix\n        (\u03bbeq:Nat->Nat->Bool.\n           \u03bbm:Nat. \u03bbn:Nat.\n             if m=0 then iszero n\n             else if n=0 then false\n             else eq (pred m) (pred n))\n\n```", "```\n      evenodd =\n        fix\n          (\u03bbeo: (Nat->Bool * Nat->Bool).\n             let e = \u03bbn:Nat. if n=0 then true  else eo.snd (pred n) in\n             let o = \u03bbn:Nat. if n=0 then false else eo.fst (pred n) in\n             (e,o))\n\n      even = evenodd.fst\n      odd  = evenodd.snd\n\n```", "```\n\n## Records\n\n    As a final example of a basic extension of the STLC, let's look\n    briefly at how to define *records* and their types.  Intuitively,\n    records can be obtained from pairs by two straightforward\n    generalizations: they are n-ary (rather than just binary) and\n    their fields are accessed by *label* (rather than position). \n\n    Syntax:\n\n```", "```\n\n    The generalization from products should be pretty obvious.  But \n   it's worth noticing the ways in which what we've actually written is\n   even *more* informal than the informal syntax we've used in previous \n   sections and chapters: we've used \"...\" in several places to mean \"any\n   number of these,\" and we've omitted explicit mention of the usual\n   side condition that the labels of a record should not contain any\n   repetitions. \n\n    Reduction:\n\n                        ti\u00a0\u21d2\u00a0ti'\n           |\n\n                        (ST_Rcd) \u00a0\n           |\n\n* * *\n\n           |\n\n                        {i[1]=v[1],\u00a0...,\u00a0im=vm,\u00a0in=ti,\u00a0...}\n           |\n\n                     |\n\n                        \u21d2\u00a0{i[1]=v[1],\u00a0...,\u00a0im=vm,\u00a0in=ti',\u00a0...}\n           |\n\n                     |\n\n                        t[1]\u00a0\u21d2\u00a0t[1]'\n           |\n\n                        (ST_Proj1) \u00a0\n           |\n\n* * *\n\n           |\n\n                        t[1].i\u00a0\u21d2\u00a0t[1]'.i\n           |\n\n                     |\n\n           |\n\n                        (ST_ProjRcd) \u00a0\n           |\n\n* * *\n\n           |\n\n                        {...,\u00a0i=vi,\u00a0...}.i\u00a0\u21d2\u00a0vi\n           |\n\n                     |\n\n    Again, these rules are a bit informal.  For example, the first rule\n   is intended to be read \"if ti is the leftmost field that is not a\n   value and if ti steps to ti', then the whole record steps...\"\n   In the last rule, the intention is that there should only be one\n   field called i, and that all the other fields must contain values. \n\n    The typing rules are also simple:\n\n                        \u0393\u00a0\u22a2\u00a0t[1]\u00a0:\u00a0T[1]\u00a0\u00a0\u00a0\u00a0\u00a0...\u00a0\u00a0\u00a0\u00a0\u00a0\u0393\u00a0\u22a2\u00a0tn\u00a0:\u00a0Tn\n           |\n\n                        (T_Rcd) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0{i[1]=t[1],\u00a0...,\u00a0in=tn}\u00a0:\u00a0{i[1]:T[1],\u00a0...,\u00a0in:Tn}\n           |\n\n                     |\n\n                        \u0393\u00a0\u22a2\u00a0t\u00a0:\u00a0{...,\u00a0i:Ti,\u00a0...}\n           |\n\n                        (T_Proj) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0t.i\u00a0:\u00a0Ti\n           |\n\n                     |\n\n    There are several ways to approach formalizing the above\n    definitions.\n\n*   We can directly formalize the syntactic forms and inference rules, staying as close as possible to the form we've given them above. This is conceptually straightforward, and it's probably what we'd want to do if we were building a real compiler (in particular, it will allow us to print error messages in the form that programmers will find easy to understand). But the formal versions of the rules will not be very pretty or easy to work with, because all the ...s above will have to be replaced with explicit quantifications or comprehensions. For this reason, records are not included in the extended exercise at the end of this chapter. (It is still useful to discuss them informally here because they will help motivate the addition of subtyping to the type system when we get to the [Sub](Sub.html) chapter.) \n\n*   Alternatively, we could look for a smoother way of presenting records \u2014 for example, a binary presentation with one constructor for the empty record and another constructor for adding a single field to an existing record, instead of a single monolithic constructor that builds a whole record at once. This is the right way to go if we are primarily interested in studying the metatheory of the calculi with records, since it leads to clean and elegant definitions and proofs. Chapter [Records](Records.html) shows how this can be done. \n\n*   Finally, if we like, we can avoid formalizing records altogether, by stipulating that record notations are just informal shorthands for more complex expressions involving pairs and product types. We sketch this approach in the next section.\n\n```", "```\n      {}                 ---->  unit\n      {t1, t2, ..., tn}  ---->  (t1, trest)\n                                where {t2, ..., tn} ----> trest\n\n```", "```\n      {}                 ---->  Unit\n      {T1, T2, ..., Tn}  ---->  T1 * TRest\n                                where {T2, ..., Tn} ----> TRest\n\n```", "```\n      t.0        ---->  t.fst\n      t.(n+1)    ---->  (t.snd).n\n\n```", "```\n      LABEL   POSITION\n      a       0\n      b       1\n      c       2\n      ...     ...\n      bar     1395\n      ...     ...\n      foo     4460\n      ...     ...\n\n```", "```\n      {a=5, b=6}      ---->   {5,6}\n      {a=5, c=7}      ---->   {5,unit,7}\n      {c=7, a=5}      ---->   {5,unit,7}\n      {c=5, b=3}      ---->   {unit,3,5}\n      {f=8,c=5,a=7}   ---->   {7,unit,5,unit,unit,8}\n      {f=8,c=5}       ---->   {unit,unit,5,unit,unit,8}\n\n```", "```\n      {a:Nat, b:Nat}      ---->   {Nat,Nat}\n      {c:Nat, a:Nat}      ---->   {Nat,Unit,Nat}\n      {f:Nat,c:Nat}       ---->   {Unit,Unit,Nat,Unit,Unit,Nat}\n\n```", "```\n      t.l  ---->  t.(position of l)\n\n```", "```\n\n# Exercise: Formalizing the Extensions\n\n#### Exercise: 5 stars (STLC_extensions)\n\n    In this exercise, you will formalize some of the extensions\n    described in this chapter.  We've provided the necessary additions\n    to the syntax of terms and types, and we've included a few\n    examples that you can test your definitions with to make sure they\n    are working as expected.  You'll fill in the rest of the\n    definitions and extend all the proofs accordingly.\n\n    To get you started, we've provided implementations for:\n\n*   numbers\n\n*   sums\n\n*   lists\n\n*   unit\n\n    You need to complete the implementations for:\n\n*   pairs\n\n*   let (which involves binding)\n\n*   fix\n\n    A good strategy is to work on the extensions one at a time, in two\n    passes, rather than trying to work through the file from start to\n    finish in a single pass.  For each definition or proof, begin by\n    reading carefully through the parts that are provided for you,\n    referring to the text in the [Stlc](Stlc.html) chapter for high-level\n    intuitions and the embedded comments for detailed mechanics.\n\n```", "```\n\n### Syntax\n\n```", "```\n\n    Note that, for brevity, we've omitted booleans and instead\n    provided a single if[0] form combining a zero test and a\n    conditional.  That is, instead of writing\n\n```", "```\n\n    we'll write this:\n\n```", "```\n\n```", "```\nFixpoint subst (x:id) (s:tm) (t:tm) : tm :=\n\u00a0\u00a0match t with\n\u00a0\u00a0| tvar y \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if beq_id x y then s else t\n\u00a0\u00a0| tabs y T t[1] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tabs y T (if beq_id x y then t[1] else (subst x s t[1]))\n\u00a0\u00a0| tapp t[1] t[2] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tapp (subst x s t[1]) (subst x s t[2])\n\u00a0\u00a0| tnat n \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tnat n\n\u00a0\u00a0| tsucc t[1] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tsucc (subst x s t[1])\n\u00a0\u00a0| tpred t[1] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tpred (subst x s t[1])\n\u00a0\u00a0| tmult t[1] t[2] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmult (subst x s t[1]) (subst x s t[2])\n\u00a0\u00a0| tif0 t[1] t[2] t[3] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tif0 (subst x s t[1]) (subst x s t[2]) (subst x s t[3])\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\u00a0\u00a0| tunit \u21d2 tunit\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\u00a0\u00a0| tinl T t[1] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tinl T (subst x s t[1])\n\u00a0\u00a0| tinr T t[1] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tinr T (subst x s t[1])\n\u00a0\u00a0| tcase t[0] y[1] t[1] y[2] t[2] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tcase (subst x s t[0])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0y[1] (if beq_id x y[1] then t[1] else (subst x s t[1]))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0y[2] (if beq_id x y[2] then t[2] else (subst x s t[2]))\n\u00a0\u00a0| tnil T \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tnil T\n\u00a0\u00a0| tcons t[1] t[2] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tcons (subst x s t[1]) (subst x s t[2])\n\u00a0\u00a0| tlcase t[1] t[2] y[1] y[2] t[3] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tlcase (subst x s t[1]) (subst x s t[2]) y[1] y[2]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(if beq_id x y[1] then\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[3]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else if beq_id x y[2] then t[3]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else (subst x s t[3]))\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\u00a0\u00a0| _ \u21d2 t  (*\u00a0...\u00a0and\u00a0delete\u00a0this\u00a0line\u00a0*)\n\u00a0\u00a0end.\n\nNotation \"'[' x ':=' s ']' t\" := (subst x s t) (at level 20).\n\n```", "```\nInductive value : tm \u2192 Prop :=\n\u00a0\u00a0| v_abs : \u2200x T[11] t[12],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value (tabs x T[11] t[12])\n\u00a0\u00a0(*\u00a0Numbers\u00a0are\u00a0values:\u00a0*)\n\u00a0\u00a0| v_nat : \u2200n[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value (tnat n[1])\n\u00a0\u00a0(*\u00a0A\u00a0pair\u00a0is\u00a0a\u00a0value\u00a0if\u00a0both\u00a0components\u00a0are:\u00a0*)\n\u00a0\u00a0| v_pair : \u2200v[1] v[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value (tpair v[1] v[2])\n\u00a0\u00a0(*\u00a0A\u00a0unit\u00a0is\u00a0always\u00a0a\u00a0value\u00a0*)\n\u00a0\u00a0| v_unit : value tunit\n\u00a0\u00a0(*\u00a0A\u00a0tagged\u00a0value\u00a0is\u00a0a\u00a0value:\u00a0\u00a0*)\n\u00a0\u00a0| v_inl : \u2200v T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value (tinl T v)\n\u00a0\u00a0| v_inr : \u2200v T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value (tinr T v)\n\u00a0\u00a0(*\u00a0A\u00a0list\u00a0is\u00a0a\u00a0value\u00a0iff\u00a0its\u00a0head\u00a0and\u00a0tail\u00a0are\u00a0values:\u00a0*)\n\u00a0\u00a0| v_lnil : \u2200T, value (tnil T)\n\u00a0\u00a0| v_lcons : \u2200v[1] vl,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value vl \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value (tcons v[1] vl)\n\u00a0\u00a0.\n\nHint Constructors value.\n\nReserved Notation \"t1 '\u21d2' t2\" (at level 40).\n\nInductive step : tm \u2192 tm \u2192 Prop :=\n\u00a0\u00a0| ST_AppAbs : \u2200x T[11] t[12] v[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tapp (tabs x T[11] t[12]) v[2]) \u21d2 [x:=v[2]]t[12]\n\u00a0\u00a0| ST_App1 : \u2200t[1] t[1]' t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tapp t[1] t[2]) \u21d2 (tapp t[1]' t[2])\n\u00a0\u00a0| ST_App2 : \u2200v[1] t[2] t[2]',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[2] \u21d2 t[2]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tapp v[1] t[2]) \u21d2 (tapp v[1] t[2]')\n\u00a0\u00a0(*\u00a0nats\u00a0*)\n\u00a0\u00a0| ST_Succ1 : \u2200t[1] t[1]',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tsucc t[1]) \u21d2 (tsucc t[1]')\n\u00a0\u00a0| ST_SuccNat : \u2200n[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tsucc (tnat n[1])) \u21d2 (tnat (S n[1]))\n\u00a0\u00a0| ST_Pred : \u2200t[1] t[1]',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tpred t[1]) \u21d2 (tpred t[1]')\n\u00a0\u00a0| ST_PredNat : \u2200n[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tpred (tnat n[1])) \u21d2 (tnat (pred n[1]))\n\u00a0\u00a0| ST_Mult1 : \u2200t[1] t[1]' t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tmult t[1] t[2]) \u21d2 (tmult t[1]' t[2])\n\u00a0\u00a0| ST_Mult2 : \u2200v[1] t[2] t[2]',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[2] \u21d2 t[2]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tmult v[1] t[2]) \u21d2 (tmult v[1] t[2]')\n\u00a0\u00a0| ST_MultNats : \u2200n[1] n[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tmult (tnat n[1]) (tnat n[2])) \u21d2 (tnat (mult n[1] n[2]))\n\u00a0\u00a0| ST_If[01] : \u2200t[1] t[1]' t[2] t[3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tif0 t[1] t[2] t[3]) \u21d2 (tif0 t[1]' t[2] t[3])\n\u00a0\u00a0| ST_If0Zero : \u2200t[2] t[3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tif0 (tnat 0) t[2] t[3]) \u21d2 t[2]\n\u00a0\u00a0| ST_If0Nonzero : \u2200n t[2] t[3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tif0 (tnat (S n)) t[2] t[3]) \u21d2 t[3]\n\u00a0\u00a0(*\u00a0pairs\u00a0*)\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\u00a0\u00a0(*\u00a0let\u00a0*)\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\u00a0\u00a0(*\u00a0sums\u00a0*)\n\u00a0\u00a0| ST_Inl : \u2200t[1] t[1]' T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tinl T t[1]) \u21d2 (tinl T t[1]')\n\u00a0\u00a0| ST_Inr : \u2200t[1] t[1]' T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tinr T t[1]) \u21d2 (tinr T t[1]')\n\u00a0\u00a0| ST_Case : \u2200t[0] t[0]' x[1] t[1] x[2] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[0] \u21d2 t[0]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tcase t[0] x[1] t[1] x[2] t[2]) \u21d2 (tcase t[0]' x[1] t[1] x[2] t[2])\n\u00a0\u00a0| ST_CaseInl : \u2200v[0] x[1] t[1] x[2] t[2] T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[0] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tcase (tinl T v[0]) x[1] t[1] x[2] t[2]) \u21d2 [x[1]:=v[0]]t[1]\n\u00a0\u00a0| ST_CaseInr : \u2200v[0] x[1] t[1] x[2] t[2] T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[0] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tcase (tinr T v[0]) x[1] t[1] x[2] t[2]) \u21d2 [x[2]:=v[0]]t[2]\n\u00a0\u00a0(*\u00a0lists\u00a0*)\n\u00a0\u00a0| ST_Cons1 : \u2200t[1] t[1]' t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tcons t[1] t[2]) \u21d2 (tcons t[1]' t[2])\n\u00a0\u00a0| ST_Cons2 : \u2200v[1] t[2] t[2]',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[2] \u21d2 t[2]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tcons v[1] t[2]) \u21d2 (tcons v[1] t[2]')\n\u00a0\u00a0| ST_Lcase1 : \u2200t[1] t[1]' t[2] x[1] x[2] t[3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tlcase t[1] t[2] x[1] x[2] t[3]) \u21d2 (tlcase t[1]' t[2] x[1] x[2] t[3])\n\u00a0\u00a0| ST_LcaseNil : \u2200T t[2] x[1] x[2] t[3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tlcase (tnil T) t[2] x[1] x[2] t[3]) \u21d2 t[2]\n\u00a0\u00a0| ST_LcaseCons : \u2200v[1] vl t[2] x[1] x[2] t[3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[1]  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value vl  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tlcase (tcons v[1] vl) t[2] x[1] x[2] t[3]) \u21d2 (subst x[2] vl (subst x[1] v[1] t[3]))\n\u00a0\u00a0(*\u00a0fix\u00a0*)\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\nwhere \"t1 '\u21d2' t2\" := (step t[1] t[2]).\n\nNotation multistep := (multi step).\nNotation \"t1 '\u21d2*' t2\" := (multistep t[1] t[2]) (at level 40).\n\nHint Constructors step.\n\n```", "```\nDefinition context := partial_map ty.\n\n```", "```\nReserved Notation \"Gamma '\u22a2' t '\u2208' T\" (at level 40).\n\nInductive has_type : context \u2192 tm \u2192 ty \u2192 Prop :=\n\u00a0\u00a0(*\u00a0Typing\u00a0rules\u00a0for\u00a0proper\u00a0terms\u00a0*)\n\u00a0\u00a0| T_Var : \u2200\u0393 x T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 x = Some T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tvar x) \u2208 T\n\u00a0\u00a0| T_Abs : \u2200\u0393 x T[11] T[12] t[12],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(update \u0393 x T[11]) \u22a2 t[12] \u2208 T[12] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tabs x T[11] t[12]) \u2208 (TArrow T[11] T[12])\n\u00a0\u00a0| T_App : \u2200T[1] T[2] \u0393 t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[1] \u2208 (TArrow T[1] T[2]) \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[2] \u2208 T[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tapp t[1] t[2]) \u2208 T[2]\n\u00a0\u00a0(*\u00a0nats\u00a0*)\n\u00a0\u00a0| T_Nat : \u2200\u0393 n[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tnat n[1]) \u2208 TNat\n\u00a0\u00a0| T_Succ : \u2200\u0393 t[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[1] \u2208 TNat \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tsucc t[1]) \u2208 TNat\n\u00a0\u00a0| T_Pred : \u2200\u0393 t[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[1] \u2208 TNat \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tpred t[1]) \u2208 TNat\n\u00a0\u00a0| T_Mult : \u2200\u0393 t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[1] \u2208 TNat \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[2] \u2208 TNat \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tmult t[1] t[2]) \u2208 TNat\n\u00a0\u00a0| T_If[0] : \u2200\u0393 t[1] t[2] t[3] T[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[1] \u2208 TNat \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[2] \u2208 T[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[3] \u2208 T[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tif0 t[1] t[2] t[3]) \u2208 T[1]\n\u00a0\u00a0(*\u00a0pairs\u00a0*)\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\u00a0\u00a0(*\u00a0unit\u00a0*)\n\u00a0\u00a0| T_Unit : \u2200\u0393,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 tunit \u2208 TUnit\n\u00a0\u00a0(*\u00a0let\u00a0*)\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\u00a0\u00a0(*\u00a0sums\u00a0*)\n\u00a0\u00a0| T_Inl : \u2200\u0393 t[1] T[1] T[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[1] \u2208 T[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tinl T[2] t[1]) \u2208 (TSum T[1] T[2])\n\u00a0\u00a0| T_Inr : \u2200\u0393 t[2] T[1] T[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[2] \u2208 T[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tinr T[1] t[2]) \u2208 (TSum T[1] T[2])\n\u00a0\u00a0| T_Case : \u2200\u0393 t[0] x[1] T[1] t[1] x[2] T[2] t[2] T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[0] \u2208 (TSum T[1] T[2]) \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(update \u0393 x[1] T[1]) \u22a2 t[1] \u2208 T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(update \u0393 x[2] T[2]) \u22a2 t[2] \u2208 T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tcase t[0] x[1] t[1] x[2] t[2]) \u2208 T\n\u00a0\u00a0(*\u00a0lists\u00a0*)\n\u00a0\u00a0| T_Nil : \u2200\u0393 T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tnil T) \u2208 (TList T)\n\u00a0\u00a0| T_Cons : \u2200\u0393 t[1] t[2] T[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[1] \u2208 T[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[2] \u2208 (TList T[1]) \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tcons t[1] t[2]) \u2208 (TList T[1])\n\u00a0\u00a0| T_Lcase : \u2200\u0393 t[1] T[1] t[2] x[1] x[2] t[3] T[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[1] \u2208 (TList T[1]) \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[2] \u2208 T[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(update (update \u0393 x[2] (TList T[1])) x[1] T[1]) \u22a2 t[3] \u2208 T[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 (tlcase t[1] t[2] x[1] x[2] t[3]) \u2208 T[2]\n\u00a0\u00a0(*\u00a0fix\u00a0*)\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\nwhere \"Gamma '\u22a2' t '\u2208' T\" := (has_type \u0393 t T).\n\nHint Constructors has_type.\n\n```", "```\nModule Examples.\n\n```", "```\nNotation x := (Id \"x\").\nNotation y := (Id \"y\").\nNotation a := (Id \"a\").\nNotation f := (Id \"f\").\nNotation g := (Id \"g\").\nNotation l := (Id \"l\").\nNotation k := (Id \"k\").\nNotation i[1] := (Id \"i1\").\nNotation i[2] := (Id \"i2\").\nNotation processSum := (Id \"processSum\").\nNotation n := (Id \"n\").\nNotation eq := (Id \"eq\").\nNotation m := (Id \"m\").\nNotation evenodd := (Id \"evenodd\").\nNotation even := (Id \"even\").\nNotation odd := (Id \"odd\").\nNotation eo := (Id \"eo\").\n\n```", "```\nHint Extern 2 (has_type _ (tapp _ _) _) \u21d2\n\u00a0\u00a0eapply T_App; auto.\nHint Extern 2 (has_type _ (tlcase _ _ _ _ _) _) \u21d2\n\u00a0\u00a0eapply T_Lcase; auto.\nHint Extern 2 (_ = _) \u21d2 compute; reflexivity.\n\n```", "```\nModule Numtest.\n\n(*\u00a0if[0]\u00a0(pred\u00a0(succ\u00a0(pred\u00a0(2\u00a0*\u00a00)))\u00a0then\u00a05\u00a0else\u00a06\u00a0*)\nDefinition test :=\n\u00a0\u00a0tif0\n\u00a0\u00a0\u00a0\u00a0(tpred\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tsucc\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tpred\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tmult\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tnat 2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tnat 0)))))\n\u00a0\u00a0\u00a0\u00a0(tnat 5)\n\u00a0\u00a0\u00a0\u00a0(tnat 6).\n\n```", "```\n(*\u00a0 Example\u00a0typechecks\u00a0: \u00a0\u00a0empty\u00a0|-\u00a0test\u00a0\u2208\u00a0TNat. Proof. \u00a0\u00a0unfold\u00a0test. \u00a0\u00a0(*\u00a0This\u00a0typing\u00a0derivation\u00a0is\u00a0quite\u00a0deep,\u00a0so\u00a0we\u00a0need\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0to\u00a0increase\u00a0the\u00a0max\u00a0search\u00a0depth\u00a0of\u00a0auto\u00a0from\u00a0the\u00a0 \u00a0\u00a0\u00a0\u00a0\u00a0default\u00a05\u00a0to\u00a010.\u00a0*) \u00a0\u00a0auto\u00a010\\. Qed. Example\u00a0numtest_reduces\u00a0: \u00a0\u00a0test\u00a0==>*\u00a0tnat\u00a05\\. Proof. \u00a0\u00a0unfold\u00a0test.\u00a0normalize. Qed. *)\n\nEnd Numtest.\n\n```", "```\nModule Prodtest.\n\n(*\u00a0((5,6),7).fst.snd\u00a0*)\nDefinition test :=\n\u00a0\u00a0tsnd\n\u00a0\u00a0\u00a0\u00a0(tfst\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tpair\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tpair\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tnat 5)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tnat 6))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tnat 7))).\n\n(*\u00a0 Example\u00a0typechecks\u00a0: \u00a0\u00a0empty\u00a0|-\u00a0test\u00a0\u2208\u00a0TNat. Proof.\u00a0unfold\u00a0test.\u00a0eauto\u00a015.\u00a0Qed. Example\u00a0reduces\u00a0: \u00a0\u00a0test\u00a0==>*\u00a0tnat\u00a06\\. Proof.\u00a0unfold\u00a0test.\u00a0normalize.\u00a0Qed. *)\n\nEnd Prodtest.\n\n```", "```\nModule LetTest.\n\n(*\u00a0let\u00a0x\u00a0=\u00a0pred\u00a06\u00a0in\u00a0succ\u00a0x\u00a0*)\nDefinition test :=\n\u00a0\u00a0tlet\n\u00a0\u00a0\u00a0\u00a0x\n\u00a0\u00a0\u00a0\u00a0(tpred (tnat 6))\n\u00a0\u00a0\u00a0\u00a0(tsucc (tvar x)).\n\n(*\u00a0 Example\u00a0typechecks\u00a0: \u00a0\u00a0empty\u00a0|-\u00a0test\u00a0\u2208\u00a0TNat. Proof.\u00a0unfold\u00a0test.\u00a0eauto\u00a015.\u00a0Qed. Example\u00a0reduces\u00a0: \u00a0\u00a0test\u00a0==>*\u00a0tnat\u00a06\\. Proof.\u00a0unfold\u00a0test.\u00a0normalize.\u00a0Qed. *)\n\nEnd LetTest.\n\n```", "```\nModule Sumtest1.\n\n(*\u00a0case\u00a0(inl\u00a0Nat\u00a05)\u00a0of \u00a0\u00a0\u00a0\u00a0\u00a0inl\u00a0x\u00a0=>\u00a0x \u00a0\u00a0\u00a0|\u00a0inr\u00a0y\u00a0=>\u00a0y\u00a0*)\n\nDefinition test :=\n\u00a0\u00a0tcase (tinl TNat (tnat 5))\n\u00a0\u00a0\u00a0\u00a0x (tvar x)\n\u00a0\u00a0\u00a0\u00a0y (tvar y).\n\n(*\u00a0 Example\u00a0typechecks\u00a0: \u00a0\u00a0empty\u00a0|-\u00a0test\u00a0\u2208\u00a0TNat. Proof.\u00a0unfold\u00a0test.\u00a0eauto\u00a015.\u00a0Qed. Example\u00a0reduces\u00a0: \u00a0\u00a0test\u00a0==>*\u00a0(tnat\u00a05). Proof.\u00a0unfold\u00a0test.\u00a0normalize.\u00a0Qed. *)\n\nEnd Sumtest1.\n\nModule Sumtest2.\n\n(*\u00a0let\u00a0processSum\u00a0= \u00a0\u00a0\u00a0\u00a0\u00a0\\x:Nat+Nat. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case\u00a0x\u00a0of \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inl\u00a0n\u00a0=>\u00a0n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inr\u00a0n\u00a0=>\u00a0if[0]\u00a0n\u00a0then\u00a01\u00a0else\u00a00\u00a0in \u00a0\u00a0\u00a0(processSum\u00a0(inl\u00a0Nat\u00a05),\u00a0processSum\u00a0(inr\u00a0Nat\u00a05))\u00a0\u00a0\u00a0\u00a0*)\n\nDefinition test :=\n\u00a0\u00a0tlet\n\u00a0\u00a0\u00a0\u00a0processSum\n\u00a0\u00a0\u00a0\u00a0(tabs x (TSum TNat TNat)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tcase (tvar x)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0n (tvar n)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0n (tif0 (tvar n) (tnat 1) (tnat 0))))\n\u00a0\u00a0\u00a0\u00a0(tpair\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tapp (tvar processSum) (tinl TNat (tnat 5)))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tapp (tvar processSum) (tinr TNat (tnat 5)))).\n\n(*\u00a0 Example\u00a0typechecks\u00a0: \u00a0\u00a0empty\u00a0|-\u00a0test\u00a0\u2208\u00a0(TProd\u00a0TNat\u00a0TNat). Proof.\u00a0unfold\u00a0test.\u00a0eauto\u00a015.\u00a0Qed. Example\u00a0reduces\u00a0: \u00a0\u00a0test\u00a0==>*\u00a0(tpair\u00a0(tnat\u00a05)\u00a0(tnat\u00a00)). Proof.\u00a0unfold\u00a0test.\u00a0normalize.\u00a0Qed. *)\n\nEnd Sumtest2.\n\n```", "```\nModule ListTest.\n\n(*\u00a0let\u00a0l\u00a0=\u00a0cons\u00a05\u00a0(cons\u00a06\u00a0(nil\u00a0Nat))\u00a0in \u00a0\u00a0\u00a0lcase\u00a0l\u00a0of \u00a0\u00a0\u00a0\u00a0\u00a0nil\u00a0=>\u00a00 \u00a0\u00a0\u00a0|\u00a0x::y\u00a0=>\u00a0x*x\u00a0*)\n\nDefinition test :=\n\u00a0\u00a0tlet l\n\u00a0\u00a0\u00a0\u00a0(tcons (tnat 5) (tcons (tnat 6) (tnil TNat)))\n\u00a0\u00a0\u00a0\u00a0(tlcase (tvar l)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tnat 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0x y (tmult (tvar x) (tvar x))).\n\n(*\u00a0 Example\u00a0typechecks\u00a0: \u00a0\u00a0empty\u00a0|-\u00a0test\u00a0\u2208\u00a0TNat. Proof.\u00a0unfold\u00a0test.\u00a0eauto\u00a020.\u00a0Qed. Example\u00a0reduces\u00a0: \u00a0\u00a0test\u00a0==>*\u00a0(tnat\u00a025). Proof.\u00a0unfold\u00a0test.\u00a0normalize.\u00a0Qed. *)\n\nEnd ListTest.\n\n```", "```\nModule FixTest1.\n\n(*\u00a0fact\u00a0:=\u00a0fix \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u03bbf:nat->nat. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\\a:nat. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0a=0\u00a0then\u00a01\u00a0else\u00a0a\u00a0*\u00a0(f\u00a0(pred\u00a0a)))\u00a0*)\nDefinition fact :=\n\u00a0\u00a0tfix\n\u00a0\u00a0\u00a0\u00a0(tabs f (TArrow TNat TNat)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tabs a TNat\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tif0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tvar a)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tnat 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tmult\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tvar a)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tapp (tvar f) (tpred (tvar a))))))).\n\n```", "```\n(*\u00a0 Example\u00a0fact_typechecks\u00a0: \u00a0\u00a0empty\u00a0|-\u00a0fact\u00a0\u2208\u00a0(TArrow\u00a0TNat\u00a0TNat). Proof.\u00a0unfold\u00a0fact.\u00a0auto\u00a010\\. Qed. *)\n\n(*\u00a0 Example\u00a0fact_example: \u00a0\u00a0(tapp\u00a0fact\u00a0(tnat\u00a04))\u00a0==>*\u00a0(tnat\u00a024). Proof.\u00a0unfold\u00a0fact.\u00a0normalize.\u00a0Qed. *)\n\nEnd FixTest1.\n\nModule FixTest2.\n\n(*\u00a0map\u00a0:= \u00a0\u00a0\u00a0\u00a0\u00a0\\g:nat->nat. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fix \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u03bbf:nat->nat. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\\l:nat. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case\u00a0l\u00a0of \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0->\u00a0 |\u00a0x::l\u00a0->\u00a0(g\u00a0x)::(f\u00a0l))\u00a0*)\nDefinition map :=\n\u00a0\u00a0[tabs](MoreStlc.html#STLCExtended.Examples.FixTest2.tabs) [g](MoreStlc.html#STLCExtended.Examples.FixTest2.g) ([TArrow](MoreStlc.html#STLCExtended.Examples.FixTest2.TArrow) [TNat](MoreStlc.html#STLCExtended.Examples.FixTest2.TNat) [TNat](MoreStlc.html#STLCExtended.Examples.FixTest2.TNat))\n\u00a0\u00a0\u00a0\u00a0([tfix](MoreStlc.html#STLCExtended.Examples.FixTest2.tfix)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tabs](MoreStlc.html#STLCExtended.Examples.FixTest2.tabs) [f](MoreStlc.html#STLCExtended.Examples.FixTest2.f) ([TArrow](MoreStlc.html#STLCExtended.Examples.FixTest2.TArrow) ([TList](MoreStlc.html#STLCExtended.Examples.FixTest2.TList) [TNat](MoreStlc.html#STLCExtended.Examples.FixTest2.TNat)) ([TList](MoreStlc.html#STLCExtended.Examples.FixTest2.TList) [TNat](MoreStlc.html#STLCExtended.Examples.FixTest2.TNat)))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tabs](MoreStlc.html#STLCExtended.Examples.FixTest2.tabs) [l](MoreStlc.html#STLCExtended.Examples.FixTest2.l) ([TList](MoreStlc.html#STLCExtended.Examples.FixTest2.TList) [TNat](MoreStlc.html#STLCExtended.Examples.FixTest2.TNat))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tlcase](MoreStlc.html#STLCExtended.Examples.FixTest2.tlcase) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest2.tvar) [l](MoreStlc.html#STLCExtended.Examples.FixTest2.l))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tnil](MoreStlc.html#STLCExtended.Examples.FixTest2.tnil) [TNat](MoreStlc.html#STLCExtended.Examples.FixTest2.TNat))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[a](MoreStlc.html#STLCExtended.Examples.FixTest2.a) [l](MoreStlc.html#STLCExtended.Examples.FixTest2.l) ([tcons](MoreStlc.html#STLCExtended.Examples.FixTest2.tcons) ([tapp](MoreStlc.html#STLCExtended.Examples.FixTest2.tapp) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest2.tvar) [g](MoreStlc.html#STLCExtended.Examples.FixTest2.g)) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest2.tvar) [a](MoreStlc.html#STLCExtended.Examples.FixTest2.a)))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tapp](MoreStlc.html#STLCExtended.Examples.FixTest2.tapp) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest2.tvar) [f](MoreStlc.html#STLCExtended.Examples.FixTest2.f)) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest2.tvar) [l](MoreStlc.html#STLCExtended.Examples.FixTest2.l)))))))).\n\n(*\u00a0 (*\u00a0Make\u00a0sure\u00a0you've\u00a0uncommented\u00a0the\u00a0last\u00a0Hint Extern\u00a0above...\u00a0*) Example\u00a0map_typechecks\u00a0: \u00a0\u00a0empty\u00a0|-\u00a0map\u00a0\u2208 \u00a0\u00a0\u00a0\u00a0(TArrow\u00a0(TArrow\u00a0TNat\u00a0TNat) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(TArrow\u00a0(TList\u00a0TNat) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(TList\u00a0TNat))). Proof.\u00a0unfold\u00a0map.\u00a0auto\u00a010.\u00a0Qed. Example\u00a0map_example\u00a0: \u00a0\u00a0tapp\u00a0(tapp\u00a0map\u00a0(tabs\u00a0a\u00a0TNat\u00a0(tsucc\u00a0(tvar\u00a0a)))) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tcons\u00a0(tnat\u00a01)\u00a0(tcons\u00a0(tnat\u00a02)\u00a0(tnil\u00a0TNat))) \u00a0\u00a0==>*\u00a0(tcons\u00a0(tnat\u00a02)\u00a0(tcons\u00a0(tnat\u00a03)\u00a0(tnil\u00a0TNat))). Proof.\u00a0unfold\u00a0map.\u00a0normalize.\u00a0Qed. *)\n\nEnd [FixTest2](MoreStlc.html#STLCExtended.Examples.FixTest2).\n\nModule FixTest3.\n\n(*\u00a0equal\u00a0= \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fix \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u03bbeq:Nat->Nat->Bool. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\\m:Nat.\u00a0\\n:Nat. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if[0]\u00a0m\u00a0then\u00a0(if[0]\u00a0n\u00a0then\u00a01\u00a0else\u00a00) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\u00a0if[0]\u00a0n\u00a0then\u00a00 \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else\u00a0eq\u00a0(pred\u00a0m)\u00a0(pred\u00a0n))\u00a0\u00a0\u00a0*)\n\nDefinition equal :=\n\u00a0\u00a0[tfix](MoreStlc.html#STLCExtended.Examples.FixTest3.tfix)\n\u00a0\u00a0\u00a0\u00a0([tabs](MoreStlc.html#STLCExtended.Examples.FixTest3.tabs) [eq](MoreStlc.html#STLCExtended.Examples.FixTest3.eq) ([TArrow](MoreStlc.html#STLCExtended.Examples.FixTest3.TArrow) [TNat](MoreStlc.html#STLCExtended.Examples.FixTest3.TNat) ([TArrow](MoreStlc.html#STLCExtended.Examples.FixTest3.TArrow) [TNat](MoreStlc.html#STLCExtended.Examples.FixTest3.TNat) [TNat](MoreStlc.html#STLCExtended.Examples.FixTest3.TNat)))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tabs](MoreStlc.html#STLCExtended.Examples.FixTest3.tabs) [m](MoreStlc.html#STLCExtended.Examples.FixTest3.m) [TNat](MoreStlc.html#STLCExtended.Examples.FixTest3.TNat)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tabs](MoreStlc.html#STLCExtended.Examples.FixTest3.tabs) [n](MoreStlc.html#STLCExtended.Examples.FixTest3.n) [TNat](MoreStlc.html#STLCExtended.Examples.FixTest3.TNat)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tif0](MoreStlc.html#STLCExtended.Examples.FixTest3.tif0) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest3.tvar) [m](MoreStlc.html#STLCExtended.Examples.FixTest3.m))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tif0](MoreStlc.html#STLCExtended.Examples.FixTest3.tif0) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest3.tvar) [n](MoreStlc.html#STLCExtended.Examples.FixTest3.n)) ([tnat](MoreStlc.html#STLCExtended.Examples.FixTest3.tnat) 1) ([tnat](MoreStlc.html#STLCExtended.Examples.FixTest3.tnat) 0))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tif0](MoreStlc.html#STLCExtended.Examples.FixTest3.tif0) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest3.tvar) [n](MoreStlc.html#STLCExtended.Examples.FixTest3.n))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tnat](MoreStlc.html#STLCExtended.Examples.FixTest3.tnat) 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tapp](MoreStlc.html#STLCExtended.Examples.FixTest3.tapp) ([tapp](MoreStlc.html#STLCExtended.Examples.FixTest3.tapp) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest3.tvar) [eq](MoreStlc.html#STLCExtended.Examples.FixTest3.eq))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tpred](MoreStlc.html#STLCExtended.Examples.FixTest3.tpred) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest3.tvar) [m](MoreStlc.html#STLCExtended.Examples.FixTest3.m))))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tpred](MoreStlc.html#STLCExtended.Examples.FixTest3.tpred) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest3.tvar) [n](MoreStlc.html#STLCExtended.Examples.FixTest3.n))))))))).\n\n(*\u00a0 Example\u00a0equal_typechecks\u00a0: \u00a0\u00a0empty\u00a0|-\u00a0equal\u00a0\u2208\u00a0(TArrow\u00a0TNat\u00a0(TArrow\u00a0TNat\u00a0TNat)). Proof.\u00a0unfold\u00a0equal.\u00a0auto\u00a010\\. Qed. *)\n\n(*\u00a0 Example\u00a0equal_example1: \u00a0\u00a0(tapp\u00a0(tapp\u00a0equal\u00a0(tnat\u00a04))\u00a0(tnat\u00a04))\u00a0==>*\u00a0(tnat\u00a01). Proof.\u00a0unfold\u00a0equal.\u00a0normalize.\u00a0Qed. *)\n\n(*\u00a0 Example\u00a0equal_example2: \u00a0\u00a0(tapp\u00a0(tapp\u00a0equal\u00a0(tnat\u00a04))\u00a0(tnat\u00a05))\u00a0==>*\u00a0(tnat\u00a00). Proof.\u00a0unfold\u00a0equal.\u00a0normalize.\u00a0Qed. *)\n\nEnd [FixTest3](MoreStlc.html#STLCExtended.Examples.FixTest3).\n\nModule FixTest4.\n\n(*\u00a0let\u00a0evenodd\u00a0= \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fix \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u03bbeo:\u00a0(Nat->Nat\u00a0*\u00a0Nat->Nat). \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0let\u00a0e\u00a0=\u00a0\\n:Nat.\u00a0if[0]\u00a0n\u00a0then\u00a01\u00a0else\u00a0eo.snd\u00a0(pred\u00a0n)\u00a0in \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0let\u00a0o\u00a0=\u00a0\\n:Nat.\u00a0if[0]\u00a0n\u00a0then\u00a00\u00a0else\u00a0eo.fst\u00a0(pred\u00a0n)\u00a0in \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(e,o))\u00a0in \u00a0\u00a0\u00a0\u00a0let\u00a0even\u00a0=\u00a0evenodd.fst\u00a0in \u00a0\u00a0\u00a0\u00a0let\u00a0odd\u00a0\u00a0=\u00a0evenodd.snd\u00a0in \u00a0\u00a0\u00a0\u00a0(even\u00a03,\u00a0even\u00a04) *)\n\nDefinition eotest :=\n\u00a0\u00a0[tlet](MoreStlc.html#STLCExtended.Examples.FixTest4.tlet) [evenodd](MoreStlc.html#STLCExtended.Examples.FixTest4.evenodd)\n\u00a0\u00a0\u00a0\u00a0([tfix](MoreStlc.html#STLCExtended.Examples.FixTest4.tfix)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tabs](MoreStlc.html#STLCExtended.Examples.FixTest4.tabs) [eo](MoreStlc.html#STLCExtended.Examples.FixTest4.eo) ([TProd](MoreStlc.html#STLCExtended.Examples.FixTest4.TProd) ([TArrow](MoreStlc.html#STLCExtended.Examples.FixTest4.TArrow) [TNat](MoreStlc.html#STLCExtended.Examples.FixTest4.TNat) [TNat](MoreStlc.html#STLCExtended.Examples.FixTest4.TNat)) ([TArrow](MoreStlc.html#STLCExtended.Examples.FixTest4.TArrow) [TNat](MoreStlc.html#STLCExtended.Examples.FixTest4.TNat) [TNat](MoreStlc.html#STLCExtended.Examples.FixTest4.TNat)))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tpair](MoreStlc.html#STLCExtended.Examples.FixTest4.tpair)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tabs](MoreStlc.html#STLCExtended.Examples.FixTest4.tabs) [n](MoreStlc.html#STLCExtended.Examples.FixTest4.n) [TNat](MoreStlc.html#STLCExtended.Examples.FixTest4.TNat)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tif0](MoreStlc.html#STLCExtended.Examples.FixTest4.tif0) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest4.tvar) [n](MoreStlc.html#STLCExtended.Examples.FixTest4.n))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tnat](MoreStlc.html#STLCExtended.Examples.FixTest4.tnat) 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tapp](MoreStlc.html#STLCExtended.Examples.FixTest4.tapp) ([tsnd](MoreStlc.html#STLCExtended.Examples.FixTest4.tsnd) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest4.tvar) [eo](MoreStlc.html#STLCExtended.Examples.FixTest4.eo))) ([tpred](MoreStlc.html#STLCExtended.Examples.FixTest4.tpred) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest4.tvar) [n](MoreStlc.html#STLCExtended.Examples.FixTest4.n))))))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tabs](MoreStlc.html#STLCExtended.Examples.FixTest4.tabs) [n](MoreStlc.html#STLCExtended.Examples.FixTest4.n) [TNat](MoreStlc.html#STLCExtended.Examples.FixTest4.TNat)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tif0](MoreStlc.html#STLCExtended.Examples.FixTest4.tif0) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest4.tvar) [n](MoreStlc.html#STLCExtended.Examples.FixTest4.n))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tnat](MoreStlc.html#STLCExtended.Examples.FixTest4.tnat) 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0([tapp](MoreStlc.html#STLCExtended.Examples.FixTest4.tapp) ([tfst](MoreStlc.html#STLCExtended.Examples.FixTest4.tfst) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest4.tvar) [eo](MoreStlc.html#STLCExtended.Examples.FixTest4.eo))) ([tpred](MoreStlc.html#STLCExtended.Examples.FixTest4.tpred) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest4.tvar) [n](MoreStlc.html#STLCExtended.Examples.FixTest4.n)))))))))\n\u00a0\u00a0([tlet](MoreStlc.html#STLCExtended.Examples.FixTest4.tlet) [even](MoreStlc.html#STLCExtended.Examples.FixTest4.even) ([tfst](MoreStlc.html#STLCExtended.Examples.FixTest4.tfst) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest4.tvar) [evenodd](MoreStlc.html#STLCExtended.Examples.FixTest4.evenodd)))\n\u00a0\u00a0([tlet](MoreStlc.html#STLCExtended.Examples.FixTest4.tlet) [odd](MoreStlc.html#STLCExtended.Examples.FixTest4.odd) ([tsnd](MoreStlc.html#STLCExtended.Examples.FixTest4.tsnd) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest4.tvar) [evenodd](MoreStlc.html#STLCExtended.Examples.FixTest4.evenodd)))\n\u00a0\u00a0([tpair](MoreStlc.html#STLCExtended.Examples.FixTest4.tpair)\n\u00a0\u00a0\u00a0\u00a0([tapp](MoreStlc.html#STLCExtended.Examples.FixTest4.tapp) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest4.tvar) [even](MoreStlc.html#STLCExtended.Examples.FixTest4.even)) ([tnat](MoreStlc.html#STLCExtended.Examples.FixTest4.tnat) 3))\n\u00a0\u00a0\u00a0\u00a0([tapp](MoreStlc.html#STLCExtended.Examples.FixTest4.tapp) ([tvar](MoreStlc.html#STLCExtended.Examples.FixTest4.tvar) [even](MoreStlc.html#STLCExtended.Examples.FixTest4.even)) ([tnat](MoreStlc.html#STLCExtended.Examples.FixTest4.tnat) 4))))).\n\n(*\u00a0 Example\u00a0eotest_typechecks\u00a0: \u00a0\u00a0empty\u00a0|-\u00a0eotest\u00a0\u2208\u00a0(TProd\u00a0TNat\u00a0TNat). Proof.\u00a0unfold\u00a0eotest.\u00a0eauto\u00a030\\. Qed. *)\n\n(*\u00a0 Example\u00a0eotest_example1: \u00a0\u00a0eotest\u00a0==>*\u00a0(tpair\u00a0(tnat\u00a00)\u00a0(tnat\u00a01)). Proof.\u00a0unfold\u00a0eotest.\u00a0normalize.\u00a0Qed. *)\n\nEnd [FixTest4](MoreStlc.html#STLCExtended.Examples.FixTest4).\n\nEnd [Examples](MoreStlc.html#STLCExtended.Examples). \n```", "```\n\n### Progress\n\n```", "```\n\n### Context Invariance\n\n```", "```\n\n### Substitution\n\n```", "```\n\n### Preservation\n\n```", "```\n\n    \u2610\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]