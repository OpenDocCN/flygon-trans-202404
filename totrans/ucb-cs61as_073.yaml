- en: Tagged Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Tagged Data
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can create generic operators, we first have to be able to keep track
    of data types. Why?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Think back to Lesson 4 where we implemented rational numbers. We made the decision
    to store rational numbers as a pair, where the `car` held the numerator and the
    `cdr` held the denominator. Meanwhile, our frenemy, Ben Bitdiddle, implemented
    complex numbers. He represented these numbers as a pair as well: the `car` held
    the real part and the `cdr` held the imaginary part.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![](/static/tagged_data_1.gif) ![](/static/tagged_data_2.gif)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: Now, given a pair whose `car` is 3 and whose `cdr` is 4, how can we tell if
    the given data represents the rational number [mathjaxinline]\frac{3}{4}[/mathjaxinline]
    or the complex number [mathjaxinline]3+4i[/mathjaxinline]? The raw data we are
    given can be interpreted either way, so we can't know for sure! In fact, the pair
    may be neither of the two and actually represent some other data type. That's
    why need a system to associate data with their particular types.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '(Side note: At this point, you might be mad at Ben—why did he have to use the
    same representation as us?! However, he really isn''t to blame. Even if he used
    a different internal representation, we *cannot* use this distinction to check
    the type of the data: we would be breaking data abstraction barriers!)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to have **tagged data**: Each piece of data carries around
    information about its type. We can do this by attaching tags to all our data.
    To accomplish this, we need a constructor to tag our data (`attach-tag`) and selectors
    to grab the tag and the data from a piece of tagged data (`type-tag` and `contents`).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Here's a possible implementation for handling tagged data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Can you come up with another set of constructors and selectors that implements
    data tagging using a different internal representation?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Tagging Rational and Complex Numbers
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve implemented tagged data, we can fix our implementations of
    the rational and complex number data types. Our old code looked like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But now we can do this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that we easily could have replaced the function `attach-tag` with `cons`
    and the code would have still worked. But this violates the data abstraction barrier
    we created!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then write selectors using `contents`. For example, for rational numbers:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Writing Procedures for Tagged Data
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our goal is to write a universal addition procedure. It should work with rational
    numbers and complex numbers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to write addition procedures that are specific to the data
    types of the inputs. Using the constructors and selectors that we just wrote in
    the previous section, this should be fairly straight forward.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Write `add-rational`, which takes in two rational numbers and returns a rational
    number equal to the sum of the two inputs. Remember to respect the data abstraction
    by using proper constructors and selectors.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write `add-complex`, which takes in two complex numbers and returns a complex
    number equal to the sum of the two inputs. Remember that [mathjaxinline](a+bi)
    + (c+di) = (a+c)+(b+d)i[/mathjaxinline].
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assume that we've written a procedure `add-rational-complex` which takes in
    rational number and complex number in that order, and adds them properly.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now write a generic addition operation called `add-numbers` that takes in two
    numbers, each of which can be either rational or complex. We should rely on tags
    to direct our data to the correct procedure above.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check your answers below.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your `add-rational` should look something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Your `add-complex` should be similar. Notice that we didn't have to worry about
    tagging, thanks to the abstraction barrier created by `make-rational`, `numer`,
    and `denom`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for `add-numbers`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Great! We can now add numbers using a single generic procedure!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Reflection
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s think about what we''ve learned:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: We don't even need to know how tags are implemented to write this `add-numbers`!
    This is because we properly *abstracted away* those details. So we can just use
    the selector `type-tag` to tell us what type of data we're dealing with.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we want to add another type of number to our system, we'll have to change
    our generic function's definition, adding a good number of extra conditions to
    handle the new data type. The modifications would be straightforward in our situation,
    but this wouldn't work with larger systems. In other words, our system has poor
    *scalability*.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although the `add-numbers` example is a little contrived, there are many systems
    that do use tagged data in the real world. In fact, the Racket interpreter uses
    tagged data to evaluate your code!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Weaknesses of Tagged Data
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we hinted above, tagged data systems have several key weaknesses.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: One weakness is that every data type must be identified and manually incorporated
    into every generic procedure. For instance, suppose we wanted to incorporate a
    new type of number into our system. We would need to identify this new representation
    with a type, then edit all the generic procedures out there (`add-numbers, multiply-numbers,
    divide-numbers`, etc.) to check for the new type and carry out the appropriate
    operations.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Another weakness is that even though the individual representations and corresponding
    procedures can be designed separately, we must guarantee that no two procedures
    in the entire system have the same name. This is why we created the new procedure
    `add-numbers,` which calls `add- rational,` `add-complex`, and `add-rational-complex`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The issue underlying both of these weaknesses is that the technique for implementing
    generic interfaces does not scale—the person implementing the generic procedures
    must modify those procedures each time a new representation or type is added.
    Additionally, the people who originally wrote the rational number system and the
    complex number system must now modify their code to avoid name conflicts. In each
    of these cases, the changes that must be made to the code are straightforward,
    but they must be made nonetheless, and this is a source of inconvenience and error.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个弱点的根本问题是，实现通用接口的技术不具备可扩展性——实现通用程序的人必须每次添加新的表示或类型时修改这些程序。此外，最初编写有理数系统和复数系统的人现在必须修改他们的代码以避免名称冲突。在这些情况下，必须对代码进行的更改是直接的，但仍然必须进行，这是不便和错误的根源。
