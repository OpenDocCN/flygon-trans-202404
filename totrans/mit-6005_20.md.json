["```\npublic class Factorial {\n\n    /**\n     * Computes n! and prints it on standard output.\n     * @param n must be >= 0\n     */\n    private static void computeFact(final int n) {\n        BigInteger result = new BigInteger(\"1\");\n        for (int i = 1; i <= n; ++i) {\n            System.out.println(\"working on fact \" + n);\n            result = result.multiply(new BigInteger(String.valueOf(i)));\n        }\n        System.out.println(\"fact(\" + n + \") = \" + result);\n    }\n\n    public static void main(String[] args) {\n        new Thread(new Runnable() { // create a thread using an\n            public void run() {     // anonymous Runnable\n                computeFact(99);\n            }\n        }).start();\n        computeFact(100);\n    }\n}\n```", "```\n// This class has a race condition in it.\npublic class PinballSimulator {\n\n    private static PinballSimulator simulator = null;\n    // invariant: there should never be more than one PinballSimulator\n    //            object created\n\n    private PinballSimulator() {\n        System.out.println(\"created a PinballSimulator object\");\n    }\n\n    // factory method that returns the sole PinballSimulator object,\n    // creating it if it doesn't exist\n    public static PinballSimulator getInstance() {\n        if (simulator == null) {\n            simulator = new PinballSimulator();\n        }\n        return simulator;\n    }\n}\n```", "```\n// is this method threadsafe?\n/**\n * @param x integer to test for primeness; requires x > 1\n * @return true if x is prime with high probability\n */\npublic static boolean isPrime(int x) {\n    if (cache.containsKey(x)) return cache.get(x);\n    boolean answer = BigInteger.valueOf(x).isProbablePrime(100);\n    cache.put(x, answer);\n    return answer;\n}\n\nprivate static Map<Integer,Boolean> cache = new HashMap<>();\n```", "```\npublic static void main(String[] args) {\n    new Thread(new Runnable() { // create a thread using an\n        public void run() {     // anonymous Runnable\n            computeFact(99);\n        }\n    }).start();\n    computeFact(100);\n}\n```", "```\npublic class PinballSimulator {\n\n    private static PinballSimulator simulator = null;\n\n    // ...\n\n    public static PinballSimulator getInstance() {\n1)      if (simulator == null) {\n2)          simulator = new PinballSimulator();\n        }\n3)      return simulator;\n    }\n}\n```", "```\npublic class C {\n    public static void main(String[] args) {\n        new Thread(new Runnable() {\n            public void run() {\n                threadA();\n            }\n        }).start();\n\n        new Thread(new Runnable() {\n            public void run() {\n                threadB();\n            }\n        }).start();\n    }\n\n    private static String name = \"Napoleon Dynamite\";\n    private static int cashLeft = 150;\n\n    private static void threadA() {\n        int amountA = 20;\n        cashLeft = spend(amountA);\n    }\n\n    private static void threadB() {\n        int amountB = 30;\n        cashLeft = spend(amountB);\n    }\n\n    private static int spend(int amountToSpend) {\n        return cashLeft - amountToSpend;\n    }\n}\n```", "```\nprivate static Map<Integer,Boolean> cache =\n                Collections.synchronizedMap(new HashMap<>());\n```", "```\nfor (String s: lst) { ... } // not threadsafe, even if lst is a synchronized list wrapper\n```", "```\nif ( ! lst.isEmpty()) { String s = lst.get(0); ... }\n```", "```\nif (cache.containsKey(x)) return cache.get(x);\nboolean answer = BigInteger.valueOf(x).isProbablePrime(100);\ncache.put(x, answer);\n```", "```\npublic class Building {\n    private final String buildingName;\n    private int numberOfFloors;\n    private final int[] occupancyPerFloor;\n    private final List<String> companyNames = Collections.synchronizedList(new ArrayList<>());\n    ...\n}\n```", "```\n/** MyString is an immutable data type representing a string of characters. */\npublic class MyString {\n    private final char[] a;\n    // Thread safety argument:\n    //    This class is threadsafe because it's immutable:\n    //    - a is final\n    //    - a points to a mutable char array, but that array is encapsulated\n    //      in this object, not shared with any other object or exposed to a\n    //      client\n```", "```\n/** MyString is an immutable data type representing a string of characters. */\npublic class MyString {\n    private final char[] a;\n    private final int start;\n    private final int len;\n    // Rep invariant:\n    //    0 <= start <= a.length\n    //    0 <= len <= a.length-start\n    // Abstraction function:\n    //    represents the string of characters a[start],...,a[start+length-1]\n    // Thread safety argument:\n    //    This class is threadsafe because it's immutable:\n    //    - a, start, and len are final\n    //    - a points to a mutable char array, which may be shared with other\n    //      MyString objects, but they never mutate it\n    //    - the array is never exposed to a client\n```", "```\n/** MyStringBuffer is a threadsafe mutable string of characters. */\npublic class MyStringBuffer {\n    private String text;\n    // Rep invariant:\n    //   none\n    // Abstraction function:\n    //   represents the sequence text[0],...,text[text.length()-1]\n    // Thread safety argument:\n    //   text is an immutable (and hence threadsafe) String,\n    //   so this object is also threadsafe\n```", "```\npublic class Graph {\n    private final Set<Node> nodes =\n                   Collections.synchronizedSet(new HashSet<>());\n    private final Map<Node,Set<Node>> edges =\n                   Collections.synchronizedMap(new HashMap<>());\n    // Rep invariant:\n    //    for all x, y such that y is a member of edges.get(x),\n    //        x, y are both members of nodes\n    // Abstraction function:\n    //    represents a directed graph whose nodes are the set of nodes\n    //        and whose edges are the set (x,y) such that\n    //                         y is a member of edges.get(x)\n    // Thread safety argument:\n    //    - nodes and edges are final, so those variables are immutable\n    //      and threadsafe\n    //    - nodes and edges point to threadsafe set and map data types\n```", "```\npublic void addEdge(Node from, Node to) {\n    if ( ! edges.containsKey(from)) {\n        edges.put(from, Collections.synchronizedSet(new HashSet<>()));\n    }\n    edges.get(from).add(to);\n    nodes.add(from);\n    nodes.add(to);\n}\n```", "```\n/** MyStringBuffer is a threadsafe mutable string of characters. */\npublic class MyStringBuffer {\n    private String text;\n    // Rep invariant:\n    //   none\n    // Abstraction function:\n    //   represents the sequence text[0],...,text[text.length()-1]\n    // Thread safety argument:\n    //   text is an immutable (and hence threadsafe) String,\n    //   so this object is also threadsafe\n\n    /** @return the string represented by this buffer,\n     *          with all letters converted to uppercase */\n    public String toUpperCase() { return text.toUpperCase(); }\n\n    /** @param pos position to insert text into the buffer,\n     *             requires 0 <= pos <= length of the current string\n     *  @param s text to insert\n     *  Mutates this buffer to insert s as a substring at position pos. */\n    public void insert(int pos, String s) {\n        text = text.substring(0, pos) + s + text.substring(pos);\n    }\n\n    /** @return the string represented by this buffer */\n    public void toString() { return text; }\n\n    /** Resets this buffer to the empty string. */\n    public void clear() { text = \"\"; }\n\n    /** @return the first character of this buffer, or \"\" if this buffer is empty */\n    public String first() {\n        if (text.length() > 0) {\n            return String.valueOf(text.charAt(0));\n        } else {\n            return \"\";\n        }\n    }\n}\n```"]