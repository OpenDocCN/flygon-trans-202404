["```\n    undefined :: a error :: String -> a\n    ```", "```\n    import Prelude hiding (catch) -- not necessary with new GHCs import Control.Exception\n    ```", "```\n    class (Typeable e, Show e) => Exception e where ... throw :: Exception e => e -> a throwIO :: Exception e => e -> IO a catch :: Exception e => IO a -> (e -> IO a) -> IO a\n    ```", "```\n{-# LANGUAGE DeriveDataTypeable #-} import Prelude hiding (catch) import Control.Exception import Data.Typeable data MyError = MyError String deriving (Show, Typeable) instance Exception MyError catcher :: IO a -> IO (Maybe a) catcher action = fmap Just action `catch` handler where handler (MyError msg) = do putStrLn msg; return Nothing\n```", "```\n*Main> catcher $ readFile \"/dev/null\" Just \"\" *Main> catcher $ throwIO $ MyError \"something bad\" something bad Nothing\n```", "```\n     do x <- throwIO (MyError \"one\") -- this exception thrown y <- throwIO (MyError \"two\") -- this code not reached return $ x + y\n    ```", "```\n    -- Simplified version of functions in standard Prelude: error :: String -> a error a = throw (ErrorCall a) undefined :: a undefined = error \"Prelude.undefined\"\n    ```", "```\n    pureCatcher :: a -> IO (Maybe a) pureCatcher a = (a `seq` return (Just a)) `catch` \\(SomeException _) -> return Nothing\n    ```", "```\n    pureCatcher $ 1 + 1 Just 2 *Main> pureCatcher $ 1 `div` 0 Nothing *Main> pureCatcher (undefined :: String) Nothing\n    ```", "```\n    *Main> pureCatcher (undefined:undefined :: String)\n    ```", "```\n    pureCatcher :: a -> IO (Maybe a) pureCatcher a = (a `seq` return (Just a)) `catch` \\(SomeException _) -> return Nothing\n    ```", "```\n    pureCatcher $ 1 + 1 Just 2 *Main> pureCatcher $ 1 `div` 0 Nothing *Main> pureCatcher (undefined :: String) Nothing\n    ```", "```\n    *Main> pureCatcher (undefined:undefined :: String) Just \"*** Exception: Prelude.undefined\n    ```", "```\n    pureCatcher :: a -> IO (Maybe a) pureCatcher a = (a `seq` return (Just a)) `catch` \\(SomeException _) -> return Nothing\n    ```", "```\n    pureCatcher $ 1 + 1 Just 2 *Main> pureCatcher $ 1 `div` 0 Nothing *Main> pureCatcher (undefined :: String) Nothing\n    ```", "```\n    *Main> pureCatcher (undefined:undefined :: String) Just \"*** Exception: Prelude.undefined\n    ```", "```\n    *Main> seq (undefined:undefined) () ()\n    ```", "```\n    seqList :: [a] -> b -> b\n    ```", "```\n    *Main> seqList [1, 2, 3] () () *Main> seqList [1, 2, 3, undefined] () *** Exception: Prelude.undefined\n    ```", "```\nseqList :: [a] -> b -> b seqList [] b = b seqList (a:as) b = seq a $ seqList as b\n```", "```\n    try :: Exception e => IO a -> IO (Either e a)\n    ```", "```\n    finally :: IO a -> IO b -> IO a -- cleanup always onException :: IO a -> IO b -> IO a -- after exception\n    ```", "```\n    catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a readFileIfExists f = catchJust p (readFile f) (\\_ -> return \"\") where p e = if isDoesNotExistError e then Just e else Nothing\n    ```", "```\n    *Main> readFileIfExists \"/nosuchfile\" \"\" *Main> readFileIfExists \"/etc/shadow\" *** Exception: /etc/shadow: openFile: permission denied ...\n    ```", "```\n    instance Monad Maybe where (Just x) >>= k = k x Nothing >>= _ = Nothing return = Just fail _ = Nothing\n    ```", "```\n    *Main> (do 1 <- return 2; return 3) :: Maybe Int Nothing\n    ```", "```\n    forkIO :: IO () -> IO ThreadId -- creates a new thread\n    ```", "```\n    throwTo :: Exception e => ThreadId -> e -> IO () killThread :: ThreadId -> IO () -- = flip throwTo ThreadKilled threadDelay :: Int -> IO () -- sleeps for # of \u00b5sec myThreadId :: IO ThreadId\n    ```", "```\ndata TimedOut = TimedOut UTCTime deriving (Eq, Show, Typeable) instance Exception TimedOut timeout :: Int -> IO a -> IO (Maybe a) timeout usec action = do -- Create unique exception val (for nested timeouts): expired <- fmap TimedOut getCurrentTime ptid <- myThreadId let child = do threadDelay usec throwTo ptid expired parent = do ctid <- forkIO child result <- action killThread ctid return $ Just result catchJust (\\e -> if e == expired then Just e else Nothing) parent (\\_ -> return Nothing)\n```", "```\n    newEmptyMVar :: IO (MVar a) -- create empty MVar newMVar :: a -> IO (MVar a) -- create full MVar given val takeMVar :: MVar a -> IO a putMVar :: MVar a -> a -> IO ()\n    ```", "```\n    tryTakeMVar :: MVar a -> IO (Maybe a) -- Nothing if empty tryPutMVar :: MVar a -> a -> IO Bool -- False if full\n    ```", "```\nimport Control.Concurrent import Control.Exception import Control.Monad pingpong :: Bool -> Int -> IO () pingpong v n = do mvc <- newEmptyMVar -- MVar read by child mvp <- newEmptyMVar -- MVar read by parent let parent n | n > 0 = do when v $ putStr $ \" \" ++ show n putMVar mvc n takeMVar mvp >>= parent | otherwise = return () child = do n <- takeMVar mvc putMVar mvp (n - 1) child tid <- forkIO child parent n `finally` killThread tid when v $ putStrLn \"\"\n```", "```\n*Main> pingpong True 10 10 9 8 7 6 5 4 3 2 1\n```", "```\nimport Criterion.Main ... main :: IO () main = defaultMain [ bench \"thread switch test\" mybench ] where mybench = pingpong False 10000\n```", "```\n$ ghc -O pingpong.hs [1 of 1] Compiling Main ( pingpong.hs, pingpong.o ) Linking pingpong ... $ ./pingpong ... benchmarking thread switch test mean: 3.774590 ms, lb 3.739223 ms, ub 3.808865 ms, ci 0.950 ...\n```", "```\n    forkOS :: IO () -> IO ThreadId\n    ```", "```\n$ rm pingpong $ ghc -threaded -O pingpong.hs Linking pingpong ... $ ./pingpong ... mean: 121.1729 ms, lb 120.5601 ms, ub 121.7044 ms, ci 0.950 ...\n```", "```\n    wrap :: IO a -> IO a wrap action = do mv <- newEmptyMVar _ <- forkIO $ (action >>= putMVar mv) `catch` \\e@(SomeException _) -> putMVar mv (throw e) takeMVar mv\n    ```", "```\n    modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()\n    ```", "```\n    modifyMVar :: MVar a -> (a -> IO (a,b)) -> IO b modifyMVar m action = do v0 <- takeMVar m (v, r) <- action v0 `onException` putMVar m v0 putMVar m v return r\n    ```", "```\n    modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()\n    ```", "```\n    modifyMVar :: MVar a -> (a -> IO (a,b)) -> IO b modifyMVar m action = do v0 <- takeMVar m -- -------------- oops, race condition (v, r) <- action v0 `onException` putMVar m v0 putMVar m v return r\n    ```", "```\n    mask :: ((forall a. IO a -> IO a) -> IO b) -> IO b\n    ```", "```\n    modifyMVar :: MVar a -> (a -> IO (a,b)) -> IO b modifyMVar m action = mask $ \\unmask -> do v0 <- takeMVar m -- automatically unmasked while waiting (v, r) <- unmask (action v0) `onException` putMVar m v0 putMVar m v return r\n    ```", "```\nwrap :: IO a -> IO a -- Fixed version of wrap wrap action = do mv <- newEmptyMVar mask $ \\unmask -> do tid <- forkIO $ (unmask action >>= putMVar mv) `catch` \\e@(SomeException _) -> putMVar mv (throw e) let loop = takeMVar mv `catch` \\e@(SomeException _) -> throwTo tid e >> loop loop\n```", "```\n    bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c\n    ```", "```\n    bracket (openFile \"/etc/mtab\" ReadMode) -- first hClose -- last (\\h -> hGetContents h >>= doit) -- main\n    ```", "```\n     parent = do ctid <- forkIO child -- old code, result <- action -- bad if async killThread ctid -- exception return $ Just result\n    ```", "```\n     parent = bracket (forkIO child) killThread $ -- new code \\_ -> fmap Just action\n    ```", "```\n    -- type introduces type alias (like typedef in C) type Mutex = MVar () mutex_create :: IO Mutex mutex_create = newMVar () mutex_lock, mutex_unlock :: Mutex -> IO () mutex_lock = takeMVar mutex_unlock mv = putMVar mv () mutex_synchronize :: Mutex -> IO a -> IO a mutex_synchronize mv action = bracket (mutex_lock mv) (\\_ -> mutex_unlock mv) (\\_ -> action)\n    ```", "```\n    type Mutex = MVar ThreadId mutex_create :: IO Mutex mutex_create = newEmptyMVar mutex_lock, mutex_unlock :: Mutex -> IO () mutex_lock mv = myThreadId >>= putMVar mv mutex_unlock mv = do mytid <- myThreadId lockTid <- tryTakeMVar mv unless (lockTid == Just mytid) $ error \"mutex_unlock\"\n    ```", "```\ndata Cond = Cond (MVar [MVar ()]) cond_create :: IO Cond cond_create = liftM Cond $ newMVar [] -- liftM is fmap for Monads (i.e., no required Functor instance): -- liftM f m1 = do x <- m1; return (f m1) cond_wait :: Mutex -> Cond -> IO () cond_wait m (Cond waiters) = do me <- newEmptyMVar modifyMVar_ waiters $ \\others -> return $ others ++ [me] mutex_unlock m -- note we don't care if preempted after this takeMVar me `finally` mutex_lock m cond_signal, cond_broadcast :: Cond -> IO () cond_signal (Cond waiters) = modifyMVar_ waiters wakeone where wakeone [] = return [] wakeone (w:ws) = putMVar w () >> return ws cond_broadcast (Cond waiters) = modifyMVar_ waiters wakeall where wakeall ws = do mapM_ (flip putMVar ()) ws return []\n```", "```\n    data Item a = Item a (Stream a) type Stream a = MVar (Item a) data Chan a = Chan (MVar (Stream a)) (MVar (Stream a))\n    ```", "```\ndata Item a = Item a (Stream a) type Stream a = MVar (Item a) data Chan a = Chan (MVar (Stream a)) (MVar (Stream a)) newChan :: IO (Chan a) newChan = do empty <- newEmptyMVar liftM2 Chan (newMVar empty) (newMVar empty) -- liftM2 is like liftM for functions of two arguments: -- liftM2 f m1 m2 = do x1 <- m1; x2 <- m2; return (f x1 x2) writeChan :: Chan a -> a -> IO () writeChan (Chan _ w) a = do empty <- newEmptyMVar modifyMVar_ w $ \\oldEmpty -> do putMVar oldEmpty (Item a empty) return empty readChan :: Chan a -> IO a readChan (Chan r _) = modifyMVar r $ \\full -> do (Item a newFull) <- takeMVar full return (newFull, a)\n```", "```\n    connectTo :: HostName -> PortID -> IO Handle listenOn :: PortID -> IO Socket accept :: Socket -> (Handle, HostName, PortNumber) sClose :: Socket -> IO () hClose :: Handle -> IO ()\n    ```", "```\n    withClient :: PortID -> (Handle -> IO a) -> IO a\n    ```", "```\n    *Main> withClient (PortNumber 1617) (computerVsUser Rock)\n    ```", "```\n    $ nc localhost 1617 Please enter one of [Rock,Paper,Scissors] Rock You Tie\n    ```", "```\nwithClient :: PortID -> (Handle -> IO a) -> IO a withClient listenPort fn = bracket (listenOn listenPort) sClose $ \\s -> do bracket (accept s) (\\(h, _, _) -> hClose h) $ \\(h, host, port) -> do putStrLn $ \"Connection from host \" ++ host ++ \" port \" ++ show port fn h\n```", "```\n    $ nc localhost 1617 Please enter one of [Rock,Paper,Scissors] Rock You Win\n    ```", "```\n    $ nc localhost 1617 Please enter one of [Rock,Paper,Scissors] Scissors You Lose\n    ```", "```\n    netrock :: PortID -> IO ()\n    ```", "```\n        play :: MVar Move -> MVar Move -> (Handle, HostName, PortNumber) -> IO () play myMoveMVar opponentMoveMVar (h, host, port) = do\n        ```", "```\nplay :: MVar Move -> MVar Move -> (Handle, HostName, PortNumber) -> IO () play myMoveMVar opponentMoveMVar (h, host, port) = do putStrLn $ \"Connection from host \" ++ host ++ \" port \" ++ show port myMove <- getMove h putMVar myMoveMVar myMove opponentMove <- takeMVar opponentMoveMVar let o = outcome myMove opponentMove hPutStrLn h $ \"You \" ++ show o netrock :: PortID -> IO () netrock listenPort = bracket (listenOn listenPort) sClose $ \\s -> do mv1 <- newEmptyMVar mv2 <- newEmptyMVar let cleanup mv (h,_,_) = do tryPutMVar mv (error \"something blew up\") hClose h wait <- newEmptyMVar forkIO $ bracket (accept s) (cleanup mv1) (play mv1 mv2) `finally` putMVar wait () bracket (accept s) (cleanup mv2) (play mv2 mv1) takeMVar wait\n```", "```\n    socket :: Family -> SocketType -> ProtocolNumber -> IO Socket connect :: Socket -> SockAddr -> IO () bindSocket :: Socket -> SockAddr -> IO () listen :: Socket -> Int -> IO () accept :: Socket -> IO (Socket, SockAddr)\n    ```", "```\n    getAddrInfo :: Maybe AddrInfo -> Maybe HostName -> Maybe ServiceName -> IO [AddrInfo]\n    ```", "```\n    webServerAddr :: String -> IO SockAddr webServerAddr name = do addrs <- getAddrInfo Nothing (Just name) (Just \"www\") return $ addrAddress $ head $ addrs\n    ```", "```\nnetcat :: String -> String -> IO () netcat host port = do -- Extract address from first AddrInfo in list AddrInfo{ addrAddress = addr, addrFamily = family }:_ <- getAddrInfo Nothing (Just host) (Just port) -- Create a TCP socket connected to server s <- socket family Stream 0 connect s addr -- Convert socket to handle h <- socketToHandle s ReadWriteMode hSetBuffering h NoBuffering -- THIS IS IMPORTANT -- Punt on complex locale stuff hSetBinaryMode stdout True -- Copy data back and forth taking advantage of laziness done <- newEmptyMVar forkIO $ (hGetContents h >>= putStr) `finally` putMVar done () getContents >>= hPutStr h takeMVar done\n```"]