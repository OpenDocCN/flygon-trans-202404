["```\n\n    Maps (or dictionaries) are ubiquitous data structures both\n    generally and in the theory of programming languages in\n    particular; we're going to need them in many places in the coming\n    chapters.  They also make a nice case study using ideas we've seen\n    in previous chapters, including building data structures out of\n    higher-order functions (from Basics and Poly) and the use of\n    reflection to streamline proofs (from IndProp).\n\n    We'll define two flavors of maps: *total* maps, which include a\n    \"default\" element to be returned when a key being looked up\n    doesn't exist, and *partial* maps, which return an option to\n    indicate success or failure.  The latter is defined in terms of\n    the former, using None as the default element.\n\n```", "```\nRequire Import Coq.Arith.Arith.\nRequire Import Coq.Bool.Bool.\nRequire Import Coq.Strings.String.\nRequire Import Coq.Logic.FunctionalExtensionality.\n\n```", "```\n\n# Identifiers\n\n    First, we need a type for the keys that we use to index into our\n    maps.  For this purpose, we again use the type id from the\n    [Lists](Lists.html) chapter.  To make this chapter self contained, we repeat\n    its definition here, together with the equality comparison\n    function for ids and its fundamental property.\n\n```", "```\n\n    (The function string_dec comes from Coq's string library.\n    If you check its result type, you'll see that it does not actually\n    return a bool, but rather a type that looks like {x = y} + {x \u2260 y}, called a sumbool, which can be thought of as an\n    \"evidence-carrying boolean.\"  Formally, an element of sumbool is\n    either a proof that two things are equal or a proof that they are\n    unequal, together with a tag indicating which.  But for present\n    purposes you can think of it as just a fancy bool.)\n\n```", "```\n\n    The following useful property of beq_id follows from an\n    analogous lemma about strings:\n\n```", "```\n\n    Similarly:\n\n```", "```\n\n    This useful variant follows just by rewriting:\n\n```", "```\n\n# Total Maps\n\n    Our main job in this chapter will be to build a definition of\n    partial maps that is similar in behavior to the one we saw in the\n    [Lists](Lists.html) chapter, plus accompanying lemmas about its behavior.\n\n    This time around, though, we're going to use *functions*, rather\n    than lists of key-value pairs, to build maps.  The advantage of\n    this representation is that it offers a more *extensional* view of\n    maps, where two maps that respond to queries in the same way will\n    be represented as literally the same thing (the very same function),\n    rather than just \"equivalent\" data structures.  This, in turn,\n    simplifies proofs that use maps.\n\n    We build partial maps in two steps.  First, we define a type of\n    *total maps* that return a default value when we look up a key\n    that is not present in the map.\n\n```", "```\n\n    Intuitively, a total map over an element type A is just a\n    function that can be used to look up ids, yielding As.\n\n    The function t_empty yields an empty total map, given a default\n    element; this map always returns the default element when applied\n    to any id.\n\n```", "```\n\n    More interesting is the update function, which (as before) takes\n    a map m, a key x, and a value v and returns a new map that\n    takes x to v and takes every other key to whatever m does.\n\n```", "```\n\n    This definition is a nice example of higher-order programming:\n    t_update takes a *function* m and yields a new function \n    fun x' \u21d2 ... that behaves like the desired map.\n\n    For example, we can build a map taking ids to bools, where Id 3 is mapped to true and every other key is mapped to false,\n    like this:\n\n```", "```\n\n    This completes the definition of total maps.  Note that we don't\n    need to define a find operation because it is just function\n    application!\n\n```", "```\n\n    To use maps in later chapters, we'll need several fundamental\n    facts about how they behave.  Even if you don't work the following\n    exercises, make sure you thoroughly understand the statements of\n    the lemmas!  (Some of the proofs require the functional\n    extensionality axiom, which is discussed in the [Logic](Logic.html)\n    chapter.) \n\n#### Exercise: 1 star, optional (t_apply_empty)\n\n    First, the empty map returns its default element for all keys:\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 stars, optional (t_update_eq)\n\n    Next, if we update a map m at a key x with a new value v\n    and then look up x in the map resulting from the update, we\n    get back v:\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 stars, optional (t_update_neq)\n\n    On the other hand, if we update a map m at a key x[1] and then\n    look up a *different* key x[2] in the resulting map, we get the\n    same result that m would have given:\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 stars, optional (t_update_shadow)\n\n    If we update a map m at a key x with a value v[1] and then\n    update again with the same key x and another value v[2], the\n    resulting map behaves the same (gives the same result when applied\n    to any key) as the simpler map obtained by performing just\n    the second update on m:\n\n```", "```\n\n    \u2610 \n\n    For the final two lemmas about total maps, it's convenient to use\n    the reflection idioms introduced in chapter [IndProp](IndProp.html).  We begin\n    by proving a fundamental *reflection lemma* relating the equality\n    proposition on ids with the boolean function beq_id. \n\n#### Exercise: 2 stars, optional (beq_idP)\n\n    Use the proof of beq_natP in chapter [IndProp](IndProp.html) as a template to\n    prove the following:\n\n```", "```\n\n    \u2610 \n\n    Now, given ids x[1] and x[2], we can use the destruct (beq_idP x[1] x[2]) to simultaneously perform case analysis on the result of\n    beq_id x[1] x[2] and generate hypotheses about the equality (in the\n    sense of =) of x[1] and x[2]. \n\n#### Exercise: 2 stars (t_update_same)\n\n    With the example in chapter [IndProp](IndProp.html) as a template, use\n    beq_idP to prove the following theorem, which states that if we\n    update a map to assign key x the same value as it already has in\n    m, then the result is equal to m:\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 3 stars, recommended (t_update_permute)\n\n    Use beq_idP to prove one final property of the update\n    function: If we update a map m at two distinct keys, it doesn't\n    matter in which order we do the updates.\n\n```", "```\n\n    \u2610\n\n```", "```\nDefinition partial_map (A:Type) := total_map (option A).\n\nDefinition empty {A:Type} : partial_map A :=\n\u00a0\u00a0t_empty None.\n\nDefinition update {A:Type} (m : partial_map A)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(x : id) (v : A) :=\n\u00a0\u00a0t_update m x (Some v).\n\n```", "```\nLemma apply_empty : \u2200A x, @empty A x = None.\n\n    Proof.\n\u00a0\u00a0intros. unfold [empty](Maps.html#empty). rewrite [t_apply_empty](Maps.html#t_apply_empty).\n\u00a0\u00a0reflexivity.\n    Qed.\n\nLemma update_eq : \u2200A (m: partial_map A) x v,\n\u00a0\u00a0(update m x v) x = Some v.\n\n    Proof.\n\u00a0\u00a0intros. unfold [update](Maps.html#update). rewrite [t_update_eq](Maps.html#t_update_eq).\n\u00a0\u00a0reflexivity.\n    Qed.\n\nTheorem update_neq : \u2200(X:Type) v x[1] x[2]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(m : partial_map X),\n\u00a0\u00a0x[2] \u2260 x[1] \u2192\n\u00a0\u00a0(update m x[2] v) x[1] = m x[1].\n\n    Proof.\n\u00a0\u00a0intros X v x[1] x[2] m H.\n\u00a0\u00a0unfold [update](Maps.html#update). rewrite [t_update_neq](Maps.html#t_update_neq). reflexivity.\n\u00a0\u00a0apply H. Qed.\n\nLemma update_shadow : \u2200A (m: partial_map A) v[1] v[2] x,\n\u00a0\u00a0update (update m x v[1]) x v[2] = update m x v[2].\n\n    Proof.\n\u00a0\u00a0intros A m v[1] v[2] x[1]. unfold [update](Maps.html#update). rewrite [t_update_shadow](Maps.html#t_update_shadow).\n\u00a0\u00a0reflexivity.\n    Qed.\n\nTheorem update_same : \u2200X v x (m : partial_map X),\n\u00a0\u00a0m x = Some v \u2192\n\u00a0\u00a0update m x v = m.\n\n    Proof.\n\u00a0\u00a0intros X v x m H. unfold [update](Maps.html#update). rewrite \u2190 H.\n\u00a0\u00a0apply [t_update_same](Maps.html#t_update_same).\n    Qed.\n\nTheorem update_permute : \u2200(X:Type) v[1] v[2] x[1] x[2]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(m : partial_map X),\n\u00a0\u00a0x[2] \u2260 x[1] \u2192\n\u00a0\u00a0\u00a0\u00a0(update (update m x[2] v[2]) x[1] v[1])\n\u00a0\u00a0= (update (update m x[1] v[1]) x[2] v[2]).\n\n    Proof.\n\u00a0\u00a0intros X v[1] v[2] x[1] x[2] m. unfold [update](Maps.html#update).\n\u00a0\u00a0apply [t_update_permute](Maps.html#t_update_permute).\n    Qed.\n\n```", "```\n\n```", "```\n\n```"]