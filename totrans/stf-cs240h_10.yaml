- en: Zippers and lenses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s talk about well-behaved Haskell programs for a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'So well-typed but non-terminating constructs such as the following are forbidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Back to basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How many values can we construct from the following type?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Ordering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another well-known type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Clearly we can construct three different values of this type.
  prefs: []
  type: TYPE_NORMAL
- en: A zero-valued type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Haskell 2010, we can create types from which *no* values can be constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This type has no value constructors (and we can’t use `deriving` syntax on it).
  prefs: []
  type: TYPE_NORMAL
- en: “Why?” you may ask. For programming with types while compiling.
  prefs: []
  type: TYPE_NORMAL
- en: Zero, one, two…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So big deal, we can create types with zero or more constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Adding some parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here’s another type to ponder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Spend a minute working out how many values this can have. We’ll do a quick poll.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting I
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now how many values can this familiar type have?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Abstracting II
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now how many values can this familiar type have?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Algebra I
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why do we refer to these as *product* types?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'They can hold a number of values equal to:'
  prefs: []
  type: TYPE_NORMAL
- en: '*a* × *b* × *c*'
  prefs: []
  type: TYPE_NORMAL
- en: Algebra II
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The same holds for the naming of *sum* types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'They can hold a number of values equal to:'
  prefs: []
  type: TYPE_NORMAL
- en: '*a* + *b* + *c*'
  prefs: []
  type: TYPE_NORMAL
- en: Working with nested data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose we’re writing a benchmarking tool. We’ll take criterion as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Measurements produce noisy samples.
  prefs: []
  type: TYPE_NORMAL
- en: The effect of outliers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to understand how outliers in our sample data affect the sample mean
    and standard deviation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Our `OutlierEffect` type is embedded in another type that carries extra information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: More nesting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: And `OutlierVariance` is buried in another type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Which is nested in *yet another* type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Accessing data is easy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even with three levels of nesting, it’s easy to access an `OutlierEffect` given
    a `Payload`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These record accessor functions are handy!
  prefs: []
  type: TYPE_NORMAL
- en: Updates, not so much
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OK, so suppose we want to “*modify*” an `OutlierEffect` buried in a `Payload`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is hideous! It hardly even looks like Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: What was this?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just saw Haskell’s record update syntax in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This notation means:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a complete copy of the record `addr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When copying, set the `addrZip` field to `zip`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s a way of “editing” a value that leaves the original unchanged, but doesn’t
    require us to specify every field to copy.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also a very non-composable hack, as we saw.
  prefs: []
  type: TYPE_NORMAL
- en: What we actually want
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our demands:'
  prefs: []
  type: TYPE_NORMAL
- en: Access fields within records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose *accesses*, so that we can inspect fields within nested records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update fields within records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose *updates*, so that we can modify fields within nested records.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With Haskell’s record syntax, we get #1 and #2, sort of #3 (if we squint),
    and #4 is hideous.'
  prefs: []
  type: TYPE_NORMAL
- en: What to do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose we have a pair.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We’d like to edit its second element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let’s refer to the fact that we’re interested in the second element *focusing*
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: It’s equally easy to edit the first element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Holes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s refer to the slot we want to fill when editing a tole as a *hole*.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the hole is in the second position.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: And here, it’s in the first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Counting holes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we drop the `b` from `(a,b)`, how many values does the resulting pseudo-type
    have?
  prefs: []
  type: TYPE_NORMAL
- en: Counting holes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we drop the `b` from `(a,b)`, how many values does the resulting pseudo-type
    have?
  prefs: []
  type: TYPE_NORMAL
- en: What if we drop `a` from `(a,b)`?
  prefs: []
  type: TYPE_NORMAL
- en: Counting holes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we drop the `b` from `(a,b)`, how many values does the resulting pseudo-type
    have?
  prefs: []
  type: TYPE_NORMAL
- en: What if we drop `a` from `(a,b)`?
  prefs: []
  type: TYPE_NORMAL
- en: If we want to drop some arbitrary field from `(a,b,c)`, we can represent this
    via a type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Counting holes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can write the number of values of `(x,x,x)` as *x* × *x* × *x*, or *x*³.
  prefs: []
  type: TYPE_NORMAL
- en: If we substitute `x` for `a`, `b`, and `c` below, how many different values
    of type `Hole3` can there be?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Counting holes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can write the number of values of `(x,x,x)` as *x* × *x* × *x*, or *x*³.
  prefs: []
  type: TYPE_NORMAL
- en: If we substitute `x` for `a`, `b`, and `c` below, how many different values
    of type `Hole3` can there be?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Hmm, that’s 3*x*².
  prefs: []
  type: TYPE_NORMAL
- en: Does this remind you of symbolic differentiation?
  prefs: []
  type: TYPE_NORMAL
- en: Back to pairs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s a hole type for pairs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If we pull a value out of the hole, we need to store it somewhere so we can
    work with it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Why do we have an extra type parameter `c`?
  prefs: []
  type: TYPE_NORMAL
- en: So we can choose what type of value to store in the hole later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please provide bodies for the two undefined functions below.
  prefs: []
  type: TYPE_NORMAL
- en: You have one minute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Skeleton: [http://cs240h.scs.stanford.edu/Hole1.hs](http://cs240h.scs.stanford.edu/Hole1.hs)'
  prefs: []
  type: TYPE_NORMAL
- en: My solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A nice thing about this?
  prefs: []
  type: TYPE_NORMAL
- en: The polymorphism forces there to be only one possible implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inverse conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We obviously also need to be able to convert from a zipper back to a pair.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the focused value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have focus functions to get the first or second element of a pair,
    we can write a generic accessor function for our zipper type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Try in `ghci`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Editing the focused value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the more fun part.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again in `ghci`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Editing part deux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What will this print in `ghci`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Editing part deux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What will this print in `ghci`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It’s a type error! `over` is not polymorphic enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bad version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The good version allows editing to change the type of the field being edited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Hmm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This approach has problems.
  prefs: []
  type: TYPE_NORMAL
- en: We have to specify what field we’re focusing at both ends of the “pipeline”.
  prefs: []
  type: TYPE_NORMAL
- en: This is repetitive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we compose these so that we can ‘focusFst’ then ‘focusSnd’ to get another
    zipper?
  prefs: []
  type: TYPE_NORMAL
- en: No.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gluing things together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of keeping `focusFst` and `unfocusFst` separate and wiring them together
    by hand, let’s manage them automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Focused` is a pair consisting of:'
  prefs: []
  type: TYPE_NORMAL
- en: The focused element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that knows how to reconstitute the original value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: A `Focuser` is a function that takes a value and gives us a `Focused`.
  prefs: []
  type: TYPE_NORMAL
- en: Why so polymorphic?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that our original definition of `over` wasn’t polymorphic enough.
  prefs: []
  type: TYPE_NORMAL
- en: We could not change the type of the first element while editing a pair.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Well, `Focused` and `Focuser` have so many type parameters to give exactly this
    generality.
  prefs: []
  type: TYPE_NORMAL
- en: Another look
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`Focused` is in effect saying:'
  prefs: []
  type: TYPE_NORMAL
- en: I am focusing on an `a`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I might change its type to `b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When I am eventually done focusing, I will give you back a `t` (which is `s`
    with every `a` replaced with `b`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another look
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The “meaning” of `Focuser` is:'
  prefs: []
  type: TYPE_NORMAL
- en: You give me an `s`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I will focus on an `a`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I might change its type to `b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When I’m done focusing, I might change the thing I give you back from `s` to
    `t` (once again `s` with every `a` replaced with `b`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some machinery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions for working with these types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Our friends `focusFst` and `focusSnd` recast in this framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Your turn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s your scaffolding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Take two minutes to implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'It should focus on the head of a list, such that we can run this in `ghci`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Skeleton: [http://cs240h.scs.stanford.edu/Focus.hs](http://cs240h.scs.stanford.edu/Focus.hs)'
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting again
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our two most interesting functions have a lot in common.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How could we unify these types?
  prefs: []
  type: TYPE_NORMAL
- en: By using abstraction to decide what type to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Type-level fun
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, `f` is a type-level function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If we supply the type-level identity function, `f` disappears and we get out
    the type of `over`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'With the type-level `const a` function, we get the type of `view`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Type-level identity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Defined in [`Data.Functor.Identity`](http://hackage.haskell.org/package/transformers/docs/Data-Functor-Identity.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Type-level const
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Defined in [`Control.Applicative`](http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:Const):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Our final type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'From our perspective as lens library writers:'
  prefs: []
  type: TYPE_NORMAL
- en: We use `forall` here to make it clear that *we control* the `Functor` we use,
    not our caller.
  prefs: []
  type: TYPE_NORMAL
- en: We choose `Identity` or `Const a` to get the right types for `over` and `view`.
  prefs: []
  type: TYPE_NORMAL
- en: Our final type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'From our perspective as lens library writers:'
  prefs: []
  type: TYPE_NORMAL
- en: We have to explain this type to users.
  prefs: []
  type: TYPE_NORMAL
- en: Give me an `s`, and I will focus on its elements of type `a`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use `over` to edit, you can change those `a` types to `b`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you’re done editing, you’ll get back a `t`, which (if you didn’t change
    `a` to `b`) will be `s`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New machinery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Tuple sections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we turn on this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: More machinery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Composing access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `ghci`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Why is this different from the traditional order of composition?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Composition of lenses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is a lens even *for*?
  prefs: []
  type: TYPE_NORMAL
- en: It turns an action on a *part* of a structure into an action on the *whole*
    structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_1` and `_2` are *not* “just getters”, they take an *entire pair* and focus
    on its first or second element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s `view` and `over` that then determine getter-or-setter nature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does it then mean to compose lenses?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you write `_1 . _head`, you are:'
  prefs: []
  type: TYPE_NORMAL
- en: Taking the entire pair, and focusing on its first element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking the entire pair, and focusing on the head of the list *inside the first
    element of the pair*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing modifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s work out how we would use the lens machinery to give us a pair with an
    uppercased first name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '1: Why are lenses composable?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At first glance, it’s hard to tell why `_1 . _head` even typechecks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: And especially—why can we compose using `.` for function composition?
  prefs: []
  type: TYPE_NORMAL
- en: '2: Why are lenses composable?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key: remembering that a function of 2 arguments is really a function of
    1 arg that returns a function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: What next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best place to start is with the gateway drug:'
  prefs: []
  type: TYPE_NORMAL
- en: The [lens-family-core package](http://hackage.haskell.org/package/lens-family-core)
    is the easiest to learn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also has the easiest source to read: highly recommended!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The full monty:'
  prefs: []
  type: TYPE_NORMAL
- en: The [lens package](http://lens.github.io/) is *way* more powerful, more abstract,
    more difficult to learn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A little controversial due to being huge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Becoming more widely used in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: My [wreq HTTP library](http://www.serpentine.com/wreq)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spotter’s guide to lens operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`^.` is `view` (think “getter”)'
  prefs: []
  type: TYPE_NORMAL
- en: '`%~` is `over` (think “editor”)'
  prefs: []
  type: TYPE_NORMAL
- en: '`.~` is `over` – but accepts a *value* instead of a *function* (think “setter”)'
  prefs: []
  type: TYPE_NORMAL
- en: '`&` is just `$` with arguments flipped'
  prefs: []
  type: TYPE_NORMAL
- en: 'Used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: (“Thing being modified, followed by modifiers in a chain.”)
  prefs: []
  type: TYPE_NORMAL
