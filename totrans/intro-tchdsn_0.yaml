- en: Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Foreword
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前言
- en: Between the artist and the tool are countless techniques and bits of know-how
    that contribute to the artist becoming more fluid and well-equipped for the challenges
    of production. When I caught wind of Elburz’ TouchDesigner book project, I thought,
    yes I’d like to know what he knows! Elburz’ deep storage of TouchDesigner wisdom
    was absorbed from multiple sources - helping and conversing with a myriad of users
    on the forums, red-lining on-the-job on time-critical projects, working with Derivative
    using beta builds of TouchDesigner, and his purely exploratory endeavors mixed
    with his side-life as a hip-hop trombonist and VJ.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在艺术家和工具之间有无数的技巧和知识片段，这些都有助于艺术家变得更加流畅和为制作挑战做好准备。当我听说Elburz的TouchDesigner书籍项目时，我想，是的，我想知道他知道什么！Elburz对TouchDesigner的深入了解来自多个来源——在论坛上帮助和交谈与无数用户，紧急项目的现场修正，使用TouchDesigner的beta版本进行与Derivative的合作，以及他作为嘻哈长号手和VJ的副业纯粹的探索活动。
- en: The book is a good keyboard-side or bed-side companion that explores the concepts,
    techniques and methodology behind TouchDesigner - something I have not had the
    opportunity to personally present before and am very happy Elburz has presented
    here. So build your chops with these treats - It can be read end-to-end or by
    randomly flipping through pages, as I found myself doing - discovering gems of
    information and insights throughout.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是一个很好的键盘旁或床边的伴侣，探讨了TouchDesigner背后的概念、技术和方法论 - 这是我以前没有机会亲自介绍过的东西，我很高兴Elburz在这里呈现了。所以用这些东西来提升自己的技能——它可以从头到尾阅读，也可以随意翻阅页面，就像我自己所做的那样——在整本书中发现了信息和见解的宝藏。
- en: Many thanks to Elburz for this initiative to enrich the TouchDesigner community.
    I’m sure it will trigger a great chain reaction.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢Elburz为丰富TouchDesigner社区所做的努力。我相信这将引发一连串伟大的反应。
- en: '*Greg Hermanovic'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*Greg Hermanovic'
- en: Founder
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 创始人
- en: Derivative*
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 衍生品*
- en: Foreword by Author
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作者的前言
- en: 'The purpose of this book is two-fold:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目的是双重的：
- en: to teach the fundamentals of TouchDesigner 088
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教授TouchDesigner 088的基础知识
- en: to create a community-driven resource for beginners
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个由社区驱动的初学者资源
- en: The first purpose is straightforward. We will look at various UI elements, discuss
    Operators and Operator families, explore logical workflows, Network optimizations,
    performance interfaces, display management, and etc. TouchDesigner's core elements
    will be explained and demonstrated, and many common problems will be pre-emptively
    dealt with.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个目的很简单。我们将看看各种UI元素，讨论操作符和操作符系列，探索逻辑工作流程，网络优化，性能界面，显示管理等。TouchDesigner的核心元素将被解释和演示，并且将预先解决许多常见问题。
- en: After the written portion, we will learn how to approach solving a problem with
    example projects and video tutorials at the end of the book. These lessons will
    be practical in that we will assemble a few projects and useful modules from the
    ground up.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在书面部分之后，我们将通过书的结尾的示例项目和视频教程学习如何解决问题的方法。这些课程将是实践性的，因为我们将从零开始组装一些项目和有用的模块。
- en: The second purpose of this book is slightly more asking of the community. We
    really believe in the community, so instead of selling this book, we wanted everyone
    to be able to access it for free (text, video, and example files). We wanted to
    take this idea a step further, and not only allow free access to the book's contents,
    but also allow free access to the book's building blocks.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的第二个目的对社区的要求稍微更高一些。我们真的相信社区，所以我们不想出售这本书，我们希望每个人都能免费访问它（文字、视频和示例文件）。我们希望进一步推动这个想法，不仅允许免费访问书籍的内容，还允许免费访问书籍的构建模块。
- en: What this means is that anyone can feel free to add, comment, change, mark up,
    delete, or increment upon the resources in this book. All of the book has been
    completely written using LaTeX, and the code to compile the book, project files,
    examples, diagrams, and videos, and whatever else ends up within it, will all
    be hosted on GitHub, and will be free (under a Creative Commons license) for anyone
    to download, share, and build upon.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着任何人都可以随意添加、评论、更改、标记、删除或增加这本书中的资源。这本书的所有内容都是完全使用LaTeX编写的，编译该书的代码、项目文件、示例、图表、视频以及任何其他内容都将托管在GitHub上，并且将免费（根据知识共享许可证）供任何人下载、分享和构建。
- en: For quality control purposes, everyone will be able to branch the repository,
    but we will review all changes before integrating updates back into a main branch.
    Everyone who contributes will be thanked and added to the 'Credits' portion of
    the book. This way, a new user only has to look for a single PDF, or download
    link, to receive the communities most up-to-date knowledge.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了质量控制目的，每个人都可以分支存储库，但我们将在将更新集成回主分支之前审查所有更改。每个贡献者都将受到感谢，并被添加到本书的“致谢”部分。这样，新用户只需寻找一个单独的PDF文件或下载链接，就可以获得社区最新的知识。
- en: We really hope that the community engages with this and helps create the ultimate
    how-to resource for beginners!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真诚希望社区参与其中，并帮助为初学者创建终极的入门资源！
- en: As of the initial writing, knowing what this book is will be as important as
    knowing what this book is not. This book is not an Operator reference manual.
    We will not cover every parameter or use of every Operator. This book is not meant
    to replace the Derivative Wiki as the main reference, we will only use and learn
    about what we need. This book is not meant to replace the forum's wealth of helpful
    users and components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初的撰写时，了解这本书是什么将和了解这本书不是什么一样重要。这本书不是操作符参考手册。我们不会涵盖每个操作符的每个参数或用法。这本书不旨在取代Derivative
    Wiki作为主要参考，我们只会使用和学习我们需要的内容。这本书也不旨在取代论坛中丰富的有用用户和组件。
- en: In the end, this resource is a tribute to many TouchDesigner programmers and
    Derivative staff who, whether on the forum, or in real-life, have helped all of
    us get where we are. We hope that this tradition will continue as long as TouchDesigner
    does.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这个资源是对许多TouchDesigner程序员和Derivative员工的致敬，无论是在论坛上还是在现实生活中，他们都帮助我们所有人走到了今天。我们希望这一传统将随着TouchDesigner的持续而延续。
- en: '*Elburz Sorkhabi & nVoid Art-Tech Limited*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*Elburz Sorkhabi & nVoid Art-Tech Limited*'
- en: What is TouchDesigner?
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TouchDesigner是什么？
- en: 'This is a question many users spend time trying to answer when starting out.
    It can be surprising how long it takes to create and perform simple tasks. It
    can be surprising that a good amount of time is spent building functionality that
    is already native to other software packages. So what is TouchDesigner? The answer
    is simple: TouchDesigner is a visual, node-based programming language.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是许多用户在刚开始时花时间尝试回答的问题。令人惊讶的是，创建和执行简单任务需要花费多长时间。令人惊讶的是，花费了大量时间来构建其他软件包中已经存在的功能。那么TouchDesigner是什么？答案很简单：TouchDesigner是一种视觉、基于节点的编程语言。
- en: Starting from possibly the most important aspect of the description, TouchDesigner
    is a programming language. TouchDesigner isn't an application that is ready on
    start to perform actions that may seem simple in other applications. TouchDesigner
    is an environment with extreme depth, and many potential pitfalls. With some practice
    and time, many things can be created quickly as theyre required. With the book's
    goal to create re-useable modules, the speed at which a blank canvas can become
    a finished project will be greatly increased. This doesn't negate the fact that
    TouchDesigner is still a programming language. Many tasks will still require due
    diligence in regards to time and effort. Many will require quite a bit of head-scratching,
    and all of them will require some basic problem-solving skills.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从描述中可能最重要的方面开始，TouchDesigner是一种编程语言。TouchDesigner不是一个在启动时准备好执行在其他应用程序中看似简单的操作的应用程序。TouchDesigner是一个具有极端深度和许多潜在陷阱的环境。通过一些练习和时间，许多东西可以在需要时快速创建。通过本书的目标创建可重复使用的模块，空白画布变成完成项目的速度将大大增加。这并不是否认TouchDesigner仍然是一种编程语言。许多任务仍然需要时间和精力的尽职调查。许多任务将需要相当多的思考，所有这些任务都将需要一些基本的问题解决技能。
- en: The second aspect of the description is that TouchDesigner is node-based. This
    mean that instead of opening a text document and typing line after line of code,
    TouchDesigner's graphical interface is used to make applications out of nodes.
    Each node, or Operator in TouchDesigner, performs a specific, small, and granular
    action. To perform complex tasks, a handful of nodes will work together. To send
    information between these nodes, their inputs and outputs are wired together.
    There are many node-based programming languages in existence, such as Cycling
    74's Max/MSP, but what sets TouchDesigner apart is it's visual nature.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的第二个方面是TouchDesigner是基于节点的。这意味着，与其打开文本文档并逐行输入代码，TouchDesigner的图形界面用于通过节点制作应用程序。TouchDesigner中的每个节点或操作符执行特定、小型和细粒度的操作。为执行复杂任务，一些节点将共同工作。为在这些节点之间发送信息，它们的输入和输出被连线在一起。存在许多基于节点的编程语言，例如Cycling
    74的Max/MSP，但是TouchDesigner的视觉特性使其与众不同。
- en: Everything in TouchDesigner has a visual counterpart. All the Operators have
    viewers. Everything, whether it be text, control data, audio, videos, and more,
    is visualized through each and every operation that is performed. This is unlike
    any traditional programming, and even node-based, language, but it is what makes
    TouchDesigner a fantastic environment to work with. Learning how to do many complex
    tasks is greatly simplified by the ability to visualize the steps involved, every
    step of the way.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: TouchDesigner中的所有内容都有可视化对应物。所有操作符都有查看器。无论是文本、控制数据、音频、视频等，都通过执行的每个操作来可视化。这与任何传统编程，甚至基于节点的语言都不同，但这正是使TouchDesigner成为一个出色的工作环境的原因。通过能够可视化所涉及的每个步骤，学习如何完成许多复杂任务变得大大简化。
- en: Accessing the book
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问这本书
- en: 'There are multiple ways to access an Introduction to TouchDesigner 088\. Since
    converting the book to using Gitbooks, you may now download the PDF, epub, or
    mobi version of the book from the link below:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以访问《TouchDesigner 088入门》。自从将这本书转换为使用Gitbooks后，您现在可以从下面的链接下载PDF、epub或mobi版本的书籍：
- en: '[https://www.gitbook.com/book/nvoid/introduction-to-touchdesigner/details](https://www.gitbook.com/book/nvoid/introduction-to-touchdesigner/details)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.gitbook.com/book/nvoid/introduction-to-touchdesigner/details](https://www.gitbook.com/book/nvoid/introduction-to-touchdesigner/details)'
- en: 'The example files are found in the `TouchDesigner Example Files` folder of
    the GitHub repo, which can be cloned or downloaded here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 示例文件位于GitHub存储库的`TouchDesigner示例文件`文件夹中，可以在此处克隆或下载：
- en: '[https://github.com/nVoid/Introduction-to-touchdesigner](https://github.com/nVoid/Introduction-to-touchdesigner)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/nVoid/Introduction-to-touchdesigner](https://github.com/nVoid/Introduction-to-touchdesigner)'
- en: 'The hours of HD video tutorials are available in a single Vimeo channel. All
    the files can be downloaded from Vimeo for offline viewing. The link for this
    is below:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 数小时的高清视频教程可在单个Vimeo频道中找到。所有文件都可以从Vimeo下载以供离线观看。以下是此链接：
- en: '[https://vimeo.com/channels/845218](https://vimeo.com/channels/845218)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://vimeo.com/channels/845218](https://vimeo.com/channels/845218)'
- en: You can also download the Markdown source code from this GitHub repo and build
    use the parts separately. You are free to change, edit, add, delete, and modify
    the text by branching the source files. When you are finished, submit your changes
    and they will be reviewed by our administration, and merged into the main branch,
    at which point you will be added to the list of contributors in the Contributors
    chapter of the book, along with your contributions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从此GitHub存储库下载Markdown源代码，并单独构建使用各部分。您可以自由更改、编辑、添加、删除和修改文本，通过分支源文件。完成后，提交您的更改，它们将由我们的管理人员审核，并合并到主分支中，届时您将被添加到书籍的贡献者章节的贡献者列表中，连同您的贡献。
- en: For more general information about this resource, visit [http://book.nvoid.com](http://book.nvoid.com)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此资源的更多一般信息，请访问[http://book.nvoid.com](http://book.nvoid.com)
- en: Compiling the book
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译这本书
- en: Unlike the previous LaTeX version, no build environment is required to contribute
    to the book. You can use plain Markdown, and when you're done and your changes
    are accepted to the repository, Gitbooks automatically takes care of creating
    a new web version, PDF, epub, and mobi version of the book.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的LaTeX版本不同，无需构建环境即可为这本书做出贡献。您可以使用普通的Markdown，当您完成并且您的更改被接受到存储库时，Gitbooks会自动创建新的网络版本、PDF、epub和mobi版本的书籍。
- en: Attribution and Licensing
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归属和许可
- en: This resource is licensed under Creative Commons - Attribution-NonCommercial-ShareAlike-4.0
    International.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本资源采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议。
- en: 'Link: [http://creativecommons.org/licenses/by-nc-sa/4.0/](http://creativecommons.org/licenses/by-nc-sa/4.0/)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '链接: [http://creativecommons.org/licenses/by-nc-sa/4.0/](http://creativecommons.org/licenses/by-nc-sa/4.0/)'
- en: Thank you!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢！
- en: Signal Flow and Wiring
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号流和连接
- en: 1 Basics
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 基础知识
- en: '*1.1 Signal Flow and Wiring*'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*1.1 信号流和连接*'
- en: Wiring Operators is the most basic operation in TouchDesigner. All projects
    are made up of nothing more than groups of Operators wired together. Each Operator,
    on its own, does a very specific thing, but when they are combined together into
    a ’Network’, they can solve extremely complex problems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在TouchDesigner中，连接操作符是最基本的操作。所有项目都由一组组连接在一起的操作符组成。每个操作符本身都有一个非常具体的功能，但当它们组合在一起成为一个'网络'时，它们可以解决非常复杂的问题。
- en: All data in TouchDesigner flows from left to right. Any inputs that an Operator
    has will always be on the left side, and outputs will be on the right side. The
    inputs and outputs will also be ordered first to last, going from top to bottom.
    In the example diagram below, follow the two signals starting on the left. As
    they flow from left to right, they are composited, one over the other.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: TouchDesigner中的所有数据都是从左到右流动的。任何操作符具有的输入始终在左侧，输出在右侧。输入和输出也将按照从上到下的顺序排序。在下面的示例图中，从左侧开始跟随两个信号。当它们从左到右流动时，它们会叠加在一起。
- en: '![img 1.1.1](signal-flow-1.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![img 1.1.1](signal-flow-1.png)'
- en: Components, interestingly, have the same data signal flow as Operators, flowing
    from left to right, but they are also capable of parent and child relationships,
    which flow from top to bottom. The component at the top of the signal chain is
    the parent, and the components below it are its children, and below that are the
    children’s children, and so on. In the example below, there is a small UI, that
    is made of a few sliders. In this example, the Slider COMPs are the children of
    the Container COMP, which is the parent.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，组件与操作符具有相同的数据信号流，从左到右流动，但它们还能够具有父子关系，从上到下流动。信号链顶部的组件是父组件，其下方的组件是其子组件，再下方是子组件的子组件，依此类推。在下面的示例中，有一个由几个滑块组成的小型UI。在这个示例中，滑块组件是容器组件的子组件，而容器组件是父组件。
- en: '![img 1.1.2](signal-flow-2.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![img 1.1.2](signal-flow-2.png)'
- en: Creating Operators
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建操作符
- en: '*1.2 Creating Operators*'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*1.2 创建操作符*'
- en: The OP Create Dialog can be reached in a multitude of ways. Each has a correct
    time and place of usage. When creating Operators from scratch the two easiest
    methods are to hit ’Tab’ on the keyboard, or to double click on the Network background.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: OP 创建对话框可以通过多种方式到达。每种方式都有正确的使用时间和地点。当从头开始创建操作符时，最简单的两种方法是在键盘上按下'Tab'键，或者双击网络背景。
- en: When working with existing chains of Operators, there are two easy ways to add
    Operators. The first is to right click on either the input or output of an Operator.
    This will add the chosen Operator, pre-wired, directly before the input or after
    the output. This is especially useful as it inserts the Operator seamlessly into
    a pre-existing chain.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理现有操作符链时，有两种简单的方法可以添加操作符。第一种是右键单击操作符的输入或输出。这将在输入之前或输出之后直接添加所选的操作符，并进行预连接。这在将操作符无缝插入到现有链中时特别有用。
- en: For example, there is a Constant TOP wired to a Null TOP, and a Transform TOP
    needs to be added between the two. Right clicking either the output of the Constant
    TOP, or the input of the Null TOP, and selecting Transform TOP, would create a
    Transform TOP, that would be pre-wired in-between the Constant TOP and Null TOP.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有一个连接到Null TOP的Constant TOP，需要在两者之间添加一个Transform TOP。右键单击Constant TOP的输出或Null
    TOP的输入，并选择Transform TOP，将创建一个Transform TOP，它将预先连接在Constant TOP和Null TOP之间。
- en: The second way to add an Operator to an existing chain is to middle click on
    the output of an Operator. The difference is that right clicking integrates the
    newly created Operator into the current Operator chain, whereas middle clicking
    creates a new branch in parallel to the chain of Operators.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 添加操作符到现有链中的第二种方法是在操作符的输出上中键单击。不同之处在于，右键单击会将新创建的操作符集成到当前操作符链中，而中键单击会在操作符链的旁边创建一个新的并行分支。
- en: Similar results can be achieved by right clicking on the wire itself and clicking
    on ’Insert Operator’ or ’Add Operator’. ’Insert Operator’ acts like right clicking
    an Operator’s output and integrates it into the current Operator chain, whereas
    ’Add Operator’ acts like middle clicking and creates a new branch in parallel
    to the chain.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过右键单击线本身然后点击“插入操作符”或“添加操作符”来实现类似的结果。“插入操作符”的作用类似于右键单击操作符的输出，并将其集成到当前操作符链中，而“添加操作符”的作用类似于中键单击，并在操作符链的旁边创建一个新的分支。
- en: In the diagram below, there is an example with a Constant TOP and a Null TOP.
    In the next diagram, the wire connecting them was right clicked and a Transform
    TOP was created using ’Insert Operator’. In the proceeding diagram, the wire connecting
    the Operators was right clicked and a Transform TOP was created using ’Add Operator’.
    Notice how it is pre-wired in parallel to the first Transform TOP.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图表中，有一个包含一个常量 TOP 和一个空 TOP 的示例。在接下来的图表中，右键单击连接它们的线，并使用“插入操作符”创建了一个变换 TOP。在后续图表中，右键单击连接操作符的线，并使用“添加操作符”创建了一个变换
    TOP。注意它是如何预先连线并行到第一个变换 TOP 的。
- en: '![img 1.2.1](creating-operators-1.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![img 1.2.1](creating-operators-1.png)'
- en: '![img 1.2.2](creating-operators-2.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![img 1.2.2](creating-operators-2.png)'
- en: '![img 1.2.3](creating-operators-3.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![img 1.2.3](creating-operators-3.png)'
- en: 'There are two useful key commands when working with the OP Create Dialog: ’Control’
    and ’Shift’. Open the OP Create dialog, hold down ’Control’ on the keyboard, and
    then begin to select multiple Operators in a row. Each one will be added to the
    Network below the last. This is useful for quickly populating a Network with a
    few different Operators.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用操作符创建对话框时，有两个有用的键命令：“Control”和“Shift”。打开操作符创建对话框，按住键盘上的“Control”键，然后开始连续选择多个操作符。每个操作符将被添加到上一个下方的网络中。这对于快速使用几个不同的操作符填充网络非常有用。
- en: Similarly, open the OP Create dialog, press and hold the ’Shift’ key, and then
    begin to select multiple Operators. This is different than above, in that the
    Operators will be wired together in series. This key command can be used to quickly
    create small, or large, chains of pre-wired Operators.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，打开操作符创建对话框，按住“Shift”键，然后开始选择多个操作符。这与上面不同，因为这些操作符将串联在一起。这个键盘命令可用于快速创建预先连线的操作符的小型或大型链。
- en: 'Both of these key commands are quite powerful, but they become even more so
    when they are used in tandem. For example, a project requires 3 chains of Operators.
    The first will consist of a Circle TOP, connected to a Blur TOP, connected to
    a Null TOP. The second will consist of a Circle TOP, connected to an Edge TOP,
    connected to a Noise TOP, connected to a Null TOP. The final chain will consist
    of a Movie In TOP, connected to a Blur TOP, connected to a Null TOP. Let’s go
    through this step by step, to demonstrate practical use of the above key commands:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当这两个键命令一起使用时，它们变得更加强大。例如，一个项目需要 3 条操作符链。第一条将由一个 Circle TOP 组成，连接到一个模糊 TOP，连接到一个空
    TOP。第二条将由一个 Circle TOP 组成，连接到一个 Edge TOP，连接到一个 Noise TOP，连接到一个空 TOP。最后一条链将由一个
    Movie In TOP 组成，连接到一个模糊 TOP，连接到一个空 TOP。让我们一步步地进行，以演示以上键命令的实际用法：
- en: Open the OP Create dialog
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开操作符创建对话框
- en: Press and hold down ’Shift’
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住“Shift”键
- en: While holding ’Shift’, click on Circle TOP, Blur TOP, then Null TOP. This will
    create the first chain.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按住“Shift”键的同时，点击 Circle TOP、模糊 TOP，然后空 TOP。这将创建第一条链。
- en: Release the ’Shift’ key
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 松开“Shift”键
- en: Press and hold down ’Control’. This will place the next Operator below the first
    Operator.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住“Control”键。这将在第一个操作符下放置下一个操作符。
- en: Holding ’Control’, click on Circle TOP
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按住“Control”键的同时，点击 Circle TOP
- en: Release the ’Control’ key
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 松开“Control”键
- en: Press and hold down the ’Shift’ key
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住“Shift”键
- en: While holding ’Shift’, click on Edge TOP, Noise TOP, and then Null TOP. This
    will create the second chain
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按住“Shift”键的同时，点击 Edge TOP、Noise TOP，然后空 TOP。这将创建第二条链
- en: Release the ’Shift’ key
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 松开“Shift”键
- en: Press and hold ’Control’
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住“Control”键
- en: While holding ’Control’, click on Movie In TOP.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按住“Control”键的同时，点击 Movie In TOP。
- en: Release the ’Control’ key
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 松开“Control”键
- en: Press and hold ’Shift’
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住“Shift”键
- en: 'Click on the remaining operators: Blur TOP, and Null TOP'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击剩余的操作符：模糊 TOP 和 空 TOP
- en: Now that all of the Operators are created, use the ’Esc’ key to close the OP
    Create dialog.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在所有操作符都已创建完成，使用“Esc”键关闭操作符创建对话框。
- en: After closing the OP Create Dialog, all the required Operators will be wired
    and ready to go in the project. These key commands have not only saved having
    to open and close the OP Create Dialog for every Operator, but they’ve saved the
    need to manually wire them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭OP创建对话框后，所有所需的运算符将被连接并准备好在项目中使用。这些关键命令不仅节省了每个运算符都要打开和关闭OP创建对话框的时间，而且还节省了手动连接它们的需要。
- en: Mouse and Keyboard Navigation
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鼠标和键盘导航
- en: '*1.3 Mouse and Keyboard Navigation*'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*1.3 鼠标和键盘导航*'
- en: The mouse plays a vital role in TouchDesigner programming, and a high-quality
    mouse is highly recommended. The mouse is used to move around the Network and
    work with Operators.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标在TouchDesigner编程中起着至关重要的作用，强烈推荐使用高质量的鼠标。鼠标用于在网络中移动和处理运算符。
- en: To navigate around the Network, left click and drag the Network background.
    Left click on an Operator to select it. Left click and drag that Operator to move
    it around the Network. Right click on an Operator to reveal a menu with options
    that will be introduced slowly. To select and work with more than one Operator,
    right click and drag the selection box around the desired Operators. Middle click
    on an Operator to get more info about it. There is a UI button that displays the
    same Operator info window, which is useful when using a mouse that doesn’t have
    a middle click button.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要在网络中导航，左键单击并拖动网络背景。左键单击运算符以选择它。左键单击并拖动该运算符以在网络中移动它。右键单击运算符以显示带有逐渐介绍的选项的菜单。要选择并处理多个运算符，右键单击并拖动选择框围绕所需的运算符。中键单击运算符以获取有关它的更多信息。有一个显示相同运算符信息窗口的UI按钮，当使用没有中键单击按钮的鼠标时非常有用。
- en: '![](navigation-1.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](navigation-1.png)'
- en: Left-click on the ’i’ to get more detailed information about the selected operator.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 左键单击“i”以获取有关所选运算符的更详细信息。
- en: There are several key commands used to navigate TouchDesigner projects. Two
    of these key commands are ’u’ and ’i’. Press ’u’ will move up one Network, and
    out of the current component. To go inside of a Network or component (like a Container
    COMP or Base COMP), select the component and hit ’i’.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个用于导航TouchDesigner项目的关键命令。其中两个关键命令是‘u’和‘i’。按‘u’将向上移动一个网络，并退出当前组件。要进入网络或组件（如容器COMP或基础COMP），选择组件并按‘i’。
- en: To centralize the screen on all the Operators in a Network, use the ’h’ key
    on the keyboard. This performs the ’Home’ action on the current Network.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要将屏幕居中显示网络中的所有运算符，请使用键盘上的‘h’键。这会执行当前网络上的‘主页’操作。
- en: Networks and Paths
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络和路径
- en: '*1.4 Networks and Paths*'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*1.4 网络和路径*'
- en: All TouchDesigner projects are made of Networks. A Network is a group of Operators.
    Networks are encapsulated inside of components, such as a Container COMP, Base
    COMP, Geometry COMP, etc. Networks can be infinitely nested. The top level is
    called the ’root’ level. TouchDesigner system and UI elements can be found at
    the ’root’ level.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有TouchDesigner项目都由网络组成。网络是一组运算符。网络封装在组件内，例如容器COMP、基础COMP、几何COMP等。网络可以无限嵌套。顶层称为“根”级别。TouchDesigner系统和UI元素可以在“根”级别找到。
- en: Encapsulating and organizing Networks from the start of the project is a great
    practice to get in the habit of. The current path is always visible in the ’Path
    Bar’ at the top of the ’Network Editor’.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目开始封装和组织网络是一个很好的习惯。当前路径始终显示在“网络编辑器”顶部的“路径栏”中。
- en: '![](path-1.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](path-1.png)'
- en: 'All TouchDesigner Operators have a path. These paths are similar to Unix file
    paths. There are two kinds of paths to an Operator: the ’absolute path’ and the
    ’relative path’. The ’absolute path’ is the path to the Operator from the ’root’
    of the project, or ’/’. The ’relative path’ is the path to an Operator from another
    Operator. These paths start from the Network of the referencing Operator, instead
    of starting from the ’root’.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所有TouchDesigner运算符都有路径。这些路径类似于Unix文件路径。有两种到运算符的路径：‘绝对路径’和‘相对路径’。‘绝对路径’是从项目的‘根’或‘/’到运算符的路径。‘相对路径’是从另一个运算符到运算符的路径。这些路径从引用运算符的网络开始，而不是从‘根’开始。
- en: Open example ’Paths.toe’. This example demonstrates paths. TouchDesigner will
    start in the ’root’ of the project where there is a Container COMP named ’network1’.
    Inside of ’network1’, there are two Operators. ’rel1’ is a Text DAT with two paths
    in its contents. The first is an ’absolute path’. This path starts from the ’root’,
    or top of the project, and travels towards the Operator. The second path is the
    ’relative path’ from the current Operator to ’rel2’, which is a Text DAT inside
    of the Container COMP named ’network2’. In the ’relative path’, the path travels
    from the current location to the destination. To get from ’rel1’ to ’rel2’, the
    path only needs to travel into ’network2’, thus the ’relative path’ is ’network2/rel2’.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Paths.toe'。此示例演示路径。TouchDesigner 将从项目的 'root' 开始，在那里有一个名为 'network1' 的容器
    COMP。在 'network1' 中，有两个运算符。'rel1' 是一个 Text DAT，其内容中有两个路径。第一个是 '绝对路径'。该路径从 'root'，或项目的顶部开始，并朝着运算符。第二个路径是从当前运算符到
    'rel2' 的 '相对路径'，后者是名为 'network2' 的容器 COMP 中的 Text DAT。在 '相对路径' 中，路径从当前位置到目的地。要从
    'rel1' 到 'rel2'，路径只需要进入 'network2'，因此 '相对路径' 是 'network2/rel2'。
- en: Notice that the viewer of ’network2’ is displaying an Operator from inside of
    it. This technique will be discussed more in later examples, but what is important
    now is the path used. In the ’Operator Viewer’ parameter of ’network2’, there
    is the path to ’./display’, where ’display’ is the name of the Operator, and ’./’
    denotes one level inside of the referencing Operator, which is ’network2’ in this
    case.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，''network2'' 的查看器正在显示来自其中的运算符。这种技术将在后续示例中更详细地讨论，但现在重要的是使用的路径。在 ''network2''
    的 ''运算符查看器'' 参数中，有指向 ''./display'' 的路径，其中 ''display'' 是运算符的名称，''./'' 表示参考运算符内部的一个级别，这种情况下是
    ''network2''。 '
- en: Inside of ’network2’, there is a Text DAT named ’display’, whose contents are
    being displayed in the Network above. The other two Text DATs have more path examples
    written in them. ’abs1’ is another example of an ’absolute path’. ’rel2’ has an
    example of a ’relative path’ between itself and ’abs1’. It also has an example
    of a ’relative path’ between itself and ’rel1’ in the Network above, where ’rel1’
    is the Operator’s name, and ’../’ denotes one Network level above the current
    Network. ’../’ can be used in sequence to move up as high as the root, but there
    are more efficient ways of making paths.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 'network2' 内部，有一个名为 'display' 的 Text DAT，其内容正在上面的网络中显示。另外两个 Text DAT 中写入了更多的路径示例。'abs1'
    是 '绝对路径' 的另一个示例。'rel2' 有一个示例，显示了它与 'abs1' 之间的 '相对路径'。它还展示了它与上面网络中的 'rel1' 之间的
    '相对路径' 的示例，其中 'rel1' 是运算符的名称，'../' 表示当前网络的上一个网络级别。'../' 可以连续使用，直到到达根目录，但有更有效的方法来创建路径。
- en: Using an External Text Editor
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部文本编辑器
- en: '*1.5 Using an External Text Editor*'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*1.5 使用外部文本编辑器*'
- en: Small Python scripts can be created and edited inside of TouchDesigner, but
    as scripts grow, an external text editor can save a lot of time and trouble.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TouchDesigner 内部可以创建和编辑小型 Python 脚本，但随着脚本的增长，使用外部文本编辑器可以节省大量时间和麻烦。
- en: 'There are a number of helpful features gained by editing scripts in an external
    text editor. Without creating an extensive list, some reasons include:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在外部文本编辑器中编辑脚本，可以获得许多有用的功能。不列举详尽列表，一些原因包括：
- en: Line numbering
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行编号
- en: Colour coded syntax
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 颜色编码的语法
- en: Find & Replace functionality
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找和替换功能
- en: Auto-completion
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动完成
- en: These features add up to a far richer, and more efficient experience when working
    extensively with Python inside of TouchDesigner.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当大量使用 Python 在 TouchDesigner 内部工作时，这些功能会大大丰富和提高效率。
- en: Open the ’Preferences’ dialog found in the ’Edit’ menu
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“编辑”菜单中的“首选项”对话框
- en: Go to the ’DATs’ preferences
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“DATs”首选项
- en: Click the file browser icon for the ’Text Editor’ setting
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“文本编辑器”设置的文件浏览器图标
- en: Assign the the external editor’s executable (.exe) by selecting it and clicking
    ’Open’. This is usually located in the ’Program Files’ folder
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择外部编辑器的可执行文件（.exe）并点击“打开”来分配。这通常位于“Program Files”文件夹中。
- en: Click ’Accept’ on the Preferences dialog
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在首选项对话框上单击“接受”
- en: Once the setup is complete, right click on a DAT and click the ’Edit Contents’
    option. The DAT will be opened in the program which is specified by this preference.
    A separate ’Table Editor’ preference is available to set the external editor used
    for DATs that are tables.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，在 DAT 上右键单击并单击“编辑内容”选项。DAT 将在此首选项指定的程序中打开。可用单独的“表格编辑器”首选项来设置用于 DAT 的外部编辑器，这些
    DAT 是表格。
- en: 'Two well-respected editors that are used frequently in the TouchDesigner community,
    and are crossplatform, are linked below:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: TouchDesigner 社区经常使用的两个备受尊敬的编辑器，而且跨平台性强，下面链接了它们：
- en: '*Sublime Text 3* [http://www.sublimetext.com/](http://www.sublimetext.com/)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*Sublime Text 3* [http://www.sublimetext.com/](http://www.sublimetext.com/)'
- en: '*Notepad++* [http://notepad-plus-plus.org/](http://notepad-plus-plus.org/)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*Notepad++* [http://notepad-plus-plus.org/](http://notepad-plus-plus.org/)'
- en: Help
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帮助
- en: '*1.6 Help*'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*1.6 帮助*'
- en: If there are ever any questions about specific Operators or processes, refer
    to the official Derivative Wiki. Each Operator has two shortcuts that will open
    its Wiki page in a new browser window. These two buttons are located in the Parameter
    window, and both are represented by question marks. One is specifically about
    the Operator and its use, while the other, the question mark over the Python logo,
    is specifically about Python scripting with that Operator.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对特定操作器或流程有任何疑问，请参阅官方 Derivative Wiki。每个操作器都有两个快捷方式，将在新浏览器窗口中打开其 Wiki 页面。这两个按钮位于参数窗口中，都由问号表示。一个是关于操作器及其用法的，而另一个，Python
    标志上的问号，是关于使用该操作器进行 Python 脚本编写的。
- en: '![](help-1.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](help-1.png)'
- en: '![](help-2.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](help-2.png)'
- en: Parameter Window
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数窗口
- en: 2 User Interface
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 用户界面
- en: '*2.1 Parameter Window*'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.1 参数窗口*'
- en: The 'Parameter Window' is where all an Operator's parameters can be accessed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: “参数窗口”是可以访问所有操作器参数的地方。
- en: There are two ways to access the 'Parameter Window'. The first is using the
    'P' key. This will open a docked 'Parameter Window' in the top-right hand corner
    of the pane. This docked 'Parameter Window' will display the parameters of whatever
    Operator is selected.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 访问“参数窗口”的两种方法。第一种方法是使用“P”键。这将在窗格的右上角打开一个停靠的“参数窗口”。这个停靠的“参数窗口”将显示所选操作器的参数。
- en: The second way to access the 'Parameter Window' is by right clicking on an Operator
    and selecting 'Parameters...'. This will open up a floating 'Parameter Window'
    for the Operator. This method differs from the first in that the parameters will
    not change if another Operator is selected. This is useful for being able to manage
    the parameters of multiple Operators simultaneously.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 访问“参数窗口”的第二种方法是右键单击操作器，然后选择“参数...”。这将为操作器打开一个浮动的“参数窗口”。此方法与第一种方法不同之处在于，如果选择另一个操作器，参数不会更改。这对同时管理多个操作器的参数非常有用。
- en: 'Every Operator has a different set of parameters, but all ''Parameter Windows''
    have the same set of options. Below is a diagram highlighting the options:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作器都有一组不同的参数，但所有“参数窗口”都具有相同的选项集。下面是一个突出显示选项的图表：
- en: '![image 2.1.1](parameter-window.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image 2.1.1](parameter-window.png)'
- en: 'From left to right, the options are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，选项如下：
- en: 'Operator Help: opens the Operator''s Wiki help page in a new browser window'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作器帮助：在新浏览器窗口中打开操作器的 Wiki 帮助页面
- en: 'Operator Python Help: opens the Operator''s Python Wiki help page in a new
    browser'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作器 Python 帮助：在新浏览器中打开操作器的 Python Wiki 帮助页面
- en: 'Operator Information Dialog: displays information about the Operator''s process,
    similar to middle-clicking an Operator'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作器信息对话框：显示有关操作器过程的信息，类似于中键单击操作器
- en: 'Comment: display and edit Operator comments'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释：显示并编辑操作器注释
- en: 'Copied Parameters: displays parameters copied via the right click menu'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已复制的参数：显示通过右键菜单复制的参数
- en: 'Language: choose whether the Operator will use Python or tscript as its scripting
    language'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语言：选择操作器将使用 Python 还是 tscript 作为其脚本语言
- en: 'Expand/Collapse Parameters: expand or collapse all the Operator''s parameters'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开/折叠参数：展开或折叠所有操作器的参数
- en: 'Non-default Parameters: display only parameters that have been changed from
    their default values'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非默认参数：仅显示已更改为非默认值的参数
- en: Parameters
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数
- en: '*2.2 Parameters*'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.2 参数*'
- en: 'Parameters can be entered in a number of ways. Depending on the situation,
    some parameters may require a static value, and some may need to be driven by
    other values and inputs. Each parameter has three modes. Each mode is quite different
    and each defines how the parameter behaves. The three modes are:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以通过多种方式输入。根据情况，某些参数可能需要静态值，而某些参数可能需要由其他值和输入驱动。每个参数都有三种模式。每种模式都非常不同，并且每种都定义了参数的行为。这三种模式分别是：
- en: Constant mode
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常量模式
- en: Expression mode
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表达式模式
- en: Export mode
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出模式
- en: Constant mode is the default for most parameters, and is represented by a grey
    colour scheme in the value field. Expression mode is used for Python, tscript,
    or mathematical operations and scripts. Expression mode is represented by a dark
    grey and light blue colour scheme. Export mode is used to directly reference CHOP
    channels. It is represented by a light green colour scheme.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数参数的默认模式是常量模式，以灰色方案表示在数值字段中。表达式模式用于Python、tscript或数学运算和脚本。表达式模式以深灰色和浅蓝色方案表示。导出模式用于直接引用CHOP通道。它以浅绿色方案表示。
- en: Each of an Operators parameters can be independently changed between the three
    modes. To change the mode of a parameter, hover the mouse over the parameter's
    name. A '+' sign will appear near the parameter's name, similarly to the diagram
    below.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符的每个参数可以在三种模式之间独立更改。要更改参数的模式，请将鼠标悬停在参数的名称上。在参数的名称附近会出现一个“+”号，与下图类似。
- en: '![](parameters-1.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](parameters-1.png)'
- en: 'Once hovering over the parameter''s name, click it and it will expand, displaying
    more information and options, similarly to the diagram below:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 悬停在参数的名称上后，点击它会展开，显示更多信息和选项，与下图类似：
- en: '![](parameters-2.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](parameters-2.png)'
- en: 'There are three main elements that are available once a parameter is expanded.
    The first on the left, is the parameter''s scripting name. This scripting name
    is needed whenever that parameter is referenced in any of TouchDesigner''s scripting
    languages. In the above diagram, the scripting name for the Noise CHOP''s Roughness
    is ''rough''. Continuing the above example, the Python script to set the Roughness
    of the above Noise CHOP to ''1'' would be:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦参数展开，就会提供三个主要元素。左侧的第一个是参数的脚本名称。无论何时需要引用该参数在TouchDesigner的任何脚本语言中都需要此脚本名称。在上图中，噪声CHOP的粗糙度的脚本名称是'rough'。继续上面的例子，将上述噪声CHOP的粗糙度设置为'1'的Python脚本将是：
- en: '`op(''noise1'').par.rough = 1`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`op(''noise1'').par.rough = 1`'
- en: The second element is the three coloured squares. These squares represent the
    different modes for the parameter, as discussed above. Operator parameters set
    to Constant mode are represented by a filled grey square. This parameter can be
    changed to Expression mode by clicking on the outline of the light blue square.
    Once clicked, the light blue square will be filled, and the value field to the
    right will also be coloured to reflect the parameter's mode.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个元素是三个彩色方块。这些方块代表了上面讨论的参数的不同模式。设置为常量模式的操作符参数由填充的灰色方块表示。可以通过点击浅蓝色方块的轮廓来将此参数更改为表达式模式。一旦点击，浅蓝色方块将被填充，并且右侧的值字段也将被着色以反映参数的模式。
- en: '![](parameters-3.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](parameters-3.png)'
- en: To change the parameter's mode to Export mode, a CHOP channel needs to be dragged
    and dropped on the parameter, at which point it will take up Export mode's colour
    scheme, and the green box will be filled in.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要将参数的模式更改为导出模式，需要将CHOP通道拖放到参数上，此时它将采用导出模式的颜色方案，并且绿色方块将被填充。
- en: '![](parameters-4.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](parameters-4.png)'
- en: The third element of the expanded parameter is the value field. The value field
    displays a different piece of information depending on the parameter mode. In
    Constant mode, the value field displays the current value, and can be edited by
    clicking and typing in the field. In Expression mode, the value field displays
    the script of Python or tscript that is being evaluated. The expression can be
    edited by clicking and typing in the value field. In Export mode, the value field
    displays two pieces of information separated by a colon. The text before the colon
    displays the path of the CHOP that is exporting to this parameter. The text after
    the colon is the name of the channel being exported from the CHOP. Because these
    values are being imposed by another Operator, the value field cannot be edited
    while the parameter is in Export mode.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 展开参数的第三个元素是值字段。值字段显示不同的信息，具体取决于参数模式。在常量模式下，值字段显示当前值，并且可以通过单击并在字段中输入来进行编辑。在表达式模式下，值字段显示正在评估的Python或tscript的脚本。表达式可以通过单击并在值字段中输入来编辑。在导出模式下，值字段显示由冒号分隔的两个信息。冒号前的文本显示导出到此参数的CHOP的路径。冒号后的文本是从CHOP导出的通道的名称。因为这些值是由另一个操作符强加的，所以在参数处于导出模式时无法编辑值字段。
- en: Transport Controls
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输控制
- en: '*2.3 Transport Controls*'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.3 传输控制*'
- en: 'The transport bar functions similarly to the transport bars of many other applications.
    To go through it quickly, from left to right the buttons do the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 运输栏的功能与许多其他应用程序的运输栏类似。从左到右快速浏览按钮的功能如下：
- en: '![](transport-1.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](transport-1.png)'
- en: Resets timeline to frame 1
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将时间轴重置为第1帧
- en: Pause the timeline
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂停时间轴
- en: Play timeline in reverse
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反向播放时间轴
- en: Play timeline forward
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放时间轴向前
- en: Step one frame backward
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向后移动一帧
- en: Step one frame forward
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向前移动一帧
- en: Setting 'Range Limit' to 'Loop' will continuously loop the timeline
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将'范围限制'设置为'循环'将持续循环时间轴
- en: Setting 'Range Limit' to 'Once' will play through the timeline and hold the
    last frame
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将'范围限制'设置为'一次'将播放时间轴并保持最后一帧
- en: The most used functions of the timeline are 'Play' and 'Pause', which can be
    accessed quickly by pressing the 'Space bar' on the keyboard.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 时间轴最常用的功能是'播放'和'暂停'，可以通过快速按键盘上的'空格键'来快速访问。
- en: Timeline Settings
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间轴设置
- en: '*2.4 Timeline Settings*'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.4 时间轴设置*'
- en: Unless media or animations is locked to the timeline, the 'Timeline settings'
    won't need to be regularly accessed. The 'Timeline settings' can be found in the
    bottom left of the window. The key things to know about this area are that the
    project's 'FPS' and 'Tempo' can be changed here. The project's 'FPS' determines
    the rate at which the project will render frames. By default it is set to 60 FPS,
    meaning that TouchDesigner will try to render 60 frames every second. The 'Tempo'
    will set the BPM (beats per minute) of the project, for use by the Beat CHOP.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除非媒体或动画被锁定到时间轴，否则不需要经常访问'时间轴设置'。'时间轴设置'位于窗口左下角。关于这个区域需要知道的关键事项是项目的'FPS'和'节奏'可以在这里更改。项目的'FPS'确定项目渲染帧的速率。默认设置为60
    FPS，这意味着TouchDesigner会尝试每秒渲染60帧。'节奏'将设置项目的BPM（每分钟节拍数），供Beat CHOP使用。
- en: The 'Timeline settings' are use more in situations where animations and media
    need to be locked to a consistent timeline. The frame controls include 'Start'
    and 'End', which control the start frame and end frame of the timeline, as well
    as 'RStart' and 'REnd', which control the loop start and loop end of the timeline.
    With these settings, it is possible to create an animation that spans the entire
    timeline, which could be 4000 frames, while still leaving the option to loop a
    small section of the timeline to work within.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '''时间轴设置''在需要将动画和媒体锁定到一致时间轴的情况下更常用。帧控制包括''开始''和''结束''，控制时间轴的开始帧和结束帧，以及''RStart''和''REnd''，控制时间轴的循环开始和循环结束。通过这些设置，可以创建一个跨越整个时间轴的动画，可能是4000帧，同时仍然可以选择循环时间轴的一小部分以进行工作。'
- en: '![](timeline.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](timeline.png)'
- en: Panes
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面板
- en: '*2.5 Panes*'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.5 面板*'
- en: Using panes regularly can save a ton of time when moving back and forth between
    Networks. Having to travel through 3 Networks to change a parameter, only to have
    to travel back to see the changes is a waste of time. Panes take the current window,
    split it horizontally or vertically as many times as desired. Each pane layout
    can be saved for later use.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 定期使用面板可以在在不同网络之间来回移动时节省大量时间。不得不穿越3个网络来更改参数，然后再返回查看更改是浪费时间的。面板将当前窗口水平或垂直分割多次。每个面板布局都可以保存以供以后使用。
- en: '![](panes-1.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](panes-1.png)'
- en: The diagram above highlights the pane presets that are available by default.
    The presets provide quick access to a few standard configurations of panes including
    split left and right, split top and bottom, a 3 pane setup, and a 4 pane setup.
    Saving pane presets is as easy as clicking the 'Add New Layout +' button, entering
    a name, and clicking 'Ok'. Saving a layout not only saves the size and position
    of the panes, but also saves each pane's type.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上图突出显示了默认可用的面板预设。这些预设提供了对几种标准面板配置的快速访问，包括左右分割，上下分割，3个面板设置和4个面板设置。保存面板预设就像点击'添加新布局+'按钮，输入名称，然后点击'确定'一样简单。保存布局不仅保存了面板的大小和位置，还保存了每个面板的类型。
- en: Panes are able to display unique types of content, whether they are other dialogs,
    Networks, or viewers. Being able to mix and match combinations of viewers and
    Network editors allows for a lot of flexibility. In the diagram below, the top
    left pane is a Network editor. On the right-hand side, is a Textport, and on the
    bottom-left, there is a Geometry Viewer. Again, saving this layout would not only
    save the pane arrangement, but also the pane types. This is useful when working
    on a project with a lot of different elements, where jumping between something
    like the setup above, and a simple Network editor, can save quite a bit of time
    in the long run.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 窗格能够显示各种独特类型的内容，无论是其他对话框、网络还是查看器。能够混合和匹配查看器和网络编辑器的组合允许有很大的灵活性。在下面的图表中，左上角的窗格是网络编辑器。右侧是文本端口，左下方是几何查看器。再次保存此布局不仅会保存窗格排列，还会保存窗格类型。在处理具有许多不同元素的项目时，跳转到上述设置和简单的网络编辑器之间可以在长期内节省���当多的时间。
- en: '![](panes-2.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](panes-2.png)'
- en: 'The keyboard shortcuts for working with panes are as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与窗格一起工作的键盘快捷键如下：
- en: 'Alt + [ : Vertically split current pane under mouse'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alt + [：在鼠标下垂直拆分当前窗格
- en: 'Alt + ] : Horizontally split current pane under mouse'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alt + ]：在鼠标下水平拆分当前窗格
- en: 'Alt + Z : close pane under mouse'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alt + Z：关闭鼠标下的窗格
- en: Palette Browser
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调色板浏览器
- en: '*2.6 Palette Browser*'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.6 调色板浏览器*'
- en: The Palette Browser can be thought of as a component library. The Palette Browser
    holds '.tox' files (or TouchDesigner Component files). These files contain a single
    Component Operator, that can hold a Network of other Operators. This means that
    a series of frequently used Operators, UI components, Python scripts, and more,
    can be created inside of a single Component Operator, saved as a '.tox' file,
    and quickly accessed at any time in the future.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 调色板浏览器可以被视为组件库。调色板浏览器保存'.tox'文件（或TouchDesigner组件文件）。这些文件包含一个单一的组件运算符，可以包含其他运算符的网络。这意味着一系列经常使用的运算符、UI组件、Python脚本等可以在单个组件运算符内创建，保存为'.tox'文件，并在将来任何时候快速访问。
- en: Open the Palette Browser, and look through the large number of pre-existing
    '.tox' files that are available. Blank projects start with the Palette Browser
    open by default, and docked to the left side of the window. To open the Palette
    Browser as a floating window, use the keyboard command 'Alt + L'. Let's try one
    of the pre-built components.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 打开调色板浏览器，并查看大量可用的预先存在的'.tox'文件。空白项目默认情况下以调色板浏览器打开，并停靠在窗口的左侧。要将调色板浏览器打开为浮动窗口，请使用键盘命令'Alt
    + L'。让我们尝试一个预构建的组件。
- en: Under the 'Derivative' section, navigate to 'Tools', and then finally drag and
    drop the 'Blend' component into a new project. Looking at the 'Blend' component's
    UI, it is clear that there is quite a bit going on inside. Before diving deeper,
    take a moment to connect two inputs and try the 'Blend' component. Activate the
    viewer, click on the button underneath the image to select a blend mode, and then
    drag the semi-transparent handle across the image to blend between the inputs.
    This is a useful tool, and all it took was a simple drag and drop from the Palette
    Browser!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在'Derivative'部分下，导航到'Tools'，最后将'Blend'组件拖放到新项目中。查看'Blend'组件的用户界面，很明显里面有很多内容。在深入之前，花点时间连接两个输入并尝试'Blend'组件。激活查看器，单击图像下方的按钮选择混合模式，然后拖动半透明手柄在图像之间混合输入。这是一个有用的工具，只需从调色板浏览器简单拖放即可！
- en: One of the goals of this book is to create some tools that can be added to the
    Palette Browser, so that they may be used regularly. There are two ways to add
    a component to the Palette Browser. The first is a drag and drop method. To do
    so, select 'My Components' from the top portion of the browser. Then drag any
    component from the Network and drop it into the lower portion of the Palette Browser.
    It will then be added to 'My Components' repository. The second method of adding
    a component is to drag a saved '.tox' file from Windows Explorer, and drop it
    in the same region mentioned above. The diagram below illustrates exactly where
    components should be dropped.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一个目标是创建一些可以添加到调色板浏览器中的工具，以便可以定期使用它们。有两种方法可以将组件添加到调色板浏览器中。第一种是拖放方法。要这样做，请从浏览器的顶部部分选择'My
    Components'。然后将网络中的任何组件拖放到调色板浏览器的下部分。然后它将被添加到'My Components'存储库中。添加组件的第二种方法是从Windows资源管理器中拖动保存的'.tox'文件，然后将其放在上述相同区域中。下面的图表清楚地说明了组件应该放置的位置。
- en: '![](palette-1.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](palette-1.png)'
- en: Search Dialog
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索对话框
- en: '*2.7 Search Dialog*'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.7 搜索对话框*'
- en: The 'Search Dialog' is incredibly helpful as projects become more complicated,
    and riddled with Python scripts and nested Networks. The 'Search Dialog' can find
    a multitude of things in a multitude of places, and searches can be as broad,
    or specific, as needed. It is accessible in the 'Edit' menu at the top of the
    screen, or by pressing 'F3' on the keyboard.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '''搜索对话框''在项目变得更加复杂，并且充斥着Python脚本和嵌套网络时非常有帮助。''搜索对话框''可以在多个地方找到多种东西，搜索可以根据需要进行广泛或具体的搜索。它可以在屏幕顶部的''编辑''菜单中访问，或者通过键盘上的''F3''键进行访问。'
- en: 'The ''Basic'' search can not only find Operators, but can search through Python
    code. Frequently, Python is used to change Operator parameter values. Sometimes,
    in the thick of Python scripts, it is easy to lose track of specific lines of
    code. A quick search for the code below will return a list of every single line
    of code that involves changing parameters of the Operators with ''transform''
    in their name:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '''基本''搜索不仅可以找到运算符，还可以搜索Python代码。经常使用Python来更改运算符参数值。有时，在Python脚本的深处，很容易迷失特定的代码行。快速搜索下面的代码将返回涉及更改具有名称中带有''transform''的运算符参数的每一行代码的列表：'
- en: '`op(''transform'').par`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`op(''transform'').par`'
- en: Sifting through the results is much easier than manually looking through Networks
    full of code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览结果比手动查看充满代码的网络要容易得多。
- en: The 'Advanced' search can search by any combination of name, Operator type,
    comments, flags, and more. When returning to past projects, often it takes some
    time to relocate and reacclimatize to the inner workings of complex logic systems.
    This is when searching for operators by vague name and type can save a ton of
    time. For example, in an extremely nested system, somewhere in the depths of it
    might be a Movie In TOP that has the word 'movie' in its name. These little pieces
    of information about the Operator type, and partial name, can be used to create
    a fairly precise search.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '''高级''搜索可以按任何组合的名称、操作类型、注释、标志等进行搜索。当返回到过去的项目时，通常需要一些时间来重新定位和重新适应复杂逻辑系统的内部运作。这就是在通过模糊名称和类型搜索运算符时可以节省大量时间的时候。例如，在一个极其嵌套的系统中，可能会有一个在其名称中包含''电影''一词的Movie
    In TOP。关于运算符类型和部分名称的这些小信息可以用来创建一个相当精确的搜索。'
- en: When a search has yielded results, each result can be clicked on to open the
    Network in a new floating pane. Here, the results can be can quickly previewed,
    and simple changes can be made within this pane, without affecting the current
    work area.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当搜索产生结果时，每个结果都可以点击以在新的浮动窗格中打开网络。在这里，结果可以快速预览，并且可以在此窗格内进行简单更改，而不会影响当前工作区。
- en: Realtime Flag
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时标志
- en: '*2.8 Realtime Flag*'
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.8 实时标志*'
- en: '![](realtime-1.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](realtime-1.png)'
- en: The Realtime flag changes TouchDesigner's behaviour significantly. When it is
    active (it is active by default), TouchDesigner will always prioritize real-world
    time. In a simple example, if a movie file is 30 seconds long, no matter what
    happens, TouchDesigner will try to play it over the course of 30 seconds. If this
    means that frames need to be dropped, TouchDesigner will try to honour time. This
    is the mode used for most real-time installation and performance work.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 实时标志会显著改变TouchDesigner的行为。当它激活时（默认情况下是激活的），TouchDesigner将始终优先考虑真实世界的时间。举个简单的例子，如果一个电影文件长达30秒，无论发生什么，TouchDesigner都会尝试在30秒内播放它。如果这意味着需要丢帧，TouchDesigner会尽量遵守时间。这是用于大多数实时安装和表演工作的模式。
- en: When the Realtime flag is off, TouchDesigner will prioritize frame rendering
    over real-world time. In the example mentioned above, if Realtime is off, TouchDesigner
    would take as long as it needed to process and render each frame, falling out
    of real-world time to display every frame. This mode is useful when exporting
    complex animations or 3D renderings. Imagine this mode to be similar to a real-time
    version of rendering out of Adobe After Effects.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当实时标志关闭时，TouchDesigner将优先考虑帧渲染而不是真实世界的时间。在上面提到的例子中，如果实时关闭，TouchDesigner将花费所需的时间来处理和渲染每一帧，脱离真实世界的时间来显示每一帧。这种模式在导出复杂动画或3D渲染时非常有用。想象这种模式类似于从Adobe
    After Effects中实时渲染的版本。
- en: Useful Shortcuts
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的快捷键
- en: '*2.9 Useful Shortcuts*'
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.9 有用的快捷键*'
- en: 'Below is a bullet point list of some useful shortcuts:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些有用快捷键的项目符号列表：
- en: 'When hovering over the Network:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当悬停在网络上时：
- en: '''P'' - Opens and closes the selected Operator''s Parameter window'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''P'' - 打开和关闭所选运算符的参数窗口'
- en: '''O'' - Opens and closes a visual overview of the Network in the bottom-left
    corner of the pane'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''O'' - 打开和关闭窗格左下角的网络可视化概览'
- en: '''C'' - Opens and closes the Colour Palette. This can add a coloured outline
    to the selected Operators for easier identification'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''C'' - 打开和关闭颜色调色板。这可以为选定的操作器添加彩色轮廓，以便更容易识别'
- en: 'With an Operator(s) selected:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个或多个操作器时：
- en: '''A'' - Allows interaction with the Operator''s viewer'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''A'' - 允许与操作器的查看器进行交互'
- en: '''B'' - Bypass and un-bypass the selected Operator'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''B'' - 绕过选定的操作器'
- en: '''H'' - Performs the ''Home All'' action on the Network, which is the equivalent
    to fitting all Operators of a Network onto the screen'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''H'' - 对网络执行“Home All”操作，这相当于将网络中的所有操作器适配到屏幕上'
- en: '''Shift + H'' - Performs the ''Home Selected'' action which fits all the selected
    Operators onto the screen'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''Shift + H'' - 执行''Home Selected''动作，将所有选择的操作器适配到屏幕上'
- en: '''R'' - Toggles the Operator''s Render Flag (if it has one)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''R'' - 切换操作器的渲染标志（如果有的话）'
- en: '''D'' - Toggles the Operator''s Display Flag (if it has one)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''D'' - 切换操作器的显示标志（如果有的话）'
- en: '''Control + C'' - Copy selected Operators'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''Control + C'' - 复制选择的操作器'
- en: '''Control + V'' - Paste copied Operators'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''Control + V'' - 粘贴复制的操作器'
- en: '''Control + Shift + V'' - Paste copied Operators at the mouse'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''Control + Shift + V'' - 在鼠标位置粘贴复制的操作器'
- en: Introduction
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 3 TOPs
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3个TOPs
- en: '*3.1 Introduction*'
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*3.1 介绍*'
- en: Texture Operators, or TOPs, are a fundamental aspect of almost every project.
    They are the 2D texture Operators that handle everything from movie playback,
    3D geometry rendering, compositing, hardware video inputs and outputs, and are
    used to process everything that will be output to a monitor, projector, or LED
    display.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理操作器，或称为TOPs，是几乎每个项目中的基本组成部分。它们是处理从影片播放、3D几何渲染、合成、硬件视频输入和输出的2D纹理操作器，并用于处理将输出到显示器、投影仪或LED显示器的所有内容。
- en: Movie In TOP
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Movie In TOP
- en: '*3.2 Movie In TOP*'
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*3.2 Movie In TOP*'
- en: 'The Movie In TOP is one of the most used TOPs. It''s function is to load assets
    into TouchDesigner. It is capable of loading many different types of assets, ranging
    from still images to a variety of movie codecs. Below is a small list of common
    file formats used with the Movie In TOP:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Movie In TOP 是最常用的TOP之一。它的功能是将资产加载到 TouchDesigner 中。它能够加载许多不同类型的资产，从静止图像到各种电影编解码器。以下是与
    Movie In TOP 一起使用的常见文件格式的小列表：
- en: .mov
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .mov
- en: .mp4
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .mp4
- en: .avi
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .avi
- en: .tiff
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .tiff
- en: .jpeg
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .jpeg
- en: .png
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .png
- en: There are many more supported file formats, which are listed on the Derivative
    TouchDesigner 088 wiki under the 'File Types' page.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多支持的文件格式，在Derivative TouchDesigner 088维基的“文件类型”页面中列出。
- en: There are a few of great features built into the Movie In TOP that can significantly
    reduce the headaches involved with quickly ingesting and outputting assets with
    different frame-rates. The main feature is that the Movie In TOP's goal is to
    playback assets while staying true to its time duration. For example, if the project
    is set to 60FPS and an asset is made at 30FPS and is 10 seconds long, it will
    play over the course of 10 seconds, regardless of FPS differences between the
    project and the asset. The opposite is true as well. If a 10 second asset created
    at 60 FPS is played in a 30FPS timeline, it will play over the course of 10 seconds.
    In both of these cases frames are either doubled or discarded to stay true to
    each asset's real-world time length. This makes interpolation of frames a good
    idea in some situations.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Movie In TOP 内置了一些很棒的功能，可以极大地减少快速摄入和输出具有不同帧速率的资产所涉及的问题。其主要功能是，Movie In TOP 的目标是在保持其时间持续性的同时播放资产。例如，如果项目设置为60FPS，而一个以30FPS制作的资产长达10秒，那么它将在10秒内播放，而不考虑项目和资产之间的FPS差异。反之亦然。如果在30FPS时间轴中播放以60
    FPS创建的10秒资产，则会在10秒内播放。在这两种情况下，帧数要么翻倍，要么丢弃，以保持每个资产的真实时间长度。这在某些情况下使帧的插值成为一个好主意。
- en: Preloading Movies
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预加载影片
- en: '*3.3 Preloading Movies*'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*3.3 预加载影片*'
- en: When creating real-time applications, continuous dropped frames can greatly
    detract from presentation and impact. Diagnosing performance issues is something
    that will be discussed in a later chapter, but many preventative measures can
    be taken. Preloading and unloading Movie In TOPs is one of these preventative
    measures. The simple procedure of preloading and unloading movies is often overlooked
    by new users because the easiest methods involve scripting.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建实时应用程序时，连续丢帧会严重影响展示效果和影响。诊断性能问题将在后面的章节中讨论，但可以采取许多预防措施。预加载和卸载电影播放器是其中之一。新用户通常忽略了预加载和卸载电影的简单程序，因为最简单的方法涉及脚本编写。
- en: 'Open example ''Preloading.toe''. This example has a set of three buttons. The
    ''Preload'' button uses the following Python function to preload the number of
    frames set in the ''Pre-Read frames'' parameter in the ''Tune'' parameters of
    the Operator ''moviein1'':'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例'Preloading.toe'。此示例有一组三个按钮。'Preload'按钮使用以下Python函数预加载在'电影播放器'操作符的'Tune'参数中设置的'Pre-Read
    frames'参数中设置的帧数：
- en: '`op(''moviein1'').preload()`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`op(''moviein1'').preload()`'
- en: 'The ''Play'' button starts playback of the Movie In TOP. The ''Unload'' button
    stops ''moviein1'' playback, and then unloads the movie, freeing up whatever system
    resources were being used. This is done with the following Python script:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '''Play''按钮开始播放Movie In TOP。''Unload''按钮停止''moviein1''的播放，然后卸载电影，释放正在使用的任何系统资源。下面是使用以下Python脚本完成的：'
- en: '`op(''play'').click(0)`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`op(''play'').click(0)`'
- en: '`op(''moviein1'').unload()`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`op(''moviein1'').unload()`'
- en: It is best practice to preload movies before playing them, otherwise there is
    a high risk of dropping frames upon playback.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是在播放电影之前预加载电影，否则有很高的丢帧风险。
- en: Null TOPs and Select TOPs
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空的TOP和选择的TOP
- en: '*3.4 Null TOPs and Select TOPs*'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*3.4 空TOP和选择TOP*'
- en: In contrast to expensive TOPs, like the Blur TOP, some TOPs are 'free', and
    should be used generously! Two specific examples are Null TOPs and Select TOPs.
    These two Operators, although they don't alter any pixel, are incredibly helpful
    in creating more efficient workflows.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与昂贵的TOP（如模糊TOP）相比，一些TOP是'免费'的，并且应该慷慨地使用！两个具体的例子是空TOP和选择TOP。尽管这两个操作符不会改变任何像素，但它们在创建更有效的工作流程方面非常有帮助。
- en: The difference between an illegible network, with wires overlapping and sprawled
    everywhere, and an easily followable Network are some properly placed Null TOPs
    and Select TOPs. Open examples 'Null_1.toe' and 'Null_2.toe'. The first file is
    a mish-mash of TOPs which are composited together. In this file, there is little
    regard for the layout of the Network, and the wires are overlapped by other Operators
    and other wires, making it difficult to trace any particular series of Operators.
    In 'Null_2.toe' a column of Null TOPs are laid out to gather all the signals before
    they are composited. This column of Null TOPs can serve as a checkpoint, and even
    at quick glance, makes it much easier to follow series of operations.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无法辨认的网络，其中电线重叠且随处可见，与一个易于跟踪的网络之间的区别在于，一些适当放置的空TOP和选择的TOP。打开示例'Null_1.toe'和'Null_2.toe'。第一个文件是一堆在一起的TOP，它们被合成在一起。在这个文件中，对网络布局几乎没有考虑，电线被其他操作符和其他电线覆盖，使得难以追踪任何特定的一系列操作符。在'Null_2.toe'中，一列空TOP被布置在一起，以在它们被合成之前收集所有信号。这一列空TOP可以作为一个检查点，在快速浏览时，使得更容易跟踪一系列操作。
- en: The same case can be made for Select TOPs. When working with nested Networks,
    using the Out TOP and pulling connections between containers can lead to the same
    situation as above, where Networks become illegible rather quickly. The Select
    TOPs can quickly and neatly reference other TOPs. Open example 'Select_1.toe'.
    This examples demonstrates how using In TOPs and Out TOPs can lead to extra clutter.
    This example is only replicating the movie 12 times! What would happen if there
    needed to be 100 of them? This is where the Select TOP comes in handy.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的情况也适用于选择TOP。当使用嵌套网络时，使用Out TOP并在容器之间拉取连接会导致与上述情况相同的情况，其中网络变得非常难以辨认。选择的TOP可以快速而整洁地引用其他TOP。打开示例'Select_1.toe'。这个示例演示了如何使用In
    TOP和Out TOP会导致额外的混乱。这个示例只是复制了电影12次！如果需要100次呢？这就是选择的TOP派上用场的地方。
- en: Open example 'Select_2.toe'. This example exponentially increases the amount
    of replicated components while being simultaneously more legible. Even more interesting
    is the dynamic selection system created using the Select TOPs. This is much more
    efficient than the manual method from before, and allows a Python script in the
    Select TOP's 'Select' parameter to automatically reference the corresponding replicated
    TOPs from the Network above, based on the digits in their names. To take this
    concept one step further, a Select DAT is used to drive a Replicator COMP that
    creates a new Select TOP, and automatically wires it to the Composite TOP every
    time a new item is added with the first Replicator COMP. Don't worry if this example
    seems daunting, Replicators and Scripting will be covered in later examples. For
    now, the important thing to note is that by using Select TOPs and very simple
    scripting, this component is relatively future-proof and won't require much maintenance.
    When it comes time to replicate more items, it's as easy as adding a row to a
    table.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例'Select_2.toe'。这个示例在同时更易读的情况下指数增加了复制的组件数量。更有趣的是使用Select TOPs创建的动态选择系统。这比以前的手动方法要高效得多，并且允许Select
    TOP的“Select”参数中的Python脚本自动引用上面网络中基于其名称中的数字的相应复制TOPs。为了进一步发展这个概念，使用Select DAT来驱动一个Replicator
    COMP，创建一个新的Select TOP，并在每次使用第一个Replicator COMP添加新项目时自动将其连接到Composite TOP。如果这个示例看起来令人生畏，不要担心，复制器和脚本将在后续示例中介绍。目前，需要注意的重要事情是，通过使用Select
    TOPs和非常简单的脚本，这个组件相对具有未来性，并且不需要太多维护。当需要复制更多项目时，只需向表中添加一行即可。
- en: Codecs
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编解码器
- en: '*3.5 Codecs*'
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*3.5 编解码器*'
- en: Movie playback is a taxing process. It is wise to spend time experimenting with
    different codecs to see which one suits a project in terms of visual quality and
    performance.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 电影播放是一个繁重的过程。花时间尝试不同的编解码器，看哪一个在视觉质量和性能方面适合项目是明智的。
- en: Before diving into specific codecs, it is important to know the difference between
    a codec and a container. Codec has taken over as the general term for the file
    format of audio-video files, which is confusing for beginners, because many containers
    can hold multiple codecs.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解特定编解码器之前，了解编解码器和容器之间的区别是很重要的。编解码器已经成为音视频文件的文件格式的通用术语，这对初学者来说很令人困惑，因为许多容器可以容纳多个编解码器。
- en: Codec stands for compressor-decompressor. The codec has two main tasks. The
    first is to compress video data for storage and transportation, and the second
    is to decompress the video data for playback. Because of these different tasks,
    each codec is made for a different purpose. Some prioritize compression for light
    weight, portable files, while others prioritize quality, for long-term preservation
    of content. Different projects will have different requirements. Sometimes, the
    goal is to play back a single piece of content at the highest quality possible,
    whereas other times, quality must be sacrificed to be able to playback multiple
    video files simultaneously. Finding the right codec for each project may require
    a few tests and some forethought, but it is time well spent.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 编解码器代表压缩-解压缩。编解码器有两个主要任务。第一个是为存储和传输压缩视频数据，第二个是为播放解压缩视频数据。由于这些不同的任务，每个编解码器都是为不同的目的而制作的。有些优先考虑轻便便携文件的压缩，而其他一些则优先考虑质量，以便长期保存内容。不同的项目将有不同的要求。有时，目标是以最高质量播放单个内容，而其他时候，必须牺牲质量以能够同时播放多个视频文件。为每个项目找到合适的编解码器可能需要一些测试和一些事先考虑，但这是值得花时间的。
- en: A container does exactly what its name implies. It holds the compressed video,
    audio, and all the metadata a movie player needs to properly decompress and playback
    the content. There are quite a few different containers, but they have much less
    of an impact on the overall programming workflow, compared to codecs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 容器确实做了其名称所暗示的事情。它保存了压缩的视频、音频以及电影播放器需要正确解压缩和播放内容的所有元数据。有许多不同的容器，但与编解码器相比，它们对整体编程工作流程的影响要小得多。
- en: Things can get complicated when different combinations of containers and codecs
    are used. Imagine a file named 'test_movie.mov'. In one example, this file could
    be an Animation codec compressed video file inside of a '.mov' QuickTime container.
    What's interesting, and what also confuses many beginners, is that in another
    example, this file could be an H.264 compressed video file inside of a QuickTime
    container. To add to confusion, the same H.264 file could also be inside of a
    '.mp4', or MPEG-4 Part 14, container.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用不同的容器和编解码器的组合时，情况可能会变得复杂。想象一个名为'test_movie.mov'的文件。在一个示例中，这个文件可能是一个Animation编解码器压缩的视频文件，位于'.mov'
    QuickTime容器内。有趣的是，也令许多初学者困惑的是，在另一个示例中，这个文件可能是一个H.264压缩的视频文件，位于QuickTime容器内。增加了混淆的是，同一个H.264文件也可以位于'.mp4'或MPEG-4
    Part 14容器内。
- en: 'Confusion aside, some popular codec choices are currently the HAP family, H.264,
    Animation codec, and Cineform. Each codec has its own set of advantages and disadvantages.
    Below is a very quick point form list of some pros and cons to each:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 除了混乱外，一些流行的编解码器选择目前包括HAP系列、H.264、动画编解码器和Cineform。每种编解码器都有其自身的优缺点。以下是一份非常简要的每种编解码器的一些优缺点的列表：
- en: '**HAP family**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**HAP系列**'
- en: '*Pros*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: Can playback extremely high resolutions and high frame rates
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以播放极高分辨率和高帧率的视频
- en: Very little CPU cost
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU成本极低
- en: HAP Q is visually lossless
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HAP Q是视觉上无损的
- en: Very little GPU cost
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPU成本极低
- en: '*Cons*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: Large file sizes
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件大小大
- en: Difficult to batch encode files on Windows
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上批量编码文件困难
- en: Must use SSDs or a RAID0 of SSDs for file playback
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须使用SSD或SSD的RAID0来播放文件
- en: Main bottleneck is hard drive read speeds
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要瓶颈是硬盘读取速度
- en: '**H.264**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**H.264**'
- en: '*Pros*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: Creates extremely light-weight/low file size videos
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建极轻量级/低文件大小的视频
- en: Best bang for buck when comparing quality to file size
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在比较质量和文件大小时性价比最高
- en: Low disk usage
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低磁盘使用率
- en: '*Cons*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: Requires a large number of CPU cores to playback extremely high resolutions
    or high frame rate.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要大量CPU核心来播放极高分辨率或高帧率。
- en: Can experience colour quantization if proper care is not taken in encoding
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果编码时没有采取适当的措施，可能会出现颜色量化
- en: Bit rate is highly dependent on content
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特率高度依赖内容
- en: 4096 pixel size resolution in both length and width
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分辨率可以达到4096像素大小的长度和宽度
- en: Difficult to create alpha channels
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Alpha通道困难
- en: '**Animation Codec**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**动画编解码器**'
- en: '*Pros*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: 100% quality is a lossless file
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 100%质量是无损文件
- en: Prioritizes quality
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先考虑质量
- en: Has native support for Alpha channel
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有本地支持Alpha通道
- en: '*Cons*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: Large file sizes
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件大小大
- en: Demanding on both hard drives and CPU
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对硬盘和CPU都要求高
- en: Bit rate fluctuates with amount of detail in video content
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特率随视频内容中的细节数量而波动
- en: '**Cineform**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cineform**'
- en: '*Pros*'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: Constant bit rate
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恒定比特率
- en: High image quality
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高图像质量
- en: Native Alpha channel support
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地Alpha通道支持
- en: '*Cons*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: file sizes
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件大小
- en: Must purchase encoding software from Cineform
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须从Cineform购买编码软件
- en: Introduction
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 4 CHOPs
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 CHOPs
- en: '*4.1 Introduction*'
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*4.1介绍*'
- en: 'The Channel Operators, or CHOP, family of Operators handle all channel operations
    including motion data, audio inputs, key-frame animations, hardware inputs (from
    Microsoft Kinect, Leap Motion, Oculus Rift, pen tablets, keyboards, mice, etc),
    DMX, MIDI, and OSC. These are the Operators that handle inputs, processing, and
    outputs, of the data used to communicate with many types of audio-visual gear
    such as:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通道操作器或CHOP家族的操作器处理所有通道操作，包括动作数据、音频输入、关键帧动画、硬件输入（来自Microsoft Kinect、Leap Motion、Oculus
    Rift、笔式平板电脑、键盘、鼠标等）、DMX、MIDI和OSC。这些是处理与许多类型的音频视觉设备通信所使用的数据的输入、处理和输出的操作器，例如：
- en: Mixers
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混音器
- en: MIDI controllers
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MIDI控制器
- en: Synths
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合成
- en: DMX lighting fixtures
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DMX照明设备
- en: Microsoft Kinect cameras
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Kinect相机
- en: Computers running TouchDesigner
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行TouchDesigner的计算机
- en: Loudspeakers
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扬声器
- en: Other audio-video applications like Max/MSP, Ableton Live, Resolume Arena
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他音频视频应用程序，如Max/MSP、Ableton Live、Resolume Arena
- en: Communication Methods
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信方法
- en: '*4.2 Communication Methods*'
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*4.2通信方法*'
- en: 'MIDI works with an extensive amount of existing software and hardware. Digital
    Audio Workstations, or DAWs, like Ableton Live, Avid Pro Tools, Propellerhead
    Reason, and more, all support MIDI input and output. It is a relatively fast,
    stable, and time-tested protocol. Audio performance controllers often come equipped
    with MIDI over USB. These controllers include inputs hardware with controls such
    as: buttons, faders, piano keys, touch strips, jog wheels, drum pads, and potentiometers.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: MIDI与大量现有软件和硬件兼容。数字音频工作站（DAWs），如Ableton Live，Avid Pro Tools，Propellerhead Reason等，都支持MIDI输入和输出。这是一个相对快速，稳定且经过时间考验的协议。音频性能控制器通常配备有MIDI
    over USB。这些控制器包括具有控件的硬件输入，如：按钮，推子，钢琴键，触摸条，旋钮轮，鼓垫和电位器。
- en: Programming environments such as Cycling 74 Max/MSP, PureData, Native Instruments
    Reaktor, and more, have support for OSC messaging. OSC messaging has the benefit
    of modern networking technology, higher resolutions than MIDI, channel naming,
    and many structural improvements. OSC messaging can be sent over UDP or TCP connections,
    making it incredibly easy to network, and transmit long distances in real-time.
    Currently, OSC is more commonly used as a communication method between softwares
    and computer systems.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 编程环境，如Cycling 74 Max/MSP，PureData，Native Instruments Reaktor等，都支持OSC消息传递。OSC消息传递具有现代网络技术的优势，比MIDI具有更高的分辨率，通道命名和许多结构改进。OSC消息可以通过UDP或TCP连接发送，使其非常容易进行网络传输，并实时传输长距离。目前，OSC更常用作软件和计算机系统之间的通信方法。
- en: DMX is a protocol used by lighting fixtures and controllers. Many DMX fixtures
    have various channels for dimmers, various settings, built-in chases, RGB channels,
    motor automation, and more. Many lighting controllers and desks use DMX protocol
    to communicate with fixtures and video-computer systems. With the many types of
    controllers and desks available, their manuals will be invaluable when creating
    projects with them in mind. In general, all of a fixture's channels need to be
    accounted for, even if they aren't being actively used. There are many ways to
    optimize the workflow of sending and receiving DMX data, mostly concerning the
    management and organization of channels. These will be looked at in later examples.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: DMX是灯具和控制器使用的协议。许多DMX灯具具有各种通道，用于调光器，各种设置，内置追逐，RGB通道，电机自动化等。许多灯光控制器和控制台使用DMX协议与灯具和视频计算机系统进行通信。有许多类型的控制器和控制台可用，当考虑到它们时，它们的手册将是无价的。一般来说，即使未被积极使用，所有灯具的通道都需要考虑在内。有许多优化发送和接收DMX数据的工作流程的方法，主要涉及通道的管理和组织。这些将在后面的示例中进行讨论。
- en: Sync In CHOP and Sync Out CHOP are used to frame sync internal and external
    instances of TouchDesigner. They use the OSC protocol for their underlying communication.
    These two Operators work by communicating the state of each frame on every synced
    machine. Once all sync machines confirm that they have rendered the current frame,
    they simultaneously move to the next frame. This sequence of events is repeated
    for every frame and keeps the synced machines always on the same frame.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Sync In CHOP和Sync Out CHOP用于帧同步TouchDesigner的内部和外部实例。它们使用OSC协议进行底层通信。这两个操作符通过在每个同步机器上通信每帧的状态来工作。一旦所有同步机器确认已渲染当前帧，它们同时转移到下一帧。这一系列事件为每一帧重复进行，并始终使同步机器保持在同一帧上。
- en: Audio Inputs and Outputs
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频输入和输出
- en: '*4.3 Audio Inputs and Outputs*'
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*4.3 音频输入和输出*'
- en: Audio can be processed from a variety of sources, and can be processed in a
    variety of ways. TouchDesigner is capable of processing audio from audio files,
    movie files, external audio interfaces, internet audio streams, and can even synthesize
    audio from nothing.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 音频可以从各种来源处理，并且可以以各种方式处理。TouchDesigner能够处理来自音频文件，电影文件，外部音频接口，互联网音频流的音频，甚至可以从无中合成音频。
- en: Most projects involving sound design and audio tracks will include dedicated
    audio files. TouchDesigner is capable of reading and playing many standard audio
    formats such as MP3, AIFF, and WAV, through the use of the Audio File In CHOP
    and the Audio Play CHOP. These files can be looped, cued, re-pitched, and trimmed,
    allowing for flexible uses of samples and audio files.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数涉及声音设计和音轨的项目都将包含专用音频文件。TouchDesigner能够通过使用Audio File In CHOP和Audio Play CHOP读取和播放许多标准音频格式，如MP3，AIFF和WAV。这些文件可以循环播放，预备播放，重新调整音高和修剪，从而灵活使用样本和音频文件。
- en: The Audio Movie CHOP can be used to playback audio from a movie file. Instead
    of reading audio by referencing a file, this CHOP references a Movie In TOP. This
    is useful because it keeps the audio in sync with the video playing back in the
    Movie In TOP, and comes with a parameter that can be used to offset the audio
    to better match the video.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Audio Movie CHOP 可用于从电影文件播放音频。与通过引用文件读取音频不同，此 CHOP 引用一个 Movie In TOP。这很有用，因为它将音频与
    Movie In TOP 中播放的视频同步，并带有一个参数，可用于偏移音频以更好地匹配视频。
- en: There are many different external audio interfaces that can be used with TouchDesigner.
    It is best to refer to the Derivative TouchDesigner Wiki and Forum for a more
    comprehensive list of compatible devices.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的外部音频接口可与 TouchDesigner 一起使用。最好参考衍生 TouchDesigner Wiki 和论坛，以获取更全面的兼容设备列表。
- en: These devices provide analog and digital audio inputs and outputs. These can
    be inputs from musicians and instrumentalists, audio mixing consoles, professional
    video cameras, other computer systems, and much more. These devices can output
    audio to many of the above mentioned destinations, as well as to loud speaker
    systems. The CHOPs used to communicate with external interfaces are the Audio
    Device In CHOP and the Audio Device Out CHOP. Each respectively handles the inputs
    and outputs, to and from, a project. There is an Audio SDI CHOP which is used
    in conjunction with the nVidia Quadro SDI card, to receive audio from external
    SDI sources.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备提供模拟和数字音频输入和输出。这些可以是音乐家和乐器演奏者、音频混音控制台、专业视频摄像机、其他计算机系统等的输入。这些设备可以将音频输出到上述许多目的地，以及音响系统。用于与外部接口通信的
    CHOP 是 Audio Device In CHOP 和 Audio Device Out CHOP。它们分别处理项目中的输入和输出。有一个 Audio
    SDI CHOP 与 nVidia Quadro SDI 卡配合使用，用于从外部 SDI 源接收音频。
- en: There are two different audio drivers that can be accessed from within TouchDesigner.
    DirectSound has been available since previous versions of TouchDesigner, and has
    been developed as a part of DirectX. It is a mature driver, having been in development
    for many years, and provides relatively low latencies even under heavy use.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: TouchDesigner 内可以访问两种不同的音频驱动程序。DirectSound 从 TouchDesigner 的先前版本就已经可用，并作为 DirectX
    的一部分进行了开发。它是一个成熟的驱动程序，经过多年的开发，即使在重度使用下也能提供相对较低的延迟。
- en: ASIO is a new addition to TouchDesigner 088\. It has been developed by Steinberg
    to improve on one of DirectX's main drawbacks, which is that DirectX feeds all
    audio through the Windows operating system. Bypassing the operating system, the
    ASIO driver is able to communicate directly with external audio hardware, thus
    creating lower latencies than what was previously possible with DirectSound.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ASIO 是 TouchDesigner 088 的新功能。它由 Steinberg 开发，旨在改善 DirectX 的主要缺点之一，即 DirectX
    通过 Windows 操作系统传输所有音频。绕过操作系统，ASIO 驱动程序能够直接与外部音频硬件通信，从而创造出比以前通过 DirectSound 可能性更低的延迟。
- en: Once inputs and outputs are setup in TouchDesigner, they can be routed much
    like any other data.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在 TouchDesigner 中设置了输入和输出，它们可以像任何其他数据一样进行路由。
- en: Sample Rates
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采样率
- en: '*4.4 Sample Rates*'
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*4.4 采样率*'
- en: Many applications never expose the granular functions and operations that are
    happening behind the scenes. Because of this, many people aren't used to processing
    audio in a mathematical fashion. Audio is, at its core, numerical data being processed
    incredibly fast. Knowing this lays the groundwork for how to work with audio in
    TouchDesigner.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序从不暴露在幕后发生的细微功能和操作。因此，许多人不习惯以数学方式处理音频。音频在本质上是数值数据，正在快速处理。了解这一点为如何在 TouchDesigner
    中处理音频奠定了基础。
- en: 'Open up example ''Sample_rates_1.toe''. This example creates a very basic feature
    common in many audio applications: muting. This is achieved by using a Math CHOP
    to multiply the audio stream by the output value of a Button COMP, which is either
    0 or 1\. Like any other mathematical equation, a value, in this case each sample
    of audio, multiplied by 0 will always be 0\. Similarly, a value, or audio sample,
    multiplied by 1 will be returned unchanged. These two states produce on and off
    states for this audio example.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Sample_rates_1.toe'。这个示例创建了许多音频应用程序中常见的一个非常基本的功能：静音。这是通过使用 Math CHOP 将音频流乘以
    Button COMP 的输出值来实现的，该值为 0 或 1。像任何其他数学方程一样，乘以 0 的值，在这种情况下是每个音频样本，将始终为 0。同样，乘以
    1 的值，或音频样本，将被返回不变。这两种状态为此音频示例产生了打开和关闭状态。
- en: Let's take this example a step further by allowing the button to fade the audio
    in and out. Open example 'Sample_rates_2.toe'.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步将此示例进行扩展，使按钮能够使音频淡入淡出。打开示例 'Sample_rates_2.toe'。
- en: This example takes the previous example and adds two Operators. The first is
    the Filter CHOP which smoothens the input value. This creates a smooth ramp between
    the two states of the button. The second is a Resample CHOP.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例在之前的基础上添加了两个操作符。第一个是滤波器 CHOP，用于平滑输入值。这样可以在按钮的两个状态之间创建平滑的斜坡。第二个是重采样 CHOP。
- en: The sample rate of different Operators is something that is overlooked by many
    beginners, but is essential to having artifact-free audio. The Oscillator CHOP
    is being sampled 44,100 times a second, and the Filter CHOP is being sampled 60
    times a second. This discrepancy means that there will not be a 1:1 ratio between
    the samples of audio and the samples of the ramp when they are multiplied. More
    accurately, there will be a 735:1 ratio between samples of audio and samples of
    the ramp. This means when the two values are multiplied, the audio will step up
    or down in volume every 735 samples. Examine the diagram below, where the dotted
    blue line is a 1:1 ratio, and the dotted red line represents a 735:1 ratio.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 不同操作符的采样率是许多初学者忽视的内容，但对于无杂音的音频至关重要。振荡器 CHOP 每秒采样 44,100 次，而滤波器 CHOP 每秒采样 60
    次。这种差异意味着在将音频和斜坡的样本相乘时，它们之间不会有 1:1 的比例关系。更准确地说，音频样本和斜坡样本之间将有一个 735:1 的比率。这意味着当两个值相乘时，每隔
    735 个样本音频的音量就会上升或下降。请参考下面的图表，其中虚线蓝线是 1:1 的比例关系，虚线红线表示 735:1 的比率。
- en: '![](sample-rate.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](sample-rate.png)'
- en: Looking at the diagram above, there is a very distinct stepping that happens
    when the two channels that have different sample rates are multiplied. Many CHOPs
    use the project FPS as their default sample rate, causing the stepping to become
    exaggerated when the project is set to run at 30 FPS. Using the same example as
    above, the ratio of samples of audio and samples of the ramp would jump from 735:1
    to 1470:1\. This means in a 30 FPS project, there would only be an incremental
    volume change every 1470 samples!
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的图表可以看出，当具有不同采样率的两个通道相乘时，会出现非常明显的阶梯效应。许多 CHOP 默认使用项目的 FPS 作为它们的采样率，当项目设置为以
    30 FPS 运行时，这种阶梯效应会变得更加明显。以上述相同的示例为例，音频样本和斜坡样本之间的比率将从 735:1 跳变到 1470:1。这意味着在一个
    30 FPS 的项目中，每隔 1470 个样本才会有一个增量音量变化！
- en: The above examples highlight the need to always be aware of the sample rates
    of CHOPs in a project, and to use the Resample CHOP when necessary. Many times,
    this situation will occur in regards to audio, but there are instances where control
    data might need to be input or output at a different sample rate.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例突显了在项目中始终注意 CHOP 的采样率，并在必要时使用重采样 CHOP 的必要性。许多时候，这种情况会涉及到音频，但也有一些情况是控制数据可能需要以不同的采样率输入或输出。
- en: Time Slicing
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间切片
- en: '*4.5 Time Slicing*'
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*4.5 时间切片*'
- en: Time slicing is something that is unique to TouchDesigner, and can be a bit
    tricky to understand at first.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 时间切片是 TouchDesigner 独有的功能，一开始可能有点难以理解。
- en: A Time slice is the period between the last rendered frame and the current rendered
    frame. Think of Time slices as dynamic amounts of time. If a project is running
    at a consistent 60 FPS, then the time slices will be 1 frame in length. If a project
    is having trouble keeping up with real-time, and drops 10 frames, the corresponding
    time slice would be 10 frames in length.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 时间切片是最后一个渲染帧和当前渲染帧之间的时间段。将时间切片视为动态时间量。如果一个项目以一致的 60 FPS 运行，那么时间切片将为 1 帧长度。如果一个项目在实时运行时出现问题，并且丢失了
    10 帧，则相应的时间切片将为 10 帧长度。
- en: Time slicing exists to smoothen out CHOP data in situations where frames are
    dropped. To think about it simply, Time slicing is when CHOPs start taking the
    size of Time slices into account when cooking. Think of this as a kind of adaptive
    cooking, meaning that as the time slices grow in length, the CHOPs will compensate
    for the amount of frames lost, and cook the amount of frames necessary to produce
    smoother outputs. This is in contrast to CHOPs that aren't time sliced, that will
    cook their value at the last cooked frame, then jump to the value at the next
    cooked frame, no matter how many frames are dropped inbetween. Only CHOPs can
    take advantage of Time slicing.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 时间切片存在的目的是在帧被丢弃的情况下平滑CHOP数据。简单地说，时间切片是当CHOP开始考虑时间片的大小进行计算时的情况。可以将其视为一种自适应烹饪，这意味着随着时间片长度的增加，CHOP将补偿丢失的帧数，并烹饪产生更平滑输出所需的帧数。这与未进行时间切片的CHOP形成对比，后者将在上次烹饪的帧上烹饪其值，然后跳到下次烹饪的帧的值，无论中间丢失了多少帧。只有CHOP才能利用时间切片。
- en: Using the example above, when the timeline is running consistently at 30 FPS,
    every time slice is 1 frame in length. If there are two ramps going from 0 to
    1 over the course of one second (30 frames), both outputs would be smooth ramps.
    If, for some bizarre reason, only every tenth frame was cooked, there would be
    very different results. In the non-time sliced CHOP, the value would jump every
    time a frame is cooked, while the data between those cooked frames is lost. The
    Time sliced CHOP is aware that it is only being cooked every tenth frame, and
    will cook the frames inbetween to interpolate between the value of the last cooked
    frame, and the current cooked frame. This keeps the data smooth no matter what
    is going on.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上面的示例，当时间轴以恒定的30 FPS运行时，每个时间片的长度为1帧。如果有两个斜坡在一秒钟内从0到1（30帧）的过程中，那么两个输出都将是平滑的斜坡。如果由于某种奇怪的原因，只有每十帧烹饪一次，结果将会有很大不同。在未进行时间切片的CHOP中，每次烹饪一帧时值都会跳跃，而在这些烹饪帧之间的数据将丢失。时间切片的CHOP知道自己只有每十帧才会被烹饪，将在最后一个烹饪帧和当前烹饪帧之间进行插值。这样无论发生什么情况，数据都保持平滑。
- en: 'The diagram below illustrates the above example, where the dotted-blue line
    is a non-Time sliced CHOP, the dotted-red line is a Time sliced CHOP, and the
    vertical dotted-green lines represent a cooked frame:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了上述示例，其中虚线蓝色线是非时间切片的CHOP，虚线红色线是时间切片的CHOP，垂直虚线绿色线表示烹饪的帧：
- en: '![Time Slicing](Timeslice.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![时间切片](Timeslice.png)'
- en: Common CHOPs
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见CHOP
- en: '*4.6 Common Channel Operators*'
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*4.6 常见通道操作符*'
- en: This section is an introduction to some of the channel operators that are used
    in many situations. There is an example file that is included in the .zip folder.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了许多情况下使用的一些通道操作符。示例文件包含在.zip文件夹中。
- en: Generator CHOPs
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成器CHOP
- en: Constant
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 常数
- en: The Constant CHOP holds up to 40 unique constant values. The channel name is
    defined in text field on the left, and the value is defined with the number field
    slider on the right.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 常数CHOP最多可容纳40个独特的常数值。通道名称在左侧的文本字段中定义，值在右侧的数字字段滑块中定义。
- en: When a Constant CHOP is created, only 1 channel is active. If a channel is not
    active, its number field is greyed out. To activate a channel just give it a name,
    and the number field will light up as well as show up in the operator viewer.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 创建常数CHOP时，只有1个通道处于活动状态。如果通道未激活，则其数字字段将变灰。只需给通道命名即可激活通道，数字字段将亮起，并显示在操作器查看器中。
- en: 'To create multiple channels with the same value, you can name the channels
    using pattern matching. If you enter `chan[1-4]` in the name field, 4 channels
    will be created: `chan1`, `chan2`, `chan3`, and `chan4`. These channels will all
    have the same value.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建具有相同值的多个通道，可以使用模式匹配来命名通道。如果在名称字段中输入`chan[1-4]`，将创建4个通道：`chan1`、`chan2`、`chan3`和`chan4`。这些通道都将具有相同的值。
- en: Noise
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 噪声
- en: This CHOP generates a set of pseudo-random points according to the settings
    in the operators Parameters. There are 6 different algorithms to choose from,
    each with different characteristics and may suit some situations better than the
    others. The basis for each algorithm is the `seed` value. You can have 2 Noise
    CHOPs with the same values, and the noise would look the same, but if you change
    the seed, it will generate a set of points based on the new seed number, creating
    a different result. *(ex.1 of noise.toe)*
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 此CHOP根据操作器参数中的设置生成一组伪随机点。有6种不同的算法可供选择，每种算法具有不同的特征，可能比其他情况更适合。每个算法的基础是`seed`值。您可以有2个具有相同值的Noise
    CHOPs，噪声看起来相同，但如果您更改seed，它将基于新的seed数字生成一组点，从而产生不同的结果。(*noise.toe*的示例1)
- en: To create movement, you can change values on the `Transform` page. If you enter
    `absTime.frame` to the first `Translate` field, you can see that the noise begins
    to scroll along the x-axis. (ex. 2 of *noise.toe*)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建运动，您可以在`Transform`页面上更改值。如果您将`absTime.frame`输入到第一个`Translate`字段中，您会看到噪声开始沿着x轴滚动。（*noise.toe*的示例2）
- en: To create multiple channels of noise, go to the `Channel` page of the Parameters,
    and in the `Channel Names` field, enter the names of the channels separated by
    a space. *(ex.3 of noise.toe)*
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建多个通道的噪声，请转到参数的`Channel`页面，并在`Channel Names`字段中输入以空格分隔的通道名称。(*noise.toe*的示例3)
- en: The number of samples you would like to generate is determined by the settings
    on the `Channel` page, with the `Start`, `End`, and `Sample Rate`. The amount
    of time multiplied by the sample rate. But if you only need 1 sample at a time,
    you can go to the `Common` page, and turn the `Time Slice` toggle to `On`. This
    creates 1 random value per channel for each frame, which requires less CPU usage.
    *(ex.4 of noise.toe)*
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要生成的样本数量由`Channel`页面上的设置确定，包括`Start`、`End`和`Sample Rate`。时间乘以采样率。但如果您一次只需要1个样本，您可以转到`Common`页面，并将`Time
    Slice`切换打开。这会为每帧的每个通道创建1个随机值，从而减少CPU使用量。(*noise.toe*的示例4)
- en: Pattern
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模式
- en: The Pattern CHOP generates a function that is a set amount, or array, of samples.
    The size of the array is set by `Length` on the `Pattern` parameter page, and
    the type of function is chosen by `Type`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Pattern CHOP生成一个函数，即一组样本或数组。数组的大小由`Pattern`参数页面上的`Length`设置，函数类型由`Type`选择。
- en: '`Cycles` is the amount of times the function loops within the amount of samples.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cycles`是函数在样本数量内循环的次数。'
- en: There are settings to control your pattern, depending on what `Type` you have
    chosen.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您选择的`Type`，有设置来控制您的模式。
- en: '`From Range` and `To Range` are very useful for something like a sine wave
    that creates a `-1` to `1` value, but you need a `0` to `1` value. (There''s more
    on this later, in the Math CHOP section). *(ex.3 in pattern.toe)*'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`From Range`和`To Range`对于像创建`-1`到`1`值的正弦波这样的情况非常有用，但您需要`0`到`1`值。（稍后在Math CHOP部分中会详细介绍）。(*pattern.toe*的示例3)'
- en: This is a great tool for creating lookup tables. *(ex.4 in pattern.toe)*
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个创建查找表的好工具。(*pattern.toe*的示例4)
- en: LFO
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: LFO
- en: The LFO CHOP generates an oscillating value according to the parameter settings.
    It goes back and forth between 2 values that are determined by `Amplitude` and
    `Offset`, over a given time, or `Frequency`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: LFO CHOP根据参数设置生成振荡值。它在给定时间或`Frequency`内在`Amplitude`和`Offset`确定的2个值之间来回摆动。
- en: '`Frequency` generally determines how many cycles per second, except when a
    value is connected to the first input for `Octave Control`. If the `Octave Control`
    value is set to `1`, the speed is doubled, and if the value is set to `2`, the
    speed is doubled 2 (4x), etc. *(ex.2 of noise.toe)*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frequency`通常确定每秒循环的次数，除非将值连接到`Octave Control`的第一个输入。如果`Octave Control`值设置为`1`，速度加倍，如果值设置为`2`，速度加倍2（4倍），依此类推。(*noise.toe*的示例2)'
- en: The shape of the oscillation is controlled by `Type`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 振荡的形状由`Type`控制。
- en: You can also oscillate using a different oscillation pattern by using the 3rd
    input. *(ex.3 of lfo.toe)*
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用第3个输入使用不同的振荡模式进行振荡。(*lfo.toe*的示例3)
- en: Timer
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 计时器
- en: This CHOP is very useful for anything that involves fixed time periods. You
    can trigger the timer and recieve different types of data throughout its duration,
    as well as set it do act different ways when it ends.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 此CHOP对涉及固定时间段的任何事物非常有用。您可以触发计时器，并在其持续时间内接收不同类型的数据，以及在结束时设置其以不同方式运行。
- en: The timer can run once and stop at the end, run once and reset itself, repeat
    itself a certain amount of times, or indefinitely.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器可以运行一次并在结束时停止，运行一次并重置自身，重复某个特定次数或无限期重复。
- en: Use the `Timer` parameter to set the length of the timer, and trigger it to
    start or reset. You can use `Delay` to set an amount of time to wait after the
    `Start` button was triggered, to actually start the timer.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Timer`参数设置计时器的长度，并触发它开始或重置。您可以使用`Delay`在触发`Start`按钮后设置一段时间等待，以实际启动计时器。
- en: '`Cue Point` sets a point during the timer that you can jump to by triggering
    the `Cue` pulse. If you''d like to be able to jump to a point that is half way
    through the duration of the timer, set `Cue Point` to `0.5`.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cue Point`在计时器期间设置一个点，您可以通过触发`Cue`脉冲跳转到该点。如果您想要能够跳转到计时器持续时间的一半处，将`Cue Point`设置为`0.5`。'
- en: 'On the `Outputs` parameter page, you can select what information you would
    like to recieve. Some common outputs are:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Outputs`参数页面上，您可以选择要接收的信息。一些常见的输出包括：
- en: '`Timer Fraction` displays the percentage of the set time period that has passed,
    in a 0 to 1 value. 0.5 would mean the timer is half done and 1 meaning the timer
    is finished.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Timer Fraction`显示已经过的设置时间段的百分比，以0到1的值表示。0.5意味着计时器完成一半，1意味着计时器已完成。'
- en: '`Done` is a value of `0` while the timer is initialized or running, and turns
    to `1` when the timer has finished. It will turn back to `0` once the `Init` or
    `Start` button is triggered again.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当计时器被初始化或运行时，`Done`的值为`0`，当计时器完成时，它会变为`1`。一旦再次触发`Init`或`Start`按钮，它将恢复为`0`。
- en: Filter CHOPs
  id: totrans-376
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Filter CHOPs`'
- en: Math
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数学
- en: 'This is probably the most commonly used CHOP. It takes data from its inputs
    and manipulates it in different ways :'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最常用的CHOP。它从其输入中获取数据并以不同的方式操纵它：
- en: The most intuitive use would be to take a value and perform some simple math,
    like add 10, or multiply the given value by 10\. This is done on the `Mult-Add`
    parameter page.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 最直观的用法是取一个值并执行一些简单的数学运算，比如加10，或者将给定的值乘以10。这是在`Mult-Add`参数页面上完成的。
- en: '![Order of Operations](math1.JPG "Order of Operations")'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![运算顺序](math1.JPG "运算顺序")'
- en: 'Commonly, we need to take a value, or set of values, and adjust them according
    to another value or set of values. For example, if our end desire is to have a
    value moving up and down over time, but we also want to add a random jitter, we
    could use a Pattern CHOP to create a SIN wave, a Noise CHOP to create a random
    set of numbers, and using the `OP` parameter page of a Math CHOP, we could set
    the `Combine CHOPs` drop-down menu to `Add`. The result could look something like
    this :'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要获取一个值或一组值，并根据另一个值或一组值进行调整。例如，如果我们最终想要的是随时间变化而上下移动的值，但我们还想添加随机抖动，我们可以使用Pattern
    CHOP创建一个SIN波，使用Noise CHOP创建一组随机数字，并在Math CHOP的`OP`参数页面上将`Combine CHOPs`下拉菜单设置为`Add`。结果可能是这样的：
- en: '![Combine Chops](math2.JPG "Combine Chops")'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![组合Chops](math2.JPG "组合Chops")'
- en: Another very useful function of the Math CHOP is the `Range` parameter page.
    This takes a range of values, and re-maps them to a new range. For example, if
    you have an LFO CHOP that ramps from 0 to 1, but you need that same movement to
    fit between the specific values of 7.9 and 51.4, it is much faster to use the
    `From Range` and `To Range` parameters than to adjust it using order of operations.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Math CHOP的另一个非常有用的功能是`Range`参数页面。这将一系列值重新映射到一个新的范围。例如，如果您有一个从0到1的LFO CHOP，但您需要相同的运动适合于7.9和51.4的特定值，那么使用`From
    Range`和`To Range`参数比使用运算顺序调整要快得多。
- en: '![Range](math3.JPG "Range")'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![范围](math3.JPG "范围")'
- en: Select
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选择
- en: This CHOP can be used to split up data that is contained in a single CHOP, or
    can be used to grab data from a remote section of a project. You can also rename
    channels that you are selecting at the same time.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`CHOP`可以用来分割包含在一个`CHOP`中的数据，或者可以用来从项目的远程部分获取数据。您还可以同时选择重命名通道。
- en: If you have a CHOP that contains several channels of information, and need to
    apply a process to 2 of the channels, but not all, a Select CHOP will allow you
    to name the channels that you want to focus on. Use the `Channel Names` field
    on the `Select` page of the parameters to list the channels you require, separated
    by a space.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个包含多个信息通道的`CHOP`，并且需要对其中的2个通道应用处理，而不是所有通道，`Select CHOP`将允许您命名您想要关注的通道。在参数的`Select`页面上使用`Channel
    Names`字段列出您需要的通道，用空格分隔。
- en: If you want to re-name these channels to something else, you can use the `Rename
    From` field to write the original channel names, and the `Rename To` field to
    enter the new names.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将这些通道重新命名为其他名称，你可以使用`重命名自`字段写入原始通道名称，并使用`重命名为`字段输入新名称。
- en: This CHOP also allows you to point to other CHOPs from different areas of a
    project. Lets say you have have data in a Constant CHOP that is nested inside
    2 other COMPs. TheConstant CHOPs path is `/project1/base1/base1/constant1`. But
    your project requires you to access this data in your `/project1` COMP. You could
    either make some `Out` CHOPs and manually wire the information, or use a Select
    CHOP to wireless point at the path of the constant CHOP, which usually quicker
    and keeps the network more organized. In the `CHOP` field of the `Select` parameter
    page, enter `project1/base1/base1/constant1`, and you will now see the data.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这个CHOP还允许你指向项目不同区域的其他CHOP。假设你的Constant CHOP中有数据，它嵌套在其他2个COMPs中。Constant CHOP的路径是`/project1/base1/base1/constant1`。但是你的项目要求你在你的`/project1`
    COMP中访问这些数据。你可以使用一些`Out` CHOP手动连接信息，或者使用Select CHOP无线指向常量CHOP的路径，这通常更快并且保持网络更有组织性。在`Select`参数页面的`CHOP`字段中输入`project1/base1/base1/constant1`，然后你现在会看到数据。
- en: As before, if there are several channels in the constant, and you only want
    to select 1, you can use the `Channel Names` field to select the one you need,
    and rename it as well.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，如果常量中有几个通道，而你只想选择一个，你可以使用`通道名称`字段来选择你需要的通道，并重命名它。
- en: Merge
  id: totrans-391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 合并
- en: The Merge CHOP is the opposite of the Select CHOP. It takes channels from multiple
    CHOPs and merges them into a single CHOP.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: Merge CHOP是Select CHOP的相反。它从多个CHOP中获取通道，并将它们合并到单个CHOP中。
- en: This is a straightforward idea, but if the results are different than what you
    expected, you will need to middle-mouse-click on the input CHOPs to see if the
    `Start/End` samples match.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的想法，但如果结果与你预期的不同，你需要中键单击输入的CHOPs，看看`起始/结束`样本是否匹配。
- en: '![Range](mmc1.JPG "Range") ![Range](mmc2.JPG "Range")'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![范围](mmc1.JPG "范围") ![范围](mmc2.JPG "范围")'
- en: In the CHOPs pictured above, both the Start samples and the End samples differ.
    This is dealt with by setting the Extend Conditions on the `Channel` parameter
    page of the Generator CHOPs that are being input, as well as the `Align` options
    on the `Merge` parameter page of the Merge CHOP.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的CHOP中，起始样本和结束样本都不同。这通过在被输入的Generator CHOP的`通道`参数页面上设置扩展条件以及在Merge CHOP的`Merge`参数页面上设置`Align`选项来处理。
- en: There is an explanation of the different Extend methods located on Extend CHOP
    wiki page, located [here](http://www.derivative.ca/wiki088/index.php?title=Extend_CHOP
    "Extend CHOP wiki page")
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 关于不同扩展方法的解释位于Extend CHOP维基页面上，位于[这里](http://www.derivative.ca/wiki088/index.php?title=Extend_CHOP
    "Extend CHOP维基页面")
- en: You can also open up the example project and experiment with the extend conditions
    and the different `Align` options.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以打开示例项目，尝试不同的扩展条件和不同的`Align`选项。
- en: Trail
  id: totrans-398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 轨迹
- en: The Trail CHOP creates a visual display of how the value of it's inputs have
    changed over a given time. This can be very useful when you need to see subtle
    differences of a channels movement, or how a channel's value changes compared
    to another.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Trail CHOP创建了一个可视化显示，显示了它的输入值在给定时间内的变化。当你需要看到通道运动的微妙差异，或者一个通道的值与另一个通道的值的变化时，这可能非常有用。
- en: '![Trail](trail.JPG "Trail")'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![轨迹](trail.JPG "轨迹")'
- en: Filter / Lag
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 过滤器 / 滞后
- en: Filter and Lag CHOPs create a smooth transition between values over a given
    time. The 2 CHOPs have similar purposes, but different options.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Filter和Lag CHOP在给定时间内创建值之间的平滑过渡。这两个CHOP具有类似的目的，但是不同的选项。
- en: Filter CHOP applies a smoothing effect or time, and you can choose the shape
    of the smoothing, with different options for different shapes.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Filter CHOP应用了平滑效果或时间，你可以选择平滑的形状，具有不同形状的不同选项。
- en: '![Filter Types](Filter.JPG "Filter Types")'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![滤波器类型](Filter.JPG "滤波器类型")'
- en: '*(see **/filter_lag/ example 1** of the example project file)*'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '*(参见示例项目文件中的**/filter_lag/ 示例 1**)*'
- en: Lag CHOP, depending on the method of smoothing, allows you to set 2 seperate
    effect-lengths for an increasing input value, and decreasing input value. *(see
    **/filter_lag/ example 2** of the example project file)*
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: Lag CHOP，根据平滑方法的不同，允许你为增加的输入值和减少的输入值设置2个单独的效果长度。*(参见示例项目文件中的**/filter_lag/ 示例
    2**)*
- en: Trigger
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 触发器
- en: This CHOP takes an event and creates an ADSR envelope (Attack, Decay, Sustain,
    and Release) with some additional control.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这个CHOP接收一个事件，并创建一个带有一些附加控制的ADSR包络（Attack、Decay、Sustain和Release）。
- en: 'The envelope can be triggered by the `Trigger Pulse` on the `Trigger` Parameter
    page, or by connecting a CHOP to its input, such as the Out of a Button. These
    are the different parts of the envelope:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `Trigger Parameter` 页面上的 `Trigger Pulse` 或将 CHOP 连接到其输入来触发包络，例如按钮的输出。以下是包络的不同部分：
- en: '![Filter Types](Trigger_ADSR_an.jpg "Filter Types")'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![Filter Types](Trigger_ADSR_an.jpg "Filter Types")'
- en: 'The different sections of the envelope can have easings as well. Here is an
    example of with the `Attack Shape` set to `Ease out`, `Decay Shape` set to `Ease
    in Ease out` and the `Release Shape` set to `Ease in`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 包络的不同部分也可以有缓动。这里是一个示例，`Attack Shape` 设置为 `Ease out`，`Decay Shape` 设置为 `Ease
    in Ease out`，`Release Shape` 设置为 `Ease in`：
- en: '![Filter Types](Trigger_ADSR_Ease.JPG "Filter Types")'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![Filter Types](Trigger_ADSR_Ease.JPG "Filter Types")'
- en: Introduction
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 5 DATs
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 个 DATs
- en: '*5.1 Introduction*'
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*5.1 介绍*'
- en: Data Operators, or DATs, perform operations on data. They can edit, parse, create,
    send, and receive data in various forms. These forms of data can range from text
    strings, tables, Python scripts, XML, JSON, MIDI, Serial, OSC, and much more.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Data Operators，或 DATs，对数据执行操作。它们可以编辑、解析、创建、发送和接收各种形式的数据。这些数据形式可以是文本字符串、表格、Python
    脚本、XML、JSON、MIDI、串口、OSC 等等。
- en: Logical systems rely heavily on the use of DATs and Python scripting. Being
    able to parse tables full of information and metadata, monitor other Operators
    and their states, perform complex tasks based on incoming messages from other
    systems, and more, make it possible to create rather complex systems in TouchDesigner.
    There will be a few simple logical systems in the examples portion of the book,
    as they are one of the things that makes TouchDesigner unique.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑系统在很大程度上依赖于 DATs 和 Python 脚本的使用。能够解析充满信息和元数据的表格，监视其他操作员及其状态，根据来自其他系统的消息执行复杂任务等，使得在
    TouchDesigner 中创建相当复杂的系统成为可能。在本书的示例部分将会有一些简单的逻辑系统，因为它们是使 TouchDesigner 独特的因素之一。
- en: An interesting way of thinking about TouchDesigner 088 is as a modular Python
    programming environment. Imagine taking intricate, and long, Python programs and
    functions, and breaking them into light-weight, and modular pieces. Think of the
    Text DAT as these pieces. This setup is easy to learn from, easy to maintain,
    easy to expand upon, and even more importantly, easy to share and work on collaboratively.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 将 TouchDesigner 088 看作是一个模块化的 Python 编程环境是一种有趣的思考方式。想象一下，将复杂且冗长的 Python 程序和函数拆分成轻量级和模块化的部分。把
    Text DAT 想象成这些部分。这种设置易于学习、易于维护、易于扩展，更重要的是，易于分享和共同合作。
- en: Communication Methods
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信方法
- en: '*5.2 Communication Methods*'
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*5.2 通信方法*'
- en: There are quite a few DATs that are capable of providing inputs and outputs
    over the many standard communication protocols. TouchDesigner is able to communicate
    natively over MIDI, OSC, TCP, UDP, UDT, and Websocket, giving it the ability to
    speak to many different types of programs, web applications and services, show
    control hardware, other computer systems, and etc.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多 DATs 能够在许多标准通信协议上提供输入和输出。TouchDesigner 能够原生支持 MIDI、OSC、TCP、UDP、UDT 和 Websocket
    进行通信，使其能够与许多不同类型的程序、Web 应用程序和服务、展示控制硬件、其他计算机系统等进行通信。
- en: MIDI, OSC, and DMX protocols were explained in the CHOP chapter. DATs can communicate
    over the same protocols, and quite a few more.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: CHOP 章节解释了 MIDI、OSC 和 DMX 协议。DATs 可以使用相同的协议进行通信，还有很多其他协议。
- en: TCP is the internet standard communication protocol. It is a connection oriented
    protocol, meaning there is a clear client-server relationship between the communicating
    parties, and a connection must be established (usually behind the scenes) before
    any data is transmitted. This relationship allows TCP connections to be reliable,
    in that the communicating parties can provide acknowledgment of all data sent
    and received, meaning no data ever gets lost. TCP is an ordered delivery stream,
    meaning data sent in a specific order, will be received in that same order.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 是互联网标准通信协议。它是一种面向连接的协议，意味着通信双方之间有明确的客户端-服务器关系，并且必须在传输任何数据之前建立连接（通常在幕后）。这种关系使得
    TCP 连接能够可靠，即通信双方可以确认所有发送和接收的数据，这意味着没有任何数据会丢失。TCP 是有序传递流，意味着以特定顺序发送的数据将以相同的顺序接收。
- en: UDP, on the contrary, is a connection-less protocol, in that no explicit connection
    is established prior to data transmission. This creates a level of unreliability
    in areas such as delivery acknowledgments, dropped packets, and order of messages.
    If none of these are crucial to a project, there are some performance gains in
    systems where dropped packets are less of an issue than delayed packets.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: UDP，相反，是一种无连接协议，在数据传输之前不建立明确的连接。这在交付确认、丢包和消息顺序等方面造成了一定程度的不可靠性。如果这些对项目都不是至关重要的，那么在丢包不是问题的系统中可能会有一些性能上的提升。
- en: UDT is one of the newer communication protocols. It is essentially the better
    parts of UDP and TCP combined. It is built on the UDP protocol, but is connection-based,
    and reliable. This means that is has the same acknowledgments and data ordering
    that a TCP connection would have, but over the faster UDP protocol.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: UDT 是较新的通信协议之一。它基本上是 UDP 和 TCP 的优点结合。它是建立在 UDP 协议上的，但是是基于连接的和可靠的。这意味着它具有与 TCP
    连接相同的确认和数据排序，但是使用更快的 UDP 协议。
- en: A benefit of connection-less protocols is that they support a feature called
    'Multicast messaging'. This means that regardless of how many computers are connected,
    each message is only sent over the network once. When sending the same message
    to many computers, this removes the overhead of sending the same message to each
    individual computer. This is the opposite of 'Unicast messaging', in which each
    connected computer receives an individual message, even if the message being sent
    to every machine is the same.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 无连接协议的一个好处是它们支持一种称为“多播消息”的功能。这意味着无论连接了多少台计算机，每条消息都只发送一次。当将相同的消息发送到许多计算机时，这消除了将相同消息发送到每台计算机的开销。这与“单播消息”相反，单播消息中每个连接的计算机都会接收到一个独立的消息，即使发送到每台机器的消息都是相同的。
- en: Websocket is the go-to communication method when working with web browsers and
    real-time web application. It has been designed from the ground up to be used
    as an interface between web browsers and servers, and the protocol has simplified
    some key functionality in regards to bi-directional web communication.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Websocket 是在处理 Web 浏览器和实时 Web 应用程序时的首选通信方法。它从头开始设计，用作 Web 浏览器和服务器之间的接口，并且协议简化了关于双向
    Web 通信的一些关键功能。
- en: Introduction
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 6 SOPs
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 个 SOPs
- en: '*6.1 Introduction*'
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*6.1 介绍*'
- en: The Surface Operators, or SOPs, family of Operators are used for any and all
    3D operations. This includes working with simple 3D geometry, particle systems,
    architectural models, 3D characters, and more. SOPs are the oft ignored operators
    by many beginners because of their steep learning curve, but rest assured that
    a firm knowledge over the SOP family of operators will open up many incredibly
    interesting opportunities, project-wise, as well as offer many extremely efficient
    ways of solving problems.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 表面操作器，或者 SOPs，是用于所有 3D 操作的操作器家族。这包括处理简单的 3D 几何体、粒子系统、建筑模型、3D 角色等。SOPs 是许多初学者经常忽视的操作器，因为它们的学习曲线陡峭，但是请放心，对
    SOP 家族操作器的扎实了解将会在项目上开启许多非常有趣的机会，并且提供许多非常有效的解决问题的方法。
- en: Many projects involving projection mapping, real-time 3D motion capture, architectural
    LED facade installations, and layered video players, would either be impossible
    or extremely difficult without the SOP family of operators.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 许多涉及投影映射、实时 3D 动作捕捉、建筑 LED 立面安装和分层视频播放器的项目，如果没有 SOP 操作器家族，要么是不可能的，要么是非常困难的。
- en: 'TouchDesigner 088 currently supports the following 3D file types:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: TouchDesigner 088 当前支持以下 3D 文件类型：
- en: .fbx
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .fbx
- en: .obj
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .obj
- en: .3ds
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .3ds
- en: .dxf
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .dxf
- en: .dae
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .dae
- en: Keeping Operators from cooking needlessly is essential to smooth performance,
    which will be discussed further in the 'Optimization' section of the book. This
    is even more important when it comes to SOPs. Always try to apply transform animation
    data to a Geometry COMP instead directly of to a SOP. This is because SOP transformations
    happen on the CPU, and the transformation must be performed for every vertex that
    is present in the geometry. Component level transformations are applied to the
    3D geometry, or object, as a whole, and are performed on the GPU as a single operation.
    A single operation performed on the GPU is much preferred when compared to what
    could amount hundreds or thousands of operations performed on the CPU.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 避免不必要地让操作器无谓运算对于顺畅的性能至关重要，这将在本书的 '优化' 部分进一步讨论。当涉及到 SOPs 时，这一点更加重要。始终尝试将变换动画数据应用于
    Geometry COMP，而不是直接应用于 SOP。这是因为 SOP 变换发生在 CPU 上，并且必须为几何体中存在的每个顶点执行变换。组件级别的变换应用于整个
    3D 几何体或对象，并且在 GPU 上作为单个操作执行。与在 CPU 上执行数百次或数千次操作相比，GPU 上执行的单个操作要好得多。
- en: The number of total points, primitives, vertices, and meshes will vary depending
    on what kind of model is being processed, but the basic principle is that the
    more polygons/vertices in a model, the more processing power and GPU RAM are needed
    to process operations. There are tools inside of TouchDesigner to reduce polygon
    counts in complex models, but optimizing geometry in dedicated modelling suites
    can provide more flexibility.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 总点数、基元数、顶点数和网格数会根据正在处理的模型类型而变化，但基本原则是，模型中的多边形/顶点越多，处理操作所需的处理器和 GPU RAM 就越多。TouchDesigner
    中有一些工具可以减少复杂模型中的多边形数量，但在专用建模套件中优化几何形状可以提供更大的灵活性。
- en: Rendering
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染
- en: '*6.2 Rendering*'
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*6.2 渲染*'
- en: One thing many beginners struggle with is the process of quickly and effectively
    transitioning from a 3D workflow to a 2D workflow. The Internet is full of 3D
    workflow tutorials that can explain many of the finer points of 3D rendering,
    but for this chapter, the goal is to get from point A, a simple 3D object, to
    Point B, a Render TOP.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 许多初学者所困扰的一件事是如何快速有效地从 3D 工作流程过渡到 2D 工作流程的过程。互联网上充斥着许多可以解释 3D 渲染的细节的教程，但在本章中，目标是从点
    A，一个简单的 3D 对象，到点 B，一个渲染 TOP。
- en: 'There are three parts to a 3D scene:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 3D 场景由三个部分组成：
- en: 3D geometry (and materials)
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3D 几何体（和材质）
- en: Camera
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相机
- en: Lighting
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 照明
- en: Open example 'Rendering_1.toe'. Taking a quick look at it, there are three basic
    things needed to render the scene, Camera, Light, and 3D geometry, which are all
    referenced by a Render TOP. Let's break down each aspect of the render setup,
    and then look at how it all fits together.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Rendering_1.toe'。快速浏览一下，渲染场景需要三样基本东西：相机、光线和 3D 几何体，这些都由 Render TOP 引用。让我们分解渲染设置的每个方面，然后看看它们如何组合在一起。
- en: The appropriate place to begin is the 3D geometry. This is the essence of it
    all. The 3D model can be anything from simple polygons, animated 3D characters,
    architectural models, etc. Whether importing or procedurally building models,
    all of the operations are done with SOPs, and these SOPs end up in a Geometry
    Component. A key idea to grasp is that in TouchDesigner, SOPs themselves are never
    directly rendered. Instead, Geometry Components, or Geometry COMPs, are rendered,
    that hold SOPs that are flagged for rendering. This is a crucial idea to understand.
    Two scenarios demonstrate this.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 开始的合适地方是 3D 几何体。这就是一切的本质。3D 模型可以是任何东西，从简单的多边形、动画 3D 角色、建筑模型等。无论是导入还是程序化构建模型，所有操作都是用
    SOP 完成的，并且这些 SOP 最终会在 Geometry Component 中。要掌握的一个关键概念是，在 TouchDesigner 中，SOPs
    本身永远不会直接渲染。相反，被标记为渲染的 SOPs 存储在 Geometry Components 中，并且这是一个关键的理念。两种情况可以说明这一点。
- en: Open example 'Rendering_2.toe'. In this project, there is a single geometry
    that is sent into 4 different Geometry COMPs, each of which is rendered with different
    transform values. For the sake of example, this project uses a Box SOP, but in
    this could apply to more complex models. Performing operations on a complex character,
    and having a few iterations of it, could max out a system's headroom. Going back
    to the idea that SOPs aren't directly rendered, it becomes logical to load the
    model once, from which a few iterations can be housed and rendered from Geometry
    COMPs.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Rendering_2.toe'。在这个项目中，有一个单一的几何图形被发送到 4 个不同的 Geometry COMPs 中，每个都以不同的变换值进行渲染。出于示例的目的，此项目使用了一个
    Box SOP，但这也适用于更复杂的模型。对于复杂角色执行操作，并对其进行几次迭代可能会耗尽系统的余量。回到 SOPs 不直接渲染的想法，从一个模型加载一次，然后从
    Geometry COMPs 渲染出几个迭代成为合乎逻辑的做法。
- en: Open example 'Rendering_3.toe'. This is very different than the previous example,
    in that there is a single Geometry COMP with 3 different models that are being
    rendered. Keeping in mind that Geometry COMPs are rendered, it becomes logical
    to group these models into a single Geometry COMP, that is being rendered. The
    difference may seem arbitrary, but as projects become more complex, saving resources
    becomes paramount.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Rendering_3.toe'。这与前面的示例非常不同，因为有一个单一的 Geometry COMP，渲染了 3 个不同的模型。牢记 Geometry
    COMPs 是被渲染的，将这些模型分组到一个单一的 Geometry COMP 中进行渲染就变得合乎逻辑。差异可能看起来是任意的，但随着项目变得更加复杂，节约资源变得至关重要。
- en: 'Till now, the various geometry haven''t had any materials. Materials are what
    make 3D scenes interesting. The difference between a cement building-block and
    a 3D box is a material. Textures can be applied at two levels: the SOP level,
    and the Component level. The first is through the use of the Material SOP, and
    the second is by referencing the material in the ''Render'' tab of a Geometry
    COMP. In the example ''Rendering_4.toe'', both materials look the same, but each
    use a different method of texturing.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，各种几何图形都没有任何材料。材料使 3D 场景变得有趣。水泥建筑块和 3D 盒子之间的区别在于材料。纹理可以在两个级别上应用：SOP 级别和组件级别。第一个是通过使用
    Material SOP，第二个是通过在 Geometry COMP 的 'Render' 选项卡中引用材料。在示例 'Rendering_4.toe' 中，两种材料看起来相同，但每种使用了不同的纹理方法。
- en: Now that materials are added to the mix, let's quickly discuss UV maps. Open
    example 'Rendering_5.toe'. This is the same example as above, but the same texture
    looks completely different. This is because the co-ordinates of the UV map have
    been changed.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 现在材质加入了混合，让我们快速讨论一下 UV 贴图。打开示例 'Rendering_5.toe'。这与上面的示例相同，但是相同的纹理看起来完全不同。这是因为
    UV 贴图的坐标已经被更改。
- en: The second aspect of a 3D scene is light. Just as in real life, 3D scenes require
    lighting. Open example 'Rendering_6.toe'. This example has a simple box being
    rendered, but nothing is visible in the Render TOP. This is because the light's
    dimness has been purposefully set the to 0, to demonstrate how important lighting
    is, and how it is often overlooked.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 场景的第二个方面是光线。就像现实生活中一样，3D 场景需要光线。打开示例 'Rendering_6.toe'。这个示例中有一个简单的盒子被渲染，但在
    Render TOP 中什么都看不到。这是因为光线的昏暗被故意设置为 0，以演示光照的重要性，以及它经常被忽视。
- en: The next few example projects are the same scene with different lights. In each
    consecutive project, the Light COMP has been transformed to light the Box SOP
    from a different angle. These are example projects 'Rendering_7.toe', 'Rendering_8.toe',
    and 'Rendering_9.toe'.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个示例项目是相同的场景，但使用不同的灯光。在每个连续的项目中，Light COMP 已被转换以从不同的角度照亮 Box SOP。这些示例项目是
    'Rendering_7.toe'、'Rendering_8.toe' 和 'Rendering_9.toe'。
- en: The last aspect to rendering a 3D scene is the camera. The camera is the eye
    and perspective. What the camera sees is what gets rendered. Open example 'Rendering_10.toe'.
    All the movement in the scene stems from the animated camera movements. Often
    times, a camera is placed in a scene and never thought about again. This can lead
    to boring 3D scenes that feel very static and lifeless. Don't be afraid to think
    like a cinematographer, and experiment with camera positions, focal lengths, and
    animated camera movement.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染 3D 场景的最后一个方面是摄像机。摄像机是眼睛和透视。摄像机看到的就是被渲染的。打开示例 'Rendering_10.toe'。场景中的所有运动都源自动画摄像机运动。通常情况下，摄像机放置在场景中并且再也不加考虑。这可能导致乏味的
    3D 场景，感觉非常静态和无生命。不要害怕像电影摄影师一样思考，尝试使用不同的摄像机位置、焦距和动画摄像机运动。
- en: 'There are two main types of cameras: perspective cameras and orthographic cameras.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像机有两种主要类型：透视摄像机和正交摄像机。
- en: '![](rendering-1.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![](rendering-1.png)'
- en: '![](rendering-2.png)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![](rendering-2.png)'
- en: Perspective cameras need very little explanation, as they work similarly to
    the human eye. Perspective cameras have a perspective point, and a view frustum
    that are used to determine what the camera sees and how that is rendered. With
    a perspective camera, imagine all light in the 3D scene funnelling towards the
    perspective point. Perspective correction, or 'foreshortening', is applied on
    all objects in the scene, meaning that objects farther away from the camera appear
    smaller. This camera ends up being used most often as it functions like human
    eyes. An example of this type of camera can be found in example file 'Camera_1.toe'.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 透视相机需要很少的解释，因为它们的工作方式类似于人眼。 透视相机有一个透视点和一个视锥体，用于确定相机看到的内容以及如何渲染。 使用透视相机，想象3D场景中的所有光线都汇聚到透视点。
    透视校正，或称为“透视缩短”，应用于场景中的所有对象，这意味着距离相机更远的对象看起来更小。 这种相机最常被使用，因为它的功能类似于人眼。 这种类型的相机的示例可以在示例文件'Camera_1.toe'中找到。
- en: This example highlights perspective correction. There are two cubes, both the
    same size. The cube placed farther in the scene appears smaller, just as it would
    in real life. This is the simplest example of how a perspective camera functions.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例突出了透视校正。 有两个立方体，大小相同。 放置在场景中更远的立方体看起来更小，就像在现实生活中一样。 这是透视相机功能的最简单示例。
- en: Orthographic cameras, on the other hand, are very different. Those familiar
    with computer-aided design (CAD) software, may have encountered orthographic cameras
    before. The key principle behind an orthographic camera is that there is no single
    point of perspective. All of the light in the imaginary 3D scene would not filter
    into a single point, as in a perspective camera. Objects are not distorted by
    their Z position in space, meaning that no matter how far away from the camera
    an object is, it will appear no bigger or smaller than the other objects in the
    scene.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，正交相机则大不相同。 熟悉计算机辅助设计（CAD）软件的人可能以前遇到过正交相机。 正交相机背后的关键原则是没有单一的透视点。 在想象中的3D场景中的所有光线不会像在透视相机中那样汇聚到一个单一点。
    对象不会受到它们在空间中的Z位置的扭曲，这意味着无论物体离相机有多远，它看起来都不会比场景中的其他物体更大或更小。
- en: 'Open example ''Camera_2.toe''. This example is exactly the same as ''Camera_1.toe'',
    but there is a big difference in what is being rendered. In this example, the
    two cubes appear to be side by side, regardless of positioning in Z space. This
    can be a hard concept to understand the first time it is presented. Two ways of
    thinking about it are as follows:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例'Camera_2.toe'。 这个示例与'Camera_1.toe'完全相同，但在渲染的内容上有很大的区别。 在这个示例中，两个立方体看起来是并排的，无论在Z空间中的位置如何。
    这可能是第一次理解时很难理解的概念。 关于这个概念有两种思考方式：
- en: '**First** The concept of a 3D world that gets squashed onto a single plane
    before it gets rendered. Imagine the original Super Mario video game actually
    being a 3D scene that was rendered using an orthographic camera. No matter where
    bad guys and platforms are on the screen, whether at the edge or in the middle,
    they are always the same size and shape, and have no perspective correction applied.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一** 一个3D世界的概念，在渲染之前被压缩到一个单一平面上。 想象一下原始的超级马里奥视频游戏实际上是一个使用正交相机渲染的3D场景。 无论坏人和平台在屏幕上的位置如何，无论是在边缘还是在中间，它们始终具有相同的大小和形状，并且没有应用透视校正。'
- en: '**Second** Think about the blueprint of a building in a CAD program. It is
    a representation of a 3D object on a 2D plane. No matter where the blueprint is
    perceived from on screen, 1 unit of measurement on the edge of the screen is exactly
    the same length as 1 unit of measurement in the middle of the screen. Any change
    in the camera positioning doesn''t distort what is being rendered.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二** 想象一下CAD程序中建筑蓝图的蓝图。 这是在2D平面上对3D对象的表示。 无论屏幕上的蓝图从哪个位置看，屏幕边缘的1个单位长度与屏幕中间的1个单位长度完全相同。
    相机位置的任何变化都不会扭曲渲染的内容。'
- en: None of this is to say that Z-depth is irrelevant when using an orthographic
    camera. Z depth becomes imperative when layering different pieces of geometry
    in a scene.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说在使用正交相机时Z深度是无关紧要的。 当在场景中叠加不同的几何体时，Z深度变得至关重要。
- en: The camera is equally important for projection mapping projects. Projection
    mapping will be explored in later examples, but for now, the key is to understand
    another of the Camera's roles. In projection mapping, the primary goal is to turn
    real-world objects into 3D display surfaces. To achieve this, a 3D model of the
    object is imported into TouchDesigner and textured using a variety of sources.
    This textured object then needs to be rendered. Camera COMPs come into play to
    simulate real-world projectors. Gathering as much information about the characteristics
    of a projector and its lens, the Camera COMP can accurately replicate the point
    of view of the projector inside of TouchDesigner. These points of view are then
    rendered, output, calibrated, and lined up to the real-world object. This is the
    basis of projection mapping.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 对于投影映射项目，摄像机同样重要。投影映射将在后续示例中探讨，但现在，关键是了解摄像机的另一个作用。在投影映射中，主要目标是将现实世界的物体转化为 3D
    显示表面。为了实现这一目标，需要将物体的 3D 模型导入到 TouchDesigner 中，并使用各种来源进行纹理处理。然后需要渲染这个带纹理的物体。摄像机
    COMP 用于模拟现实世界的投影仪。通过收集有关投影仪及其镜头特性的尽可能多的信息，摄像机 COMP 可以在 TouchDesigner 中准确复制投影仪的视角。然后这些视角被渲染、输出、校准，并与现实世界的物体对齐。这就是投影映射的基础。
- en: Introduction
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 7 COMPs
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 个 COMPs
- en: '*7.1 Introduction*'
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*7.1 介绍*'
- en: 'There are 3 types of Component Operators, or COMPs, and each have different
    uses:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 有3种类型的组件运算符，或者说 COMPs，每种都有不同的用途：
- en: '**Object** components create, light, and view 3D scenes'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象**组件创建、照明和查看 3D 场景'
- en: '**Panel** components create UI components such as buttons, sliders, and window
    panes'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '**面板**组件创建 UI 组件，如按钮、滑块和窗口窗格'
- en: '**Other** components include components that create keyframe animations, replicate
    other Operators, and create output windows'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他** 组件包括创建关键帧动画、复制其他运算符和创建输出窗口的组件'
- en: Component Operators are generally used in conjunction with other Operators.
    The 'Object' components are used in various combinations to create and render
    SOPs and 3D scenes. The 'Panel' components are used to create UIs and various
    containers to create output rasters. The 'Other' components are used for various
    tasks, such as keyframe animations, dynamic Operator replication, opening windows
    on various displays, etc.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 组件运算符通常与其他运算符一起使用。'对象' 组件用于各种组合，以创建和渲染 SOPs 和 3D 场景。'面板' 组件用于创建 UI 和各种容器，以创建输出光栅。'其他'
    组件用于各种任务，如关键帧动画、动态运算符复制、在各种显示器上打开窗口等。
- en: An interesting fact to put things in perspective is that a large amount of TouchDesigner
    is made from components inside of TouchDesigner. Understanding this really helps
    in grasping the granularity of TouchDesigner, and how to approach working on various
    projects. For example, all Panel components are made of other Operators. Create
    a Button COMP, and inside its Network, its background is made of a Text TOP, and
    its on/off values are being generated by a Panel CHOP. Similarly, all of TouchDesigner's
    UI is made and stored in the 'ui' container in the root of all projects. Even
    the menus and dialogs, like the MIDI Mapper Dialog and the Variables Dialog, are
    created using other TouchDesigner components.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的事实是，TouchDesigner 中有大量的组件构成。理解这一点真的有助于把握 TouchDesigner 的细微之处，以及如何处理各种项目。例如，所有面板组件都由其他运算符制成。创建一个按钮
    COMP，在其网络中，其背景由一个文本 TOP 制成，其开/关值由一个面板 CHOP 生成。同样，TouchDesigner 的所有 UI 都是在所有项目的根目录中的
    'ui' 容器中制作和存储的。甚至菜单和对话框，如 MIDI 映射对话框和变量对话框，都是使用其他 TouchDesigner 组件创建的。
- en: Window COMP
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口 COMP
- en: '*7.2 Window COMP*'
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*7.2 窗口 COMP*'
- en: The Window COMP is used in almost every project to display the contents of an
    Operator in a new window. Whether using the Window COMP to create a full-screen
    output, or to create more of a traditional windowed application, there are a number
    of options that will need modifying. Because of the unique nature of every project,
    there are no 'best settings' to consistently rely on. Spend some time and go over
    the parameters on the Wiki, and experiment to find works best in each and every
    new situation.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口 COMP 几乎在每个项目中都用于在新窗口中显示运算符的内容。无论是使用窗口 COMP 创建全屏输出，还是创建更传统的窗口化应用程序，都需要修改一些选项。由于每个项目的独特性，没有可以始终依赖的
    '最佳设置'。花一些时间查看 Wiki 上的参数，并尝试找到在每个新情况下最适合的设置。
- en: Open example 'Window.toe'. This example demonstrates a very helpful practice,
    as well as some simple Window COMP functionality. It is best practice to use a
    Container COMP as the source of the Window COMP's output. This is because the
    texture in a TOP can be dragged around the screen, even in Perform Mode. If this
    happens, the texture will remain shifted until the project is reloaded, or until
    the texture is moved back to its original position. The same texture shifting
    doesn't occur to Container COMPs. The texture inside of a Container COMP cannot
    be dragged around by default, meaning the texture will always be consistent.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Window.toe'。此示例演示了一种非常有用的实践，以及一些简单的 Window COMP 功能。最佳实践是使用容器 COMP 作为 Window
    COMP 输出的源。这是因为 TOP 中的纹理可以在屏幕上拖动，即使在执行模式下也是如此。如果发生这种情况，纹理将保持移位，直到重新加载项目，或者直到将纹理移回其原始位置。容器
    COMP 中的纹理不会发生相同的纹理移位。容器 COMP 中的纹理默认情况下无法被拖动，这意味着纹理始终是一致的。
- en: The other functionality in this example is rather simple. The first is a button,
    whose Null CHOP is being referenced in the 'Open in Separate Window' parameter
    of the Window COMP. This allows easy access to the opening of the window. The
    next is a button that dynamically checks how many monitors are connected, by getting
    a row count from the recently implemented Monitors DAT. Using that value to cycle
    a Count CHOP, open the window with the first button, then use the second button
    to cycle through which monitor this window is assigned to.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例中的其他功能相对简单。首先是一个按钮，其 Null CHOP 被引用在 Window COMP 的 'Open in Separate Window'
    参数中。这样可以方便地打开窗口。接下来是一个按钮，通过从最近实施的 Monitors DAT 获取行数来动态检查连接的显示器数量。利用该值循环一个 Count
    CHOP，用第一个按钮打开窗口，然后使用第二个按钮循环切换此窗口分配到哪个显示器上。
- en: User Interface Components
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面组件
- en: '*7.3 User Interface Components*'
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*7.3 用户界面组件*'
- en: Component Operators are incredibly important as they create user interfaces
    in TouchDesigner. Specifically, the Panel Components are what provide this functionality.
    Many user interfaces will be created in later examples, so only a few basic examples
    will be examined in this section.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 组件运算符非常重要，因为它们在 TouchDesigner 中创建用户界面。具体来说，面板组件提供了此功能。许多用户界面将在后面的示例中创建，因此本节仅检查了一些基本示例。
- en: 'Three of the most useful Panel COMPs are:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 三个最有用的面板 COMPs 是：
- en: the Slider COMP
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑块 COMP
- en: the Button COMP
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮 COMP
- en: Container COMP
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器 COMP
- en: The first two function with the same capabilities as sliders and buttons in
    other applications, but can be modified to suit different requirements. Buttons
    can be programmed as toggles, radios, or momentary buttons. Sliders can function
    as single axis sliders, or as full XY pads.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个功能具有与其他应用程序中的滑块和按钮相同的功能，但可以修改以适应不同的要求。按钮可以编程为切换、单选或瞬时按钮。滑块可以作为单轴滑块或完整的 XY
    轴块。
- en: Container COMPs, on the other hand, don't have a function other than acting
    as a container for other UI elements.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，容器 COMPs 除了作为其他 UI 元素的容器外，没有其他功能。
- en: Open example 'UI.toe'. In this example, there is a simple UI. From the bottom
    of the Network upwards, there are the 2 Button COMPs and the 5 Slider COMPs. These
    are the components that are actually creating the UI's functionality. The parent
    of these elements, is used to group and arrange the buttons and sliders separately.
    Notice that if the viewers for 'container1' or 'container2' are activated, the
    UI elements are usable, but neither 'container1' or 'container2' have any outputs
    or Operators in their Networks. Similarly, the results are the same when 'container1'
    and 'container2' are combined inside of 'container3'. This is because Container
    COMPs have the ability to display their children in their viewers. Container COMPs
    facilitate the creation of complex interfaces using a combination of smaller pieces.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'UI.toe'。在这个示例中，有一个简单的用户界面。从网络底部向上，有 2 个按钮 COMPs 和 5 个滑块 COMPs。这些是实际创建
    UI 功能的组件。这些元素的父级用于分组和分别排列按钮和滑块。注意，如果激活了 'container1' 或 'container2' 的视图器，则可以使用
    UI 元素，但 'container1' 或 'container2' 的网络中没有任何输出或运算符。类似地，当 'container1' 和 'container2'
    合并到 'container3' 中时，结果相同。这是因为容器 COMPs 有能力在其视图器中显示其子级。容器 COMPs 通过组合较小的部分来促进复杂界面的创建。
- en: Introduction
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 8 MATs
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 个 MATs
- en: '*8.1 Introduction*'
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*8.1 介绍*'
- en: Material Operators, or MATs, are used for materials and shaders for 3D geometry.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 材质运算符，或 MATs，用于三维几何体的材质和着色器。
- en: A deep knowledge of computer graphics and rendering helps a great deal when
    working with materials and shaders. Without this knowledge, most users will be
    restricted to the basic settings of the Phong MAT and Point Sprite MAT.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理材质和着色器时，对计算机图形学和渲染有深入的了解会大有帮助。没有这方面的知识，大多数用户将被限制在Phong MAT和Point Sprite MAT的基本设置上。
- en: Texturing and UV mapping geometry are involved processes, and the best results
    are often achieved inside dedicated modelling packages. The textured models can
    then be imported, and worked with, in TouchDesigner.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理和UV映射几何体是复杂的过程，通常在专门的建模软件中可以获得最佳结果。然后可以将带有纹理的模型导入TouchDesigner并进行处理。
- en: Many tools exist for modifying textures, such as the Texture SOP, but complex
    processes might be easier to achieve in a software package created for that specific
    purpose.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多用于修改纹理的工具，例如Texture SOP，但复杂的过程可能更容易在专门为此目的创建的软件包中实现。
- en: Phong, GLSL, and Point Sprite Materials
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Phong、GLSL和Point Sprite材质
- en: '*8.2 Phong, GLSL, and Point Sprite Materials*'
  id: totrans-500
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*8.2 Phong、GLSL和Point Sprite材质*'
- en: 'The three most used MATs are:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的三种MAT是：
- en: the Phong MAT
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Phong MAT
- en: the GLSL MAT
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GLSL MAT
- en: the Point Sprite MAT
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Point Sprite MAT
- en: The general uses of these three MATs will quickly be covered in this section.
    These are three very different Operators, and cover many shading and material
    needs.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分将快速介绍这三种MAT的一般用途。这三个操作符非常不同，涵盖了许多着色和材质需求。
- en: The Phong MAT is the most common material Operator. It is responsible for applying
    texture to 3D geometry. There are a variety of maps that can be applied, such
    as Color, Bump, Specular, Diffuse, and more. The Phong MAT can mix and match Ambient,
    Diffuse, Specular, Emit, and Constant lighting. Open example 'Phong.toe'. In this
    project there are two very simple examples of the Phong MAT. The first uses the
    texture's alpha to create a transparent box. The second sets the Emit Light of
    1,1,1 to fully illuminate the object regardless of the lighting condition. There
    will be many examples of the Phong MAT when it is put to use in the examples section.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: Phong MAT是最常见的材质操作符。它负责将纹理应用于3D几何体。可以应用各种地图，如颜色、凹凸、高光、漫反射等。Phong MAT可以混合匹配环境光、漫反射、高光、发射和常数光。打开示例'Phong.toe'。在这个项目中，有两个非常简单的Phong
    MAT示例。第一个使用纹理的alpha通道创建一个透明的盒子。第二个将发射光设置为1,1,1，以完全照亮物体，而不受光照条件的影响。当Phong MAT在示例部分中投入使用时，将有许多示例。
- en: The GLSL MAT is used to create custom materials using the OpenGL Shading Language
    (GLSL for short). GLSL is a fantastic programming language that can create extremely
    complex textures that run extremely quickly. It achieves this by giving the programmer
    quite a bit of control over the graphics pipeline, without exposing them to assembly
    languages. There can be a slight learning curve when first starting, but there
    are tons of examples of GLSL shaders on the Internet, as well as quite a number
    of great examples in the 'Shared Component' area of the TouchDesigner Forum.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GLSL MAT可以使用OpenGL着色语言（简称GLSL）创建自定义材质。GLSL是一种非常棒的编程语言，可以创建运行非常快速的极其复杂的纹理。它通过让程序员对图形管线有相当大的控制权，而不暴露给他们汇编语言来实现这一点。刚开始时可能会有一点学习曲线，但互联网上有大量GLSL着色器的示例，以及TouchDesigner论坛的“共享组件”区域中有相当多的优秀示例。
- en: The Point Sprite MAT is used to assign sprites to the points of a particle system.
    The name is self explanatory, in that a 2D image (a sprite) is placed at every
    single point in 3D space. The sprites are always facing the camera, and are scaled
    according to their Z depth. The example 'Point_Sprite.toe' demonstrates this.
    To create a similar TouchDesigner network without point sprites, not only would
    there be a pretty disorganized Network, of who knows how many Transform TOPs and
    Composite TOPs, but they would all be using much more resources. By using a particle
    system and point sprites, the Network is easy to read, and doesn't require a lot
    of system resources.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: Point Sprite MAT用于将精灵分配给粒子系统的点。名称是不言而喻的，即在3D空间的每个点上放置一个2D图像（精灵）。精灵始终面向摄像机，并根据它们的Z深度进行缩放。示例'Point_Sprite.toe'演示了这一点。要创建一个类似的TouchDesigner网络而不使用点精灵，不仅会有一个相当混乱的网络，谁知道有多少个Transform
    TOP和Composite TOP，而且它们都会使用更多的资源。通过使用粒子系统和点精灵，网络易于阅读，并且不需要大量系统资源。
- en: UV Maps
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UV映射
- en: '*8.3 UV Maps*'
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*8.3 UV映射*'
- en: UV mapping is an essential to working with complex 3D geometry. As with certain
    other aspects of 3D modelling, it is easier to create and work with UV maps in
    a dedicated modelling program.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: UV 映射对于处理复杂的 3D 几何体至关重要。与三维建模的其他方面一样，使用专用建模程序创建和处理 UV 映射更容易。
- en: UV mapping is what allows designers and artists to create interesting motion
    and still graphic textures for 3D geometry. It bridges the 2D world that motion
    and still graphics are created in with the 3D world of the geometry.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: UV 映射使设计师和艺术家能够为 3D 几何体创建有趣的运动和静态图形纹理。它连接了在其中创建运动和静态图形的 2D 世界与几何体的 3D 世界。
- en: UV mapping is a three-step process. The first step is the unwrapping of the
    3D object into a 2D plane. This unwrapped texture is called a UV map. It is referred
    to as a map, because much like any other type of map, it takes a 3D object and
    accurately, and proportionally, creates a 2D reference. This is the same as street
    maps or world maps, that take the 3D universe and represent them on a 2D plane.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: UV 映射是一个三步过程。第一步是将 3D 对象展开成 2D 平面。这个展开的纹理称为 UV 图。它被称为图，因为就像任何其他类型的地图一样，它将 3D
    对象以准确且成比例的方式创建为 2D 参考。这与街道地图或世界地图相同，它们将 3D 宇宙表示在 2D 平面上。
- en: Texturing is the the second step. The 2D UV map is used by artists and designers
    in their compositing softwares to create textures, whether still or moving. The
    benefit of the UV map is that the textures can be applied to the geometry with
    a high degree of precision.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理处理是第二步。艺术家和设计师在他们的合成软件中使用 2D UV 图来创建纹理，无论是静止的还是动态的。UV 图的好处在于，纹理可以被精确地应用到几何体上。
- en: The third step is the application of the texture onto the 3D geometry. This
    varies depending on the software used.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是将纹理应用到 3D 几何体上。这取决于所使用的软件。
- en: The combination of these three steps are referred to as UV mapping.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个步骤的组合被称为 UV 映射。
- en: The third step is a relatively common operation in TouchDesigner. As long as
    the 3D geometry is exported correctly from its modelling software, it will include
    co-ordinates indicating to other applications where the UV maps should be applied.
    In these situations the texture is loaded in a Movie In TOP and applied using
    a Phong MAT to the geometry. If any changes need to be made to how the UV map
    is applied, the Texture SOP can be used.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是在 TouchDesigner 中相对常见的操作。只要 3D 几何体从其建模软件中正确导出，它将包括指示其他应用程序在何处应用 UV 映射的坐标。在这些情况下，纹理将在
    Movie In TOP 中加载，并使用 Phong MAT 应用于几何体。如果需要对 UV 映射的应用进行任何更改，则可以使用 Texture SOP。
- en: 'Below is an example of a simple 3D box, and it''s UV map:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单 3D 箱子及其 UV 映射的示例：
- en: '![](3D-geo.png)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![](3D-geo.png)'
- en: '![](Geo-map.png)'
  id: totrans-520
  prefs: []
  type: TYPE_IMG
  zh: '![](Geo-map.png)'
- en: Introduction
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 9 Python
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 Python
- en: '*9.1 Introduction*'
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*9.1 简介*'
- en: Python scripting is one of the most powerful features of TouchDesigner 088\.
    It is capable of doing incredibly complex operations, like iterating through large
    data sets, natively communicating with a myriad web APIs, controlling and changing
    the parameters of other Operators in extremely rapid succession, and much more.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: Python 脚本是 TouchDesigner 088 最强大的功能之一。它能够执行非常复杂的操作，如遍历大型数据集，与众多网络 API 本地通信，以极快的速度控制和更改其他运算符的参数，等等。
- en: It is important to note that, as of writing, TouchDesigner 088 uses Python 3.3.1\.
    Python 3 differs from Python 2.7 in a number of ways, but most issues can be resolved
    with a quick Google search. Most questions have probably already been asked, and
    the solution could be as simple as a set of parentheses.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，截至目前，TouchDesigner 088 使用的是 Python 3.3.1。 Python 3 与 Python 2.7 有许多不同之处，但大多数问题都可以通过快速的谷歌搜索解决。大多数问题可能已经被提出，并且解决方案可能就是一组括号。
- en: 'For example, in Python 2.7, the Print function could be used without parentheses,
    where in Python 3, this will raise an error. Below is an example of how many Python
    2.7 courses use the Print function:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Python 2.7 中，Print 函数可以在没有括号的情况下使用，而在 Python 3 中，这将引发错误。以下是许多 Python 2.7
    课程使用 Print 函数的示例：
- en: '[PRE0]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is in contrast to how the Print function is used in Python 3, where the
    parentheses are required:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 Python 3 中 Print 函数的使用方式相反，在其中需要括号：
- en: '[PRE1]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An incredible feature of Python, aside from it's readability, is that there
    are many external libraries, many of which can natively connect to most of the
    webs most active spaces, like Facebook, Twitter, Instagram, Foursquare, etc. These
    kind of native integrations unlock a world of real-time data driven projects,
    as well as incredible real-time data sets for visualizations and client presentations.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: Python的一个令人难以置信的特性，除了它的可读性外，还有许多外部库，其中许多可以本地连接到大多数最活跃的网络空间，如Facebook、Twitter、Instagram、Foursquare等。这些本地集成解锁了实时数据驱动项目的世界，以及令人难以置信的实时数据集，可用于可视化和客户演示。
- en: There will be quite a bit of Python scripting in later examples, and although
    it is not mandatory to do so, it is highly recommended that some time be spent
    learning Python through introductory tutorials. There are many fantastic resources
    for learning Python, some of them gamified, and most of them often quite easy
    to pick up and put down. Often times, 10-15 minutes a day of tutorials, over the
    course of a few weeks, can provide a strong fundamental knowledge of Python, and
    more than enough knowledge to do quite a bit of scripting in TouchDesigner.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 以后的示例中会有大量的Python脚本，虽然没有必要这样做，但强烈建议花一些时间通过入门教程学习Python。有许多学习Python的优秀资源，其中一些是游戏化的，大多数都很容易上手和放下。通常，每天10-15分钟的教程，在几周的时间里，可以提供强大的Python基础知识，以及足够的知识来在TouchDesigner中进行相当多的脚本编写。
- en: Textport
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Textport
- en: '*9.2 Textport*'
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*9.2 Textport*'
- en: The Textport has a few important roles in regards to scripting inside of TouchDesigner.
    There are two ways to open the Textport. The first is by using key command 'Alt
    + T'. The second is by selecting 'Textport' from 'Dialogs' in the menu bar at
    the top of the TouchDesigner window.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: Textport在TouchDesigner中的脚本方面有几个重要角色。打开Textport有两种方法。第一种是使用键盘命令“Alt + T”。第二种是从TouchDesigner窗口顶部的菜单栏中选择“对话框”，然后选择“Textport”。
- en: 'The first is that it can be used similarly to the IDLE shell that comes with
    Python installations. For example, open the Textport, type the following, and
    hit ''Enter'' on the keyboard:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点是它可以类似于Python安装中附带的IDLE shell。例如，打开Textport，键入以下内容，然后在键盘上按“Enter”：
- en: '[PRE2]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Running this in Python would print the result of the equation, which is 8\.
    After hitting 'Enter' in the Textport, the result of the equation is displayed.
    This is because the Textport works as a Python interpreter. Type Python code into
    the Textport, it will be processed, and the results will be returned.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中运行此代码将打印出方程的结果，即8。在Textport中按“Enter”键后，方程的结果将显示出来。这是因为Textport作为Python解释器工作。在Textport中键入Python代码，它将被处理，并返回结果。
- en: 'It can similarly do the same for tscript, the scripting language that was used
    in TouchDesigner 077\. Notice that when the Textport is opened, the first thing
    printed is:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以为tscript执行相同的操作，tscript是在TouchDesigner 077中使用的脚本语言。请注意，当打开Textport时，首先打印的是：
- en: '[PRE3]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is because in TouchDesigner 088, the Textport interpreter is set to interpret
    Python by default. To work with tscript in the Textport, the mode of the Textport
    needs to be changed from Python to tscript. This is done by clicking on the Python
    logo in the top left corner of the Textport. Once clicked, it will change to the
    letter ''T'' and the next line of the Textport will be:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在TouchDesigner 088中，Textport解释器默认设置为解释Python。要在Textport中使用tscript，需要将Textport的模式从Python更改为tscript。方法是点击Textport左上角的Python标志。点击后，它将变成字母“T”，Textport的下一行将是：
- en: '[PRE4]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This means the Textport is now in tscript mode. To confirm this, type the following
    tscript code into the Textport:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Textport现在处于tscript模式。要确认这一点，请在Textport中键入以下tscript代码：
- en: '[PRE5]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Similar to the Python Print function, the above tscript code will print 'Hello!''
    to the Textport.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Python的Print函数，上述tscript代码将“Hello!”打印到Textport。
- en: Another great use of the Textport is as a Python debugger. Open example 'Textport_1.toe'.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: Textport的另一个很好的用途是作为Python调试器。打开示例“Textport_1.toe”。
- en: 'This is a very simple example that highlights how beneficial the Textport becomes
    when using Python scripts. Open the Textport, and then click on the ''Good Python''
    button in the middle of the Network. This will run a script that prints to the
    Textport:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的示例，突出显示了在使用Python脚本时Textport变得多么有用。打开Textport，然后点击网络中间的“Good Python”按钮。这将运行一个打印到Textport的脚本：
- en: '[PRE6]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now click on the 'Bad Python' button. The Textport will display something very
    different.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击“Bad Python”按钮。Textport将显示完全不同的内容。
- en: '[PRE7]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a Python error, occurring because some of the code being interpreted
    is invalid. Learning to read these errors can greatly speed up debugging large
    Python scripts. Let's examine the different portions of this error.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Python错误，因为正在解释的一些代码无效。学会阅读这些错误可以极大地加快调试大型Python脚本的速度。让我们来检查这个错误的不同部分。
- en: 'The first line indicates exactly where the error is in the Network, and which
    line of the script the Python interpreter believes is invalid:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行准确地指示了网络中错误的位置，以及Python解释器认为无效的脚本的哪一行：
- en: '[PRE8]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, the Operator with the error is 'chopexec1' inside of the component
    'project1'. The Python stops interpreting the script at line 11.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，出错的运算符是'project1'组件内的'chopexec1'。Python在第11行停止解释脚本。
- en: 'Below that, the Textport prints the line with the error:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之下，Textport打印出了带有错误的行：
- en: '[PRE9]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'More often that not, spelling mistakes and slip-ups can easily be caught by
    these two lines. In this case, it is clear that the string being printed is not
    enclosed in quotation marks. Knowing where the error is, and more specifically
    what the line the error is occurring on, means this would result in the problem
    being quickly solved. For the sake of this example look at the last line of the
    error:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 往往，拼写错误和小失误可以很容易地被这两行捕捉到。在这种情况下，很明显，要打印的字符串没有被引号括起来。知道错误在哪里，更具体地说是错误发生在哪一行，意味着问题会很快得到解决。就这个示例而言，看看错误的最后一行：
- en: '[PRE10]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The last line of the error is the type of error Python is encountering. More
    detailed information on the different types of errors can be found by looking
    through the official Python 3.3 documentation, under the 'Errors and Exceptions'
    section. The 'SyntaxErrror' is a very common error, and is caused by the Python
    interpreter encountering code that isn't valid Python syntax. As mentioned, the
    above line of code is the missing the quotation marks around the string being
    printed.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的最后一行是Python遇到的错误类型。可以通过查看官方Python 3.3文档中的'错误和异常'部分找到有关不同类型错误的更详细信息。'SyntaxErrror'是一个非常常见的错误，是由于Python解释器遇到了无效的Python语法代码。如上所述，上述代码行是缺少了打印的字符串周围的引号。
- en: Printing to the Textport is an excellent way to take some of the mystery out
    of scripting. When scripting in larger and larger projects, there are often scripts
    in every Network, and quite often, many of them are performing backend tasks,
    such as preloading and unloading movies, that have results that are difficult
    to view. More often than not, scripts are running in parallel in different Networks,
    and it becomes incredibly difficult to tell if the timing of scripts are correct,
    or if actions are happening in the wrong order.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 向Textport打印是消除脚本中一些神秘感的绝佳方式。当在越来越大的项目中编写脚本时，通常在每个网络中都有脚本，而且很多时候，其中许多脚本正在执行后台任务，比如预加载和卸载影片，其结果很难查看。往往脚本在不同的网络中并行运行，这样就非常难以确定脚本的时间是否正确，或者操作是否按照错误的顺序发生。
- en: By having simple Print functions spread throughout scripts, it is not only easy
    to see when scripts are running, but myriad pieces of information can be printed
    as well. Some of these pieces of information can be as simple as the path to the
    script that is being run, or as detailed as what values and variables are being
    worked with and changed.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在脚本中分散简单的打印函数，不仅可以看到脚本何时运行，还可以打印出各种各样的信息。其中一些信息可能是简单的脚本路径，或者详细到正在处理和更改的值和变量。
- en: Open example 'Textport_2.toe'. In this example, there are two sequences of scripts
    that run one after another, with a certain amount of pause between them. Click
    the 'Visual Sequence' button. This sequence has buttons that are clicked into
    the On position as each script is run. This is solely to make it easier to see
    the progress of this sequence. How would this progress be monitored from another
    Network?
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例'Textport_2.toe'。在这个示例中，有两个脚本序列，它们一个接一个地运行，并且它们之间有一定的暂停时间。点击'Visual Sequence'按钮。这个序列有按钮，随着每个脚本的运行而被点击到开启状态。这仅仅是为了更容易地看到这个序列的进展。如何从另一个网络监视这个进展呢？
- en: Open the Textport and click the 'Textport Sequence' button. Contrary to the
    first sequence, this sequence prints a message to the Textport as each script
    is run. There may not be buttons visually changing states in the Network, but
    a number of new abilities are gained. The first is the ability to monitor these
    scripts from anywhere in the project. The second is that it is possible to compare
    the timing of these sequences to any other scripts that are running elsewhere
    in the project. The third, and possibly the most valuable, is the ability to pause
    the project and have a written history of the most recent sequence of events.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Textport并单击'Textport Sequence'按钮。与第一个序列相反，此序列在每个脚本运行时向Textport打印一条消息。网络中可能没有视觉上状态变化的按钮，但会获得许多新的功能。第一个是能够从项目的任何位置监视这些脚本。第二个是可以将这些序列的时间与项目中其他地方运行的任何其他脚本进行比较。第三，可能是最有价值的，是暂停项目并拥有最近事件序列的书面历史。
- en: This history becomes absolutely invaluable when debugging complex logic systems.
    In a project with 30 Networks and 300 independent scripts, when a series of actions
    fail without raising any Python errors, without an ordered log of events, it would
    be impossible to trace bugs. As a script becomes longer and more complex, it is
    easy to create more of these pseudo-checkpoints throughout the script, such as
    'running X section of Y script'.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 这段历史在调试复杂逻辑系统时变得非常宝贵。在一个有30个网络和300个独立脚本的项目中，当一系列操作失败而没有引发任何Python错误时，如果没有有序的事件日志，将无法追踪错误。随着脚本变得越来越长和复杂，很容易在整个脚本中创建更多这些伪检查点，比如'运行Y脚本的X部分'。
- en: Common Practices
  id: totrans-564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见做法
- en: '*9.3 Common Practices*'
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*9.3 常见做法*'
- en: 'There are some common practices that should be upheld when working with Python.
    Something that is interesting about the Python language is that it is built around
    the idea of readability and simplicity. Python has an easter egg built inside
    of it, which can be accessed by entering the following code into a Python interpreter
    or the Textport:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Python时应遵守一些常见做法。关于Python语言有趣的一点是，它建立在可读性和简单性的理念之上。Python内置了一个彩蛋，可以通过在Python解释器或Textport中输入以下代码来访问：
- en: '[PRE11]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Python returns a poem named ''The Zen of Python'' by Tim Peters. Below is that
    text:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: Python返回了一首名为'The Zen of Python'的诗，作者是Tim Peters。以下是该文本：
- en: '[PRE12]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This poem is the motto for many Python developers. Many of its lines try to
    convey Python's ideals and common developer sense.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 这首诗是许多Python开发者的座右铭。它的许多句子试图传达Python的理想和常见开发者意识。
- en: 'Think about the line:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这句话：
- en: '[PRE13]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This can be applied to something that is often done in a hurry: naming. There
    are many different areas in Python and TouchDesigner where objects reference each
    other by name. A developer ends up naming variables, functions, Operators, Networks,
    and more. Without carefully naming Operators, it would be impossible to know each
    Operator''s function. Similarly, without care in naming variables, as demonstrated
    earlier in the chapter, reading scripts can become quite a tedious task. There
    are two conventions that are regularly used when naming Operators and variables
    in TouchDesigner.'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以应用于经常匆忙完成的事情：命名。在Python和TouchDesigner中有许多不同的领域，对象通过名称相互引用。开发人员最终会为变量、函数、操作符、网络等命名。如果不仔细命名操作符，将无法知道每个操作符的功能。同样，如果不在命名变量时小心，如本章前面所示，阅读脚本可能会变得非常繁琐。在TouchDesigner中命名操作符和变量时通常使用两种约定。
- en: 'The first involves using underscores in the place of real-world spaces. Here
    are some examples:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个涉及在现实世界空间的位置使用下划线。以下是一些示例：
- en: final_comp
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: final_comp
- en: stop_button
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stop_button
- en: time_now
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: time_now
- en: 'The underscores make names easier to read and quickly understand. There are
    individuals who aren''t partial to using underscores, and because of such the
    second convention involves using capital letters to differentiate between words.
    Here are some examples:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线使名称更易于阅读和快速理解。有些人不喜欢使用下划线，因此第二个约定涉及使用大写字母区分单词。以下是一些示例：
- en: finalComp
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: finalComp
- en: stopButton
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stopButton
- en: timeNow
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: timeNow
- en: Both are able to convey the original idea of explicit naming, and should be
    used to facilitate collaboration.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都能传达明确命名的原始想法，并应用于促进协作。
- en: Commenting Code
  id: totrans-583
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码注释
- en: '*9.4 Commenting Code*'
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*9.4 代码注释*'
- en: 'Commenting is a practice that should not be overlooked by new users of Python.
    As easy as it is to write a few lines of script, it takes only a few more seconds
    to quickly document what those lines do. This comes in handy in a multitude of
    situations such as:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是新用户不应忽视的一种实践。写几行脚本很容易，但只需几秒钟就可以快速记录这些行的作用。这在许多情况下都很有用，比如：
- en: Sharing code and projects with other programmers
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他程序员分享代码和项目
- en: Maintaining code in older projects
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护旧项目中的代码
- en: Changing the functionality inside of a re-usable component
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改可重复使用组件内的功能
- en: 'It may seem frivolous when scripts are brief, but it is a habit that should
    be solidified from day 1\. Look at the example code below:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本简短时，这可能看起来是不必要的，但这是一个应该从第一天就养成的习惯。看下面的示例代码：
- en: '[PRE14]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This script is hard to read for a number of reasons. The main reason is that
    its actions weren''t obvious when quickly skimmed. One quick way to increase the
    readability of this script is to comment it. Let''s take the above script and
    add some basic comments to it:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本很难阅读，原因有很多。主要原因是当快速浏览时，它的操作并不明显。增加这个脚本可读性的一种快速方法是对其进行注释。让我们看看上面的脚本，并为其添加一些基本注释：
- en: '[PRE15]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Without taking the time to create meaningful variable and Operator names, the
    above script is still much easier to read through. Even out of context, the function
    of the script is apparent.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有花时间创建有意义的变量和操作符名称，上面的脚本仍然更容易阅读。即使脱离上下文，脚本的功能也是明显的。
- en: This kind of simple addition can make collaborating with other developers much
    easier and more enjoyable.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的添加可以使与其他开发人员合作变得更加容易和愉快。
- en: Compartmentalizing
  id: totrans-595
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分隔
- en: '*9.5 Compartmentalizing*'
  id: totrans-596
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*9.5 分隔*'
- en: The more complicated projects become, scripts will slowly become longer and
    longer. At a certain point, it will take more time to search through code, than
    it will take to actually change and add to it. Because of this, it is important
    to compartmentalize all of a projects scripts.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 项目变得越复杂，脚本会慢慢变得越来越长。在某个时候，搜索代码会花费更多时间，而不是实际进行更改和添加。因此，重要的是将所有项目的脚本进行分隔。
- en: 'This means a few different things, and incorporates a few different techniques,
    but it yields quite a number of benefits. All of these benefits will directly
    improve one''s workflow, but more importantly, they will take a lot of the pain
    out of collaborative settings. Some of the benefits include:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着几件不同的事情，并结合了几种不同的技术，但它会带来许多好处。所有这些好处都将直接改善工作流程，但更重要的是，它们将减少协作环境中的痛苦。一些好处包括：
- en: Easier long-term maintenance of scripts
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易长期维护脚本
- en: Less time spent explaining scripts to colleagues
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 少花时间向同事解释脚本
- en: Easier reusability of programmed functionality
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程功能的更容易重用性
- en: Faster short-term edibility and code management
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快速的短期可编辑性和代码管理
- en: Open example 'Scripting_1.toe'. In this example, there are 10 Movie In TOPs
    and there are a series of actions that need to be performed on each of them. First,
    each one should be unloaded. Secondly, each one will be assigned a new file path.
    Finally, each movie needs to be preloaded, and prepared for playback. Because
    this is a Python example, all of these actions will be performed with Python script.
    Take a look at the Text DAT named 'movies'.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Scripting_1.toe'。在这个示例中，有 10 个 Movie In TOPs，需要对每个进行一系列操作。首先，每个都应该被卸载。其次，每个将被分配一个新的文件路径。最后，每个电影需要被预加载，并准备好播放。因为这是一个
    Python 示例，所有这些操作将通过 Python 脚本执行。查看名为 'movies' 的 Text DAT。
- en: 'A quick note about this script: For the sake of this example, this script doesn''t
    iterate over all of the Operators using loops. This is to simulate what a longer
    and more complex script would feel like, even though only a few simple actions
    are being performed.'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个脚本的一个快速说明：为了这个例子，这个脚本没有使用循环迭代所有的操作符。这是为了模拟一个更长更复杂的脚本会是什么感觉，即使只执行了一些简单的操作。
- en: Right-click on the Text DAT named 'movies', select 'Run', and all the actions
    mentioned above will occur in sequence. This script has been lightly commented,
    but looking through it quickly can be a bit disorienting. To edit a single value
    somewhere in the code, it would have to be found in the long list of actions.
    Colleagues would have to spend more time trying to figure out what this script
    does. To re-use a piece of this script in the future, pieces of it would have
    to be manually found and extracted. How can these processes become more efficient?
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为 'movies' 的 Text DAT 上右键单击，选择 'Run'，所有上述动作将按顺序发生。这个脚本有轻微的注释，但是快速查看它可能有点令人迷惑。要编辑代码中的单个值，必须在长长的动作列表中找到它。同事们将不得不花费更多的时间来弄清楚这个脚本的作用。在将来重新使用脚本的一部分时，必须手动找到并提取它的各个部分。这些过程如何变得更有效？
- en: 'Open example ''Scripting_2.toe''. This example takes the code from the previous
    example, but separates each of our ''actions'' into its own, isolated, Text DAT.
    Immediately, even without diving into each of the scripts, it is easy to tell
    what each one will do. There is one for unloading movies, one for changing paths,
    and one for preloading movies. At the end of each, there is a line of code that
    runs each progressive script in the sequence. This is line of code uses the Run
    class:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Scripting_2.toe'。 这个示例从前一个示例中获取代码，但是将每个“动作”分隔开，放入自己独立的 Text DAT 中。即使没有深入研究每个脚本，也很容易看出每个脚本将做什么。有一个用于卸载电影的脚本，一个用于更改路径，一个用于预加载电影。在每个脚本的末尾，有一行代码运行每个连续脚本的序列。这行代码使用了
    Run 类：
- en: '`op(''preload'').run()`'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '`op(''preload'').run()`'
- en: It would be easy to quickly edit a single value, as actions and parameters are
    much easier to track down now. Passing this component to a colleague would be
    no trouble at all, as they could quickly see what each script does at first glance.
    If someone needed a script to start to preload of a set of Movie In TOPs, it could
    be quickly taken from this project.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很容易快速编辑单个值，因为动作和参数现在要容易追踪得多。将此组件传递给同事将毫不费力，因为他们可以一眼看出每个脚本的作用。如果有人需要一个脚本来启动一组
    Movie In TOPs 的预加载，可以从该项目中快速获取。
- en: This compartmentalized workflow helps cut hard to manage scripts, some more
    than 500 lines in length, into smaller scripts that are easy to sort through quickly
    and share. In the case of the above example, there is third way to handle working
    with these multiple Operators.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分隔的工作流程有助于将难以管理的脚本（有些超过500行）分割为易于快速整理和共享的较小脚本。在上述示例中，处理这些多个运算符的第三种方法。
- en: Open example 'Scripting_3.toe'. This example takes advantage of Python functions.
    A Python function is a small cluster of code that can be called to perform as
    series of action. Inside of the Text DAT named 'actions', a function has been
    defined that contains the set of actions that need to be performed on each Movie
    In TOP. From the Text DAT named 'set_movie_tops', instead of retyping the same
    set of actions over and over, the new function is called by passing it the name
    of each Movie In TOP.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Scripting_3.toe'。 这个示例利用了 Python 函数。Python 函数是一小段代码集群，可以调用以执行一系列操作。在名为
    'actions' 的 Text DAT 中定义了一个包含需要在每个 Movie In TOP 上执行的一组动作的函数。从名为 'set_movie_tops'
    的 Text DAT 中，不再重复输入相同的一组动作，而是通过传递函数名称来调用新函数，传递每个 Movie In TOP 的名称。
- en: 'Although the series of actions have been slightly arbitrary, the idea is simple:
    compartmentalize Python scripts for ease of maintenance, easier co-operative workflows,
    re-usability, and ease of management.'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一系列动作可能略有武断，但思想很简单：将 Python 脚本分割为易于维护、更易于协作的工作流程、可重用性和管理的便利性。
- en: External Modules
  id: totrans-612
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部模块
- en: '*9.6 External Modules*'
  id: totrans-613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*9.6 外部模块*'
- en: One of the underused benefits of Python integration in TouchDesginer is the
    ability to import third-party Python libraries and use them natively. This includes
    the ability to use libraries such as the popular Requests or Beautiful Soup libraries.
    Importing a library is a simple process.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在 TouchDesigner 中的集成的一个不太常用的好处是能够导入第三方 Python 库并在本地使用它们。这包括使用流行的 Requests
    或 Beautiful Soup 库等库的能力。导入库是一个简单的过程。
- en: Install a 64-bit build of Python. At the time of writing, 3.5 is the latest.
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装一个64位版本的Python。在撰写本文时，3.5版本是最新的。
- en: Use 'pip' to install your desired packages
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 'pip' 安装所需的软件包
- en: Open TouchDesigner and go to the 'Edit' menu, and then click on 'Preferences'
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 TouchDesigner 并转到 'Edit' 菜单，然后单击 'Preferences'
- en: Find the setting under 'General' called 'Python 64-bit Module Path' and add
    the path to your 64-bit Python 'site-packages' folder. This folder can be found
    in your Python installing folder, inside of the 'Lib' folder
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在'常规'下找到名为'Python 64位模块路径'的设置，并将路径添加到您的64位 Python 'site-packages'文件夹中。这个文件夹可以在您的
    Python 安装文件夹内的 'Lib' 文件夹中找到。
- en: Inside of TouchDesigner, create a Text DAT, and test the package by using standard
    'import' command
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 TouchDesigner 内创建一个文本 DAT，并使用标准的 'import' 命令测试包。
- en: It is a good idea to confirm that 'pip' installed the package for the correct
    version of Python. A common issue users face is that 'pip' is called for a different
    version of Python than is desired.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 最好确认'pip'是否为正确版本的 Python 安装了包。用户常见的问题是，'pip'被调用以获取与所需版本的 Python 不同的版本。
- en: Where to Learn Python
  id: totrans-621
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 Python 的地方
- en: '*9.7 Where to Learn Python*'
  id: totrans-622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*9.7 学习 Python 的地方*'
- en: 'Below is a very basic list of some free, online, Python tutorials. (Note: some
    of the tutorials are for Python 2.7, but are incredibly well made, and thus included).'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一份非常基本的一些免费在线 Python 教程的列表。（注意：其中一些教程是针对 Python 2.7 的，但制作得非常好，因此包括在内）。
- en: '**CodeAcademy** [http://www.codecademy.com/tracks/python](http://www.codecademy.com/tracks/python)'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '**CodeAcademy** [http://www.codecademy.com/tracks/python](http://www.codecademy.com/tracks/python)'
- en: '**Khan Academy** [https://www.khanacademy.org/science/computer-science](https://www.khanacademy.org/science/computer-science)'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '**可汗学院** [https://www.khanacademy.org/science/computer-science](https://www.khanacademy.org/science/computer-science)'
- en: '**Coursera** [https://www.coursera.org/course/interactivepython](https://www.coursera.org/course/interactivepython)'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '**Coursera** [https://www.coursera.org/course/interactivepython](https://www.coursera.org/course/interactivepython)'
- en: '**Google Developers** [https://developers.google.com/edu/python/?csw=1](https://developers.google.com/edu/python/?csw=1)'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google 开发者** [https://developers.google.com/edu/python/?csw=1](https://developers.google.com/edu/python/?csw=1)'
- en: '**Learn Python The Hard Way** [http://learnpythonthehardway.org/](http://learnpythonthehardway.org/)'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '**用困难的方式学习 Python** [http://learnpythonthehardway.org/](http://learnpythonthehardway.org/)'
- en: Perform Mode
  id: totrans-629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行模式
- en: 10 Outputting Content for Deployment and Performance
  id: totrans-630
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 输出内容以供部署和性能
- en: '*10.1 Perform Mode*'
  id: totrans-631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*10.1 执行模式*'
- en: Perform mode should be used whenever possible when deploying projects. The basic
    premise behind Perform mode is that when a project is ready to be delivered, it
    will be in a state that won't require on-demand programming, and thus won't require
    the Network editor. It is surprising how much system resources can go towards
    just rendering the Network editor, especially if there are many Operators with
    visible viewers, displaying CHOP channels, TOP previews, DAT tables, etc.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 部署项目时应尽可能使用执行模式（Perform mode）。执行模式背后的基本前提是，当项目准备好交付时，它将处于一个状态，不需要按需编程，因此不需要网络编辑器。令人惊讶的是，系统资源可以用于仅仅渲染网络编辑器，特别是如果有许多操作器具有可见的查看器，显示CHOP通道、TOP预览、DAT表等。
- en: Therefore, Perform mode exists so that that computer can focus on rendering
    the content, and doesn't have to render the extra Network editor. Everything that
    is involved with creating the final product is still rendered and active in Perform
    window, including elements such as external data inputs and outputs. The only
    thing that stops being rendered is the Network editor.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，执行模式存在是为了让计算机专注于渲染内容，并且不必渲染额外的网络编辑器。与创建最终产品有关的所有内容仍然在执行窗口中被渲染和激活，包括外部数据输入和输出等元素。停止渲染的唯一内容是网络编辑器。
- en: As mentioned in the Component chapter, it is recommended that Container COMPs
    are used as the source for Window COMPs. The same recommendation applies to Perform
    mode.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 如在组件章节中所述，建议使用容器COMP作为窗口COMP的源。相同的建议适用于执行模式。
- en: Open example 'Perform_mode.toe'. In this example, the Container COMP, 'container1',
    is used as the source for Perform mode. Press the 'F1' key to enter Perform mode,
    and the contents of the container will be displayed in a new window. Press the
    'ESC' key to exit Perform mode and return to the Network editor. There is a UI
    button that can be used to enter Perform mode via the mouse.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Perform_mode.toe'。在这个示例中，容器 COMP 'container1' 被用作执行模式的源。按下 'F1' 键进入执行模式，容器的内容将显示在一个新窗口中。按下
    'ESC' 键退出执行模式并返回到网络编辑器。可以使用鼠标来使用 UI 按钮进入执行模式。
- en: '![10.1.1](perform.png)'
  id: totrans-636
  prefs: []
  type: TYPE_IMG
  zh: '![10.1.1](perform.png)'
- en: Performing with the Network Editor
  id: totrans-637
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网络编辑器进行执行
- en: '*10.2 Performing with the Network Editor*'
  id: totrans-638
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*10.2 使用网络编辑器进行执行*'
- en: 'Every situation is different, and it is possible that programming might have
    to be done during a live performance. If that is the case, there are a few things
    that can help manage the impact the Network Editor has on the system. The first
    is to turn off the viewers on any Operators that don''t need to be monitored.
    See the diagrams below:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 每种情况都是不同的，可能需要在实时演出期间进行编程。如果是这种情况，有一些事情可以帮助管理网络编辑器对系统的影响。首先是关闭不需要监视的任何运算符的查看器。见下图：
- en: '![10.2.1](performing-network-1.png)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
  zh: '![10.2.1](performing-network-1.png)'
- en: '![10.2.2](performing-network-2.png)'
  id: totrans-641
  prefs: []
  type: TYPE_IMG
  zh: '![10.2.2](performing-network-2.png)'
- en: The next thing that helps is to only use 1 pane in the Network Editor. The more
    panes that are visible, the more things there are needing to be rendered.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 只在网络编辑器中使用一个窗格是有帮助的。显示的窗格越多，需要渲染的东西就越多。
- en: Finally, moving in and out of large Networks should be avoided. Moving in and
    out of large Networks can cause frame drops, as TouchDesigner will have to render
    all of the Operators in that Network before they can be viewed.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应避免进入和离开大型网络。进入和离开大型网络可能导致帧率下降，因为 TouchDesigner 必须在可以查看之前渲染该网络中的所有运算符。
- en: Creating an Output Raster
  id: totrans-644
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建输出栅格
- en: '*10.3 Creating an Output Raster*'
  id: totrans-645
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*10.3 创建输出栅格*'
- en: As a general rule, to get the best performance possible, one should always strive
    to only use 1 Window COMP at a time. This doesn't apply while programming, but
    when it comes to deployment and performance, having more than one window open
    will greatly decrease the system's performance. So what should be done if there
    are multiple outputs with different positions and rotations?
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，为了获得最佳性能，应始终努力只使用一个窗口 COMP。这不适用于编程，但是在部署和性能方面，打开多个窗口会大大降低系统的性能。那么如果有多个具有不同位置和旋转的输出应该怎么办呢？
- en: The answer is to create a raster for the output and create a single, all-encompassing,
    window that will span all of the real-world outputs.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是为输出创建一个栅格，并创建一个单一的、全包围的窗口，跨越所有现实世界的输出。
- en: This is more simply expressed with an example. In this example scenario, there
    are four SXGA+ projectors, each with a resolution of 1400x1050\. In the real-world
    setup, there are two projects beaming horizontally on side walls, and two projectors
    beaming vertically, and edge blended, on the center wall. The diagram below illustrates
    the desired setup.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 这更容易通过一个例子来表达。在这个例子场景中，有四个 SXGA+ 投影仪，每个投影仪的分辨率为 1400x1050。在现实世界的设置中，有两个投影仪水平投射在侧墙上，另外两个投影仪垂直投射在中央墙上，并且进行了边缘混合。下图说明了所需的设置。
- en: '![10.3.1](raster-1.png)'
  id: totrans-649
  prefs: []
  type: TYPE_IMG
  zh: '![10.3.1](raster-1.png)'
- en: This setup isn't particularly complex, thus knowing how to deal with it most
    effectively is important. Let's take this setup, and lay it out in 2D.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置并不特别复杂，因此了解如何最有效地处理它是很重要的。让我们把这个设置放在2D中。
- en: '![10.3.2](raster-2.png)'
  id: totrans-651
  prefs: []
  type: TYPE_IMG
  zh: '![10.3.2](raster-2.png)'
- en: A beginners's first instinct might be to use four Window COMPs because there
    are four outputs, two of which need to be rotated. The challenge is finding the
    most efficient layout for these four canvases, to create a single raster. In this
    instance, because all four outputs are the same resolution, an easy solution is
    to make a 2x2 grid.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者的第一直觉可能是使用四个窗口 COMPs，因为有四个输出，其中两个需要旋转。挑战在于为这四个画布找到最有效的布局，以创建单个栅格。在这种情况下，因为所有四个输出的分辨率都相同，一个简单的解决方案是创建一个2x2的网格。
- en: '![10.3.3](raster-3.png)'
  id: totrans-653
  prefs: []
  type: TYPE_IMG
  zh: '![10.3.3](raster-3.png)'
- en: In the above diagram, all of the outputs are placed into a single raster. This
    setup can efficiently use one Window COMP that is 2800x2100 pixels. At this point,
    the nVidia or AMD control panel should be used to create a similar setup out of
    the monitors in Windows, which should then be connected to the correct outputs
    on the graphics card.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，所有输出都放置在单个栅格中。这个设置可以有效地使用一个大小为2800x2100像素的窗口 COMP。此时，应使用 nVidia 或 AMD 控制面板在
    Windows 中创建类似的设置，然后将其连接到显卡上的正确输出。
- en: The next step is to prepare this raster inside of TouchDesigner. Open example
    'Raster.toe'. There are a few things to note from the start. For the example,
    some very basic dummy content has been created, and will represent where real
    content would go. 'Content1' is for the left wall projector and is 1400x1050 pixels.
    'Content2' is for the middle set of projectors and is 2100x1400 pixels. 'Content3'
    is for the right wall projector and is 1400x1050 pixels. All of the canvas building
    happens inside of the 'canvas' Container COMP.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在TouchDesigner中准备这个光栅。打开示例'Raster.toe'。从一开始就有一些需要注意的地方。对于示例，已创建了一些非常基本的虚拟内容，并将代表实际内容的位置。'Content1'用于左墙投影仪，大小为1400x1050像素。'Content2'用于中间的投影仪组，大小为2100x1400像素。'Content3'用于右墙投影仪，大小为1400x1050像素。所有的画布构建都发生在'canvas'容器内部。
- en: 'In the ''canvas'' container, the signal path can be followed from left to right,
    and from top to bottom, like a waterfall. The first step is to create a blank
    raster that content can be composited on. There is a Constant TOP set to 2800x2100
    pixels at the top left of the Network for this purpose. Using an Over TOP, the
    first piece of content is placed, for the left wall projector, in its appropriate
    position, according to the diagram above. This is done using the ''Translate''
    parameter of the Over TOP. Projector 1: done!'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 在'canvas'容器中，信号路径可以从左到右，从上到下地跟随，就像瀑布一样。第一步是创建一个空的光栅，可以在其上合成内容。为此，在网络的左上角设置了一个尺寸为2800x2100像素的常量TOP。使用一个Over
    TOP，将第一片内容放置在其适当的位置上，根据上面的图表来看，为左侧的投影仪。这是通过Over TOP的'Translate'参数来完成的。投影仪 1：完成！
- en: The middle wall has two projectors that are edge blended together. Because a
    few operations need to happen on the raw content, there is a container name 'crop'.
    This keeps the operations encapsulated, neat, and easy to find. Inside of 'crop',
    three main operations are performed. The first is that the big piece of content
    is cut it in half, so that each projector can display half of the image. Since
    the projectors are positioned vertically in the installation, but are positioned
    horizontally in the raster, the 'Flop' parameter of the Flip TOP is used to turn
    the canvas on its side. The settings for the Flip TOP will always end up being
    different depending on hardware setup, so be prepared to try different Flip and
    Flop settings to get the correct content orientation.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 中间墙有两个边缘混合在一起的投影仪。因为需要对原始内容进行一些操作，所以有一个名为'crop'的容器。这使得操作封装在内部，整洁且易于查找。在'crop'内部，执行三个主要操作。第一个是将大块内容切成两半，以便每个投影仪可以显示图像的一半。由于投影仪在安装中是垂直放置的，但在光栅中是水平放置的，因此使用Flip
    TOP的'Flop'参数将画布翻转。Flip TOP的设置将根据硬件设置而不同，因此要准备尝试不同的Flip和Flop设置以获得正确的内容方向。
- en: 'Side note: Most beginners have trouble rotating a full canvas. The first instinct
    is to use the Transform TOP, but it is important to note that the Transform TOP
    will transform the pixels inside of a canvas. This is where the ''Flop'' parameter
    of the Flip TOP comes in. It will fully rotate the canvas.'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 旁注：大多数初学者在旋转整个画布时会遇到困难。第一反应是使用Transform TOP，但重要的是要注意，Transform TOP将转换画布内的像素。这就是Flip
    TOP的'Flop'参数派上用场的地方。它将完全旋转画布。
- en: Since this example isn't dedicated to edge blending, the 'edge_blend' containers
    are just place holders that create the visual effect of a blended edge.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本示例并非专门用于边缘混合，因此'edge_blend'容器只是创建混合边缘视觉效果的占位符。
- en: With all the cropping, rotating, and blending done, the two projector outputs
    are ready to be composited onto the raster. Using the same technique as before,
    an Over TOP with a modified 'Translate' parameter correctly positions the two
    pieces of content. Now Projector 2 and 3 done as well!
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 所有裁剪、旋转和混合完成后，两个投影仪输出准备好合成到光栅上。使用与之前相同的技术，具有修改的'Translate'参数的Over TOP正确地定位两个内容片段。现在投影仪
    2 和 3 也完成了！
- en: The final projector is as simple as the first, and using the trusty Over TOP,
    the final piece of the puzzle is positioned.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个投影仪与第一个一样简单，使用可靠的Over TOP，定位最后的一块拼图。
- en: As mentioned in an earlier chapter, it is best practice to use Container COMPs
    instead of TOPs as the source for Window COMPs. In this project, there is a container
    that is 2800x2100 pixels that holds the completed raster. The 'final' container
    is set as the Window COMPs 'Operator', the 'Borders' setting is turned off in
    the Window COMP, and the window size is set to 2800x2100 pixels. With that, the
    project is ready to be output to the above, 4 projector, setup.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，最佳实践是使用容器 COMPs 而不是 TOPs 作为 Window COMPs 的源。在这个项目中，有一个尺寸为 2800x2100 像素的容器，用于保存完成的光栅图像。'final'
    容器被设置为 Window COMPs 的 'Operator'，在 Window COMP 中关闭了 'Borders' 设置，并将窗口大小设置为 2800x2100
    像素。有了这些，项目就准备好输出到上述的 4 投影仪设置中。
- en: Displays, Tearing, and Stuttering
  id: totrans-663
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示器、撕裂和卡顿
- en: '*10.4 Displays, Tearing, and Stuttering*'
  id: totrans-664
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*10.4 显示器、撕裂和卡顿*'
- en: There has not been much hardware discussion throughout this book, but it is
    important to keep a few things in mind when working with multiple displays. The
    most important rule is to always try to have all display hardware be exactly the
    same. Any difference in the signal flow, can cause what is called 'tearing'. The
    image below is an example of a frame that has tearing.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中并没有太多关于硬件的讨论，但在使用多个显示器时有几点需要注意。最重要的规则是始终尽量使所有显示硬件完全相同。信号流中的任何差异都可能导致所谓的
    'tearing'。下面的图像是一个具有撕裂的帧的示例。
- en: 'Examine the image below. Is it an example of what a frame with tearing will
    look like. Notice the two horizontal cuts across the frame:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面的图像。这是一个带有撕裂的帧的示例。注意帧上的两个水平切割：
- en: '![](tearing.jpg)'
  id: totrans-667
  prefs: []
  type: TYPE_IMG
  zh: '![](tearing.jpg)'
- en: '*Image courtesy of Wikipedia*'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '*图片由维基百科提供*'
- en: Tearing occurs when a display refreshes its image out of sync with when the
    graphics card renders its image. The result is part of the image being from the
    previous frame, and part of it being from the next frame. On slow moving content,
    this can sometimes be hard to notice, but once there is any sort of motion in
    the content, tearing becomes incredibly distracting.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示器在渲染图像时与图形卡刷新图像不同步时，就会发生撕裂。结果是图像的一部分来自上一帧，另一部分来自下一帧。在内容移动缓慢时，有时可能很难注意到，但一旦内容中有任何运动，撕裂就会变得极为分散注意力。
- en: Tearing is a complex issue to solve, but there are a few preventative measures
    that can be taken to avoid it. The first is to use a professional graphics card,
    such as something from the nVidia Quadro series. Most companies will not guarantee
    tear-free playback on anything but their professional cards.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 撕裂是一个复杂的问题，但有一些预防措施可以避免它。首先是使用专业的显卡，比如来自 nVidia Quadro 系列的显卡。大多数公司不会保证除了他们的专业显卡外的任何设备都能无撕裂地播放。
- en: The second is to always ensure that the displays are identical. Identical can't
    be stressed enough. If there is an installation with 3 outputs that have a refresh
    rate of 60hz, and one output with a refresh rate of 59hz, there is a chance there
    will be tearing. If there is an installation with two 1080p projectors, and two
    SXGA+ projectors, there is a chance there will be tearing. The best practice is
    to use displays that are not only identical in specifications, but are also the
    exact same model of displays. Network remote access applications like VNC and
    LogMeIn have also been the culprits of tearing.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是始终确保显示器是相同的。相同是再强调也不为过。如果有一个安装有 3 个刷新率为 60hz 的输出和一个刷新率为 59hz 的输出，那么可能会出现撕裂。如果有一个安装有两个
    1080p 投影仪和两个 SXGA+ 投影仪，那么可能会出现撕裂。最佳实践是使用不仅规格相同，而且也是完全相同型号的显示器。像 VNC 和 LogMeIn
    这样的网络远程访问应用程序也是撕裂的罪魁祸首。
- en: 'This brings up a very important issue with tearing: there are no hard and fast
    rules. Sometimes, setups with a handful of different resolutions and refresh rates
    will work perfectly and won''t tear. On the other hand, sometimes even setups
    with identical displays can tear. Enough emphasis cannot be put on preventative
    measures to avoiding tearing. When tearing issues arise, the only things that
    can be done are a step by step breakdown and analysis of the system to see what
    is causing the tearing.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了撕裂的一个非常重要的问题：没有硬性规定。有时，具有一些不同分辨率和刷新率的设置会完美运行而不会撕裂。另一方面，有时即使是具有相同显示器的设置也会出现撕裂。无法过分强调避免撕裂的预防措施。当出现撕裂问题时，唯一能做的就是逐步分析系统，看看是什么导致了撕裂。
- en: There is a list of common debugging methods on the Derivative Wiki page for
    'Tearing'.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Derivative Wiki 页面上有一个关于 'Tearing' 的常见调试方法列表。
- en: 'Generally the steps to begin with are as follows, in no particular order:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开始的步骤如下，没有特定的顺序：
- en: Verify the project isn't dropping any frames. Dropped frames can sometimes trigger
    tearing
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证项目是否丢失任何帧。丢帧有时可能会触发撕裂。
- en: Verify no other applications are interrupting or mirroring the graphics card
    drivers, such as VNC and LogMeIn.
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证没有其他应用程序中断或镜像图形卡驱动程序，例如 VNC 和 LogMeIn。
- en: Disconnect every display connected to computer, and one by one connect them
    until tearing occurs. Then isolate that display on it's own, and figure out if
    it's being cause by a single display, or by the layout
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断开连接到计算机的每个显示器，然后逐个连接它们，直到出现撕裂。然后将该显示器隔离开来，并确定是单个显示器还是布局导致的问题。
- en: Verify all displays are configured to the same resolution, colour bit depth,
    and refresh rate, in the nVidia or AMD control panel
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证所有显示器在 nVidia 或 AMD 控制面板中配置为相同的分辨率、颜色位深度和刷新率。
- en: Verify that none of the displays have any rotation applied in Windows. this
    can cause unpredictable behaviour.
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认在 Windows 中没有应用任何显示器旋转。这可能导致不可预测的行为。
- en: Check the graphics card driver version and update it if necessary
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查图形卡驱动程序版本，并在必要时进行更新。
- en: Check for drivers or firmware updates on external video splitters - such as
    the Datapath X4 or Matrox TripleHead2Go
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查外部视频分配器（如 Datapath X4 或 Matrox TripleHead2Go）的驱动程序或固件更新。
- en: Confirm only 1 Window COMP is being rendered
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认只有 1 个 Window COMP 被渲染
- en: Verify Windows Aero is disabled. In Windows 7, Aero can cause dropped frames
    and stutters, but won't tear. Once disabled, the system might tear, but stutter
    free playback is guaranteed.
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认 Windows Aero 已禁用。在 Windows 7 中，Aero 可能会导致丢帧和卡顿，但不会撕裂。一旦禁用，系统可能会出现撕裂，但播放时不会出现卡顿。
- en: Configure a Premium Mosaic using the nVidia Control Panel to create a single
    logical display
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 nVidia 控制面板配置高级镶嵌，以创建一个单一的逻辑显示。
- en: There are many instances in which a system that performs perfectly, and doesn't
    drop a single frame, will occasionally stutter. This may occur because of how
    displays and graphics cards negotiate different refresh rates.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，一个完美运行、不丢失任何帧的系统偶尔会出现卡顿。这可能是因为显示器和图形卡协商不同刷新率的方式造成的。
- en: If a project is running at 30 FPS, but a display's refresh rate is 60hz, frame
    doubling has to be negotiated somewhere. Between the graphics card and the display,
    most of the time this negotiation is done transparently, but sometimes there can
    be issues. What can occur is that instead of negotiating a proper frame doubling
    for every frame, one frame might be displayed once, while the next frame is displayed
    for three frames. From the project's point of view, no time is lost and no frames
    were dropped, so it would not be reported in the Performance Monitor or Windows
    Task Manager.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目以 30 FPS 运行，但显示器的刷新率为 60hz，则必须在某个地方协商帧加倍。在图形卡和显示器之间，大多数情况下这种协商是透明进行的，但有时会出现问题。可能发生的情况是，每一帧都不会协商正确的帧加倍，其中一帧可能显示一次，而下一帧可能显示三次。从项目的角度来看，没有丢失时间，也没有丢失帧，因此不会在性能监视器或
    Windows 任务管理器中报告。
- en: If it seems that this kind of issue may be occurring, use the 'FPS is Half Monitor
    Refresh' feature in the Window COMP. This informs the graphics driver that it
    should show each frame for 2 refreshes.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 如果似乎可能发生这种问题，请使用 Window COMP 中的“FPS is Half Monitor Refresh”功能。这会通知图形驱动程序应该将每一帧显示两次。
- en: Edge Blending
  id: totrans-688
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘混合
- en: '*10.5 Edge Blending*'
  id: totrans-689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*10.5 边缘混合*'
- en: Video projectors are an incredibly flexible and are able to create infinitely
    large canvases. This is done by creating arrays of projectors with overlapping
    edges that are blended together to create a seamless canvas. This act of blending
    the overlapping sections is called 'Edge blending'.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 视频投影仪具有极大的灵活性，并且能够创建无限大的画布。这是通过创建具有重叠边缘的投影仪数组并将它们混合在一起来实现的，从而创建一个无缝的画布。混合重叠部分的行为称为“边缘混合”。
- en: The idea of edge blending might be new to those who generally work with monitors
    and screen arrays. A great example of the principles behind edge blending can
    be done relatively quickly. Set up 2 projectors and have one project the color
    blue and have the other project the color green. Separately, these projectors
    output their assigned colors, but if you aim the projectors so that the colors
    overlap, the areas where these two projectors overlap you will actually have a
    turquoise color. These principles of physics and additive color mixing are the
    basis for edge blending.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘混合的概念对于通常使用显示器和屏幕阵列的人来说可能是新的。边缘混合原理的一个很好的示例可以相对快速地完成。设置两个投影仪，一个投影蓝色，另一个投影绿色。单独地，这些投影仪输出它们分配的颜色，但如果你将投影仪对准以使颜色重叠的区域，这两个投影仪重叠的区域实际上将产生一种青绿色。这些物理原理和加色混合是边缘混合的基础。
- en: 'There is an excellent paper written by Paul Bourke that goes much more in-depth
    on the subject of edge blending than we will be going here. For further reference
    and reading, please find that paper at the link below:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 保罗·伯克写了一篇关于边缘混合主题的非常深入的优秀论文，比我们在这里要深入得多。有关进一步参考和阅读，请在以下链接找到该论文：
- en: '**Edge blending using commodity projectors by Paul Bourke** [http://paulbourke.net/texture_colour/edgeblend/](http://paulbourke.net/texture_colour/edgeblend/)'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用普通投影仪进行边缘混合，作者保罗·伯克** [http://paulbourke.net/texture_colour/edgeblend/](http://paulbourke.net/texture_colour/edgeblend/)'
- en: 'The best way to learn the basics of edge blending is through an example setup.
    In this example, the goal will be to blend two 1920 x 1080 projectors in a 1 x
    2 array (1 unit tall and 2 units across). Below is a diagram of a 1 x 2 array
    of projectors:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 学习边缘混合的基础知识的最佳方法是通过一个示例设置。在本示例中，目标是在 1 x 2 数组（高度为 1 单元，横向为 2 单元）中混合两个 1920 x
    1080 投影仪。下面是一个投影仪 1 x 2 数组的图示：
- en: '![10.5.1](blending_layout.png)'
  id: totrans-695
  prefs: []
  type: TYPE_IMG
  zh: '![10.5.1](blending_layout.png)'
- en: The act of blending both of these projectors will require an overlapping section.
    The amount of overlap needed will vary based on many factors such as projector
    resolution and installation parameters. Starting with a blend zone that is a power
    of 2 close to 10\% of your single projector size can be a good place to start
    experimenting. For this example, 10\% of the length of a 1920 x 1080 screen is
    192 pixels, and the nearest power of 2 is 256\.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '混合这两个投影仪将需要一个重叠部分。所需的重叠量将根据许多因素而变化，如投影仪分辨率和安装参数。从接近单个投影仪尺寸的 10% 的 2 的幂的混合区域开始尝试是一个不错的起点。对于本示例，1920
    x 1080 屏幕长度的 10% 是 192 个像素，最近的 2 的幂是 256。 '
- en: 'This overlapping section can cause problems if all of its implications aren''t
    considered. For the image to overlap, that means the both projectors must have
    the same content on their blending edges. In this example, that means that the
    right edge of Projector A and the left edge of Projector B must have the exact
    same content. Filling in some numbers, that means that the 256 pixels on the right
    edge of Projector A must be the same as the 256 pixels on the left edge of Projector
    B, as per the diagram below:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不考虑其所有含义，这个重叠部分可能会导致问题。要使图像重叠，这意味着两个投影仪必须在它们的混合边缘上具有相同的内容。在这个示例中，这意味着投影仪 A
    的右边缘和投影仪 B 的左边缘必须具有相同的内容。填写一些数字，这意味着投影仪 A 右边缘的 256 个像素必须与投影仪 B 左边缘的 256 个像素相同，如下图所示：
- en: '![10.5.2](blended_edge_layout.png)'
  id: totrans-698
  prefs: []
  type: TYPE_IMG
  zh: '![10.5.2](blended_edge_layout.png)'
- en: It's important to take this fact into consideration in regards to the full production
    pipeline and workflow. It seems natural at first to think that a 1 x 2 array of
    1920 x 1080 projectors would need content created at 3840 x 1080, but that assumption
    can lead undesirable consequences.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个生产流程和工作流程中考虑到这一事实非常重要。起初，人们自然会认为，一个 1920 x 1080 投影仪的 1 x 2 数组需要创建 3840 x
    1080 的内容，但这种假设可能会导致不良后果。
- en: A projector has a set amount of physical pixels just like a monitor. Two 1920
    x 1080 images placed edge to edge will have a span of 3840 pixels, but if pixels
    need to be doubled in the overlapping blend zone, those extra pixels used for
    blending don't appear from thin air. The blend zone will need to consume pixels
    that would have otherwise been used for content.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 投影仪与显示器一样，有一定数量的物理像素。两个 1920 x 1080 的图像放置在边缘相接处将有 3840 个像素，但如果需要在重叠的混合区域中加倍像素，那么用于混合的额外像素并不是凭空出现的。混合区域将需要消耗本来用于内容的像素。
- en: 'In this example, if the content creation team created a 3840 x 1080 asset,
    256 pixels would need to be discarded from somewhere to account for the 256 pixels
    that are going to be doubled in the blend zone. Where these pixels are discarded
    from is a matter of preference and tool choice, but the preferred method is to
    discard half of the blend zone from each non-blended edges opposite the blend
    zone. This method keeps the absolute center of the canvas the area where blending
    will occur, as per the diagram below:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果内容创建团队创建了一个 3840 x 1080 的资源，那么需要从某个地方丢弃256像素，以便考虑到将在混合区域中加倍的256像素。从哪里丢弃这些像素是一个偏好和工具选择的问题，但首选方法是从非混合边缘的每一侧丢弃一半的混合区域。这种方法保持了画布的绝对中心，混合将在该区域进行，如下图所示：
- en: '![Discarded Edge Layout](discarded_edge_layout.png)'
  id: totrans-702
  prefs: []
  type: TYPE_IMG
  zh: '![废弃的边缘布局](discarded_edge_layout.png)'
- en: Always be aware of this loss of pixels when edge blending projectors to avoid
    placing critical information or content around areas where pixels may be discarded.
    So why remove only half the blend zone (128 pixels) on each side and not remove
    the whole blend zone from each side (256 pixels)? The answer is that to create
    an overlap of 256 pixels in the center, each side needs to be shifted 128 pixels
    towards the other. When both sides are moved 128 pixels towards each other, the
    resulting overlap is 256 pixels.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 在边缘混合投影仪时，始终要注意像素的丢失，避免将关键信息或内容放在可能丢弃像素的区域周围。那么为什么只移除每侧一半的混合区域（128像素），而不是从每侧完全移除整个混合区域（256像素）呢？答案是为了在中心创建一个256像素的重叠，每侧都需要向另一侧移动128像素。当两侧都向彼此移动128像素时，得到的重叠区域为256像素。
- en: Before proceeding with edge blending in TouchDesigner, there are a few ways
    to approach creating content for blended projectors.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TouchDesigner 中进行边缘混合之前，有几种方法可以用来创建混合投影仪的内容。
- en: The first is to create content at the full output resolution, in this example
    that would be 3840 x 1080, with a buffer of content around the edges where pixels
    will be discarded. Even though parts of the buffer will be discarded, it allows
    for a bit of flexibility in changing the size of the blend zone during installation
    and setup without worrying about cutting too much content and not having enough
    to fill the canvas. This is the 'safe' way to proceed for projects that don't
    have an experienced projectionist on staff to calculate the blend zones before
    installation.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是以完整的输出分辨率创建内容，在这个例子中，分辨率为 3840 x 1080，边缘周围有一个内容缓冲区，其中的像素将被丢弃。即使部分缓冲区将被丢弃，它也允许在安装和设置过程中灵活调整混合区域的大小，而不必担心剪切太多内容而无法填充画布。这是对于没有经验的投影师在安装前计算混合区域的项目来说是“安全”的方式。
- en: For projects that do have a projectionist or other experienced individual on
    staff, there is the option to have the content team create content to the size
    of your visible image, and not the full output resolution. This is appealing because
    it means that there are less pixels to process in generative pipelines or pixels
    to read from a hard drive. To calculate the total image size in this example,
    take the full output resolution (3840 x 1080) and subtract the size of the blend
    zone (256 pixels). This leaves 3584 x 1080 for content, or the image resolution.
    The risk exists with this method that if the blend zones aren't calculated correctly,
    then the content may not be large enough to fill the screen without additional
    scaling.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有投影师或其他经验丰富的员工的项目，有一个选项是让内容团队创建内容以适应可见图像的大小，而不是完整的输出分辨率。这是有吸引力的，因为这意味着在生成管道中处理的像素更少，或者从硬盘读取的像素更少。在这个例子中，要计算总图像大小，需要将完整的输出分辨率（3840
    x 1080）减去混合区域的大小（256像素）。这样留下 3584 x 1080 的内容，或者图像分辨率。这种方法存在风险，即如果混合区域没有正确计算，那么内容可能不足以填充屏幕而需要额外缩放。
- en: Whichever route is chosen, the diagrams below illustrate firstly the final output
    of each projector side by side as seen by Windows and TouchDesigner, and secondly
    the projected image as seen on the projection surface after the blending.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 无论选择哪种方法，下面的图表首先展示了每个投影仪的最终输出，Windows 和 TouchDesigner 中的显示方式，其次是混合后在投影表面上看到的投影图像。
- en: '![Full Layout](full_layout.png)'
  id: totrans-708
  prefs: []
  type: TYPE_IMG
  zh: '![完整布局](full_layout.png)'
- en: '![Full Image Layout](full_image_layout.png)'
  id: totrans-709
  prefs: []
  type: TYPE_IMG
  zh: '![完整图像布局](full_image_layout.png)'
- en: Implementing this example is straightforward in TouchDesigner thanks to built-in
    edge blending tools. Before using the built-in edge blending component, let's
    take a look at the base elements of an edge blending workflow in a simple example.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 在TouchDesigner中实现这个示例非常简单，因为有内置的边缘混合工具。在使用内置的边缘混合组件之前，让我们看一个简单示例中边缘混合工作流程的基本元素。
- en: Open example 'Simple_blend.toe'. In this example, the Container COMP named 'content',
    creates stand-in 3840 x 1080 content by stretching a TouchDesigner sample file.
    The output of this container is then split into two parts using Crop TOPs, one
    for each projector. The important thing to note here is the offset mentioned previously
    is in the Crop TOPs. Projector A's Crop TOP creates a 1920 x 1080 (projector resolution)
    texture starting from the left edge that is offset 128 pixels to the right, discarding
    128 pixels (half the size of the blend zone) from the non-blended edge, in this
    case, the left edge. Similarly, Projector B's Crop TOP creates a 1920 x 1080 texture
    starting from the right edge that is offset 128 pixels to the left, discarding
    128 pixels from the non-blended edge, in this case, the right edge. Both textures
    being offset by 128 pixels towards each other creates a 256 pixel overlap for
    blending.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例'Simple_blend.toe'。在这个示例中，名为'content'的容器COMP通过拉伸TouchDesigner示例文件创建了一个代替的3840
    x 1080内容。然后，该容器的输出通过Crop TOPs分成两部分，每个投影仪一个。这里需要注意的重要事项是之前提到的偏移量在Crop TOPs中。投影仪A的Crop
    TOP创建了一个从左边缘开始偏移128像素的1920 x 1080（投影仪分辨率）纹理，丢弃了非混合边缘的128像素（混合区域的一半大小），在这种情况下是左边缘。类似地，投影仪B的Crop
    TOP创建了一个从右边缘开始偏移128像素的1920 x 1080纹理，丢弃了非混合边缘的128像素，这种情况下是右边缘。两个纹理相互偏移128像素，创造了一个256像素的重叠区域用于混合。
- en: To create the blend zone, these textures are multiplied by alpha ramps that
    are the size of the blend zone, which is 256 x 1080 pixels. There are a number
    of other elements needed to create a seamless image, but this example is to demonstrate
    the workflow. After the elements have their edges prepared for blending, they
    can be appropriately composited onto a single texture that is the full output
    resolution, or in this case, the individual textures are then assigned to the
    backgrounds of Container COMPs, each at the projector resolution. These Container
    COMPs are then parented and aligned using the parent container's 'Align Layout
    Horizontal Left To Right' parameter, which effectively creates the master output.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建混合区域，这些纹理被与混合区域大小相同的alpha斜坡相乘，即256 x 1080像素。创建无缝图像需要一些其他元素，但这个示例是为了演示工作流程。在元素准备好进行混合的边缘后，它们可以适当地合成到一个完整输出分辨率的纹理上，或者在这种情况下，各个纹理然后被分配给Container
    COMPs的背景，每个在投影仪分辨率上。然后，这些Container COMPs通过父容器的'Align Layout Horizontal Left To
    Right'参数进行父子关联和对齐，从而有效地创建主输出。
- en: There are a few elements missing from this basic example such as gamma and luminance
    correction, but this should give you an example of the process of cropping the
    source texture, offsetting the pieces to create an overlap, creating the blend
    zone using a ramp, and then creating an output from that. With a basic understanding
    of the workflow, let's take a look at an example using the more feature-rich built-in
    edge blending tool.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本示例中缺少一些元素，比如伽马和亮度校正，但这应该给你一个裁剪源纹理、偏移片段以创建重叠区域、使用斜坡创建混合区域，然后从中创建输出的过程示例。通过对工作流程的基本理解，让我们看一个使用更丰富功能的内置边缘混合工具的示例。
- en: Open example 'Full_blend.toe'. This project file has two examples in it corresponding
    to the two methods of content creation that were discussed. To find the edge blending
    component for your own projects, open the Palette Browser either using 'Alt +
    L' or by going to the 'Dialogue' menu at the top of the screen and clicking on
    'Palette Browser'. Inside the Palette Browser, under the 'Tools' section, you
    will find the 'EdgeBlend' component that can be dragged into your project. This
    component is based on the same paper by Paul Bourke referenced earlier.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例'Full_blend.toe'。这个项目文件中有两个示例，对应讨论过的两种内容创建方法。要找到自己项目中的边缘混合组件，打开Palette Browser，可以使用'Alt
    + L'或者在屏幕顶部的'Dialogue'菜单中点击'Palette Browser'。在Palette Browser中，在'Tools'部分下，你会找到可以拖入项目中的'EdgeBlend'组件。这个组件基于之前提到的Paul
    Bourke的同一篇论文。
- en: In both examples, the 'EdgeBlend' component is set to have a blend of 256 pixels.
    The 'EdgeBlend' component creates an overlap of content in the center of the texture,
    at the expense of discarding pixels on the non-blended edges. It multiplies the
    blended edges by a ramp and composites the processed textures onto a canvas that
    is the full projector resolution.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个示例中，“EdgeBlend”组件的混合设置为256像素。 “EdgeBlend”组件在纹理的中心创建内容的重叠部分，以牺牲非混合边缘上的像素。它通过斜坡乘以混合边缘，并将处理后的纹理合成到完整投影仪分辨率的画布上。
- en: The first example uses stand-in content at the full output resolution of 3840
    x 1080 pixels. This is the 'safe' method mentioned earlier where losing extraneous
    content on the non-blended edges allows a bit more flexibility in blend zone adjustments
    during installation.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例使用完整输出分辨率为3840 x 1080像素的临时内容。这是前面提到的“安全”方法，在非混合边缘丢失多余内容的情况下，允许在安装过程中更灵活地调整混合区域。
- en: The second example uses stand-in content at the image resolution of 3584 x 1080\.
    At this resolution, pixels don't need to be discarded from this texture. One key
    thing to remember is that many edge blending tools will assume that you are using
    the first example's route, providing content at the full output resolution and
    they will discard pixels on the outside edges and return a texture at the same
    resolution as your input texture. That is why in this example, the image resolution
    asset (3584 x 1080) is composited in the center of a full output resolution canvas
    (3840 x 1080) before being input into the 'EdgeBlend' component. Thus the 'EdgeBlend'
    component will double content in the middle and discard the blank space on either
    side of the image.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例使用图像分辨率为3584 x 1080的临时内容。在此分辨率下，不需要从此纹理中丢弃像素。需要记住的一个关键事项是，许多边缘混合工具将假定您使用第一个示例的路线，提供完整输出分辨率的内容，并且它们将丢弃外部边缘上的像素，并返回与输入纹理相同分辨率的纹理。这就是为什么在这个示例中，图像分辨率资产（3584
    x 1080）在输入到“EdgeBlend”组件之前，被合成在完整输出分辨率画布（3840 x 1080）的中心。因此，“EdgeBlend”组件将在图像的两侧丢弃空白空间，并且在中间加倍内容。
- en: The difference of outputs can be seen clearly, whereas the top example loses
    the reference color bars that were on the outside edges of the image, and the
    second example does not.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的差异可以清楚地看到，顶部示例丢失了图像外侧的参考色条，而第二个示例则没有。
- en: 'With these outputs prepared, it''s a matter of sending the correct texture
    to the correct projector. How to rig projectors and work with complex rigs is
    outside of the scope of this chapter. In an ideal situation, both projectors are
    parallel with the projection surface as such:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好这些输出后，就是将正确的纹理发送到正确的投影仪的问题了。如何设置投影仪并处理复杂的装配超出了本章的范围。在理想情况下，两个投影仪与投影表面平行，如下所示：
- en: '![Projectors](projectors.png)'
  id: totrans-720
  prefs: []
  type: TYPE_IMG
  zh: '![投影仪](projectors.png)'
- en: If the amount of pixels in the blend zone are already known, input them into
    the 'Region' parameter of the 'EdgeBlend' component. Then try turning off the
    'Enable Blend' button to make sure your image is correctly overlapping. At this
    point, the overlapped images should match and be lined up. Always remember the
    main purpose of an edge blending tool is to remove the seams, not line up the
    content.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 如果混合区域中的像素数量已知，请将其输入到“EdgeBlend”组件的“Region”参数中。然后尝试关闭“启用混合”按钮，以确保您的图像正确重叠。在这一点上，重叠的图像应该匹配并对齐。永远记住边缘混合工具的主要目的是消除接缝，而不是对齐内容。
- en: If the amount of pixels in the blend zone aren't know, turn off the 'Enable
    Blend' button and enter a guess. Trying a lower value in the 'Region' parameter
    will offset each projector's texture towards the center, while a higher value
    will offset them towards the edges. Continue increasing or decreasing the 'Region'
    value until your the content in the overlap is the same. Then turn on the 'Enable
    Blend' button.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 如果混合区域中的像素数量未知，请关闭“启用混合”按钮并输入一个猜测值。尝试在“Region”参数中使用较低的值将每个投影仪的纹理向中心偏移，而较高的值将使它们向边缘偏移。继续增加或减少“Region”值，直到重叠中的内容相同。然后打开“启用混合”按钮。
- en: At this point, use the 'Blend' slider to adjust power of the blend. A higher
    value will make the ramp steeper, whereas a lower value will create a more gradual
    ramp.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，使用“Blend”滑块来调整混合的功率。较高的值将使斜坡更陡峭，而较低的值将创建更渐进的斜坡。
- en: You may need to perform gamma correction on the contents of the blend zone.
    This is because light isn't perceived linearly, so the luminance of a pixel being
    input at 0.5 might not be double that of brightness of a pixel being input at
    0.25 (pixel values being normalized from 0-1). Almost all video data already passes
    through gamma correction but because of the variance of projector technologies
    and the fact that there are two projectors overlapping, you may find subtle changes
    need to be made. These sliders are used to compensate or lessen the intensity
    of the gamma correction.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要对混合区域的内容执行伽马校正。这是因为光线的感知不是线性的，因此输入像素的亮度为 0.5 的可能并不是输入像素亮度为 0.25 的两倍（像素值从
    0-1 进行归一化）。几乎所有视频数据已经通过伽马校正，但由于投影技术的差异以及存在两个投影仪重叠的事实，您可能会发现需要进行细微的更改。这些滑块用于补偿或减轻伽马校正的强度。
- en: The 'Luminance' slider controls the overall luminance of the blend zone. If
    the blend zone is brighter or darker than the rest of image, bringing this slider
    below 0.5 will make the blend zone darker, while raising this slider above 0.5
    will brighten the blend zone.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: “亮度”滑块控制混合区域的整体亮度。如果混合区域比图像的其他部分更亮或更暗，将该滑块调低至 0.5 以下将使混合区域变暗，而将该滑块调高至 0.5 以上将使混合区域变亮。
- en: Introduction
  id: totrans-726
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 11 Optimization
  id: totrans-727
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 优化
- en: '*11.1 Introduction*'
  id: totrans-728
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*11.1 介绍*'
- en: Is is incredible to think about the challenges that are overcome when working
    in real-time. All the hardware and software aside, there is an extraordinary amount
    of precision to real-time work. When working in a project at 30 FPS, every single
    thing that is processed, displayed, and created, must be done in a 33ms window.
    That's not even a tenth of a second! This window is even smaller when working
    at higher frame rates. A project running at 60 FPS only has 16ms to render every
    frame from start to finish.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 想想在实时工作中所克服的挑战是令人难以置信的。抛开所有硬件和软件，实时工作需要极其精密的操作。在以 30 FPS 运行的项目中，每处理、显示和创建的事物都必须在
    33ms 的窗口内完成。那甚至不到一秒钟的十分之一！在更高的帧率下工作时，这个窗口甚至更小。以 60 FPS 运行的项目只有 16ms 来渲染从头到尾的每一帧。
- en: Realizing how tiny the window of opportunity is, it is important to cherish
    every single fraction of a single millisecond. Wonder why Operators are taking
    a whole millisecond to cook. Become nervous and try to salvage every half millisecond
    possible, knowing that every millisecond makes a difference. These all require
    basic project analysis and optimization skills.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 意识到机会之窗有多么微小，珍惜每一毫秒的每一分每一秒非常重要。不明白为什么操作员要花费整整一毫秒的时间来进行处理。变得紧张，尽力挽回尽可能多的半毫秒，知道每一毫秒都很重要。所有这些都需要基本的项目分析和优化技能。
- en: TouchDesigner uses the CPU and GPU heavily, and knowing how to figure out which
    is under more demand is an important skill. When faced with larger and larger
    Networks, knowing where the system is stalling, and how to optimize Operators
    to get around these pitfalls, can be the difference between successfully delivering
    and not delivering a project.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: TouchDesigner 大量使用 CPU 和 GPU，知道如何确定哪个需求更大是一项重要技能。面对越来越大的网络，知道系统在哪里停滞，以及如何优化操作员以避开这些陷阱，可能是成功交付和未能交付项目之间的区别。
- en: Finding the Bottleneck
  id: totrans-732
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 找到瓶颈
- en: '*11.2 Finding the Bottleneck*'
  id: totrans-733
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*11.2 找到瓶颈*'
- en: The computer as a whole can be thought of as a pipeline. The CPU, GPU, RAM,
    and hard drives, all work together to create the final product. They sometimes
    work independently, but often times they are reliant on each other, because they
    individually perform very specific tasks. In a pipeline, the system can only be
    as fast as the weakest link. Because of this dependant nature, one stage of the
    pipeline can stall a whole project, even if the rest of the pipeline is completely
    clear. This stall, or weak link in the chain, is referred to as a bottleneck.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 整个计算机可以被视为一个管道。CPU、GPU、RAM 和硬盘都共同工作，创建最终产品。它们有时会独立工作，但通常彼此依赖，因为它们各自执行非常特定的任务。在管道中，系统只能像最弱的一环那样快。由于这种依赖性，管道的一个阶段可能会使整个项目停滞，即使管道的其他部分完全清晰。这种停滞或链条中的弱环被称为瓶颈。
- en: An example of a pipeline with a bottleneck is a project that tries to render
    some basic 3D geometry and texture their faces with video files. This hypothetical
    project consists of 4 Box SOPs. Every face of the Box SOPs are textured with a
    1920x1080 HAP Q movie file. The computer being used for this has 32GB of RAM,
    dual 8-core processors, a top of the line nVidia Quadro graphics card, and a single
    5400-RPM hard drive.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 一个存在瓶颈的管道示例是一个尝试渲染一些基本 3D 几何体并用视频文件纹理它们的项目。这个假设性项目由 4 个 Box SOPs 组成。Box SOPs
    的每个面都使用 1920x1080 HAP Q 电影文件进行纹理。用于此项目的计算机具有 32GB 的 RAM，双 8 核处理器，一款顶级的 nVidia
    Quadro 显卡和一个 5400 转的硬盘。
- en: When launched, this project just won't run on this system. Regardless of how
    much RAM, how many processors, and how expensive a graphics card, the project
    can't read that many HAP Q files from a single 5400-RPM hard drive. The computer
    will continually stall because the hard drive can not spin fast enough to read
    every single movie file simultaneously. HAP Q files are demanding on the hard
    drive, and no matter how powerful the rest of the computer is, the project will
    not run. The GPU can't begin to read movies from a hard drive, just as the hard
    drive cannot begin to process pixels. The hard drive, in this case, has become
    the bottleneck in this project's pipeline.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动时，这个项目在这个系统上根本无法运行。无论有多少 RAM，多少处理器，多贵的显卡，项目都无法从单个 5400 转的硬盘中读取那么多 HAP Q 文件。计算机将不断停顿，因为硬盘无法以足够快的速度同时读取每个电影文件。HAP
    Q 文件对硬盘要求很高，无论计算机的其他部分有多强大，项目都无法运行。GPU 无法开始从硬盘读取电影，就像硬盘无法开始处理像素一样。在这种情况下，硬盘已成为该项目管道中的瓶颈。
- en: 'Generally there are three areas where bottlenecking occurs: the GPU, the CPU,
    and the hard drives.'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 通常瓶颈出现在三个领域：GPU、CPU 和硬盘。
- en: The GPU is a pipeline in and of itself, and pixel shading is the stage that
    is likely to become a bottleneck. Whenever operating on pixels, using almost any
    TOP, the system demands more and more of the GPU's pixel shader. The higher the
    resolution, the higher the demand on the GPU. There is a 1:1 ratio between a TOPs
    resolution and it's GPU workload. If a TOP's resolution is reduced by a factor
    of two, its GPU workload is proportionally reduced. A quick way to check if there
    is a pixel shading bottleneck is to lower the resolution of all generator TOPs,
    such as Render TOPs and Constant TOPs. If there is an immediate increase in speed
    and performance, then it is clear that there is a pixel shading bottleneck.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: GPU 本身就是一个管道，像素着色是可能成为瓶颈的阶段。每当在像素上操作时，几乎使用任何 TOP，系统都会对 GPU 的像素着色器需求越来越高。分辨率越高，对
    GPU 的需求就越高。TOP 的分辨率与其 GPU 工作量之间存在 1:1 的比例关系。如果将 TOP 的分辨率减少一半，其 GPU 工作量也会相应减少。检查是否存在像素着色瓶颈的快速方法是降低所有生成器
    TOP（如 Render TOP 和 Constant TOP）的分辨率。如果速度和性能立即提高，那么很明显存在像素着色瓶颈。
- en: When the graphics card is overworked, seemingly random TOPs will start to have
    higher than normal cook times. This becomes apparent when looking in the Performance
    Monitor at the cook times of various TouchDesigner UI elements. If all of a sudden,
    the various UI elements are taking more than a millisecond to cook, the Network
    needs to be optimized to relieve the GPU of some of its workload.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 当显卡超负荷时，看似随机的 TOPs 开始具有高于正常烹饪时间。当查看性能监视器中各种 TouchDesigner UI 元素的烹饪时间时，这一点变得明显。如果突然之间，各种
    UI 元素的烹饪时间超过一毫秒，那么需要优化网络以减轻 GPU 的一些工作负荷。
- en: The CPU is second area where bottlenecks are experienced. Most Operators require
    the CPU to function, thus the CPU can quickly be overworked. CPU bottlenecks tend
    to be easier to track down, because the Operators that take a long time to cook
    are visible in the Performance Monitor. It is possible to measure how much CPU
    head room there is with the Hog CHOP. This CHOP does as it name implies, and hogs
    CPU processing power. The 'Delay' parameter is the amount of seconds that the
    Hog CHOP will add to the cook time of each frame. If a Hog CHOP is created and
    the project begins dropping frames, that means the CPU is the our bottleneck.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 是第二个经历瓶颈的领域。大多数运算符需要 CPU 运行，因此 CPU 可能很快就会超负荷。CPU 瓶颈往往更容易追踪，因为在性能监视器中可以看到需要很长时间才能完成的运算符。可以使用
    Hog CHOP 来测量 CPU 的剩余处理能力。这个 CHOP 的功能正如其名，会占用 CPU 处理能力。'Delay' 参数是每帧 Hog CHOP 将增加的烹饪时间的秒数。如果创建了一个
    Hog CHOP 并且项目开始丢帧，那么意味着 CPU 是我们的瓶颈。
- en: All movie files use the CPU to decode data from their compressed state. Certain
    codecs use the CPU more than others, and reading many movie files simultaneously
    can use more CPU resources than one would imagine.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 所有电影文件都使用CPU来解码其压缩状态的数据。某些编解码器比其他编解码器更多地使用CPU，并且同时读取多个电影文件可能会使用比想象中更多的CPU资源。
- en: An overloaded CPU reacts similarly to an overloaded GPU, in that inconsistent
    results will appear in the Performance Monitor. Operators will have varying cook
    times. This is because their operations are started, but before they finish, the
    CPU is called to perform another process. The amount of time that the Operator
    spends waiting for the CPU to return to its process is what increases it's cook
    time. Unlike a GPU overload, a CPU overload will generally effect more than just
    TOPs.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 过载的CPU与过载的GPU反应类似，即性能监视器中会出现不一致的结果。操作员的烹饪时间会有所不同。这是因为它们的操作已经开始，但在完成之前，CPU被调用执行另一个进程。操作员等待CPU返回其进程的时间增加了其烹饪时间。与GPU过载不同，CPU过载通常会影响不止TOPs。
- en: 'Hard drives are the third area where bottlenecks occur. Specific operations
    can be demanding on hard drives, and it is easy to overlook high quality solid
    state drives (SSD) when preparing systems for deployment. Operations such as reading
    and writing movies can quickly exhaust a drive, depending on the codec used. This
    bottleneck will often appear in the Performance Monitor as a line item under a
    Movie In TOP that such as:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘是瓶颈发生的第三个领域。特定操作可能对硬盘要求很高，当准备系统部署时，很容易忽视高质量的固态硬盘（SSD）。诸如读写电影之类的操作可能会快速耗尽驱动器，具体取决于使用的编解码器。这种瓶颈通常会出现在性能监视器中，作为Movie
    In TOP下的一行项目，例如：
- en: '[PRE16]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Where the number is the frame of the movie, and the path is the path to the
    movie file.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 电影的帧数是数字，路径是电影文件的路径。
- en: Using the Performance Monitor
  id: totrans-746
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用性能监视器
- en: '*11.3 Using Performance Monitor*'
  id: totrans-747
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*11.3 使用性能监视器*'
- en: The Performance Monitor is a tool for analyzing the cook time of a frame. This
    is useful when trying to optimize and debug a project's performance.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 性能监视器是分析帧的烹饪时间的工具。在尝试优化和调试项目性能时非常有用。
- en: 'There are three ways to access the Performance Monitor:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种访问性能监视器的方式：
- en: '''F2'' on the keyboard'
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键盘上的'F2'
- en: '''Alt + Y'' on the keyboard'
  id: totrans-751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键盘上的'Alt + Y'
- en: Clicking 'Performance Monitor' under 'Dialogs' in the menubar at the top of
    the screen
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕顶部的菜单栏下点击'Dialogs'下的'性能监视器'
- en: There are only a few buttons, and they perform simple tasks that are almost
    self-explanatory.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 只有几个按钮，它们执行几乎是不言自明的简单任务。
- en: '![Performance Monitor](performance-monitor-1.png)'
  id: totrans-754
  prefs: []
  type: TYPE_IMG
  zh: '![性能监视器](performance-monitor-1.png)'
- en: Performs an analyses on the current frame
  id: totrans-755
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对当前帧执行分析
- en: Clears the current results
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除当前结果
- en: Saves the current results to a text file
  id: totrans-757
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前结果保存到文本文件中
- en: Change what is being monitored
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改监视的内容
- en: A millisecond threshold value, which if crossed by a frame's cook time, will
    trigger the Performance Monitor to analyze
  id: totrans-759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 毫秒阈值，如果帧的烹饪时间超过该值，将触发性能监视器进行分析
- en: Filter the results for more precision, i.e. only CHOPS, TOPs, etc
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更精确地过滤结果，即仅限于CHOPS、TOPs等
- en: It is important to note that cook times are based on the CPU. This doesn't mean
    GPU bottlenecks will go unnoticed in the Performance monitor, but be cognizant
    that these are CPU readings.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是烹饪时间是基于CPU的。这并不意味着GPU瓶颈在性能监视器中不会被注意到，但要注意这些是CPU读数。
- en: Here is an example analyses from the Performance Montior.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自性能监视器的一个示例分析。
- en: '![Performance Monitor 2](performance-monitor-2.png)'
  id: totrans-763
  prefs: []
  type: TYPE_IMG
  zh: '![性能监视器 2](performance-monitor-2.png)'
- en: The analyses above is taken from a simple project with a few Movie In TOPs and
    a few Over TOPs. Every frame that is analyzed will have some similar Operators.
    These are the Operators responsible for the functionality and user interface elements
    of TouchDesigner.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 上述分析来自一个简单的项目，其中有几个Movie In TOPs和几个Over TOPs。分析的每一帧都会有一些类似的操作员。这些操作员负责TouchDesigner的功能和用户界面元素。
- en: Look at the marked sections on the above diagram to see the cook times, and
    paths, for the Operators responsible for TouchDesigner's main functionality (User
    interfaces, dialog windows, etc), and more importantly the Operators belonging
    to the example project. The cook time of each Operator is represented by a white
    bar that is sized proportionally based on its contribution to the total cook time
    of that frame. When projects grow and become more involved, the section labeled
    'Example project' will grow to include all of the project's Operators. This allows
    the analysis of a project to find problem Operators that too many system resources.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 查看上图标记的部分，可以看到操作员的烹饪时间和路径，这些操作员负责 TouchDesigner 的主要功能（用户界面、对话框窗口等），更重要的是属于示例项目的操作员。每个操作员的烹饪时间由一个白色条表示，其大小与其对该帧的总烹饪时间的贡献成比例。当项目不断壮大并变得更加复杂时，标有“示例项目”的部分将扩大以包括项目的所有操作员。这允许对项目进行分析以找出使用过多系统资源的问题操作员。
- en: In this example, the paths and cook times of the series of Over TOPs can be
    traced. They are all located inside of the 'project1' container, and their cook
    times range from 0.06 milliseconds to 0.6 milliseconds.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，可以追踪一系列 Over TOPs 的路径和烹饪时间。它们都位于“project1”容器内，其烹饪时间范围从 0.06 毫秒到 0.6 毫秒不等。
- en: 'A cautious side-note: Be careful of the effects of Vertical Sync and how cook
    time is perceived in the Performance Monitor. The graphics card will try to lock
    project FPS and display refresh rate. At 30 FPS, even in an empty project, the
    cook time per frame might be perceived as 33 milliseconds. The same effect can
    occur when working at 60 FPS, except that the Performance Monitor would show a
    frame cook time of 16 milliseconds. This doesn''t mean that each frame actually
    needs a full 33 ms or 16 ms to render a frame, but that Vertical Sync is trying
    to sync TouchDesigner''s FPS and the refresh rate of the displays.'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 小心的侧面说明：注意垂直同步的效果以及性能监视器中烹饪时间的感知。显卡将尝试锁定项目的 FPS 和显示刷新率。在 30 FPS 时，即使是在一个空项目中，每帧的烹饪时间可能被感知为
    33 毫秒。当以 60 FPS 工作时，相同的效果可能发生，只是性能监视器会显示每帧的烹饪时间为 16 毫秒。这并不意味着每帧实际上都需要完整的 33 毫秒或
    16 毫秒来渲染一帧，而是垂直同步正在尝试同步 TouchDesigner 的 FPS 和显示器的刷新率。
- en: Operator Cooking
  id: totrans-768
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作员烹饪
- en: '*11.4 Operator Cooking*'
  id: totrans-769
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*11.4 操作员烹饪*'
- en: Better performance can always be achieved by decreasing the amount of Operators
    that cook every frame. Many beginners never take this into account when creating
    Networks. Admittedly, everyone has worked on prototypes with tight deadlines,
    and has had to created Networks without much foresight. However, not taking cooking
    into account can be quite hazardous if a project can't afford any dropped frames.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 通过减少每帧烹饪的操作员数量，总是可以实现更好的性能。许多初学者在创建网络时从未考虑过这一点。诚然，每个人都曾在紧迫的截止日期下工作过原型，并且不得不在没有太多远见的情况下创建网络。然而，如果项目无法承受任何丢帧，不考虑烹饪可能是非常危险的。
- en: The main goal is to perform static operations as early as possible in the signal
    flow, to prevent those specific from being rendered every frame.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 主要目标是在信号流中尽早执行静态操作，以防止特定的操作在每帧都被渲染。
- en: Open example 'Cooking_1.toe'. In this example, there is a simple graphic that
    rotates, and then various Operators are used to give the image a more interesting
    look. A feature that can help with optimizing Networks is the animation of the
    wires connecting Operators. Animated wires mean that the Operators on both ends
    are being cooked every frame. Starting at the far left of the Network, the wire
    between the Movie In TOP and the Transform TOP is not animated. This is because
    the image is loaded, and remains static. Operators only cook when they need to
    perform an operation or change. A still picture is static, and therefore does
    not change, and does not cook every frame.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例“Cooking_1.toe”。在这个示例中，有一个简单的图形在旋转，然后使用各种操作员使图像看起来更有趣。一个有助于优化网络的功能是动画连接操作员的导线。动画导线意味着两端的操作员每帧都在烹饪。从网络的最左边开始，Movie
    In TOP 和 Transform TOP 之间的导线没有动画。这是因为图像已加载，并保持静态。操作员只有在需要执行操作或更改时才会烹饪。静止图片是静态的，因此不会改变，也不会每帧烹饪。
- en: On the contrary, the rest of the wires in the Network are animated, meaning
    that everything after the Movie In TOP is cooking every frame. For this project,
    this isn't a dire problem, because there isn't anything extremely complex happening.
    Getting in the mind set of making efficient Networks from the start can save a
    lot of headaches come performance time. Let's take a look at this project in the
    Performance Monitor.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，网络中其余的线路都是动画的，这意味着在“顶部的电影”之后的一切都在每一帧中进行处理。对于这个项目来说，这并不是一个严重的问题，因为没有发生非常复杂的事情。从一开始就设定高效网络的思维模式可以在性能时间到来时节省很多麻烦。让我们在性能监视器中查看这个项目。
- en: '![Operator Cooking](operator-cooking-1.png)'
  id: totrans-774
  prefs: []
  type: TYPE_IMG
  zh: '![操作器处理](operator-cooking-1.png)'
- en: Ignoring all the Operators needed for TouchDesigner's functionality, there is
    a small block of Operators dedicated to this example. The operations being performed
    on the image, in total, take about 0.25 milliseconds. As mentioned, static operations
    only need to cook once, and something to note is that many of the operations after
    the Transform TOP are static in nature. Let's re-arrange these and see the gains
    in performance.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略TouchDesigner功能所需的所有操作器，有一小块操作器专门用于这个示例。总体上，对图像执行的操作大约需要0.25毫秒。正如前面提到的，静态操作只需要处理一次，需要注意的是，在变换TOP之后的许多操作都是静态的。让我们重新排列这些操作，看看性能的提升。
- en: Open example 'Cooking_2.toe'. This project is the same as the previous, except
    the Operators have been re-arranged. Before examining the signal flow closer,
    let's take a look at the Performance Monitor.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例“Cooking_2.toe”。这个项目与之前的相同，只是操作器已经重新排列。在更仔细地检查信号流之前，让我们先看一下性能监视器。
- en: '![Operator Cooking 2](operator-cooking-2.png)'
  id: totrans-777
  prefs: []
  type: TYPE_IMG
  zh: '![操作器处理2](operator-cooking-2.png)'
- en: At first glance it appears as if the project has shrank! A few of the Operators
    that were listed previously have disappeared. This is because these Operators
    aren't cooking every frame. In the last example, the Transform TOP was performing
    a transformation every frame, forcing the TOPs after it to recalculate their operations
    every frame. In this example, all of the static operations happen at the start
    of the signal flow, leaving the Transform TOP free to perform its transformation,
    without forcing any other Operators to recalculate their operations, or cook.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，项目似乎已经缩小了！之前列出的一些操作器已经消失了。这是因为这些操作器不是每一帧都在处理。在上一个示例中，变换TOP每帧都在执行变换，迫使其后的TOP每帧重新计算其操作。在这个示例中，所有静态操作都发生在信号流的开始，使变换TOP可以自由执行其变换，而不会强迫其他操作器重新计算其操作或处理。
- en: Taking a more in depth look at the Performance Monitor reading, the only Operator
    that was cooked was the Transform TOP, which took 0.061 milliseconds to cook.
    Compare this to the previous example, where the series of operations took 0.25
    milliseconds to cook. That is an unbelievable gain for such a simple change.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 更深入地查看性能监视器读数，唯一被处理的操作器是变换TOP，它需要0.061毫秒来处理。将这与之前的示例进行比较，那里的一系列操作需要0.25毫秒来处理。对于这样一个简单的改变来说，这是一个令人难以置信的收益。
- en: It is worth noting that side by side, the outputs of these two Operator chains
    may not be exactly identical, but they are so indistinguishable from each other
    that many clients and artists will not mind the difference, knowing that the massive
    performance gains will allow them to do so much more.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这两个操作链的输出可能并不完全相同，但它们之间的区别是如此微不足道，以至于许多客户和艺术家不会在意这种差异，因为他们知道巨大的性能提升将使他们能够做更多事情。
- en: Resolution
  id: totrans-781
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分辨率
- en: '*11.5 Resolution*'
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*11.5 分辨率*'
- en: When it comes to working with 2D textures, resolution is extremely important,
    because of the almost 1:1 ratio of pixels processed compared to processing power
    used.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理2D纹理时，分辨率非常重要，因为像素处理与使用的处理能力几乎是1:1的比例。
- en: An incredibly easy way to demonstrate this fact is through example. Open example
    'Resolution_1.toe'. This is a simple setup. The butterfly is composited on a bigger
    canvas, then using some LFOs, the opacity and blur are modulated before it is
    composited onto the forest background. Middle clicking on any of the TOPs will
    reveal that this example requires just over 100MB of GPU RAM. That's not a lot
    of memory on a system with 4+ GB of GPU RAM, but this can quickly add up. Try
    to composite 40 of these butterflies in real-time, and 4GB can easily be spent.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 通过示例演示这一事实的一种非常简单的方法是通过示例。打开示例'Resolution_1.toe'。 这是一个简单的设置。 蝴蝶被合成在一个更大的画布上，然后使用一些LFOs，在它被合成到森林背景之前，不透明度和模糊度被调制。
    在任何TOP上中键单击将显示，这个示例需要超过100MB的GPU RAM。 在具有4GB以上GPU RAM的系统上，这并不是很多内存，但这可能很快累积起来。
    尝试实时合成40只这样的蝴蝶，4GB很容易就会花掉。
- en: Now contrast this to example 'Resolution_2.toe'. It creates the exact same results,
    but for only 60MB of GPU RAM. That is a significant difference. Take the above
    example of compositing 40 butterflies, and using this second method, only about
    2.4 GB of GPU RAM are needed. All of the extra headroom from a simple change in
    resolution. The source butterfly asset is only 512x512 pixels, and in the first
    example, it is immediately composited on a 1920x1080 pixel canvas that is modulated.
    This creates a scenario where TouchDesigner is constantly re-drawing all 1920x1080
    pixels every frame that the butterfly is modulated. 'Empty' pixels that have neither
    colour or alpha data are also re-drawn. In the second example, the exact same
    operations are being performed, but only on the source asset, which is a much
    lower resolution. This modulated asset is then composited on the 1920x1080 canvas.
    This saves the GPU having to re-draw a large canvas of pixels, when only a small
    section requires processing, thus saving quite a bit of GPU RAM and processing
    power.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将此与示例'Resolution_2.toe'进行对比。 它创建完全相同的结果，但只使用60MB的GPU RAM。 这是一个显着的差异。 以合成40只蝴蝶的示例为例，使用此第二种方法，只需要约2.4GB的GPU
    RAM。 来自分辨率简单更改的所有额外的可用空间。 源蝴蝶资产仅为512x512像素，并且在第一个示例中，它立即被合成在一个1920x1080像素的画布上，然后进行调制。
    这会创建一个场景，其中TouchDesigner在每个蝴蝶调制的每一帧都在不断重新绘制所有1920x1080像素。 没有颜色或alpha数据的“空”像素也将被重新绘制。
    在第二个示例中，执行的操作完全相同，但仅适用于源资产，这是一个更低的分辨率。 然后，在1920x1080画布上合成这个调制的资产。 当只有一个小部分需要处理时，这样可以节省GPU重新绘制大画布像素的时间，从而节省相当多的GPU
    RAM和处理能力。
- en: GPU Memory Fragmentation
  id: totrans-786
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPU内存碎片化
- en: '*11.6 GPU Memory Fragmentation*'
  id: totrans-787
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*11.6 GPU内存碎片*'
- en: Operators that use the GPU will often allocate the resources required for their
    tasks, and hold onto them until the task has been completed or changed.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GPU的Operators通常会分配其任务所需的资源，并将其保留，直到任务完成或更改为止。
- en: GPU Fragmentation is one of the main concerns when working working with projects
    that have many different content sources. For example, a Constant TOP with a resolution
    of 1280x720 is connected to 10 other Operators. Once connected and cooked, each
    Operator will set aside the proper amount of GPU memory required to handle the
    processing of its specific amount of pixels. Once the memory is allocated, the
    Operators can operate relatively efficiently within their allocated space.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: GPU碎片化是在处理具有许多不同内容源的项目时的主要关注点之一。 例如，一个分辨率为1280x720的Constant TOP连接到其他10个Operators。
    一旦连接并烹饪，每个Operator都会设置所需的正确数量的GPU内存，以处理其特定数量的像素的处理。 一旦分配了内存，Operators可以相对有效地在其分配的空间内运行。
- en: If the resolution of the source Constant TOP is changed, this will trigger a
    chain reaction, where all of the 10 other Operators will have to reallocate the
    correct amount of GPU resources for their tasks. If the Operator's resources are
    reallocated efficiently, many of the same memory blocks will be reused. If on
    the off-chance they can't reuse memory blocks, they'll have to relocate to the
    end of the memory. If this happens enough times in quick succession, the GPU memory
    will be fragmented, leaving the project in a state of poor performance while the
    GPU tries to defragment it's memory.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源Constant TOP的分辨率更改，则会触发一系列连锁反应，其中所有其他10个Operators将不得不重新分配正确数量的GPU资源来执行它们的任务。
    如果Operator的资源被有效地重新分配，许多相同的内存块将被重用。 如果偶然它们无法重用内存块，它们将不得不重新定位到内存的末尾。 如果这种情况连续发生了足够多的次数，GPU内存将被碎片化，导致项目处于性能不佳的状态，而GPU试图对其内存进行碎片整理。
- en: The two diagrams below try to outline memory fragmentation in the simplest way
    possible.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个图表尝试以最简单的方式概述内存碎片化。
- en: 'There are two case studies, both with similar parameters: There are 3GB of
    GPU RAM and there are three 1GB static textures to load and hold in RAM indefinitely.'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个案例研究，都具有类似的参数：GPU RAM 为 3GB，并且有三个 1GB 的静态纹理需要加载并永久保存在 RAM 中。
- en: '![Memory Fragmentation](memory-frag-1.png)'
  id: totrans-793
  prefs: []
  type: TYPE_IMG
  zh: '![内存碎片化](memory-frag-1.png)'
- en: In Case 1, the 3GB GPU of RAM would be able to perfectly fit the three 1GB static
    textures. They are called static textures because once they've allocated to memory,
    they aren't changed. This is the equivalent to loading a large image into a Movie
    In TOP at the start of a project and leaving it there indefinitely.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 在案例1中，3GB 的 GPU RAM 可以完美地容纳这三个 1GB 的静态纹理。它们被称为静态纹理，因为一旦它们分配到内存中，就不会改变。这相当于在项目开始时将大图像加载到
    Movie In TOP 中并永久留在那里。
- en: This is a perfect world situation, as there are many other processes that use
    GPU RAM, meaning resources are constantly in flux, and there would never be 3GB
    of free RAM on a graphics card that only has 3GB of GPU RAM.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完美的世界情况，因为还有许多其他使用 GPU RAM 的进程，这意味着资源不断变化，一个只有 3GB GPU RAM 的显卡上永远不会有 3GB
    的空闲 RAM。
- en: 'Case 2 describes a situation where memory fragmentation will occur. To the
    already existing three 1GB textures, a 200MB texture is added to the mix. In this
    example, the loading and unloading is to happen in the following order:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: Case 2 描述了一种内存碎片化的情况。在已经存在的三个 1GB 的纹理中，加入了一个 200MB 的纹理。在这个例子中，加载和卸载将按以下顺序进行：
- en: Load 1GB texture
  id: totrans-797
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载 1GB 的纹理
- en: Load 200MB texture
  id: totrans-798
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载 200MB 的纹理
- en: Load 1GB texture
  id: totrans-799
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载 1GB 的纹理
- en: Unload 200MB texture
  id: totrans-800
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卸载 200MB 的纹理
- en: Load 1GB texture
  id: totrans-801
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载 1GB 的纹理
- en: This would simulate a situation where a texture is loaded, displayed, and then
    replaced with another texture.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 这将模拟这样一种情况：一个纹理被加载、显示，然后用另一个纹理替换。
- en: '![Memory Fragmentation 2](memory-frag-2.png)'
  id: totrans-803
  prefs: []
  type: TYPE_IMG
  zh: '![内存碎片化 2](memory-frag-2.png)'
- en: In diagram 'Case 2.1', Steps 1 through 3 are completed, and there is 800MB free.
    At first glance, this might seem perfect, because if the 200MB texture is unloaded,
    there would be 1GB of free space for the final texture. Unfortunately, this isn't
    how graphics cards work.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 'Case 2.1' 中，完成了步骤 1 到 3，并且有 800MB 的空闲空间。乍一看，这可能看起来很完美，因为如果卸载了 200MB 的纹理，将会有
    1GB 的空闲空间供最后的纹理使用。不幸的是，图形卡不是这样工作的。
- en: '![Memory Fragmentation 3](memory-frag-3.png)'
  id: totrans-805
  prefs: []
  type: TYPE_IMG
  zh: '![内存碎片化 3](memory-frag-3.png)'
- en: As seen above, in diagram 'Case 2.2', Step 4 has been completed, and the 200MB
    texture has been unloaded. What remains is a prime example of GPU memory fragmentation.
    There is a total of 1GB of free GPU memory, but there isn't a single block of
    1GB to allocate to the 1GB texture. The already-loaded 1GB textures, in their
    static state, can't be shifted in the GPU memory without a full unload and reload
    process occurring, and because the memory can't be shifted, the 200MB of free
    space has been trapped between the static textures. This 200MB allocation can
    be filled with 200MB or smaller textures, but it will not be able to load the
    third 1GB static texture.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，在图 'Case 2.2' 中，第 4 步已经完成，并且已卸载了 200MB 的纹理。剩下的是 GPU 内存碎片化的一个典型例子。总共有 1GB
    的空闲 GPU 内存，但没有一个 1GB 的单一块来分配给 1GB 的纹理。已经加载的 1GB 静态纹理在它们的静态状态下不能在 GPU 内存中移动而不发生完全卸载和重新加载过程，因为内存无法移动，所以
    200MB 的空闲空间被困在静态纹理之间。这 200MB 的分配可以用 200MB 或更小的纹理填充，但无法加载第三个 1GB 的静态纹理。
- en: The best way to prevent heavy memory fragmentation is to try to and restrict
    the amount of varying resolutions in a project. When an asset is swapped out for
    one that is the same resolution, often times it can take it's place in the memory.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 防止严重的内存碎片化的最佳方法是尽量限制项目中变化分辨率的数量。当一个资源被替换为与其分辨率相同的资源时，通常可以在内存中占用它的位置。
- en: Windows System Processes
  id: totrans-808
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows 系统进程
- en: '*11.7 Windows System Processes*'
  id: totrans-809
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*11.7 Windows 系统进程*'
- en: Windows is a complex operating system, and there are many processes and system-related
    applications running behind the scenes. Many of these processes and applications
    can negatively impact performance of a computer, and TouchDesigner.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 是一个复杂的操作系统，有许多后台运行的进程和与系统相关的应用程序。这些进程和应用程序中的许多可能会对计算机和 TouchDesigner
    的性能产生负面影响。
- en: Windows is made for a large market of consumers, who primarily use their computers
    during the day. Because of such, there are many applications and Windows system
    operations that are scheduled to run if a computer is left powered-on overnight.
    This can be problematic for performance installations that run 24 hours a day.
    Depending on the needs of the installation or performance, many different applications
    and system related tasks can, and should, be turned off and rescheduled.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: Windows是为大量消费者市场设计的，他们主要在白天使用计算机。因此，如果计算机在夜间保持通电状态，将会有许多应用程序和Windows系统操作被安排在后台运行。这对于全天候运行的性能安装可能会有问题。根据安装或性能的需求，许多不同的应用程序和系统相关任务可以被关闭并重新安排。
- en: Applications such as virus and spyware scanning softwares, albeit useful for
    daily computing, should generally be avoided when using TouchDesigner. Virus and
    spyware softwares can cause a number of issues, the first being pop-ups. Many
    of these softwares display pop-up reminders and notifications at regular intervals.
    In unfortunate situations, these can overlap with displayed content and cover
    outputs during performances and installations. These applications can negatively
    effect the hard drive as well, as they often scan the system for viruses and malware,
    using up hard drive read \& write cycles. These two issues are aside from the
    CPU toll that many of these ever-running applications can incur.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然病毒和间谍软件等应用在日常计算中很有用，但在使用TouchDesigner时通常应避免。病毒和间谍软件可能会引起许多问题，首先是弹出窗口。许多这些软件会定期显示弹出提醒和通知。在不幸的情况下，这些内容可能与显示的内容重叠，并在演出和安装过程中覆盖输出。这些应用程序还可能对硬盘产生负面影响，因为它们经常扫描系统以查找病毒和恶意软件，消耗硬盘的读写循环。这两个问题都是许多这些长时间运行的应用程序可能带来的CPU负担之外的问题。
- en: Introduction
  id: totrans-813
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 12 GLSL
  id: totrans-814
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 GLSL
- en: '*12.1 Introduction*'
  id: totrans-815
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*12.1 简介*'
- en: GLSL, or OpenGL Shading Language, is an incredible tool to have in one's back
    pocket. With a little bit of code, one can program directly on the GPU.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL，或OpenGL着色语言，是一个非常强大的工具。通过一点点代码，人们可以直接在GPU上编程。
- en: Many avoid learning GLSL because they believe that it is only useful for working
    with large textures (4K and beyond), complex 2D generative visual scenes, or creating
    and manipulating 3D geometry, but it can be used in so many facets of day to day
    programming. Whether that be optimizing and creating incredibly effecient compositing
    workflows for standard HD content, or creating simple generative backgrounds for
    interactive experiences.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人避免学习GLSL，因为他们认为它只对处理大纹理（4K及以上）、复杂的2D生成视觉场景或创建和操作3D几何体有用，但它可以在日常编程的许多方面使用。无论是为标准HD内容优化和创建极其高效的合成工作流程，还是为交互体验创建简单的生成背景。
- en: The goal of this chapter is to introduce the reader to some basic GLSL workflows
    and techniques, with the assumption that the reader has no previous GLSL experience.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是向读者介绍一些基本的GLSL工作流程和技术，假设读者没有之前的GLSL经验。
- en: Types of Shaders and Rendering Pipeline
  id: totrans-819
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器类型和渲染管线
- en: '*12.2 Types of Shaders and Rendering Pipeline*'
  id: totrans-820
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*12.2 着色器类型和渲染管线*'
- en: 'The two main types of shaders that can be programmed in TouchDesigner are the
    Vertex shader and the Pixel (or Fragment) shader. In a standard rendering pipeline,
    they are processed in that order, as can be seen in the diagram below:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 在TouchDesigner中可以编程的两种主要着色器是顶点着色器和像素（或片段）着色器。在标准渲染管线中，它们按照顺序处理，如下图所示：
- en: '![GLSL Pipeline](pipeline.png)'
  id: totrans-822
  prefs: []
  type: TYPE_IMG
  zh: '![GLSL管线](pipeline.png)'
- en: There is also a geometry shader that can be applied between the Vertex and Pixel
    shaders for layered rendering and transform feedbacks, but it is not used commonly.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种几何着色器可以应用于顶点着色器和像素着色器之间，用于分层渲染和变换反馈，但并不常用。
- en: In the above pipeline, the application passes the vertex and primitive data
    to the GPU. This includes information such as vertex position, texture coordinate,
    color, normal, etc. This information can be programatically processed and worked
    with by using a Vertex shader.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述管线中，应用程序将顶点和基元数据传递给GPU。这包括顶点位置、纹理坐标、颜色、法线等信息。通过使用顶点着色器，可以对这些信息进行程序化处理和操作。
- en: When the Vertex shader has finished processing the vertex and primitive data,
    the geometry is rasterized. During this process, the geometry goes through various
    stages such as clipping, culling, transformations to window space, etc. These
    stages prepare fragments that will be processed by the Pixel shader.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 当顶点着色器处理完顶点和基元数据后，几何体被光栅化。在此过程中，几何体经历各种阶段，如裁剪、剔除、转换到窗口空间等。这些阶段准备了将由像素着色器处理的片段。
- en: The Pixel shader takes these fragments, processes them, and outputs the color
    and depth data for each pixel.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 像素着色器接收这些片段，处理它们，并为每个像素输出颜色和深度数据。
- en: 'For a more in-depth look at the render pipeline, there is a more thorough explanation
    on the OpenGL website:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 要更深入地了解渲染管线，可以在OpenGL网站上找到更详细的解释：
- en: '[http://www.opengl.org/wiki/Rendering_Pipeline_Overview](http://www.opengl.org/wiki/Rendering_Pipeline_Overview)'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.opengl.org/wiki/Rendering_Pipeline_Overview](http://www.opengl.org/wiki/Rendering_Pipeline_Overview)'
- en: Debugging
  id: totrans-829
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: '*12.3 Debugging*'
  id: totrans-830
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*12.3 调试*'
- en: Before getting too deep into the world of GLSL, it is important to know how
    to debug compiling issues. There are two signs that denote a compiling error.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入GLSL的世界之前，了解如何调试编译问题是很重要的。有两个标志表示编译错误。
- en: The first is a blue and red checker pattern. When working with the GLSL MAT,
    this check pattern will be on the geometry itself. When using GLSL with TOPs,
    this checker pattern will fill up the Operator's viewer and be output from the
    TOP.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是蓝色和红色的棋盘格图案。在使用GLSL MAT时，这个检查图案将出现在几何体本身上。当在TOPs中使用GLSL时，这个棋盘格图案将填满操作符的查看器并从TOP输出。
- en: 'The second sign of a compile error is a yellow triangle warning flag on the
    Operator. Upon clicking and holding the left mouse button on the flag, the error
    will read:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 编译错误的第二个标志是操作符上的黄色三角形警告标志。单击并按住鼠标左键在标志上，错误将显示为：
- en: '[PRE17]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To diagnose these issues, an Info DAT is required. Create an Info DAT, and
    set the ''Operator'' Parameter to reference the GLSL operator with the error.
    In the Info DAT, if there are no errors, there will be only a few lines and of
    them will read ''Compiled Successfully'' or ''Linked Successfully''. If there
    are errors however, they will read more like:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 要诊断这些问题，需要一个信息DAT。创建一个信息DAT，并将“Operator”参数设置为引用带有错误的GLSL操作符。在信息DAT中，如果没有错误，将只有几行，其中一行将会显示“编译成功”或“链接成功”。然而，如果有错误，它们将会显示如下：
- en: '[PRE18]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To quickly break this down, the first thing is the line number. In this case,
    '0(3)' means the compiler is encountering errors at line 3\. In many situations,
    this may mean that the actual mistake happens a line or two earlier, but the compiler
    doesn't halt until the next line when things stop making sense for it.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地解释一下，第一件事是行号。在这种情况下，“0(3)”表示编译器在第3行遇到错误。在许多情况下，这可能意味着实际错误发生在一两行之前，但编译器直到下一行停止时才停止，当事情对它来说不再有意义。
- en: The next section highlights that this is a syntax error, and then there is more
    information about the error.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节强调这是一个语法错误，然后提供有关错误的更多信息。
- en: For beginners, the majority of these errors will be because of forgotten semi-colons
    at the end of lines, or errors trying to cast one data type into another incompatible
    data type.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，大部分错误是因为忘记在行末添加分号，或者尝试将一种数据类型转换为另一种不兼容的数据类型。
- en: Shaders in 3D
  id: totrans-840
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D中的着色器
- en: '*12.4 Shaders in 3D*'
  id: totrans-841
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*12.4 3D中的着色器*'
- en: Let's start by looking at a few very simple 3D scenes that utilize Vertex and
    Pixel shaders.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看一些非常简单的利用顶点和像素着色器的3D场景。
- en: Open example 'Basic_3D.toe'.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例'Basic_3D.toe'。
- en: 'This is a simple render setup where the vertex shader does nothing but pass
    the vertices to the pixel shader, which then colors everything white. Let''s take
    a more in-depth at each shader, starting with the Vertex shader:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的渲染设置，其中顶点着色器什么也不做，只是将顶点传递给像素着色器，然后将一切着色为白色。让我们更深入地看一下每个着色器，从顶点着色器开始：
- en: '[PRE19]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since this is written for someone with no GLSL experience, a few notes about
    basic C syntax and rules that need to be followed, since GLSL is very similar
    to C.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是为没有GLSL经验的人编写的，需要注意一些关于基本C语法和需要遵循的规则，因为GLSL与C非常相似。
- en: The first thing is that semi-colons need to be added at the end of working lines
    of code.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是需要在工作代码行的末尾添加分号。
- en: The second thing is that most of the working code will be inside of the main()
    loop. For beginners, the only things outside of the main loops will be the delcaring
    of variables such as input and output streams and attributes.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 第二件事是，大多数工作代码都将位于主() 循环内。对于初学者来说，除了主循环外的唯一事情将是声明诸如输入和输出流和属性之类的变量。
- en: 'When starting an empty shader, it''s good practice to start by entering the
    main() loop as follows:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动一个空的着色器时，最好的做法是从输入主函数() 开始，如下所示：
- en: '[PRE20]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this vertex shader, there is only have one line of code:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个顶点着色器中，只有一行代码：
- en: '[PRE21]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's break this down from right to left, as there is a lot going on here.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从右向左分解这个，因为这里有很多内容。
- en: '''P'' in this instance is the vertex position. In TouchDesigner, there are
    a few attributes that are declared by default. For instance, ''P'' is the vertex
    position, ''N'' is the normal, ''Cd'' is the color, and ''uv'' is the texture
    coordinate layers (it is an array that is accessed by index, i.e. uv[0], uv[1],
    etc). These values can be accessed as easily as we''ve accesed ''P''.'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实例中，'P' 是顶点位置。在TouchDesigner中，默认声明了一些属性。例如，'P' 是顶点位置，'N' 是法线，'Cd' 是颜色，'uv'
    是纹理坐标层（它是一个通过索引访问的数组，即 uv[0]，uv[1]，等等）。这些值可以像访问 'P' 一样轻松访问。
- en: In the line of code, 'P' is input into a function named 'TDDeform()'. This function
    takes the vertex position from object space and returns the position in world
    space.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码行中，'P' 被输入到一个名为 'TDDeform()' 的函数中。这个函数从对象空间获取顶点位置，并返回世界空间中的位置。
- en: Think of object space as if each object in the 3D world had it's own co-ordinate
    system and 0,0,0 point. After processing these vertices, they have to be transformed
    and integrated into world space. World space is, as the name implies, the full
    world. The world, in this case, is the common coordinate system, with one 0,0,0
    point, where all objects will exist together.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象空间视为3D世界中每个对象都有自己的坐标系和0,0,0点。在处理这些顶点后，它们必须被转换并集成到世界空间中。世界空间是，顾名思义，整个世界。在这种情况下，世界是共同的坐标系，有一个0,0,0点，所有对象都将共存于此。
- en: Once the vertex positions are returned in world space, they are passed to the
    function 'TDWorldToProj()'. This function takes the world space co-ordinates and
    returns them in projection space. The projection space takes all the co-ordinates
    from the world space, and returns them from a camera's point of view.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦顶点位置返回到世界空间，它们就会被传递给函数 'TDWorldToProj()'。这个函数将世界空间坐标作为参数，并返回投影空间中的坐标。投影空间将来自世界空间的所有坐标从摄像机的视角返回。
- en: These values are then assigned to the variable 'gl_Position', which is a built-in
    output for the transformed vertices.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将这些值赋给变量 'gl_Position'，这是转换后顶点的内置输出。
- en: As shown in the rendering pipeline diagram, these transformed vertices are processed
    and passed to the Pixel shader, where they will be assigned color values.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 如渲染管线图所示，这些转换后的顶点将被处理并传递到像素着色器，其中它们将被分配颜色值。
- en: 'In this example, the Pixel shader sets the color output of all the fragments
    to white. The code is below:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，像素着色器将所有片段的颜色输出设置为白色。代码如下：
- en: '[PRE22]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Similar to the Vertex shader, all of the code except for the output declaration
    are inside of the main() loop, and there are semi-colons at the end of lines of
    code.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 与顶点着色器类似，除了输出声明之外的所有代码都在主() 循环内，并且在代码行的末尾有分号。
- en: 'Starting from the top, there is this line of code:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，有这一行代码：
- en: '[PRE23]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This line sets the output as a variable called 'fragColor'. A 'vec4' is a vector
    with 4 components, and in this scenario, they correspond to the output red, green,
    blue, and alpha channels. In GLSL, whenever declaring an input or output, the
    type must be declared as well, thus the specification that it will be a 'vec4'.
    Similarly, inputs will be prefaced by 'in' and outputs will be prefaced by 'out'.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行将输出设置为名为 'fragColor' 的变量。'vec4' 是一个具有4个分量的向量，在这种情况下，它们对应于输出的红色、绿色、蓝色和 alpha
    通道。在GLSL中，无论是声明输入还是输出，都必须声明类型，因此规定它将是一个 'vec4'。同样，输入将以 'in' 为前缀，输出将以 'out' 为前缀。
- en: 'The line of code inside of the main() loop is as follows:'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 主() 循环中的代码行如下：
- en: '[PRE24]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As 'fragColor' has already been declared as the output, this line writes the
    pixel values directly to the output. The section 'vec4(1,1,1,1)' creates a 4-component
    vector with the values 1,1,1,1, and then assigns it to 'fragColor'. 'vec4' has
    to precede the list of values because 'fragColor' has already been declared as
    a vec4, so to assign a value to it, that value needs to be a 'vec4'.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 由于'fragColor'已经声明为输出，这一行直接将像素值写入输出。部分'vec4(1,1,1,1)'创建一个具有值1,1,1,1的4分量向量，然后将其分配给'fragColor'。'vec4'必须在值列表之前，因为'fragColor'已经被声明为vec4，因此要将值分配给它，该值需要是'vec4'。
- en: Because the 4 components of the output correspond to RGBA channels, (1,1,1,1)
    would set all of the channels to 1, effectively setting the output to white for
    every pixel.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 因为输出的4个分量对应于RGBA通道，(1,1,1,1)会将所有通道设置为1，有效地将输出设置为每个像素的白色。
- en: Now with a basic understand of working with shaders in a 3D scene, let's add
    a few levels of complexity. For starters, let's resize the box. This is as simple
    as multiplying each of the vertex positions, or 'P', by a value.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 现在了解了在3D场景中使用着色器的基本方法，让我们增加一些复杂性。首先，让我们调整盒子的大小。这只需将每个顶点位置或'P'乘以一个值即可。
- en: Open example 'Basic_3D_scaled.toe'.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例'Basic_3D_scaled.toe'。
- en: 'Only a few lines of the vertex shader are changed:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 仅更改了几行顶点着色器：
- en: '[PRE25]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first this that is added is a declaration for a variable that is going to
    be used, named 'scaledP'. This is going to be a 3-component vector because we'll
    be working with the vertex position, 'P', which is also a 3-component vector.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的第一件事是一个将要使用的变量的声明，名为'scaledP'。这将是一个3分量向量，因为我们将使用顶点位置'P'，它也是一个3分量向量。
- en: 'Once the variable is defined, it can be used throughout the code. The next
    line that is added is:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 定义变量后，可以在整个代码中使用它。接下来添加的下一行是：
- en: '[PRE26]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This line takes the vertex position, multiplies all the values by 0.5, effectively
    making the box half the size. Similarly, a value of 2 would make the box be double
    it's original size.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行将顶点位置乘以所有值的0.5，有效地使盒子缩小了一半。类似地，值为2会使盒子成为其原始大小的两倍。
- en: 'This new value, ''scaledP'', then replaces ''P'' below:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将这个新值'scaledP'替换到下面的'P'中：
- en: '[PRE27]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Similarly, to transform the box instead of scaling it, values need to be added
    or subtracted to the various axis.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要转换盒子而不是缩放它，需要向各个轴添加或减去值。
- en: Open example 'Basic_3D_transform.toe'.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例'Basic_3D_transform.toe'。
- en: 'In this example, The code in the vertex shader has been changed as below:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，顶点着色器中的代码已更改如下：
- en: '[PRE28]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is very similar to the above example. It starts off by declaring a 3-component
    vector named 'transformedP'. In the first line of the main() loop, instead of
    multiplying the vertex positions by 0.5, the new 3-component vector is being added
    to them.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上面的示例非常相似。它首先声明了一个名为'transformedP'的3分量向量。在main()循环的第一行，不是将顶点位置乘以0.5，而是将新的3分量向量添加到它们。
- en: The reason to use a 'vec3' in this example is that if 0.5 was simply added to
    'P', it would add 0.5 to the x-axis, 0.5 to the y-axis, and 0.5 to the z-axis.
    Creating a 'vec3' for these values allows control over each specific axis. In
    this example, adding 'vec3(1,0,0)' will only add 1 to the x-axis, leaving the
    y-axis and z-axis untouched. In practice, this moves the box 1 unit to the camera's
    right.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中使用'vec3'的原因是，如果简单地将0.5添加到'P'，它将分别添加0.5到x轴，0.5到y轴和0.5到z轴。为这些值创建'vec3'允许控制每个特定轴。在这个例子中，添加'vec3(1,0,0)'将仅在x轴上添加1，使y轴和z轴保持不变。实际上，这将把盒子移动到相机的右侧1个单位。
- en: We could just as easily change from addition to subtraction to move the box
    in the other direction.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地从加法改为减法，以将盒子移动到另一个方向。
- en: Now, let's reference an LFO CHOP from the vertex shader to animate the movement.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从顶点着色器中引用一个LFO CHOP来对移动进行动画处理。
- en: Open example 'Basic_3D_LFO.toe'.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例'Basic_3D_LFO.toe'。
- en: For this to be achieved, an LFO CHOP was created. The value of it's channel
    was then exported to the GLSL MAT's parameter 'value0x' in the 'Vectors 1' tab
    of the Parameter window. Then the Uniform was given a name, in this case 'lfoCHOP'.
    This means the value can now be accesed from within the vertex and pixel shaders.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，创建了一个LFO CHOP。然后，将其通道的值导出到参数窗口的'Vectors 1'选项卡中的GLSL MAT的参数'value0x'中。然后，给出了一个统一的名称，这种情况下是'lfoCHOP'。这意味着现在可以从顶点着色器和像素着色器中访问该值。
- en: 'The code in the vertex shader has been changed as follows:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器中的代码已更改如下：
- en: '[PRE29]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first addition is in the second line, where a 'uniform' is declared. A 'uniform'
    is a global GLSL variable that is mainly used for parameters that a user or program
    will pass into the shader.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个增加的是在第二行，声明了一个 'uniform'。 'uniform' 是一个全局的 GLSL 变量，主要用于用户或程序将传递到着色器的参数。
- en: In this example, the LFO CHOP channel is a float value, so then 'float' is added
    after 'uniform'. The name of the uniform is important, because it must correspond
    to the name entered in the 'Uniform Name' parameter in the GLSL MAT. In the GLSL
    MAT, we named the uniform 'lfoCHOP', so to access it, the same name must be used.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，LFO CHOP 通道是一个浮点值，所以在 'uniform' 后面添加了 'float'。 uniform 的名称很重要，因为它必须对应于在
    GLSL MAT 中输入的 'Uniform Name' 参数中输入的名称。 在 GLSL MAT 中，我们将 uniform 命名为 'lfoCHOP'，因此要访问它，必须使用相同的名称。
- en: The only other change is that where previously 1 was being added to the x-axis
    of the vertex position, there is now the value of 'lfoCHOP'.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的其他变化是先前在顶点位置的 x 轴上添加了 1，现在是 'lfoCHOP' 的值。
- en: '[PRE30]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With those small changes, a CHOP is controlling the x-axis position of the shader.
    Pixel shaders function in much of the same way as Vertex shaders. Let's assign
    the LFO CHOP in the previous example to control the red channel of the output
    color.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些小改动，一个 CHOP 控制着着色器的 x 轴位置。 像素着色器的功能方式与顶点着色器大致相同。 让我们将前面示例中的 LFO CHOP 分配给控制输出颜色的红色通道。
- en: Open example 'Basic_3D_red.toe'.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Basic_3D_red.toe'。
- en: In this example, the LFO CHOP is controlling the red channel of the pixel shader
    in much the same way that the LFO CHOP is controlling the x-axis transform.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，LFO CHOP 控制像素着色器中的红色通道，方式与 LFO CHOP 控制 x 轴变换类似。
- en: 'The code in the Pixel shader is below:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 像素着色器中的代码如下：
- en: '[PRE31]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Similarly to the x-axis transform example, the only steps needed were to declare
    the incoming uniform, and then to assign it to a parameter, in this case the first
    component of the vector. To take this another step furtuer, let's sample a Ramp
    TOP as the texture, instead of just outputting a single color.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 x 轴变换示例，唯一需要的步骤是声明传入的 uniform，然后将其分配给参数，在这种情况下是向量的第一个分量。 要再进一步，让我们将 Ramp
    TOP 作为纹理进行采样，而不仅仅是输出单一颜色。
- en: Open example 'Basic_3D_texture.toe'.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Basic_3D_texture.toe'。
- en: The first thing that was done was create the Ramp TOP and assign it to the GLSL
    MAT. The TOP needs to be referenced in the 'Samplers 1' tab in the Paramter window.
    In the same way that the LFO CHOP needed a 'Uniform Name', the Ramp TOP needs
    a 'Sampler Name', which in this case is 'rampTOP'.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是创建 Ramp TOP 并将其分配给 GLSL MAT。 TOP 需要在参数窗口的 'Samplers 1' 选项卡中引用。 与 LFO CHOP
    需要一个 'Uniform Name' 类似，Ramp TOP 需要一个 'Sampler Name'，在这种情况下是 'rampTOP'。
- en: Then a Texture SOP is added after the Box SOP to assign the texture co-ordinates.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 Box SOP 后面添加了一个 Texture SOP 来分配纹理坐标。
- en: 'In the Vertex shader, a few lines of code are added to assign the texture co-ordinates.
    These lines are added below:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中，添加了几行代码来分配纹理坐标。 这些行添加在下面：
- en: '[PRE32]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first line that is added is:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的第一行是：
- en: '[PRE33]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This line outputs a 2-component vector named 'texCoord0' which can be used in
    the pixel shader. In this case, they will be the texture UV co-ordinates.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码输出一个名为 'texCoord0' 的 2 组件向量，可以在像素着色器中使用。 在这种情况下，它们将是纹理 UV 坐标。
- en: 'There is one more additional line:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一行额外的内容：
- en: '[PRE34]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This line takes 'texCoord0' that was declared earlier, and assigns it the built-in
    TouchDesigner variable 'uv', which as mentioned earlier is declared by default
    and contains the UV texture co-ordinates (similar to 'P' for vertex position).
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码获取了之前声明的 'texCoord0'，并将其赋值给内置的 TouchDesigner 变量 'uv'，正如之前提到的，默认情况下由 'uv'
    声明，包含 UV 纹理坐标（类似于顶点位置的 'P'）。
- en: The '.st' here is assigning the two values contained in the 2-component vector
    'uv' to the 2 components of 'texCoord0'. As mentioned earlier, where '.xyzw' are
    used for vertex positions, '.stpq' are often used for texture co-ordinates. These
    are mostly just for convention so that the same letters (such as XYZW and RGBA)
    don't mean multiple different things. You may also see '.uv' used instead of '.st',
    depending on the software package.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 '.st' 正在将 2 组件向量 'uv' 中包含的两个值分配给 'texCoord0' 的 2 个分量。 正如前面提到的，'.xyzw' 用于顶点位置，'.stpq'
    经常用于纹理坐标。 这主要是为了约定，以便相同的字母（例如 XYZW 和 RGBA）不表示多个不同的东西。 可以根据软件包看到 '.uv' 而不是 '.st'。
- en: With these two extra lines of code, the Box SOP is now being textured by the
    Ramp TOP.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两行额外的代码，现在 Box SOP 正在被 Ramp TOP 纹理化。
- en: Shaders in 2D
  id: totrans-915
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2D 着色器
- en: '*12.5 Shaders in 2D*'
  id: totrans-916
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*12.5 2D 着色器*'
- en: Even if one doesn't want to spend a ton of time learning about GLSL for 3D use,
    the Pixel shader can be extremely useful as a tool for generative visuals and
    compositing 2D textures. Simple GLSL shaders can be especially useful when compositing
    textures, as it can save quite a lot of graphics memory when doing repititious
    work.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个人不想花费大量时间学习 GLSL 用于 3D 使用，像素着色器作为一种生成视觉和合成 2D 纹理的工具仍然非常有用。简单的 GLSL 着色器在合成纹理时尤其有用，因为在执行重复工作时可以节省相当多的图形内存。
- en: Let's take a look at an example of adding two TOPs together, similar to a Add
    TOP.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个类似于 Add TOP 的示例，将两个 TOP 添加在一起。
- en: Open example 'Basic_2D_add.toe'.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Basic_2D_add.toe'。
- en: 'Using the GLSL TOP, multiple TOP inputs can be composited, sampled, and effected
    in a GLSL pixel shader. In this example, a Movie In TOP and a Constant TOP are
    input into the GLSL TOP. The GLSL code in the pixel shader, adds them together:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GLSL TOP，可以在 GLSL 像素着色器中合成、采样和处理多个 TOP 输入。在这个示例中，Movie In TOP 和 Constant
    TOP 被输入到 GLSL TOP 中。像素着色器中的 GLSL 代码将它们相加：
- en: '[PRE35]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Working with Pixel shaders in the TOP family is very similar to working with
    them using a GLSL MAT. There is still a main() loop, the declarations happen first
    before the main() loop, and there are semi-colons at the end of working lines
    of code.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TOP 家族中使用像素着色器与使用 GLSL MAT 非常相似。仍然有一个主() 循环，声明首先发生在主() 循环之前，工作代码行的末尾有分号。
- en: 'The first difference to notice is how inputs are handled. In this example there
    are two inputs, and there are two lines that deal with those inputs:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意的第一个区别是如何处理输入。在这个示例中有两个输入，并且有两行处理这些输入：
- en: '[PRE36]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To get access to a TOP input, a 4-component variable must be declared for the
    RGBA channels. The texture() function is used to sample a texture. It takes two
    arguments, the first is the texture that it is going to sample, which in these
    cases are TOP inputs. The second argument is the texture co-ordinate to sample.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 TOP 输入，必须声明一个 4 组件变量，用于 RGBA 通道。texture() 函数用于采样纹理。它有两个参数，第一个是要采样的纹理，这些情况下是
    TOP 输入。第二个参数是要采样的纹理坐标。
- en: In this case, since TOP inputs are being sampled, the built-in sampler array
    named 'sTD2DInputs' is used. This array is accessed by index. In this case, there
    are two TOP inputs, so 'sTD2DInputs[0]' is used to access the first input, and
    'sTD2DInputs[1]' is used to access the second.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于正在对 TOP 输入进行采样，所以使用名为 'sTD2DInputs' 的内置采样器数组。此数组通过索引访问。在这种情况下，有两个 TOP
    输入，因此使用 'sTD2DInputs[0]' 访问第一个输入，使用 'sTD2DInputs[1]' 访问第二个。
- en: To access the proper texture co-ordinate, 'vUV.st' is used. 'vUV' is a built-in
    variable that contains the texture co-ordinates of the pixel. As mentioned, '.st'
    is used to access the first two components of the vector.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问正确的纹理坐标，使用 'vUV.st'。'vUV' 是一个内置变量，包含像素的纹理坐标。如前所述，'.st' 用于访问向量的前两个分量。
- en: 'Once the appropriate pixel is addressed from each input, this example procedes
    to add the pixels together, and output them to ''fragColor'', which is the defined
    output:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从每个输入中选取了适当的像素，这个示例就会将像素相加，并将它们输出到 'fragColor'，这是已定义的输出：
- en: '[PRE37]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As simple as that, a main functionality of the Add TOP has been replicated.
    This may seem like a round-about way of adding two textures, but the benefits
    of something as simple as this begin to become apparent when using more complicated
    workflows or the GLSL Multi TOP, which is fundamentaly the same as the GLSL TOP,
    except that it has an infinite number of TOP inputs (limited only by the graphics
    card).
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单，Add TOP 的一个主要功能已经被复制了。这似乎是一种处理两个纹理的迂回方式，但当使用更复杂的工作流程或 GLSL Multi TOP
    时，这种简单的东西的好处开始显现出来，GLSL Multi TOP 与 GLSL TOP 基本相同，只是它具有无限数量的 TOP 输入（仅受显卡限制）。
- en: Open example 'Basic_2D_multi.toe'.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Basic_2D_multi.toe'。
- en: This example expands on the previous example by adding together more sources.
    This is done by connecting all the sources into a GLSL Multi TOP, and then accesing
    them in the same way that the two inputs were accessed previously.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例扩展了之前示例的功能，通过将所有源连接到 GLSL Multi TOP，然后以与之前访问两个输入相同的方式访问它们来添加。
- en: In the shader of this example, each input takes the next index of 'sTD2DInputs'
    and assigns it to another 'vec4', after which they are all added together.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例的着色器中，每个输入都获取 'sTD2DInputs' 的下一个索引，并将其分配给另一个 'vec4'，然后将它们全部加在一起。
- en: Again, this might be useful, but a Composite TOP can add multiple inputs s well,
    so let's take it one step further.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这可能会很有用，但是复合 TOP 也可以添加多个输入，所以让我们再进一步。
- en: Open example 'Basic_2D_composite.toe'.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Basic_2D_composite.toe'。
- en: This example takes the previous example a step further. With all the inputs
    defined, instead of just adding all the inputs together, the GLSL code does a
    mix of addition, subtraction, and multiplication. Remembering the order of operations
    when working like this is key!
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例将上一个示例进一步扩展了一步。在定义了所有输入之后，GLSL 代码不仅仅是将所有输入相加，而是进行了加法、减法和乘法的混合。在像这样工作时记住操作顺序是关键！
- en: This is incredibly useful when working with a large number of textures, even
    if just 1920x1080, because doing a similar process with TOPs would take multiple
    Composite TOPs, or a number of Multiply, Add, and Subtract TOPs. Being able to
    manipulate all these textures, even in such simple methods, all at once can save
    quite a bit of GPU memory.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大量纹理时，即使只有 1920x1080，这也非常有用，因为使用 TOP 进行类似的处理将需要多个复合 TOP，或者一些乘法、加法和减法 TOP。即使是在这样简单的方法下，一次性操纵所有这些纹理也可以节省相当多的
    GPU 内存。
- en: Transforming the textures is very similar to transforming vertices in a vertex
    shader. Let's take a look at an example.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 转换纹理与在顶点着色器中转换顶点非常相似。让我们看一个例子。
- en: Open example 'Basic_2D_transform.toe'.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Basic_2D_transform.toe'。
- en: 'This example takes the previous example, and offsets a few of the textures.
    This is done by adding, subtracting, multiplying, and dividing the texture co-ordinate.
    Let''s examine the example code below:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例采用了上一个示例，并对其中的一些纹理进行了偏移。这是通过对纹理坐标进行加法、减法、乘法和除法来实现的。让我们来看一下下面的示例代码：
- en: '[PRE38]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the above example, three of the textures are being transformed. The first
    is being scaled up by a factor of two. To do this, 'vUV.st' is multiplied by 0.5\.
    This may seem backwards, but remember that 'vUV' is the texture co-ordinates,
    so when both x-axis and y-axis co-ordinates are moved to the right, the image
    moves to the left. Imagine having a finger pointing into the center of a piece
    of paper. If the finger position is moved to the right, the image will be more
    to the left of the finger than before. This is an overtly simple example, but
    should help get the idea across.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，有三个纹理正在被转换。第一个纹理被放大了两倍。为了实现这一点，'vUV.st' 被乘以 0.5。这可能看起来有些反直觉，但是请记住 'vUV'
    是纹理坐标，所以当 x 轴和 y 轴坐标都向右移动时，图像会向左移动。想象一下把手指指向纸的中心。如果把手指位置向右移动，图像就会比以前更靠近手指的左侧。这是一个非常简单的例子，但应该有助于理解。
- en: The third input, 'in3', has been translated on both x-axis and y-axis by subtracting
    0.5 from the x-axis, and 0.25 from the y-axis.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个输入，“in3”，在 x 轴和 y 轴上都被平移，x 轴上减去了 0.5，y 轴上减去了 0.25。
- en: The final input, 'in5', has been translated on the x-axis by adding 0.5 to the
    x-axis.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的输入，“in5”，在 x 轴上的平移是通过在 x 轴上添加 0.5 实现的。
- en: Both of these two tranformations also follow the same thought process mentioned
    for the first transformation. For example, when adding 0.5 to the x-axis texture
    co-ordinates, they are being added to the texture co-ordinates and not the position
    of the image. Thus when the texture co-ordinates move 0.5 on the x-axis, the image
    appears to move to the left.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种转换也遵循了第一种转换提到的相同思路。例如，当在 x 轴纹理坐标上加 0.5 时，它们被加到了纹理坐标上而不是图像的位置上。因此，当纹理坐标在 x
    轴上移动 0.5 时，图像会向左移动。
- en: The final example will be to take the previous exampleoutputs each individual
    layer to a separate color buffer instead of compositing them.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子将是对上一个示例的改进，将每个单独的图层输出到单独的颜色缓冲区而不是将它们合成在一起。
- en: Open example 'Basic_2D_buffers.toe'.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Basic_2D_buffers.toe'。
- en: 'The shader is as follows:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器如下所示：
- en: '[PRE39]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first line of the shader has been modified so that the output 'fragColor'
    is now an array. Each component of the array can be assigned a different texture,
    as has been done at the end of the shader. At which point, with the '# of Color
    Buffers' parameter for the GLSL Multi TOP set to 5, Render Select TOPs can be
    used to individually select each of the separate color buffers from inside of
    the GLSL Multi TOP using the. To do this, the 'Render or GLSL TOP' parameter references
    the GLSL Multi TOP, and the 'Color Buffer Index' parameter is set to the target
    color buffer.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行着色器已被修改，使得输出'fragColor'现在是一个数组。数组的每个分量可以被分配不同的纹理，就像在着色器的末尾所做的那样。在这一点上，通过将GLSL
    Multi TOP的'# of Color Buffers'参数设置为5，可以使用Render Select TOPs来从GLSL Multi TOP内部单独选择每个单独的颜色缓冲区。为此，'Render
    or GLSL TOP'参数引用GLSL Multi TOP，'Color Buffer Index'参数设置为目标颜色缓冲区。
- en: 'Assigning textures to the color buffers is similar to assigning textures to
    a single output, with the addition of the color buffer index:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 将纹理分配给颜色缓冲区类似于将纹理分配给单个输出，只是增加了颜色缓冲区索引：
- en: '[PRE40]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The number in the square brackets refers to the buffer being written to. In
    the above example, the first buffer is being written to.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号中的数字指的是正在写入的缓冲区。在上面的示例中，正在写入第一个缓冲区。
- en: Importing Shadertoy
  id: totrans-954
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入Shadertoy
- en: '*12.6 Importing Shaders from Shadertoy*'
  id: totrans-955
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*12.6 从Shadertoy导入着色器*'
- en: Chapter by Matthew Hedlin
  id: totrans-956
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 由Matthew Hedlin撰写的章节
- en: This section will demonstrate the basics of porting a shader from Shadertoy.com
    to TouchDesigner. We recommend using a feature-rich code editor, such as Sublime
    Text, Atom, or Notepad++, as there a strong Find-and-Replace function is essential.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将演示将着色器从Shadertoy.com移植到TouchDesigner的基础知识。我们建议使用功能丰富的代码编辑器，如Sublime Text、Atom或Notepad++，因为强大的查找和替换功能是必不可少的。
- en: Shadertoy API
  id: totrans-958
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Shadertoy API
- en: When porting a shader from Shadertoy to TouchDesigner, you can either use your
    judgement and find/make sources that work similary to the built-in inputs in Shadertoy,
    or you can download the sources that were used on Shadertoy using their API. To
    download the shader's input sources, you have to set up a Shadertoy account and
    create an 'App Key'.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 当将着色器从Shadertoy移植到TouchDesigner时，您可以根据自己的判断找到/创建与Shadertoy内置输入类似的源，或者可以使用Shadertoy的API下载在Shadertoy上使用的源。要下载着色器的输入源，您必须设置一个Shadertoy帐户并创建一个'App
    Key'。
- en: To create an ‘App Key’, once you’re logged into Shadertoy, click on `Profile`
    at the top right, then click on `your Apps` in the 'Config' section. Choose a
    name and description, and click the 'Create' button.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个'App Key'，一旦您登录到Shadertoy，点击右上角的`Profile`，然后在'Config'部分点击`your Apps`。选择一个名称和描述，然后点击'Create'按钮。
- en: You'll see the `App Key` in the 'Manage Your Apps' section. Now, copy this URL
    `https://www.shadertoy.com/api/v1/shaders/MdlGDM?key=` into your browser, and
    enter your App Key at the end.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在'Manage Your Apps'部分看到`App Key`。现在，将此URL `https://www.shadertoy.com/api/v1/shaders/MdlGDM?key=`
    复制到浏览器中，并在末尾输入您的App Key。
- en: After you press enter, the response will be a JSON object with a key called
    `inputs`. In this example, the URL above requires the file called `tex09.jpg`.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 按下回车后，响应将是一个名为`inputs`的JSON对象。在这个示例中，上面的URL需要名为`tex09.jpg`的文件。
- en: If you enter `https://www.shadertoy.com/presets/tex09.jpg`, as the URL in your
    browser, you will see and be able to download the required texture.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中输入`https://www.shadertoy.com/presets/tex09.jpg`，您将看到并能够下载所需的纹理。
- en: Swizzling
  id: totrans-964
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Swizzling
- en: Swizzling is the method of accessing the components of a vector. You'll come
    across this a few times in these examples.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: Swizzling是访问矢量组件的方法。在这些示例中，您会遇到几次这种情况。
- en: If there is a variable `vec4 color`, the 4 values of `color` are represented
    as `color.rgba`. If you want to access just the first 2 values of the vector you
    could use `color.rg` If you want to rearrange the values of the vector, you could
    write `color.bgar`
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个变量`vec4 color`，则`color`的4个值表示为`color.rgba`。如果您只想访问矢量的前两个值，可以使用`color.rg`。如果您想重新排列矢量的值，可以写成`color.bgar`
- en: There are equivalents to .rgba that do the exact same thing, but are generally
    used in different situations to provide clarity when reading the code.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 有与.rgba等效的内容，执行完全相同的操作，但通常在不同的情况下使用，以提供在阅读代码时的清晰度。
- en: In general, when referring to texture coordinates, `.stpq` is used. When referring
    to 3D coordinates, `.xyzw` are used.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在引用纹理坐标时，使用`.stpq`。在引用3D坐标时，使用`.xyzw`。
- en: While these conventions do the same thing, they can not be combined. To refer
    to the four values of `vec4 a` we could use `a.xyzw`, or `a.stpq`, but we could
    not use `a.stzw` This will create an error.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些约定执行相同的操作，但不能组合使用。要引用`vec4 a`的四个值，我们可以使用`a.xyzw`或`a.stpq`，但不能使用`a.stzw`。这将导致错误。
- en: Troubleshooting
  id: totrans-970
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 故障排除
- en: A common error encountered when converting Shadertoy shaders is related to the
    UV extend default. If you find the results of your shader don't match the results
    on the Shadertoy website, try setting the `Input Extend Mode UV` parameter of
    the 'GLSL' TOP to `Repeat`.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换Shadertoy着色器时遇到的常见错误与UV扩展默认值有关。如果发现您的着色器的结果与Shadertoy网站上的结果不匹配，请尝试将'GLSL'
    TOP的`Input Extend Mode UV`参数设置为`Repeat`。
- en: Swizzling
  id: totrans-972
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Swizzling
- en: Swizzling is the method of accessing the components of a vector. You'll come
    across this a few times in these examples.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: Swizzling是访问向量组件的方法。在这些示例中，您会遇到几次。
- en: If there is a variable `vec4 color`, the 4 values of `color` are represented
    as `color.rgba`. If you wanted to access just the first 2 values of the vector
    you would use `color.rg`. If you wanted to rearrange the values of the vector,
    you could write `color.bgar`
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个变量`vec4 color`，则`color`的4个值表示为`color.rgba`。如果您只想访问向量的前两个值，可以使用`color.rg`。如果您想重新排列向量的值，可以写成`color.bgar`
- en: There are equivalents to .rgba that do the exact same thing, but are generally
    used in different situations to provide clarity when reading the code.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 有与.rgba等效的方法，执行完全相同的操作，但通常在不同情况下使用，以提供代码阅读时的清晰度。
- en: In general, when referring to texture coordinates, `.stpq` is used. When referring
    to 3D coordinates, `.xyzw` are used.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 一般情况下，当涉及到纹理坐标时，使用`.stpq`。当涉及到3D坐标时，使用`.xyzw`。
- en: While these conventions do the same thing, they can not be combined. To refer
    to the four values of `vec4 a` we could use `a.xyzw`, or `a.stpq`, but we could
    not use `a.stzw`. This will create an error.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些约定执行相同的操作，但不能组合使用。要引用`vec4 a`的四个值，我们可以使用`a.xyzw`或`a.stpq`，但不能使用`a.stzw`。这将导致错误。
- en: 'Example 1: Waterly Video - Test'
  id: totrans-978
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例1：水视频 - 测试
- en: '![Example 1: Waterly Video - Test](ex1_1.jpeg)'
  id: totrans-979
  prefs: []
  type: TYPE_IMG
  zh: '![示例1：水视频 - 测试](ex1_1.jpeg)'
- en: 'Shader written by: [FabriceNeyret2](https://www.shadertoy.com/user/FabriceNeyret2)'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 由[FabriceNeyret2](https://www.shadertoy.com/user/FabriceNeyret2)编写的着色器
- en: '[https://www.shadertoy.com/view/MdlGDM](https://www.shadertoy.com/view/MdlGDM)'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.shadertoy.com/view/MdlGDM](https://www.shadertoy.com/view/MdlGDM)'
- en: Setup
  id: totrans-982
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置
- en: Start by creating a 'GLSL' TOP and an 'Info' DAT. Put the 'GLSL' TOP's name
    in the 'Info' DATs `Operator field`.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个'GLSL' TOP和一个'Info' DAT。将'GLSL' TOP的名称放入'Info' DAT的`Operator field`中。
- en: On the the 'GLSL' TOPs `Common` page, change the `Output Resolution` to `Custom`
    and then enter `1280` and `720` in the `Resolution` fields.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 在'GLSL' TOP的`Common`页面上，将`Output Resolution`更改为`Custom`，然后在`Resolution`字段中输入`1280`和`720`。
- en: Copy the code from Shadertoy and paste it into the `glsl1_pixel` DAT, replacing
    the code that was there by default.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 从Shadertoy复制代码并粘贴到`glsl1_pixel` DAT中，替换默认的代码。
- en: Now we need to set up the sources. For this example, we're just going to create
    two 'Movie File In' TOPs and select two pictures that are the same resolution
    as the 'GLSL' TOP (1280 x 720), ‘Mettler.3.jpg’ and 'Trillium.jpg'.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要设置来源。在这个示例中，我们将创建两个'Movie File In' TOP，并选择两张分辨率与'GLSL' TOP相同的图片（1280 x
    720），'Mettler.3.jpg'和'Trillium.jpg'。
- en: Main Function and its Parameters
  id: totrans-987
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主函数及其参数
- en: 'In Shadertoy, the main function and paramters are:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 在Shadertoy中，主函数和参数为：
- en: '`mainImage( out vec4 fragColor, in vec2 fragCoord )`'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '`mainImage( out vec4 fragColor, in vec2 fragCoord )`'
- en: 'but we''ll change that to:'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们将把它改为：
- en: '`main()`'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`'
- en: 'To replace the fragColor argument that we removed, we''ll go up to the top
    of the code and insert:'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 为了替换我们删除的fragColor参数，我们将回到代码顶部并插入：
- en: '`layout(location = 0) out vec4 fragColor;`'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '`layout(location = 0) out vec4 fragColor;`'
- en: Next, we'll search for all references to `fragCoord` and replace them with `gl_FragCoord`.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将搜索所有对`fragCoord`的引用，并将它们替换为`gl_FragCoord`。
- en: '` uniform vec3 Resolution;'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '` uniform vec3 Resolution;'
- en: uniform float iGlobalTime; `
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniform float iGlobalTime; `'
- en: Uniform Inputs
  id: totrans-997
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 统一输入
- en: Shadertoy contains a list of built-in uniform variables. You can view them on
    the Shadertoy website at the top of the code window by clicking an arrow labled
    'Shader Inputs', or you can click the '?' at the bottom right of the same code
    window to create a pop up window that contains 'Shadertoy Inputs' as well as other
    information. We will go through the main samplers and uniforms associated with
    Shadertoy shaders.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: Shadertoy 包含一系列内置的统一变量。您可以在 Shadertoy 网站的代码窗口顶部点击标有“Shader Inputs”箭头的箭头，或者您可以点击同一代码窗口右下角的“?”创建一个包含“Shadertoy
    Inputs”以及其他信息的弹出窗口。我们将介绍与 Shadertoy 着色器相关的主要采样器和统一变量。
- en: Samplers
  id: totrans-999
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 采样器
- en: Shadertoy has named their sampler inputs `iChannels`.These samplers can be images,
    videos, noise patterns, cube mabs, etc. The 'GLSL' TOP has a similar variable
    called `sTD2DInputs`. The Shadertoy samplers are individual numbered samplers,
    such as `iChannel0` and `iChannel1`. In TouchDesigner, `sTD2DInputs` is an array,
    so you can access an elements with a numeric index.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: Shadertoy 将它们的采样器输入命名为`iChannels`。这些采样器可以是图像、视频、噪声模式、立方体贴图等。'GLSL' TOP 有一个类似的变量称为`sTD2DInputs`。Shadertoy
    的采样器是单独编号的采样器，例如`iChannel0`和`iChannel1`。在 TouchDesigner 中，`sTD2DInputs` 是一个数组，因此您可以使用数字索引访问元素。
- en: Now, search through the code and wherever there is the a reference to `iChannel0`,
    replace that with `sTD2DInputs[0]`. Where there is a reference to `iChannel1`,
    replace that with `sTD2DInputs[1]`.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，搜索代码，并在任何引用`iChannel0`的地方，将其替换为`sTD2DInputs[0]`。在引用`iChannel1`的地方，将其替换为`sTD2DInputs[1]`。
- en: iGlobalTime
  id: totrans-1002
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: iGlobalTime
- en: 'To find out what type of uniform this needs to be, look at the list of ''Shader
    Inputs'' on Shadertoy mentioned previously. In the list, `iGlobalTime` is a float,
    so near the top of our code, below the `fragColor` declaration, we''ll write:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出这需要是什么类型的统一变量，请查看前面提到的 Shadertoy 的“Shader Inputs”列表。在列表中，`iGlobalTime` 是一个浮点数，因此在我们的代码顶部的`fragColor`声明下面，我们将写入：
- en: '`uniform float iGlobalTime;`'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniform float iGlobalTime;`'
- en: Next, we click on the 'GLSL' TOP in TouchDesigner, and go to the `Vectors 1`
    page in the parameter window.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们点击 TouchDesigner 中的“GLSL” TOP，并转到参数窗口中的“Vectors 1”页面。
- en: 'As the first `Uniform Name` we''ll write `iGlobalTime` and for the value we
    will reference TouchDesigner''s `seconds` member of the `absTime` class by entering:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个`Uniform Name`，我们将写入`iGlobalTime`，对于值，我们将引用 TouchDesigner 的`absTime`类的`seconds`成员，输入如下：
- en: '`absTime.seconds`'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: '`absTime.seconds`'
- en: 'It should look like this:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该看起来像这样：
- en: '![iGlobalTime : absTime.seconds](ex1_2.JPG)'
  id: totrans-1009
  prefs: []
  type: TYPE_IMG
  zh: '![iGlobalTime：absTime.seconds](ex1_2.JPG)'
- en: iResolution
  id: totrans-1010
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: iResolution
- en: 'iResolution is the resolution of the Shader on Shadertoy. If our resolution
    depended on one of our inputs, we could use TouchDesigner''s built-in array of
    objects:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: iResolution 是 Shadertoy 上着色器的分辨率。如果我们的分辨率取决于我们的输入之一，我们可以使用 TouchDesigner 的内置对象数组：
- en: '`uTD2DInfos[i].res`'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '`uTD2DInfos[i].res`'
- en: In this case you could add `.zw` on the end to retrieve the width and height
    in pixels, or you can add `.xy` to receive the result of 1.0 divided by the width
    and 1.0 divded by the height.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以在末尾添加`.zw`以检索像素的宽度和高度，或者您可以添加`.xy`以接收宽度的倒数和高度的倒数的结果。
- en: 'For this example, we will manually declare iResolution as a uniform. If we
    look at Shadertoy''s input list, we see that iResolution is a vec3\. Similar to
    iGlobalTime, we''ll first declare it in the code by going near the top of our
    code and writing the line:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将手动将 iResolution 声明为一个统一变量。如果我们查看 Shadertoy 的输入列表，我们会看到 iResolution
    是一个 vec3。类似于 iGlobalTime，我们首先在代码中声明它，方法是在代码的顶部附近编写以下行：
- en: '`uniform vec3 iResolution;`'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniform vec3 iResolution;`'
- en: Next, go to the `Vectors 1` page of the 'GLSL' TOPs parameters, and next to
    the second `Uniform Name`, enter `iResolution`. For its values, enter `1270` and
    `720`. We won't need the 3rd value of the vec3 for this, so we'll just leave the
    other 2 values as `0`
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，转到“GLSL” TOP 参数的“Vectors 1”页面，并在第二个`Uniform Name`旁边输入`iResolution`。对于其值，输入`1270`和`720`。对于这个
    vec3 的第三个值，我们不需要，所以我们将其他两个值保留为`0`。
- en: 'Your GLSL TOP should now compile successfully and look something like this
    :'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 GLSL TOP 现在应该成功编译并看起来像这样：
- en: '![Example 1 compiled](ex1_3.JPG)'
  id: totrans-1018
  prefs: []
  type: TYPE_IMG
  zh: '![示例1编译](ex1_3.JPG)'
- en: 'Example 2: Shard'
  id: totrans-1019
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例2：Shard
- en: '![Example 2: Shard](ex2_1.jpg)'
  id: totrans-1020
  prefs: []
  type: TYPE_IMG
  zh: '![示例2：Shard](ex2_1.jpg)'
- en: 'Shader written by: [simesgreen](https://www.shadertoy.com/user/simesgreen)'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器作者：[simesgreen](https://www.shadertoy.com/user/simesgreen)
- en: '[https://www.shadertoy.com/view/Xdf3zM](https://www.shadertoy.com/view/Xdf3zM)'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.shadertoy.com/view/Xdf3zM](https://www.shadertoy.com/view/Xdf3zM)'
- en: This example will take you a bit further, using cubemaps, creating a noise sampler,
    using sound, and adding mouse interaction.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将带您走得更远，使用立方贴图，创建噪声采样器，使用声音，并添加鼠标交互。
- en: Setup
  id: totrans-1024
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We will start off with a new TouchDesigner project and begin the same way we
    did for the last example.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: Create a 'GLSL' TOP and set its `Output Resolution` to `1280` and `720`.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: Create an 'Info' DAT and add a reference to the 'GLSL' TOP to it’s `Operator`
    parameter.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: Copy the code from Shadertoy into `glsl1_pixel`.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the shader on the Shadertoy website, at the bottom we can see
    that we require 3 inputs: a noise texture, a background image, and some sound/audio.'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: Noise Texture
  id: totrans-1030
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In Shadertoy there are 4 noise textures: a monochrome and color noise at a
    resolution of 64 x 64, and a monochrome and color noise with a resolution of 256
    x 256.'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, create a ''Noise'' TOP and set the resolution to 64 x 64
    in the `Common` settings. We can look at the noise texture on Shadertoy and estimate
    the settings. These are the settings you can use for now:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: '![Ex2: Noise](ex2_2.JPG)'
  id: totrans-1033
  prefs: []
  type: TYPE_IMG
- en: Background Image
  id: totrans-1034
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you click on ''iChannel1'' in Shadertoy, you''ll see it is a texture from
    the ''Cubemaps'' section. There is a link to the source:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.pauldebevec.com/Probes](http://www.pauldebevec.com/Probes)'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: Near the bottom of that page, are cube-format images that we can download. The
    LDR .tif image that matches the one used in the Shadertoy shader is at the bottom
    right, called `Uffizi.tif`. Download that image.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: Create a 'Movie File In' TOP in TouchDesigner and reference the downloaded file.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: Connect the new 'Movie File In' TOP to a 'Cube Map' TOP.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: Set the `Input Layout` to `Vertical Cross` and connect the 'Cube Map' TOP to
    the second input of `glsl1`.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: '![Ex2: Cube Map](ex2_3.JPG)'
  id: totrans-1041
  prefs: []
  type: TYPE_IMG
- en: Audio
  id: totrans-1042
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '''iChannel2'' in Shadertoy is set to a Soundcloud input, but we can use any
    audio that we''d like, inside of TouchDesigner. For now, we''ll just stick with
    the default audio track in the ''Audio File In'' CHOP.'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: We need to prepare the audio for the 'GLSL' TOP, since we can't directly connect
    an 'Audio' CHOP to a 'GLSL' TOP. Line 35 of the GLSL code is commented out, stating
    that you can use this line of code if you don't have audio, but we won't do that.
    In the next line, the variable `d` is looking for a `texture` with the comment
    `move planes with music`. The easiest way to achieve a simple version of this
    is to convert the 'Audio File In' CHOP into a texture.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: We only want one sample for this example, so put an 'Analyze' CHOP after the
    'Audio File In' CHOP and set the `Function` to `Maximum`.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: We may want to adjust this value later, so put a 'Null' CHOP after that.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: Now create a 'CHOP To' TOP that references the 'Null' CHOP. Set the `Data Format`
    to `R`.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: Connect the 'CHOP To' TOP to the third input of the 'GLSL' TOP.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: 'The network should look like this:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: '![Ex2: Audio](ex2_4.JPG)'
  id: totrans-1050
  prefs: []
  type: TYPE_IMG
- en: Now that the inputs are set up, we can take a look at the `Info` DAT and see
    what we'll need to change in the code.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: Main Function and fragColor
  id: totrans-1052
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First we''ll change the name of the main function from `mainImage` to `main`
    and remove the parameters, so instead of:'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '`void mainImage( out vec4 fragColor, in vec2 fragCoord )`'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '`void mainImage( out vec4 fragColor, in vec2 fragCoord )`'
- en: 'we should just have:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该只有：
- en: '`void main()`'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '`void main()`'
- en: 'Now, we have to replace the 2 parameters we removed from the main function:
    fragColor, and fragCoord. Go to the very top of the code and insert:'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须替换主函数中删除的 2 个参数：fragColor 和 fragCoord。转到代码的最顶部，并插入：
- en: '`layout(location = 0) out vec4 fragColor;`'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '`layout(location = 0) out vec4 fragColor;`'
- en: Now you can search for all references to `fragCoord` (there should only be one,
    which is in the first line of the main function) and replace it with the built
    in variable `gl_FragCoord`.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以搜索所有对 `fragCoord` 的引用（应该只有一个，即在主函数的第一行），并将其替换为内置变量 `gl_FragCoord`。
- en: Samplers
  id: totrans-1060
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 采样器
- en: iChannel0
  id: totrans-1061
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: iChannel0
- en: Similar to the last example, iChannel0 is a 2D input, so we'll find all `iChannel0`
    references and replace them with `sTD2DInputs[0]`. In GLSL 3.30 and later, we
    don’t need to use a different `texture()` function for different texture types,
    so use Find-and-Replace to replace all `texture2D` functions to `texture`. `texture2D`
    may will still work on some drivers, but will not on many so to ensure your shader
    works on all GPUs and driver versions, you'll want to change these. As of the
    latest update to this article, the shader correctly has `texture()` calls instead
    of `texture2D()`, so no changes are needed.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个示例类似，iChannel0 是一个 2D 输入，所以我们将找到所有 `iChannel0` 引用，并将其替换为 `sTD2DInputs[0]`。在
    GLSL 3.30 及更高版本中，我们不需要为不同的纹理类型使用不同的 `texture()` 函数，因此使用查找和替换将所有 `texture2D` 函数替换为
    `texture`。`texture2D` 在某些驱动程序上可能仍然有效，但在许多驱动程序上可能无效，因此为了确保您的着色器在所有 GPU 和驱动程序版本上都能正常工作，您需要进行这些更改。截至本文的最新更新，着色器正确地使用了
    `texture()` 调用而不是 `texture2D()`，因此不需要进行更改。
- en: '![Ex2: texture](ex2_5.JPG)'
  id: totrans-1063
  prefs: []
  type: TYPE_IMG
  zh: '![示例2：纹理](ex2_5.JPG)'
- en: iChannel1
  id: totrans-1064
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: iChannel1
- en: 'Changing the code for iChannel1 is similar to the edits for iChannel0, but
    the input is a cube map. TouchDesigner sorts the types of inputs for us: 2D, 3D,
    Cube, etc, into separate arrays. If this was another 2D inputs we would use sTD2DInputs[1],
    but since it’s a cube map (the first and only in our inputs) we use `sTDCubeInputs[0]`.'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 更改 iChannel1 的代码与 iChannel0 的编辑类似，但输入是一个立方体贴图。TouchDesigner 为我们对输入类型进行了排序：2D、3D、立方体等，分成不同的数组。如果这是另一个
    2D 输入，我们将使用 `sTD2DInputs[1]`，但由于它是一个立方体贴图（我们输入的第一个和唯一的），所以我们使用 `sTDCubeInputs[0]`。
- en: Similarly as mentioned for `iChannel0`, if the shader had `textureCube` calls,
    they should be changed to `texture`. It doesn't have those calls anymore though,
    so no changes are needed.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 与`iChannel0`提到的类似，如果着色器有 `textureCube` 调用，它们应该被更改为 `texture`。不过，现在着色器不再有这些调用，因此不需要进行更改。
- en: iChannel2
  id: totrans-1067
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: iChannel2
- en: iChannel2 is the audio. We converted the audio information into a 2D texture
    with the 'CHOP To' TOP. The 'CHOP To' TOP is the 3rd input, but it is the 2nd
    2D input, so we'll replace all `iChannel2` references with `sTD2DInputs[1]`.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: iChannel2 是音频。我们使用 'CHOP To' TOP 将音频信息转换为 2D 纹理。'CHOP To' TOP 是第 3 个输入，但它是第
    2 个 2D 输入，因此我们将所有 `iChannel2` 引用替换为 `sTD2DInputs[1]`。
- en: If you save the shader and look at the 'Info' DAT, you should have fixed all
    of the errors except for 'iMouse'.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存着色器并查看'Info' DAT，你应该已经修复了除了'iMouse'之外的所有错误。
- en: iMouse
  id: totrans-1070
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: iMouse
- en: 'To find out what we need in order to mimic Shadertoy''s iMouse uniform, we
    need to go back to the Shader Input list. Click the question mark at the bottom
    right of the window, and if you scroll down, you''ll find iMouse:'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解我们需要模仿 Shadertoy 的 iMouse 统一需要什么，我们需要回到 Shader Input 列表。点击窗口右下角的问号，如果向下滚动，你会找到
    iMouse：
- en: '![Ex2: iMouse Definition](ex2_8.JPG)'
  id: totrans-1072
  prefs: []
  type: TYPE_IMG
  zh: '![示例2：iMouse 定义](ex2_8.JPG)'
- en: '`iMouse` is a `vec4` with the 4 values defined as:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '`iMouse` 是一个 `vec4`，其 4 个值定义为：'
- en: '`xy = current pixel coords (if LMB is down). zw = click pixel`'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '`xy = 当前像素坐标（如果鼠标左键按下）。zw = 单击像素`'
- en: For now, we'll just set up the uniform with the basics so that the shader renders
    without errors. Add `iMouse` as a `Uniform Name` to the `Vectors 1` page of the
    'GLSL' TOP parameters, and set all the values to `0`.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需设置基本的统一，以便着色器无错误地渲染。在'GLSL' TOP参数的'Vectors 1'页面上将`iMouse`添加为`Uniform
    Name`，并将所有值设置为`0`。
- en: 'Now add:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加：
- en: '`uniform vec4 iMouse;`'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniform vec4 iMouse;`'
- en: after the other uniform declarations near the top of the code.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码顶部附近的其他统一声明之后。
- en: 'The ''GLSL'' TOP should now be free of errors, and should look something like
    this:'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '''GLSL'' TOP 现在应该没有错误，并且应该看起来像这样：'
- en: '![Ex2: iMouse success](ex2_9.JPG)'
  id: totrans-1080
  prefs: []
  type: TYPE_IMG
  zh: '![示例2：iMouse成功](ex2_9.JPG)'
- en: iMouse Functionality
  id: totrans-1081
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: iMouse 功能
- en: 'Let''s go back to the description of what iMouse does:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 iMouse 的描述：
- en: '`xy = current pixel coords (if LMB is down). zw = click pixel`'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: '`xy = 当前像素坐标（如果鼠标左键按下）。zw = 单击像素`'
- en: 'We can also see an example of iMouse in action in this shader:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在这个着色器中看到iMouse的示例运行：
- en: '[https://www.shadertoy.com/view/Mss3zH](https://www.shadertoy.com/view/Mss3zH).'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.shadertoy.com/view/Mss3zH](https://www.shadertoy.com/view/Mss3zH)。'
- en: So `.xy` are the coordinates of the mouse while the LMB is clicked. `.zw` are
    the coordinates of where the mouse was when it was first clicked. We'll have to
    set up a little CHOP network to re-create this data.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 所以`.xy`是鼠标在按下左键时的坐标。`.zw`是鼠标在第一次点击时的坐标。我们需要设置一个小的CHOP网络来重新创建这些数据。
- en: We could use the 'Mouse In' CHOP, but I'd like to only have the mouse only interact
    with the shader when it's deliberate.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用'Mouse In' CHOP，但我希望只有在有意时鼠标才与着色器交互。
- en: Create a 'Container' COMP, set the `Width` and `Height` to the same dimensions
    as the 'GLSL' TOP, which in this case are `1280` and `720`. Set the 'GLSL' TOP
    as the `Background` of the container in the panel settings. Now make a 'Panel'
    CHOP and set a reference to your container as the `Component` parameter.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个'Container' COMP，将`Width`和`Height`设置为与'GLSL' TOP相同的尺寸，本例中为`1280`和`720`。在面板设置中将'GLSL'
    TOP设置为容器的`Background`。现在创建一个'Panel' CHOP，并将您的容器设置为`Component`参数的引用。
- en: 'We''ll want to select 3 values from the ''Panel'' CHOP: `u`, `v`, and `lselect`.
    To do this, add 3 ''Select'' CHOPs and connect `panel1` to each one of them in
    parallel.'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要从'Panel' CHOP中选择3个值：`u`、`v`和`lselect`。为此，添加3个'Select' CHOP，并将`panel1`并行连接到每一个。
- en: In 'select1', under `Channel Names`, enter `u`. We'll rename right away, so
    in the `Rename From` field enter `u` and in the `Rename To` field enter `x`. In
    `select2`, select the `v` channel, and just like before, rename from `v` to `y`.
    For `select3`, we don't need to rename anything, so just enter `lselect` in the
    `Channel Names` field.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 在`select1`中，在`Channel Names`下，输入`u`。我们将立即重命名，因此在`Rename From`字段中输入`u`，在`Rename
    To`字段中输入`x`。对于`select2`，选择`v`通道，并像以前一样，从`v`重命名为`y`。对于`select3`，我们不需要重命名任何内容，所以只需在`Channel
    Names`字段中输入`lselect`。
- en: We'll need to convert these values from 0 - 1 values to the full resolution.
    Add a 'Math' CHOP after `select1` and set the `Multiply` parameter to `1280`.
    Add a `Math` CHOP after `select2` and set the `Multiply` parameter to `720`.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将这些值从0 - 1值转换为完整分辨率。在`select1`之后添加一个'Math' CHOP，并将`Multiply`参数设置为`1280`。在`select2`之后添加一个`Math`
    CHOP，并将`Multiply`参数设置为`720`。
- en: 'Now, create a ''Merge'' CHOP and connect `math1` and `math2` to it. As always,
    add a ''Null'' CHOP after that. So far, it should look like this:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个'Merge' CHOP并将`math1`和`math2`连接到它。像往常一样，在此之后添加一个'Null' CHOP。到目前为止，它应该看起来像这样：
- en: '![Ex2: iMouse Network](ex2_10.JPG)'
  id: totrans-1093
  prefs: []
  type: TYPE_IMG
  zh: '![Ex2: iMouse网络](ex2_10.JPG)'
- en: Now we have our '.xy' values, so now we need to set up the '.zw' values. We
    need to read the position of the mouse when the LMB is first clicked, and hold
    that value until LMB is released.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`.xy`值，现在我们需要设置`.zw`值。我们需要读取鼠标在第一次点击左键时的位置，并保持该值直到释放左键。
- en: 'To do this, create a ''Chop Execute'' DAT and set the `CHOP` field to `select3`.
    Turn the `Off to On` and `On to Off` toggles `on`, and set the `Value Change`
    toggle to `off`. Add a ''Constant'' CHOP to the network and in the first two `Name`
    fields, create the channels `z` and `w`. This should look like this:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，创建一个'Chop Execute' DAT并将`CHOP`字段设置为`select3`。打开`Off to On`和`On to Off`开关，并将`Value
    Change`开关设置为`off`。在网络中添加一个'Constant' CHOP，并在前两个`Name`字段中创建通道`z`和`w`。应该看起来像这样：
- en: '![Ex2: iMouse Constant CHOP](ex2_11.JPG)'
  id: totrans-1096
  prefs: []
  type: TYPE_IMG
  zh: '![Ex2: iMouse Constant CHOP](ex2_11.JPG)'
- en: When the LMB is clicked, we want to write the values of `null2` to the`z` and
    `w` channels of `constant1`, and when it's released, we want to set them back
    to `0`.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下左键时，我们希望将`null2`的值写入`constant1`的`z`和`w`通道，释放时，我们希望将它们设置回`0`。
- en: 'Add the following code snippet to the ''offToOn'' function:'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码片段添加到'offToOn'函数中：
- en: '[PRE41]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And add the following code to the ''onToOff'' function:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 并将以下代码添加到'onToOff'函数中：
- en: '[PRE42]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can use another 'Merge' CHOP to merge `constant1` with `null2` and add another
    'Null' CHOP after it. Go back to the 'GLSL' TOP and in the four `Value` fields
    of the `iMouse` uniform, you can reference the `x`, `y`, `z`, and `w` channels
    of `null3`. You can do this with Python references or exports.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用另一个'Merge' CHOP将`constant1`与`null2`合并，并在其后添加另一个'Null' CHOP。返回到'GLSL' TOP，在`iMouse`统一的四个`Value`字段中，您可以引用`null3`的`x`、`y`、`z`和`w`通道。您可以使用Python引用或导出来实现这一点。
- en: 'The ''Vectors 1'' page should now look like this:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '''Vectors 1''页面现在应该看起来像这样：'
- en: '![Ex2: Final iMouse Network](ex2_12.JPG)'
  id: totrans-1104
  prefs: []
  type: TYPE_IMG
  zh: '![Ex2: 最终iMouse网络](ex2_12.JPG)'
- en: If you view the container, you should now be able to click and drag to rotate
    around the Shard!
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看容器，现在应该能够点击并拖动以围绕Shard旋转！
- en: 'Example 3: Cyclic Cellular Automaton'
  id: totrans-1106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例3：循环细胞自动机
- en: '![Ex2: Example 3: Cyclic Cellular Automaton](ex3_1.jpg)'
  id: totrans-1107
  prefs: []
  type: TYPE_IMG
  zh: '![Ex2: 示例3：循环细胞自动机](ex3_1.jpg)'
- en: 'shader written by: [zolozulman](https://www.shadertoy.com/user/zolozulman)'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 由[zolozulman](https://www.shadertoy.com/user/zolozulman)编写的着色器
- en: '[https://www.shadertoy.com/view/4tV3Wd](https://www.shadertoy.com/view/4tV3Wd)'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.shadertoy.com/view/4tV3Wd](https://www.shadertoy.com/view/4tV3Wd)'
- en: Shadertoy has implemented the use of multiple buffers, separating functions
    into separate processes. This example demonstrates one way of importing these
    multi-pass shaders.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: Shadertoy已经实现了多个缓冲区的使用，将函数分离为单独的进程。这个示例演示了导入这些多通道着色器的一种方法。
- en: Setup
  id: totrans-1111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置
- en: Connect the Buffers
  id: totrans-1112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 连接缓冲区
- en: On the Shadertoy website, the previous examples only had one tab that contained
    code called 'Image'. This example has an 'Image' tab as well as a 'Buf A' tab.
    This means we'll have to use 2 different 'GLSL' TOPs to represent each of the
    shader functions or `buffers`.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Shadertoy网站上，以前的示例只有一个包含名为'Image'的代码选项卡。这个示例有一个'Image'选项卡和一个'Buf A'选项卡。这意味着我们将需要使用2个不同的'GLSL'
    TOP来表示每个着色器函数或`buffers`。
- en: Start by creating those, and setting both TOPs to have the resolution 1280 by
    720\. Set up an 'Info' DAT for each. Rename the 'GLSL' TOPs to match each buffer
    so we can keep track of which one is which.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建它们，并将两个TOP的分辨率设置为1280 x 720。为每个设置一个'Info' DAT。重命名'GLSL' TOP以匹配每个缓冲区，以便我们可以跟踪哪个是哪个。
- en: Now we can copy the code from each of the buffers and paste it into the corresponding
    `GLSL` pixel shaders.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从每个缓冲区复制代码，并将其粘贴到相应的`GLSL`像素着色器中。
- en: 'It should look like this:'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该是这样的：
- en: '![Ex2: Example 3: GLSL TOP per buffer](ex3_2.JPG)'
  id: totrans-1117
  prefs: []
  type: TYPE_IMG
  zh: '![Ex2: 示例3：每个缓冲区的GLSL TOP](ex3_2.JPG)'
- en: Noise and Feedback TOP
  id: totrans-1118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 噪声和反馈TOP
- en: '''iChannel0'' for ''Image'' is ''Buf A''. This means we can connect the output
    of our `Buf_A` ''GLSL'' TOP, to the first input of our `Image` ''GLSL'' TOP. If
    we click on the Shadertoy tab for ''Buf A'' we can see that `iChannel0` is a feedback
    of itself, `Buffer A`. Before we create that feedback loop, let’s work with `iChannel1`.
    ''iChannel1'' is a noise texture, so we can create a ''Noise'' TOP with the same
    settings as the previous example and connect it to second input of the `Buf_A`
    ''GLSL'' TOP.'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '''iChannel0''代表''Image''是''Buf A''。这意味着我们可以连接我们的`Buf_A` ''GLSL'' TOP的输出到我们的`Image`
    ''GLSL'' TOP的第一个输入。如果我们点击''Buf A''的Shadertoy选项卡，我们可以看到`iChannel0`是自身的反馈，`Buffer
    A`。在创建反馈循环之前，让我们先处理`iChannel1`。''iChannel1''是一个噪声纹理，所以我们可以创建一个与之前示例相同设置的''Noise''
    TOP，并将其连接到`Buf_A` ''GLSL'' TOP的第二个输入。'
- en: For the feedback loop, we can't connect the output of a top to the input of
    itself without creating a cook dependancy loop. Add a 'Feedback' TOP in the network.
    The 'Feedback' TOP needs an input so we can connect the 'Noise' TOP to the input,
    set the 'Target TOP' parameter to `Buf_A`, then connect the output to the first
    input of the `Buf_A` 'GLSL' TOP.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于反馈循环，我们不能将一个顶部的输出连接到自身的输入，否则会创建一个烹饪依赖循环。在网络中添加一个'Feedback' TOP。'Feedback'
    TOP需要一个输入，所以我们可以将'Noise' TOP连接到输入，将'Target TOP'参数设置为`Buf_A`，然后将输出连接到`Buf_A` 'GLSL'
    TOP的第一个输入。
- en: 'Our network should look like this:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络应该是这样的：
- en: '![Ex2: Example 3: Noise and Feedback](ex3_3.JPG)'
  id: totrans-1122
  prefs: []
  type: TYPE_IMG
  zh: '![Ex2: 示例3：噪声和反馈](ex3_3.JPG)'
- en: Main Function and fragColor
  id: totrans-1123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主函数和fragColor
- en: 'We''ll go through the same process as the previous examples: changing `mainImage`
    to `main`, removing the parameters inside the `()`, and declaring at the beginning:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以前示例的相同过程进行：将`mainImage`更改为`main`，删除`()`内的参数，并在开头声明：
- en: '`layout(location = 0) out vec4 fragColor;`'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: '`layout(location = 0) out vec4 fragColor;`'
- en: Next, go through both shaders and change all `fragCoord` references to `gl_FragCoord`.
    If we look at the 'Info' DATs, we can see an error about data types. That's because
    the main function call asked for 'vec2 fragCoord' but the built in 'gl_FragCoord'
    is a vec4.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，遍历两个着色器，并将所有的`fragCoord`引用更改为`gl_FragCoord`。如果我们查看'Info' DATs，我们可以看到关于数据类型的错误。这是因为主函数调用要求'vec2
    fragCoord'，但内置的'gl_FragCoord'是一个vec4。
- en: We'll need to go through the main function, and wherever we find `gl_FragCoord`
    variable without the `.x` or `.y` after it, we have to add `.xy`. (If you change
    it in the main function, it will be vec2's that are passed to the other functions,
    which is what we want). Remember, if the code is referencing 'gl_FragCoord.x'
    or 'gl_FragCoord.y' then we don't need to change it, since the `.x` and `.y` are
    selecting the float value from inside the vector already.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要遍历主函数，无论在哪里找到没有跟在其后的`.x`或`.y`的`gl_FragCoord`变量，我们都必须添加`.xy`。（如果在主函数中更改它，那么传递给其他函数的将是
    `vec2`，这是我们想要的）。记住，如果代码引用 'gl_FragCoord.x' 或 'gl_FragCoord.y'，那么我们就不需要更改它，因为 `.x`
    和 `.y` 已经选择了向量内的浮点值。
- en: 'This example only has 1 instance in each main function that needs to be changed.
    The main function for ''Buf_A'' should look like this:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子只有在每个主函数中需要更改的 1 个实例。 'Buf_A' 的主函数应该是这样的：
- en: '[PRE43]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'and the main function for `Image` should look like this:'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image`的主函数应该是这样的：'
- en: '[PRE44]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now we can go back up to the `Info` DAT and see what else needs to be changed.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以回到 `Info` DAT 看看还有什么需要改变的。
- en: iResolution, iGlobalTime, iMouse, and iFrame
  id: totrans-1133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`iResolution`、`iGlobalTime`、`iMouse` 和 `iFrame`'
- en: Both `Buf_A` and `Image` require the declaration of `iResolution` and `iGlobalTime`,
    which we've done before, so we'll go ahead and add these to both. We need ` uniform
    vec3 Resolution;
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Buf_A` 和 `Image` 都需要声明 `iResolution` 和 `iGlobalTime`，我们之前已经做过了，所以我们将继续将这些添加到两者中。我们需要
    `uniform vec3 Resolution;`'
- en: uniform float iGlobalTime; `
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniform float iGlobalTime;`'
- en: at the top of both pixel shaders, and we'll need to add both uniforms to the
    'Vectors 1' page of the 'GLSL' TOP’s parameters.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个像素着色器的顶部，并且我们需要将这两个统一变量添加到 'GLSL' TOP 参数的 'Vectors 1' 页面中。
- en: 'If we look at the `Info` DAT for `Buf_A`, we see a new undefined variable:
    ''iFrame''. This uniform is a frame counter and we can either reference `absTime.frame`
    or `me.time.frame`, depending on whether want the frame counter to loop with the
    timeline or not. For this example, we use `absTime.frame` as the expression for
    the first value of the uniform, because we don’t want the looping of timeline
    to effect the shader.'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`Buf_A`的`Info` DAT，我们会看到一个新的未定义变量：'iFrame'。这个统一变量是一个帧计数器，我们可以使用`absTime.frame`或`me.time.frame`来引用，取决于是否希望帧计数器与时间轴循环。在这个例子中，我们使用`absTime.frame`作为统一变量第一个值的表达式，因为我们不希望时间轴的循环影响着色器。
- en: Next, we can copy and paste the same network we created for iMouse in the previous
    example, and declare the uniform in the exact same way.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以复制并粘贴我们在上一个示例中为 `iMouse` 创建的相同网络，并以完全相同的方式声明统一变量。
- en: iChannels
  id: totrans-1139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`iChannels`'
- en: The only thing left to convert, is changing any references of `iChannel0` to
    `sTD2DInputs[0]` and `iChannel1` to `sTD2DInputs[1]`. You can do this for both
    pixel shaders.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下要转换的是，将所有的`iChannel0`引用改为`sTD2DInputs[0]`，将`iChannel1`改为`sTD2DInputs[1]`。你可以在两个像素着色器中都这样做。
- en: 'Both of your ''GLSL'' TOPs should be working now, and your network might look
    something like this: ![Ex2: Example 3: Noise and Feedback](ex3_4.JPG)'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: '你的两个 ''GLSL'' TOP 现在应该可以工作了，你的网络可能看起来像这样：![Ex2: Example 3: Noise and Feedback](ex3_4.JPG)'
- en: GPU Particle Systems
  id: totrans-1142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPU 粒子系统
- en: '*12.7 GPU Particle Systems*'
  id: totrans-1143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*12.7 GPU 粒子系统*'
- en: '*12.7.1 Introduction*'
  id: totrans-1144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*12.7.1 介绍*'
- en: This tutorial will be focused on creating a GPU based particle system using
    TouchDesigner and GLSL shaders. This has many benefits compared to using the built-in
    Particle SOP, because all the computations inside of GLSL shader are performed
    on the GPU. GLSL shaders allow for the creation of particles systems with extremely
    large particle counts (in the multi-millions and more), with customized behaviour,
    that still compute quickly.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将专注于使用 TouchDesigner 和 GLSL 着色器创建基于 GPU 的粒子系统。与使用内置的 Particle SOP 相比，这具有许多优点，因为
    GLSL 着色器内的所有计算都在 GPU 上执行。GLSL 着色器允许创建具有极大粒子数（以千万甚至更多计）的粒子系统，具有自定义行为，但仍然能够快速计算。
- en: The process to achieve a particle system in GLSL can be slightly confusing at
    first, compared to just creating a Particle SOP, but once you understand the basic
    principles behind the workflow, you will have infinite freedom to experiment.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GLSL 中实现粒子系统的过程一开始可能会有点令人困惑，与创建 Particle SOP 相比，但是一旦你理解了工作流背后的基本原理，你就会有无限的自由进行实验。
- en: One concept to understand is that the GLSL material shader we'll be using cannot
    create new points out of thin air, so you have to feed it a set a starting points
    that correspond to the maximum number of particles in your system. The amount
    of points feeding in determine the number of times our material shader will compute
    and the shader code we write will be applied to every single particle individually.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 一个要理解的概念是，我们将使用的GLSL材质着色器不能从空气中创建新的点，因此您必须向其提供一组起始点，这些点对应于您系统中的最大粒子数量。输入的点的数量决定我们的材质着色器将计算的次数，我们编写的着色器代码将应用于每个单独的粒子。
- en: A second important concept to remember is that similar to any other type of
    shader, your code has no reference to anything other than the current point it
    is processing. The shader will not have a reference of the previous or next frame,
    and wont have any reference to any points that have been computed on that same
    frame. All the shader code will need to be standalone and any referential data
    will need to be fed to the shader as either a texture or value uniform. A uniform
    is a parameter or value that you will pass to your shader code. This is important
    because the particles in a particle systems need to know their previous position
    at last compute, so that they can then re-apply their code to compute their new
    position on the next frame. In other OpenGL applications, you'd create multiple
    texture buffers that you would ping-pong between reading and writing. In TouchDesigner,
    this be solved by using a simple feedback loop.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重要的概念要记住的是，与任何其他类型的着色器一样，您的代码除了处理当前点之外没有任何其他内容的引用。该着色器将不会引用上一帧或下一帧，也不会引用在同一帧上计算的任何点。所有的着色器代码都需要是独立的，并且任何引用数据都需要作为纹理或值统一地提供给着色器。统一是您将传递给着色器代码的参数或值。这很重要，因为粒子系统中的粒子需要知道它们上一次计算时的前一个位置，这样它们就可以在下一帧上重新应用它们的代码来计算它们的新位置。在其他OpenGL应用程序中，您会创建多个纹理缓冲区，您将在读取和写入之间来回跳动。在TouchDesigner中，这可以通过使用一个简单的反馈循环来解决。
- en: To achieve the goal of creating a fully-functioning GPU particle system, we
    will break the particle system into a number of incremental projects.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现创建一个完全功能的GPU粒子系统的目标，我们将粒子系统分解为多个增量项目。
- en: '*12.7.2 Moving Particles with Textures*'
  id: totrans-1150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*12.7.2 使用纹理移动粒子*'
- en: 'Before getting started, this is an outline of the steps to this section:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，这是本节步骤的概述：
- en: Create a set of points that will be your initial positions
  id: totrans-1152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一组点，这将是您的初始位置。
- en: Add a point index to each point
  id: totrans-1153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个点添加一个点索引。
- en: Use a Noise TOP to create 1000 RGBA channels to use as point positions
  id: totrans-1154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Noise TOP创建1000个RGBA通道，用作点位置。
- en: Create a GLSL TOP to scale the values of the Noise TOP (will be built upon later
    after we remove the noise)
  id: totrans-1155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个GLSL TOP来缩放噪声TOP的值（在删除噪声后将在稍后构建）。
- en: Create a basic render setup
  id: totrans-1156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基本的渲染设置。
- en: Create a GLSL Mat that will hold all of the shader code for the particles
  id: totrans-1157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将容纳所有粒子的着色器代码的GLSL Mat。
- en: Create a basic pixel shader to shade all pixels white
  id: totrans-1158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基本的像素着色器，以将所有像素着色为白色。
- en: Create a vertex shader with uniform inputs and correct outputs
  id: totrans-1159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有统一输入和正确输出的顶点着色器。
- en: Get the pointIndex, point position texture, and then the points per instance
  id: totrans-1160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取点索引、点位置纹理，然后每个实例的点数。
- en: Sample the Noise TOP texture and create UV co-ordinates
  id: totrans-1161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对噪声TOP纹理进行采样并创建UV坐标。
- en: Move the incoming points from using all the above steps
  id: totrans-1162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用以上所有步骤移动传入的点。
- en: The first thing we need to do is create a set of points that will be used by
    the GLSL MAT as the particles. As mentioned earlier, a GLSL MAT cannot create
    particles on its own. It is simply a bit of code that gets applied onto every
    point that is given to it. For the particle system this means that we need a piece
    of geometry with 1000 points to have a particle system with 1000 points. Similarly
    if we wanted a particle system with 1,000,000 points, we would need a piece of
    geometry with 1,000,000 points. To start simply, we're going to generate 1000
    points at the origin 0,0,0.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一组点，GLSL MAT将使用这些点作为粒子。如前所述，GLSL MAT不能自行创建粒子。它只是一小段代码，应用到每个给定的点上。对于粒子系统，这意味着我们需要一个包含1000个点的几何体来构建一个包含1000个点的粒子系统。类似地，如果我们想要一个包含1,000,000个点的粒子系统，我们将需要一个包含1,000,000个点的几何体。为了开始简单，我们将在原点0,0,0处生成1000个点。
- en: You can follow along with the explanation below by opening example '01_Moving_particles_with_textures.toe'.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打开示例'01_Moving_particles_with_textures.toe'来跟随下面的解释。
- en: Start by creating an 'Add SOP' and clicking the first checkbox in the parameter
    window to enable 'Point 0'. The default values of 'Point 0' will work for this
    example. This creates our first point. Connect the output of the 'Add SOP' to
    the first input of a 'Copy SOP'. The 'Copy SOP' is used to copy the first point
    created by the 'Add SOP', giving us more points for our particle system. Do this
    by changing the 'Number of Copies' parameter of the 'Copy SOP' to 1000\. Now we
    have 1000 points to create a 1000 point particle system.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 从创建一个'Add SOP'并点击参数窗口中的第一个复选框以启用'Point 0'开始。'Point 0'的默认值适用于此示例。这样就创建了我们的第一个点。将'Add
    SOP'的输出连接到'Copy SOP'的第一个输入。'Copy SOP'用于复制'Add SOP'创建的第一个点，为我们的粒子系统提供更多的点。通过将'Copy
    SOP'的'Number of Copies'参数更改为1000来完成此操作。现在我们有1000个点来创建一个1000个点的粒子系统。
- en: Connect the ouput of the 'Copy SOP' to the first input of another 'Add SOP'.
    This 'Add SOP' will be used to close the points and create a polygon. This is
    to create a polygon from our 1000 points that can be converted into particles
    before entering the shader. To do this, in the new 'Add SOP' (which should be
    named 'add2' if you're using the default operator names) go to the 'Polygons'
    tab in the parameter window, and add an asterix ('*') to the first parameter named
    'Polygon'. Now we'll convert this 1000 point poygon into particles. Do this by
    connecting the output of the second 'Add SOP' ('add2') to a 'Convert SOP'. In
    the new 'Convert SOP', change the parameter named 'Convert To' to have the value
    of 'Particles' and change the parameter named 'Particle Type' to 'Render as Point
    Sprites'. Creating point sprites allows us to use a single line of shader code
    to increase the particle size later.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 将'Copy SOP'的输出连接到另一个'Add SOP'的第一个输入。此'Add SOP'将用于关闭点并创建多边形。这是为了从我们的1000个点创建一个多边形，该多边形可以在进入着色器之前转换为粒子。要做到这一点，在新的'Add
    SOP'（如果您使用默认运算符名称，它应该被命名为'add2'）中，转到参数窗口中的'Polygons'选项卡，并在名为'Polygon'的第一个参数中添加一个星号（'*'）。现在我们将把这个1000点多边形转换成粒子。通过将第二个'Add
    SOP'（'add2'）的输出连接到'Convert SOP'来完成此操作。在新的'Convert SOP'中，将名为'Convert To'的参数更改为值为'Particles'，并将名为'Particle
    Type'的参数更改为'Render as Point Sprites'。创建点精灵使我们可以使用单行着色器代码稍后增加粒子大小。
- en: 'The final step before creating out material is to create an additional custom
    attribute using the point indices. To do this, connect the output of the ''Convert
    SOP'' to a ''Point SOP''. Set the first ''Custom Attrib'' name to ''pointIndex''.
    Select ''float'' as the data type from the dropdown to the right of the name field.
    Expand the ''Value'' field, and in the first parameter field named ''custom1val1'',
    enter the Python script:'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 创建材质之前的最后一步是使用点索引创建一个额外的自定义属性。要做到这一点，将'Convert SOP'的输出连接到'Point SOP'。将第一个'Custom
    Attrib'名称设置为'pointIndex'。从名称字段右侧的下拉菜单中选择'float'作为数据类型。展开'Value'字段，并在命名为'custom1val1'的第一个参数字段中输入Python脚本：
- en: '[PRE45]'
  id: totrans-1168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'What this does is create a custom attribute on each point that we can use in
    the GLSL code. In this case, we''ve taken the point index of each point, and assigned
    it to a float value named ''pointIndex''. Now we''ve finished the first two steps,
    and we have 1000 particles that we will feed into the GLSL MAT. This should look
    like this (Note: You will not see anything in your SOP viewers at this stage unless
    you activate different display options to make points visible!):'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '这样做的作用是在每个点上创建一个自定义属性，我们可以在GLSL代码中使用。在这种情况下，我们已经获取了每个点的点索引，并将其分配给了名为''pointIndex''的浮点值。现在我们已经完成了前两个步骤，我们有了1000个粒子，我们将把它们馈送到GLSL
    MAT中。这应该看起来像这样（注意：在此阶段，除非您激活不同的显示选项使点可见，否则您在SOP查看器中看不到任何内容！）:'
- en: '![](step1_2.PNG)'
  id: totrans-1170
  prefs: []
  type: TYPE_IMG
  zh: '![](step1_2.PNG)'
- en: 'The next thing we''re going to do is create some noise that we will use as
    our point positions. The first thing to do is create a ''Noise TOP''. In the ''Common''
    parameters, change the resolution to 1000 pixels by 1 pixels and the ''Pixel Format''
    to ''32-bit float (RGBA)''. This gives us one pixel of noise for every particle
    we have (1000 pixels of noise for 1000 particles). Changing the ''Pixel Format''
    to ''32-bit float (RGBA)'' means that every pixel will have 32-bits per color
    channel, meaning a lot more precise data can be held in each color channel. The
    next step is to set the ''Monochrome'' parameter to ''off''. This returns a different
    noise value for each of the color channels, which will be translated into different
    noise values for our X,Y,Z positions of the particles. You can then choose to
    animate the noise however you like for the example, but the easiest is the add
    the following code to the ''Translate'' parameter''s ''tx'' value:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的是创建一些噪声，我们将用作我们的点位置。首先要做的是创建一个'Noise TOP'。在'Common'参数中，将分辨率更改为 1000
    像素乘以 1 像素，并将'Pixel Format'更改为'32 位浮点（RGBA）'。这为我们提供了每个粒子一个像素的噪声（1000 个像素的噪声对应于
    1000 个粒子）。将'Pixel Format'更改为'32 位浮点（RGBA）'意味着每个像素将每个颜色通道有 32 位，这意味着每个颜色通道中可以保存更精确的数据。接下来的步骤是将'Monochrome'参数设置为'off'。这将为每个颜色通道返回不同的噪声值，这些值将被转换为我们粒子的
    X、Y、Z 位置的不同噪声值。您可以选择以任何您喜欢的方式对噪声进行动画处理，但最简单的是将以下代码添加到'Translate'参数的 'tx' 值中：
- en: '[PRE46]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will transform the noise along the X axis, which will create a ribbon-effect
    on the initial particle system. Next we''re going to create a ''GLSL TOP'' that
    will allow us to have more fine tuned control over the current noise values in
    each color channel. We''ll be able to scale those values, and then in further
    sections, expand on the same shader to add more functionality. Connect the output
    of the ''Noise TOP'' to the first input of a ''GLSL TOP''. The ''GLSL TOP'' is
    created by default with a ''Text DAT'' docked to it, with a default shader that
    outputs the color white. Edit the ''Text DAT'', erase the existing code, add the
    code below, and then save it:'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将沿 X 轴转换噪声，从而在初始粒子系统上创建带状效果。接下来，我们将创建一个'GLSL TOP'，这将使我们能够对每个颜色通道中的当前噪声值进行更精细的控制。我们将能够缩放这些值，并且在进一步的部分中，扩展相同的着色器以添加更多功能。将'Noise
    TOP'的输出连接到'GLSL TOP'的第一个输入。'GLSL TOP'默认创建时带有连接到其上的'Text DAT'，其中包含一个默认着色器，输出白色。编辑'Text
    DAT'，删除现有代码，添加下面的代码，然后保存：
- en: '[PRE47]'
  id: totrans-1174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We'll quickly review the code above, but please refer to previous sections in
    this chapter. We first setup the main output 'fragColor'. We then sample the texture
    at the current UV. Because we setup the 'Noise TOP' to have the same number of
    pixels as there are particles, we can then sample the pixels on a one to one basis
    for each particle. After we sample the current pixel, we scale the R and G channels
    (the X and Y of the vec4) by 5.0 and then translate them 2.5 units to the left
    and down of the camera. We then we scale the B channel (the Z of the vec4) by
    -5.0, and then translate it 20 units away from the camera to fit the whole particle
    system in the scene. We can leave the alpha channel at 1.0 as we currently wont
    be using it.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会快速回顾上面的代码，但请参考本章的前几节。我们首先设置了主输出'fragColor'。然后我们在当前 UV 处对纹理进行采样。因为我们设置了'Noise
    TOP'与粒子数量相同的像素数，所以我们可以按照每个粒子的一对一方式对每个粒子进行像素采样。在采样当前像素后，我们将 R 和 G 通道（vec4 的 X 和
    Y）缩放了 5.0 倍，然后将它们向左下移动 2.5 个单位的摄像机。然后我们将 B 通道（vec4 的 Z）缩放了 -5.0 倍，然后将其移动 20 个单位远离摄像机，以适应场景中的整个粒子系统。我们可以将
    alpha 通道保留为 1.0，因为我们当前不会使用它。
- en: After the scaling and translating, the 'outPosition' is assigned to the 'fragColor'
    output. If you'd like to see the positions that the particles will be receiving,
    you can connect the 'GLSL TOP' to a 'TOP to CHOP' operator and view each color
    channels values. This finishes step 3 and 4 of the item list.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放和平移之后，将'outPosition'分配给'fragColor'输出。如果您想看到粒子将接收的位置，您可以将'GLSL TOP'连接到'TOP
    to CHOP'运算符，并查看每个颜色通道的值。这完成了项目列表的第 3 和第 4 步。
- en: '![Particle](step3_4.PNG)'
  id: totrans-1177
  prefs: []
  type: TYPE_IMG
  zh: '![粒子](step3_4.PNG)'
- en: Now create a basic render setup by adding a 'Camera COMP', a 'Light COMP', a
    'Geometry COMP', and a 'Render TOP'. They can all be set to their default values
    for this exercise. Make sure to add an 'In SOP' to the 'Geometry COMP' so that
    you can input your set of points and turn on the render and display flags on the
    'In SOP' inside of the 'Geometry COMP'. That will complete step 5.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过添加一个'Camera COMP'、一个'Light COMP'、一个'Geometry COMP'和一个'Render TOP'来创建一个基本的渲染设置。它们可以都设置为默认值以供本练习使用。确保在'Geometry
    COMP'上添加一个'In SOP'，这样你就可以输入你的点集，并在'Geometry COMP'内部的'In SOP'上打开渲染和显示标志。这将完成步骤
    5。
- en: '![Particle 2](step5.PNG)'
  id: totrans-1179
  prefs: []
  type: TYPE_IMG
  zh: '![第二粒子](step5.PNG)'
- en: Next, create a 'GLSL MAT' operator, an 'Info DAT', and two 'Text DAT''s. Reference
    the 'GLSL MAT' in the 'Info DAT''s 'Operator' parameter to help debug any errors.
    Name one of the 'Text DAT''s 'vertex' and the other 'pixel'. These will be the
    GLSL vertex and pixel shaders. Reference 'vertex' in the 'GLSL MAT''s 'Vertex
    Shader' parameter, and reference 'pixel' in the 'GLSL MAT''s 'Pixel Shader' parameter.
    Then we need to reference the 'GLSL TOP' we created. To do so, on the 'Samplers
    1' parameter page of the 'GLSL MAT', add 'sPointPosition' to the first 'Sampler
    Name' parameter, and add the name of the noise texture to the first 'TOP' parameter.
    In the example file, a 'Null TOP' named 'null1' was added after the 'GLSL TOP',
    and that is the operator name that is referenced in the 'TOP' parameter. Be very
    careful with the 'Sampler Name' parameter, as this will the name used in the code
    and if it is different than the code, you won't see any outputs as you won't be
    able to reference the particle position. Finally, on the 'Vectors 1' page of the
    'GLSL MAT', add 'uPointsPerInstance' to the first 'Uniform Name', and enter '1.0
    / 1000' as the first value of the parameter 'value0x'. This last vector will be
    used in the shader to scale the point index from 0-1000 to the normalized 0.0
    to 1.0 UV co-ordinate when sampling the point position noise texture. With that
    setup complete, we can move from step 6 to step 7.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个 'GLSL MAT' 运算符，一个 'Info DAT'，和两个 'Text DAT'。在 'Info DAT' 的 'Operator'
    参数中引用 'GLSL MAT' 以帮助调试任何错误。将其中一个 'Text DAT' 命名为 'vertex'，另一个命名为 'pixel'。这些将是 GLSL
    顶点和像素着色器。在 'GLSL MAT' 的 'Vertex Shader' 参数中引用 'vertex'，在 'GLSL MAT' 的 'Pixel Shader'
    参数中引用 'pixel'。然后，我们需要引用我们创建的 'GLSL TOP'。要做到这一点，在 'GLSL MAT' 的 'Samplers 1' 参数页面上，将
    'sPointPosition' 添加到第一个 'Sampler Name' 参数中，并将噪声纹理的名称添加到第一个 'TOP' 参数中。在示例文件中，'GLSL
    TOP' 之后添加了一个名为 'null1' 的 'Null TOP'，这是在 'TOP' 参数中引用的运算符名称。非常小心 'Sampler Name'
    参数，因为这将是代码中使用的名称，如果与代码不同，你将无法引用粒子位置而看不到任何输出。最后，在 'GLSL MAT' 的 'Vectors 1' 页面上，将
    'uPointsPerInstance' 添加到第一个 'Uniform Name' 中，并将 '1.0 / 1000' 输入为参数 'value0x' 的第一个值。这个最后的向量将用于在着色器中将点索引从
    0-1000 缩放到标准化的 0.0 到 1.0 UV 坐标时采样点位置噪声纹理。设置完成后，我们可以从步骤 6 移动到步骤 7。
- en: '![](step6.PNG)'
  id: totrans-1181
  prefs: []
  type: TYPE_IMG
  zh: '![](step6.PNG)'
- en: 'From here, we will finish all the remaining steps in the GLSL shaders. First,
    edit ''pixel'', the ''Text DAT'' we will use to hold the pixel shader, and enter
    the follow:'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们将在 GLSL 着色器中完成所有剩余的步骤。首先，编辑'pixel'，我们将用来保存像素着色器的 'Text DAT'，并输入以下内容：
- en: '[PRE48]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is a very basic pixel shader as we've seen earlier in the chapter, and
    all it does is shade any incoming pixels white. This completes step 7.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的像素着色器，正如我们之前在本章中看到的那样，它只是将任何传入的像素着色为白色。这完成了步骤 7。
- en: 'Edit ''vertex'', the ''Text DAT'' we will use to hold the vertex shader and
    enter the following:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 'vertex'，我们将用来保存顶点着色器的 'Text DAT' 并输入以下内容：
- en: '[PRE49]'
  id: totrans-1186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Once you enter and save that code, you will see the particle system creating
    a ribbon-effect using the generated noise. Let's go through this vertex shader.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你输入并保存了这段代码，你将看到粒子系统使用生成的噪声创建了一个带状效果。让我们来看一下这个顶点着色器。
- en: 'The first 4 lines setup the noise texture as a ''uniform sampler2D'', the ''uPointsPerInstance''
    value as a ''uniform float'', and the incoming point index attribute as an incoming
    float:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 前 4 行设置噪声纹理为 'uniform sampler2D'，将 'uPointsPerInstance' 值设置为 'uniform float'，并将传入的点索引属性设置为传入的浮点数：
- en: '[PRE50]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The next few lines in the code create the UV to use when sampling the noise
    texture. To create the X location of the UV, we first take the incoming point
    index and multiply it by 'uPointsPerInstance', which is 1 / 1000\. This gives
    us the location to sample from the 0.0 to 1.0 range. A key thing to remember when
    creating UV's manually is that the UV co-ordinates have infinite precision, so
    a UV of 0 along the X axis isn't the first pixel, it is the left edge of the first
    pixel, which will cause visual errors as the shader will then interpolate 50\%
    of the first pixel and 50\% of whatever is to the left of the first pixel (depending
    on the repeat parameters set). Because of this, we need to offset our sample by
    half of the sample step 'uPointsPerInstance', which is why we add the result of
    'uPointsPerInstance' multiplied by 0.5 to the location we calculated by multiplying
    'pointIndex' and 'uPointsPerInstance'.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中接下来的几行创建了用于采样噪声纹理的UV。为了创建UV的X位置，我们首先取入点索引并将其乘以'uPointsPerInstance'，即1 / 1000。这给了我们从0.0到1.0范围内采样的位置。在手动创建UV时要记住的一点是，UV坐标具有无限精度，因此沿X轴的UV为0不是第一个像素，而是第一个像素的左边缘，这将导致视觉错误，因为着色器将插值第一个像素的50%和第一个像素左侧的50%（取决于设置的重复参数）。因此，我们需要通过将采样步长'uPointsPerInstance'的一半偏移我们的采样，这就是为什么我们将'uPointsPerInstance'乘以0.5的结果添加到我们通过将'pointIndex'和'uPointsPerInstance'相乘计算出的位置上。
- en: 'To recap that:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：
- en: We need to convert the point index from 0 - 1000 to the UV co-ordinates 0.0
    to 1.0
  id: totrans-1192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将点索引从0到1000转换为UV坐标0.0到1.0
- en: Do that by multiplying the point index by the result of 1 / 1000, which gives
    us our sample step along the 0.0 to 1.0 range
  id: totrans-1193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将点索引乘以1 / 1000的结果来实现，这给了我们在0.0到1.0范围内的采样步长
- en: Then add half of 'uPointsPerInstance' value (which is half of a single sample
    step) to offset our sampling so that we are samlping the middle of each pixel
    and not the left most edge
  id: totrans-1194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将'uPointsPerInstance'值的一半（即单个采样步长的一半）添加到我们的采样中，以便我们采样每个像素的中心而不是最左边缘
- en: Finally, because we know the texture is only 1 pixel tall, we can set 'uv.y'
    to 0.5 (again, because we don't want to sample the edge of the pixel, we want
    to sample the midle of it).
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，因为我们知道纹理只有1像素高，我们可以将'uv.y'设置为0.5（同样，因为我们不想采样像素的边缘，我们想采样其中心）。
- en: '[PRE51]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The next thing to do is use the UV co-ordinates to sample the noise texture:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的是使用UV坐标来采样噪声纹理：
- en: '[PRE52]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Before we finish assigning the new point position, we use this handy piece of
    GLSL code to quickly adjust the size of the particles. We're able to do this because
    earlier, we used the 'Convert SOP' to set the particle types to sprites (as this
    code only works with sprites).
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成分配新点位置之前，我们使用这段方便的GLSL代码快速调整粒子的大小。我们能够做到这一点是因为之前我们使用'Convert SOP'将粒子类型设置为精灵（因为这段代码只适用于精灵）。
- en: '[PRE53]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Finally, the code below takes our 'newPosition' values from object space, uses
    'TDDeform()' to move them to world space. It then multiplies the position by 'uTDMat.cam'
    to move the point into camera space. And finally, 'TDCamToProj()' is used to convert
    the camera space point to screen space points, which are assigned to 'gl_Position',
    which is the built-in output for each points position.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，下面的代码从对象空间获取我们的'newPosition'值，使用'TDDeform()'将它们移动到世界空间。然后将位置乘以'uTDMat.cam'将点移动到相机空间。最后，使用'TDCamToProj()'将相机空间点转换为屏幕空间点，分配给'gl_Position'，这是每个点位置的内置输出。
- en: '[PRE54]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: With that, we've finished the first goal, which was to move particles with textures.
    Although this may not seem like a traditional particle system, these steps lay
    the foundation for the next implementations.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们完成了第一个目标，即使用纹理移动粒子。虽然这可能看起来不像传统的粒子系统，但这些步骤为下一步的实现奠定了基础。
- en: '![Particles final](final_step.PNG)'
  id: totrans-1204
  prefs: []
  type: TYPE_IMG
  zh: '![粒子最终效果](final_step.PNG)'
- en: 12.7.3 Using Source Geometry
  id: totrans-1205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.7.3 使用源几何
- en: 'Now that we have a basic grasp on moving particles using textures, we can add
    in a piece of geometry and use its positions as starting positions for our particle
    system. In this exercise, we''ll replace our ''Add SOP'' with a ''Grid SOP'' (with
    the same point count) and add some noise to each particle position. These are
    the steps we will follow:'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对使用纹理移动粒子有了基本的了解，我们可以添加一块几何体，并使用其位置作为粒子系统的起始位置。在这个练习中，我们将用一个'Grid SOP'（具有相同的点数）替换我们的'Add
    SOP'，并为每个粒子位置添加一些噪声。我们将按照以下步骤进行：
- en: Create a texture from the point position data of 'Grid SOP'
  id: totrans-1207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从'Grid SOP'的点位置数据创建纹理
- en: Use this texture to position our particles in the point positions of the 'Grid
    SOP'
  id: totrans-1208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the previous noise texture on the new positions to create an effected
    grid
  id: totrans-1209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is best to read this text while examing the example project '02_Source_geometry.toe',
    because I will refer to certain operators by their names in the example project.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create a texture from the point position data of the 'Grid
    SOP'. The source of point positions in the first example was an 'Add SOP', a 'Copy
    SOP', and another 'Add SOP'. Start by removing these and replacing them with a
    'Grid SOP' with the 'Rows' parameter set to 100 and the 'Columns' parameter set
    to 10\. This combination of rows and columns will create a grid with the same
    number of points as our previous example.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to get all the point positions from the 'Grid SOP' using a
    'SOP to CHOP'. Create a 'SOP to CHOP' and set the 'SOP' parameter to the name
    of the 'Grid SOP' which in this case is 'grid1'.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: This creates a CHOP with all the point positions as separate channels. We can
    translate these XYZ channels into RGB channels of a texture by using the 'CHOP
    to TOP'. Create a 'CHOP to TOP' and set the 'CHOP' parameter to the name of the
    'SOP to CHOP', which in this example is 'sopto1'. Make sure the set the 'Pixel
    Format' to '32-bit float (RGBA)' in the 'Common' settings of the 'CHOP to TOP',
    as we will be feeding this into the GLSL shader and want it to continue outputting
    a 32-bit texture. Connect the output of the 'CHOP to TOP' to the second input
    of 'glsl2', the 'GLSL TOP' we were using in the last example to scale the noise
    values.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: This complete the first step of the example.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: '![](step1.PNG)'
  id: totrans-1215
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a texture, let''s make a few additions to our shader. Below
    is our final shader from the previous example:'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-1217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We''ll start by adding a line to sample the new texture with the ''Grid SOP''
    position data. Insert this line after line 7 (we will review the full code at
    the end):'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-1219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This creates a new 4-part vector with our XYZ data that is connected to the
    second input (remember the inputs are indexed starting at 0). If you''d like to
    visualize this very quickly, change the last line temporarily to:'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This will move all of the particles to the static points on the ''Grid SOP''.
    Before continuing, make sure the change the final line back to:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now we''re going to focus on this line:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Previously, we were taking the noise values, scaling them to make them interesting,
    then offsetting them to sit nicely in the camera''s view. Our goal now is to take
    the incoming grid positions, and effect them with the noise. To do so, we can
    use a line like this:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Inside each part of the ''vec4'', we''re taking the ''Grid SOP'' XYZ and adding
    to it the XYZ of the noise texture. The only extra thing we''ve added here, is
    that before adding the X and Y values of the noise, we''re scaling them down,
    as it makes it a bit easier to see the ''Grid SOP'' shape in the render. The full
    shader code should look like this:'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-1229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Once you save, you should the columns of the grid being effected by the noise
    texture.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，你应该看到网格的列受到噪声纹理的影响。
- en: '![](step2_3.PNG)'
  id: totrans-1231
  prefs: []
  type: TYPE_IMG
  zh: '![](step2_3.PNG)'
- en: Feel free to experiment by replacing the 'Grid SOP' with another geometry with
    1000 points.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试用另一个具有1000个点的几何体替换'Grid SOP'。
- en: 12.7.4 Adding Velocity
  id: totrans-1233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.7.4 添加速度
- en: 'In this section, we''re going to remove the random noise that is driving the
    particles and add a constant velocity. We won''t spend much time going into depth
    on some of the physics concepts, if they''re new to you, we recommend either:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将删除驱动粒子的随机噪声，并添加一个恒定速度。如果您对一些物理概念还不熟悉，我们不会花太多时间深入讨论，我们建议您：
- en: '[Nature of Code](http://natureofcode.com/) which is a great Processing book
    about modeling natural forces'
  id: totrans-1235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[自然编码](http://natureofcode.com/)是一本关于建模自然力的优秀Processing书籍'
- en: '[Khan Academy](https://www.khanacademy.org/science/physics) for learning the
    physics concepts on their own'
  id: totrans-1236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可汗学院](https://www.khanacademy.org/science/physics)用于自学物理概念'
- en: We're going to make some simple UI controls that will allow us to add a constant
    velocity in XYZ space to all the particles. How the particles are controlled is
    important because data from the last frame is added to the current frame to find
    the new positions. Think about a particle traveling over a few frames. For every
    frame the particle needs to know where it was the last frame so it can add the
    velocity and calculate it's new position. In the previous examples, the noise
    only ever had the current frame worth of data.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一些简单的UI控件，允许我们在XYZ空间中为所有粒子添加恒定速度。粒子是如何控制的很重要，因为从上一帧的数据添加到当前帧以找到新位置。想象一下一个粒子在几帧中移动。对于每一帧，粒子需要知道上一帧它在哪里，这样它就可以添加速度并计算它的新位置。在以前的示例中，噪声只有当前帧的数据。
- en: The main element we're going to add in this example is a feedback loop so that
    we can continuously feed in the last frame's data, update the texture with new
    positions, then feed it back as the input.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个示例中添加的主要元素是一个反馈循环，这样我们就可以持续地输入上一帧的数据，更新纹理以获取新位置，然后将其作为输入反馈。
- en: You can follow along with example `01_adding_velocity.toe` in the folder `TouchDesigner
    Example Files/12.7.4`.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在文件夹`TouchDesigner Example Files/12.7.4`中跟随示例`01_adding_velocity.toe`。
- en: 'Start by deleting the ''Noise TOP'' and unplugging the `chopto1` from the ''GLSL
    TOP''. Follow these steps:'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先删除'Noise TOP'并将`chopto1`从'GLSL TOP'中拔出。按照以下步骤进行：
- en: Create a 'Feedback TOP'
  id: totrans-1241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个'Feedback TOP'
- en: Connect the output of `chopto1` to the input of the 'Feedback TOP'
  id: totrans-1242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`chopto1`的输出连接到'Feedback TOP'的输入
- en: Connect the output of the 'Feedback TOP' to the first input of the 'GLSL TOP'
  id: totrans-1243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将'Feedback TOP'的输出连接到'GLSL TOP'的第一个输入
- en: Set the 'Target TOP' parameter of the 'Feedback TOP' to the name of the 'GLSL
    TOP', in the example project this is `glsl2`
  id: totrans-1244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将'Feedback TOP'的'Target TOP'参数设置为'GLSL TOP'的名称，在示例项目中这是`glsl2`
- en: 'This should look like the image below:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该看起来像下面的图片：
- en: '![](step11.PNG)'
  id: totrans-1246
  prefs: []
  type: TYPE_IMG
  zh: '![](step11.PNG)'
- en: Now let's create a new uniform on the 'Vectors 1' page of the 'GLSL TOP' parameters.
    Name it it `uVel` and leave the values at 0.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在'GLSL TOP'参数的'Vectors 1'页面上创建一个新的uniform。将其命名为`uVel`，并将值保留为0。
- en: You can see the final shader if you skip down a little bit, but here are the
    individual changes explained.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向下滑动一点，您可以看到最终的着色器，但这里解释了各个更改。
- en: 'Add a line to get our new uniform value at the start of the shader:'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一行以在着色器开头获取我们的新uniform值：
- en: '[PRE62]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We're going to change the name of our vec4 output from `fragColor` to `oPosition`,
    which is a short name for 'output position'.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把vec4输出的名称从`fragColor`改为`oPosition`，这是'output position'的简称。
- en: 'Then, instead of sampling noise positions and grid positions, we''re going
    to sample the new input positions that are fed back to the shader from the ''Feedback
    TOP'':'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将采样从'Feedback TOP'反馈到着色器的新输入位置，而不是采样噪声位置和网格位置：
- en: '[PRE63]'
  id: totrans-1253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We will add our new velocity value to the previous point position:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把新的速度值添加到上一个点位置：
- en: '[PRE64]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And finally, output the new point position:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，输出新的点位置：
- en: '[PRE65]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The final shader for this example will look like this:'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的最终着色器将如下所示：
- en: '[PRE66]'
  id: totrans-1259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The final elements that we need are an interface to change the `uVel` uniform
    parameter, and a button to reset the particles by resetting the feedback.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一个元素是一个界面来改变`uVel` uniform参数，以及一个按钮通过重置反馈来重置粒子。
- en: In the example, we created a 2D slider for the XY velocity of the particles
    and a slider for the Z velocity. You can experiment with other kinds of sliders
    and buttons, as long as you reference the channel values in the first three values
    of the `uVel` uniform on the 'Vectors 1' page of the 'GLSL TOP' parameters.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: The script you'll add to your reset button will vary depending on the type of
    interface you create, but there will be one line that should always be at the
    end of it. This line will pulse the 'Reset' parameter of the 'Feedback TOP', which
    will then clear the feedback and pass through the original point positions of
    the grid again. In the example reset script, the UI elements are all reset to
    a 0 position, and then the 'Feedback TOP' is reset.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: 12.7.5 Random Velocity
  id: totrans-1263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we have the most basic particle system imaginable: a system where all the
    particles move with the same constant velocity. In this section we''re going to
    give each of the points their own random velocity instead of controlling them
    with UI elements. This will create the effect of a particle explosion from the
    ''Grid SOP''.'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: Start by removing the `uVel` uniform from the 'GLSL TOP' and clearing the parameters
    that reference our UI elements. Your `Vectors 1` parameter page of the 'GLSL TOP'
    should be clear.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: Next, delete the sliders/UI elements created to control the particle velocity
    *but do not delete the reset button*. We will continue to use the reset button
    in this example.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on what kind of elements you had created to control the particles,
    we''ll need to remove any of the Python code associated with them from the ''Panel
    Execute DAT'' connected to the reset button. Inside the `def offToOn` callback
    you should only have a line that resets the ''Feedback TOP'':'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-1268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The final element we need in the network is a 'Noise TOP' with a resolution
    of 1000 pixels by 1 pixel, to match the resolution of our 'CHOP to TOP'. Set the
    'Noise TOP' type to `Random (GPU)`. Turn of the `Monochrome` toggle. Set the `Amplitude`
    to 0.5, and set the `Offset` to 0.5\. Changing these two parameters is an easy
    way to move the noise values from the range of 0 and 1 with a floor of 0 to a
    range of 0 and 1 with a 0.5 center.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: 'To visualize this, it is a move from this kind of noise:'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: '![](noise1.PNG)'
  id: totrans-1271
  prefs: []
  type: TYPE_IMG
- en: 'To this kind of noise:'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: '![](noise2.PNG)'
  id: totrans-1273
  prefs: []
  type: TYPE_IMG
- en: With these parameters set, plug the 'Noise TOP' into the second input of the
    'GLSL TOP'.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: 'Your network should now look like this:'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: '![](network.PNG)'
  id: totrans-1276
  prefs: []
  type: TYPE_IMG
- en: In our shader, we only have to make a few changes.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: 'After the line where we sample the input positions from the grid, we''ll add
    a line that samples our noise texture and creates a new vec4 named `velocity`:'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-1279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This should look very familiar by now. The `* 2 - 1` at the end is some simple
    math that changes the noise range of 0 and 1 to a range of -1 and 1.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in the next line of code, instead of adding the `uVel` uniform, we''ll
    add the new `velocity` vector:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-1282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now you can click your reset button and watch the particle system explode away
    from the 'Grid SOP' points. Experiment with the 'Noise TOP' settings and the ranging
    math in the shader to see how you can create different results.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以点击重置按钮，看着粒子系统从“网格 SOP”点处爆炸开来。尝试调整“噪声 TOP”设置和着色器中的范围数学，看看你能够创造出不同的结果。
- en: What Next?
  id: totrans-1284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来呢？
- en: '*12.7 What Next?*'
  id: totrans-1285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*12.7 接下来呢？*'
- en: This chapter should have helped unravel a bit of the introductory mysteries
    of GLSL without getting unnecessarily technical.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 本章应该已经在不过度技术的情况下帮助你解开了 GLSL 的一些入门之谜。
- en: 'If you''d like to continue learning GLSL to experiment with more complex 3D
    scenes and material shaders, or with more complex 2D compositing tools and generative
    textures, below are some resources:'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想继续学习 GLSL，尝试在更复杂的 3D 场景和材质着色器中进行实验，或者使用更复杂的 2D 合成工具和生成纹理，以下是一些资源：
- en: 'OpenGL Main reference page: [http://www.opengl.org/wiki/Main_Page](http://www.opengl.org/wiki/Main_Page)'
  id: totrans-1288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenGL 主要参考页面：[http://www.opengl.org/wiki/Main_Page](http://www.opengl.org/wiki/Main_Page)
- en: 'OpenGL General information: [http://www.opengl.org/wiki/General_OpenGL](http://www.opengl.org/wiki/General_OpenGL)'
  id: totrans-1289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenGL 一般信息：[http://www.opengl.org/wiki/General_OpenGL](http://www.opengl.org/wiki/General_OpenGL)
- en: 'Derivative Wiki: [http://www.derivative.ca/wiki088/index.php?title=Glsl](http://www.derivative.ca/wiki088/index.php?title=Glsl)'
  id: totrans-1290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 衍生 Wiki：[http://www.derivative.ca/wiki088/index.php?title=Glsl](http://www.derivative.ca/wiki088/index.php?title=Glsl)
- en: 'Shader Toy: [https://www.shadertoy.com/](https://www.shadertoy.com/)'
  id: totrans-1291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Shader Toy：[https://www.shadertoy.com/](https://www.shadertoy.com/)
