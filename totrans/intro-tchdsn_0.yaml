- en: Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Foreword
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前言
- en: Between the artist and the tool are countless techniques and bits of know-how
    that contribute to the artist becoming more fluid and well-equipped for the challenges
    of production. When I caught wind of Elburz’ TouchDesigner book project, I thought,
    yes I’d like to know what he knows! Elburz’ deep storage of TouchDesigner wisdom
    was absorbed from multiple sources - helping and conversing with a myriad of users
    on the forums, red-lining on-the-job on time-critical projects, working with Derivative
    using beta builds of TouchDesigner, and his purely exploratory endeavors mixed
    with his side-life as a hip-hop trombonist and VJ.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在艺术家和工具之间有无数的技巧和知识片段，这些都有助于艺术家变得更加流畅和为制作挑战做好准备。当我听说Elburz的TouchDesigner书籍项目时，我想，是的，我想知道他知道什么！Elburz对TouchDesigner的深入了解来自多个来源——在论坛上帮助和交谈与无数用户，紧急项目的现场修正，使用TouchDesigner的beta版本进行与Derivative的合作，以及他作为嘻哈长号手和VJ的副业纯粹的探索活动。
- en: The book is a good keyboard-side or bed-side companion that explores the concepts,
    techniques and methodology behind TouchDesigner - something I have not had the
    opportunity to personally present before and am very happy Elburz has presented
    here. So build your chops with these treats - It can be read end-to-end or by
    randomly flipping through pages, as I found myself doing - discovering gems of
    information and insights throughout.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是一个很好的键盘旁或床边的伴侣，探讨了TouchDesigner背后的概念、技术和方法论 - 这是我以前没有机会亲自介绍过的东西，我很高兴Elburz在这里呈现了。所以用这些东西来提升自己的技能——它可以从头到尾阅读，也可以随意翻阅页面，就像我自己所做的那样——在整本书中发现了信息和见解的宝藏。
- en: Many thanks to Elburz for this initiative to enrich the TouchDesigner community.
    I’m sure it will trigger a great chain reaction.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢Elburz为丰富TouchDesigner社区所做的努力。我相信这将引发一连串伟大的反应。
- en: '*Greg Hermanovic'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*Greg Hermanovic'
- en: Founder
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 创始人
- en: Derivative*
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 衍生品*
- en: Foreword by Author
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作者的前言
- en: 'The purpose of this book is two-fold:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目的是双重的：
- en: to teach the fundamentals of TouchDesigner 088
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教授TouchDesigner 088的基础知识
- en: to create a community-driven resource for beginners
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个由社区驱动的初学者资源
- en: The first purpose is straightforward. We will look at various UI elements, discuss
    Operators and Operator families, explore logical workflows, Network optimizations,
    performance interfaces, display management, and etc. TouchDesigner's core elements
    will be explained and demonstrated, and many common problems will be pre-emptively
    dealt with.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个目的很简单。我们将看看各种UI元素，讨论操作符和操作符系列，探索逻辑工作流程，网络优化，性能界面，显示管理等。TouchDesigner的核心元素将被解释和演示，并且将预先解决许多常见问题。
- en: After the written portion, we will learn how to approach solving a problem with
    example projects and video tutorials at the end of the book. These lessons will
    be practical in that we will assemble a few projects and useful modules from the
    ground up.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在书面部分之后，我们将通过书的结尾的示例项目和视频教程学习如何解决问题的方法。这些课程将是实践性的，因为我们将从零开始组装一些项目和有用的模块。
- en: The second purpose of this book is slightly more asking of the community. We
    really believe in the community, so instead of selling this book, we wanted everyone
    to be able to access it for free (text, video, and example files). We wanted to
    take this idea a step further, and not only allow free access to the book's contents,
    but also allow free access to the book's building blocks.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的第二个目的对社区的要求稍微更高一些。我们真的相信社区，所以我们不想出售这本书，我们希望每个人都能免费访问它（文字、视频和示例文件）。我们希望进一步推动这个想法，不仅允许免费访问书籍的内容，还允许免费访问书籍的构建模块。
- en: What this means is that anyone can feel free to add, comment, change, mark up,
    delete, or increment upon the resources in this book. All of the book has been
    completely written using LaTeX, and the code to compile the book, project files,
    examples, diagrams, and videos, and whatever else ends up within it, will all
    be hosted on GitHub, and will be free (under a Creative Commons license) for anyone
    to download, share, and build upon.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着任何人都可以随意添加、评论、更改、标记、删除或增加这本书中的资源。这本书的所有内容都是完全使用LaTeX编写的，编译该书的代码、项目文件、示例、图表、视频以及任何其他内容都将托管在GitHub上，并且将免费（根据知识共享许可证）供任何人下载、分享和构建。
- en: For quality control purposes, everyone will be able to branch the repository,
    but we will review all changes before integrating updates back into a main branch.
    Everyone who contributes will be thanked and added to the 'Credits' portion of
    the book. This way, a new user only has to look for a single PDF, or download
    link, to receive the communities most up-to-date knowledge.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了质量控制目的，每个人都可以分支存储库，但我们将在将更新集成回主分支之前审查所有更改。每个贡献者都将受到感谢，并被添加到本书的“致谢”部分。这样，新用户只需寻找一个单独的PDF文件或下载链接，就可以获得社区最新的知识。
- en: We really hope that the community engages with this and helps create the ultimate
    how-to resource for beginners!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真诚希望社区参与其中，并帮助为初学者创建终极的入门资源！
- en: As of the initial writing, knowing what this book is will be as important as
    knowing what this book is not. This book is not an Operator reference manual.
    We will not cover every parameter or use of every Operator. This book is not meant
    to replace the Derivative Wiki as the main reference, we will only use and learn
    about what we need. This book is not meant to replace the forum's wealth of helpful
    users and components.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初的撰写时，了解这本书是什么将和了解这本书不是什么一样重要。这本书不是操作符参考手册。我们不会涵盖每个操作符的每个参数或用法。这本书不旨在取代Derivative
    Wiki作为主要参考，我们只会使用和学习我们需要的内容。这本书也不旨在取代论坛中丰富的有用用户和组件。
- en: In the end, this resource is a tribute to many TouchDesigner programmers and
    Derivative staff who, whether on the forum, or in real-life, have helped all of
    us get where we are. We hope that this tradition will continue as long as TouchDesigner
    does.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这个资源是对许多TouchDesigner程序员和Derivative员工的致敬，无论是在论坛上还是在现实生活中，他们都帮助我们所有人走到了今天。我们希望这一传统将随着TouchDesigner的持续而延续。
- en: '*Elburz Sorkhabi & nVoid Art-Tech Limited*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*Elburz Sorkhabi & nVoid Art-Tech Limited*'
- en: What is TouchDesigner?
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TouchDesigner是什么？
- en: 'This is a question many users spend time trying to answer when starting out.
    It can be surprising how long it takes to create and perform simple tasks. It
    can be surprising that a good amount of time is spent building functionality that
    is already native to other software packages. So what is TouchDesigner? The answer
    is simple: TouchDesigner is a visual, node-based programming language.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是许多用户在刚开始时花时间尝试回答的问题。令人惊讶的是，创建和执行简单任务需要花费多长时间。令人惊讶的是，花费了大量时间来构建其他软件包中已经存在的功能。那么TouchDesigner是什么？答案很简单：TouchDesigner是一种视觉、基于节点的编程语言。
- en: Starting from possibly the most important aspect of the description, TouchDesigner
    is a programming language. TouchDesigner isn't an application that is ready on
    start to perform actions that may seem simple in other applications. TouchDesigner
    is an environment with extreme depth, and many potential pitfalls. With some practice
    and time, many things can be created quickly as theyre required. With the book's
    goal to create re-useable modules, the speed at which a blank canvas can become
    a finished project will be greatly increased. This doesn't negate the fact that
    TouchDesigner is still a programming language. Many tasks will still require due
    diligence in regards to time and effort. Many will require quite a bit of head-scratching,
    and all of them will require some basic problem-solving skills.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从描述中可能最重要的方面开始，TouchDesigner是一种编程语言。TouchDesigner不是一个在启动时准备好执行在其他应用程序中看似简单的操作的应用程序。TouchDesigner是一个具有极端深度和许多潜在陷阱的环境。通过一些练习和时间，许多东西可以在需要时快速创建。通过本书的目标创建可重复使用的模块，空白画布变成完成项目的速度将大大增加。这并不是否认TouchDesigner仍然是一种编程语言。许多任务仍然需要时间和精力的尽职调查。许多任务将需要相当多的思考，所有这些任务都将需要一些基本的问题解决技能。
- en: The second aspect of the description is that TouchDesigner is node-based. This
    mean that instead of opening a text document and typing line after line of code,
    TouchDesigner's graphical interface is used to make applications out of nodes.
    Each node, or Operator in TouchDesigner, performs a specific, small, and granular
    action. To perform complex tasks, a handful of nodes will work together. To send
    information between these nodes, their inputs and outputs are wired together.
    There are many node-based programming languages in existence, such as Cycling
    74's Max/MSP, but what sets TouchDesigner apart is it's visual nature.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 描述的第二个方面是TouchDesigner是基于节点的。这意味着，与其打开文本文档并逐行输入代码，TouchDesigner的图形界面用于通过节点制作应用程序。TouchDesigner中的每个节点或操作符执行特定、小型和细粒度的操作。为执行复杂任务，一些节点将共同工作。为在这些节点之间发送信息，它们的输入和输出被连线在一起。存在许多基于节点的编程语言，例如Cycling
    74的Max/MSP，但是TouchDesigner的视觉特性使其与众不同。
- en: Everything in TouchDesigner has a visual counterpart. All the Operators have
    viewers. Everything, whether it be text, control data, audio, videos, and more,
    is visualized through each and every operation that is performed. This is unlike
    any traditional programming, and even node-based, language, but it is what makes
    TouchDesigner a fantastic environment to work with. Learning how to do many complex
    tasks is greatly simplified by the ability to visualize the steps involved, every
    step of the way.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: TouchDesigner中的所有内容都有可视化对应物。所有操作符都有查看器。无论是文本、控制数据、音频、视频等，都通过执行的每个操作来可视化。这与任何传统编程，甚至基于节点的语言都不同，但这正是使TouchDesigner成为一个出色的工作环境的原因。通过能够可视化所涉及的每个步骤，学习如何完成许多复杂任务变得大大简化。
- en: Accessing the book
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问这本书
- en: 'There are multiple ways to access an Introduction to TouchDesigner 088\. Since
    converting the book to using Gitbooks, you may now download the PDF, epub, or
    mobi version of the book from the link below:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以访问《TouchDesigner 088入门》。自从将这本书转换为使用Gitbooks后，您现在可以从下面的链接下载PDF、epub或mobi版本的书籍：
- en: '[https://www.gitbook.com/book/nvoid/introduction-to-touchdesigner/details](https://www.gitbook.com/book/nvoid/introduction-to-touchdesigner/details)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.gitbook.com/book/nvoid/introduction-to-touchdesigner/details](https://www.gitbook.com/book/nvoid/introduction-to-touchdesigner/details)'
- en: 'The example files are found in the `TouchDesigner Example Files` folder of
    the GitHub repo, which can be cloned or downloaded here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 示例文件位于GitHub存储库的`TouchDesigner示例文件`文件夹中，可以在此处克隆或下载：
- en: '[https://github.com/nVoid/Introduction-to-touchdesigner](https://github.com/nVoid/Introduction-to-touchdesigner)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/nVoid/Introduction-to-touchdesigner](https://github.com/nVoid/Introduction-to-touchdesigner)'
- en: 'The hours of HD video tutorials are available in a single Vimeo channel. All
    the files can be downloaded from Vimeo for offline viewing. The link for this
    is below:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 数小时的高清视频教程可在单个Vimeo频道中找到。所有文件都可以从Vimeo下载以供离线观看。以下是此链接：
- en: '[https://vimeo.com/channels/845218](https://vimeo.com/channels/845218)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://vimeo.com/channels/845218](https://vimeo.com/channels/845218)'
- en: You can also download the Markdown source code from this GitHub repo and build
    use the parts separately. You are free to change, edit, add, delete, and modify
    the text by branching the source files. When you are finished, submit your changes
    and they will be reviewed by our administration, and merged into the main branch,
    at which point you will be added to the list of contributors in the Contributors
    chapter of the book, along with your contributions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从此GitHub存储库下载Markdown源代码，并单独构建使用各部分。您可以自由更改、编辑、添加、删除和修改文本，通过分支源文件。完成后，提交您的更改，它们将由我们的管理人员审核，并合并到主分支中，届时您将被添加到书籍的贡献者章节的贡献者列表中，连同您的贡献。
- en: For more general information about this resource, visit [http://book.nvoid.com](http://book.nvoid.com)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此资源的更多一般信息，请访问[http://book.nvoid.com](http://book.nvoid.com)
- en: Compiling the book
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译这本书
- en: Unlike the previous LaTeX version, no build environment is required to contribute
    to the book. You can use plain Markdown, and when you're done and your changes
    are accepted to the repository, Gitbooks automatically takes care of creating
    a new web version, PDF, epub, and mobi version of the book.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的LaTeX版本不同，无需构建环境即可为这本书做出贡献。您可以使用普通的Markdown，当您完成并且您的更改被接受到存储库时，Gitbooks会自动创建新的网络版本、PDF、epub和mobi版本的书籍。
- en: Attribution and Licensing
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归属和许可
- en: This resource is licensed under Creative Commons - Attribution-NonCommercial-ShareAlike-4.0
    International.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本资源采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议。
- en: 'Link: [http://creativecommons.org/licenses/by-nc-sa/4.0/](http://creativecommons.org/licenses/by-nc-sa/4.0/)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '链接: [http://creativecommons.org/licenses/by-nc-sa/4.0/](http://creativecommons.org/licenses/by-nc-sa/4.0/)'
- en: Thank you!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢！
- en: Signal Flow and Wiring
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号流和连接
- en: 1 Basics
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 基础知识
- en: '*1.1 Signal Flow and Wiring*'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*1.1 信号流和连接*'
- en: Wiring Operators is the most basic operation in TouchDesigner. All projects
    are made up of nothing more than groups of Operators wired together. Each Operator,
    on its own, does a very specific thing, but when they are combined together into
    a ’Network’, they can solve extremely complex problems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在TouchDesigner中，连接操作符是最基本的操作。所有项目都由一组组连接在一起的操作符组成。每个操作符本身都有一个非常具体的功能，但当它们组合在一起成为一个'网络'时，它们可以解决非常复杂的问题。
- en: All data in TouchDesigner flows from left to right. Any inputs that an Operator
    has will always be on the left side, and outputs will be on the right side. The
    inputs and outputs will also be ordered first to last, going from top to bottom.
    In the example diagram below, follow the two signals starting on the left. As
    they flow from left to right, they are composited, one over the other.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: TouchDesigner中的所有数据都是从左到右流动的。任何操作符具有的输入始终在左侧，输出在右侧。输入和输出也将按照从上到下的顺序排序。在下面的示例图中，从左侧开始跟随两个信号。当它们从左到右流动时，它们会叠加在一起。
- en: '![img 1.1.1](signal-flow-1.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![img 1.1.1](signal-flow-1.png)'
- en: Components, interestingly, have the same data signal flow as Operators, flowing
    from left to right, but they are also capable of parent and child relationships,
    which flow from top to bottom. The component at the top of the signal chain is
    the parent, and the components below it are its children, and below that are the
    children’s children, and so on. In the example below, there is a small UI, that
    is made of a few sliders. In this example, the Slider COMPs are the children of
    the Container COMP, which is the parent.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，组件与操作符具有相同的数据信号流，从左到右流动，但它们还能够具有父子关系，从上到下流动。信号链顶部的组件是父组件，其下方的组件是其子组件，再下方是子组件的子组件，依此类推。在下面的示例中，有一个由几个滑块组成的小型UI。在这个示例中，滑块组件是容器组件的子组件，而容器组件是父组件。
- en: '![img 1.1.2](signal-flow-2.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![img 1.1.2](signal-flow-2.png)'
- en: Creating Operators
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建操作符
- en: '*1.2 Creating Operators*'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*1.2 创建操作符*'
- en: The OP Create Dialog can be reached in a multitude of ways. Each has a correct
    time and place of usage. When creating Operators from scratch the two easiest
    methods are to hit ’Tab’ on the keyboard, or to double click on the Network background.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: OP 创建对话框可以通过多种方式到达。每种方式都有正确的使用时间和地点。当从头开始创建操作符时，最简单的两种方法是在键盘上按下'Tab'键，或者双击网络背景。
- en: When working with existing chains of Operators, there are two easy ways to add
    Operators. The first is to right click on either the input or output of an Operator.
    This will add the chosen Operator, pre-wired, directly before the input or after
    the output. This is especially useful as it inserts the Operator seamlessly into
    a pre-existing chain.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理现有操作符链时，有两种简单的方法可以添加操作符。第一种是右键单击操作符的输入或输出。这将在输入之前或输出之后直接添加所选的操作符，并进行预连接。这在将操作符无缝插入到现有链中时特别有用。
- en: For example, there is a Constant TOP wired to a Null TOP, and a Transform TOP
    needs to be added between the two. Right clicking either the output of the Constant
    TOP, or the input of the Null TOP, and selecting Transform TOP, would create a
    Transform TOP, that would be pre-wired in-between the Constant TOP and Null TOP.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有一个连接到Null TOP的Constant TOP，需要在两者之间添加一个Transform TOP。右键单击Constant TOP的输出或Null
    TOP的输入，并选择Transform TOP，将创建一个Transform TOP，它将预先连接在Constant TOP和Null TOP之间。
- en: The second way to add an Operator to an existing chain is to middle click on
    the output of an Operator. The difference is that right clicking integrates the
    newly created Operator into the current Operator chain, whereas middle clicking
    creates a new branch in parallel to the chain of Operators.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 添加操作符到现有链中的第二种方法是在操作符的输出上中键单击。不同之处在于，右键单击会将新创建的操作符集成到当前操作符链中，而中键单击会在操作符链的旁边创建一个新的并行分支。
- en: Similar results can be achieved by right clicking on the wire itself and clicking
    on ’Insert Operator’ or ’Add Operator’. ’Insert Operator’ acts like right clicking
    an Operator’s output and integrates it into the current Operator chain, whereas
    ’Add Operator’ acts like middle clicking and creates a new branch in parallel
    to the chain.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过右键单击线本身然后点击“插入操作符”或“添加操作符”来实现类似的结果。“插入操作符”的作用类似于右键单击操作符的输出，并将其集成到当前操作符链中，而“添加操作符”的作用类似于中键单击，并在操作符链的旁边创建一个新的分支。
- en: In the diagram below, there is an example with a Constant TOP and a Null TOP.
    In the next diagram, the wire connecting them was right clicked and a Transform
    TOP was created using ’Insert Operator’. In the proceeding diagram, the wire connecting
    the Operators was right clicked and a Transform TOP was created using ’Add Operator’.
    Notice how it is pre-wired in parallel to the first Transform TOP.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图表中，有一个包含一个常量 TOP 和一个空 TOP 的示例。在接下来的图表中，右键单击连接它们的线，并使用“插入操作符”创建了一个变换 TOP。在后续图表中，右键单击连接操作符的线，并使用“添加操作符”创建了一个变换
    TOP。注意它是如何预先连线并行到第一个变换 TOP 的。
- en: '![img 1.2.1](creating-operators-1.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![img 1.2.1](creating-operators-1.png)'
- en: '![img 1.2.2](creating-operators-2.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![img 1.2.2](creating-operators-2.png)'
- en: '![img 1.2.3](creating-operators-3.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![img 1.2.3](creating-operators-3.png)'
- en: 'There are two useful key commands when working with the OP Create Dialog: ’Control’
    and ’Shift’. Open the OP Create dialog, hold down ’Control’ on the keyboard, and
    then begin to select multiple Operators in a row. Each one will be added to the
    Network below the last. This is useful for quickly populating a Network with a
    few different Operators.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用操作符创建对话框时，有两个有用的键命令：“Control”和“Shift”。打开操作符创建对话框，按住键盘上的“Control”键，然后开始连续选择多个操作符。每个操作符将被添加到上一个下方的网络中。这对于快速使用几个不同的操作符填充网络非常有用。
- en: Similarly, open the OP Create dialog, press and hold the ’Shift’ key, and then
    begin to select multiple Operators. This is different than above, in that the
    Operators will be wired together in series. This key command can be used to quickly
    create small, or large, chains of pre-wired Operators.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，打开操作符创建对话框，按住“Shift”键，然后开始选择多个操作符。这与上面不同，因为这些操作符将串联在一起。这个键盘命令可用于快速创建预先连线的操作符的小型或大型链。
- en: 'Both of these key commands are quite powerful, but they become even more so
    when they are used in tandem. For example, a project requires 3 chains of Operators.
    The first will consist of a Circle TOP, connected to a Blur TOP, connected to
    a Null TOP. The second will consist of a Circle TOP, connected to an Edge TOP,
    connected to a Noise TOP, connected to a Null TOP. The final chain will consist
    of a Movie In TOP, connected to a Blur TOP, connected to a Null TOP. Let’s go
    through this step by step, to demonstrate practical use of the above key commands:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当这两个键命令一起使用时，它们变得更加强大。例如，一个项目需要 3 条操作符链。第一条将由一个 Circle TOP 组成，连接到一个模糊 TOP，连接到一个空
    TOP。第二条将由一个 Circle TOP 组成，连接到一个 Edge TOP，连接到一个 Noise TOP，连接到一个空 TOP。最后一条链将由一个
    Movie In TOP 组成，连接到一个模糊 TOP，连接到一个空 TOP。让我们一步步地进行，以演示以上键命令的实际用法：
- en: Open the OP Create dialog
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开操作符创建对话框
- en: Press and hold down ’Shift’
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住“Shift”键
- en: While holding ’Shift’, click on Circle TOP, Blur TOP, then Null TOP. This will
    create the first chain.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按住“Shift”键的同时，点击 Circle TOP、模糊 TOP，然后空 TOP。这将创建第一条链。
- en: Release the ’Shift’ key
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 松开“Shift”键
- en: Press and hold down ’Control’. This will place the next Operator below the first
    Operator.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住“Control”键。这将在第一个操作符下放置下一个操作符。
- en: Holding ’Control’, click on Circle TOP
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按住“Control”键的同时，点击 Circle TOP
- en: Release the ’Control’ key
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 松开“Control”键
- en: Press and hold down the ’Shift’ key
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住“Shift”键
- en: While holding ’Shift’, click on Edge TOP, Noise TOP, and then Null TOP. This
    will create the second chain
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按住“Shift”键的同时，点击 Edge TOP、Noise TOP，然后空 TOP。这将创建第二条链
- en: Release the ’Shift’ key
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 松开“Shift”键
- en: Press and hold ’Control’
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住“Control”键
- en: While holding ’Control’, click on Movie In TOP.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按住“Control”键的同时，点击 Movie In TOP。
- en: Release the ’Control’ key
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 松开“Control”键
- en: Press and hold ’Shift’
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住“Shift”键
- en: 'Click on the remaining operators: Blur TOP, and Null TOP'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击剩余的操作符：模糊 TOP 和 空 TOP
- en: Now that all of the Operators are created, use the ’Esc’ key to close the OP
    Create dialog.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在所有操作符都已创建完成，使用“Esc”键关闭操作符创建对话框。
- en: After closing the OP Create Dialog, all the required Operators will be wired
    and ready to go in the project. These key commands have not only saved having
    to open and close the OP Create Dialog for every Operator, but they’ve saved the
    need to manually wire them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭OP创建对话框后，所有所需的运算符将被连接并准备好在项目中使用。这些关键命令不仅节省了每个运算符都要打开和关闭OP创建对话框的时间，而且还节省了手动连接它们的需要。
- en: Mouse and Keyboard Navigation
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鼠标和键盘导航
- en: '*1.3 Mouse and Keyboard Navigation*'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*1.3 鼠标和键盘导航*'
- en: The mouse plays a vital role in TouchDesigner programming, and a high-quality
    mouse is highly recommended. The mouse is used to move around the Network and
    work with Operators.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标在TouchDesigner编程中起着至关重要的作用，强烈推荐使用高质量的鼠标。鼠标用于在网络中移动和处理运算符。
- en: To navigate around the Network, left click and drag the Network background.
    Left click on an Operator to select it. Left click and drag that Operator to move
    it around the Network. Right click on an Operator to reveal a menu with options
    that will be introduced slowly. To select and work with more than one Operator,
    right click and drag the selection box around the desired Operators. Middle click
    on an Operator to get more info about it. There is a UI button that displays the
    same Operator info window, which is useful when using a mouse that doesn’t have
    a middle click button.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要在网络中导航，左键单击并拖动网络背景。左键单击运算符以选择它。左键单击并拖动该运算符以在网络中移动它。右键单击运算符以显示带有逐渐介绍的选项的菜单。要选择并处理多个运算符，右键单击并拖动选择框围绕所需的运算符。中键单击运算符以获取有关它的更多信息。有一个显示相同运算符信息窗口的UI按钮，当使用没有中键单击按钮的鼠标时非常有用。
- en: '![](navigation-1.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](navigation-1.png)'
- en: Left-click on the ’i’ to get more detailed information about the selected operator.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 左键单击“i”以获取有关所选运算符的更详细信息。
- en: There are several key commands used to navigate TouchDesigner projects. Two
    of these key commands are ’u’ and ’i’. Press ’u’ will move up one Network, and
    out of the current component. To go inside of a Network or component (like a Container
    COMP or Base COMP), select the component and hit ’i’.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个用于导航TouchDesigner项目的关键命令。其中两个关键命令是‘u’和‘i’。按‘u’将向上移动一个网络，并退出当前组件。要进入网络或组件（如容器COMP或基础COMP），选择组件并按‘i’。
- en: To centralize the screen on all the Operators in a Network, use the ’h’ key
    on the keyboard. This performs the ’Home’ action on the current Network.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要将屏幕居中显示网络中的所有运算符，请使用键盘上的‘h’键。这会执行当前网络上的‘主页’操作。
- en: Networks and Paths
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络和路径
- en: '*1.4 Networks and Paths*'
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*1.4 网络和路径*'
- en: All TouchDesigner projects are made of Networks. A Network is a group of Operators.
    Networks are encapsulated inside of components, such as a Container COMP, Base
    COMP, Geometry COMP, etc. Networks can be infinitely nested. The top level is
    called the ’root’ level. TouchDesigner system and UI elements can be found at
    the ’root’ level.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有TouchDesigner项目都由网络组成。网络是一组运算符。网络封装在组件内，例如容器COMP、基础COMP、几何COMP等。网络可以无限嵌套。顶层称为“根”级别。TouchDesigner系统和UI元素可以在“根”级别找到。
- en: Encapsulating and organizing Networks from the start of the project is a great
    practice to get in the habit of. The current path is always visible in the ’Path
    Bar’ at the top of the ’Network Editor’.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目开始封装和组织网络是一个很好的习惯。当前路径始终显示在“网络编辑器”顶部的“路径栏”中。
- en: '![](path-1.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](path-1.png)'
- en: 'All TouchDesigner Operators have a path. These paths are similar to Unix file
    paths. There are two kinds of paths to an Operator: the ’absolute path’ and the
    ’relative path’. The ’absolute path’ is the path to the Operator from the ’root’
    of the project, or ’/’. The ’relative path’ is the path to an Operator from another
    Operator. These paths start from the Network of the referencing Operator, instead
    of starting from the ’root’.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所有TouchDesigner运算符都有路径。这些路径类似于Unix文件路径。有两种到运算符的路径：‘绝对路径’和‘相对路径’。‘绝对路径’是从项目的‘根’或‘/’到运算符的路径。‘相对路径’是从另一个运算符到运算符的路径。这些路径从引用运算符的网络开始，而不是从‘根’开始。
- en: Open example ’Paths.toe’. This example demonstrates paths. TouchDesigner will
    start in the ’root’ of the project where there is a Container COMP named ’network1’.
    Inside of ’network1’, there are two Operators. ’rel1’ is a Text DAT with two paths
    in its contents. The first is an ’absolute path’. This path starts from the ’root’,
    or top of the project, and travels towards the Operator. The second path is the
    ’relative path’ from the current Operator to ’rel2’, which is a Text DAT inside
    of the Container COMP named ’network2’. In the ’relative path’, the path travels
    from the current location to the destination. To get from ’rel1’ to ’rel2’, the
    path only needs to travel into ’network2’, thus the ’relative path’ is ’network2/rel2’.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Paths.toe'。此示例演示路径。TouchDesigner 将从项目的 'root' 开始，在那里有一个名为 'network1' 的容器
    COMP。在 'network1' 中，有两个运算符。'rel1' 是一个 Text DAT，其内容中有两个路径。第一个是 '绝对路径'。该路径从 'root'，或项目的顶部开始，并朝着运算符。第二个路径是从当前运算符到
    'rel2' 的 '相对路径'，后者是名为 'network2' 的容器 COMP 中的 Text DAT。在 '相对路径' 中，路径从当前位置到目的地。要从
    'rel1' 到 'rel2'，路径只需要进入 'network2'，因此 '相对路径' 是 'network2/rel2'。
- en: Notice that the viewer of ’network2’ is displaying an Operator from inside of
    it. This technique will be discussed more in later examples, but what is important
    now is the path used. In the ’Operator Viewer’ parameter of ’network2’, there
    is the path to ’./display’, where ’display’ is the name of the Operator, and ’./’
    denotes one level inside of the referencing Operator, which is ’network2’ in this
    case.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，''network2'' 的查看器正在显示来自其中的运算符。这种技术将在后续示例中更详细地讨论，但现在重要的是使用的路径。在 ''network2''
    的 ''运算符查看器'' 参数中，有指向 ''./display'' 的路径，其中 ''display'' 是运算符的名称，''./'' 表示参考运算符内部的一个级别，这种情况下是
    ''network2''。 '
- en: Inside of ’network2’, there is a Text DAT named ’display’, whose contents are
    being displayed in the Network above. The other two Text DATs have more path examples
    written in them. ’abs1’ is another example of an ’absolute path’. ’rel2’ has an
    example of a ’relative path’ between itself and ’abs1’. It also has an example
    of a ’relative path’ between itself and ’rel1’ in the Network above, where ’rel1’
    is the Operator’s name, and ’../’ denotes one Network level above the current
    Network. ’../’ can be used in sequence to move up as high as the root, but there
    are more efficient ways of making paths.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 'network2' 内部，有一个名为 'display' 的 Text DAT，其内容正在上面的网络中显示。另外两个 Text DAT 中写入了更多的路径示例。'abs1'
    是 '绝对路径' 的另一个示例。'rel2' 有一个示例，显示了它与 'abs1' 之间的 '相对路径'。它还展示了它与上面网络中的 'rel1' 之间的
    '相对路径' 的示例，其中 'rel1' 是运算符的名称，'../' 表示当前网络的上一个网络级别。'../' 可以连续使用，直到到达根目录，但有更有效的方法来创建路径。
- en: Using an External Text Editor
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部文本编辑器
- en: '*1.5 Using an External Text Editor*'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*1.5 使用外部文本编辑器*'
- en: Small Python scripts can be created and edited inside of TouchDesigner, but
    as scripts grow, an external text editor can save a lot of time and trouble.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TouchDesigner 内部可以创建和编辑小型 Python 脚本，但随着脚本的增长，使用外部文本编辑器可以节省大量时间和麻烦。
- en: 'There are a number of helpful features gained by editing scripts in an external
    text editor. Without creating an extensive list, some reasons include:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在外部文本编辑器中编辑脚本，可以获得许多有用的功能。不列举详尽列表，一些原因包括：
- en: Line numbering
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行编号
- en: Colour coded syntax
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 颜色编码的语法
- en: Find & Replace functionality
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找和替换功能
- en: Auto-completion
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动完成
- en: These features add up to a far richer, and more efficient experience when working
    extensively with Python inside of TouchDesigner.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当大量使用 Python 在 TouchDesigner 内部工作时，这些功能会大大丰富和提高效率。
- en: Open the ’Preferences’ dialog found in the ’Edit’ menu
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“编辑”菜单中的“首选项”对话框
- en: Go to the ’DATs’ preferences
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“DATs”首选项
- en: Click the file browser icon for the ’Text Editor’ setting
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“文本编辑器”设置的文件浏览器图标
- en: Assign the the external editor’s executable (.exe) by selecting it and clicking
    ’Open’. This is usually located in the ’Program Files’ folder
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择外部编辑器的可执行文件（.exe）并点击“打开”来分配。这通常位于“Program Files”文件夹中。
- en: Click ’Accept’ on the Preferences dialog
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在首选项对话框上单击“接受”
- en: Once the setup is complete, right click on a DAT and click the ’Edit Contents’
    option. The DAT will be opened in the program which is specified by this preference.
    A separate ’Table Editor’ preference is available to set the external editor used
    for DATs that are tables.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，在 DAT 上右键单击并单击“编辑内容”选项。DAT 将在此首选项指定的程序中打开。可用单独的“表格编辑器”首选项来设置用于 DAT 的外部编辑器，这些
    DAT 是表格。
- en: 'Two well-respected editors that are used frequently in the TouchDesigner community,
    and are crossplatform, are linked below:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: TouchDesigner 社区经常使用的两个备受尊敬的编辑器，而且跨平台性强，下面链接了它们：
- en: '*Sublime Text 3* [http://www.sublimetext.com/](http://www.sublimetext.com/)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*Sublime Text 3* [http://www.sublimetext.com/](http://www.sublimetext.com/)'
- en: '*Notepad++* [http://notepad-plus-plus.org/](http://notepad-plus-plus.org/)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*Notepad++* [http://notepad-plus-plus.org/](http://notepad-plus-plus.org/)'
- en: Help
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帮助
- en: '*1.6 Help*'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*1.6 帮助*'
- en: If there are ever any questions about specific Operators or processes, refer
    to the official Derivative Wiki. Each Operator has two shortcuts that will open
    its Wiki page in a new browser window. These two buttons are located in the Parameter
    window, and both are represented by question marks. One is specifically about
    the Operator and its use, while the other, the question mark over the Python logo,
    is specifically about Python scripting with that Operator.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对特定操作器或流程有任何疑问，请参阅官方 Derivative Wiki。每个操作器都有两个快捷方式，将在新浏览器窗口中打开其 Wiki 页面。这两个按钮位于参数窗口中，都由问号表示。一个是关于操作器及其用法的，而另一个，Python
    标志上的问号，是关于使用该操作器进行 Python 脚本编写的。
- en: '![](help-1.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](help-1.png)'
- en: '![](help-2.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](help-2.png)'
- en: Parameter Window
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数窗口
- en: 2 User Interface
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 用户界面
- en: '*2.1 Parameter Window*'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.1 参数窗口*'
- en: The 'Parameter Window' is where all an Operator's parameters can be accessed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: “参数窗口”是可以访问所有操作器参数的地方。
- en: There are two ways to access the 'Parameter Window'. The first is using the
    'P' key. This will open a docked 'Parameter Window' in the top-right hand corner
    of the pane. This docked 'Parameter Window' will display the parameters of whatever
    Operator is selected.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 访问“参数窗口”的两种方法。第一种方法是使用“P”键。这将在窗格的右上角打开一个停靠的“参数窗口”。这个停靠的“参数窗口”将显示所选操作器的参数。
- en: The second way to access the 'Parameter Window' is by right clicking on an Operator
    and selecting 'Parameters...'. This will open up a floating 'Parameter Window'
    for the Operator. This method differs from the first in that the parameters will
    not change if another Operator is selected. This is useful for being able to manage
    the parameters of multiple Operators simultaneously.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 访问“参数窗口”的第二种方法是右键单击操作器，然后选择“参数...”。这将为操作器打开一个浮动的“参数窗口”。此方法与第一种方法不同之处在于，如果选择另一个操作器，参数不会更改。这对同时管理多个操作器的参数非常有用。
- en: 'Every Operator has a different set of parameters, but all ''Parameter Windows''
    have the same set of options. Below is a diagram highlighting the options:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作器都有一组不同的参数，但所有“参数窗口”都具有相同的选项集。下面是一个突出显示选项的图表：
- en: '![image 2.1.1](parameter-window.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image 2.1.1](parameter-window.png)'
- en: 'From left to right, the options are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，选项如下：
- en: 'Operator Help: opens the Operator''s Wiki help page in a new browser window'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作器帮助：在新浏览器窗口中打开操作器的 Wiki 帮助页面
- en: 'Operator Python Help: opens the Operator''s Python Wiki help page in a new
    browser'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作器 Python 帮助：在新浏览器中打开操作器的 Python Wiki 帮助页面
- en: 'Operator Information Dialog: displays information about the Operator''s process,
    similar to middle-clicking an Operator'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作器信息对话框：显示有关操作器过程的信息，类似于中键单击操作器
- en: 'Comment: display and edit Operator comments'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释：显示并编辑操作器注释
- en: 'Copied Parameters: displays parameters copied via the right click menu'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已复制的参数：显示通过右键菜单复制的参数
- en: 'Language: choose whether the Operator will use Python or tscript as its scripting
    language'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语言：选择操作器将使用 Python 还是 tscript 作为其脚本语言
- en: 'Expand/Collapse Parameters: expand or collapse all the Operator''s parameters'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开/折叠参数：展开或折叠所有操作器的参数
- en: 'Non-default Parameters: display only parameters that have been changed from
    their default values'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非默认参数：仅显示已更改为非默认值的参数
- en: Parameters
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数
- en: '*2.2 Parameters*'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.2 参数*'
- en: 'Parameters can be entered in a number of ways. Depending on the situation,
    some parameters may require a static value, and some may need to be driven by
    other values and inputs. Each parameter has three modes. Each mode is quite different
    and each defines how the parameter behaves. The three modes are:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以通过多种方式输入。根据情况，某些参数可能需要静态值，而某些参数可能需要由其他值和输入驱动。每个参数都有三种模式。每种模式都非常不同，并且每种都定义了参数的行为。这三种模式分别是：
- en: Constant mode
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 常量模式
- en: Expression mode
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表达式模式
- en: Export mode
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出模式
- en: Constant mode is the default for most parameters, and is represented by a grey
    colour scheme in the value field. Expression mode is used for Python, tscript,
    or mathematical operations and scripts. Expression mode is represented by a dark
    grey and light blue colour scheme. Export mode is used to directly reference CHOP
    channels. It is represented by a light green colour scheme.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数参数的默认模式是常量模式，以灰色方案表示在数值字段中。表达式模式用于Python、tscript或数学运算和脚本。表达式模式以深灰色和浅蓝色方案表示。导出模式用于直接引用CHOP通道。它以浅绿色方案表示。
- en: Each of an Operators parameters can be independently changed between the three
    modes. To change the mode of a parameter, hover the mouse over the parameter's
    name. A '+' sign will appear near the parameter's name, similarly to the diagram
    below.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符的每个参数可以在三种模式之间独立更改。要更改参数的模式，请将鼠标悬停在参数的名称上。在参数的名称附近会出现一个“+”号，与下图类似。
- en: '![](parameters-1.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](parameters-1.png)'
- en: 'Once hovering over the parameter''s name, click it and it will expand, displaying
    more information and options, similarly to the diagram below:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 悬停在参数的名称上后，点击它会展开，显示更多信息和选项，与下图类似：
- en: '![](parameters-2.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](parameters-2.png)'
- en: 'There are three main elements that are available once a parameter is expanded.
    The first on the left, is the parameter''s scripting name. This scripting name
    is needed whenever that parameter is referenced in any of TouchDesigner''s scripting
    languages. In the above diagram, the scripting name for the Noise CHOP''s Roughness
    is ''rough''. Continuing the above example, the Python script to set the Roughness
    of the above Noise CHOP to ''1'' would be:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦参数展开，就会提供三个主要元素。左侧的第一个是参数的脚本名称。无论何时需要引用该参数在TouchDesigner的任何脚本语言中都需要此脚本名称。在上图中，噪声CHOP的粗糙度的脚本名称是'rough'。继续上面的例子，将上述噪声CHOP的粗糙度设置为'1'的Python脚本将是：
- en: '`op(''noise1'').par.rough = 1`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`op(''noise1'').par.rough = 1`'
- en: The second element is the three coloured squares. These squares represent the
    different modes for the parameter, as discussed above. Operator parameters set
    to Constant mode are represented by a filled grey square. This parameter can be
    changed to Expression mode by clicking on the outline of the light blue square.
    Once clicked, the light blue square will be filled, and the value field to the
    right will also be coloured to reflect the parameter's mode.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个元素是三个彩色方块。这些方块代表了上面讨论的参数的不同模式。设置为常量模式的操作符参数由填充的灰色方块表示。可以通过点击浅蓝色方块的轮廓来将此参数更改为表达式模式。一旦点击，浅蓝色方块将被填充，并且右侧的值字段也将被着色以反映参数的模式。
- en: '![](parameters-3.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](parameters-3.png)'
- en: To change the parameter's mode to Export mode, a CHOP channel needs to be dragged
    and dropped on the parameter, at which point it will take up Export mode's colour
    scheme, and the green box will be filled in.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要将参数的模式更改为导出模式，需要将CHOP通道拖放到参数上，此时它将采用导出模式的颜色方案，并且绿色方块将被填充。
- en: '![](parameters-4.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](parameters-4.png)'
- en: The third element of the expanded parameter is the value field. The value field
    displays a different piece of information depending on the parameter mode. In
    Constant mode, the value field displays the current value, and can be edited by
    clicking and typing in the field. In Expression mode, the value field displays
    the script of Python or tscript that is being evaluated. The expression can be
    edited by clicking and typing in the value field. In Export mode, the value field
    displays two pieces of information separated by a colon. The text before the colon
    displays the path of the CHOP that is exporting to this parameter. The text after
    the colon is the name of the channel being exported from the CHOP. Because these
    values are being imposed by another Operator, the value field cannot be edited
    while the parameter is in Export mode.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 展开参数的第三个元素是值字段。值字段显示不同的信息，具体取决于参数模式。在常量模式下，值字段显示当前值，并且可以通过单击并在字段中输入来进行编辑。在表达式模式下，值字段显示正在评估的Python或tscript的脚本。表达式可以通过单击并在值字段中输入来编辑。在导出模式下，值字段显示由冒号分隔的两个信息。冒号前的文本显示导出到此参数的CHOP的路径。冒号后的文本是从CHOP导出的通道的名称。因为这些值是由另一个操作符强加的，所以在参数处于导出模式时无法编辑值字段。
- en: Transport Controls
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输控制
- en: '*2.3 Transport Controls*'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.3 传输控制*'
- en: 'The transport bar functions similarly to the transport bars of many other applications.
    To go through it quickly, from left to right the buttons do the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 运输栏的功能与许多其他应用程序的运输栏类似。从左到右快速浏览按钮的功能如下：
- en: '![](transport-1.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](transport-1.png)'
- en: Resets timeline to frame 1
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将时间轴重置为第1帧
- en: Pause the timeline
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂停时间轴
- en: Play timeline in reverse
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反向播放时间轴
- en: Play timeline forward
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放时间轴向前
- en: Step one frame backward
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向后移动一帧
- en: Step one frame forward
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向前移动一帧
- en: Setting 'Range Limit' to 'Loop' will continuously loop the timeline
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将'范围限制'设置为'循环'将持续循环时间轴
- en: Setting 'Range Limit' to 'Once' will play through the timeline and hold the
    last frame
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将'范围限制'设置为'一次'将播放时间轴并保持最后一帧
- en: The most used functions of the timeline are 'Play' and 'Pause', which can be
    accessed quickly by pressing the 'Space bar' on the keyboard.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 时间轴最常用的功能是'播放'和'暂停'，可以通过快速按键盘上的'空格键'来快速访问。
- en: Timeline Settings
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间轴设置
- en: '*2.4 Timeline Settings*'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.4 时间轴设置*'
- en: Unless media or animations is locked to the timeline, the 'Timeline settings'
    won't need to be regularly accessed. The 'Timeline settings' can be found in the
    bottom left of the window. The key things to know about this area are that the
    project's 'FPS' and 'Tempo' can be changed here. The project's 'FPS' determines
    the rate at which the project will render frames. By default it is set to 60 FPS,
    meaning that TouchDesigner will try to render 60 frames every second. The 'Tempo'
    will set the BPM (beats per minute) of the project, for use by the Beat CHOP.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除非媒体或动画被锁定到时间轴，否则不需要经常访问'时间轴设置'。'时间轴设置'位于窗口左下角。关于这个区域需要知道的关键事项是项目的'FPS'和'节奏'可以在这里更改。项目的'FPS'确定项目渲染帧的速率。默认设置为60
    FPS，这意味着TouchDesigner会尝试每秒渲染60帧。'节奏'将设置项目的BPM（每分钟节拍数），供Beat CHOP使用。
- en: The 'Timeline settings' are use more in situations where animations and media
    need to be locked to a consistent timeline. The frame controls include 'Start'
    and 'End', which control the start frame and end frame of the timeline, as well
    as 'RStart' and 'REnd', which control the loop start and loop end of the timeline.
    With these settings, it is possible to create an animation that spans the entire
    timeline, which could be 4000 frames, while still leaving the option to loop a
    small section of the timeline to work within.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '''时间轴设置''在需要将动画和媒体锁定到一致时间轴的情况下更常用。帧控制包括''开始''和''结束''，控制时间轴的开始帧和结束帧，以及''RStart''和''REnd''，控制时间轴的循环开始和循环结束。通过这些设置，可以创建一个跨越整个时间轴的动画，可能是4000帧，同时仍然可以选择循环时间轴的一小部分以进行工作。'
- en: '![](timeline.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](timeline.png)'
- en: Panes
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面板
- en: '*2.5 Panes*'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.5 面板*'
- en: Using panes regularly can save a ton of time when moving back and forth between
    Networks. Having to travel through 3 Networks to change a parameter, only to have
    to travel back to see the changes is a waste of time. Panes take the current window,
    split it horizontally or vertically as many times as desired. Each pane layout
    can be saved for later use.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 定期使用面板可以在在不同网络之间来回移动时节省大量时间。不得不穿越3个网络来更改参数，然后再返回查看更改是浪费时间的。面板将当前窗口水平或垂直分割多次。每个面板布局都可以保存以供以后使用。
- en: '![](panes-1.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](panes-1.png)'
- en: The diagram above highlights the pane presets that are available by default.
    The presets provide quick access to a few standard configurations of panes including
    split left and right, split top and bottom, a 3 pane setup, and a 4 pane setup.
    Saving pane presets is as easy as clicking the 'Add New Layout +' button, entering
    a name, and clicking 'Ok'. Saving a layout not only saves the size and position
    of the panes, but also saves each pane's type.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上图突出显示了默认可用的面板预设。这些预设提供了对几种标准面板配置的快速访问，包括左右分割，上下分割，3个面板设置和4个面板设置。保存面板预设就像点击'添加新布局+'按钮，输入名称，然后点击'确定'一样简单。保存布局不仅保存了面板的大小和位置，还保存了每个面板的类型。
- en: Panes are able to display unique types of content, whether they are other dialogs,
    Networks, or viewers. Being able to mix and match combinations of viewers and
    Network editors allows for a lot of flexibility. In the diagram below, the top
    left pane is a Network editor. On the right-hand side, is a Textport, and on the
    bottom-left, there is a Geometry Viewer. Again, saving this layout would not only
    save the pane arrangement, but also the pane types. This is useful when working
    on a project with a lot of different elements, where jumping between something
    like the setup above, and a simple Network editor, can save quite a bit of time
    in the long run.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 窗格能够显示各种独特类型的内容，无论是其他对话框、网络还是查看器。能够混合和匹配查看器和网络编辑器的组合允许有很大的灵活性。在下面的图表中，左上角的窗格是网络编辑器。右侧是文本端口，左下方是几何查看器。再次保存此布局不仅会保存窗格排列，还会保存窗格类型。在处理具有许多不同元素的项目时，跳转到上述设置和简单的网络编辑器之间可以在长期内节省���当多的时间。
- en: '![](panes-2.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](panes-2.png)'
- en: 'The keyboard shortcuts for working with panes are as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与窗格一起工作的键盘快捷键如下：
- en: 'Alt + [ : Vertically split current pane under mouse'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alt + [：在鼠标下垂直拆分当前窗格
- en: 'Alt + ] : Horizontally split current pane under mouse'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alt + ]：在鼠标下水平拆分当前窗格
- en: 'Alt + Z : close pane under mouse'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alt + Z：关闭鼠标下的窗格
- en: Palette Browser
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调色板浏览器
- en: '*2.6 Palette Browser*'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.6 调色板浏览器*'
- en: The Palette Browser can be thought of as a component library. The Palette Browser
    holds '.tox' files (or TouchDesigner Component files). These files contain a single
    Component Operator, that can hold a Network of other Operators. This means that
    a series of frequently used Operators, UI components, Python scripts, and more,
    can be created inside of a single Component Operator, saved as a '.tox' file,
    and quickly accessed at any time in the future.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 调色板浏览器可以被视为组件库。调色板浏览器保存'.tox'文件（或TouchDesigner组件文件）。这些文件包含一个单一的组件运算符，可以包含其他运算符的网络。这意味着一系列经常使用的运算符、UI组件、Python脚本等可以在单个组件运算符内创建，保存为'.tox'文件，并在将来任何时候快速访问。
- en: Open the Palette Browser, and look through the large number of pre-existing
    '.tox' files that are available. Blank projects start with the Palette Browser
    open by default, and docked to the left side of the window. To open the Palette
    Browser as a floating window, use the keyboard command 'Alt + L'. Let's try one
    of the pre-built components.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 打开调色板浏览器，并查看大量可用的预先存在的'.tox'文件。空白项目默认情况下以调色板浏览器打开，并停靠在窗口的左侧。要将调色板浏览器打开为浮动窗口，请使用键盘命令'Alt
    + L'。让我们尝试一个预构建的组件。
- en: Under the 'Derivative' section, navigate to 'Tools', and then finally drag and
    drop the 'Blend' component into a new project. Looking at the 'Blend' component's
    UI, it is clear that there is quite a bit going on inside. Before diving deeper,
    take a moment to connect two inputs and try the 'Blend' component. Activate the
    viewer, click on the button underneath the image to select a blend mode, and then
    drag the semi-transparent handle across the image to blend between the inputs.
    This is a useful tool, and all it took was a simple drag and drop from the Palette
    Browser!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在'Derivative'部分下，导航到'Tools'，最后将'Blend'组件拖放到新项目中。查看'Blend'组件的用户界面，很明显里面有很多内容。在深入之前，花点时间连接两个输入并尝试'Blend'组件。激活查看器，单击图像下方的按钮选择混合模式，然后拖动半透明手柄在图像之间混合输入。这是一个有用的工具，只需从调色板浏览器简单拖放即可！
- en: One of the goals of this book is to create some tools that can be added to the
    Palette Browser, so that they may be used regularly. There are two ways to add
    a component to the Palette Browser. The first is a drag and drop method. To do
    so, select 'My Components' from the top portion of the browser. Then drag any
    component from the Network and drop it into the lower portion of the Palette Browser.
    It will then be added to 'My Components' repository. The second method of adding
    a component is to drag a saved '.tox' file from Windows Explorer, and drop it
    in the same region mentioned above. The diagram below illustrates exactly where
    components should be dropped.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一个目标是创建一些可以添加到调色板浏览器中的工具，以便可以定期使用它们。有两种方法可以将组件添加到调色板浏览器中。第一种是拖放方法。要这样做，请从浏览器的顶部部分选择'My
    Components'。然后将网络中的任何组件拖放到调色板浏览器的下部分。然后它将被添加到'My Components'存储库中。添加组件的第二种方法是从Windows资源管理器中拖动保存的'.tox'文件，然后将其放在上述相同区域中。下面的图表清楚地说明了组件应该放置的位置。
- en: '![](palette-1.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](palette-1.png)'
- en: Search Dialog
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索对话框
- en: '*2.7 Search Dialog*'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.7 搜索对话框*'
- en: The 'Search Dialog' is incredibly helpful as projects become more complicated,
    and riddled with Python scripts and nested Networks. The 'Search Dialog' can find
    a multitude of things in a multitude of places, and searches can be as broad,
    or specific, as needed. It is accessible in the 'Edit' menu at the top of the
    screen, or by pressing 'F3' on the keyboard.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '''搜索对话框''在项目变得更加复杂，并且充斥着Python脚本和嵌套网络时非常有帮助。''搜索对话框''可以在多个地方找到多种东西，搜索可以根据需要进行广泛或具体的搜索。它可以在屏幕顶部的''编辑''菜单中访问，或者通过键盘上的''F3''键进行访问。'
- en: 'The ''Basic'' search can not only find Operators, but can search through Python
    code. Frequently, Python is used to change Operator parameter values. Sometimes,
    in the thick of Python scripts, it is easy to lose track of specific lines of
    code. A quick search for the code below will return a list of every single line
    of code that involves changing parameters of the Operators with ''transform''
    in their name:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '''基本''搜索不仅可以找到运算符，还可以搜索Python代码。经常使用Python来更改运算符参数值。有时，在Python脚本的深处，很容易迷失特定的代码行。快速搜索下面的代码将返回涉及更改具有名称中带有''transform''的运算符参数的每一行代码的列表：'
- en: '`op(''transform'').par`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`op(''transform'').par`'
- en: Sifting through the results is much easier than manually looking through Networks
    full of code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览结果比手动查看充满代码的网络要容易得多。
- en: The 'Advanced' search can search by any combination of name, Operator type,
    comments, flags, and more. When returning to past projects, often it takes some
    time to relocate and reacclimatize to the inner workings of complex logic systems.
    This is when searching for operators by vague name and type can save a ton of
    time. For example, in an extremely nested system, somewhere in the depths of it
    might be a Movie In TOP that has the word 'movie' in its name. These little pieces
    of information about the Operator type, and partial name, can be used to create
    a fairly precise search.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '''高级''搜索可以按任何组合的名称、操作类型、注释、标志等进行搜索。当返回到过去的项目时，通常需要一些时间来重新定位和重新适应复杂逻辑系统的内部运作。这就是在通过模糊名称和类型搜索运算符时可以节省大量时间的时候。例如，在一个极其嵌套的系统中，可能会有一个在其名称中包含''电影''一词的Movie
    In TOP。关于运算符类型和部分名称的这些小信息可以用来创建一个相当精确的搜索。'
- en: When a search has yielded results, each result can be clicked on to open the
    Network in a new floating pane. Here, the results can be can quickly previewed,
    and simple changes can be made within this pane, without affecting the current
    work area.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当搜索产生结果时，每个结果都可以点击以在新的浮动窗格中打开网络。在这里，结果可以快速预览，并且可以在此窗格内进行简单更改，而不会影响当前工作区。
- en: Realtime Flag
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时标志
- en: '*2.8 Realtime Flag*'
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.8 实时标志*'
- en: '![](realtime-1.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](realtime-1.png)'
- en: The Realtime flag changes TouchDesigner's behaviour significantly. When it is
    active (it is active by default), TouchDesigner will always prioritize real-world
    time. In a simple example, if a movie file is 30 seconds long, no matter what
    happens, TouchDesigner will try to play it over the course of 30 seconds. If this
    means that frames need to be dropped, TouchDesigner will try to honour time. This
    is the mode used for most real-time installation and performance work.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 实时标志会显著改变TouchDesigner的行为。当它激活时（默认情况下是激活的），TouchDesigner将始终优先考虑真实世界的时间。举个简单的例子，如果一个电影文件长达30秒，无论发生什么，TouchDesigner都会尝试在30秒内播放它。如果这意味着需要丢帧，TouchDesigner会尽量遵守时间。这是用于大多数实时安装和表演工作的模式。
- en: When the Realtime flag is off, TouchDesigner will prioritize frame rendering
    over real-world time. In the example mentioned above, if Realtime is off, TouchDesigner
    would take as long as it needed to process and render each frame, falling out
    of real-world time to display every frame. This mode is useful when exporting
    complex animations or 3D renderings. Imagine this mode to be similar to a real-time
    version of rendering out of Adobe After Effects.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当实时标志关闭时，TouchDesigner将优先考虑帧渲染而不是真实世界的时间。在上面提到的例子中，如果实时关闭，TouchDesigner将花费所需的时间来处理和渲染每一帧，脱离真实世界的时间来显示每一帧。这种模式在导出复杂动画或3D渲染时非常有用。想象这种模式类似于从Adobe
    After Effects中实时渲染的版本。
- en: Useful Shortcuts
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的快捷键
- en: '*2.9 Useful Shortcuts*'
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*2.9 有用的快捷键*'
- en: 'Below is a bullet point list of some useful shortcuts:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些有用快捷键的项目符号列表：
- en: 'When hovering over the Network:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当悬停在网络上时：
- en: '''P'' - Opens and closes the selected Operator''s Parameter window'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''P'' - 打开和关闭所选运算符的参数窗口'
- en: '''O'' - Opens and closes a visual overview of the Network in the bottom-left
    corner of the pane'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''O'' - 打开和关闭窗格左下角的网络可视化概览'
- en: '''C'' - Opens and closes the Colour Palette. This can add a coloured outline
    to the selected Operators for easier identification'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''C'' - 打开和关闭颜色调色板。这可以为选定的操作器添加彩色轮廓，以便更容易识别'
- en: 'With an Operator(s) selected:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个或多个操作器时：
- en: '''A'' - Allows interaction with the Operator''s viewer'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''A'' - 允许与操作器的查看器进行交互'
- en: '''B'' - Bypass and un-bypass the selected Operator'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''B'' - 绕过选定的操作器'
- en: '''H'' - Performs the ''Home All'' action on the Network, which is the equivalent
    to fitting all Operators of a Network onto the screen'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''H'' - 对网络执行“Home All”操作，这相当于将网络中的所有操作器适配到屏幕上'
- en: '''Shift + H'' - Performs the ''Home Selected'' action which fits all the selected
    Operators onto the screen'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''Shift + H'' - 执行''Home Selected''动作，将所有选择的操作器适配到屏幕上'
- en: '''R'' - Toggles the Operator''s Render Flag (if it has one)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''R'' - 切换操作器的渲染标志（如果有的话）'
- en: '''D'' - Toggles the Operator''s Display Flag (if it has one)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''D'' - 切换操作器的显示标志（如果有的话）'
- en: '''Control + C'' - Copy selected Operators'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''Control + C'' - 复制选择的操作器'
- en: '''Control + V'' - Paste copied Operators'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''Control + V'' - 粘贴复制的操作器'
- en: '''Control + Shift + V'' - Paste copied Operators at the mouse'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''Control + Shift + V'' - 在鼠标位置粘贴复制的操作器'
- en: Introduction
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 3 TOPs
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3个TOPs
- en: '*3.1 Introduction*'
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*3.1 介绍*'
- en: Texture Operators, or TOPs, are a fundamental aspect of almost every project.
    They are the 2D texture Operators that handle everything from movie playback,
    3D geometry rendering, compositing, hardware video inputs and outputs, and are
    used to process everything that will be output to a monitor, projector, or LED
    display.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理操作器，或称为TOPs，是几乎每个项目中的基本组成部分。它们是处理从影片播放、3D几何渲染、合成、硬件视频输入和输出的2D纹理操作器，并用于处理将输出到显示器、投影仪或LED显示器的所有内容。
- en: Movie In TOP
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Movie In TOP
- en: '*3.2 Movie In TOP*'
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*3.2 Movie In TOP*'
- en: 'The Movie In TOP is one of the most used TOPs. It''s function is to load assets
    into TouchDesigner. It is capable of loading many different types of assets, ranging
    from still images to a variety of movie codecs. Below is a small list of common
    file formats used with the Movie In TOP:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Movie In TOP 是最常用的TOP之一。它的功能是将资产加载到 TouchDesigner 中。它能够加载许多不同类型的资产，从静止图像到各种电影编解码器。以下是与
    Movie In TOP 一起使用的常见文件格式的小列表：
- en: .mov
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .mov
- en: .mp4
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .mp4
- en: .avi
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .avi
- en: .tiff
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .tiff
- en: .jpeg
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .jpeg
- en: .png
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .png
- en: There are many more supported file formats, which are listed on the Derivative
    TouchDesigner 088 wiki under the 'File Types' page.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多支持的文件格式，在Derivative TouchDesigner 088维基的“文件类型”页面中列出。
- en: There are a few of great features built into the Movie In TOP that can significantly
    reduce the headaches involved with quickly ingesting and outputting assets with
    different frame-rates. The main feature is that the Movie In TOP's goal is to
    playback assets while staying true to its time duration. For example, if the project
    is set to 60FPS and an asset is made at 30FPS and is 10 seconds long, it will
    play over the course of 10 seconds, regardless of FPS differences between the
    project and the asset. The opposite is true as well. If a 10 second asset created
    at 60 FPS is played in a 30FPS timeline, it will play over the course of 10 seconds.
    In both of these cases frames are either doubled or discarded to stay true to
    each asset's real-world time length. This makes interpolation of frames a good
    idea in some situations.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Movie In TOP 内置了一些很棒的功能，可以极大地减少快速摄入和输出具有不同帧速率的资产所涉及的问题。其主要功能是，Movie In TOP 的目标是在保持其时间持续性的同时播放资产。例如，如果项目设置为60FPS，而一个以30FPS制作的资产长达10秒，那么它将在10秒内播放，而不考虑项目和资产之间的FPS差异。反之亦然。如果在30FPS时间轴中播放以60
    FPS创建的10秒资产，则会在10秒内播放。在这两种情况下，帧数要么翻倍，要么丢弃，以保持每个资产的真实时间长度。这在某些情况下使帧的插值成为一个好主意。
- en: Preloading Movies
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预加载影片
- en: '*3.3 Preloading Movies*'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*3.3 预加载影片*'
- en: When creating real-time applications, continuous dropped frames can greatly
    detract from presentation and impact. Diagnosing performance issues is something
    that will be discussed in a later chapter, but many preventative measures can
    be taken. Preloading and unloading Movie In TOPs is one of these preventative
    measures. The simple procedure of preloading and unloading movies is often overlooked
    by new users because the easiest methods involve scripting.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建实时应用程序时，连续丢帧会严重影响展示效果和影响。诊断性能问题将在后面的章节中讨论，但可以采取许多预防措施。预加载和卸载电影播放器是其中之一。新用户通常忽略了预加载和卸载电影的简单程序，因为最简单的方法涉及脚本编写。
- en: 'Open example ''Preloading.toe''. This example has a set of three buttons. The
    ''Preload'' button uses the following Python function to preload the number of
    frames set in the ''Pre-Read frames'' parameter in the ''Tune'' parameters of
    the Operator ''moviein1'':'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例'Preloading.toe'。此示例有一组三个按钮。'Preload'按钮使用以下Python函数预加载在'电影播放器'操作符的'Tune'参数中设置的'Pre-Read
    frames'参数中设置的帧数：
- en: '`op(''moviein1'').preload()`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`op(''moviein1'').preload()`'
- en: 'The ''Play'' button starts playback of the Movie In TOP. The ''Unload'' button
    stops ''moviein1'' playback, and then unloads the movie, freeing up whatever system
    resources were being used. This is done with the following Python script:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '''Play''按钮开始播放Movie In TOP。''Unload''按钮停止''moviein1''的播放，然后卸载电影，释放正在使用的任何系统资源。下面是使用以下Python脚本完成的：'
- en: '`op(''play'').click(0)`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`op(''play'').click(0)`'
- en: '`op(''moviein1'').unload()`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`op(''moviein1'').unload()`'
- en: It is best practice to preload movies before playing them, otherwise there is
    a high risk of dropping frames upon playback.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是在播放电影之前预加载电影，否则有很高的丢帧风险。
- en: Null TOPs and Select TOPs
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空的TOP和选择的TOP
- en: '*3.4 Null TOPs and Select TOPs*'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*3.4 空TOP和选择TOP*'
- en: In contrast to expensive TOPs, like the Blur TOP, some TOPs are 'free', and
    should be used generously! Two specific examples are Null TOPs and Select TOPs.
    These two Operators, although they don't alter any pixel, are incredibly helpful
    in creating more efficient workflows.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与昂贵的TOP（如模糊TOP）相比，一些TOP是'免费'的，并且应该慷慨地使用！两个具体的例子是空TOP和选择TOP。尽管这两个操作符不会改变任何像素，但它们在创建更有效的工作流程方面非常有帮助。
- en: The difference between an illegible network, with wires overlapping and sprawled
    everywhere, and an easily followable Network are some properly placed Null TOPs
    and Select TOPs. Open examples 'Null_1.toe' and 'Null_2.toe'. The first file is
    a mish-mash of TOPs which are composited together. In this file, there is little
    regard for the layout of the Network, and the wires are overlapped by other Operators
    and other wires, making it difficult to trace any particular series of Operators.
    In 'Null_2.toe' a column of Null TOPs are laid out to gather all the signals before
    they are composited. This column of Null TOPs can serve as a checkpoint, and even
    at quick glance, makes it much easier to follow series of operations.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无法辨认的网络，其中电线重叠且随处可见，与一个易于跟踪的网络之间的区别在于，一些适当放置的空TOP和选择的TOP。打开示例'Null_1.toe'和'Null_2.toe'。第一个文件是一堆在一起的TOP，它们被合成在一起。在这个文件中，对网络布局几乎没有考虑，电线被其他操作符和其他电线覆盖，使得难以追踪任何特定的一系列操作符。在'Null_2.toe'中，一列空TOP被布置在一起，以在它们被合成之前收集所有信号。这一列空TOP可以作为一个检查点，在快速浏览时，使得更容易跟踪一系列操作。
- en: The same case can be made for Select TOPs. When working with nested Networks,
    using the Out TOP and pulling connections between containers can lead to the same
    situation as above, where Networks become illegible rather quickly. The Select
    TOPs can quickly and neatly reference other TOPs. Open example 'Select_1.toe'.
    This examples demonstrates how using In TOPs and Out TOPs can lead to extra clutter.
    This example is only replicating the movie 12 times! What would happen if there
    needed to be 100 of them? This is where the Select TOP comes in handy.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的情况也适用于选择TOP。当使用嵌套网络时，使用Out TOP并在容器之间拉取连接会导致与上述情况相同的情况，其中网络变得非常难以辨认。选择的TOP可以快速而整洁地引用其他TOP。打开示例'Select_1.toe'。这个示例演示了如何使用In
    TOP和Out TOP会导致额外的混乱。这个示例只是复制了电影12次！如果需要100次呢？这就是选择的TOP派上用场的地方。
- en: Open example 'Select_2.toe'. This example exponentially increases the amount
    of replicated components while being simultaneously more legible. Even more interesting
    is the dynamic selection system created using the Select TOPs. This is much more
    efficient than the manual method from before, and allows a Python script in the
    Select TOP's 'Select' parameter to automatically reference the corresponding replicated
    TOPs from the Network above, based on the digits in their names. To take this
    concept one step further, a Select DAT is used to drive a Replicator COMP that
    creates a new Select TOP, and automatically wires it to the Composite TOP every
    time a new item is added with the first Replicator COMP. Don't worry if this example
    seems daunting, Replicators and Scripting will be covered in later examples. For
    now, the important thing to note is that by using Select TOPs and very simple
    scripting, this component is relatively future-proof and won't require much maintenance.
    When it comes time to replicate more items, it's as easy as adding a row to a
    table.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例'Select_2.toe'。这个示例在同时更易读的情况下指数增加了复制的组件数量。更有趣的是使用Select TOPs创建的动态选择系统。这比以前的手动方法要高效得多，并且允许Select
    TOP的“Select”参数中的Python脚本自动引用上面网络中基于其名称中的数字的相应复制TOPs。为了进一步发展这个概念，使用Select DAT来驱动一个Replicator
    COMP，创建一个新的Select TOP，并在每次使用第一个Replicator COMP添加新项目时自动将其连接到Composite TOP。如果这个示例看起来令人生畏，不要担心，复制器和脚本将在后续示例中介绍。目前，需要注意的重要事情是，通过使用Select
    TOPs和非常简单的脚本，这个组件相对具有未来性，并且不需要太多维护。当需要复制更多项目时，只需向表中添加一行即可。
- en: Codecs
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编解码器
- en: '*3.5 Codecs*'
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*3.5 编解码器*'
- en: Movie playback is a taxing process. It is wise to spend time experimenting with
    different codecs to see which one suits a project in terms of visual quality and
    performance.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 电影播放是一个繁重的过程。花时间尝试不同的编解码器，看哪一个在视觉质量和性能方面适合项目是明智的。
- en: Before diving into specific codecs, it is important to know the difference between
    a codec and a container. Codec has taken over as the general term for the file
    format of audio-video files, which is confusing for beginners, because many containers
    can hold multiple codecs.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解特定编解码器之前，了解编解码器和容器之间的区别是很重要的。编解码器已经成为音视频文件的文件格式的通用术语，这对初学者来说很令人困惑，因为许多容器可以容纳多个编解码器。
- en: Codec stands for compressor-decompressor. The codec has two main tasks. The
    first is to compress video data for storage and transportation, and the second
    is to decompress the video data for playback. Because of these different tasks,
    each codec is made for a different purpose. Some prioritize compression for light
    weight, portable files, while others prioritize quality, for long-term preservation
    of content. Different projects will have different requirements. Sometimes, the
    goal is to play back a single piece of content at the highest quality possible,
    whereas other times, quality must be sacrificed to be able to playback multiple
    video files simultaneously. Finding the right codec for each project may require
    a few tests and some forethought, but it is time well spent.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 编解码器代表压缩-解压缩。编解码器有两个主要任务。第一个是为存储和传输压缩视频数据，第二个是为播放解压缩视频数据。由于这些不同的任务，每个编解码器都是为不同的目的而制作的。有些优先考虑轻便便携文件的压缩，而其他一些则优先考虑质量，以便长期保存内容。不同的项目将有不同的要求。有时，目标是以最高质量播放单个内容，而其他时候，必须牺牲质量以能够同时播放多个视频文件。为每个项目找到合适的编解码器可能需要一些测试和一些事先考虑，但这是值得花时间的。
- en: A container does exactly what its name implies. It holds the compressed video,
    audio, and all the metadata a movie player needs to properly decompress and playback
    the content. There are quite a few different containers, but they have much less
    of an impact on the overall programming workflow, compared to codecs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 容器确实做了其名称所暗示的事情。它保存了压缩的视频、音频以及电影播放器需要正确解压缩和播放内容的所有元数据。有许多不同的容器，但与编解码器相比，它们对整体编程工作流程的影响要小得多。
- en: Things can get complicated when different combinations of containers and codecs
    are used. Imagine a file named 'test_movie.mov'. In one example, this file could
    be an Animation codec compressed video file inside of a '.mov' QuickTime container.
    What's interesting, and what also confuses many beginners, is that in another
    example, this file could be an H.264 compressed video file inside of a QuickTime
    container. To add to confusion, the same H.264 file could also be inside of a
    '.mp4', or MPEG-4 Part 14, container.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用不同的容器和编解码器的组合时，情况可能会变得复杂。想象一个名为'test_movie.mov'的文件。在一个示例中，这个文件可能是一个Animation编解码器压缩的视频文件，位于'.mov'
    QuickTime容器内。有趣的是，也令许多初学者困惑的是，在另一个示例中，这个文件可能是一个H.264压缩的视频文件，位于QuickTime容器内。增加了混淆的是，同一个H.264文件也可以位于'.mp4'或MPEG-4
    Part 14容器内。
- en: 'Confusion aside, some popular codec choices are currently the HAP family, H.264,
    Animation codec, and Cineform. Each codec has its own set of advantages and disadvantages.
    Below is a very quick point form list of some pros and cons to each:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 除了混乱外，一些流行的编解码器选择目前包括HAP系列、H.264、动画编解码器和Cineform。每种编解码器都有其自身的优缺点。以下是一份非常简要的每种编解码器的一些优缺点的列表：
- en: '**HAP family**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**HAP系列**'
- en: '*Pros*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: Can playback extremely high resolutions and high frame rates
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以播放极高分辨率和高帧率的视频
- en: Very little CPU cost
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU成本极低
- en: HAP Q is visually lossless
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HAP Q是视觉上无损的
- en: Very little GPU cost
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPU成本极低
- en: '*Cons*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: Large file sizes
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件大小大
- en: Difficult to batch encode files on Windows
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上批量编码文件困难
- en: Must use SSDs or a RAID0 of SSDs for file playback
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须使用SSD或SSD的RAID0来播放文件
- en: Main bottleneck is hard drive read speeds
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要瓶颈是硬盘读取速度
- en: '**H.264**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**H.264**'
- en: '*Pros*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: Creates extremely light-weight/low file size videos
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建极轻量级/低文件大小的视频
- en: Best bang for buck when comparing quality to file size
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在比较质量和文件大小时性价比最高
- en: Low disk usage
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低磁盘使用率
- en: '*Cons*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: Requires a large number of CPU cores to playback extremely high resolutions
    or high frame rate.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要大量CPU核心来播放极高分辨率或高帧率。
- en: Can experience colour quantization if proper care is not taken in encoding
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果编码时没有采取适当的措施，可能会出现颜色量化
- en: Bit rate is highly dependent on content
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特率高度依赖内容
- en: 4096 pixel size resolution in both length and width
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分辨率可以达到4096像素大小的长度和宽度
- en: Difficult to create alpha channels
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Alpha通道困难
- en: '**Animation Codec**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**动画编解码器**'
- en: '*Pros*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: 100% quality is a lossless file
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 100%质量是无损文件
- en: Prioritizes quality
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先考虑质量
- en: Has native support for Alpha channel
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有本地支持Alpha通道
- en: '*Cons*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: Large file sizes
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件大小大
- en: Demanding on both hard drives and CPU
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对硬盘和CPU都要求高
- en: Bit rate fluctuates with amount of detail in video content
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比特率随视频内容中的细节数量而波动
- en: '**Cineform**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cineform**'
- en: '*Pros*'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*优点*'
- en: Constant bit rate
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恒定比特率
- en: High image quality
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高图像质量
- en: Native Alpha channel support
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地Alpha通道支持
- en: '*Cons*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*缺点*'
- en: file sizes
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件大小
- en: Must purchase encoding software from Cineform
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须从Cineform购买编码软件
- en: Introduction
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 4 CHOPs
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 CHOPs
- en: '*4.1 Introduction*'
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*4.1介绍*'
- en: 'The Channel Operators, or CHOP, family of Operators handle all channel operations
    including motion data, audio inputs, key-frame animations, hardware inputs (from
    Microsoft Kinect, Leap Motion, Oculus Rift, pen tablets, keyboards, mice, etc),
    DMX, MIDI, and OSC. These are the Operators that handle inputs, processing, and
    outputs, of the data used to communicate with many types of audio-visual gear
    such as:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通道操作器或CHOP家族的操作器处理所有通道操作，包括动作数据、音频输入、关键帧动画、硬件输入（来自Microsoft Kinect、Leap Motion、Oculus
    Rift、笔式平板电脑、键盘、鼠标等）、DMX、MIDI和OSC。这些是处理与许多类型的音频视觉设备通信所使用的数据的输入、处理和输出的操作器，例如：
- en: Mixers
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混音器
- en: MIDI controllers
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MIDI控制器
- en: Synths
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合成
- en: DMX lighting fixtures
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DMX照明设备
- en: Microsoft Kinect cameras
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Kinect相机
- en: Computers running TouchDesigner
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行TouchDesigner的计算机
- en: Loudspeakers
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扬声器
- en: Other audio-video applications like Max/MSP, Ableton Live, Resolume Arena
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他音频视频应用程序，如Max/MSP、Ableton Live、Resolume Arena
- en: Communication Methods
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信方法
- en: '*4.2 Communication Methods*'
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*4.2通信方法*'
- en: 'MIDI works with an extensive amount of existing software and hardware. Digital
    Audio Workstations, or DAWs, like Ableton Live, Avid Pro Tools, Propellerhead
    Reason, and more, all support MIDI input and output. It is a relatively fast,
    stable, and time-tested protocol. Audio performance controllers often come equipped
    with MIDI over USB. These controllers include inputs hardware with controls such
    as: buttons, faders, piano keys, touch strips, jog wheels, drum pads, and potentiometers.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: MIDI与大量现有软件和硬件兼容。数字音频工作站（DAWs），如Ableton Live，Avid Pro Tools，Propellerhead Reason等，都支持MIDI输入和输出。这是一个相对快速，稳定且经过时间考验的协议。音频性能控制器通常配备有MIDI
    over USB。这些控制器包括具有控件的硬件输入，如：按钮，推子，钢琴键，触摸条，旋钮轮，鼓垫和电位器。
- en: Programming environments such as Cycling 74 Max/MSP, PureData, Native Instruments
    Reaktor, and more, have support for OSC messaging. OSC messaging has the benefit
    of modern networking technology, higher resolutions than MIDI, channel naming,
    and many structural improvements. OSC messaging can be sent over UDP or TCP connections,
    making it incredibly easy to network, and transmit long distances in real-time.
    Currently, OSC is more commonly used as a communication method between softwares
    and computer systems.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 编程环境，如Cycling 74 Max/MSP，PureData，Native Instruments Reaktor等，都支持OSC消息传递。OSC消息传递具有现代网络技术的优势，比MIDI具有更高的分辨率，通道命名和许多结构改进。OSC消息可以通过UDP或TCP连接发送，使其非常容易进行网络传输，并实时传输长距离。目前，OSC更常用作软件和计算机系统之间的通信方法。
- en: DMX is a protocol used by lighting fixtures and controllers. Many DMX fixtures
    have various channels for dimmers, various settings, built-in chases, RGB channels,
    motor automation, and more. Many lighting controllers and desks use DMX protocol
    to communicate with fixtures and video-computer systems. With the many types of
    controllers and desks available, their manuals will be invaluable when creating
    projects with them in mind. In general, all of a fixture's channels need to be
    accounted for, even if they aren't being actively used. There are many ways to
    optimize the workflow of sending and receiving DMX data, mostly concerning the
    management and organization of channels. These will be looked at in later examples.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: DMX是灯具和控制器使用的协议。许多DMX灯具具有各种通道，用于调光器，各种设置，内置追逐，RGB通道，电机自动化等。许多灯光控制器和控制台使用DMX协议与灯具和视频计算机系统进行通信。有许多类型的控制器和控制台可用，当考虑到它们时，它们的手册将是无价的。一般来说，即使未被积极使用，所有灯具的通道都需要考虑在内。有许多优化发送和接收DMX数据的工作流程的方法，主要涉及通道的管理和组织。这些将在后面的示例中进行讨论。
- en: Sync In CHOP and Sync Out CHOP are used to frame sync internal and external
    instances of TouchDesigner. They use the OSC protocol for their underlying communication.
    These two Operators work by communicating the state of each frame on every synced
    machine. Once all sync machines confirm that they have rendered the current frame,
    they simultaneously move to the next frame. This sequence of events is repeated
    for every frame and keeps the synced machines always on the same frame.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Sync In CHOP和Sync Out CHOP用于帧同步TouchDesigner的内部和外部实例。它们使用OSC协议进行底层通信。这两个操作符通过在每个同步机器上通信每帧的状态来工作。一旦所有同步机器确认已渲染当前帧，它们同时转移到下一帧。这一系列事件为每一帧重复进行，并始终使同步机器保持在同一帧上。
- en: Audio Inputs and Outputs
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 音频输入和输出
- en: '*4.3 Audio Inputs and Outputs*'
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*4.3 音频输入和输出*'
- en: Audio can be processed from a variety of sources, and can be processed in a
    variety of ways. TouchDesigner is capable of processing audio from audio files,
    movie files, external audio interfaces, internet audio streams, and can even synthesize
    audio from nothing.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 音频可以从各种来源处理，并且可以以各种方式处理。TouchDesigner能够处理来自音频文件，电影文件，外部音频接口，互联网音频流的音频，甚至可以从无中合成音频。
- en: Most projects involving sound design and audio tracks will include dedicated
    audio files. TouchDesigner is capable of reading and playing many standard audio
    formats such as MP3, AIFF, and WAV, through the use of the Audio File In CHOP
    and the Audio Play CHOP. These files can be looped, cued, re-pitched, and trimmed,
    allowing for flexible uses of samples and audio files.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数涉及声音设计和音轨的项目都将包含专用音频文件。TouchDesigner能够通过使用Audio File In CHOP和Audio Play CHOP读取和播放许多标准音频格式，如MP3，AIFF和WAV。这些文件可以循环播放，预备播放，重新调整音高和修剪，从而灵活使用样本和音频文件。
- en: The Audio Movie CHOP can be used to playback audio from a movie file. Instead
    of reading audio by referencing a file, this CHOP references a Movie In TOP. This
    is useful because it keeps the audio in sync with the video playing back in the
    Movie In TOP, and comes with a parameter that can be used to offset the audio
    to better match the video.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Audio Movie CHOP 可用于从电影文件播放音频。与通过引用文件读取音频不同，此 CHOP 引用一个 Movie In TOP。这很有用，因为它将音频与
    Movie In TOP 中播放的视频同步，并带有一个参数，可用于偏移音频以更好地匹配视频。
- en: There are many different external audio interfaces that can be used with TouchDesigner.
    It is best to refer to the Derivative TouchDesigner Wiki and Forum for a more
    comprehensive list of compatible devices.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的外部音频接口可与 TouchDesigner 一起使用。最好参考衍生 TouchDesigner Wiki 和论坛，以获取更全面的兼容设备列表。
- en: These devices provide analog and digital audio inputs and outputs. These can
    be inputs from musicians and instrumentalists, audio mixing consoles, professional
    video cameras, other computer systems, and much more. These devices can output
    audio to many of the above mentioned destinations, as well as to loud speaker
    systems. The CHOPs used to communicate with external interfaces are the Audio
    Device In CHOP and the Audio Device Out CHOP. Each respectively handles the inputs
    and outputs, to and from, a project. There is an Audio SDI CHOP which is used
    in conjunction with the nVidia Quadro SDI card, to receive audio from external
    SDI sources.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备提供模拟和数字音频输入和输出。这些可以是音乐家和乐器演奏者、音频混音控制台、专业视频摄像机、其他计算机系统等的输入。这些设备可以将音频输出到上述许多目的地，以及音响系统。用于与外部接口通信的
    CHOP 是 Audio Device In CHOP 和 Audio Device Out CHOP。它们分别处理项目中的输入和输出。有一个 Audio
    SDI CHOP 与 nVidia Quadro SDI 卡配合使用，用于从外部 SDI 源接收音频。
- en: There are two different audio drivers that can be accessed from within TouchDesigner.
    DirectSound has been available since previous versions of TouchDesigner, and has
    been developed as a part of DirectX. It is a mature driver, having been in development
    for many years, and provides relatively low latencies even under heavy use.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: TouchDesigner 内可以访问两种不同的音频驱动程序。DirectSound 从 TouchDesigner 的先前版本就已经可用，并作为 DirectX
    的一部分进行了开发。它是一个成熟的驱动程序，经过多年的开发，即使在重度使用下也能提供相对较低的延迟。
- en: ASIO is a new addition to TouchDesigner 088\. It has been developed by Steinberg
    to improve on one of DirectX's main drawbacks, which is that DirectX feeds all
    audio through the Windows operating system. Bypassing the operating system, the
    ASIO driver is able to communicate directly with external audio hardware, thus
    creating lower latencies than what was previously possible with DirectSound.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ASIO 是 TouchDesigner 088 的新功能。它由 Steinberg 开发，旨在改善 DirectX 的主要缺点之一，即 DirectX
    通过 Windows 操作系统传输所有音频。绕过操作系统，ASIO 驱动程序能够直接与外部音频硬件通信，从而创造出比以前通过 DirectSound 可能性更低的延迟。
- en: Once inputs and outputs are setup in TouchDesigner, they can be routed much
    like any other data.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在 TouchDesigner 中设置了输入和输出，它们可以像任何其他数据一样进行路由。
- en: Sample Rates
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采样率
- en: '*4.4 Sample Rates*'
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*4.4 采样率*'
- en: Many applications never expose the granular functions and operations that are
    happening behind the scenes. Because of this, many people aren't used to processing
    audio in a mathematical fashion. Audio is, at its core, numerical data being processed
    incredibly fast. Knowing this lays the groundwork for how to work with audio in
    TouchDesigner.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序从不暴露在幕后发生的细微功能和操作。因此，许多人不习惯以数学方式处理音频。音频在本质上是数值数据，正在快速处理。了解这一点为如何在 TouchDesigner
    中处理音频奠定了基础。
- en: 'Open up example ''Sample_rates_1.toe''. This example creates a very basic feature
    common in many audio applications: muting. This is achieved by using a Math CHOP
    to multiply the audio stream by the output value of a Button COMP, which is either
    0 or 1\. Like any other mathematical equation, a value, in this case each sample
    of audio, multiplied by 0 will always be 0\. Similarly, a value, or audio sample,
    multiplied by 1 will be returned unchanged. These two states produce on and off
    states for this audio example.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Sample_rates_1.toe'。这个示例创建了许多音频应用程序中常见的一个非常基本的功能：静音。这是通过使用 Math CHOP 将音频流乘以
    Button COMP 的输出值来实现的，该值为 0 或 1。像任何其他数学方程一样，乘以 0 的值，在这种情况下是每个音频样本，将始终为 0。同样，乘以
    1 的值，或音频样本，将被返回不变。这两种状态为此音频示例产生了打开和关闭状态。
- en: Let's take this example a step further by allowing the button to fade the audio
    in and out. Open example 'Sample_rates_2.toe'.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步将此示例进行扩展，使按钮能够使音频淡入淡出。打开示例 'Sample_rates_2.toe'。
- en: This example takes the previous example and adds two Operators. The first is
    the Filter CHOP which smoothens the input value. This creates a smooth ramp between
    the two states of the button. The second is a Resample CHOP.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例在之前的基础上添加了两个操作符。第一个是滤波器 CHOP，用于平滑输入值。这样可以在按钮的两个状态之间创建平滑的斜坡。第二个是重采样 CHOP。
- en: The sample rate of different Operators is something that is overlooked by many
    beginners, but is essential to having artifact-free audio. The Oscillator CHOP
    is being sampled 44,100 times a second, and the Filter CHOP is being sampled 60
    times a second. This discrepancy means that there will not be a 1:1 ratio between
    the samples of audio and the samples of the ramp when they are multiplied. More
    accurately, there will be a 735:1 ratio between samples of audio and samples of
    the ramp. This means when the two values are multiplied, the audio will step up
    or down in volume every 735 samples. Examine the diagram below, where the dotted
    blue line is a 1:1 ratio, and the dotted red line represents a 735:1 ratio.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 不同操作符的采样率是许多初学者忽视的内容，但对于无杂音的音频至关重要。振荡器 CHOP 每秒采样 44,100 次，而滤波器 CHOP 每秒采样 60
    次。这种差异意味着在将音频和斜坡的样本相乘时，它们之间不会有 1:1 的比例关系。更准确地说，音频样本和斜坡样本之间将有一个 735:1 的比率。这意味着当两个值相乘时，每隔
    735 个样本音频的音量就会上升或下降。请参考下面的图表，其中虚线蓝线是 1:1 的比例关系，虚线红线表示 735:1 的比率。
- en: '![](sample-rate.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](sample-rate.png)'
- en: Looking at the diagram above, there is a very distinct stepping that happens
    when the two channels that have different sample rates are multiplied. Many CHOPs
    use the project FPS as their default sample rate, causing the stepping to become
    exaggerated when the project is set to run at 30 FPS. Using the same example as
    above, the ratio of samples of audio and samples of the ramp would jump from 735:1
    to 1470:1\. This means in a 30 FPS project, there would only be an incremental
    volume change every 1470 samples!
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的图表可以看出，当具有不同采样率的两个通道相乘时，会出现非常明显的阶梯效应。许多 CHOP 默认使用项目的 FPS 作为它们的采样率，当项目设置为以
    30 FPS 运行时，这种阶梯效应会变得更加明显。以上述相同的示例为例，音频样本和斜坡样本之间的比率将从 735:1 跳变到 1470:1。这意味着在一个
    30 FPS 的项目中，每隔 1470 个样本才会有一个增量音量变化！
- en: The above examples highlight the need to always be aware of the sample rates
    of CHOPs in a project, and to use the Resample CHOP when necessary. Many times,
    this situation will occur in regards to audio, but there are instances where control
    data might need to be input or output at a different sample rate.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例突显了在项目中始终注意 CHOP 的采样率，并在必要时使用重采样 CHOP 的必要性。许多时候，这种情况会涉及到音频，但也有一些情况是控制数据可能需要以不同的采样率输入或输出。
- en: Time Slicing
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间切片
- en: '*4.5 Time Slicing*'
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*4.5 时间切片*'
- en: Time slicing is something that is unique to TouchDesigner, and can be a bit
    tricky to understand at first.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 时间切片是 TouchDesigner 独有的功能，一开始可能有点难以理解。
- en: A Time slice is the period between the last rendered frame and the current rendered
    frame. Think of Time slices as dynamic amounts of time. If a project is running
    at a consistent 60 FPS, then the time slices will be 1 frame in length. If a project
    is having trouble keeping up with real-time, and drops 10 frames, the corresponding
    time slice would be 10 frames in length.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 时间切片是最后一个渲染帧和当前渲染帧之间的时间段。将时间切片视为动态时间量。如果一个项目以一致的 60 FPS 运行，那么时间切片将为 1 帧长度。如果一个项目在实时运行时出现问题，并且丢失了
    10 帧，则相应的时间切片将为 10 帧长度。
- en: Time slicing exists to smoothen out CHOP data in situations where frames are
    dropped. To think about it simply, Time slicing is when CHOPs start taking the
    size of Time slices into account when cooking. Think of this as a kind of adaptive
    cooking, meaning that as the time slices grow in length, the CHOPs will compensate
    for the amount of frames lost, and cook the amount of frames necessary to produce
    smoother outputs. This is in contrast to CHOPs that aren't time sliced, that will
    cook their value at the last cooked frame, then jump to the value at the next
    cooked frame, no matter how many frames are dropped inbetween. Only CHOPs can
    take advantage of Time slicing.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 时间切片存在的目的是在帧被丢弃的情况下平滑CHOP数据。简单地说，时间切片是当CHOP开始考虑时间片的大小进行计算时的情况。可以将其视为一种自适应烹饪，这意味着随着时间片长度的增加，CHOP将补偿丢失的帧数，并烹饪产生更平滑输出所需的帧数。这与未进行时间切片的CHOP形成对比，后者将在上次烹饪的帧上烹饪其值，然后跳到下次烹饪的帧的值，无论中间丢失了多少帧。只有CHOP才能利用时间切片。
- en: Using the example above, when the timeline is running consistently at 30 FPS,
    every time slice is 1 frame in length. If there are two ramps going from 0 to
    1 over the course of one second (30 frames), both outputs would be smooth ramps.
    If, for some bizarre reason, only every tenth frame was cooked, there would be
    very different results. In the non-time sliced CHOP, the value would jump every
    time a frame is cooked, while the data between those cooked frames is lost. The
    Time sliced CHOP is aware that it is only being cooked every tenth frame, and
    will cook the frames inbetween to interpolate between the value of the last cooked
    frame, and the current cooked frame. This keeps the data smooth no matter what
    is going on.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上面的示例，当时间轴以恒定的30 FPS运行时，每个时间片的长度为1帧。如果有两个斜坡在一秒钟内从0到1（30帧）的过程中，那么两个输出都将是平滑的斜坡。如果由于某种奇怪的原因，只有每十帧烹饪一次，结果将会有很大不同。在未进行时间切片的CHOP中，每次烹饪一帧时值都会跳跃，而在这些烹饪帧之间的数据将丢失。时间切片的CHOP知道自己只有每十帧才会被烹饪，将在最后一个烹饪帧和当前烹饪帧之间进行插值。这样无论发生什么情况，数据都保持平滑。
- en: 'The diagram below illustrates the above example, where the dotted-blue line
    is a non-Time sliced CHOP, the dotted-red line is a Time sliced CHOP, and the
    vertical dotted-green lines represent a cooked frame:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了上述示例，其中虚线蓝色线是非时间切片的CHOP，虚线红色线是时间切片的CHOP，垂直虚线绿色线表示烹饪的帧：
- en: '![Time Slicing](Timeslice.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![时间切片](Timeslice.png)'
- en: Common CHOPs
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见CHOP
- en: '*4.6 Common Channel Operators*'
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*4.6 常见通道操作符*'
- en: This section is an introduction to some of the channel operators that are used
    in many situations. There is an example file that is included in the .zip folder.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了许多情况下使用的一些通道操作符。示例文件包含在.zip文件夹中。
- en: Generator CHOPs
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成器CHOP
- en: Constant
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 常数
- en: The Constant CHOP holds up to 40 unique constant values. The channel name is
    defined in text field on the left, and the value is defined with the number field
    slider on the right.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 常数CHOP最多可容纳40个独特的常数值。通道名称在左侧的文本字段中定义，值在右侧的数字字段滑块中定义。
- en: When a Constant CHOP is created, only 1 channel is active. If a channel is not
    active, its number field is greyed out. To activate a channel just give it a name,
    and the number field will light up as well as show up in the operator viewer.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 创建常数CHOP时，只有1个通道处于活动状态。如果通道未激活，则其数字字段将变灰。只需给通道命名即可激活通道，数字字段将亮起，并显示在操作器查看器中。
- en: 'To create multiple channels with the same value, you can name the channels
    using pattern matching. If you enter `chan[1-4]` in the name field, 4 channels
    will be created: `chan1`, `chan2`, `chan3`, and `chan4`. These channels will all
    have the same value.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建具有相同值的多个通道，可以使用模式匹配来命名通道。如果在名称字段中输入`chan[1-4]`，将创建4个通道：`chan1`、`chan2`、`chan3`和`chan4`。这些通道都将具有相同的值。
- en: Noise
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 噪声
- en: This CHOP generates a set of pseudo-random points according to the settings
    in the operators Parameters. There are 6 different algorithms to choose from,
    each with different characteristics and may suit some situations better than the
    others. The basis for each algorithm is the `seed` value. You can have 2 Noise
    CHOPs with the same values, and the noise would look the same, but if you change
    the seed, it will generate a set of points based on the new seed number, creating
    a different result. *(ex.1 of noise.toe)*
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 此CHOP根据操作器参数中的设置生成一组伪随机点。有6种不同的算法可供选择，每种算法具有不同的特征，可能比其他情况更适合。每个算法的基础是`seed`值。您可以有2个具有相同值的Noise
    CHOPs，噪声看起来相同，但如果您更改seed，它将基于新的seed数字生成一组点，从而产生不同的结果。(*noise.toe*的示例1)
- en: To create movement, you can change values on the `Transform` page. If you enter
    `absTime.frame` to the first `Translate` field, you can see that the noise begins
    to scroll along the x-axis. (ex. 2 of *noise.toe*)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建运动，您可以在`Transform`页面上更改值。如果您将`absTime.frame`输入到第一个`Translate`字段中，您会看到噪声开始沿着x轴滚动。（*noise.toe*的示例2）
- en: To create multiple channels of noise, go to the `Channel` page of the Parameters,
    and in the `Channel Names` field, enter the names of the channels separated by
    a space. *(ex.3 of noise.toe)*
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建多个通道的噪声，请转到参数的`Channel`页面，并在`Channel Names`字段中输入以空格分隔的通道名称。(*noise.toe*的示例3)
- en: The number of samples you would like to generate is determined by the settings
    on the `Channel` page, with the `Start`, `End`, and `Sample Rate`. The amount
    of time multiplied by the sample rate. But if you only need 1 sample at a time,
    you can go to the `Common` page, and turn the `Time Slice` toggle to `On`. This
    creates 1 random value per channel for each frame, which requires less CPU usage.
    *(ex.4 of noise.toe)*
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要生成的样本数量由`Channel`页面上的设置确定，包括`Start`、`End`和`Sample Rate`。时间乘以采样率。但如果您一次只需要1个样本，您可以转到`Common`页面，并将`Time
    Slice`切换打开。这会为每帧的每个通道创建1个随机值，从而减少CPU使用量。(*noise.toe*的示例4)
- en: Pattern
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模式
- en: The Pattern CHOP generates a function that is a set amount, or array, of samples.
    The size of the array is set by `Length` on the `Pattern` parameter page, and
    the type of function is chosen by `Type`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Pattern CHOP生成一个函数，即一组样本或数组。数组的大小由`Pattern`参数页面上的`Length`设置，函数类型由`Type`选择。
- en: '`Cycles` is the amount of times the function loops within the amount of samples.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cycles`是函数在样本数量内循环的次数。'
- en: There are settings to control your pattern, depending on what `Type` you have
    chosen.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您选择的`Type`，有设置来控制您的模式。
- en: '`From Range` and `To Range` are very useful for something like a sine wave
    that creates a `-1` to `1` value, but you need a `0` to `1` value. (There''s more
    on this later, in the Math CHOP section). *(ex.3 in pattern.toe)*'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`From Range`和`To Range`对于像创建`-1`到`1`值的正弦波这样的情况非常有用，但您需要`0`到`1`值。（稍后在Math CHOP部分中会详细介绍）。(*pattern.toe*的示例3)'
- en: This is a great tool for creating lookup tables. *(ex.4 in pattern.toe)*
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个创建查找表的好工具。(*pattern.toe*的示例4)
- en: LFO
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: LFO
- en: The LFO CHOP generates an oscillating value according to the parameter settings.
    It goes back and forth between 2 values that are determined by `Amplitude` and
    `Offset`, over a given time, or `Frequency`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: LFO CHOP根据参数设置生成振荡值。它在给定时间或`Frequency`内在`Amplitude`和`Offset`确定的2个值之间来回摆动。
- en: '`Frequency` generally determines how many cycles per second, except when a
    value is connected to the first input for `Octave Control`. If the `Octave Control`
    value is set to `1`, the speed is doubled, and if the value is set to `2`, the
    speed is doubled 2 (4x), etc. *(ex.2 of noise.toe)*'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frequency`通常确定每秒循环的次数，除非将值连接到`Octave Control`的第一个输入。如果`Octave Control`值设置为`1`，速度加倍，如果值设置为`2`，速度加倍2（4倍），依此类推。(*noise.toe*的示例2)'
- en: The shape of the oscillation is controlled by `Type`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 振荡的形状由`Type`控制。
- en: You can also oscillate using a different oscillation pattern by using the 3rd
    input. *(ex.3 of lfo.toe)*
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用第3个输入使用不同的振荡模式进行振荡。(*lfo.toe*的示例3)
- en: Timer
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 计时器
- en: This CHOP is very useful for anything that involves fixed time periods. You
    can trigger the timer and recieve different types of data throughout its duration,
    as well as set it do act different ways when it ends.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 此CHOP对涉及固定时间段的任何事物非常有用。您可以触发计时器，并在其持续时间内接收不同类型的数据，以及在结束时设置其以不同方式运行。
- en: The timer can run once and stop at the end, run once and reset itself, repeat
    itself a certain amount of times, or indefinitely.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器可以运行一次并在结束时停止，运行一次并重置自身，重复某个特定次数或无限期重复。
- en: Use the `Timer` parameter to set the length of the timer, and trigger it to
    start or reset. You can use `Delay` to set an amount of time to wait after the
    `Start` button was triggered, to actually start the timer.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Timer`参数设置计时器的长度，并触发它开始或重置。您可以使用`Delay`在触发`Start`按钮后设置一段时间等待，以实际启动计时器。
- en: '`Cue Point` sets a point during the timer that you can jump to by triggering
    the `Cue` pulse. If you''d like to be able to jump to a point that is half way
    through the duration of the timer, set `Cue Point` to `0.5`.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cue Point`在计时器期间设置一个点，您可以通过触发`Cue`脉冲跳转到该点。如果您想要能够跳转到计时器持续时间的一半处，将`Cue Point`设置为`0.5`。'
- en: 'On the `Outputs` parameter page, you can select what information you would
    like to recieve. Some common outputs are:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Outputs`参数页面上，您可以选择要接收的信息。一些常见的输出包括：
- en: '`Timer Fraction` displays the percentage of the set time period that has passed,
    in a 0 to 1 value. 0.5 would mean the timer is half done and 1 meaning the timer
    is finished.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Timer Fraction`显示已经过的设置时间段的百分比，以0到1的值表示。0.5意味着计时器完成一半，1意味着计时器已完成。'
- en: '`Done` is a value of `0` while the timer is initialized or running, and turns
    to `1` when the timer has finished. It will turn back to `0` once the `Init` or
    `Start` button is triggered again.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当计时器被初始化或运行时，`Done`的值为`0`，当计时器完成时，它会变为`1`。一旦再次触发`Init`或`Start`按钮，它将恢复为`0`。
- en: Filter CHOPs
  id: totrans-376
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Filter CHOPs`'
- en: Math
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数学
- en: 'This is probably the most commonly used CHOP. It takes data from its inputs
    and manipulates it in different ways :'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最常用的CHOP。它从其输入中获取数据并以不同的方式操纵它：
- en: The most intuitive use would be to take a value and perform some simple math,
    like add 10, or multiply the given value by 10\. This is done on the `Mult-Add`
    parameter page.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 最直观的用法是取一个值并执行一些简单的数学运算，比如加10，或者将给定的值乘以10。这是在`Mult-Add`参数页面上完成的。
- en: '![Order of Operations](math1.JPG "Order of Operations")'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![运算顺序](math1.JPG "运算顺序")'
- en: 'Commonly, we need to take a value, or set of values, and adjust them according
    to another value or set of values. For example, if our end desire is to have a
    value moving up and down over time, but we also want to add a random jitter, we
    could use a Pattern CHOP to create a SIN wave, a Noise CHOP to create a random
    set of numbers, and using the `OP` parameter page of a Math CHOP, we could set
    the `Combine CHOPs` drop-down menu to `Add`. The result could look something like
    this :'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要获取一个值或一组值，并根据另一个值或一组值进行调整。例如，如果我们最终想要的是随时间变化而上下移动的值，但我们还想添加随机抖动，我们可以使用Pattern
    CHOP创建一个SIN波，使用Noise CHOP创建一组随机数字，并在Math CHOP的`OP`参数页面上将`Combine CHOPs`下拉菜单设置为`Add`。结果可能是这样的：
- en: '![Combine Chops](math2.JPG "Combine Chops")'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![组合Chops](math2.JPG "组合Chops")'
- en: Another very useful function of the Math CHOP is the `Range` parameter page.
    This takes a range of values, and re-maps them to a new range. For example, if
    you have an LFO CHOP that ramps from 0 to 1, but you need that same movement to
    fit between the specific values of 7.9 and 51.4, it is much faster to use the
    `From Range` and `To Range` parameters than to adjust it using order of operations.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Math CHOP的另一个非常有用的功能是`Range`参数页面。这将一系列值重新映射到一个新的范围。例如，如果您有一个从0到1的LFO CHOP，但您需要相同的运动适合于7.9和51.4的特定值，那么使用`From
    Range`和`To Range`参数比使用运算顺序调整要快得多。
- en: '![Range](math3.JPG "Range")'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![范围](math3.JPG "范围")'
- en: Select
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 选择
- en: This CHOP can be used to split up data that is contained in a single CHOP, or
    can be used to grab data from a remote section of a project. You can also rename
    channels that you are selecting at the same time.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`CHOP`可以用来分割包含在一个`CHOP`中的数据，或者可以用来从项目的远程部分获取数据。您还可以同时选择重命名通道。
- en: If you have a CHOP that contains several channels of information, and need to
    apply a process to 2 of the channels, but not all, a Select CHOP will allow you
    to name the channels that you want to focus on. Use the `Channel Names` field
    on the `Select` page of the parameters to list the channels you require, separated
    by a space.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个包含多个信息通道的`CHOP`，并且需要对其中的2个通道应用处理，而不是所有通道，`Select CHOP`将允许您命名您想要关注的通道。在参数的`Select`页面上使用`Channel
    Names`字段列出您需要的通道，用空格分隔。
- en: If you want to re-name these channels to something else, you can use the `Rename
    From` field to write the original channel names, and the `Rename To` field to
    enter the new names.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将这些通道重新命名为其他名称，你可以使用`重命名自`字段写入原始通道名称，并使用`重命名为`字段输入新名称。
- en: This CHOP also allows you to point to other CHOPs from different areas of a
    project. Lets say you have have data in a Constant CHOP that is nested inside
    2 other COMPs. TheConstant CHOPs path is `/project1/base1/base1/constant1`. But
    your project requires you to access this data in your `/project1` COMP. You could
    either make some `Out` CHOPs and manually wire the information, or use a Select
    CHOP to wireless point at the path of the constant CHOP, which usually quicker
    and keeps the network more organized. In the `CHOP` field of the `Select` parameter
    page, enter `project1/base1/base1/constant1`, and you will now see the data.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这个CHOP还允许你指向项目不同区域的其他CHOP。假设你的Constant CHOP中有数据，它嵌套在其他2个COMPs中。Constant CHOP的路径是`/project1/base1/base1/constant1`。但是你的项目要求你在你的`/project1`
    COMP中访问这些数据。你可以使用一些`Out` CHOP手动连接信息，或者使用Select CHOP无线指向常量CHOP的路径，这通常更快并且保持网络更有组织性。在`Select`参数页面的`CHOP`字段中输入`project1/base1/base1/constant1`，然后你现在会看到数据。
- en: As before, if there are several channels in the constant, and you only want
    to select 1, you can use the `Channel Names` field to select the one you need,
    and rename it as well.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，如果常量中有几个通道，而你只想选择一个，你可以使用`通道名称`字段来选择你需要的通道，并重命名它。
- en: Merge
  id: totrans-391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 合并
- en: The Merge CHOP is the opposite of the Select CHOP. It takes channels from multiple
    CHOPs and merges them into a single CHOP.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: Merge CHOP是Select CHOP的相反。它从多个CHOP中获取通道，并将它们合并到单个CHOP中。
- en: This is a straightforward idea, but if the results are different than what you
    expected, you will need to middle-mouse-click on the input CHOPs to see if the
    `Start/End` samples match.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的想法，但如果结果与你预期的不同，你需要中键单击输入的CHOPs，看看`起始/结束`样本是否匹配。
- en: '![Range](mmc1.JPG "Range") ![Range](mmc2.JPG "Range")'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![范围](mmc1.JPG "范围") ![范围](mmc2.JPG "范围")'
- en: In the CHOPs pictured above, both the Start samples and the End samples differ.
    This is dealt with by setting the Extend Conditions on the `Channel` parameter
    page of the Generator CHOPs that are being input, as well as the `Align` options
    on the `Merge` parameter page of the Merge CHOP.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的CHOP中，起始样本和结束样本都不同。这通过在被输入的Generator CHOP的`通道`参数页面上设置扩展条件以及在Merge CHOP的`Merge`参数页面上设置`Align`选项来处理。
- en: There is an explanation of the different Extend methods located on Extend CHOP
    wiki page, located [here](http://www.derivative.ca/wiki088/index.php?title=Extend_CHOP
    "Extend CHOP wiki page")
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 关于不同扩展方法的解释位于Extend CHOP维基页面上，位于[这里](http://www.derivative.ca/wiki088/index.php?title=Extend_CHOP
    "Extend CHOP维基页面")
- en: You can also open up the example project and experiment with the extend conditions
    and the different `Align` options.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以打开示例项目，尝试不同的扩展条件和不同的`Align`选项。
- en: Trail
  id: totrans-398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 轨迹
- en: The Trail CHOP creates a visual display of how the value of it's inputs have
    changed over a given time. This can be very useful when you need to see subtle
    differences of a channels movement, or how a channel's value changes compared
    to another.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Trail CHOP创建了一个可视化显示，显示了它的输入值在给定时间内的变化。当你需要看到通道运动的微妙差异，或者一个通道的值与另一个通道的值的变化时，这可能非常有用。
- en: '![Trail](trail.JPG "Trail")'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![轨迹](trail.JPG "轨迹")'
- en: Filter / Lag
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 过滤器 / 滞后
- en: Filter and Lag CHOPs create a smooth transition between values over a given
    time. The 2 CHOPs have similar purposes, but different options.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Filter和Lag CHOP在给定时间内创建值之间的平滑过渡。这两个CHOP具有类似的目的，但是不同的选项。
- en: Filter CHOP applies a smoothing effect or time, and you can choose the shape
    of the smoothing, with different options for different shapes.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Filter CHOP应用了平滑效果或时间，你可以选择平滑的形状，具有不同形状的不同选项。
- en: '![Filter Types](Filter.JPG "Filter Types")'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![滤波器类型](Filter.JPG "滤波器类型")'
- en: '*(see **/filter_lag/ example 1** of the example project file)*'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '*(参见示例项目文件中的**/filter_lag/ 示例 1**)*'
- en: Lag CHOP, depending on the method of smoothing, allows you to set 2 seperate
    effect-lengths for an increasing input value, and decreasing input value. *(see
    **/filter_lag/ example 2** of the example project file)*
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: Lag CHOP，根据平滑方法的不同，允许你为增加的输入值和减少的输入值设置2个单独的效果长度。*(参见示例项目文件中的**/filter_lag/ 示例
    2**)*
- en: Trigger
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 触发器
- en: This CHOP takes an event and creates an ADSR envelope (Attack, Decay, Sustain,
    and Release) with some additional control.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这个CHOP接收一个事件，并创建一个带有一些附加控制的ADSR包络（Attack、Decay、Sustain和Release）。
- en: 'The envelope can be triggered by the `Trigger Pulse` on the `Trigger` Parameter
    page, or by connecting a CHOP to its input, such as the Out of a Button. These
    are the different parts of the envelope:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `Trigger Parameter` 页面上的 `Trigger Pulse` 或将 CHOP 连接到其输入来触发包络，例如按钮的输出。以下是包络的不同部分：
- en: '![Filter Types](Trigger_ADSR_an.jpg "Filter Types")'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![Filter Types](Trigger_ADSR_an.jpg "Filter Types")'
- en: 'The different sections of the envelope can have easings as well. Here is an
    example of with the `Attack Shape` set to `Ease out`, `Decay Shape` set to `Ease
    in Ease out` and the `Release Shape` set to `Ease in`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 包络的不同部分也可以有缓动。这里是一个示例，`Attack Shape` 设置为 `Ease out`，`Decay Shape` 设置为 `Ease
    in Ease out`，`Release Shape` 设置为 `Ease in`：
- en: '![Filter Types](Trigger_ADSR_Ease.JPG "Filter Types")'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![Filter Types](Trigger_ADSR_Ease.JPG "Filter Types")'
- en: Introduction
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 5 DATs
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 个 DATs
- en: '*5.1 Introduction*'
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*5.1 介绍*'
- en: Data Operators, or DATs, perform operations on data. They can edit, parse, create,
    send, and receive data in various forms. These forms of data can range from text
    strings, tables, Python scripts, XML, JSON, MIDI, Serial, OSC, and much more.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Data Operators，或 DATs，对数据执行操作。它们可以编辑、解析、创建、发送和接收各种形式的数据。这些数据形式可以是文本字符串、表格、Python
    脚本、XML、JSON、MIDI、串口、OSC 等等。
- en: Logical systems rely heavily on the use of DATs and Python scripting. Being
    able to parse tables full of information and metadata, monitor other Operators
    and their states, perform complex tasks based on incoming messages from other
    systems, and more, make it possible to create rather complex systems in TouchDesigner.
    There will be a few simple logical systems in the examples portion of the book,
    as they are one of the things that makes TouchDesigner unique.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑系统在很大程度上依赖于 DATs 和 Python 脚本的使用。能够解析充满信息和元数据的表格，监视其他操作员及其状态，根据来自其他系统的消息执行复杂任务等，使得在
    TouchDesigner 中创建相当复杂的系统成为可能。在本书的示例部分将会有一些简单的逻辑系统，因为它们是使 TouchDesigner 独特的因素之一。
- en: An interesting way of thinking about TouchDesigner 088 is as a modular Python
    programming environment. Imagine taking intricate, and long, Python programs and
    functions, and breaking them into light-weight, and modular pieces. Think of the
    Text DAT as these pieces. This setup is easy to learn from, easy to maintain,
    easy to expand upon, and even more importantly, easy to share and work on collaboratively.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 将 TouchDesigner 088 看作是一个模块化的 Python 编程环境是一种有趣的思考方式。想象一下，将复杂且冗长的 Python 程序和函数拆分成轻量级和模块化的部分。把
    Text DAT 想象成这些部分。这种设置易于学习、易于维护、易于扩展，更重要的是，易于分享和共同合作。
- en: Communication Methods
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信方法
- en: '*5.2 Communication Methods*'
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*5.2 通信方法*'
- en: There are quite a few DATs that are capable of providing inputs and outputs
    over the many standard communication protocols. TouchDesigner is able to communicate
    natively over MIDI, OSC, TCP, UDP, UDT, and Websocket, giving it the ability to
    speak to many different types of programs, web applications and services, show
    control hardware, other computer systems, and etc.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多 DATs 能够在许多标准通信协议上提供输入和输出。TouchDesigner 能够原生支持 MIDI、OSC、TCP、UDP、UDT 和 Websocket
    进行通信，使其能够与许多不同类型的程序、Web 应用程序和服务、展示控制硬件、其他计算机系统等进行通信。
- en: MIDI, OSC, and DMX protocols were explained in the CHOP chapter. DATs can communicate
    over the same protocols, and quite a few more.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: CHOP 章节解释了 MIDI、OSC 和 DMX 协议。DATs 可以使用相同的协议进行通信，还有很多其他协议。
- en: TCP is the internet standard communication protocol. It is a connection oriented
    protocol, meaning there is a clear client-server relationship between the communicating
    parties, and a connection must be established (usually behind the scenes) before
    any data is transmitted. This relationship allows TCP connections to be reliable,
    in that the communicating parties can provide acknowledgment of all data sent
    and received, meaning no data ever gets lost. TCP is an ordered delivery stream,
    meaning data sent in a specific order, will be received in that same order.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 是互联网标准通信协议。它是一种面向连接的协议，意味着通信双方之间有明确的客户端-服务器关系，并且必须在传输任何数据之前建立连接（通常在幕后）。这种关系使得
    TCP 连接能够可靠，即通信双方可以确认所有发送和接收的数据，这意味着没有任何数据会丢失。TCP 是有序传递流，意味着以特定顺序发送的数据将以相同的顺序接收。
- en: UDP, on the contrary, is a connection-less protocol, in that no explicit connection
    is established prior to data transmission. This creates a level of unreliability
    in areas such as delivery acknowledgments, dropped packets, and order of messages.
    If none of these are crucial to a project, there are some performance gains in
    systems where dropped packets are less of an issue than delayed packets.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: UDP，相反，是一种无连接协议，在数据传输之前不建立明确的连接。这在交付确认、丢包和消息顺序等方面造成了一定程度的不可靠性。如果这些对项目都不是至关重要的，那么在丢包不是问题的系统中可能会有一些性能上的提升。
- en: UDT is one of the newer communication protocols. It is essentially the better
    parts of UDP and TCP combined. It is built on the UDP protocol, but is connection-based,
    and reliable. This means that is has the same acknowledgments and data ordering
    that a TCP connection would have, but over the faster UDP protocol.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: UDT 是较新的通信协议之一。它基本上是 UDP 和 TCP 的优点结合。它是建立在 UDP 协议上的，但是是基于连接的和可靠的。这意味着它具有与 TCP
    连接相同的确认和数据排序，但是使用更快的 UDP 协议。
- en: A benefit of connection-less protocols is that they support a feature called
    'Multicast messaging'. This means that regardless of how many computers are connected,
    each message is only sent over the network once. When sending the same message
    to many computers, this removes the overhead of sending the same message to each
    individual computer. This is the opposite of 'Unicast messaging', in which each
    connected computer receives an individual message, even if the message being sent
    to every machine is the same.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 无连接协议的一个好处是它们支持一种称为“多播消息”的功能。这意味着无论连接了多少台计算机，每条消息都只发送一次。当将相同的消息发送到许多计算机时，这消除了将相同消息发送到每台计算机的开销。这与“单播消息”相反，单播消息中每个连接的计算机都会接收到一个独立的消息，即使发送到每台机器的消息都是相同的。
- en: Websocket is the go-to communication method when working with web browsers and
    real-time web application. It has been designed from the ground up to be used
    as an interface between web browsers and servers, and the protocol has simplified
    some key functionality in regards to bi-directional web communication.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Websocket 是在处理 Web 浏览器和实时 Web 应用程序时的首选通信方法。它从头开始设计，用作 Web 浏览器和服务器之间的接口，并且协议简化了关于双向
    Web 通信的一些关键功能。
- en: Introduction
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 6 SOPs
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 个 SOPs
- en: '*6.1 Introduction*'
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*6.1 介绍*'
- en: The Surface Operators, or SOPs, family of Operators are used for any and all
    3D operations. This includes working with simple 3D geometry, particle systems,
    architectural models, 3D characters, and more. SOPs are the oft ignored operators
    by many beginners because of their steep learning curve, but rest assured that
    a firm knowledge over the SOP family of operators will open up many incredibly
    interesting opportunities, project-wise, as well as offer many extremely efficient
    ways of solving problems.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 表面操作器，或者 SOPs，是用于所有 3D 操作的操作器家族。这包括处理简单的 3D 几何体、粒子系统、建筑模型、3D 角色等。SOPs 是许多初学者经常忽视的操作器，因为它们的学习曲线陡峭，但是请放心，对
    SOP 家族操作器的扎实了解将会在项目上开启许多非常有趣的机会，并且提供许多非常有效的解决问题的方法。
- en: Many projects involving projection mapping, real-time 3D motion capture, architectural
    LED facade installations, and layered video players, would either be impossible
    or extremely difficult without the SOP family of operators.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 许多涉及投影映射、实时 3D 动作捕捉、建筑 LED 立面安装和分层视频播放器的项目，如果没有 SOP 操作器家族，要么是不可能的，要么是非常困难的。
- en: 'TouchDesigner 088 currently supports the following 3D file types:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: TouchDesigner 088 当前支持以下 3D 文件类型：
- en: .fbx
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .fbx
- en: .obj
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .obj
- en: .3ds
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .3ds
- en: .dxf
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .dxf
- en: .dae
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .dae
- en: Keeping Operators from cooking needlessly is essential to smooth performance,
    which will be discussed further in the 'Optimization' section of the book. This
    is even more important when it comes to SOPs. Always try to apply transform animation
    data to a Geometry COMP instead directly of to a SOP. This is because SOP transformations
    happen on the CPU, and the transformation must be performed for every vertex that
    is present in the geometry. Component level transformations are applied to the
    3D geometry, or object, as a whole, and are performed on the GPU as a single operation.
    A single operation performed on the GPU is much preferred when compared to what
    could amount hundreds or thousands of operations performed on the CPU.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 避免不必要地让操作器无谓运算对于顺畅的性能至关重要，这将在本书的 '优化' 部分进一步讨论。当涉及到 SOPs 时，这一点更加重要。始终尝试将变换动画数据应用于
    Geometry COMP，而不是直接应用于 SOP。这是因为 SOP 变换发生在 CPU 上，并且必须为几何体中存在的每个顶点执行变换。组件级别的变换应用于整个
    3D 几何体或对象，并且在 GPU 上作为单个操作执行。与在 CPU 上执行数百次或数千次操作相比，GPU 上执行的单个操作要好得多。
- en: The number of total points, primitives, vertices, and meshes will vary depending
    on what kind of model is being processed, but the basic principle is that the
    more polygons/vertices in a model, the more processing power and GPU RAM are needed
    to process operations. There are tools inside of TouchDesigner to reduce polygon
    counts in complex models, but optimizing geometry in dedicated modelling suites
    can provide more flexibility.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 总点数、基元数、顶点数和网格数会根据正在处理的模型类型而变化，但基本原则是，模型中的多边形/顶点越多，处理操作所需的处理器和 GPU RAM 就越多。TouchDesigner
    中有一些工具可以减少复杂模型中的多边形数量，但在专用建模套件中优化几何形状可以提供更大的灵活性。
- en: Rendering
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染
- en: '*6.2 Rendering*'
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*6.2 渲染*'
- en: One thing many beginners struggle with is the process of quickly and effectively
    transitioning from a 3D workflow to a 2D workflow. The Internet is full of 3D
    workflow tutorials that can explain many of the finer points of 3D rendering,
    but for this chapter, the goal is to get from point A, a simple 3D object, to
    Point B, a Render TOP.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 许多初学者所困扰的一件事是如何快速有效地从 3D 工作流程过渡到 2D 工作流程的过程。互联网上充斥着许多可以解释 3D 渲染的细节的教程，但在本章中，目标是从点
    A，一个简单的 3D 对象，到点 B，一个渲染 TOP。
- en: 'There are three parts to a 3D scene:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 3D 场景由三个部分组成：
- en: 3D geometry (and materials)
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3D 几何体（和材质）
- en: Camera
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相机
- en: Lighting
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 照明
- en: Open example 'Rendering_1.toe'. Taking a quick look at it, there are three basic
    things needed to render the scene, Camera, Light, and 3D geometry, which are all
    referenced by a Render TOP. Let's break down each aspect of the render setup,
    and then look at how it all fits together.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例 'Rendering_1.toe'。快速浏览一下，渲染场景需要三样基本东西：相机、光线和 3D 几何体，这些都由 Render TOP 引用。让我们分解渲染设置的每个方面，然后看看它们如何组合在一起。
- en: The appropriate place to begin is the 3D geometry. This is the essence of it
    all. The 3D model can be anything from simple polygons, animated 3D characters,
    architectural models, etc. Whether importing or procedurally building models,
    all of the operations are done with SOPs, and these SOPs end up in a Geometry
    Component. A key idea to grasp is that in TouchDesigner, SOPs themselves are never
    directly rendered. Instead, Geometry Components, or Geometry COMPs, are rendered,
    that hold SOPs that are flagged for rendering. This is a crucial idea to understand.
    Two scenarios demonstrate this.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 开始的合适地方是 3D 几何体。这就是一切的本质。3D 模型可以是任何东西，从简单的多边形、动画 3D 角色、建筑模型等。无论是导入还是程序化构建模型，所有操作都是用
    SOP 完成的，并且这些 SOP 最终会在 Geometry Component 中。要掌握的一个关键概念是，在 TouchDesigner 中，SOPs
    本身永远不会直接渲染。相反，被标记为渲染的 SOPs 存储在 Geometry Components 中，并且这是一个关键的理念。两种情况可以说明这一点。
- en: Open example 'Rendering_2.toe'. In this project, there is a single geometry
    that is sent into 4 different Geometry COMPs, each of which is rendered with different
    transform values. For the sake of example, this project uses a Box SOP, but in
    this could apply to more complex models. Performing operations on a complex character,
    and having a few iterations of it, could max out a system's headroom. Going back
    to the idea that SOPs aren't directly rendered, it becomes logical to load the
    model once, from which a few iterations can be housed and rendered from Geometry
    COMPs.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Rendering_3.toe'. This is very different than the previous example,
    in that there is a single Geometry COMP with 3 different models that are being
    rendered. Keeping in mind that Geometry COMPs are rendered, it becomes logical
    to group these models into a single Geometry COMP, that is being rendered. The
    difference may seem arbitrary, but as projects become more complex, saving resources
    becomes paramount.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'Till now, the various geometry haven''t had any materials. Materials are what
    make 3D scenes interesting. The difference between a cement building-block and
    a 3D box is a material. Textures can be applied at two levels: the SOP level,
    and the Component level. The first is through the use of the Material SOP, and
    the second is by referencing the material in the ''Render'' tab of a Geometry
    COMP. In the example ''Rendering_4.toe'', both materials look the same, but each
    use a different method of texturing.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Now that materials are added to the mix, let's quickly discuss UV maps. Open
    example 'Rendering_5.toe'. This is the same example as above, but the same texture
    looks completely different. This is because the co-ordinates of the UV map have
    been changed.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: The second aspect of a 3D scene is light. Just as in real life, 3D scenes require
    lighting. Open example 'Rendering_6.toe'. This example has a simple box being
    rendered, but nothing is visible in the Render TOP. This is because the light's
    dimness has been purposefully set the to 0, to demonstrate how important lighting
    is, and how it is often overlooked.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: The next few example projects are the same scene with different lights. In each
    consecutive project, the Light COMP has been transformed to light the Box SOP
    from a different angle. These are example projects 'Rendering_7.toe', 'Rendering_8.toe',
    and 'Rendering_9.toe'.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: The last aspect to rendering a 3D scene is the camera. The camera is the eye
    and perspective. What the camera sees is what gets rendered. Open example 'Rendering_10.toe'.
    All the movement in the scene stems from the animated camera movements. Often
    times, a camera is placed in a scene and never thought about again. This can lead
    to boring 3D scenes that feel very static and lifeless. Don't be afraid to think
    like a cinematographer, and experiment with camera positions, focal lengths, and
    animated camera movement.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main types of cameras: perspective cameras and orthographic cameras.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '![](rendering-1.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![](rendering-1.png)'
- en: '![](rendering-2.png)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![](rendering-2.png)'
- en: Perspective cameras need very little explanation, as they work similarly to
    the human eye. Perspective cameras have a perspective point, and a view frustum
    that are used to determine what the camera sees and how that is rendered. With
    a perspective camera, imagine all light in the 3D scene funnelling towards the
    perspective point. Perspective correction, or 'foreshortening', is applied on
    all objects in the scene, meaning that objects farther away from the camera appear
    smaller. This camera ends up being used most often as it functions like human
    eyes. An example of this type of camera can be found in example file 'Camera_1.toe'.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 透视相机需要很少的解释，因为它们的工作方式类似于人眼。 透视相机有一个透视点和一个视锥体，用于确定相机看到的内容以及如何渲染。 使用透视相机，想象3D场景中的所有光线都汇聚到透视点。
    透视校正，或称为“透视缩短”，应用于场景中的所有对象，这意味着距离相机更远的对象看起来更小。 这种相机最常被使用，因为它的功能类似于人眼。 这种类型的相机的示例可以在示例文件'Camera_1.toe'中找到。
- en: This example highlights perspective correction. There are two cubes, both the
    same size. The cube placed farther in the scene appears smaller, just as it would
    in real life. This is the simplest example of how a perspective camera functions.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例突出了透视校正。 有两个立方体，大小相同。 放置在场景中更远的立方体看起来更小，就像在现实生活中一样。 这是透视相机功能的最简单示例。
- en: Orthographic cameras, on the other hand, are very different. Those familiar
    with computer-aided design (CAD) software, may have encountered orthographic cameras
    before. The key principle behind an orthographic camera is that there is no single
    point of perspective. All of the light in the imaginary 3D scene would not filter
    into a single point, as in a perspective camera. Objects are not distorted by
    their Z position in space, meaning that no matter how far away from the camera
    an object is, it will appear no bigger or smaller than the other objects in the
    scene.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，正交相机则大不相同。 熟悉计算机辅助设计（CAD）软件的人可能以前遇到过正交相机。 正交相机背后的关键原则是没有单一的透视点。 在想象中的3D场景中的所有光线不会像在透视相机中那样汇聚到一个单一点。
    对象不会受到它们在空间中的Z位置的扭曲，这意味着无论物体离相机有多远，它看起来都不会比场景中的其他物体更大或更小。
- en: 'Open example ''Camera_2.toe''. This example is exactly the same as ''Camera_1.toe'',
    but there is a big difference in what is being rendered. In this example, the
    two cubes appear to be side by side, regardless of positioning in Z space. This
    can be a hard concept to understand the first time it is presented. Two ways of
    thinking about it are as follows:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 打开示例'Camera_2.toe'。 这个示例与'Camera_1.toe'完全相同，但在渲染的内容上有很大的区别。 在这个示例中，两个立方体看起来是并排的，无论在Z空间中的位置如何。
    这可能是第一次理解时很难理解的概念。 关于这个概念有两种思考方式：
- en: '**First** The concept of a 3D world that gets squashed onto a single plane
    before it gets rendered. Imagine the original Super Mario video game actually
    being a 3D scene that was rendered using an orthographic camera. No matter where
    bad guys and platforms are on the screen, whether at the edge or in the middle,
    they are always the same size and shape, and have no perspective correction applied.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一** 一个3D世界的概念，在渲染之前被压缩到一个单一平面上。 想象一下原始的超级马里奥视频游戏实际上是一个使用正交相机渲染的3D场景。 无论坏人和平台在屏幕上的位置如何，无论是在边缘还是在中间，它们始终具有相同的大小和形状，并且没有应用透视校正。'
- en: '**Second** Think about the blueprint of a building in a CAD program. It is
    a representation of a 3D object on a 2D plane. No matter where the blueprint is
    perceived from on screen, 1 unit of measurement on the edge of the screen is exactly
    the same length as 1 unit of measurement in the middle of the screen. Any change
    in the camera positioning doesn''t distort what is being rendered.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二** 想象一下CAD程序中建筑蓝图的蓝图。 这是在2D平面上对3D对象的表示。 无论屏幕上的蓝图从哪个位置看，屏幕边缘的1个单位长度与屏幕中间的1个单位长度完全相同。
    相机位置的任何变化都不会扭曲渲染的内容。'
- en: None of this is to say that Z-depth is irrelevant when using an orthographic
    camera. Z depth becomes imperative when layering different pieces of geometry
    in a scene.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说在使用正交相机时Z深度是无关紧要的。 当在场景中叠加不同的几何体时，Z深度变得至关重要。
- en: The camera is equally important for projection mapping projects. Projection
    mapping will be explored in later examples, but for now, the key is to understand
    another of the Camera's roles. In projection mapping, the primary goal is to turn
    real-world objects into 3D display surfaces. To achieve this, a 3D model of the
    object is imported into TouchDesigner and textured using a variety of sources.
    This textured object then needs to be rendered. Camera COMPs come into play to
    simulate real-world projectors. Gathering as much information about the characteristics
    of a projector and its lens, the Camera COMP can accurately replicate the point
    of view of the projector inside of TouchDesigner. These points of view are then
    rendered, output, calibrated, and lined up to the real-world object. This is the
    basis of projection mapping.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 对于投影映射项目，摄像机同样重要。投影映射将在后续示例中探讨，但现在，关键是了解摄像机的另一个作用。在投影映射中，主要目标是将现实世界的物体转化为 3D
    显示表面。为了实现这一目标，需要将物体的 3D 模型导入到 TouchDesigner 中，并使用各种来源进行纹理处理。然后需要渲染这个带纹理的物体。摄像机
    COMP 用于模拟现实世界的投影仪。通过收集有关投影仪及其镜头特性的尽可能多的信息，摄像机 COMP 可以在 TouchDesigner 中准确复制投影仪的视角。然后这些视角被渲染、输出、校准，并与现实世界的物体对齐。这就是投影映射的基础。
- en: Introduction
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 7 COMPs
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 个 COMPs
- en: '*7.1 Introduction*'
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*7.1 介绍*'
- en: 'There are 3 types of Component Operators, or COMPs, and each have different
    uses:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 有3种类型的组件运算符，或者说 COMPs，每种都有不同的用途：
- en: '**Object** components create, light, and view 3D scenes'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象**组件创建、照明和查看 3D 场景'
- en: '**Panel** components create UI components such as buttons, sliders, and window
    panes'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '**面板**组件创建 UI 组件，如按钮、滑块和窗口窗格'
- en: '**Other** components include components that create keyframe animations, replicate
    other Operators, and create output windows'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他** 组件包括创建关键帧动画、复制其他运算符和创建输出窗口的组件'
- en: Component Operators are generally used in conjunction with other Operators.
    The 'Object' components are used in various combinations to create and render
    SOPs and 3D scenes. The 'Panel' components are used to create UIs and various
    containers to create output rasters. The 'Other' components are used for various
    tasks, such as keyframe animations, dynamic Operator replication, opening windows
    on various displays, etc.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 组件运算符通常与其他运算符一起使用。'对象' 组件用于各种组合，以创建和渲染 SOPs 和 3D 场景。'面板' 组件用于创建 UI 和各种容器，以创建输出光栅。'其他'
    组件用于各种任务，如关键帧动画、动态运算符复制、在各种显示器上打开窗口等。
- en: An interesting fact to put things in perspective is that a large amount of TouchDesigner
    is made from components inside of TouchDesigner. Understanding this really helps
    in grasping the granularity of TouchDesigner, and how to approach working on various
    projects. For example, all Panel components are made of other Operators. Create
    a Button COMP, and inside its Network, its background is made of a Text TOP, and
    its on/off values are being generated by a Panel CHOP. Similarly, all of TouchDesigner's
    UI is made and stored in the 'ui' container in the root of all projects. Even
    the menus and dialogs, like the MIDI Mapper Dialog and the Variables Dialog, are
    created using other TouchDesigner components.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的事实是，TouchDesigner 中有大量的组件构成。理解这一点真的有助于把握 TouchDesigner 的细微之处，以及如何处理各种项目。例如，所有面板组件都由其他运算符制成。创建一个按钮
    COMP，在其网络中，其背景由一个文本 TOP 制成，其开/关值由一个面板 CHOP 生成。同样，TouchDesigner 的所有 UI 都是在所有项目的根目录中的
    'ui' 容器中制作和存储的。甚至菜单和对话框，如 MIDI 映射对话框和变量对话框，都是使用其他 TouchDesigner 组件创建的。
- en: Window COMP
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口 COMP
- en: '*7.2 Window COMP*'
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*7.2 窗口 COMP*'
- en: The Window COMP is used in almost every project to display the contents of an
    Operator in a new window. Whether using the Window COMP to create a full-screen
    output, or to create more of a traditional windowed application, there are a number
    of options that will need modifying. Because of the unique nature of every project,
    there are no 'best settings' to consistently rely on. Spend some time and go over
    the parameters on the Wiki, and experiment to find works best in each and every
    new situation.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口 COMP 几乎在每个项目中都用于在新窗口中显示运算符的内容。无论是使用窗口 COMP 创建全屏输出，还是创建更传统的窗口化应用程序，都需要修改一些选项。由于每个项目的独特性，没有可以始终依赖的
    '最佳设置'。花一些时间查看 Wiki 上的参数，并尝试找到在每个新情况下最适合的设置。
- en: Open example 'Window.toe'. This example demonstrates a very helpful practice,
    as well as some simple Window COMP functionality. It is best practice to use a
    Container COMP as the source of the Window COMP's output. This is because the
    texture in a TOP can be dragged around the screen, even in Perform Mode. If this
    happens, the texture will remain shifted until the project is reloaded, or until
    the texture is moved back to its original position. The same texture shifting
    doesn't occur to Container COMPs. The texture inside of a Container COMP cannot
    be dragged around by default, meaning the texture will always be consistent.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: The other functionality in this example is rather simple. The first is a button,
    whose Null CHOP is being referenced in the 'Open in Separate Window' parameter
    of the Window COMP. This allows easy access to the opening of the window. The
    next is a button that dynamically checks how many monitors are connected, by getting
    a row count from the recently implemented Monitors DAT. Using that value to cycle
    a Count CHOP, open the window with the first button, then use the second button
    to cycle through which monitor this window is assigned to.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: User Interface Components
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*7.3 User Interface Components*'
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Component Operators are incredibly important as they create user interfaces
    in TouchDesigner. Specifically, the Panel Components are what provide this functionality.
    Many user interfaces will be created in later examples, so only a few basic examples
    will be examined in this section.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'Three of the most useful Panel COMPs are:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: the Slider COMP
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the Button COMP
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container COMP
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two function with the same capabilities as sliders and buttons in
    other applications, but can be modified to suit different requirements. Buttons
    can be programmed as toggles, radios, or momentary buttons. Sliders can function
    as single axis sliders, or as full XY pads.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: Container COMPs, on the other hand, don't have a function other than acting
    as a container for other UI elements.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'UI.toe'. In this example, there is a simple UI. From the bottom
    of the Network upwards, there are the 2 Button COMPs and the 5 Slider COMPs. These
    are the components that are actually creating the UI's functionality. The parent
    of these elements, is used to group and arrange the buttons and sliders separately.
    Notice that if the viewers for 'container1' or 'container2' are activated, the
    UI elements are usable, but neither 'container1' or 'container2' have any outputs
    or Operators in their Networks. Similarly, the results are the same when 'container1'
    and 'container2' are combined inside of 'container3'. This is because Container
    COMPs have the ability to display their children in their viewers. Container COMPs
    facilitate the creation of complex interfaces using a combination of smaller pieces.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 8 MATs
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*8.1 Introduction*'
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Material Operators, or MATs, are used for materials and shaders for 3D geometry.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: A deep knowledge of computer graphics and rendering helps a great deal when
    working with materials and shaders. Without this knowledge, most users will be
    restricted to the basic settings of the Phong MAT and Point Sprite MAT.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理材质和着色器时，对计算机图形学和渲染有深入的了解会大有帮助。没有这方面的知识，大多数用户将被限制在Phong MAT和Point Sprite MAT的基本设置上。
- en: Texturing and UV mapping geometry are involved processes, and the best results
    are often achieved inside dedicated modelling packages. The textured models can
    then be imported, and worked with, in TouchDesigner.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理和UV映射几何体是复杂的过程，通常在专门的建模软件中可以获得最佳结果。然后可以将带有纹理的模型导入TouchDesigner并进行处理。
- en: Many tools exist for modifying textures, such as the Texture SOP, but complex
    processes might be easier to achieve in a software package created for that specific
    purpose.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多用于修改纹理的工具，例如Texture SOP，但复杂的过程可能更容易在专门为此目的创建的软件包中实现。
- en: Phong, GLSL, and Point Sprite Materials
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Phong、GLSL和Point Sprite材质
- en: '*8.2 Phong, GLSL, and Point Sprite Materials*'
  id: totrans-500
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*8.2 Phong、GLSL和Point Sprite材质*'
- en: 'The three most used MATs are:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的三种MAT是：
- en: the Phong MAT
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Phong MAT
- en: the GLSL MAT
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GLSL MAT
- en: the Point Sprite MAT
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Point Sprite MAT
- en: The general uses of these three MATs will quickly be covered in this section.
    These are three very different Operators, and cover many shading and material
    needs.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分将快速介绍这三种MAT的一般用途。这三个操作符非常不同，涵盖了许多着色和材质需求。
- en: The Phong MAT is the most common material Operator. It is responsible for applying
    texture to 3D geometry. There are a variety of maps that can be applied, such
    as Color, Bump, Specular, Diffuse, and more. The Phong MAT can mix and match Ambient,
    Diffuse, Specular, Emit, and Constant lighting. Open example 'Phong.toe'. In this
    project there are two very simple examples of the Phong MAT. The first uses the
    texture's alpha to create a transparent box. The second sets the Emit Light of
    1,1,1 to fully illuminate the object regardless of the lighting condition. There
    will be many examples of the Phong MAT when it is put to use in the examples section.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: Phong MAT是最常见的材质操作符。它负责将纹理应用于3D几何体。可以应用各种地图，如颜色、凹凸、高光、漫反射等。Phong MAT可以混合匹配环境光、漫反射、高光、发射和常数光。打开示例'Phong.toe'。在这个项目中，有两个非常简单的Phong
    MAT示例。第一个使用纹理的alpha通道创建一个透明的盒子。第二个将发射光设置为1,1,1，以完全照亮物体，而不受光照条件的影响。当Phong MAT在示例部分中投入使用时，将有许多示例。
- en: The GLSL MAT is used to create custom materials using the OpenGL Shading Language
    (GLSL for short). GLSL is a fantastic programming language that can create extremely
    complex textures that run extremely quickly. It achieves this by giving the programmer
    quite a bit of control over the graphics pipeline, without exposing them to assembly
    languages. There can be a slight learning curve when first starting, but there
    are tons of examples of GLSL shaders on the Internet, as well as quite a number
    of great examples in the 'Shared Component' area of the TouchDesigner Forum.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GLSL MAT可以使用OpenGL着色语言（简称GLSL）创建自定义材质。GLSL是一种非常棒的编程语言，可以创建运行非常快速的极其复杂的纹理。它通过让程序员对图形管线有相当大的控制权，而不暴露给他们汇编语言来实现这一点。刚开始时可能会有一点学习曲线，但互联网上有大量GLSL着色器的示例，以及TouchDesigner论坛的“共享组件”区域中有相当多的优秀示例。
- en: The Point Sprite MAT is used to assign sprites to the points of a particle system.
    The name is self explanatory, in that a 2D image (a sprite) is placed at every
    single point in 3D space. The sprites are always facing the camera, and are scaled
    according to their Z depth. The example 'Point_Sprite.toe' demonstrates this.
    To create a similar TouchDesigner network without point sprites, not only would
    there be a pretty disorganized Network, of who knows how many Transform TOPs and
    Composite TOPs, but they would all be using much more resources. By using a particle
    system and point sprites, the Network is easy to read, and doesn't require a lot
    of system resources.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: Point Sprite MAT用于将精灵分配给粒子系统的点。名称是不言而喻的，即在3D空间的每个点上放置一个2D图像（精灵）。精灵始终面向摄像机，并根据它们的Z深度进行缩放。示例'Point_Sprite.toe'演示了这一点。要创建一个类似的TouchDesigner网络而不使用点精灵，不仅会有一个相当混乱的网络，谁知道有多少个Transform
    TOP和Composite TOP，而且它们都会使用更多的资源。通过使用粒子系统和点精灵，网络易于阅读，并且不需要大量系统资源。
- en: UV Maps
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UV映射
- en: '*8.3 UV Maps*'
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*8.3 UV映射*'
- en: UV mapping is an essential to working with complex 3D geometry. As with certain
    other aspects of 3D modelling, it is easier to create and work with UV maps in
    a dedicated modelling program.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: UV mapping is what allows designers and artists to create interesting motion
    and still graphic textures for 3D geometry. It bridges the 2D world that motion
    and still graphics are created in with the 3D world of the geometry.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: UV mapping is a three-step process. The first step is the unwrapping of the
    3D object into a 2D plane. This unwrapped texture is called a UV map. It is referred
    to as a map, because much like any other type of map, it takes a 3D object and
    accurately, and proportionally, creates a 2D reference. This is the same as street
    maps or world maps, that take the 3D universe and represent them on a 2D plane.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: Texturing is the the second step. The 2D UV map is used by artists and designers
    in their compositing softwares to create textures, whether still or moving. The
    benefit of the UV map is that the textures can be applied to the geometry with
    a high degree of precision.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: The third step is the application of the texture onto the 3D geometry. This
    varies depending on the software used.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: The combination of these three steps are referred to as UV mapping.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: The third step is a relatively common operation in TouchDesigner. As long as
    the 3D geometry is exported correctly from its modelling software, it will include
    co-ordinates indicating to other applications where the UV maps should be applied.
    In these situations the texture is loaded in a Movie In TOP and applied using
    a Phong MAT to the geometry. If any changes need to be made to how the UV map
    is applied, the Texture SOP can be used.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is an example of a simple 3D box, and it''s UV map:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '![](3D-geo.png)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
- en: '![](Geo-map.png)'
  id: totrans-520
  prefs: []
  type: TYPE_IMG
- en: Introduction
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 9 Python
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*9.1 Introduction*'
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python scripting is one of the most powerful features of TouchDesigner 088\.
    It is capable of doing incredibly complex operations, like iterating through large
    data sets, natively communicating with a myriad web APIs, controlling and changing
    the parameters of other Operators in extremely rapid succession, and much more.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that, as of writing, TouchDesigner 088 uses Python 3.3.1\.
    Python 3 differs from Python 2.7 in a number of ways, but most issues can be resolved
    with a quick Google search. Most questions have probably already been asked, and
    the solution could be as simple as a set of parentheses.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in Python 2.7, the Print function could be used without parentheses,
    where in Python 3, this will raise an error. Below is an example of how many Python
    2.7 courses use the Print function:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is in contrast to how the Print function is used in Python 3, where the
    parentheses are required:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An incredible feature of Python, aside from it's readability, is that there
    are many external libraries, many of which can natively connect to most of the
    webs most active spaces, like Facebook, Twitter, Instagram, Foursquare, etc. These
    kind of native integrations unlock a world of real-time data driven projects,
    as well as incredible real-time data sets for visualizations and client presentations.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: There will be quite a bit of Python scripting in later examples, and although
    it is not mandatory to do so, it is highly recommended that some time be spent
    learning Python through introductory tutorials. There are many fantastic resources
    for learning Python, some of them gamified, and most of them often quite easy
    to pick up and put down. Often times, 10-15 minutes a day of tutorials, over the
    course of a few weeks, can provide a strong fundamental knowledge of Python, and
    more than enough knowledge to do quite a bit of scripting in TouchDesigner.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Textport
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*9.2 Textport*'
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Textport has a few important roles in regards to scripting inside of TouchDesigner.
    There are two ways to open the Textport. The first is by using key command 'Alt
    + T'. The second is by selecting 'Textport' from 'Dialogs' in the menu bar at
    the top of the TouchDesigner window.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is that it can be used similarly to the IDLE shell that comes with
    Python installations. For example, open the Textport, type the following, and
    hit ''Enter'' on the keyboard:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Running this in Python would print the result of the equation, which is 8\.
    After hitting 'Enter' in the Textport, the result of the equation is displayed.
    This is because the Textport works as a Python interpreter. Type Python code into
    the Textport, it will be processed, and the results will be returned.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: 'It can similarly do the same for tscript, the scripting language that was used
    in TouchDesigner 077\. Notice that when the Textport is opened, the first thing
    printed is:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is because in TouchDesigner 088, the Textport interpreter is set to interpret
    Python by default. To work with tscript in the Textport, the mode of the Textport
    needs to be changed from Python to tscript. This is done by clicking on the Python
    logo in the top left corner of the Textport. Once clicked, it will change to the
    letter ''T'' and the next line of the Textport will be:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This means the Textport is now in tscript mode. To confirm this, type the following
    tscript code into the Textport:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Similar to the Python Print function, the above tscript code will print 'Hello!''
    to the Textport.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: Another great use of the Textport is as a Python debugger. Open example 'Textport_1.toe'.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very simple example that highlights how beneficial the Textport becomes
    when using Python scripts. Open the Textport, and then click on the ''Good Python''
    button in the middle of the Network. This will run a script that prints to the
    Textport:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now click on the 'Bad Python' button. The Textport will display something very
    different.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a Python error, occurring because some of the code being interpreted
    is invalid. Learning to read these errors can greatly speed up debugging large
    Python scripts. Let's examine the different portions of this error.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line indicates exactly where the error is in the Network, and which
    line of the script the Python interpreter believes is invalid:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, the Operator with the error is 'chopexec1' inside of the component
    'project1'. The Python stops interpreting the script at line 11.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'Below that, the Textport prints the line with the error:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'More often that not, spelling mistakes and slip-ups can easily be caught by
    these two lines. In this case, it is clear that the string being printed is not
    enclosed in quotation marks. Knowing where the error is, and more specifically
    what the line the error is occurring on, means this would result in the problem
    being quickly solved. For the sake of this example look at the last line of the
    error:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The last line of the error is the type of error Python is encountering. More
    detailed information on the different types of errors can be found by looking
    through the official Python 3.3 documentation, under the 'Errors and Exceptions'
    section. The 'SyntaxErrror' is a very common error, and is caused by the Python
    interpreter encountering code that isn't valid Python syntax. As mentioned, the
    above line of code is the missing the quotation marks around the string being
    printed.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: Printing to the Textport is an excellent way to take some of the mystery out
    of scripting. When scripting in larger and larger projects, there are often scripts
    in every Network, and quite often, many of them are performing backend tasks,
    such as preloading and unloading movies, that have results that are difficult
    to view. More often than not, scripts are running in parallel in different Networks,
    and it becomes incredibly difficult to tell if the timing of scripts are correct,
    or if actions are happening in the wrong order.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: By having simple Print functions spread throughout scripts, it is not only easy
    to see when scripts are running, but myriad pieces of information can be printed
    as well. Some of these pieces of information can be as simple as the path to the
    script that is being run, or as detailed as what values and variables are being
    worked with and changed.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Textport_2.toe'. In this example, there are two sequences of scripts
    that run one after another, with a certain amount of pause between them. Click
    the 'Visual Sequence' button. This sequence has buttons that are clicked into
    the On position as each script is run. This is solely to make it easier to see
    the progress of this sequence. How would this progress be monitored from another
    Network?
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: Open the Textport and click the 'Textport Sequence' button. Contrary to the
    first sequence, this sequence prints a message to the Textport as each script
    is run. There may not be buttons visually changing states in the Network, but
    a number of new abilities are gained. The first is the ability to monitor these
    scripts from anywhere in the project. The second is that it is possible to compare
    the timing of these sequences to any other scripts that are running elsewhere
    in the project. The third, and possibly the most valuable, is the ability to pause
    the project and have a written history of the most recent sequence of events.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Textport并单击'Textport Sequence'按钮。与第一个序列相反，此序列在每个脚本运行时向Textport打印一条消息。网络中可能没有视觉上状态变化的按钮，但会获得许多新的功能。第一个是能够从项目的任何位置监视这些脚本。第二个是可以将这些序列的时间与项目中其他地方运行的任何其他脚本进行比较。第三，可能是最有价值的，是暂停项目并拥有最近事件序列的书面历史。
- en: This history becomes absolutely invaluable when debugging complex logic systems.
    In a project with 30 Networks and 300 independent scripts, when a series of actions
    fail without raising any Python errors, without an ordered log of events, it would
    be impossible to trace bugs. As a script becomes longer and more complex, it is
    easy to create more of these pseudo-checkpoints throughout the script, such as
    'running X section of Y script'.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 这段历史在调试复杂逻辑系统时变得非常宝贵。在一个有30个网络和300个独立脚本的项目中，当一系列操作失败而没有引发任何Python错误时，如果没有有序的事件日志，将无法追踪错误。随着脚本变得越来越长和复杂，很容易在整个脚本中创建更多这些伪检查点，比如'运行Y脚本的X部分'。
- en: Common Practices
  id: totrans-564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见做法
- en: '*9.3 Common Practices*'
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*9.3 常见做法*'
- en: 'There are some common practices that should be upheld when working with Python.
    Something that is interesting about the Python language is that it is built around
    the idea of readability and simplicity. Python has an easter egg built inside
    of it, which can be accessed by entering the following code into a Python interpreter
    or the Textport:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Python时应遵守一些常见做法。关于Python语言有趣的一点是，它建立在可读性和简单性的理念之上。Python内置了一个彩蛋，可以通过在Python解释器或Textport中输入以下代码来访问：
- en: '[PRE11]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Python returns a poem named ''The Zen of Python'' by Tim Peters. Below is that
    text:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: Python返回了一首名为'The Zen of Python'的诗，作者是Tim Peters。以下是该文本：
- en: '[PRE12]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This poem is the motto for many Python developers. Many of its lines try to
    convey Python's ideals and common developer sense.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 这首诗是许多Python开发者的座右铭。它的许多句子试图传达Python的理想和常见开发者意识。
- en: 'Think about the line:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这句话：
- en: '[PRE13]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This can be applied to something that is often done in a hurry: naming. There
    are many different areas in Python and TouchDesigner where objects reference each
    other by name. A developer ends up naming variables, functions, Operators, Networks,
    and more. Without carefully naming Operators, it would be impossible to know each
    Operator''s function. Similarly, without care in naming variables, as demonstrated
    earlier in the chapter, reading scripts can become quite a tedious task. There
    are two conventions that are regularly used when naming Operators and variables
    in TouchDesigner.'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以应用于经常匆忙完成的事情：命名。在Python和TouchDesigner中有许多不同的领域，对象通过名称相互引用。开发人员最终会为变量、函数、操作符、网络等命名。如果不仔细命名操作符，将无法知道每个操作符的功能。同样，如果不在命名变量时小心，如本章前面所示，阅读脚本可能会变得非常繁琐。在TouchDesigner中命名操作符和变量时通常使用两种约定。
- en: 'The first involves using underscores in the place of real-world spaces. Here
    are some examples:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个涉及在现实世界空间的位置使用下划线。以下是一些示例：
- en: final_comp
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: final_comp
- en: stop_button
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stop_button
- en: time_now
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: time_now
- en: 'The underscores make names easier to read and quickly understand. There are
    individuals who aren''t partial to using underscores, and because of such the
    second convention involves using capital letters to differentiate between words.
    Here are some examples:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线使名称更易于阅读和快速理解。有些人不喜欢使用下划线，因此第二个约定涉及使用大写字母区分单词。以下是一些示例：
- en: finalComp
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: finalComp
- en: stopButton
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stopButton
- en: timeNow
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: timeNow
- en: Both are able to convey the original idea of explicit naming, and should be
    used to facilitate collaboration.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都能传达明确命名的原始想法，并应用于促进协作。
- en: Commenting Code
  id: totrans-583
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码注释
- en: '*9.4 Commenting Code*'
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*9.4 代码注释*'
- en: 'Commenting is a practice that should not be overlooked by new users of Python.
    As easy as it is to write a few lines of script, it takes only a few more seconds
    to quickly document what those lines do. This comes in handy in a multitude of
    situations such as:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: Sharing code and projects with other programmers
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining code in older projects
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the functionality inside of a re-usable component
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It may seem frivolous when scripts are brief, but it is a habit that should
    be solidified from day 1\. Look at the example code below:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This script is hard to read for a number of reasons. The main reason is that
    its actions weren''t obvious when quickly skimmed. One quick way to increase the
    readability of this script is to comment it. Let''s take the above script and
    add some basic comments to it:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Without taking the time to create meaningful variable and Operator names, the
    above script is still much easier to read through. Even out of context, the function
    of the script is apparent.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: This kind of simple addition can make collaborating with other developers much
    easier and more enjoyable.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: Compartmentalizing
  id: totrans-595
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*9.5 Compartmentalizing*'
  id: totrans-596
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The more complicated projects become, scripts will slowly become longer and
    longer. At a certain point, it will take more time to search through code, than
    it will take to actually change and add to it. Because of this, it is important
    to compartmentalize all of a projects scripts.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: 'This means a few different things, and incorporates a few different techniques,
    but it yields quite a number of benefits. All of these benefits will directly
    improve one''s workflow, but more importantly, they will take a lot of the pain
    out of collaborative settings. Some of the benefits include:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: Easier long-term maintenance of scripts
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less time spent explaining scripts to colleagues
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier reusability of programmed functionality
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faster short-term edibility and code management
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open example 'Scripting_1.toe'. In this example, there are 10 Movie In TOPs
    and there are a series of actions that need to be performed on each of them. First,
    each one should be unloaded. Secondly, each one will be assigned a new file path.
    Finally, each movie needs to be preloaded, and prepared for playback. Because
    this is a Python example, all of these actions will be performed with Python script.
    Take a look at the Text DAT named 'movies'.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick note about this script: For the sake of this example, this script doesn''t
    iterate over all of the Operators using loops. This is to simulate what a longer
    and more complex script would feel like, even though only a few simple actions
    are being performed.'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the Text DAT named 'movies', select 'Run', and all the actions
    mentioned above will occur in sequence. This script has been lightly commented,
    but looking through it quickly can be a bit disorienting. To edit a single value
    somewhere in the code, it would have to be found in the long list of actions.
    Colleagues would have to spend more time trying to figure out what this script
    does. To re-use a piece of this script in the future, pieces of it would have
    to be manually found and extracted. How can these processes become more efficient?
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: 'Open example ''Scripting_2.toe''. This example takes the code from the previous
    example, but separates each of our ''actions'' into its own, isolated, Text DAT.
    Immediately, even without diving into each of the scripts, it is easy to tell
    what each one will do. There is one for unloading movies, one for changing paths,
    and one for preloading movies. At the end of each, there is a line of code that
    runs each progressive script in the sequence. This is line of code uses the Run
    class:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '`op(''preload'').run()`'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: It would be easy to quickly edit a single value, as actions and parameters are
    much easier to track down now. Passing this component to a colleague would be
    no trouble at all, as they could quickly see what each script does at first glance.
    If someone needed a script to start to preload of a set of Movie In TOPs, it could
    be quickly taken from this project.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: This compartmentalized workflow helps cut hard to manage scripts, some more
    than 500 lines in length, into smaller scripts that are easy to sort through quickly
    and share. In the case of the above example, there is third way to handle working
    with these multiple Operators.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Scripting_3.toe'. This example takes advantage of Python functions.
    A Python function is a small cluster of code that can be called to perform as
    series of action. Inside of the Text DAT named 'actions', a function has been
    defined that contains the set of actions that need to be performed on each Movie
    In TOP. From the Text DAT named 'set_movie_tops', instead of retyping the same
    set of actions over and over, the new function is called by passing it the name
    of each Movie In TOP.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the series of actions have been slightly arbitrary, the idea is simple:
    compartmentalize Python scripts for ease of maintenance, easier co-operative workflows,
    re-usability, and ease of management.'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: External Modules
  id: totrans-612
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*9.6 External Modules*'
  id: totrans-613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the underused benefits of Python integration in TouchDesginer is the
    ability to import third-party Python libraries and use them natively. This includes
    the ability to use libraries such as the popular Requests or Beautiful Soup libraries.
    Importing a library is a simple process.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: Install a 64-bit build of Python. At the time of writing, 3.5 is the latest.
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use 'pip' to install your desired packages
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open TouchDesigner and go to the 'Edit' menu, and then click on 'Preferences'
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the setting under 'General' called 'Python 64-bit Module Path' and add
    the path to your 64-bit Python 'site-packages' folder. This folder can be found
    in your Python installing folder, inside of the 'Lib' folder
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside of TouchDesigner, create a Text DAT, and test the package by using standard
    'import' command
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a good idea to confirm that 'pip' installed the package for the correct
    version of Python. A common issue users face is that 'pip' is called for a different
    version of Python than is desired.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: Where to Learn Python
  id: totrans-621
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*9.7 Where to Learn Python*'
  id: totrans-622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Below is a very basic list of some free, online, Python tutorials. (Note: some
    of the tutorials are for Python 2.7, but are incredibly well made, and thus included).'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '**CodeAcademy** [http://www.codecademy.com/tracks/python](http://www.codecademy.com/tracks/python)'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '**Khan Academy** [https://www.khanacademy.org/science/computer-science](https://www.khanacademy.org/science/computer-science)'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '**Coursera** [https://www.coursera.org/course/interactivepython](https://www.coursera.org/course/interactivepython)'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '**Google Developers** [https://developers.google.com/edu/python/?csw=1](https://developers.google.com/edu/python/?csw=1)'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '**Learn Python The Hard Way** [http://learnpythonthehardway.org/](http://learnpythonthehardway.org/)'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: Perform Mode
  id: totrans-629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 10 Outputting Content for Deployment and Performance
  id: totrans-630
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*10.1 Perform Mode*'
  id: totrans-631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perform mode should be used whenever possible when deploying projects. The basic
    premise behind Perform mode is that when a project is ready to be delivered, it
    will be in a state that won't require on-demand programming, and thus won't require
    the Network editor. It is surprising how much system resources can go towards
    just rendering the Network editor, especially if there are many Operators with
    visible viewers, displaying CHOP channels, TOP previews, DAT tables, etc.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, Perform mode exists so that that computer can focus on rendering
    the content, and doesn't have to render the extra Network editor. Everything that
    is involved with creating the final product is still rendered and active in Perform
    window, including elements such as external data inputs and outputs. The only
    thing that stops being rendered is the Network editor.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the Component chapter, it is recommended that Container COMPs
    are used as the source for Window COMPs. The same recommendation applies to Perform
    mode.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Perform_mode.toe'. In this example, the Container COMP, 'container1',
    is used as the source for Perform mode. Press the 'F1' key to enter Perform mode,
    and the contents of the container will be displayed in a new window. Press the
    'ESC' key to exit Perform mode and return to the Network editor. There is a UI
    button that can be used to enter Perform mode via the mouse.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '![10.1.1](perform.png)'
  id: totrans-636
  prefs: []
  type: TYPE_IMG
- en: Performing with the Network Editor
  id: totrans-637
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*10.2 Performing with the Network Editor*'
  id: totrans-638
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every situation is different, and it is possible that programming might have
    to be done during a live performance. If that is the case, there are a few things
    that can help manage the impact the Network Editor has on the system. The first
    is to turn off the viewers on any Operators that don''t need to be monitored.
    See the diagrams below:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '![10.2.1](performing-network-1.png)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
- en: '![10.2.2](performing-network-2.png)'
  id: totrans-641
  prefs: []
  type: TYPE_IMG
- en: The next thing that helps is to only use 1 pane in the Network Editor. The more
    panes that are visible, the more things there are needing to be rendered.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: Finally, moving in and out of large Networks should be avoided. Moving in and
    out of large Networks can cause frame drops, as TouchDesigner will have to render
    all of the Operators in that Network before they can be viewed.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Output Raster
  id: totrans-644
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*10.3 Creating an Output Raster*'
  id: totrans-645
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a general rule, to get the best performance possible, one should always strive
    to only use 1 Window COMP at a time. This doesn't apply while programming, but
    when it comes to deployment and performance, having more than one window open
    will greatly decrease the system's performance. So what should be done if there
    are multiple outputs with different positions and rotations?
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: The answer is to create a raster for the output and create a single, all-encompassing,
    window that will span all of the real-world outputs.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: This is more simply expressed with an example. In this example scenario, there
    are four SXGA+ projectors, each with a resolution of 1400x1050\. In the real-world
    setup, there are two projects beaming horizontally on side walls, and two projectors
    beaming vertically, and edge blended, on the center wall. The diagram below illustrates
    the desired setup.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '![10.3.1](raster-1.png)'
  id: totrans-649
  prefs: []
  type: TYPE_IMG
- en: This setup isn't particularly complex, thus knowing how to deal with it most
    effectively is important. Let's take this setup, and lay it out in 2D.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: '![10.3.2](raster-2.png)'
  id: totrans-651
  prefs: []
  type: TYPE_IMG
- en: A beginners's first instinct might be to use four Window COMPs because there
    are four outputs, two of which need to be rotated. The challenge is finding the
    most efficient layout for these four canvases, to create a single raster. In this
    instance, because all four outputs are the same resolution, an easy solution is
    to make a 2x2 grid.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '![10.3.3](raster-3.png)'
  id: totrans-653
  prefs: []
  type: TYPE_IMG
- en: In the above diagram, all of the outputs are placed into a single raster. This
    setup can efficiently use one Window COMP that is 2800x2100 pixels. At this point,
    the nVidia or AMD control panel should be used to create a similar setup out of
    the monitors in Windows, which should then be connected to the correct outputs
    on the graphics card.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to prepare this raster inside of TouchDesigner. Open example
    'Raster.toe'. There are a few things to note from the start. For the example,
    some very basic dummy content has been created, and will represent where real
    content would go. 'Content1' is for the left wall projector and is 1400x1050 pixels.
    'Content2' is for the middle set of projectors and is 2100x1400 pixels. 'Content3'
    is for the right wall projector and is 1400x1050 pixels. All of the canvas building
    happens inside of the 'canvas' Container COMP.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: 'In the ''canvas'' container, the signal path can be followed from left to right,
    and from top to bottom, like a waterfall. The first step is to create a blank
    raster that content can be composited on. There is a Constant TOP set to 2800x2100
    pixels at the top left of the Network for this purpose. Using an Over TOP, the
    first piece of content is placed, for the left wall projector, in its appropriate
    position, according to the diagram above. This is done using the ''Translate''
    parameter of the Over TOP. Projector 1: done!'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: The middle wall has two projectors that are edge blended together. Because a
    few operations need to happen on the raw content, there is a container name 'crop'.
    This keeps the operations encapsulated, neat, and easy to find. Inside of 'crop',
    three main operations are performed. The first is that the big piece of content
    is cut it in half, so that each projector can display half of the image. Since
    the projectors are positioned vertically in the installation, but are positioned
    horizontally in the raster, the 'Flop' parameter of the Flip TOP is used to turn
    the canvas on its side. The settings for the Flip TOP will always end up being
    different depending on hardware setup, so be prepared to try different Flip and
    Flop settings to get the correct content orientation.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: 'Side note: Most beginners have trouble rotating a full canvas. The first instinct
    is to use the Transform TOP, but it is important to note that the Transform TOP
    will transform the pixels inside of a canvas. This is where the ''Flop'' parameter
    of the Flip TOP comes in. It will fully rotate the canvas.'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: Since this example isn't dedicated to edge blending, the 'edge_blend' containers
    are just place holders that create the visual effect of a blended edge.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: With all the cropping, rotating, and blending done, the two projector outputs
    are ready to be composited onto the raster. Using the same technique as before,
    an Over TOP with a modified 'Translate' parameter correctly positions the two
    pieces of content. Now Projector 2 and 3 done as well!
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: The final projector is as simple as the first, and using the trusty Over TOP,
    the final piece of the puzzle is positioned.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in an earlier chapter, it is best practice to use Container COMPs
    instead of TOPs as the source for Window COMPs. In this project, there is a container
    that is 2800x2100 pixels that holds the completed raster. The 'final' container
    is set as the Window COMPs 'Operator', the 'Borders' setting is turned off in
    the Window COMP, and the window size is set to 2800x2100 pixels. With that, the
    project is ready to be output to the above, 4 projector, setup.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: Displays, Tearing, and Stuttering
  id: totrans-663
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*10.4 Displays, Tearing, and Stuttering*'
  id: totrans-664
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There has not been much hardware discussion throughout this book, but it is
    important to keep a few things in mind when working with multiple displays. The
    most important rule is to always try to have all display hardware be exactly the
    same. Any difference in the signal flow, can cause what is called 'tearing'. The
    image below is an example of a frame that has tearing.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: 'Examine the image below. Is it an example of what a frame with tearing will
    look like. Notice the two horizontal cuts across the frame:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '![](tearing.jpg)'
  id: totrans-667
  prefs: []
  type: TYPE_IMG
- en: '*Image courtesy of Wikipedia*'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: Tearing occurs when a display refreshes its image out of sync with when the
    graphics card renders its image. The result is part of the image being from the
    previous frame, and part of it being from the next frame. On slow moving content,
    this can sometimes be hard to notice, but once there is any sort of motion in
    the content, tearing becomes incredibly distracting.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: Tearing is a complex issue to solve, but there are a few preventative measures
    that can be taken to avoid it. The first is to use a professional graphics card,
    such as something from the nVidia Quadro series. Most companies will not guarantee
    tear-free playback on anything but their professional cards.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: The second is to always ensure that the displays are identical. Identical can't
    be stressed enough. If there is an installation with 3 outputs that have a refresh
    rate of 60hz, and one output with a refresh rate of 59hz, there is a chance there
    will be tearing. If there is an installation with two 1080p projectors, and two
    SXGA+ projectors, there is a chance there will be tearing. The best practice is
    to use displays that are not only identical in specifications, but are also the
    exact same model of displays. Network remote access applications like VNC and
    LogMeIn have also been the culprits of tearing.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings up a very important issue with tearing: there are no hard and fast
    rules. Sometimes, setups with a handful of different resolutions and refresh rates
    will work perfectly and won''t tear. On the other hand, sometimes even setups
    with identical displays can tear. Enough emphasis cannot be put on preventative
    measures to avoiding tearing. When tearing issues arise, the only things that
    can be done are a step by step breakdown and analysis of the system to see what
    is causing the tearing.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: There is a list of common debugging methods on the Derivative Wiki page for
    'Tearing'.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally the steps to begin with are as follows, in no particular order:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: Verify the project isn't dropping any frames. Dropped frames can sometimes trigger
    tearing
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify no other applications are interrupting or mirroring the graphics card
    drivers, such as VNC and LogMeIn.
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disconnect every display connected to computer, and one by one connect them
    until tearing occurs. Then isolate that display on it's own, and figure out if
    it's being cause by a single display, or by the layout
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify all displays are configured to the same resolution, colour bit depth,
    and refresh rate, in the nVidia or AMD control panel
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify that none of the displays have any rotation applied in Windows. this
    can cause unpredictable behaviour.
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the graphics card driver version and update it if necessary
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check for drivers or firmware updates on external video splitters - such as
    the Datapath X4 or Matrox TripleHead2Go
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirm only 1 Window COMP is being rendered
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify Windows Aero is disabled. In Windows 7, Aero can cause dropped frames
    and stutters, but won't tear. Once disabled, the system might tear, but stutter
    free playback is guaranteed.
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure a Premium Mosaic using the nVidia Control Panel to create a single
    logical display
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many instances in which a system that performs perfectly, and doesn't
    drop a single frame, will occasionally stutter. This may occur because of how
    displays and graphics cards negotiate different refresh rates.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: If a project is running at 30 FPS, but a display's refresh rate is 60hz, frame
    doubling has to be negotiated somewhere. Between the graphics card and the display,
    most of the time this negotiation is done transparently, but sometimes there can
    be issues. What can occur is that instead of negotiating a proper frame doubling
    for every frame, one frame might be displayed once, while the next frame is displayed
    for three frames. From the project's point of view, no time is lost and no frames
    were dropped, so it would not be reported in the Performance Monitor or Windows
    Task Manager.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: If it seems that this kind of issue may be occurring, use the 'FPS is Half Monitor
    Refresh' feature in the Window COMP. This informs the graphics driver that it
    should show each frame for 2 refreshes.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: Edge Blending
  id: totrans-688
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*10.5 Edge Blending*'
  id: totrans-689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Video projectors are an incredibly flexible and are able to create infinitely
    large canvases. This is done by creating arrays of projectors with overlapping
    edges that are blended together to create a seamless canvas. This act of blending
    the overlapping sections is called 'Edge blending'.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: The idea of edge blending might be new to those who generally work with monitors
    and screen arrays. A great example of the principles behind edge blending can
    be done relatively quickly. Set up 2 projectors and have one project the color
    blue and have the other project the color green. Separately, these projectors
    output their assigned colors, but if you aim the projectors so that the colors
    overlap, the areas where these two projectors overlap you will actually have a
    turquoise color. These principles of physics and additive color mixing are the
    basis for edge blending.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an excellent paper written by Paul Bourke that goes much more in-depth
    on the subject of edge blending than we will be going here. For further reference
    and reading, please find that paper at the link below:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: '**Edge blending using commodity projectors by Paul Bourke** [http://paulbourke.net/texture_colour/edgeblend/](http://paulbourke.net/texture_colour/edgeblend/)'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to learn the basics of edge blending is through an example setup.
    In this example, the goal will be to blend two 1920 x 1080 projectors in a 1 x
    2 array (1 unit tall and 2 units across). Below is a diagram of a 1 x 2 array
    of projectors:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '![10.5.1](blending_layout.png)'
  id: totrans-695
  prefs: []
  type: TYPE_IMG
- en: The act of blending both of these projectors will require an overlapping section.
    The amount of overlap needed will vary based on many factors such as projector
    resolution and installation parameters. Starting with a blend zone that is a power
    of 2 close to 10\% of your single projector size can be a good place to start
    experimenting. For this example, 10\% of the length of a 1920 x 1080 screen is
    192 pixels, and the nearest power of 2 is 256\.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: 'This overlapping section can cause problems if all of its implications aren''t
    considered. For the image to overlap, that means the both projectors must have
    the same content on their blending edges. In this example, that means that the
    right edge of Projector A and the left edge of Projector B must have the exact
    same content. Filling in some numbers, that means that the 256 pixels on the right
    edge of Projector A must be the same as the 256 pixels on the left edge of Projector
    B, as per the diagram below:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: '![10.5.2](blended_edge_layout.png)'
  id: totrans-698
  prefs: []
  type: TYPE_IMG
- en: It's important to take this fact into consideration in regards to the full production
    pipeline and workflow. It seems natural at first to think that a 1 x 2 array of
    1920 x 1080 projectors would need content created at 3840 x 1080, but that assumption
    can lead undesirable consequences.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: A projector has a set amount of physical pixels just like a monitor. Two 1920
    x 1080 images placed edge to edge will have a span of 3840 pixels, but if pixels
    need to be doubled in the overlapping blend zone, those extra pixels used for
    blending don't appear from thin air. The blend zone will need to consume pixels
    that would have otherwise been used for content.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, if the content creation team created a 3840 x 1080 asset,
    256 pixels would need to be discarded from somewhere to account for the 256 pixels
    that are going to be doubled in the blend zone. Where these pixels are discarded
    from is a matter of preference and tool choice, but the preferred method is to
    discard half of the blend zone from each non-blended edges opposite the blend
    zone. This method keeps the absolute center of the canvas the area where blending
    will occur, as per the diagram below:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '![Discarded Edge Layout](discarded_edge_layout.png)'
  id: totrans-702
  prefs: []
  type: TYPE_IMG
- en: Always be aware of this loss of pixels when edge blending projectors to avoid
    placing critical information or content around areas where pixels may be discarded.
    So why remove only half the blend zone (128 pixels) on each side and not remove
    the whole blend zone from each side (256 pixels)? The answer is that to create
    an overlap of 256 pixels in the center, each side needs to be shifted 128 pixels
    towards the other. When both sides are moved 128 pixels towards each other, the
    resulting overlap is 256 pixels.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding with edge blending in TouchDesigner, there are a few ways
    to approach creating content for blended projectors.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: The first is to create content at the full output resolution, in this example
    that would be 3840 x 1080, with a buffer of content around the edges where pixels
    will be discarded. Even though parts of the buffer will be discarded, it allows
    for a bit of flexibility in changing the size of the blend zone during installation
    and setup without worrying about cutting too much content and not having enough
    to fill the canvas. This is the 'safe' way to proceed for projects that don't
    have an experienced projectionist on staff to calculate the blend zones before
    installation.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: For projects that do have a projectionist or other experienced individual on
    staff, there is the option to have the content team create content to the size
    of your visible image, and not the full output resolution. This is appealing because
    it means that there are less pixels to process in generative pipelines or pixels
    to read from a hard drive. To calculate the total image size in this example,
    take the full output resolution (3840 x 1080) and subtract the size of the blend
    zone (256 pixels). This leaves 3584 x 1080 for content, or the image resolution.
    The risk exists with this method that if the blend zones aren't calculated correctly,
    then the content may not be large enough to fill the screen without additional
    scaling.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: Whichever route is chosen, the diagrams below illustrate firstly the final output
    of each projector side by side as seen by Windows and TouchDesigner, and secondly
    the projected image as seen on the projection surface after the blending.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '![Full Layout](full_layout.png)'
  id: totrans-708
  prefs: []
  type: TYPE_IMG
- en: '![Full Image Layout](full_image_layout.png)'
  id: totrans-709
  prefs: []
  type: TYPE_IMG
- en: Implementing this example is straightforward in TouchDesigner thanks to built-in
    edge blending tools. Before using the built-in edge blending component, let's
    take a look at the base elements of an edge blending workflow in a simple example.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Simple_blend.toe'. In this example, the Container COMP named 'content',
    creates stand-in 3840 x 1080 content by stretching a TouchDesigner sample file.
    The output of this container is then split into two parts using Crop TOPs, one
    for each projector. The important thing to note here is the offset mentioned previously
    is in the Crop TOPs. Projector A's Crop TOP creates a 1920 x 1080 (projector resolution)
    texture starting from the left edge that is offset 128 pixels to the right, discarding
    128 pixels (half the size of the blend zone) from the non-blended edge, in this
    case, the left edge. Similarly, Projector B's Crop TOP creates a 1920 x 1080 texture
    starting from the right edge that is offset 128 pixels to the left, discarding
    128 pixels from the non-blended edge, in this case, the right edge. Both textures
    being offset by 128 pixels towards each other creates a 256 pixel overlap for
    blending.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: To create the blend zone, these textures are multiplied by alpha ramps that
    are the size of the blend zone, which is 256 x 1080 pixels. There are a number
    of other elements needed to create a seamless image, but this example is to demonstrate
    the workflow. After the elements have their edges prepared for blending, they
    can be appropriately composited onto a single texture that is the full output
    resolution, or in this case, the individual textures are then assigned to the
    backgrounds of Container COMPs, each at the projector resolution. These Container
    COMPs are then parented and aligned using the parent container's 'Align Layout
    Horizontal Left To Right' parameter, which effectively creates the master output.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: There are a few elements missing from this basic example such as gamma and luminance
    correction, but this should give you an example of the process of cropping the
    source texture, offsetting the pieces to create an overlap, creating the blend
    zone using a ramp, and then creating an output from that. With a basic understanding
    of the workflow, let's take a look at an example using the more feature-rich built-in
    edge blending tool.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Full_blend.toe'. This project file has two examples in it corresponding
    to the two methods of content creation that were discussed. To find the edge blending
    component for your own projects, open the Palette Browser either using 'Alt +
    L' or by going to the 'Dialogue' menu at the top of the screen and clicking on
    'Palette Browser'. Inside the Palette Browser, under the 'Tools' section, you
    will find the 'EdgeBlend' component that can be dragged into your project. This
    component is based on the same paper by Paul Bourke referenced earlier.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: In both examples, the 'EdgeBlend' component is set to have a blend of 256 pixels.
    The 'EdgeBlend' component creates an overlap of content in the center of the texture,
    at the expense of discarding pixels on the non-blended edges. It multiplies the
    blended edges by a ramp and composites the processed textures onto a canvas that
    is the full projector resolution.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: The first example uses stand-in content at the full output resolution of 3840
    x 1080 pixels. This is the 'safe' method mentioned earlier where losing extraneous
    content on the non-blended edges allows a bit more flexibility in blend zone adjustments
    during installation.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: The second example uses stand-in content at the image resolution of 3584 x 1080\.
    At this resolution, pixels don't need to be discarded from this texture. One key
    thing to remember is that many edge blending tools will assume that you are using
    the first example's route, providing content at the full output resolution and
    they will discard pixels on the outside edges and return a texture at the same
    resolution as your input texture. That is why in this example, the image resolution
    asset (3584 x 1080) is composited in the center of a full output resolution canvas
    (3840 x 1080) before being input into the 'EdgeBlend' component. Thus the 'EdgeBlend'
    component will double content in the middle and discard the blank space on either
    side of the image.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: The difference of outputs can be seen clearly, whereas the top example loses
    the reference color bars that were on the outside edges of the image, and the
    second example does not.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: 'With these outputs prepared, it''s a matter of sending the correct texture
    to the correct projector. How to rig projectors and work with complex rigs is
    outside of the scope of this chapter. In an ideal situation, both projectors are
    parallel with the projection surface as such:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '![Projectors](projectors.png)'
  id: totrans-720
  prefs: []
  type: TYPE_IMG
- en: If the amount of pixels in the blend zone are already known, input them into
    the 'Region' parameter of the 'EdgeBlend' component. Then try turning off the
    'Enable Blend' button to make sure your image is correctly overlapping. At this
    point, the overlapped images should match and be lined up. Always remember the
    main purpose of an edge blending tool is to remove the seams, not line up the
    content.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: If the amount of pixels in the blend zone aren't know, turn off the 'Enable
    Blend' button and enter a guess. Trying a lower value in the 'Region' parameter
    will offset each projector's texture towards the center, while a higher value
    will offset them towards the edges. Continue increasing or decreasing the 'Region'
    value until your the content in the overlap is the same. Then turn on the 'Enable
    Blend' button.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: At this point, use the 'Blend' slider to adjust power of the blend. A higher
    value will make the ramp steeper, whereas a lower value will create a more gradual
    ramp.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: You may need to perform gamma correction on the contents of the blend zone.
    This is because light isn't perceived linearly, so the luminance of a pixel being
    input at 0.5 might not be double that of brightness of a pixel being input at
    0.25 (pixel values being normalized from 0-1). Almost all video data already passes
    through gamma correction but because of the variance of projector technologies
    and the fact that there are two projectors overlapping, you may find subtle changes
    need to be made. These sliders are used to compensate or lessen the intensity
    of the gamma correction.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: The 'Luminance' slider controls the overall luminance of the blend zone. If
    the blend zone is brighter or darker than the rest of image, bringing this slider
    below 0.5 will make the blend zone darker, while raising this slider above 0.5
    will brighten the blend zone.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-726
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 11 Optimization
  id: totrans-727
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*11.1 Introduction*'
  id: totrans-728
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Is is incredible to think about the challenges that are overcome when working
    in real-time. All the hardware and software aside, there is an extraordinary amount
    of precision to real-time work. When working in a project at 30 FPS, every single
    thing that is processed, displayed, and created, must be done in a 33ms window.
    That's not even a tenth of a second! This window is even smaller when working
    at higher frame rates. A project running at 60 FPS only has 16ms to render every
    frame from start to finish.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: Realizing how tiny the window of opportunity is, it is important to cherish
    every single fraction of a single millisecond. Wonder why Operators are taking
    a whole millisecond to cook. Become nervous and try to salvage every half millisecond
    possible, knowing that every millisecond makes a difference. These all require
    basic project analysis and optimization skills.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: TouchDesigner uses the CPU and GPU heavily, and knowing how to figure out which
    is under more demand is an important skill. When faced with larger and larger
    Networks, knowing where the system is stalling, and how to optimize Operators
    to get around these pitfalls, can be the difference between successfully delivering
    and not delivering a project.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Bottleneck
  id: totrans-732
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*11.2 Finding the Bottleneck*'
  id: totrans-733
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The computer as a whole can be thought of as a pipeline. The CPU, GPU, RAM,
    and hard drives, all work together to create the final product. They sometimes
    work independently, but often times they are reliant on each other, because they
    individually perform very specific tasks. In a pipeline, the system can only be
    as fast as the weakest link. Because of this dependant nature, one stage of the
    pipeline can stall a whole project, even if the rest of the pipeline is completely
    clear. This stall, or weak link in the chain, is referred to as a bottleneck.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: An example of a pipeline with a bottleneck is a project that tries to render
    some basic 3D geometry and texture their faces with video files. This hypothetical
    project consists of 4 Box SOPs. Every face of the Box SOPs are textured with a
    1920x1080 HAP Q movie file. The computer being used for this has 32GB of RAM,
    dual 8-core processors, a top of the line nVidia Quadro graphics card, and a single
    5400-RPM hard drive.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: When launched, this project just won't run on this system. Regardless of how
    much RAM, how many processors, and how expensive a graphics card, the project
    can't read that many HAP Q files from a single 5400-RPM hard drive. The computer
    will continually stall because the hard drive can not spin fast enough to read
    every single movie file simultaneously. HAP Q files are demanding on the hard
    drive, and no matter how powerful the rest of the computer is, the project will
    not run. The GPU can't begin to read movies from a hard drive, just as the hard
    drive cannot begin to process pixels. The hard drive, in this case, has become
    the bottleneck in this project's pipeline.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally there are three areas where bottlenecking occurs: the GPU, the CPU,
    and the hard drives.'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: The GPU is a pipeline in and of itself, and pixel shading is the stage that
    is likely to become a bottleneck. Whenever operating on pixels, using almost any
    TOP, the system demands more and more of the GPU's pixel shader. The higher the
    resolution, the higher the demand on the GPU. There is a 1:1 ratio between a TOPs
    resolution and it's GPU workload. If a TOP's resolution is reduced by a factor
    of two, its GPU workload is proportionally reduced. A quick way to check if there
    is a pixel shading bottleneck is to lower the resolution of all generator TOPs,
    such as Render TOPs and Constant TOPs. If there is an immediate increase in speed
    and performance, then it is clear that there is a pixel shading bottleneck.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: When the graphics card is overworked, seemingly random TOPs will start to have
    higher than normal cook times. This becomes apparent when looking in the Performance
    Monitor at the cook times of various TouchDesigner UI elements. If all of a sudden,
    the various UI elements are taking more than a millisecond to cook, the Network
    needs to be optimized to relieve the GPU of some of its workload.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: The CPU is second area where bottlenecks are experienced. Most Operators require
    the CPU to function, thus the CPU can quickly be overworked. CPU bottlenecks tend
    to be easier to track down, because the Operators that take a long time to cook
    are visible in the Performance Monitor. It is possible to measure how much CPU
    head room there is with the Hog CHOP. This CHOP does as it name implies, and hogs
    CPU processing power. The 'Delay' parameter is the amount of seconds that the
    Hog CHOP will add to the cook time of each frame. If a Hog CHOP is created and
    the project begins dropping frames, that means the CPU is the our bottleneck.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: All movie files use the CPU to decode data from their compressed state. Certain
    codecs use the CPU more than others, and reading many movie files simultaneously
    can use more CPU resources than one would imagine.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: An overloaded CPU reacts similarly to an overloaded GPU, in that inconsistent
    results will appear in the Performance Monitor. Operators will have varying cook
    times. This is because their operations are started, but before they finish, the
    CPU is called to perform another process. The amount of time that the Operator
    spends waiting for the CPU to return to its process is what increases it's cook
    time. Unlike a GPU overload, a CPU overload will generally effect more than just
    TOPs.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: 'Hard drives are the third area where bottlenecks occur. Specific operations
    can be demanding on hard drives, and it is easy to overlook high quality solid
    state drives (SSD) when preparing systems for deployment. Operations such as reading
    and writing movies can quickly exhaust a drive, depending on the codec used. This
    bottleneck will often appear in the Performance Monitor as a line item under a
    Movie In TOP that such as:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Where the number is the frame of the movie, and the path is the path to the
    movie file.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: Using the Performance Monitor
  id: totrans-746
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*11.3 Using Performance Monitor*'
  id: totrans-747
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Performance Monitor is a tool for analyzing the cook time of a frame. This
    is useful when trying to optimize and debug a project's performance.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to access the Performance Monitor:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '''F2'' on the keyboard'
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '''Alt + Y'' on the keyboard'
  id: totrans-751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clicking 'Performance Monitor' under 'Dialogs' in the menubar at the top of
    the screen
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are only a few buttons, and they perform simple tasks that are almost
    self-explanatory.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: '![Performance Monitor](performance-monitor-1.png)'
  id: totrans-754
  prefs: []
  type: TYPE_IMG
- en: Performs an analyses on the current frame
  id: totrans-755
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clears the current results
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Saves the current results to a text file
  id: totrans-757
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change what is being monitored
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A millisecond threshold value, which if crossed by a frame's cook time, will
    trigger the Performance Monitor to analyze
  id: totrans-759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter the results for more precision, i.e. only CHOPS, TOPs, etc
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is important to note that cook times are based on the CPU. This doesn't mean
    GPU bottlenecks will go unnoticed in the Performance monitor, but be cognizant
    that these are CPU readings.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example analyses from the Performance Montior.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: '![Performance Monitor 2](performance-monitor-2.png)'
  id: totrans-763
  prefs: []
  type: TYPE_IMG
- en: The analyses above is taken from a simple project with a few Movie In TOPs and
    a few Over TOPs. Every frame that is analyzed will have some similar Operators.
    These are the Operators responsible for the functionality and user interface elements
    of TouchDesigner.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: Look at the marked sections on the above diagram to see the cook times, and
    paths, for the Operators responsible for TouchDesigner's main functionality (User
    interfaces, dialog windows, etc), and more importantly the Operators belonging
    to the example project. The cook time of each Operator is represented by a white
    bar that is sized proportionally based on its contribution to the total cook time
    of that frame. When projects grow and become more involved, the section labeled
    'Example project' will grow to include all of the project's Operators. This allows
    the analysis of a project to find problem Operators that too many system resources.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the paths and cook times of the series of Over TOPs can be
    traced. They are all located inside of the 'project1' container, and their cook
    times range from 0.06 milliseconds to 0.6 milliseconds.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: 'A cautious side-note: Be careful of the effects of Vertical Sync and how cook
    time is perceived in the Performance Monitor. The graphics card will try to lock
    project FPS and display refresh rate. At 30 FPS, even in an empty project, the
    cook time per frame might be perceived as 33 milliseconds. The same effect can
    occur when working at 60 FPS, except that the Performance Monitor would show a
    frame cook time of 16 milliseconds. This doesn''t mean that each frame actually
    needs a full 33 ms or 16 ms to render a frame, but that Vertical Sync is trying
    to sync TouchDesigner''s FPS and the refresh rate of the displays.'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: Operator Cooking
  id: totrans-768
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*11.4 Operator Cooking*'
  id: totrans-769
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Better performance can always be achieved by decreasing the amount of Operators
    that cook every frame. Many beginners never take this into account when creating
    Networks. Admittedly, everyone has worked on prototypes with tight deadlines,
    and has had to created Networks without much foresight. However, not taking cooking
    into account can be quite hazardous if a project can't afford any dropped frames.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: The main goal is to perform static operations as early as possible in the signal
    flow, to prevent those specific from being rendered every frame.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Cooking_1.toe'. In this example, there is a simple graphic that
    rotates, and then various Operators are used to give the image a more interesting
    look. A feature that can help with optimizing Networks is the animation of the
    wires connecting Operators. Animated wires mean that the Operators on both ends
    are being cooked every frame. Starting at the far left of the Network, the wire
    between the Movie In TOP and the Transform TOP is not animated. This is because
    the image is loaded, and remains static. Operators only cook when they need to
    perform an operation or change. A still picture is static, and therefore does
    not change, and does not cook every frame.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: On the contrary, the rest of the wires in the Network are animated, meaning
    that everything after the Movie In TOP is cooking every frame. For this project,
    this isn't a dire problem, because there isn't anything extremely complex happening.
    Getting in the mind set of making efficient Networks from the start can save a
    lot of headaches come performance time. Let's take a look at this project in the
    Performance Monitor.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: '![Operator Cooking](operator-cooking-1.png)'
  id: totrans-774
  prefs: []
  type: TYPE_IMG
- en: Ignoring all the Operators needed for TouchDesigner's functionality, there is
    a small block of Operators dedicated to this example. The operations being performed
    on the image, in total, take about 0.25 milliseconds. As mentioned, static operations
    only need to cook once, and something to note is that many of the operations after
    the Transform TOP are static in nature. Let's re-arrange these and see the gains
    in performance.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Cooking_2.toe'. This project is the same as the previous, except
    the Operators have been re-arranged. Before examining the signal flow closer,
    let's take a look at the Performance Monitor.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: '![Operator Cooking 2](operator-cooking-2.png)'
  id: totrans-777
  prefs: []
  type: TYPE_IMG
- en: At first glance it appears as if the project has shrank! A few of the Operators
    that were listed previously have disappeared. This is because these Operators
    aren't cooking every frame. In the last example, the Transform TOP was performing
    a transformation every frame, forcing the TOPs after it to recalculate their operations
    every frame. In this example, all of the static operations happen at the start
    of the signal flow, leaving the Transform TOP free to perform its transformation,
    without forcing any other Operators to recalculate their operations, or cook.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: Taking a more in depth look at the Performance Monitor reading, the only Operator
    that was cooked was the Transform TOP, which took 0.061 milliseconds to cook.
    Compare this to the previous example, where the series of operations took 0.25
    milliseconds to cook. That is an unbelievable gain for such a simple change.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that side by side, the outputs of these two Operator chains
    may not be exactly identical, but they are so indistinguishable from each other
    that many clients and artists will not mind the difference, knowing that the massive
    performance gains will allow them to do so much more.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: Resolution
  id: totrans-781
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*11.5 Resolution*'
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it comes to working with 2D textures, resolution is extremely important,
    because of the almost 1:1 ratio of pixels processed compared to processing power
    used.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: An incredibly easy way to demonstrate this fact is through example. Open example
    'Resolution_1.toe'. This is a simple setup. The butterfly is composited on a bigger
    canvas, then using some LFOs, the opacity and blur are modulated before it is
    composited onto the forest background. Middle clicking on any of the TOPs will
    reveal that this example requires just over 100MB of GPU RAM. That's not a lot
    of memory on a system with 4+ GB of GPU RAM, but this can quickly add up. Try
    to composite 40 of these butterflies in real-time, and 4GB can easily be spent.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: Now contrast this to example 'Resolution_2.toe'. It creates the exact same results,
    but for only 60MB of GPU RAM. That is a significant difference. Take the above
    example of compositing 40 butterflies, and using this second method, only about
    2.4 GB of GPU RAM are needed. All of the extra headroom from a simple change in
    resolution. The source butterfly asset is only 512x512 pixels, and in the first
    example, it is immediately composited on a 1920x1080 pixel canvas that is modulated.
    This creates a scenario where TouchDesigner is constantly re-drawing all 1920x1080
    pixels every frame that the butterfly is modulated. 'Empty' pixels that have neither
    colour or alpha data are also re-drawn. In the second example, the exact same
    operations are being performed, but only on the source asset, which is a much
    lower resolution. This modulated asset is then composited on the 1920x1080 canvas.
    This saves the GPU having to re-draw a large canvas of pixels, when only a small
    section requires processing, thus saving quite a bit of GPU RAM and processing
    power.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: GPU Memory Fragmentation
  id: totrans-786
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*11.6 GPU Memory Fragmentation*'
  id: totrans-787
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Operators that use the GPU will often allocate the resources required for their
    tasks, and hold onto them until the task has been completed or changed.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: GPU Fragmentation is one of the main concerns when working working with projects
    that have many different content sources. For example, a Constant TOP with a resolution
    of 1280x720 is connected to 10 other Operators. Once connected and cooked, each
    Operator will set aside the proper amount of GPU memory required to handle the
    processing of its specific amount of pixels. Once the memory is allocated, the
    Operators can operate relatively efficiently within their allocated space.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: If the resolution of the source Constant TOP is changed, this will trigger a
    chain reaction, where all of the 10 other Operators will have to reallocate the
    correct amount of GPU resources for their tasks. If the Operator's resources are
    reallocated efficiently, many of the same memory blocks will be reused. If on
    the off-chance they can't reuse memory blocks, they'll have to relocate to the
    end of the memory. If this happens enough times in quick succession, the GPU memory
    will be fragmented, leaving the project in a state of poor performance while the
    GPU tries to defragment it's memory.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: The two diagrams below try to outline memory fragmentation in the simplest way
    possible.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two case studies, both with similar parameters: There are 3GB of
    GPU RAM and there are three 1GB static textures to load and hold in RAM indefinitely.'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory Fragmentation](memory-frag-1.png)'
  id: totrans-793
  prefs: []
  type: TYPE_IMG
- en: In Case 1, the 3GB GPU of RAM would be able to perfectly fit the three 1GB static
    textures. They are called static textures because once they've allocated to memory,
    they aren't changed. This is the equivalent to loading a large image into a Movie
    In TOP at the start of a project and leaving it there indefinitely.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: This is a perfect world situation, as there are many other processes that use
    GPU RAM, meaning resources are constantly in flux, and there would never be 3GB
    of free RAM on a graphics card that only has 3GB of GPU RAM.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 2 describes a situation where memory fragmentation will occur. To the
    already existing three 1GB textures, a 200MB texture is added to the mix. In this
    example, the loading and unloading is to happen in the following order:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: Load 1GB texture
  id: totrans-797
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load 200MB texture
  id: totrans-798
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load 1GB texture
  id: totrans-799
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unload 200MB texture
  id: totrans-800
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load 1GB texture
  id: totrans-801
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This would simulate a situation where a texture is loaded, displayed, and then
    replaced with another texture.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory Fragmentation 2](memory-frag-2.png)'
  id: totrans-803
  prefs: []
  type: TYPE_IMG
- en: In diagram 'Case 2.1', Steps 1 through 3 are completed, and there is 800MB free.
    At first glance, this might seem perfect, because if the 200MB texture is unloaded,
    there would be 1GB of free space for the final texture. Unfortunately, this isn't
    how graphics cards work.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '![Memory Fragmentation 3](memory-frag-3.png)'
  id: totrans-805
  prefs: []
  type: TYPE_IMG
- en: As seen above, in diagram 'Case 2.2', Step 4 has been completed, and the 200MB
    texture has been unloaded. What remains is a prime example of GPU memory fragmentation.
    There is a total of 1GB of free GPU memory, but there isn't a single block of
    1GB to allocate to the 1GB texture. The already-loaded 1GB textures, in their
    static state, can't be shifted in the GPU memory without a full unload and reload
    process occurring, and because the memory can't be shifted, the 200MB of free
    space has been trapped between the static textures. This 200MB allocation can
    be filled with 200MB or smaller textures, but it will not be able to load the
    third 1GB static texture.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: The best way to prevent heavy memory fragmentation is to try to and restrict
    the amount of varying resolutions in a project. When an asset is swapped out for
    one that is the same resolution, often times it can take it's place in the memory.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: Windows System Processes
  id: totrans-808
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*11.7 Windows System Processes*'
  id: totrans-809
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Windows is a complex operating system, and there are many processes and system-related
    applications running behind the scenes. Many of these processes and applications
    can negatively impact performance of a computer, and TouchDesigner.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: Windows is made for a large market of consumers, who primarily use their computers
    during the day. Because of such, there are many applications and Windows system
    operations that are scheduled to run if a computer is left powered-on overnight.
    This can be problematic for performance installations that run 24 hours a day.
    Depending on the needs of the installation or performance, many different applications
    and system related tasks can, and should, be turned off and rescheduled.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: Applications such as virus and spyware scanning softwares, albeit useful for
    daily computing, should generally be avoided when using TouchDesigner. Virus and
    spyware softwares can cause a number of issues, the first being pop-ups. Many
    of these softwares display pop-up reminders and notifications at regular intervals.
    In unfortunate situations, these can overlap with displayed content and cover
    outputs during performances and installations. These applications can negatively
    effect the hard drive as well, as they often scan the system for viruses and malware,
    using up hard drive read \& write cycles. These two issues are aside from the
    CPU toll that many of these ever-running applications can incur.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-813
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 12 GLSL
  id: totrans-814
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*12.1 Introduction*'
  id: totrans-815
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GLSL, or OpenGL Shading Language, is an incredible tool to have in one's back
    pocket. With a little bit of code, one can program directly on the GPU.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: Many avoid learning GLSL because they believe that it is only useful for working
    with large textures (4K and beyond), complex 2D generative visual scenes, or creating
    and manipulating 3D geometry, but it can be used in so many facets of day to day
    programming. Whether that be optimizing and creating incredibly effecient compositing
    workflows for standard HD content, or creating simple generative backgrounds for
    interactive experiences.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is to introduce the reader to some basic GLSL workflows
    and techniques, with the assumption that the reader has no previous GLSL experience.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: Types of Shaders and Rendering Pipeline
  id: totrans-819
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*12.2 Types of Shaders and Rendering Pipeline*'
  id: totrans-820
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The two main types of shaders that can be programmed in TouchDesigner are the
    Vertex shader and the Pixel (or Fragment) shader. In a standard rendering pipeline,
    they are processed in that order, as can be seen in the diagram below:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: '![GLSL Pipeline](pipeline.png)'
  id: totrans-822
  prefs: []
  type: TYPE_IMG
- en: There is also a geometry shader that can be applied between the Vertex and Pixel
    shaders for layered rendering and transform feedbacks, but it is not used commonly.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: In the above pipeline, the application passes the vertex and primitive data
    to the GPU. This includes information such as vertex position, texture coordinate,
    color, normal, etc. This information can be programatically processed and worked
    with by using a Vertex shader.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: When the Vertex shader has finished processing the vertex and primitive data,
    the geometry is rasterized. During this process, the geometry goes through various
    stages such as clipping, culling, transformations to window space, etc. These
    stages prepare fragments that will be processed by the Pixel shader.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: The Pixel shader takes these fragments, processes them, and outputs the color
    and depth data for each pixel.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more in-depth look at the render pipeline, there is a more thorough explanation
    on the OpenGL website:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.opengl.org/wiki/Rendering_Pipeline_Overview](http://www.opengl.org/wiki/Rendering_Pipeline_Overview)'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  id: totrans-829
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*12.3 Debugging*'
  id: totrans-830
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before getting too deep into the world of GLSL, it is important to know how
    to debug compiling issues. There are two signs that denote a compiling error.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: The first is a blue and red checker pattern. When working with the GLSL MAT,
    this check pattern will be on the geometry itself. When using GLSL with TOPs,
    this checker pattern will fill up the Operator's viewer and be output from the
    TOP.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: 'The second sign of a compile error is a yellow triangle warning flag on the
    Operator. Upon clicking and holding the left mouse button on the flag, the error
    will read:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To diagnose these issues, an Info DAT is required. Create an Info DAT, and
    set the ''Operator'' Parameter to reference the GLSL operator with the error.
    In the Info DAT, if there are no errors, there will be only a few lines and of
    them will read ''Compiled Successfully'' or ''Linked Successfully''. If there
    are errors however, they will read more like:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To quickly break this down, the first thing is the line number. In this case,
    '0(3)' means the compiler is encountering errors at line 3\. In many situations,
    this may mean that the actual mistake happens a line or two earlier, but the compiler
    doesn't halt until the next line when things stop making sense for it.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: The next section highlights that this is a syntax error, and then there is more
    information about the error.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: For beginners, the majority of these errors will be because of forgotten semi-colons
    at the end of lines, or errors trying to cast one data type into another incompatible
    data type.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: Shaders in 3D
  id: totrans-840
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*12.4 Shaders in 3D*'
  id: totrans-841
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's start by looking at a few very simple 3D scenes that utilize Vertex and
    Pixel shaders.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Basic_3D.toe'.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple render setup where the vertex shader does nothing but pass
    the vertices to the pixel shader, which then colors everything white. Let''s take
    a more in-depth at each shader, starting with the Vertex shader:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since this is written for someone with no GLSL experience, a few notes about
    basic C syntax and rules that need to be followed, since GLSL is very similar
    to C.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: The first thing is that semi-colons need to be added at the end of working lines
    of code.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: The second thing is that most of the working code will be inside of the main()
    loop. For beginners, the only things outside of the main loops will be the delcaring
    of variables such as input and output streams and attributes.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: 'When starting an empty shader, it''s good practice to start by entering the
    main() loop as follows:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this vertex shader, there is only have one line of code:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's break this down from right to left, as there is a lot going on here.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: '''P'' in this instance is the vertex position. In TouchDesigner, there are
    a few attributes that are declared by default. For instance, ''P'' is the vertex
    position, ''N'' is the normal, ''Cd'' is the color, and ''uv'' is the texture
    coordinate layers (it is an array that is accessed by index, i.e. uv[0], uv[1],
    etc). These values can be accessed as easily as we''ve accesed ''P''.'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: In the line of code, 'P' is input into a function named 'TDDeform()'. This function
    takes the vertex position from object space and returns the position in world
    space.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: Think of object space as if each object in the 3D world had it's own co-ordinate
    system and 0,0,0 point. After processing these vertices, they have to be transformed
    and integrated into world space. World space is, as the name implies, the full
    world. The world, in this case, is the common coordinate system, with one 0,0,0
    point, where all objects will exist together.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: Once the vertex positions are returned in world space, they are passed to the
    function 'TDWorldToProj()'. This function takes the world space co-ordinates and
    returns them in projection space. The projection space takes all the co-ordinates
    from the world space, and returns them from a camera's point of view.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: These values are then assigned to the variable 'gl_Position', which is a built-in
    output for the transformed vertices.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the rendering pipeline diagram, these transformed vertices are processed
    and passed to the Pixel shader, where they will be assigned color values.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the Pixel shader sets the color output of all the fragments
    to white. The code is below:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Similar to the Vertex shader, all of the code except for the output declaration
    are inside of the main() loop, and there are semi-colons at the end of lines of
    code.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from the top, there is this line of code:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This line sets the output as a variable called 'fragColor'. A 'vec4' is a vector
    with 4 components, and in this scenario, they correspond to the output red, green,
    blue, and alpha channels. In GLSL, whenever declaring an input or output, the
    type must be declared as well, thus the specification that it will be a 'vec4'.
    Similarly, inputs will be prefaced by 'in' and outputs will be prefaced by 'out'.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: 'The line of code inside of the main() loop is as follows:'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As 'fragColor' has already been declared as the output, this line writes the
    pixel values directly to the output. The section 'vec4(1,1,1,1)' creates a 4-component
    vector with the values 1,1,1,1, and then assigns it to 'fragColor'. 'vec4' has
    to precede the list of values because 'fragColor' has already been declared as
    a vec4, so to assign a value to it, that value needs to be a 'vec4'.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: Because the 4 components of the output correspond to RGBA channels, (1,1,1,1)
    would set all of the channels to 1, effectively setting the output to white for
    every pixel.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: Now with a basic understand of working with shaders in a 3D scene, let's add
    a few levels of complexity. For starters, let's resize the box. This is as simple
    as multiplying each of the vertex positions, or 'P', by a value.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Basic_3D_scaled.toe'.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: 'Only a few lines of the vertex shader are changed:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first this that is added is a declaration for a variable that is going to
    be used, named 'scaledP'. This is going to be a 3-component vector because we'll
    be working with the vertex position, 'P', which is also a 3-component vector.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the variable is defined, it can be used throughout the code. The next
    line that is added is:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This line takes the vertex position, multiplies all the values by 0.5, effectively
    making the box half the size. Similarly, a value of 2 would make the box be double
    it's original size.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: 'This new value, ''scaledP'', then replaces ''P'' below:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Similarly, to transform the box instead of scaling it, values need to be added
    or subtracted to the various axis.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Basic_3D_transform.toe'.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, The code in the vertex shader has been changed as below:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is very similar to the above example. It starts off by declaring a 3-component
    vector named 'transformedP'. In the first line of the main() loop, instead of
    multiplying the vertex positions by 0.5, the new 3-component vector is being added
    to them.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: The reason to use a 'vec3' in this example is that if 0.5 was simply added to
    'P', it would add 0.5 to the x-axis, 0.5 to the y-axis, and 0.5 to the z-axis.
    Creating a 'vec3' for these values allows control over each specific axis. In
    this example, adding 'vec3(1,0,0)' will only add 1 to the x-axis, leaving the
    y-axis and z-axis untouched. In practice, this moves the box 1 unit to the camera's
    right.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: We could just as easily change from addition to subtraction to move the box
    in the other direction.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's reference an LFO CHOP from the vertex shader to animate the movement.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Basic_3D_LFO.toe'.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: For this to be achieved, an LFO CHOP was created. The value of it's channel
    was then exported to the GLSL MAT's parameter 'value0x' in the 'Vectors 1' tab
    of the Parameter window. Then the Uniform was given a name, in this case 'lfoCHOP'.
    This means the value can now be accesed from within the vertex and pixel shaders.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in the vertex shader has been changed as follows:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first addition is in the second line, where a 'uniform' is declared. A 'uniform'
    is a global GLSL variable that is mainly used for parameters that a user or program
    will pass into the shader.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the LFO CHOP channel is a float value, so then 'float' is added
    after 'uniform'. The name of the uniform is important, because it must correspond
    to the name entered in the 'Uniform Name' parameter in the GLSL MAT. In the GLSL
    MAT, we named the uniform 'lfoCHOP', so to access it, the same name must be used.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: The only other change is that where previously 1 was being added to the x-axis
    of the vertex position, there is now the value of 'lfoCHOP'.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With those small changes, a CHOP is controlling the x-axis position of the shader.
    Pixel shaders function in much of the same way as Vertex shaders. Let's assign
    the LFO CHOP in the previous example to control the red channel of the output
    color.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Basic_3D_red.toe'.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the LFO CHOP is controlling the red channel of the pixel shader
    in much the same way that the LFO CHOP is controlling the x-axis transform.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in the Pixel shader is below:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Similarly to the x-axis transform example, the only steps needed were to declare
    the incoming uniform, and then to assign it to a parameter, in this case the first
    component of the vector. To take this another step furtuer, let's sample a Ramp
    TOP as the texture, instead of just outputting a single color.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Basic_3D_texture.toe'.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that was done was create the Ramp TOP and assign it to the GLSL
    MAT. The TOP needs to be referenced in the 'Samplers 1' tab in the Paramter window.
    In the same way that the LFO CHOP needed a 'Uniform Name', the Ramp TOP needs
    a 'Sampler Name', which in this case is 'rampTOP'.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: Then a Texture SOP is added after the Box SOP to assign the texture co-ordinates.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Vertex shader, a few lines of code are added to assign the texture co-ordinates.
    These lines are added below:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first line that is added is:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This line outputs a 2-component vector named 'texCoord0' which can be used in
    the pixel shader. In this case, they will be the texture UV co-ordinates.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more additional line:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This line takes 'texCoord0' that was declared earlier, and assigns it the built-in
    TouchDesigner variable 'uv', which as mentioned earlier is declared by default
    and contains the UV texture co-ordinates (similar to 'P' for vertex position).
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: The '.st' here is assigning the two values contained in the 2-component vector
    'uv' to the 2 components of 'texCoord0'. As mentioned earlier, where '.xyzw' are
    used for vertex positions, '.stpq' are often used for texture co-ordinates. These
    are mostly just for convention so that the same letters (such as XYZW and RGBA)
    don't mean multiple different things. You may also see '.uv' used instead of '.st',
    depending on the software package.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: With these two extra lines of code, the Box SOP is now being textured by the
    Ramp TOP.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: Shaders in 2D
  id: totrans-915
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*12.5 Shaders in 2D*'
  id: totrans-916
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if one doesn't want to spend a ton of time learning about GLSL for 3D use,
    the Pixel shader can be extremely useful as a tool for generative visuals and
    compositing 2D textures. Simple GLSL shaders can be especially useful when compositing
    textures, as it can save quite a lot of graphics memory when doing repititious
    work.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at an example of adding two TOPs together, similar to a Add
    TOP.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Basic_2D_add.toe'.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the GLSL TOP, multiple TOP inputs can be composited, sampled, and effected
    in a GLSL pixel shader. In this example, a Movie In TOP and a Constant TOP are
    input into the GLSL TOP. The GLSL code in the pixel shader, adds them together:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Working with Pixel shaders in the TOP family is very similar to working with
    them using a GLSL MAT. There is still a main() loop, the declarations happen first
    before the main() loop, and there are semi-colons at the end of working lines
    of code.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: 'The first difference to notice is how inputs are handled. In this example there
    are two inputs, and there are two lines that deal with those inputs:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To get access to a TOP input, a 4-component variable must be declared for the
    RGBA channels. The texture() function is used to sample a texture. It takes two
    arguments, the first is the texture that it is going to sample, which in these
    cases are TOP inputs. The second argument is the texture co-ordinate to sample.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: In this case, since TOP inputs are being sampled, the built-in sampler array
    named 'sTD2DInputs' is used. This array is accessed by index. In this case, there
    are two TOP inputs, so 'sTD2DInputs[0]' is used to access the first input, and
    'sTD2DInputs[1]' is used to access the second.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: To access the proper texture co-ordinate, 'vUV.st' is used. 'vUV' is a built-in
    variable that contains the texture co-ordinates of the pixel. As mentioned, '.st'
    is used to access the first two components of the vector.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the appropriate pixel is addressed from each input, this example procedes
    to add the pixels together, and output them to ''fragColor'', which is the defined
    output:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As simple as that, a main functionality of the Add TOP has been replicated.
    This may seem like a round-about way of adding two textures, but the benefits
    of something as simple as this begin to become apparent when using more complicated
    workflows or the GLSL Multi TOP, which is fundamentaly the same as the GLSL TOP,
    except that it has an infinite number of TOP inputs (limited only by the graphics
    card).
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Basic_2D_multi.toe'.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: This example expands on the previous example by adding together more sources.
    This is done by connecting all the sources into a GLSL Multi TOP, and then accesing
    them in the same way that the two inputs were accessed previously.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: In the shader of this example, each input takes the next index of 'sTD2DInputs'
    and assigns it to another 'vec4', after which they are all added together.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: Again, this might be useful, but a Composite TOP can add multiple inputs s well,
    so let's take it one step further.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Basic_2D_composite.toe'.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: This example takes the previous example a step further. With all the inputs
    defined, instead of just adding all the inputs together, the GLSL code does a
    mix of addition, subtraction, and multiplication. Remembering the order of operations
    when working like this is key!
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: This is incredibly useful when working with a large number of textures, even
    if just 1920x1080, because doing a similar process with TOPs would take multiple
    Composite TOPs, or a number of Multiply, Add, and Subtract TOPs. Being able to
    manipulate all these textures, even in such simple methods, all at once can save
    quite a bit of GPU memory.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: Transforming the textures is very similar to transforming vertices in a vertex
    shader. Let's take a look at an example.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Basic_2D_transform.toe'.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: 'This example takes the previous example, and offsets a few of the textures.
    This is done by adding, subtracting, multiplying, and dividing the texture co-ordinate.
    Let''s examine the example code below:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the above example, three of the textures are being transformed. The first
    is being scaled up by a factor of two. To do this, 'vUV.st' is multiplied by 0.5\.
    This may seem backwards, but remember that 'vUV' is the texture co-ordinates,
    so when both x-axis and y-axis co-ordinates are moved to the right, the image
    moves to the left. Imagine having a finger pointing into the center of a piece
    of paper. If the finger position is moved to the right, the image will be more
    to the left of the finger than before. This is an overtly simple example, but
    should help get the idea across.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: The third input, 'in3', has been translated on both x-axis and y-axis by subtracting
    0.5 from the x-axis, and 0.25 from the y-axis.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: The final input, 'in5', has been translated on the x-axis by adding 0.5 to the
    x-axis.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: Both of these two tranformations also follow the same thought process mentioned
    for the first transformation. For example, when adding 0.5 to the x-axis texture
    co-ordinates, they are being added to the texture co-ordinates and not the position
    of the image. Thus when the texture co-ordinates move 0.5 on the x-axis, the image
    appears to move to the left.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: The final example will be to take the previous exampleoutputs each individual
    layer to a separate color buffer instead of compositing them.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: Open example 'Basic_2D_buffers.toe'.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: 'The shader is as follows:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first line of the shader has been modified so that the output 'fragColor'
    is now an array. Each component of the array can be assigned a different texture,
    as has been done at the end of the shader. At which point, with the '# of Color
    Buffers' parameter for the GLSL Multi TOP set to 5, Render Select TOPs can be
    used to individually select each of the separate color buffers from inside of
    the GLSL Multi TOP using the. To do this, the 'Render or GLSL TOP' parameter references
    the GLSL Multi TOP, and the 'Color Buffer Index' parameter is set to the target
    color buffer.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: 'Assigning textures to the color buffers is similar to assigning textures to
    a single output, with the addition of the color buffer index:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The number in the square brackets refers to the buffer being written to. In
    the above example, the first buffer is being written to.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: Importing Shadertoy
  id: totrans-954
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*12.6 Importing Shaders from Shadertoy*'
  id: totrans-955
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Chapter by Matthew Hedlin
  id: totrans-956
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This section will demonstrate the basics of porting a shader from Shadertoy.com
    to TouchDesigner. We recommend using a feature-rich code editor, such as Sublime
    Text, Atom, or Notepad++, as there a strong Find-and-Replace function is essential.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: Shadertoy API
  id: totrans-958
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When porting a shader from Shadertoy to TouchDesigner, you can either use your
    judgement and find/make sources that work similary to the built-in inputs in Shadertoy,
    or you can download the sources that were used on Shadertoy using their API. To
    download the shader's input sources, you have to set up a Shadertoy account and
    create an 'App Key'.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: To create an ‘App Key’, once you’re logged into Shadertoy, click on `Profile`
    at the top right, then click on `your Apps` in the 'Config' section. Choose a
    name and description, and click the 'Create' button.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: You'll see the `App Key` in the 'Manage Your Apps' section. Now, copy this URL
    `https://www.shadertoy.com/api/v1/shaders/MdlGDM?key=` into your browser, and
    enter your App Key at the end.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: After you press enter, the response will be a JSON object with a key called
    `inputs`. In this example, the URL above requires the file called `tex09.jpg`.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: If you enter `https://www.shadertoy.com/presets/tex09.jpg`, as the URL in your
    browser, you will see and be able to download the required texture.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: Swizzling
  id: totrans-964
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Swizzling is the method of accessing the components of a vector. You'll come
    across this a few times in these examples.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: If there is a variable `vec4 color`, the 4 values of `color` are represented
    as `color.rgba`. If you want to access just the first 2 values of the vector you
    could use `color.rg` If you want to rearrange the values of the vector, you could
    write `color.bgar`
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: There are equivalents to .rgba that do the exact same thing, but are generally
    used in different situations to provide clarity when reading the code.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: In general, when referring to texture coordinates, `.stpq` is used. When referring
    to 3D coordinates, `.xyzw` are used.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: While these conventions do the same thing, they can not be combined. To refer
    to the four values of `vec4 a` we could use `a.xyzw`, or `a.stpq`, but we could
    not use `a.stzw` This will create an error.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  id: totrans-970
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A common error encountered when converting Shadertoy shaders is related to the
    UV extend default. If you find the results of your shader don't match the results
    on the Shadertoy website, try setting the `Input Extend Mode UV` parameter of
    the 'GLSL' TOP to `Repeat`.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: Swizzling
  id: totrans-972
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Swizzling is the method of accessing the components of a vector. You'll come
    across this a few times in these examples.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: If there is a variable `vec4 color`, the 4 values of `color` are represented
    as `color.rgba`. If you wanted to access just the first 2 values of the vector
    you would use `color.rg`. If you wanted to rearrange the values of the vector,
    you could write `color.bgar`
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: There are equivalents to .rgba that do the exact same thing, but are generally
    used in different situations to provide clarity when reading the code.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: In general, when referring to texture coordinates, `.stpq` is used. When referring
    to 3D coordinates, `.xyzw` are used.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: While these conventions do the same thing, they can not be combined. To refer
    to the four values of `vec4 a` we could use `a.xyzw`, or `a.stpq`, but we could
    not use `a.stzw`. This will create an error.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1: Waterly Video - Test'
  id: totrans-978
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![Example 1: Waterly Video - Test](ex1_1.jpeg)'
  id: totrans-979
  prefs: []
  type: TYPE_IMG
- en: 'Shader written by: [FabriceNeyret2](https://www.shadertoy.com/user/FabriceNeyret2)'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.shadertoy.com/view/MdlGDM](https://www.shadertoy.com/view/MdlGDM)'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  id: totrans-982
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Start by creating a 'GLSL' TOP and an 'Info' DAT. Put the 'GLSL' TOP's name
    in the 'Info' DATs `Operator field`.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: On the the 'GLSL' TOPs `Common` page, change the `Output Resolution` to `Custom`
    and then enter `1280` and `720` in the `Resolution` fields.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: Copy the code from Shadertoy and paste it into the `glsl1_pixel` DAT, replacing
    the code that was there by default.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to set up the sources. For this example, we're just going to create
    two 'Movie File In' TOPs and select two pictures that are the same resolution
    as the 'GLSL' TOP (1280 x 720), ‘Mettler.3.jpg’ and 'Trillium.jpg'.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: Main Function and its Parameters
  id: totrans-987
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In Shadertoy, the main function and paramters are:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: '`mainImage( out vec4 fragColor, in vec2 fragCoord )`'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: 'but we''ll change that to:'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: '`main()`'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace the fragColor argument that we removed, we''ll go up to the top
    of the code and insert:'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: '`layout(location = 0) out vec4 fragColor;`'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll search for all references to `fragCoord` and replace them with `gl_FragCoord`.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: '` uniform vec3 Resolution;'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: uniform float iGlobalTime; `
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: Uniform Inputs
  id: totrans-997
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Shadertoy contains a list of built-in uniform variables. You can view them on
    the Shadertoy website at the top of the code window by clicking an arrow labled
    'Shader Inputs', or you can click the '?' at the bottom right of the same code
    window to create a pop up window that contains 'Shadertoy Inputs' as well as other
    information. We will go through the main samplers and uniforms associated with
    Shadertoy shaders.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: Samplers
  id: totrans-999
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Shadertoy has named their sampler inputs `iChannels`.These samplers can be images,
    videos, noise patterns, cube mabs, etc. The 'GLSL' TOP has a similar variable
    called `sTD2DInputs`. The Shadertoy samplers are individual numbered samplers,
    such as `iChannel0` and `iChannel1`. In TouchDesigner, `sTD2DInputs` is an array,
    so you can access an elements with a numeric index.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: Now, search through the code and wherever there is the a reference to `iChannel0`,
    replace that with `sTD2DInputs[0]`. Where there is a reference to `iChannel1`,
    replace that with `sTD2DInputs[1]`.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: iGlobalTime
  id: totrans-1002
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To find out what type of uniform this needs to be, look at the list of ''Shader
    Inputs'' on Shadertoy mentioned previously. In the list, `iGlobalTime` is a float,
    so near the top of our code, below the `fragColor` declaration, we''ll write:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: '`uniform float iGlobalTime;`'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: Next, we click on the 'GLSL' TOP in TouchDesigner, and go to the `Vectors 1`
    page in the parameter window.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: 'As the first `Uniform Name` we''ll write `iGlobalTime` and for the value we
    will reference TouchDesigner''s `seconds` member of the `absTime` class by entering:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: '`absTime.seconds`'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: 'It should look like this:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: '![iGlobalTime : absTime.seconds](ex1_2.JPG)'
  id: totrans-1009
  prefs: []
  type: TYPE_IMG
- en: iResolution
  id: totrans-1010
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'iResolution is the resolution of the Shader on Shadertoy. If our resolution
    depended on one of our inputs, we could use TouchDesigner''s built-in array of
    objects:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: '`uTD2DInfos[i].res`'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: In this case you could add `.zw` on the end to retrieve the width and height
    in pixels, or you can add `.xy` to receive the result of 1.0 divided by the width
    and 1.0 divded by the height.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we will manually declare iResolution as a uniform. If we
    look at Shadertoy''s input list, we see that iResolution is a vec3\. Similar to
    iGlobalTime, we''ll first declare it in the code by going near the top of our
    code and writing the line:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: '`uniform vec3 iResolution;`'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: Next, go to the `Vectors 1` page of the 'GLSL' TOPs parameters, and next to
    the second `Uniform Name`, enter `iResolution`. For its values, enter `1270` and
    `720`. We won't need the 3rd value of the vec3 for this, so we'll just leave the
    other 2 values as `0`
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: 'Your GLSL TOP should now compile successfully and look something like this
    :'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: '![Example 1 compiled](ex1_3.JPG)'
  id: totrans-1018
  prefs: []
  type: TYPE_IMG
- en: 'Example 2: Shard'
  id: totrans-1019
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![Example 2: Shard](ex2_1.jpg)'
  id: totrans-1020
  prefs: []
  type: TYPE_IMG
- en: 'Shader written by: [simesgreen](https://www.shadertoy.com/user/simesgreen)'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.shadertoy.com/view/Xdf3zM](https://www.shadertoy.com/view/Xdf3zM)'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: This example will take you a bit further, using cubemaps, creating a noise sampler,
    using sound, and adding mouse interaction.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  id: totrans-1024
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We will start off with a new TouchDesigner project and begin the same way we
    did for the last example.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: Create a 'GLSL' TOP and set its `Output Resolution` to `1280` and `720`.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: Create an 'Info' DAT and add a reference to the 'GLSL' TOP to it’s `Operator`
    parameter.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: Copy the code from Shadertoy into `glsl1_pixel`.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the shader on the Shadertoy website, at the bottom we can see
    that we require 3 inputs: a noise texture, a background image, and some sound/audio.'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: Noise Texture
  id: totrans-1030
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In Shadertoy there are 4 noise textures: a monochrome and color noise at a
    resolution of 64 x 64, and a monochrome and color noise with a resolution of 256
    x 256.'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, create a ''Noise'' TOP and set the resolution to 64 x 64
    in the `Common` settings. We can look at the noise texture on Shadertoy and estimate
    the settings. These are the settings you can use for now:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: '![Ex2: Noise](ex2_2.JPG)'
  id: totrans-1033
  prefs: []
  type: TYPE_IMG
- en: Background Image
  id: totrans-1034
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you click on ''iChannel1'' in Shadertoy, you''ll see it is a texture from
    the ''Cubemaps'' section. There is a link to the source:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.pauldebevec.com/Probes](http://www.pauldebevec.com/Probes)'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: Near the bottom of that page, are cube-format images that we can download. The
    LDR .tif image that matches the one used in the Shadertoy shader is at the bottom
    right, called `Uffizi.tif`. Download that image.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: Create a 'Movie File In' TOP in TouchDesigner and reference the downloaded file.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: Connect the new 'Movie File In' TOP to a 'Cube Map' TOP.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: Set the `Input Layout` to `Vertical Cross` and connect the 'Cube Map' TOP to
    the second input of `glsl1`.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: '![Ex2: Cube Map](ex2_3.JPG)'
  id: totrans-1041
  prefs: []
  type: TYPE_IMG
- en: Audio
  id: totrans-1042
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '''iChannel2'' in Shadertoy is set to a Soundcloud input, but we can use any
    audio that we''d like, inside of TouchDesigner. For now, we''ll just stick with
    the default audio track in the ''Audio File In'' CHOP.'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: We need to prepare the audio for the 'GLSL' TOP, since we can't directly connect
    an 'Audio' CHOP to a 'GLSL' TOP. Line 35 of the GLSL code is commented out, stating
    that you can use this line of code if you don't have audio, but we won't do that.
    In the next line, the variable `d` is looking for a `texture` with the comment
    `move planes with music`. The easiest way to achieve a simple version of this
    is to convert the 'Audio File In' CHOP into a texture.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: We only want one sample for this example, so put an 'Analyze' CHOP after the
    'Audio File In' CHOP and set the `Function` to `Maximum`.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: We may want to adjust this value later, so put a 'Null' CHOP after that.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: Now create a 'CHOP To' TOP that references the 'Null' CHOP. Set the `Data Format`
    to `R`.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: Connect the 'CHOP To' TOP to the third input of the 'GLSL' TOP.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: 'The network should look like this:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: '![Ex2: Audio](ex2_4.JPG)'
  id: totrans-1050
  prefs: []
  type: TYPE_IMG
- en: Now that the inputs are set up, we can take a look at the `Info` DAT and see
    what we'll need to change in the code.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: Main Function and fragColor
  id: totrans-1052
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First we''ll change the name of the main function from `mainImage` to `main`
    and remove the parameters, so instead of:'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '`void mainImage( out vec4 fragColor, in vec2 fragCoord )`'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: 'we should just have:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: '`void main()`'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to replace the 2 parameters we removed from the main function:
    fragColor, and fragCoord. Go to the very top of the code and insert:'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: '`layout(location = 0) out vec4 fragColor;`'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: Now you can search for all references to `fragCoord` (there should only be one,
    which is in the first line of the main function) and replace it with the built
    in variable `gl_FragCoord`.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: Samplers
  id: totrans-1060
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: iChannel0
  id: totrans-1061
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Similar to the last example, iChannel0 is a 2D input, so we'll find all `iChannel0`
    references and replace them with `sTD2DInputs[0]`. In GLSL 3.30 and later, we
    don’t need to use a different `texture()` function for different texture types,
    so use Find-and-Replace to replace all `texture2D` functions to `texture`. `texture2D`
    may will still work on some drivers, but will not on many so to ensure your shader
    works on all GPUs and driver versions, you'll want to change these. As of the
    latest update to this article, the shader correctly has `texture()` calls instead
    of `texture2D()`, so no changes are needed.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: '![Ex2: texture](ex2_5.JPG)'
  id: totrans-1063
  prefs: []
  type: TYPE_IMG
- en: iChannel1
  id: totrans-1064
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Changing the code for iChannel1 is similar to the edits for iChannel0, but
    the input is a cube map. TouchDesigner sorts the types of inputs for us: 2D, 3D,
    Cube, etc, into separate arrays. If this was another 2D inputs we would use sTD2DInputs[1],
    but since it’s a cube map (the first and only in our inputs) we use `sTDCubeInputs[0]`.'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: Similarly as mentioned for `iChannel0`, if the shader had `textureCube` calls,
    they should be changed to `texture`. It doesn't have those calls anymore though,
    so no changes are needed.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: iChannel2
  id: totrans-1067
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: iChannel2 is the audio. We converted the audio information into a 2D texture
    with the 'CHOP To' TOP. The 'CHOP To' TOP is the 3rd input, but it is the 2nd
    2D input, so we'll replace all `iChannel2` references with `sTD2DInputs[1]`.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: If you save the shader and look at the 'Info' DAT, you should have fixed all
    of the errors except for 'iMouse'.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: iMouse
  id: totrans-1070
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To find out what we need in order to mimic Shadertoy''s iMouse uniform, we
    need to go back to the Shader Input list. Click the question mark at the bottom
    right of the window, and if you scroll down, you''ll find iMouse:'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: '![Ex2: iMouse Definition](ex2_8.JPG)'
  id: totrans-1072
  prefs: []
  type: TYPE_IMG
- en: '`iMouse` is a `vec4` with the 4 values defined as:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: '`xy = current pixel coords (if LMB is down). zw = click pixel`'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: For now, we'll just set up the uniform with the basics so that the shader renders
    without errors. Add `iMouse` as a `Uniform Name` to the `Vectors 1` page of the
    'GLSL' TOP parameters, and set all the values to `0`.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: '`uniform vec4 iMouse;`'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: after the other uniform declarations near the top of the code.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: 'The ''GLSL'' TOP should now be free of errors, and should look something like
    this:'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: '![Ex2: iMouse success](ex2_9.JPG)'
  id: totrans-1080
  prefs: []
  type: TYPE_IMG
- en: iMouse Functionality
  id: totrans-1081
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let''s go back to the description of what iMouse does:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: '`xy = current pixel coords (if LMB is down). zw = click pixel`'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see an example of iMouse in action in this shader:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.shadertoy.com/view/Mss3zH](https://www.shadertoy.com/view/Mss3zH).'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: So `.xy` are the coordinates of the mouse while the LMB is clicked. `.zw` are
    the coordinates of where the mouse was when it was first clicked. We'll have to
    set up a little CHOP network to re-create this data.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: We could use the 'Mouse In' CHOP, but I'd like to only have the mouse only interact
    with the shader when it's deliberate.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: Create a 'Container' COMP, set the `Width` and `Height` to the same dimensions
    as the 'GLSL' TOP, which in this case are `1280` and `720`. Set the 'GLSL' TOP
    as the `Background` of the container in the panel settings. Now make a 'Panel'
    CHOP and set a reference to your container as the `Component` parameter.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll want to select 3 values from the ''Panel'' CHOP: `u`, `v`, and `lselect`.
    To do this, add 3 ''Select'' CHOPs and connect `panel1` to each one of them in
    parallel.'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: In 'select1', under `Channel Names`, enter `u`. We'll rename right away, so
    in the `Rename From` field enter `u` and in the `Rename To` field enter `x`. In
    `select2`, select the `v` channel, and just like before, rename from `v` to `y`.
    For `select3`, we don't need to rename anything, so just enter `lselect` in the
    `Channel Names` field.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to convert these values from 0 - 1 values to the full resolution.
    Add a 'Math' CHOP after `select1` and set the `Multiply` parameter to `1280`.
    Add a `Math` CHOP after `select2` and set the `Multiply` parameter to `720`.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a ''Merge'' CHOP and connect `math1` and `math2` to it. As always,
    add a ''Null'' CHOP after that. So far, it should look like this:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: '![Ex2: iMouse Network](ex2_10.JPG)'
  id: totrans-1093
  prefs: []
  type: TYPE_IMG
- en: Now we have our '.xy' values, so now we need to set up the '.zw' values. We
    need to read the position of the mouse when the LMB is first clicked, and hold
    that value until LMB is released.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, create a ''Chop Execute'' DAT and set the `CHOP` field to `select3`.
    Turn the `Off to On` and `On to Off` toggles `on`, and set the `Value Change`
    toggle to `off`. Add a ''Constant'' CHOP to the network and in the first two `Name`
    fields, create the channels `z` and `w`. This should look like this:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: '![Ex2: iMouse Constant CHOP](ex2_11.JPG)'
  id: totrans-1096
  prefs: []
  type: TYPE_IMG
- en: When the LMB is clicked, we want to write the values of `null2` to the`z` and
    `w` channels of `constant1`, and when it's released, we want to set them back
    to `0`.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code snippet to the ''offToOn'' function:'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And add the following code to the ''onToOff'' function:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can use another 'Merge' CHOP to merge `constant1` with `null2` and add another
    'Null' CHOP after it. Go back to the 'GLSL' TOP and in the four `Value` fields
    of the `iMouse` uniform, you can reference the `x`, `y`, `z`, and `w` channels
    of `null3`. You can do this with Python references or exports.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: 'The ''Vectors 1'' page should now look like this:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: '![Ex2: Final iMouse Network](ex2_12.JPG)'
  id: totrans-1104
  prefs: []
  type: TYPE_IMG
- en: If you view the container, you should now be able to click and drag to rotate
    around the Shard!
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 3: Cyclic Cellular Automaton'
  id: totrans-1106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '![Ex2: Example 3: Cyclic Cellular Automaton](ex3_1.jpg)'
  id: totrans-1107
  prefs: []
  type: TYPE_IMG
- en: 'shader written by: [zolozulman](https://www.shadertoy.com/user/zolozulman)'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.shadertoy.com/view/4tV3Wd](https://www.shadertoy.com/view/4tV3Wd)'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: Shadertoy has implemented the use of multiple buffers, separating functions
    into separate processes. This example demonstrates one way of importing these
    multi-pass shaders.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  id: totrans-1111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Connect the Buffers
  id: totrans-1112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: On the Shadertoy website, the previous examples only had one tab that contained
    code called 'Image'. This example has an 'Image' tab as well as a 'Buf A' tab.
    This means we'll have to use 2 different 'GLSL' TOPs to represent each of the
    shader functions or `buffers`.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating those, and setting both TOPs to have the resolution 1280 by
    720\. Set up an 'Info' DAT for each. Rename the 'GLSL' TOPs to match each buffer
    so we can keep track of which one is which.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: Now we can copy the code from each of the buffers and paste it into the corresponding
    `GLSL` pixel shaders.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: 'It should look like this:'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: '![Ex2: Example 3: GLSL TOP per buffer](ex3_2.JPG)'
  id: totrans-1117
  prefs: []
  type: TYPE_IMG
- en: Noise and Feedback TOP
  id: totrans-1118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '''iChannel0'' for ''Image'' is ''Buf A''. This means we can connect the output
    of our `Buf_A` ''GLSL'' TOP, to the first input of our `Image` ''GLSL'' TOP. If
    we click on the Shadertoy tab for ''Buf A'' we can see that `iChannel0` is a feedback
    of itself, `Buffer A`. Before we create that feedback loop, let’s work with `iChannel1`.
    ''iChannel1'' is a noise texture, so we can create a ''Noise'' TOP with the same
    settings as the previous example and connect it to second input of the `Buf_A`
    ''GLSL'' TOP.'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: For the feedback loop, we can't connect the output of a top to the input of
    itself without creating a cook dependancy loop. Add a 'Feedback' TOP in the network.
    The 'Feedback' TOP needs an input so we can connect the 'Noise' TOP to the input,
    set the 'Target TOP' parameter to `Buf_A`, then connect the output to the first
    input of the `Buf_A` 'GLSL' TOP.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: 'Our network should look like this:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: '![Ex2: Example 3: Noise and Feedback](ex3_3.JPG)'
  id: totrans-1122
  prefs: []
  type: TYPE_IMG
- en: Main Function and fragColor
  id: totrans-1123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We''ll go through the same process as the previous examples: changing `mainImage`
    to `main`, removing the parameters inside the `()`, and declaring at the beginning:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: '`layout(location = 0) out vec4 fragColor;`'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: Next, go through both shaders and change all `fragCoord` references to `gl_FragCoord`.
    If we look at the 'Info' DATs, we can see an error about data types. That's because
    the main function call asked for 'vec2 fragCoord' but the built in 'gl_FragCoord'
    is a vec4.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to go through the main function, and wherever we find `gl_FragCoord`
    variable without the `.x` or `.y` after it, we have to add `.xy`. (If you change
    it in the main function, it will be vec2's that are passed to the other functions,
    which is what we want). Remember, if the code is referencing 'gl_FragCoord.x'
    or 'gl_FragCoord.y' then we don't need to change it, since the `.x` and `.y` are
    selecting the float value from inside the vector already.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: 'This example only has 1 instance in each main function that needs to be changed.
    The main function for ''Buf_A'' should look like this:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'and the main function for `Image` should look like this:'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now we can go back up to the `Info` DAT and see what else needs to be changed.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: iResolution, iGlobalTime, iMouse, and iFrame
  id: totrans-1133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Both `Buf_A` and `Image` require the declaration of `iResolution` and `iGlobalTime`,
    which we've done before, so we'll go ahead and add these to both. We need ` uniform
    vec3 Resolution;
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: uniform float iGlobalTime; `
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: at the top of both pixel shaders, and we'll need to add both uniforms to the
    'Vectors 1' page of the 'GLSL' TOP’s parameters.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the `Info` DAT for `Buf_A`, we see a new undefined variable:
    ''iFrame''. This uniform is a frame counter and we can either reference `absTime.frame`
    or `me.time.frame`, depending on whether want the frame counter to loop with the
    timeline or not. For this example, we use `absTime.frame` as the expression for
    the first value of the uniform, because we don’t want the looping of timeline
    to effect the shader.'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can copy and paste the same network we created for iMouse in the previous
    example, and declare the uniform in the exact same way.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: iChannels
  id: totrans-1139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The only thing left to convert, is changing any references of `iChannel0` to
    `sTD2DInputs[0]` and `iChannel1` to `sTD2DInputs[1]`. You can do this for both
    pixel shaders.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of your ''GLSL'' TOPs should be working now, and your network might look
    something like this: ![Ex2: Example 3: Noise and Feedback](ex3_4.JPG)'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: GPU Particle Systems
  id: totrans-1142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*12.7 GPU Particle Systems*'
  id: totrans-1143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*12.7.1 Introduction*'
  id: totrans-1144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This tutorial will be focused on creating a GPU based particle system using
    TouchDesigner and GLSL shaders. This has many benefits compared to using the built-in
    Particle SOP, because all the computations inside of GLSL shader are performed
    on the GPU. GLSL shaders allow for the creation of particles systems with extremely
    large particle counts (in the multi-millions and more), with customized behaviour,
    that still compute quickly.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: The process to achieve a particle system in GLSL can be slightly confusing at
    first, compared to just creating a Particle SOP, but once you understand the basic
    principles behind the workflow, you will have infinite freedom to experiment.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: One concept to understand is that the GLSL material shader we'll be using cannot
    create new points out of thin air, so you have to feed it a set a starting points
    that correspond to the maximum number of particles in your system. The amount
    of points feeding in determine the number of times our material shader will compute
    and the shader code we write will be applied to every single particle individually.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: A second important concept to remember is that similar to any other type of
    shader, your code has no reference to anything other than the current point it
    is processing. The shader will not have a reference of the previous or next frame,
    and wont have any reference to any points that have been computed on that same
    frame. All the shader code will need to be standalone and any referential data
    will need to be fed to the shader as either a texture or value uniform. A uniform
    is a parameter or value that you will pass to your shader code. This is important
    because the particles in a particle systems need to know their previous position
    at last compute, so that they can then re-apply their code to compute their new
    position on the next frame. In other OpenGL applications, you'd create multiple
    texture buffers that you would ping-pong between reading and writing. In TouchDesigner,
    this be solved by using a simple feedback loop.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: To achieve the goal of creating a fully-functioning GPU particle system, we
    will break the particle system into a number of incremental projects.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: '*12.7.2 Moving Particles with Textures*'
  id: totrans-1150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before getting started, this is an outline of the steps to this section:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: Create a set of points that will be your initial positions
  id: totrans-1152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a point index to each point
  id: totrans-1153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a Noise TOP to create 1000 RGBA channels to use as point positions
  id: totrans-1154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a GLSL TOP to scale the values of the Noise TOP (will be built upon later
    after we remove the noise)
  id: totrans-1155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a basic render setup
  id: totrans-1156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a GLSL Mat that will hold all of the shader code for the particles
  id: totrans-1157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a basic pixel shader to shade all pixels white
  id: totrans-1158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a vertex shader with uniform inputs and correct outputs
  id: totrans-1159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the pointIndex, point position texture, and then the points per instance
  id: totrans-1160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sample the Noise TOP texture and create UV co-ordinates
  id: totrans-1161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the incoming points from using all the above steps
  id: totrans-1162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing we need to do is create a set of points that will be used by
    the GLSL MAT as the particles. As mentioned earlier, a GLSL MAT cannot create
    particles on its own. It is simply a bit of code that gets applied onto every
    point that is given to it. For the particle system this means that we need a piece
    of geometry with 1000 points to have a particle system with 1000 points. Similarly
    if we wanted a particle system with 1,000,000 points, we would need a piece of
    geometry with 1,000,000 points. To start simply, we're going to generate 1000
    points at the origin 0,0,0.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: You can follow along with the explanation below by opening example '01_Moving_particles_with_textures.toe'.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating an 'Add SOP' and clicking the first checkbox in the parameter
    window to enable 'Point 0'. The default values of 'Point 0' will work for this
    example. This creates our first point. Connect the output of the 'Add SOP' to
    the first input of a 'Copy SOP'. The 'Copy SOP' is used to copy the first point
    created by the 'Add SOP', giving us more points for our particle system. Do this
    by changing the 'Number of Copies' parameter of the 'Copy SOP' to 1000\. Now we
    have 1000 points to create a 1000 point particle system.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: Connect the ouput of the 'Copy SOP' to the first input of another 'Add SOP'.
    This 'Add SOP' will be used to close the points and create a polygon. This is
    to create a polygon from our 1000 points that can be converted into particles
    before entering the shader. To do this, in the new 'Add SOP' (which should be
    named 'add2' if you're using the default operator names) go to the 'Polygons'
    tab in the parameter window, and add an asterix ('*') to the first parameter named
    'Polygon'. Now we'll convert this 1000 point poygon into particles. Do this by
    connecting the output of the second 'Add SOP' ('add2') to a 'Convert SOP'. In
    the new 'Convert SOP', change the parameter named 'Convert To' to have the value
    of 'Particles' and change the parameter named 'Particle Type' to 'Render as Point
    Sprites'. Creating point sprites allows us to use a single line of shader code
    to increase the particle size later.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step before creating out material is to create an additional custom
    attribute using the point indices. To do this, connect the output of the ''Convert
    SOP'' to a ''Point SOP''. Set the first ''Custom Attrib'' name to ''pointIndex''.
    Select ''float'' as the data type from the dropdown to the right of the name field.
    Expand the ''Value'' field, and in the first parameter field named ''custom1val1'',
    enter the Python script:'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-1168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'What this does is create a custom attribute on each point that we can use in
    the GLSL code. In this case, we''ve taken the point index of each point, and assigned
    it to a float value named ''pointIndex''. Now we''ve finished the first two steps,
    and we have 1000 particles that we will feed into the GLSL MAT. This should look
    like this (Note: You will not see anything in your SOP viewers at this stage unless
    you activate different display options to make points visible!):'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: '![](step1_2.PNG)'
  id: totrans-1170
  prefs: []
  type: TYPE_IMG
- en: 'The next thing we''re going to do is create some noise that we will use as
    our point positions. The first thing to do is create a ''Noise TOP''. In the ''Common''
    parameters, change the resolution to 1000 pixels by 1 pixels and the ''Pixel Format''
    to ''32-bit float (RGBA)''. This gives us one pixel of noise for every particle
    we have (1000 pixels of noise for 1000 particles). Changing the ''Pixel Format''
    to ''32-bit float (RGBA)'' means that every pixel will have 32-bits per color
    channel, meaning a lot more precise data can be held in each color channel. The
    next step is to set the ''Monochrome'' parameter to ''off''. This returns a different
    noise value for each of the color channels, which will be translated into different
    noise values for our X,Y,Z positions of the particles. You can then choose to
    animate the noise however you like for the example, but the easiest is the add
    the following code to the ''Translate'' parameter''s ''tx'' value:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will transform the noise along the X axis, which will create a ribbon-effect
    on the initial particle system. Next we''re going to create a ''GLSL TOP'' that
    will allow us to have more fine tuned control over the current noise values in
    each color channel. We''ll be able to scale those values, and then in further
    sections, expand on the same shader to add more functionality. Connect the output
    of the ''Noise TOP'' to the first input of a ''GLSL TOP''. The ''GLSL TOP'' is
    created by default with a ''Text DAT'' docked to it, with a default shader that
    outputs the color white. Edit the ''Text DAT'', erase the existing code, add the
    code below, and then save it:'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-1174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We'll quickly review the code above, but please refer to previous sections in
    this chapter. We first setup the main output 'fragColor'. We then sample the texture
    at the current UV. Because we setup the 'Noise TOP' to have the same number of
    pixels as there are particles, we can then sample the pixels on a one to one basis
    for each particle. After we sample the current pixel, we scale the R and G channels
    (the X and Y of the vec4) by 5.0 and then translate them 2.5 units to the left
    and down of the camera. We then we scale the B channel (the Z of the vec4) by
    -5.0, and then translate it 20 units away from the camera to fit the whole particle
    system in the scene. We can leave the alpha channel at 1.0 as we currently wont
    be using it.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: After the scaling and translating, the 'outPosition' is assigned to the 'fragColor'
    output. If you'd like to see the positions that the particles will be receiving,
    you can connect the 'GLSL TOP' to a 'TOP to CHOP' operator and view each color
    channels values. This finishes step 3 and 4 of the item list.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: '![Particle](step3_4.PNG)'
  id: totrans-1177
  prefs: []
  type: TYPE_IMG
- en: Now create a basic render setup by adding a 'Camera COMP', a 'Light COMP', a
    'Geometry COMP', and a 'Render TOP'. They can all be set to their default values
    for this exercise. Make sure to add an 'In SOP' to the 'Geometry COMP' so that
    you can input your set of points and turn on the render and display flags on the
    'In SOP' inside of the 'Geometry COMP'. That will complete step 5.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: '![Particle 2](step5.PNG)'
  id: totrans-1179
  prefs: []
  type: TYPE_IMG
- en: Next, create a 'GLSL MAT' operator, an 'Info DAT', and two 'Text DAT''s. Reference
    the 'GLSL MAT' in the 'Info DAT''s 'Operator' parameter to help debug any errors.
    Name one of the 'Text DAT''s 'vertex' and the other 'pixel'. These will be the
    GLSL vertex and pixel shaders. Reference 'vertex' in the 'GLSL MAT''s 'Vertex
    Shader' parameter, and reference 'pixel' in the 'GLSL MAT''s 'Pixel Shader' parameter.
    Then we need to reference the 'GLSL TOP' we created. To do so, on the 'Samplers
    1' parameter page of the 'GLSL MAT', add 'sPointPosition' to the first 'Sampler
    Name' parameter, and add the name of the noise texture to the first 'TOP' parameter.
    In the example file, a 'Null TOP' named 'null1' was added after the 'GLSL TOP',
    and that is the operator name that is referenced in the 'TOP' parameter. Be very
    careful with the 'Sampler Name' parameter, as this will the name used in the code
    and if it is different than the code, you won't see any outputs as you won't be
    able to reference the particle position. Finally, on the 'Vectors 1' page of the
    'GLSL MAT', add 'uPointsPerInstance' to the first 'Uniform Name', and enter '1.0
    / 1000' as the first value of the parameter 'value0x'. This last vector will be
    used in the shader to scale the point index from 0-1000 to the normalized 0.0
    to 1.0 UV co-ordinate when sampling the point position noise texture. With that
    setup complete, we can move from step 6 to step 7.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: '![](step6.PNG)'
  id: totrans-1181
  prefs: []
  type: TYPE_IMG
- en: 'From here, we will finish all the remaining steps in the GLSL shaders. First,
    edit ''pixel'', the ''Text DAT'' we will use to hold the pixel shader, and enter
    the follow:'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is a very basic pixel shader as we've seen earlier in the chapter, and
    all it does is shade any incoming pixels white. This completes step 7.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit ''vertex'', the ''Text DAT'' we will use to hold the vertex shader and
    enter the following:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-1186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Once you enter and save that code, you will see the particle system creating
    a ribbon-effect using the generated noise. Let's go through this vertex shader.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: 'The first 4 lines setup the noise texture as a ''uniform sampler2D'', the ''uPointsPerInstance''
    value as a ''uniform float'', and the incoming point index attribute as an incoming
    float:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The next few lines in the code create the UV to use when sampling the noise
    texture. To create the X location of the UV, we first take the incoming point
    index and multiply it by 'uPointsPerInstance', which is 1 / 1000\. This gives
    us the location to sample from the 0.0 to 1.0 range. A key thing to remember when
    creating UV's manually is that the UV co-ordinates have infinite precision, so
    a UV of 0 along the X axis isn't the first pixel, it is the left edge of the first
    pixel, which will cause visual errors as the shader will then interpolate 50\%
    of the first pixel and 50\% of whatever is to the left of the first pixel (depending
    on the repeat parameters set). Because of this, we need to offset our sample by
    half of the sample step 'uPointsPerInstance', which is why we add the result of
    'uPointsPerInstance' multiplied by 0.5 to the location we calculated by multiplying
    'pointIndex' and 'uPointsPerInstance'.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap that:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: We need to convert the point index from 0 - 1000 to the UV co-ordinates 0.0
    to 1.0
  id: totrans-1192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do that by multiplying the point index by the result of 1 / 1000, which gives
    us our sample step along the 0.0 to 1.0 range
  id: totrans-1193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then add half of 'uPointsPerInstance' value (which is half of a single sample
    step) to offset our sampling so that we are samlping the middle of each pixel
    and not the left most edge
  id: totrans-1194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, because we know the texture is only 1 pixel tall, we can set 'uv.y'
    to 0.5 (again, because we don't want to sample the edge of the pixel, we want
    to sample the midle of it).
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The next thing to do is use the UV co-ordinates to sample the noise texture:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Before we finish assigning the new point position, we use this handy piece of
    GLSL code to quickly adjust the size of the particles. We're able to do this because
    earlier, we used the 'Convert SOP' to set the particle types to sprites (as this
    code only works with sprites).
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Finally, the code below takes our 'newPosition' values from object space, uses
    'TDDeform()' to move them to world space. It then multiplies the position by 'uTDMat.cam'
    to move the point into camera space. And finally, 'TDCamToProj()' is used to convert
    the camera space point to screen space points, which are assigned to 'gl_Position',
    which is the built-in output for each points position.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: With that, we've finished the first goal, which was to move particles with textures.
    Although this may not seem like a traditional particle system, these steps lay
    the foundation for the next implementations.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: '![Particles final](final_step.PNG)'
  id: totrans-1204
  prefs: []
  type: TYPE_IMG
- en: 12.7.3 Using Source Geometry
  id: totrans-1205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have a basic grasp on moving particles using textures, we can add
    in a piece of geometry and use its positions as starting positions for our particle
    system. In this exercise, we''ll replace our ''Add SOP'' with a ''Grid SOP'' (with
    the same point count) and add some noise to each particle position. These are
    the steps we will follow:'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: Create a texture from the point position data of 'Grid SOP'
  id: totrans-1207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use this texture to position our particles in the point positions of the 'Grid
    SOP'
  id: totrans-1208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the previous noise texture on the new positions to create an effected
    grid
  id: totrans-1209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is best to read this text while examing the example project '02_Source_geometry.toe',
    because I will refer to certain operators by their names in the example project.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create a texture from the point position data of the 'Grid
    SOP'. The source of point positions in the first example was an 'Add SOP', a 'Copy
    SOP', and another 'Add SOP'. Start by removing these and replacing them with a
    'Grid SOP' with the 'Rows' parameter set to 100 and the 'Columns' parameter set
    to 10\. This combination of rows and columns will create a grid with the same
    number of points as our previous example.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to get all the point positions from the 'Grid SOP' using a
    'SOP to CHOP'. Create a 'SOP to CHOP' and set the 'SOP' parameter to the name
    of the 'Grid SOP' which in this case is 'grid1'.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: This creates a CHOP with all the point positions as separate channels. We can
    translate these XYZ channels into RGB channels of a texture by using the 'CHOP
    to TOP'. Create a 'CHOP to TOP' and set the 'CHOP' parameter to the name of the
    'SOP to CHOP', which in this example is 'sopto1'. Make sure the set the 'Pixel
    Format' to '32-bit float (RGBA)' in the 'Common' settings of the 'CHOP to TOP',
    as we will be feeding this into the GLSL shader and want it to continue outputting
    a 32-bit texture. Connect the output of the 'CHOP to TOP' to the second input
    of 'glsl2', the 'GLSL TOP' we were using in the last example to scale the noise
    values.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: This complete the first step of the example.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: '![](step1.PNG)'
  id: totrans-1215
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a texture, let''s make a few additions to our shader. Below
    is our final shader from the previous example:'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-1217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We''ll start by adding a line to sample the new texture with the ''Grid SOP''
    position data. Insert this line after line 7 (we will review the full code at
    the end):'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-1219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This creates a new 4-part vector with our XYZ data that is connected to the
    second input (remember the inputs are indexed starting at 0). If you''d like to
    visualize this very quickly, change the last line temporarily to:'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This will move all of the particles to the static points on the ''Grid SOP''.
    Before continuing, make sure the change the final line back to:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now we''re going to focus on this line:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Previously, we were taking the noise values, scaling them to make them interesting,
    then offsetting them to sit nicely in the camera''s view. Our goal now is to take
    the incoming grid positions, and effect them with the noise. To do so, we can
    use a line like this:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Inside each part of the ''vec4'', we''re taking the ''Grid SOP'' XYZ and adding
    to it the XYZ of the noise texture. The only extra thing we''ve added here, is
    that before adding the X and Y values of the noise, we''re scaling them down,
    as it makes it a bit easier to see the ''Grid SOP'' shape in the render. The full
    shader code should look like this:'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-1229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Once you save, you should the columns of the grid being effected by the noise
    texture.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: '![](step2_3.PNG)'
  id: totrans-1231
  prefs: []
  type: TYPE_IMG
- en: Feel free to experiment by replacing the 'Grid SOP' with another geometry with
    1000 points.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: 12.7.4 Adding Velocity
  id: totrans-1233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we''re going to remove the random noise that is driving the
    particles and add a constant velocity. We won''t spend much time going into depth
    on some of the physics concepts, if they''re new to you, we recommend either:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: '[Nature of Code](http://natureofcode.com/) which is a great Processing book
    about modeling natural forces'
  id: totrans-1235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Khan Academy](https://www.khanacademy.org/science/physics) for learning the
    physics concepts on their own'
  id: totrans-1236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're going to make some simple UI controls that will allow us to add a constant
    velocity in XYZ space to all the particles. How the particles are controlled is
    important because data from the last frame is added to the current frame to find
    the new positions. Think about a particle traveling over a few frames. For every
    frame the particle needs to know where it was the last frame so it can add the
    velocity and calculate it's new position. In the previous examples, the noise
    only ever had the current frame worth of data.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: The main element we're going to add in this example is a feedback loop so that
    we can continuously feed in the last frame's data, update the texture with new
    positions, then feed it back as the input.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: You can follow along with example `01_adding_velocity.toe` in the folder `TouchDesigner
    Example Files/12.7.4`.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by deleting the ''Noise TOP'' and unplugging the `chopto1` from the ''GLSL
    TOP''. Follow these steps:'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: Create a 'Feedback TOP'
  id: totrans-1241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the output of `chopto1` to the input of the 'Feedback TOP'
  id: totrans-1242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the output of the 'Feedback TOP' to the first input of the 'GLSL TOP'
  id: totrans-1243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the 'Target TOP' parameter of the 'Feedback TOP' to the name of the 'GLSL
    TOP', in the example project this is `glsl2`
  id: totrans-1244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should look like the image below:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: '![](step11.PNG)'
  id: totrans-1246
  prefs: []
  type: TYPE_IMG
- en: Now let's create a new uniform on the 'Vectors 1' page of the 'GLSL TOP' parameters.
    Name it it `uVel` and leave the values at 0.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: You can see the final shader if you skip down a little bit, but here are the
    individual changes explained.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a line to get our new uniform value at the start of the shader:'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We're going to change the name of our vec4 output from `fragColor` to `oPosition`,
    which is a short name for 'output position'.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, instead of sampling noise positions and grid positions, we''re going
    to sample the new input positions that are fed back to the shader from the ''Feedback
    TOP'':'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-1253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We will add our new velocity value to the previous point position:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And finally, output the new point position:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The final shader for this example will look like this:'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-1259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The final elements that we need are an interface to change the `uVel` uniform
    parameter, and a button to reset the particles by resetting the feedback.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: In the example, we created a 2D slider for the XY velocity of the particles
    and a slider for the Z velocity. You can experiment with other kinds of sliders
    and buttons, as long as you reference the channel values in the first three values
    of the `uVel` uniform on the 'Vectors 1' page of the 'GLSL TOP' parameters.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: The script you'll add to your reset button will vary depending on the type of
    interface you create, but there will be one line that should always be at the
    end of it. This line will pulse the 'Reset' parameter of the 'Feedback TOP', which
    will then clear the feedback and pass through the original point positions of
    the grid again. In the example reset script, the UI elements are all reset to
    a 0 position, and then the 'Feedback TOP' is reset.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: 12.7.5 Random Velocity
  id: totrans-1263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we have the most basic particle system imaginable: a system where all the
    particles move with the same constant velocity. In this section we''re going to
    give each of the points their own random velocity instead of controlling them
    with UI elements. This will create the effect of a particle explosion from the
    ''Grid SOP''.'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: Start by removing the `uVel` uniform from the 'GLSL TOP' and clearing the parameters
    that reference our UI elements. Your `Vectors 1` parameter page of the 'GLSL TOP'
    should be clear.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: Next, delete the sliders/UI elements created to control the particle velocity
    *but do not delete the reset button*. We will continue to use the reset button
    in this example.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on what kind of elements you had created to control the particles,
    we''ll need to remove any of the Python code associated with them from the ''Panel
    Execute DAT'' connected to the reset button. Inside the `def offToOn` callback
    you should only have a line that resets the ''Feedback TOP'':'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-1268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The final element we need in the network is a 'Noise TOP' with a resolution
    of 1000 pixels by 1 pixel, to match the resolution of our 'CHOP to TOP'. Set the
    'Noise TOP' type to `Random (GPU)`. Turn of the `Monochrome` toggle. Set the `Amplitude`
    to 0.5, and set the `Offset` to 0.5\. Changing these two parameters is an easy
    way to move the noise values from the range of 0 and 1 with a floor of 0 to a
    range of 0 and 1 with a 0.5 center.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: 'To visualize this, it is a move from this kind of noise:'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: '![](noise1.PNG)'
  id: totrans-1271
  prefs: []
  type: TYPE_IMG
- en: 'To this kind of noise:'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: '![](noise2.PNG)'
  id: totrans-1273
  prefs: []
  type: TYPE_IMG
- en: With these parameters set, plug the 'Noise TOP' into the second input of the
    'GLSL TOP'.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: 'Your network should now look like this:'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: '![](network.PNG)'
  id: totrans-1276
  prefs: []
  type: TYPE_IMG
- en: In our shader, we only have to make a few changes.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: 'After the line where we sample the input positions from the grid, we''ll add
    a line that samples our noise texture and creates a new vec4 named `velocity`:'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-1279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This should look very familiar by now. The `* 2 - 1` at the end is some simple
    math that changes the noise range of 0 and 1 to a range of -1 and 1.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in the next line of code, instead of adding the `uVel` uniform, we''ll
    add the new `velocity` vector:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-1282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now you can click your reset button and watch the particle system explode away
    from the 'Grid SOP' points. Experiment with the 'Noise TOP' settings and the ranging
    math in the shader to see how you can create different results.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: What Next?
  id: totrans-1284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*12.7 What Next?*'
  id: totrans-1285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter should have helped unravel a bit of the introductory mysteries
    of GLSL without getting unnecessarily technical.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''d like to continue learning GLSL to experiment with more complex 3D
    scenes and material shaders, or with more complex 2D compositing tools and generative
    textures, below are some resources:'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenGL Main reference page: [http://www.opengl.org/wiki/Main_Page](http://www.opengl.org/wiki/Main_Page)'
  id: totrans-1288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'OpenGL General information: [http://www.opengl.org/wiki/General_OpenGL](http://www.opengl.org/wiki/General_OpenGL)'
  id: totrans-1289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Derivative Wiki: [http://www.derivative.ca/wiki088/index.php?title=Glsl](http://www.derivative.ca/wiki088/index.php?title=Glsl)'
  id: totrans-1290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Shader Toy: [https://www.shadertoy.com/](https://www.shadertoy.com/)'
  id: totrans-1291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
