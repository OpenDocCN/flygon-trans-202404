- en: Swapping type-safety for high performance using compiler directives
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swapping type-safety for high performance using compiler directives
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*TL;DR; An experiment: you can use lots of domain modelling types at development
    time and swap them out for a more performant implementation later using compiler
    directives.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Domain Modelling vs. Performance
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I am a big fan of using [types for domain modelling](http://fsharpforfunandprofit.com/ddd/)
    -- lots and lots and *lots* of types!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: These types act both as documentation and as a compile time constraint to ensure
    that only valid data is used.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if I have two types `CustomerId` and `OrderId`, I can represent
    them as separate types:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: and by doing this, I guarantee that I can't use an `OrderId` where I need an
    `CustomerId`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that adding a layer of indirection like this can affect performance:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: the extra indirection can cause data access to be much slower.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the wrapper class needs extra memory, creating memory pressure.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: this in turn triggers the garbage collector more often, which can often be the
    cause of performance problems in managed code.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, I don't generally worry about micro-performance like this at design-time.
    Many many things will have a *much* bigger impact on performance, including any
    kind of I/O, and the algorithms you choose.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: As a result, I am very much *against* doing micro-benchmarks out of context.
    You should always profile a real app in a real context, rather than worrying too
    much over things that might not be important.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, I am now going to do some micro-benchmarks!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Micro-benchmarking a wrapper type
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s see how a wrapper type fares when used in large numbers. Let''s say
    we want to:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: create ten million customer ids
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: then, map over them twice
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: then, filter them
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Admittedly, it's a bit silly adding 1 to a customer id -- we'll look at a better
    example later.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, here''s the code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*The code sample above is [available on GitHub](https://gist.github.com/swlaschin/348b6b9e64d4b150cf86#file-typesafe-performance-with-compiler-directives-1-fsx)*.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '*(Again, let me stress that this is a terrible way to profile code!)*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical timed result looks like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That is, it takes about 0.3 seconds to do those steps, and it creates quite
    a bit of garbage, triggering four gen1 collections. If you are not sure what "gen0",
    "gen1", and "gen2" mean, then [this is a good place to start](https://msdn.microsoft.com/en-us/library/ms973837.aspx).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '*DISCLAIMER: I''m going to be doing all my benchmarking in F# interactive.
    Compiled code with optimizations might have a completely different performance
    profile. Past performance is no guarantee of future results. Draw conclusions
    at your own risk. Etc., etc.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'If we increase the array size to 10 million, we get a more than 10x slower
    result:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That is, it takes about 3.5 seconds to do those steps, and it creates *a lot*
    of garbage, including a few gen2 GC's, which are really bad. In fact, you might
    even get an "out of memory" exception, in which case, you'll have to restart F#
    Interactive!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'So what are the alternatives to using a wrapper? There are two common approaches:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Using type aliases
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using units of measure
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with type aliases.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Using type aliases
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the type alias approach, I would simply dispense with the wrapper, but keep
    the type around as documentation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If I want to use the type as documentation, I must then annotate the functions
    appropriately.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the `add1ToCustomerId` below both the parameter and the return
    value have been annotated so that it has the type `CustomerId -> CustomerId` rather
    than `int -> int`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Micro-benchmarking a type alias
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create another micro-benchmark:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*The code sample above is [available on GitHub](https://gist.github.com/swlaschin/348b6b9e64d4b150cf86#file-typesafe-performance-with-compiler-directives-2-fsx)*.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The results are spectacularly better!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It takes about 17 milliseconds to do those steps, and more importantly, very
    little garbage was generated.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'If we increase the array size to 10 million, we get a 10x slower result, but
    still no garbage:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Compared with the earlier version at over three seconds, that's excellent.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Problems with type aliases
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alas, the problem with type aliases is that we have completely lost type safety
    now!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, here''s some code that creates a `CustomerId` and an `OrderId`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And sadly, the two ids compare equal, and we can pass an `OrderId` to function
    expecting a `CustomerId` without any complaint from the compiler.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Ok, so that doesn't look promising! What next?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Using units of measure
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The other common option is to use units of measure to distinguish the two types,
    like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`CustomerId` and `OrderId` are still two different types, but the unit of measure
    is erased, so by the time the JIT sees it the type looks like an primitive int.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that this is true when we time the same steps as before:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*The code sample above is [available on GitHub](https://gist.github.com/swlaschin/348b6b9e64d4b150cf86#file-typesafe-performance-with-compiler-directives-3-fsx)*.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical timed result looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Again, the code is very fast (22 milliseconds), and just as importantly, very
    little garbage was generated again.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'If we increase the array size to 10 million, we maintain the high performance
    (just as with the type alias approach) and still no garbage:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Problems with units of measure
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advantage of units of measure is that the `CustomerId` and `OrderId` types
    are incompatible, so we get the type safety that we want.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: But I find them unsatisfactory from an esthetic point of view. I like my wrapper
    types!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'And also, units of measure are really meant to be used with numeric values.
    For example, I can create a customer id and order id:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: and then I can divide CustomerId(12) by OrderId(4) to get three...
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Three what though? Three customer ids per order id? What does that even mean?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Yes, surely this will never happen in practice, but still it bothers me!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Using compiler directives to get the best of both worlds
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Did I mention that I really like wrapper types? I really like them up until
    I get a call saying that production systems are having performance hiccups because
    of too many big GCs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: So, can we get the best of both worlds? Type-safe wrapper types AND fast performance?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: I think so, if you are willing to put up with some extra work during development
    and build.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The trick is to have *both* the "wrapper type" implemention and the "type alias"
    implementation available to you, and then switch between them based on a compiler
    directive.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'For this to work:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: you will need to tweak your code to not access the type directly, but only via
    functions and pattern matching.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: you will need to create a "type alias" implementation that implements a "constructor",
    various "getters" and for pattern matching, active patterns.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here's an example, using the `COMPILED` and `INTERACTIVE` directives so that
    you can play with it interactively. Obviously, in real code, you would use your
    own directive such as `FASTTYPES` or similar.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can see that for both versions I've created a constructor `createCustomerId`
    and a getter `customerIdValue` and, for the type alias version, an active pattern
    that looks just like `CustomerId`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'With this code in place, we can use `CustomerId` without caring about the implementation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And now we can run the *same* micro-benchmark with both implementations:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*The code sample above is [available on GitHub](https://gist.github.com/swlaschin/348b6b9e64d4b150cf86#file-typesafe-performance-with-compiler-directives-4-fsx)*.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are similar to the previous examples. The aliased version is much
    faster and does not create GC pressure:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'and for the 10 million element version:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A more complex example
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In practice, we might want something more complex than a simple wrapper.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: For example, here is an `EmailAddress` (a simple wrapper type, but constrained
    to be non-empty and containing a "@") and some sort of `Activity` record that
    stores an email and the number of visits, say.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As before, for each type there is a constructor and a getter for each field.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '*NOTE: Normally I would define a type outside a module, but because the real
    constructor needs to be private, I''ve put the type inside the module and given
    the module and the type the same name. If this is too awkward, you can rename
    the module to be different from the type, or use the OCaml convention of calling
    the main type in a module just "T", so you get `EmailAddress.T` as the type name.*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a more performant version, we replace `EmailAddress` with a type alias,
    and `Activity` with a struct, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This version reimplements the constructor and a getter for each field. I could
    have made the field names for `ActivityHistory` be the same in both cases too,
    but. in the struct case, type inference would not work. By making them different,
    the user is forced to use the getter functions rather than dotting in.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本重新实现了构造函数和每个字段的getter。我也可以使`ActivityHistory`的字段名称在两种情况下相同，但是在结构体情况下，类型推断将无法工作。通过使它们不同，用户被迫使用getter函数而不是点操作。
- en: 'Both implementations have the same "API", so we can create code that works
    with both:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 两种实现具有相同的“API”，因此我们可以创建适用于两者的代码：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Pros and cons of this approach
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这种方法的利弊
- en: One nice thing about this approach is that it is self-correcting -- it forces
    you to use the "API" properly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个好处是它是自我纠正的--它强迫你正确使用“API”。
- en: For example, if I started accessing fields directly by dotting into the `ActivityHistory`
    record, then that code would break when the compiler directive was turned on and
    the struct implementation was used.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我开始直接通过点操作访问`ActivityHistory`记录中的字段，那么当编译器指令打开并且使用结构实现时，该代码将会出错。
- en: Of course, you could also create a signature file to enforce the API.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以创建一个签名文件来强制执行API。
- en: On the negative side, we do lose some of the nice syntax such as `{rec with
    ...}`. But you should really only be using this technique with small records (2-3
    fields), so not having `with` is not a big burden.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 不足之处在于，我们失去了一些优雅的语法，比如`{rec with ...}`。但你真的只应该在小记录（2-3个字段）上使用这种技术，所以没有`with`并不是一个大负担。
- en: Timing the two implementations
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计时两种实现方式
- en: Rather than using `#time`, this time I wrote a custom timer that runs a function
    10 times and prints out the GC and memory used on each run.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用`#time`，这次我编写了一个自定义计时器，运行一个函数10次，并打印出每次运行时使用的GC和内存。
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*The code sample above is [available on GitHub](https://gist.github.com/swlaschin/348b6b9e64d4b150cf86#file-typesafe-performance-with-compiler-directives-5-fsx)*.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*上面的代码示例可以在[GitHub上找到](https://gist.github.com/swlaschin/348b6b9e64d4b150cf86#file-typesafe-performance-with-compiler-directives-5-fsx)*。'
- en: 'Let''s now run `mapAndFilter` with a million records in the array:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在数组中运行`mapAndFilter`，其中包含一百万条记录：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The results are shown below:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now this code no longer consists of only value types, so the profiling is getting
    muddier now! The `mapAndFilter` function uses `createCustomerWithRandomActivity`
    which in turn uses `Option`, a reference type, so there will be a large number
    of reference types being allocated. Just as in real life, it's hard to keep things
    pure!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这段代码不再只由值类型组成，所以性能分析现在变得更加混乱！`mapAndFilter`函数使用`createCustomerWithRandomActivity`，后者又使用`Option`，一个引用类型，因此将会分配大量引用类型。就像在现实生活中一样，保持事情纯粹是很困难的！
- en: Even so, you can see that the wrapped version is slower than the aliased version
    (approx 800ms vs. 150ms) and creates more garbage on each iteration (approx 72Mb
    vs 24Mb) and most importantly has two big GC pauses (in the 5th and 9th iterations),
    while the aliased version never even does a gen1 GC, let alone a gen2.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 即使如此，你可以看到封装版本比别名版本慢（大约800ms对150ms），并且在每次迭代中产生更多的垃圾（大约72Mb对24Mb），最重要的是在第5次和第9次迭代中有两次大的GC暂停，而别名版本甚至从未进行过gen1
    GC，更不用说gen2了。
- en: '*NOTE: The fact that aliased version is using up memory and yet there are no
    gen1s makes me a bit suspicious of these figures. I think they might be different
    if run outside of F# interactive.*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：别名版本正在使用内存，但没有gen1，这让我对这些数字有些怀疑。我认为如果在F#交互环境之外运行，结果可能会有所不同。*'
- en: What about non-record types?
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么非记录类型呢？
- en: What if the type we want to optimise is a discriminated union rather than a
    record?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ���果我们要优化的类型是一个判别联合而不是记录呢？
- en: My suggestion is to turn the DU into a struct with a tag for each case, and
    fields for all possible data.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是将DU转换为一个带有每种情况标签和所有可能数据字段的结构。
- en: 'For example, let''s say that we have DU that classifies an `Activity` into
    `Active` and `Inactive`, and for the `Active` case we store the email and visits
    and for the inactive case we only store the email:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个DU，将`Activity`分类为`Active`和`Inactive`，对于`Active`情况，我们存储电子邮件和访问次数，而对于`Inactive`情况，我们只存储电子邮件：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To turn this into a struct, I would do something like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其转换为结构体，我会这样做：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that `Visits` is not used in the `Inactive` case, so is set to a default
    value.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Visits`在`Inactive`情况下没有使用，因此设置为默认值。
- en: Now let's create a function that classifies the activity history, creates a
    `Classification` and then filters and extracts the email only for active customers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*The code sample above is [available on GitHub](https://gist.github.com/swlaschin/348b6b9e64d4b150cf86#file-typesafe-performance-with-compiler-directives-5-fsx)*.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of profiling this function with the two different implementations
    are shown below:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As before, the aliased/struct version is more performant, being faster and generating
    less garbage (although there was a GC pause at the end, oh dear).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Isn't this a lot of work, creating two implementations?
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yes! *I don't think you should do this in general.* This is just an experiment
    on my part.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: I suggest that turning records and DUs into structs is a last resort, only done
    after you have eliminated all other bottlenecks first.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: However, there may be a few special cases where speed and memory are critical,
    and then, perhaps, it might be worth doing something like this.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: What are the downsides?
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to all the extra work and maintenance, you mean?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Well, because the types are essentially private, we do lose some of the nice
    syntax available when you have access to the internals of the type, such as `{rec
    with ...}`, but as I said, you should really only be using this technique with
    small records anyway.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, value types like structs are not a silver bullet. They have
    their own problems.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: For example, they can be slower when passed as arguments (because of copy-by-value)
    and you must be careful not to [box them implicitly](http://theburningmonk.com/2015/07/beware-of-implicit-boxing-of-value-types/),
    otherwise you end up doing allocations and creating garbage. Microsoft has [guidelines
    on using classes vs structs](https://msdn.microsoft.com/en-us/library/ms229017.aspx),
    but see also [this commentary on breaking these guidelines](http://stackoverflow.com/a/6973171/1136133)
    and [these rules](http://stackoverflow.com/a/598268/1136133).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: What about using shadowing?
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shadowing is used when the client wants to use a different implementation. For
    example, you can switch from unchecked to checked arithmetic by opening the [Checked
    module](https://msdn.microsoft.com/en-us/library/ee340296.aspx). [More details
    here](http://theburningmonk.com/2012/01/checked-context-in-c-and-f/).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: But that would not work here -- I don't want each client to decide which version
    of the type they will use. That would lead to all sorts of incompatibility problems.
    Also, it's not a per-module decision, it's a decision based on deployment context.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: What about more performant collection types?
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I am using `array` everywhere as the collection type. If you want other high
    performing collections, check out [FSharpx.Collections](https://fsprojects.github.io/FSharpx.Collections/)
    or [Funq collections](https://github.com/GregRos/Funq).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: You've mixed up allocations, mapping, filtering. What about a more fine-grained
    analysis?
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I'm trying to keep some semblage of dignity after I said that micro-benchmarking
    was bad!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: So, yes, I deliberately created a case with mixed usage and measured it as a
    whole rather than benchmarking each part separately. Your usage scenarios will
    obviously be different, so I don't think there's any need to go deeper.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Also, I'm doing all my benchmarking in F# interactive. Compiled code with optimizations
    might have a completely different performance profile.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: What other ways are there to increase performance?
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since F# is a .NET language, the performance tips for C# work for F# as well,
    standard stuff like:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Make all I/O async. Use streaming IO over random access IO if possible. Batch
    up your requests.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check your algorithms. Anything worse than O(n log(n)) should be looked at.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't do things twice. Cache as needed.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep things in the CPU cache by keeping objects in contiguous memory and avoiding
    too many deep reference (pointer) chains. Things that help with this are using
    arrays instead of lists, value types instead of reference types, etc.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid pressure on the garbage collector by minimizing allocations. Avoid creating
    long-lived objects that survive gen0 collections.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be clear, I don't claim to be an expert on .NET performance and garbage collection.
    In fact, if you see something wrong with this analysis, please let me know!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some sources that helped me:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The book [Writing High-Performance .NET Code](http://www.writinghighperf.net/)
    by Ben Watson.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Martin Thompson has a great [blog](http://mechanical-sympathy.blogspot.jp/2012/08/memory-access-patterns-are-important.html)
    on performance and some excellent videos, such as [Top 10 Performance Folklore](http://www.infoq.com/presentations/top-10-performance-myths).
    ([Good summary here](http://weronikalabaj.com/performance-myths-and-facts/).)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Understanding Latency](https://www.youtube.com/watch?v=9MKY4KypBzg), a video
    by Gil Tene.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Essential Truths Everyone Should Know about Performance in a Large Managed
    Codebase](https://channel9.msdn.com/Events/TechEd/NorthAmerica/2013/DEV-B333),
    a video by Dustin Cambell at Microsoft.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For F# in particular:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yan Cui has some blog posts on [records vs structs](http://theburningmonk.com/2011/10/fsharp-performance-test-structs-vs-records/)
    and [memory layout](http://theburningmonk.com/2015/07/smallest-net-ref-type-is-12-bytes-or-why-you-should-consider-using-value-types).
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Jon Harrop has a number of good articles such as [this one](http://flyingfrogblog.blogspot.co.uk/2012/06/are-functional-languages-inherently.html)
    but some of it is behind a paywall.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Video: [High Performance F# in .NET and on the GPU](https://vimeo.com/33699102)
    with Jack Pappas. The sound is bad, but the slides and discussion are good!'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Resources for Math and Statistics](http://fsharp.org/guides/math-and-statistics/)
    on fsharp.org'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '"Keep it clean; keep it simple; aim to be elegant." -- *Martin Thompson*'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This was a little experiment to see if I could have my cake and eat it too.
    Domain modelling using lots of types, but with the ability to get performance
    when needed in an elegant way.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个小实验，看看我是否能两全其美。使用大量类型进行领域建模，但在需要时以一种优雅的方式获得性能。
- en: I think that this is quite a nice solution, but as I said earlier, this optimization
    (and uglification) should only ever be needed for a small number of heavily used
    core types that are allocated many millions of times.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这是一个相当不错的解决方案，但正如我之前所说，这种优化（和丑化）应该只在一小部分被大量使用的核心类型上需要，这些类型被分配了很多次。
- en: Finally, I have not used this approach myself in a large production system (I've
    never needed to), so I would be interested in getting feedback from people in
    the trenches on what they do.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我自己在一个大型生产系统中没有使用过这种方法（我从未需要过），所以我很想听听战壕中的人们对他们的做法有什么反馈。
- en: '*The code samples used in this post are [available on GitHub](https://gist.github.com/swlaschin/348b6b9e64d4b150cf86)*.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*本文中使用的代码示例可以在[GitHub上找到](https://gist.github.com/swlaschin/348b6b9e64d4b150cf86)*。'
