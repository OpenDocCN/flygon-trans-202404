- en: Learning F#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional languages are very different from standard imperative languages,
    and can be quite tricky to get the hang of initially. This page offers some tips
    on how to learn F# effectively.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Approach learning F# as a beginner
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have experience in languages such as C# and Java, you have probably found
    that you can get a pretty good understanding of source code written in other similar
    languages, even if you aren't familiar with the keywords or the libraries. This
    is because all imperative languages use the same way of thinking, and experience
    in one language can be easily transferred to another.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: If you are like many people, your standard approach to learning a new programming
    language is to find out how to implement concepts you are already familiar with.
    You might ask "how do I assign a variable?" or "how do I do a loop?", and with
    these answers be able to do some basic programming quite quickly.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: When learning F#, **you should not try to bring your old imperative concepts
    with you**. In a pure functional language there are no variables, there are no
    loops, and there are no objects!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Yes, F# is a hybrid language and does support these concepts. But you will learn
    much faster if you start with a beginners mind.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Change the way you think
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to understand that functional programming is not just a stylistic
    difference; it is a completely different way of thinking about programming, in
    the way that truly object-oriented programming (in Smalltalk say) is also a different
    way of thinking from a traditional imperative language such as C.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: F# does allow non-functional styles, and it is tempting to retain the habits
    you already are familiar with. You could just use F# in a non-functional way without
    really changing your mindset, and not realize what you are missing. To get the
    most out of F#, and to be fluent and comfortable with functional programming in
    general, it is critical that you think functionally, not imperatively.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: By far the most important thing you can do is to take the time and effort to
    understand exactly how F# works, especially the core concepts involving functions
    and the type system. So please read and reread the series ["thinking functionally"](thinking-functionally.html)
    and ["understanding F# types"](understanding-fsharp-types.html), play with the
    examples, and get comfortable with the ideas before you try to start doing serious
    coding. If you don't understand how functions and types work, then you will have
    a hard time being productive.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Dos and Don'ts
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is a list of dos and don'ts that will encourage you to think functionally.
    These will be hard at first, but just like learning a foreign language, you have
    to dive in and force yourself to speak like the locals.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Don't use the `mutable` keyword **at all** as a beginner. Coding complex functions
    without the crutch of mutable state will really force you to understand the functional
    paradigm.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't use `for` loops or `if-then-else`. Use pattern matching for testing booleans
    and recursing through lists.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用`for`循环或`if-then-else`。使用模式匹配来测试布尔值并通过列表进行递归。
- en: Don't use "dot notation". Instead of "dotting into" objects, try to use functions
    for everything. That is, write `String.length "hello"` rather than `"hello".Length`.
    It might seem like extra work, but this way of working is essential when using
    pipes and higher order functions like `List.map`. And don't write your own methods
    either! See [this post for details](type-extensions.html#downsides-of-methods).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用“点符号”。而不是“点进”对象，尽量使用函数来完成一切。也就是说，写`String.length "hello"`而不是`"hello".Length`。这可能看起来多余，但在使用管道和高阶函数如`List.map`时，这种工作方式是必不可少的。也不要编写自己的方法！参见[此帖子了解详情](type-extensions.html#downsides-of-methods)。
- en: As a corollary, don't create classes. Use only the pure F# types such as tuples,
    records and unions.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为推论，不要创建类。只使用纯粹的 F# 类型，如元组、记录和联合。
- en: Don't use the debugger. If you have relied on the debugger to find and fix incorrect
    code, you will get a nasty shock. In F#, you will probably not get that far, because
    the compiler is so much stricter in many ways. And of course, there is no tool
    to "debug" the compiler and step through its processing. The best tool for debugging
    compiler errors is your brain, and F# forces you to use it!
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用调试器。如果你依赖调试器来查找和修复不正确的代码，你会受到严重打击。在 F# 中，你可能不会走得那么远，因为编译器在许多方面要严格得多。当然，没有工具可以“调试”编译器并逐步处理其处理过程。调试编译器错误的最佳工具是你的大脑，而
    F# 强制你使用它！
- en: 'On the other hand:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面：
- en: Do create lots of "little types", especially union types. They are lightweight
    and easy, and their use will help document your domain model and ensure correctness.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建许多“小型类型”，特别是联合类型。它们轻量且易于使用，它们的使用将有助于记录你的领域模型并确保正确性。
- en: Do understand the `list` and `seq` types and their associated library modules.
    Functions like `List.fold` and `List.map` are very powerful. Once you understand
    how to use them, you will be well on your way to understanding higher order functions
    in general.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`list`和`seq`类型及其相关的库模块。像`List.fold`和`List.map`这样的函数非常强大。一旦你理解如何使用它们，你就会在理解高阶函数方面迈出重要的一步。
- en: Once you understand the collection modules, try to avoid recursion. Recursion
    can be error prone, and it can be hard to make sure that it is properly tail-recursive.
    When you use `List.fold`, you can never have that problem.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你理解了集合模块，请尽量避免递归。递归容易出错，并且很难确保它是正确的尾递归。当你使用`List.fold`时，你永远不会遇到这个问题。
- en: Do use pipe (`|>`) and composition (`>>`) as much as you can. This style is
    much more idiomatic than nested function calls like `f(g(x))`
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量使用管道（`|>`）和组合（`>>`）。这种风格比像`f(g(x))`这样的嵌套函数调用更符合习惯。
- en: Do understand how partial application works, and try to become comfortable with
    point-free (tacit) style.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解部分应用的工作原理，并尝试熟悉点无（tacit）风格。
- en: Do develop code incrementally, using the interactive window to test code fragments.
    If you blindly create lots of code and then try to compile it all at once, you
    may end up with many painful and hard-to-debug compilation errors.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步开发代码，使用交互式窗口测试代码片段。如果你盲目地创建大量代码，然后尝试一次性编译所有代码，你可能会遇到许多痛苦且难以调试的编译错误。
- en: Troubleshooting
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除
- en: There are a number of extremely common errors that beginners make, and if you
    are frustrated about getting your code to compile, please read the ["troubleshooting
    F#"](index5.html) page.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者经常犯一些极为常见的错误，如果你对让代码编译感到沮丧，请阅读["F#故障排除"](index5.html)页面。
