["```\ntype alias Rank = Int\ntype Tree = Node Rank Int (List Tree)\n\nrank (Node r _ _) = r\nroot (Node _ x _) = x \n```", "```\nlink : Tree -> Tree -> Tree\nlink t1 t2 =\n  let (Node r x1 c1) = t1\n      (Node _ x2 c2) = t2\n  in\n    if | x1 <= x2  -> Node (1+r) x1 (t2::c1)\n       | otherwise -> Node (1+r) x2 (t1::c2) \n```", "```\ntype alias InternalHeap = List Tree\ntype Heap = WrapHeap InternalHeap \n```", "```\nempty : Heap\nempty = WrapHeap []\n\nisEmpty : Heap -> Bool\nisEmpty h = h == empty \n```", "```\nfindMin : Heap -> Maybe Int\nfindMin (WrapHeap ts) = case ts of\n  [] -> Nothing\n  _  -> ts |> List.map root |> List.foldl1 min |> Just \n```", "```\ninsertTree : Tree -> InternalHeap -> InternalHeap\ninsertTree t ts = case ts of\n  []      -> [t]\n  t'::ts' -> if\n    | rank t == rank t' -> insertTree (link t t') ts'\n    | rank t <  rank t' -> t :: ts\n\ninsert : Int -> Heap -> Heap\ninsert x (WrapHeap ts) = WrapHeap (insertTree (Node 0 x []) ts) \n```", "```\nmerge_ : InternalHeap -> InternalHeap -> InternalHeap\nmerge_ ts1 ts2 = case (ts1, ts2) of\n  ([], _) -> ts2\n  (_, []) -> ts1\n  (t1::ts1', t2::ts2') ->\n    if | rank t1 < rank t2 -> t1 :: merge_ ts1' ts2\n       | rank t2 < rank t1 -> t2 :: merge_ ts2' ts1\n       | otherwise         -> insertTree (link t1 t2) (merge_ ts1' ts2')\n\nmerge : Heap -> Heap -> Heap\nmerge (WrapHeap ts1) (WrapHeap ts2) = WrapHeap (merge_ ts1 ts2) \n```", "```\nmerge' : InternalHeap -> InternalHeap -> InternalHeap\nmerge' ts1 ts2 = case (ts1, ts2) of\n  ([], _) -> ts2\n  (_, []) -> ts1\n  (t1::ts1', t2::ts2') ->\n    if | rank t1 < rank t2 -> t1 :: merge' ts1' ts2\n       | rank t2 < rank t1 -> t2 :: merge' ts2' ts2\n       | otherwise         -> merge_wc (link t1 t2) ts1' ts2'\n\nmerge_wc : Tree -> InternalHeap -> InternalHeap -> InternalHeap\nmerge_wc t ts1 ts2 = case (ts1, ts2) of\n  ([], _) -> insertTree t ts2\n  (_, []) -> insertTree t ts1\n  (t1::ts1', t2::ts2') ->\n    let (r,r1,r2) = (rank t, rank t1, rank t2) in\n    if | r <  r1 && r <  r2 -> t :: merge' ts1 ts2\n       | r <  r1 && r == r2 -> merge_wc (link t t2) ts1 ts2'\n       | r == r1 && r <  r2 -> merge_wc (link t t1) ts1' ts2\n       | r == r1 && r == r2 -> merge_wc (link t t1) ts1' ts2 \n```", "```\nremoveMinTree : InternalHeap -> (Tree, InternalHeap)\nremoveMinTree ts = case ts of\n  [t]    -> (t, [])\n  t::ts' ->\n    let (t',ts'') = removeMinTree ts' in\n    if | root t < root t' -> (t, ts')\n       | otherwise        -> (t', t::ts'')\n\ndeleteMin : Heap -> Maybe Heap\ndeleteMin (WrapHeap ts) = case ts of\n  [] -> Nothing\n  _  -> let (Node _ x ts1, ts2) = removeMinTree ts in\n        Just <| WrapHeap <| merge_ (List.reverse ts1) ts2 \n```", "```\nfindMin : Heap -> Maybe Int\nfindMin (WrapHeap ts) = case ts of\n  [] -> Nothing\n  _  -> ts |> removeMinTree |> fst |> root |> Just \n```"]