- en: The "Map and Bind and Apply, Oh my!" Series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '"Map和Bind和Apply，哦我的上帝！"系列'
- en: In this series of posts, I'll attempt to describe some of the core functions
    for dealing with generic data types (such as `Option` and `List`). This is a follow-up
    post to [my talk on functional patterns](http://fsharpforfunandprofit.com/fppatterns/).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一系列文章中，我将尝试描述一些处理通用数据类型（如`Option`和`List`）的核心函数。这是我关于[函数式模式的讲座](http://fsharpforfunandprofit.com/fppatterns/)的后续文章。
- en: Yes, I know that [I promised not to do this kind of thing](why-i-wont-be-writing-a-monad-tutorial.html),
    but for this post I thought I'd take a different approach from most people. Rather
    than talking about abstractions such as type classes, I thought it might be useful
    to focus on the core functions themselves and how they are used in practice.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我知道我[承诺过不做这种事情](why-i-wont-be-writing-a-monad-tutorial.html)，但是对于这篇文章，我想采取与大多数人不同的方法。与其谈论诸如类型类之类的抽象概念，我认为专注于核心函数本身以及它们在实践中的使用可能更有用。
- en: In other words, a sort of "man page" for `map`, `return`, `apply`, and `bind`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这是`map`、`return`、`apply`和`bind`的一种类似于"man page"的东西。
- en: So, there is a section for each function, describing their name (and common
    aliases), common operators, their type signature, and then a detailed description
    of why they are needed and how they are used, along with some visuals (which I
    always find helpful).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个函数都有一个部分，描述它们的名称（和常见别名），常见运算符，它们的类型签名，然后详细描述为什么需要它们以及如何使用它们，以及一些可视化内容（我总是觉得很有帮助）。
- en: '[Understanding map and apply](elevated-world.html). A toolset for working with
    elevated worlds.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[理解map和apply](elevated-world.html)。一个用于处理提升世界的工具集。'
- en: '[Understanding bind](elevated-world-2.html). Or, how to compose world-crossing
    functions.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[理解bind](elevated-world-2.html)。或者，如何组合跨世界的函数。'
- en: '[Using the core functions in practice](elevated-world-3.html). Working with
    independent and dependent data.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在实践中使用核心函数](elevated-world-3.html)。处理独立和依赖数据。'
- en: '[Understanding traverse and sequence](elevated-world-4.html). Mixing lists
    and elevated values.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[理解traverse和sequence](elevated-world-4.html)。混合列表和提升值。'
- en: '[Using map, apply, bind and sequence in practice](elevated-world-5.html). A
    real-world example that uses all the techniques.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在实践中使用map、apply、bind和sequence](elevated-world-5.html)。一个使用所有技术的真实例子。'
- en: '[Reinventing the Reader monad](elevated-world-6.html). Or, designing your own
    elevated world.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[重新设计Reader monad](elevated-world-6.html)。或者，设计您自己的提升世界。'
- en: '[Map and Bind and Apply, a summary](elevated-world-7.html). .'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Map和Bind和Apply，一个总结](elevated-world-7.html)。'
- en: Understanding map and apply
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解map和apply
- en: Understanding map and apply
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解map和apply
- en: In this series of posts, I'll attempt to describe some of the core functions
    for dealing with generic data types (such as `Option` and `List`). This is a follow-up
    post to [my talk on functional patterns](http://fsharpforfunandprofit.com/fppatterns/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一系列文章中，我将尝试描述一些处理通用数据类型（如`Option`和`List`）的核心函数。这是我关于[函数式模式的讲座](http://fsharpforfunandprofit.com/fppatterns/)的后续文章。
- en: Yes, I know that [I promised not to do this kind of thing](why-i-wont-be-writing-a-monad-tutorial.html),
    but for this post I thought I'd take a different approach from most people. Rather
    than talking about abstractions such as type classes, I thought it might be useful
    to focus on the core functions themselves and how they are used in practice.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我知道我[承诺过不做这种事情](why-i-wont-be-writing-a-monad-tutorial.html)，但是对于这篇文章，我想采取与大多数人不同的方法。与其谈论诸如类型类之类的抽象概念，我认为专注于核心函数本身以及它们在实践中的使用可能更有用。
- en: In other words, a sort of ["man page"](https://en.wikipedia.org/wiki/Man_page)
    for `map`, `return`, `apply`, and `bind`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这是`map`、`return`、`apply`和`bind`的一种类似于["man page"](https://en.wikipedia.org/wiki/Man_page)的东西。
- en: So, there is a section for each function, describing their name (and common
    aliases), common operators, their type signature, and then a detailed description
    of why they are needed and how they are used, along with some visuals (which I
    always find helpful).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个函数都有一个部分，描述它们的名称（和常见别名），常见运算符，它们的类型签名，然后详细描述为什么需要它们以及如何使用它们，以及一些可视化内容（我总是觉得很有帮助）。
- en: Haskellers and category-theorists may want to look away now! There will be no
    mathematics and quite a lot of hand-waving. I am going to avoid jargon and Haskell-specific
    concepts such as type classes and focus on the big picture as much as possible.
    The concepts here should be applicable to any kind of functional programming in
    any language.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell程序员和范畴论者现在可能会移开目光！这里不会涉及数学，但会有相当多的泛泛之谈。我将避免使用行话和Haskell特定概念，比如类型类，并尽可能关注大局。这里的概念应适用于任何语言中的任何类型的函数式编程。
- en: I know that some people might dislike this approach. That's fine. There is [no
    shortage](https://wiki.haskell.org/Monad_tutorials_timeline) of more academic
    explanations on the web. Start with [this](http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf)
    and [this](http://www.soi.city.ac.uk/~ross/papers/Applicative.html).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道有些人可能不喜欢这种方法。没关系。网上有[很多](https://wiki.haskell.org/Monad_tutorials_timeline)更学术的解释。可以从[这里](http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf)和[这里](http://www.soi.city.ac.uk/~ross/papers/Applicative.html)开始。
- en: Finally, as with most of the posts on this site, I am writing this up for my
    own benefit as well, as part of my own learning process. I don't claim to be an
    expert at all, so if I have made any errors please let me know.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与本站的大多数文章一样，我写这篇文章也是为了我自己的利益，作为我自己学习过程的一部分。我并不自称是专家，所以如果我有任何错误，请告诉我。
- en: Background
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: To start with, let me provide the background and some terminology.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我提供一些背景和一些术语。
- en: 'Imagine that there are two worlds that we could program in: a "normal" everyday
    world and a world that I will call the "elevated world" (for reasons that I will
    explain shortly).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们可以编程的有两个世界：一个是“正常”的日常世界，另一个是我将称之为“提升世界”的世界（我将很快解释原因）。
- en: The elevated world is very similar to the normal world. In fact, every thing
    in the normal world has a corresponding thing in the elevated world.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 提升世界与普通世界非常相似。实际上，普通世界中的每一件事物在提升世界中都有对应的事物。
- en: So, for example, we have the set of values called `Int` in the normal world,
    and in the elevated world there is a parallel set of values called, say, `E<Int>`.
    Similarly, we have the set of values called `String` in the normal world, and
    in the elevated world there is a parallel set of values called `E<String>`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，例如，我们在正常世界中有一组称为`Int`的值，而在提升世界中，有一组并行的值称为，比如，`E<Int>`。同样地，我们在正常世界中有一组称为`String`的值，在提升世界中，有一组并行的值称为`E<String>`。
- en: '![](vgfp_e_values.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_e_values.png)'
- en: Also, just as there are functions between `Int`s and `String`s in the normal
    world, so there are functions between `E<Int>`s and `E<String>`s in the elevated
    world.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如在正常世界中存在`Int`和`String`之间的函数一样，在提升世界中也存在`E<Int>`和`E<String>`之间的函数。
- en: '![](vgfp_e_functions.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_e_functions.png)'
- en: Note that I am deliberately using the term "world" rather than "type" to emphasis
    that the *relationships* between values in the world are just as important as
    the underlying data type.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我故意使用术语“世界”而不是“类型”，以强调世界中值之间的*关系*和底层数据类型一样重要。
- en: What exactly is an elevated world?
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 到底什么是提升世界？
- en: I can't define what an elevated world is exactly, because there are too many
    different kinds of elevated worlds, and they don't have anything in common.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法准确定义什么是“提升世界”，因为有太多不同种类的提升世界，它们之间没有任何共同之处。
- en: Some of them represent data structures (`Option<T>`), some of them represent
    workflows (`State<T>`), some of them represent signals (`Observable<T>`), or asychronous
    values (`Async<T>`), or other concepts.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些代表数据结构（`Option<T>`），一些代表工作流程（`State<T>`），一些代表信号（`Observable<T>`），或者异步值（`Async<T>`），或其他概念。
- en: But even though the various elevated worlds have nothing in common specifically,
    there *are* commonalities in the way they can be worked with. We find that certain
    issues occur over and over again in different elevated worlds, and we can use
    standard tools and patterns to deal with these issues.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但是即使各种不同的提升世界没有具体的共同之处，它们*确实*在可以处理它们的方式上存在共性。我们发现在不同的提升世界中，某些问题反复出现，我们可以使用标准工具和模式来处理这些问题。
- en: The rest of this series will attempt to document these tools and patterns.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本系列的其余部分将尝试记录这些工具和模式。
- en: Series contents
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系列内容
- en: 'This series is developed as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本系列的开发如下：
- en: First, I'll discuss the tools we have for lifting normal things into the elevated
    world. This includes functions such as `map`, `return`, `apply` and `bind`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我将讨论我们用于将正常事物提升到提升世界的工具。这包括`map`、`return`、`apply`和`bind`等函数。
- en: Next, I'll discuss how you can combine elevated values in different ways, based
    on whether the values are independent or dependent.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我将讨论如何根据值是独立还是依赖来以不同方式组合提升值。
- en: Next, we'll look at some ways of mixing lists with other elevated values.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一些将列表与其他提升值混合的方法。
- en: Finally, we'll look at two real-world examples that put all these techniques
    to use, and we'll find ourselves accidentally inventing the Reader monad.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将看两个真实世界的例子，将所有这些技术应用起来，我们会意外地发明Reader单子。
- en: 'Here''s a list of shortcuts to the various functions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是各种函数的快捷方式列表：
- en: '**Part 1: Lifting to the elevated world**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第1部分：提升到提升世界**'
- en: '[The `map` function](elevated-world.html#map)'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`map`函数](elevated-world.html#map)'
- en: '[The `return` function](elevated-world.html#return)'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`return`函数](elevated-world.html#return)'
- en: '[The `apply` function](elevated-world.html#apply)'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`apply`函数](elevated-world.html#apply)'
- en: '[The `liftN` family of functions](elevated-world.html#lift)'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`liftN`函数族](elevated-world.html#lift)'
- en: '[The `zip` function and ZipList world](elevated-world.html#zip)'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`zip`函数和ZipList世界](elevated-world.html#zip)'
- en: '**Part 2: How to compose world-crossing functions**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第2部分：如何组合跨世界函数**'
- en: '[The `bind` function](elevated-world-2.html#bind)'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[绑定（`bind`）函数](elevated-world-2.html#bind)'
- en: '[List is not a monad. Option is not a monad.](elevated-world-2.html#not-a-monad)'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[列表不是一个单子。选项不是一个单子。](elevated-world-2.html#not-a-monad)'
- en: '**Part 3: Using the core functions in practice**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第3部分：实践中使用核心函数**'
- en: '[Independent and dependent data](elevated-world-3.html#dependent)'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[独立和依赖数据](elevated-world-3.html#dependent)'
- en: '[Example: Validation using applicative style and monadic style](elevated-world-3.html#validation)'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：使用应用风格和单子风格进行验证](elevated-world-3.html#validation)'
- en: '[Lifting to a consistent world](elevated-world-3.html#consistent)'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提升到一致世界](elevated-world-3.html#consistent)'
- en: '[Kleisli world](elevated-world-3.html#kleisli)'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kleisli世界](elevated-world-3.html#kleisli)'
- en: '**Part 4: Mixing lists and elevated values**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第4部分：混合列表和提升值**'
- en: '[Mixing lists and elevated values](elevated-world-4.html#mixing)'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[混合列表和提升值](elevated-world-4.html#mixing)'
- en: '[The `traverse`/`MapM` function](elevated-world-4.html#traverse)'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`traverse`/`MapM`函数](elevated-world-4.html#traverse)'
- en: '[The `sequence` function](elevated-world-4.html#sequence)'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`sequence`函数](elevated-world-4.html#sequence)'
- en: '["Sequence" as a recipe for ad-hoc implementations](elevated-world-4.html#adhoc)'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"序列"作为临时实现的配方'
- en: '[Readability vs. performance](elevated-world-4.html#readability)'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可读性 vs. 性能](elevated-world-4.html#readability)'
- en: '[Dude, where''s my `filter`?](elevated-world-4.html#filter)'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[伙计，我的`filter`在哪里？](elevated-world-4.html#filter)'
- en: '**Part 5: A real-world example that uses all the techniques**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第5部分：使用所有技术的真实世界示例**'
- en: '[Example: Downloading and processing a list of websites](elevated-world-5.html#asynclist)'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：下载和处理网站列表](elevated-world-5.html#asynclist)'
- en: '[Treating two worlds as one](elevated-world-5.html#asyncresult)'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将两个世界视为一个](elevated-world-5.html#asyncresult)'
- en: '**Part 6: Designing your own elevated world**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第6部分：设计自己的提升世界**'
- en: '[Designing your own elevated world](elevated-world-6.html#part6)'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[设计自己的提升世界](elevated-world-6.html#part6)'
- en: '[Filtering out failures](elevated-world-6.html#filtering)'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[过滤掉失败](elevated-world-6.html#filtering)'
- en: '[The Reader monad](elevated-world-6.html#readermonad)'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Reader单子](elevated-world-6.html#readermonad)'
- en: '**Part 7: Summary**'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第7部分：总结**'
- en: '[List of operators mentioned](elevated-world-7.html#operators)'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提到的运算符列表](elevated-world-7.html#operators)'
- en: '[Further reading](elevated-world-7.html#further-reading)'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[进一步阅读](elevated-world-7.html#further-reading)'
- en: '* * *'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Part 1: Lifting to the elevated world'
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分：提升到提升世界
- en: 'The first challenge is: how do we get from the normal world to the elevated
    world?'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个挑战是：我们如何从普通世界到提升世界？
- en: 'First, we will assume that for any particular elevated world:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将假设对于任何特定的提升世界：
- en: Every type in the normal world has a corresponding type in the elevated world.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通世界中的每种类型都有对应的提升世界中的类型。
- en: Every value in the normal world has a corresponding value in the elevated world.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通世界中的每个值都有对应的提升世界中的值。
- en: Every function in the normal world has a corresponding function in the elevated
    world.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通世界中的每个函数都有对应的提升世界中的函数。
- en: The concept of moving something from the normal world to the elevated world
    is called "lifting" (which is why I used the term "elevated world" in the first
    place).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将某物从普通世界移动到提升世界的概念称为"提升"（这就是我首次使用"提升世界"这个术语的原因）。
- en: We'll call these corresponding things "lifted types" and "lifted values" and
    "lifted functions".
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些对应的东西称为"提升类型"、"提升值"和"提升函数"。
- en: Now because each elevated world is different, there is no common implementation
    for lifting, but we can give names to the various "lifting" patterns, such as
    `map` and `return`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在因为每个提升的世界都是不同的，所以没有通用的提升实现，但我们可以给各种“提升”模式命名，例如`map`和`return`。
- en: '*NOTE: There is no standard name for these lifted types. I have seen them called
    "wrapper types" or "augmented types" or "monadic types". I''m not really happy
    with any of these names, so I invented [a new one](https://xkcd.com/927/)! Also,
    I''m trying avoid any assumptions, so I don''t want to imply that the lifted types
    are somehow better or contain extra information. I hope that by using the word
    "elevated" in this post, I can focus on the* lifting process *rather than on the
    types themselves.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：这些提升的类型没有标准名称。我见过它们被称为“包装类型”或“增强类型”或“monadic类型”。我对这些名称都不是很满意，所以我发明了[一个新的名称](https://xkcd.com/927/)！另外，我正在尽量避免做出任何假设，所以我不想暗示提升的类型在某种程度上更好或包含额外的信息。我希望通过在本文中使用“提升”的词，可以将注意力集中在提升过程上，而不是类型本身上。*'
- en: '*As for using the word "monadic", that would be inaccurate, as there is no
    requirement that these types are part of a monad.*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*至于使用“monadic”这个词，那是不准确的，因为这些类型不要求是单子的一部分。*'
- en: '* * *'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The `map` function
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`map`函数'
- en: '**Common Names**: `map`, `fmap`, `lift`, `Select`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见名称**：`map`、`fmap`、`lift`、`Select`'
- en: '**Common Operators**: `<$>` `<!>`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见运算符**：`<$>` `<!>`'
- en: '**What it does**: Lifts a function into the elevated world'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能**：将一个函数提升到提升的世界中'
- en: '**Signature**: `(a->b) -> E<a> -> E<b>`. Alternatively with the parameters
    reversed: `E<a> -> (a->b) -> E<b>`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**签名**：`(a->b) -> E<a> -> E<b>`。另外，参数反转时是：`E<a> -> (a->b) -> E<b>`'
- en: Description
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: '"map" is the generic name for something that takes a function in the normal
    world and transforms it into a corresponding function in the elevated world.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: “map”是一个通用名称，用于将正常世界中的函数转换为提升世界中的对应函数。
- en: '![](vgfp_map.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_map.png)'
- en: Each elevated world will have its own implementation of map.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个提升的世界都将有自己的`map`实现。
- en: Alternative interpretation
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替代解释
- en: An alternative interpretation of `map` is that it is a *two* parameter function
    that takes an elevated value (`E<a>`) and a normal function (`a->b`), and returns
    a new elevated value (`E<b>`) generated by applying the function `a->b` to the
    internal elements of `E<a>`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对`map`的另一种解释是它是一个*两个*参数函数，它接受一个提升的值（`E<a>`）和一个普通函数（`a->b`），并返回一个通过将函数`a->b`应用于`E<a>`的内部元素而生成的新提升值（`E<b>`）。
- en: '![](vgfp_map2.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_map2.png)'
- en: In languages where functions are curried by default, such as F#, both these
    interpretation are the same. In other languages, you may need to curry/uncurry
    to switch between the two uses.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认柯里化函数的语言中，如F#，这两种解释是相同的。在其他语言中，您可能需要对函数进行柯里化/取消柯里化以在两种用法之间切换。
- en: Note that the *two* parameter version often has the signature `E<a> -> (a->b)
    -> E<b>`, with the elevated value first and the normal function second. From an
    abstract point of view, there's no difference between them -- the map concept
    is the same -- but obviously, the parameter order affects how you might use map
    functions in practice.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意*两个*参数版本通常具有`E<a> -> (a->b) -> E<b>`的签名，首先是提升值，然后是普通函数。从抽象的角度来看，它们之间没有区别--`map`概念是相同的--但显然，参数顺序会影响你在实践中如何使用`map`函数。
- en: Implementation examples
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现示例
- en: Here are two examples of how map can be defined for options and lists in F#.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个示例，演示了在F#中如何定义选项和列表的`map`。
- en: '[PRE0]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These functions are built-in of course, so we don't need to define them, I've
    done it just to show what they might look for some common types.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些函数是内置的，所以我们不需要定义它们，我只是为了展示一些常见类型可能的样子。
- en: Usage examples
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用示例
- en: 'Here are some examples of how map can be used in F#:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些在F#中如何使用`map`的示例：
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With these mapped versions in place you can write code like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些映射版本，你可以编写这样的代码：
- en: '[PRE2]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In many cases, we don''t bother to create an intermediate function -- partial
    application is used instead:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们不需要创建一个中间函数--而是使用部分应用：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The properties of a correct map implementation
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确`map`实现的属性
- en: I said earlier that the elevated world is in some ways a mirror of the normal
    world. Every function in the normal world has a corresponding function in the
    elevated world, and so on. We want `map` to return this corresponding elevated
    function in a sensible way.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过，提升的世界在某些方面是正常世界的镜像。正常世界中的每个函数都有一个对应的函数在提升的世界中，等等。我们希望`map`以明智的方式返回这个对应的提升函数。
- en: For example, `map` of `add` should not (wrongly) return the elevated version
    of `multiply`, and `map` of `lowercase` should not return the elevated version
    of `uppercase`! But how can we be *sure* that a particular implementation of map
    does indeed return the *correct* corresponding function?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`add`的`map`不应（错误地）返回`multiply`的提升版本，`lowercase`的`map`也不应返回`uppercase`的提升版本！但我们如何*确保*特定的`map`实现确实返回*正确*的相应函数呢？
- en: In [my post on property based testing](http://fsharpforfunandprofit.com/pbt/)
    I showed how a correct implementation of a function can be defined and tested
    using general properties rather than specific examples.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在[我的关于属性基础测试的文章](http://fsharpforfunandprofit.com/pbt/)中，我展示了如何通过一般属性而不是具体示例来定义和测试函数的正确实现。
- en: This is true for `map` as well. The implementation will vary with the specific
    elevated world, but in all cases, there are certain properties that the implementation
    should satisfy to avoid strange behavior.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这对`map`也是适用的。具体的实现会随着特定的提升世界而变化，但在所有情况下，实现应满足某些属性，以避免奇怪的行为。
- en: First, if you take the `id` function in the normal world, and you lift it into
    the elevated world with `map`, the new function must be the *same* as the `id`
    function in the elevated world.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你在正常世界中使用`id`函数，并将其通过`map`提升到提升世界中，新函数必须与提升世界中的`id`函数*相同*。
- en: '![](vgfp_functor_law_id.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_functor_law_id.png)'
- en: Next, if you take two functions `f` and `g` in the normal world, and you compose
    them (into `h`, say), and then lift the resulting function using `map`, the resulting
    function should be the *same* as if you lifted `f` and `g` into the elevated world
    *first*, and then composed them there afterwards.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果你在正常世界中使用两个函数`f`和`g`，并将它们组合（成为`h`），然后使用`map`提升结果函数，那么结果函数应该与如果你先将`f`和`g`提升到提升世界中，然后在那里组合它们后是*相同*的。
- en: '![](vgfp_functor_law_compose.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_functor_law_compose.png)'
- en: These two properties are the so-called ["Functor Laws"](https://en.wikibooks.org/wiki/Haskell/The_Functor_class#The_functor_laws),
    and a **Functor** (in the programming sense) is defined as a generic data type
    -- `E<T>` in our case -- plus a `map` function that obeys the functor laws.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个属性被称为["函子法则"](https://en.wikibooks.org/wiki/Haskell/The_Functor_class#The_functor_laws)，而**函子**（在编程意义上）被定义为一个通用数据类型--在我们的情况下是`E<T>`--加上一个遵守函子法则的`map`函数。
- en: '*NOTE: "Functor" is a confusing word. There is "functor" in the category theory
    sense, and there is "functor" in the programming sense (as defined above). There
    are also things called "functors" defined in libraries, such as [the `Functor`
    type class in Haskell](https://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Functor.html),
    and the [`Functor` trait in Scalaz](https://scalaz.github.io/scalaz/scalaz-2.9.0-1-6.0/doc.sxr/scalaz/Functor.scala.html),
    not to mention functors in SML and [OCaml](https://realworldocaml.org/v1/en/html/functors.html)
    (and [C++](http://www.cprogramming.com/tutorial/functors-function-objects-in-c++.html)),
    which are different yet again!*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：“函子”是一个令人困惑的词。有“函子”在范畴论意义上，也有“函子”在编程意义上（如上所定义）。还有在库中定义的称为“函子”的东西，比如[Haskell中的`Functor`类型类](https://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Functor.html)，以及[Scalaz中的`Functor`特性](https://scalaz.github.io/scalaz/scalaz-2.9.0-1-6.0/doc.sxr/scalaz/Functor.scala.html)，更不用说SML和[OCaml中的函子](https://realworldocaml.org/v1/en/html/functors.html)（以及[C++](http://www.cprogramming.com/tutorial/functors-function-objects-in-c++.html)），它们又是不同的！*'
- en: '*Conseqently, I prefer to talk about "mappable" worlds. In practical programming,
    you will almost never run into a elevated world that does not support being mapped
    over somehow.*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*因此，我更喜欢谈论“可映射”的世界。在实际编程中，你几乎永远不会遇到一个不支持以某种方式映射的提升世界。*'
- en: Variants of map
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`map`的变体'
- en: 'There are some variants of map that are common:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些常见的`map`变体：
- en: '**Const map**. A const or "replace-by" map replaces all values with a constant
    rather than the output of a function. In some cases, a specialized function like
    this can allow for a more efficient implementation.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常量映射**。常量或“替换为”映射将所有值替换为常量而不是函数的输出。在某些情况下，像这样的专门函数可以实现更高效的实现。'
- en: '**Maps that work with cross-world functions**. The map function `a->b` lives
    entirely in the normal world. But what if the function you want to map with does
    not return something in the normal world, but a value in another, different, enhanced
    world? We''ll see how to address this challenge in [a later post](elevated-world-4.html).'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与跨世界函数一起工作的映射**。映射函数 `a->b` 完全存在于正常世界中。但是，如果您要映射的函数并不在正常世界中返回值，而是在另一个不同的增强世界中返回值呢？我们将在[后续文章](elevated-world-4.html)中看到如何解决这个挑战。'
- en: '* * *'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The `return` function
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`return` 函数'
- en: '**Common Names**: `return`, `pure`, `unit`, `yield`, `point`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见名称**：`return`、`pure`、`unit`、`yield`、`point`'
- en: '**Common Operators**: None'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见运算符**：无'
- en: '**What it does**: Lifts a single value into the elevated world'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能**：将单个值提升到增强世界中'
- en: '**Signature**: `a -> E<a>`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**签名**：`a -> E<a>`'
- en: Description
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: '"return" (also known as "unit" or "pure") simply creates a elevated value from
    a normal value.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '"return"（也称为"unit"或"pure"）只是从普通值创建一个增强值。'
- en: '![](vgfp_return.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_return.png)'
- en: This function goes by many names, but I'm going to be consistent and call it
    `return` as that is the common term for it in F#, and is the term used in computation
    expressions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有很多名称，但我会保持一致，称之为`return`，因为这是 F# 中的通用术语，并且是计算表达式中使用的术语。
- en: '*NOTE: I''m ignoring the difference between `pure` and `return`, because type
    classes are not the focus of this post.*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：我忽略了`pure`和`return`之间的区别，因为类型类不是本文的重点。*'
- en: Implementation examples
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现示例
- en: 'Here are two examples of `return` implementations in F#:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 F# 中 `return` 实现的两个示例：
- en: '[PRE4]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Obviously, we don't need to define special functions like this for options and
    lists. Again, I've just done it to show what `return` might look for some common
    types.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不需要为选项和列表定义特殊函数。再次强调，我只是为了展示对于一些常见类型，`return`可能是什么样子。
- en: '* * *'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The `apply` function
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`apply` 函数'
- en: '**Common Names**: `apply`, `ap`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见名称**：`apply`、`ap`'
- en: '**Common Operators**: `<*>`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见运算符**：`<*>`'
- en: '**What it does**: Unpacks a function wrapped inside a elevated value into a
    lifted function `E<a> -> E<b>`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能**：将包装在增强值内部的函数解包为一个提升函数 `E<a> -> E<b>`'
- en: '**Signature**: `E<(a->b)> -> E<a> -> E<b>`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**签名**：`E<(a->b)> -> E<a> -> E<b>`'
- en: Description
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: '"apply" unpacks a function wrapped inside a elevated value (`E<(a->b)>`) into
    a lifted function `E<a> -> E<b>`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '"apply"将包装在增强值内部的函数（`E<(a->b)>`）解包为一个提升函数 `E<a> -> E<b>`'
- en: '![](vgfp_apply.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_apply.png)'
- en: This might seem unimportant, but is actually very valuable, as it allows you
    to lift a multi-parameter function in the normal world into a multi-parameter
    function in the elevated world, as we'll see shortly.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不重要，但实际上非常有价值，因为它允许您将正常世界中的多参数函数提升为增强世界中的多参数函数，我们很快就会看到。
- en: Alternative interpretation
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另一种解释
- en: An alternative interpretation of `apply` is that it is a *two* parameter function
    that takes a elevated value (`E<a>`) and a elevated function (`E<(a->b)>`), and
    returns a new elevated value (`E<b>`) generated by applying the function `a->b`
    to the internal elements of `E<a>`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`的另一种解释是，它是一个*双*参数函数，接受一个增强值（`E<a>`）和一个增强函数（`E<(a->b)>`），并返回通过将函数 `a->b`
    应用于 `E<a>` 的内部元素生成的新增强值（`E<b>`）。'
- en: For example, if you have a one-parameter function (`E<(a->b)>`), you can apply
    it to a single elevated parameter to get the output as another elevated value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有一个单参数函数（`E<(a->b)>`），您可以将其应用于单个增强参数，以获得输出作为另一个增强值。
- en: '![](vgfp_apply2.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_apply2.png)'
- en: If you have a two-parameter function (`E<(a->b->c)>`), you can use `apply` twice
    in succession with two elevated parameters to get the elevated output.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个两参数函数（`E<(a->b->c)>`），您可以连续使用两次 `apply`，将两个增强参数传递给它，以获得增强输出。
- en: '![](vgfp_apply3.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_apply3.png)'
- en: You can continue to use this technique to work with as many parameters as you
    wish.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续使用这种技术来处理任意数量的参数。
- en: Implementation examples
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现示例
- en: 'Here are some examples of defining `apply` for two different types in F#:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 F# 中为两种不同类型定义 `apply` 的一些示例：
- en: '[PRE5]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, rather than have names like `applyOption` and `applyList`, I have
    given the functions the same name but put them in a per-type module.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我没有像`applyOption`和`applyList`那样命名，而是给这些函数相同的名称，但将它们放在每种类型的模块中。
- en: Note that in the `List.apply` implementation, each function in the first list
    is applied to each value in the second list, resulting in a "cross-product" style
    result. That is, the list of functions `[f; g]` applied to the list of values
    `[x; y]` becomes the four-element list `[f x; f y; g x; g y]`. We'll see shortly
    that this is not the only way to do it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`List.apply`实现中，第一个列表中的每个函数被应用到第二个列表中的每个值上，从而产生“交叉积”样式的结果。也就是说，函数列表`[f;
    g]`应用到值列表`[x; y]`上会变成四元素列表`[f x; f y; g x; g y]`。我们很快就会看到这不是唯一的做法。
- en: Also, of course, I'm cheating by building this implementation on a `for..in..do`
    loop -- functionality that already exists!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我在构建这个实现时是在一个`for..in..do`循环上作弊 -- 这个功能已经存在！
- en: I did this for clarity in showing how `apply` works. It's easy enough to create
    a "from scratch" recursive implementation, (though it is not so easy to create
    one that is properly tail-recursive!) but I want to focus on the concepts not
    on the implementation for now.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以这样做是为了清楚地展示`apply`的工作原理。创建一个“从头开始”的递归实现是很容易的（虽然创建一个正确的尾递归实现并不容易！），但我现在想专注于概念而不是实现。
- en: Infix version of apply
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`apply`的中缀版本'
- en: 'Using the `apply` function as it stands can be awkward, so it is common to
    create an infix version, typically called `<*>`. With this in place you can write
    code like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现有的`apply`函数可能会很笨拙，因此通常会创建一个中缀版本，通常称为`<*>`。有了这个，你可以这样写代码：
- en: '[PRE6]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Apply vs. Map
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用与映射
- en: The combination of `apply` and `return` is considered "more powerful" than `map`,
    because if you have `apply` and `return`, you can construct `map` from them, but
    not vice versa.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`和`return`的组合被认为比`map`“更强大”，因为如果你有`apply`和`return`，你可以从它们构造`map`，但反之则不成立。'
- en: 'Here''s how it works: to construct a lifted function from a normal function,
    just use `return` on the normal function and then `apply`. This gives you the
    same result as if you had simply done `map` in the first place.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的工作原理：要从普通函数构造一个提升函数，只需在普通函数上使用`return`然后`apply`。这给你的结果与你一开始就用`map`是一样的。
- en: '![](vgfp_apply_vs_map.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_apply_vs_map.png)'
- en: This trick also means that our infix notation can be simplified a little. The
    initial `return` then `apply` can be replaced with `map`, and we so typically
    create an infix operator for `map` as well, such as `<!>` in F#.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧还意味着我们的中缀表示法可以简化一些。初始的`return`然后`apply`可以被`map`替换，我们通常也会为`map`创建一个中缀运算符，例如在
    F# 中的`<!>`。
- en: '[PRE7]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This makes the code look more like using the function normally. That is, instead
    of the normal `add x y`, we can use the similar looking `add <!> x <*> y`, but
    now `x` and `y` can be elevated values rather than normal values. Some people
    have even called this style "overloaded whitespace"!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得代码看起来更像是正常使用函数。也就是说，我们可以使用类似的方式`add <!> x <*> y`而不是正常的`add x y`，但现在`x`和`y`可以是提升的值而不是普通值。有些人甚至将这种风格称为“过载的空格”！
- en: 'Here''s one more for fun:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个有趣的例子：
- en: '[PRE8]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The properties of a correct apply/return implementation
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确的`apply`/`return`实现的属性
- en: As with `map`, a correct implementation of the `apply`/`return` pair should
    have some properties that are true no matter what elevated world we are working
    with.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与`map`一样，正确实现的`apply`/`return`对应应该具有一些性质，无论我们正在使用什么样的提升世界。
- en: There are four so-called ["Applicative Laws"](https://en.wikibooks.org/wiki/Haskell/Applicative_functors#Applicative_functor_laws),
    and an **Applicative Functor** (in the programming sense) is defined as a generic
    data type constructor -- `E<T>` -- plus a pair of functions (`apply` and `return`)
    that obey the applicative laws.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有四条所谓的["应用定律"](https://en.wikibooks.org/wiki/Haskell/Applicative_functors#Applicative_functor_laws)，而一个**Applicative
    Functor**（在编程意义上）被定义为一个通用的数据类型构造器 -- `E<T>` -- 加上一对遵守应用定律的函数（`apply`和`return`）。
- en: Just as with the laws for `map`, these laws are quite sensible. I'll show two
    of them.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对`map`的定律一样，这些定律非常明智。我会展示其中的两个。
- en: The first law says that if you take the `id` function in the normal world, and
    you lift it into the elevated world with `return`, and then you do `apply`, the
    new function, which is of type `E<a> -> E<a>`, should be the same as the `id`
    function in the elevated world.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个定律说，如果你在普通世界中使用`id`函数，并且你使用`return`将它提升到提升的世界中，然后进行`apply`，新函数，类型为`E<a> ->
    E<a>`，应该与提升的世界中的`id`函数相同。
- en: '![](vgfp_apply_law_id.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_apply_law_id.png)'
- en: The second law says that if you take a function `f` and a value `x` in the normal
    world, and you apply `f` to `x` to get a result (`y`, say), and then lift the
    result using `return`, the resulting value should be the same as if you lifted
    `f` and `x` into the elevated world *first*, and then applied them there afterwards.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个定律说，如果你拿一个函数`f`和一个普通世界中的值`x`，并将`f`应用于`x`以获得一个结果（比如`y`），然后使用`return`提升结果，那么结果值应该与如果你首先将`f`和`x`提升到提升世界中，然后在那里应用它们后相同。
- en: '![](vgfp_apply_law_homomorphism.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_apply_law_homomorphism.png)'
- en: The other two laws are not so easily diagrammed, so I won't document them here,
    but together the laws ensure that any implementation is sensible.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个定律不容易用图表表示，所以我不会在这里记录它们，但这两个定律一起确保任何实现都是合理的。
- en: '* * *'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The `liftN` family of functions
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`liftN`函数族'
- en: '**Common Names**: `lift2`, `lift3`, `lift4` and similar'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见名称**：`lift2`、`lift3`、`lift4`等'
- en: '**Common Operators**: None'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见操作符**：无'
- en: '**What it does**: Combines two (or three, or four) elevated values using a
    specified function'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能**：使用指定函数组合两个（或三个、四个）提升值'
- en: '**Signature**:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**签名**：'
- en: 'lift2: `(a->b->c) -> E<a> -> E<b> -> E<c>`,'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: lift2：`(a->b->c) -> E<a> -> E<b> -> E<c>`,
- en: 'lift3: `(a->b->c->d) -> E<a> -> E<b> -> E<c> -> E<d>`,'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: lift3：`(a->b->c->d) -> E<a> -> E<b> -> E<c> -> E<d>`,
- en: etc.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。
- en: Description
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: The `apply` and `return` functions can be used to define a series of helper
    functions `liftN` (`lift2`, `lift3`, `lift4`, etc) that take a normal function
    with N parameters (where N=2,3,4, etc) and transform it to a corresponding elevated
    function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`和`return`函数可以用来定义一系列辅助函数`liftN`（`lift2`、`lift3`、`lift4`等），这些函数接受具有N个参数的普通函数（其中N=2,3,4等）并将其转换为相应的提升函数。'
- en: Note that `lift1` is just `map`, and so it is not usually defined as a separate
    function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`lift1`只是`map`，通常不会单独定义为一个函数。
- en: 'Here''s what an implementation might look like:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实现可能看起来像的例子：
- en: '[PRE9]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here''s a visual representation of `lift2`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`lift2`的可视化表示：
- en: '![](vgfp_lift2.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_lift2.png)'
- en: The `lift` series of functions can be used to make code a bit more readable
    because, by using one of the pre-made `lift` functions, we can avoid the `<*>`
    syntax.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`lift`系列函数可以使代码更易读，因为通过使用预先制作的`lift`函数之一，我们可以避免使用`<*>`语法。'
- en: 'First, here''s an example of lifting a two-parameter function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这里有一个提升两个参数函数的例子：
- en: '[PRE10]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And here''s an example of lifting a three-parameter function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个提升三个参数函数的例子：
- en: '[PRE11]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Interpreting "lift2" as a "combiner"
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将"lift2"解释为"组合器"
- en: There is an alternative interpretation of `apply` as a "combiner" of elevated
    values, rather than as function application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种将`apply`解释为提升值的"组合器"的替代方法，而不是作为函数应用。
- en: For example, when using `lift2`, the first parameter is a parameter specifying
    how to combine the values.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当使用`lift2`时，第一个参数是指定如何组合值的参数。
- en: 'Here''s an example where the same values are combined in two different ways:
    first with addition, then with multiplication.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，其中相同的值以两种不同的方式组合：首先是加法���然后是乘法。
- en: '[PRE12]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Going further, can we eliminate the need for this first function parameter and
    have a *generic* way of combining the values?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步地，我们能否消除对这个第一个函数参数的需求，并有一种*通用*的组合值的方式？
- en: Why, yes we can! We can just use a tuple constructor to combine the values.
    When we do this we are combining the values without making any decision about
    how they will be used yet.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以！我们可以使用元组构造函数来组合值。当我们这样做时，我们在不做出任何关于它们将如何使用的决定的情况下组合值。
- en: 'Here''s what it looks like in a diagram:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它在图表中的样子：
- en: '![](vgfp_apply_combine.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_apply_combine.png)'
- en: 'and here''s how you might implement it for options and lists:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你可能为选项和列表实现它的方式：
- en: '[PRE13]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s see what happens when we use the combiners:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们使用组合器时会发生什么：
- en: '[PRE14]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have an elevated tuple, we can work with the pair in any way we
    want, we just need to use `map` to do the actual combining.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个提升的元组，我们可以以任何想要的方式处理这对值，我们只需要使用`map`来实际组合。
- en: 'Want to add the values? Just use `+` in the `map` function:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 想要添加数值吗？只需在`map`函数中使用`+`：
- en: '[PRE15]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Want to multiply the values? Just use `*` in the `map` function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 想要将值相乘吗？只需在`map`函数中使用`*`：
- en: '[PRE16]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: And so on. Obviously, real-world uses would be somewhat more interesting.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。显然，实际应用会更有趣一些。
- en: Defining `apply` in terms of `lift2`
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以`lift2`的方式定义`apply`
- en: Interestingly, the `lift2` function above can be actually used as an alternative
    basis for defining `apply`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，上面的`lift2`函数实际上可以作为定义`apply`的替代基础。
- en: That is, we can define `apply` in terms of the `lift2` function by setting the
    combining function to be just function application.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们可以根据`lift2`函数来定义`apply`，将组合函数设置为仅为函数应用。
- en: 'Here''s a demonstration of how this works for `Option`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于`Option`的演示：
- en: '[PRE17]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This alternative approach is worth knowing about because for some types it's
    easier to define `lift2` than `apply`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这种替代方法值得了解，因为对于某些类型来说，定义`lift2`比`apply`更容易。
- en: Combining missing or bad data
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合缺失或错误数据
- en: Notice that in all the combiners we've looked at, if one of the elevated values
    is "missing" or "bad" somehow, then the overall result is also bad.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在我们查看的所有组合器中，如果其中一个升高的值“缺失”或以某种方式“错误”，则整体结果也是错误的。
- en: For example, with `combineList`, if one of the parameters is an empty list,
    the result is also an empty list, and with `combineOpt`, if one of the parameters
    is `None`, the result is also `None`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于`combineList`，如果其中一个参数是空列表，则结果也是空列表，而对于`combineOpt`，如果其中一个参数是`None`，则结果也是`None`。
- en: '[PRE18]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It's possible to create an alternative kind of combiner that ignores missing
    or bad values, just as adding "0" to a number is ignored. For more information,
    see my post on ["Monoids without tears"](monoids-without-tears.html).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建一种忽略缺失或错误值的替代组合器，就像将“0”添加到数字中一样会被忽略。有关更多信息，请参阅我的文章[“不费吹灰之力的单子”](monoids-without-tears.html)。
- en: One sided combiners `<*` and `*>`
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单侧组合器`<*`和`*>`
- en: In some cases you might have two elevated values, and want to discard the value
    from one side or the other.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能有两个升高的值，并且希望丢弃其中一侧的值或另一侧的值。
- en: 'Here''s an example for lists:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是列表的示例：
- en: '[PRE19]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can then combine a 2-element list and a 3-element list to get a 6-element
    list as expected, but the contents come from only one side or the other.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将一个2元素列表和一个3元素列表组合起来，得到一个预期的6元素列表，但内容只来自一侧或另一侧。
- en: '[PRE20]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can turn this into a feature! We can replicate a value N times by crossing
    it with `[1..n]`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此转换为一个特性！我们可以通过与`[1..n]`交叉来多次复制一个值N次。
- en: '[PRE21]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Of course, this is by no means an efficient way to replicate a value, but it
    does show that starting with just the two functions `apply` and `return`, you
    can build up some quite complex behavior.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这绝不是复制值的有效方式，但它确实显示了仅从两个函数`apply`和`return`开始，您可以构建一些相当复杂的行为。
- en: On a more practical note though, why might this "throwing away data" be useful?
    Well in many cases, we might not want the values, but we *do* want the effects.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在更实际的情况下，为什么这种“丢弃数据”会有用呢？嗯，在许多情况下，我们可能不想要值，但我们*确实*想要效果。
- en: 'For example, in a parser, you might see code like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在解析器中，您可能会看到如下代码：
- en: '[PRE22]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this snippet, `readQuoteChar` means "match and read a quote character from
    the input stream" and `readNonQuoteChars` means "read a series of non-quote characters
    from the input stream".
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在此片段中，`readQuoteChar`表示“从输入流匹配并读取引号字符”，而`readNonQuoteChars`表示“从输入流读取一系列非引号字符”。
- en: When we are parsing a quoted string we want ensure the input stream that contains
    the quote character is read, but we don't care about the quote characters themselves,
    just the inner content.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解析带引号的字符串时，我们希望确保包含引号字符的输入流被读取，但我们不关心引号字符本身，只关心内部内容。
- en: Hence the use of `*>` to ignore the leading quote and `<*` to ignore the trailing
    quote.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用`*>`来忽略前导引号，使用`<*`来忽略尾随引号。
- en: '* * *'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The `zip` function and ZipList world
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`zip`函数和ZipList世界'
- en: '**Common Names**: `zip`, `zipWith`, `map2`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见名称**：`zip`，`zipWith`，`map2`'
- en: '**Common Operators**: `<*>` (in the context of ZipList world)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见运算符**：`<*>`（在ZipList世界的上下文中）'
- en: '**What it does**: Combines two lists (or other enumerables) using a specified
    function'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能**：使用指定的函数组合两个列表（或其他可枚举对象）'
- en: '**Signature**: `E<(a->b->c)> -> E<a> -> E<b> -> E<c>` where `E` is a list or
    other enumerable type, or `E<a> -> E<b> -> E<a,b>` for the tuple-combined version.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**签名**：`E<(a->b->c)> -> E<a> -> E<b> -> E<c>`，其中`E`是列表或其他可枚举类型，或者对于元组组合版本为`E<a>
    -> E<b> -> E<a,b>`。'
- en: Description
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: Some data types might have more than one valid implementation of `apply`. For
    example, there is another possible implementation of `apply` for lists, commonly
    called `ZipList` or some variant of that.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 某些数据类型可能有多个有效的`apply`实现。例如，另一种可能的列表`apply`实现通常称为`ZipList`或其变体之一。
- en: In this implementation, the corresponding elements in each list are processed
    at the same time, and then both lists are shifted to get the next element. That
    is, the list of functions `[f; g]` applied to the list of values `[x; y]` becomes
    the two-element list `[f x; g y]`
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，每个列表中对应的元素同时处理，然后两个列表都被移动以获取下一个元素。也就是说，函数列表 `[f; g]` 应用于值列表 `[x; y]`，变成了两个元素的列表
    `[f x; g y]`
- en: '[PRE23]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*WARNING: This implementation is just for demonstration. It''s not tail-recursive,
    so don''t use it for large lists!*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*警告：这个实现仅用于演示。它不是尾递归的，所以不要用于大型列表！*'
- en: If the lists are of different lengths, some implementations throw an exception
    (as the F# library functions `List.map2` and `List.zip` do), while others silently
    ignore the extra data (as the implementation above does).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表的长度不同，一些实现会抛出异常（就像 F# 库函数 `List.map2` 和 `List.zip` 做的那样），而另一些则会默默地忽略额外的数据（就像上面的实现一样）。
- en: 'Ok, let''s see it in use:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们看看它的用法：
- en: '[PRE24]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that the result is `[11; 22; 33]` -- only three elements. If we had used
    the standard `List.apply`, there would have been nine elements.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意结果是 `[11; 22; 33]` -- 只有三个元素。如果我们使用了标准的 `List.apply`，那么就会有九个元素。
- en: Interpreting "zip" as a "combiner"
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 "zip" 解释为 "组合器"
- en: We saw above that `List.apply`, or rather `List.lift2`, could be intepreted
    as a combiner. Similarly, so can `zipList`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上面看到，`List.apply`，或者更确切地说是 `List.lift2`，可以被解释为一个组合器。同样，`zipList` 也可以。
- en: '[PRE25]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that we can't just have *one* `add` function in the first list -- we have
    to have one `add` for every element in the second and third lists!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们不能在第一个列表中只有*一个* `add` 函数 -- 我们必须为第二个和第三个列表中的每个元素都有一个 `add`！
- en: That could get annoying, so often, a "tupled" version of `zip` is used, whereby
    you don't specify a combining function at all, and just get back a list of tuples
    instead, which you can then process later using `map`. This is the same approach
    as was used in the `combine` functions discussed above, but for `zipList`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会很烦人，因此通常会使用 "tupled" 版本的 `zip`，你根本不指定组合函数，只是得到一组元组的列表，稍后可以使用 `map` 处理它们。这与上面讨论的
    `combine` 函数使用的方法相同，但用于 `zipList`。
- en: ZipList world
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ZipList 世界
- en: In standard List world, there is an `apply` and a `return`. But with our different
    version of `apply` we can create a different version of List world called ZipList
    world.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准 List 世界中，有一个 `apply` 和一个 `return`。但是有了我们不同版本的 `apply`，我们可以创建一个名为 ZipList
    世界的不同版本的 List 世界。
- en: ZipList world is quite different from the standard List world.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ZipList 世界与标准 List 世界相当不同。
- en: In ZipList world, the `apply` function is implemented as above. But more interestingly,
    ZipList world has a *completely different* implementation of `return` compared
    with standard List world. In the standard List world, `return` is just a list
    with a single element, but for ZipList world, it has to be an infinitely repeated
    value!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ZipList 世界中，`apply` 函数的实现如上所述。但更有趣的是，与标准 List 世界相比，ZipList 世界对 `return` 的实现是*完全不同*的。在标准
    List 世界中，`return` 只是一个带有单个元素的列表，但对于 ZipList 世界，它必须是一个无限重复的值！
- en: 'In a non-lazy language like F#, we can''t do this, but if we replace `List`
    with `Seq` (aka `IEnumerable`) then we *can* create an infinitely repeated value,
    as shown below:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 F# 这样的非惰性语言中，我们不能这样做，但是如果我们用 `Seq`（也就是 `IEnumerable`）替换 `List`，那么我们*可以*创建一个无限重复的值，如下所示：
- en: '[PRE26]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This example demonstrates that an elevated world is *not* just a data type (like
    the List type) but consists of the datatype *and* the functions that work with
    it. In this particular case, "List world" and "ZipList world" share the same data
    type but have quite different environments.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了，一个高级世界不仅仅是一个数据类型（比如 List 类型），而是由数据类型*和*与之配套的函数组成。在这个特殊情况下，"List 世界"
    和 "ZipList 世界" 共享相同的数据类型，但具有完全不同的环境。
- en: What types support `map` and `apply` and `return`?
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪些类型支持 `map` 和 `apply` 和 `return`？
- en: So far we have defined all these useful functions in an abstract way. But how
    easy is it to find real types that have implementations of them, including all
    the various laws?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们以抽象的方式定义了所有这些有用的函数。但是找到具有它们实现的真实类型，包括所有各种法则，有多容易呢？
- en: 'The answer is: very easy! In fact *almost all* types support these set of functions.
    You''d be hard-pressed to find a useful type that didn''t.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是：非常容易！事实上*几乎所有*类型都支持这组函数。你会很难找到一个没有用的类型。
- en: That means that `map` and `apply` and `return` are available (or can be easily
    implemented) for standard types such as `Option`, `List`, `Seq`, `Async`, etc.,
    and also any types you are likely to define yourself.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`map`、`apply`和`return`可用（或可以轻松实现）于标准类型，如`Option`、`List`、`Seq`、`Async`等，以及您可能自己定义的任何类型。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this post, I described three core functions for lifting simple "normal"
    values to elevated worlds: `map`, `return`, and `apply`, plus some derived functions
    like `liftN` and `zip`.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我描述了将简单的“普通”值提升到提升世界的三个核心函数：`map`、`return`和`apply`，以及一些派生函数，如`liftN`和`zip`。
- en: In practice however, things are not that simple. We frequently have to work
    with functions that cross between the worlds. Their input is in the normal world
    but their output is in the elevated world.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在实践中，事情并不那么简单。我们经常不得不处理跨越世界的函数。它们的输入在普通世界中，但输出在提升世界中。
- en: In the [next post](elevated-world-2.html) we'll show how these world-crossing
    functions can be lifted to the elevated world as well.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在[下一篇文章](elevated-world-2.html)中，我们将展示如何将这些跨世界函数提升到提升世界中。
- en: Understanding bind
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解绑定
- en: Understanding bind
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解绑定
- en: This post is the second in a series. In the [previous post](elevated-world.html),
    I described some of the core functions for lifting a value from a normal world
    to an elevated world.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 本文是系列文章中的第二篇。在[上一篇文章](elevated-world.html)中，我描述了一些将值从普通世界提升到提升世界的核心函数。
- en: In this post, we'll look at "world-crossing" functions, and how they can be
    tamed with the `bind` function.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将探讨“跨越世界”的函数，以及如何使用`bind`函数来驯服它们。
- en: Series contents
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系列内容
- en: 'Here''s a list of shortcuts to the various functions mentioned in this series:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是此系列中提到的各种函数的快捷方式列表：
- en: '**Part 1: Lifting to the elevated world**'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一部分：提升到提升世界**'
- en: '[The `map` function](elevated-world.html#map)'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[映射（`map`）函数](elevated-world.html#map)'
- en: '[The `return` function](elevated-world.html#return)'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[返回（`return`）函数](elevated-world.html#return)'
- en: '[The `apply` function](elevated-world.html#apply)'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[应用（`apply`）函数](elevated-world.html#apply)'
- en: '[The `liftN` family of functions](elevated-world.html#lift)'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`liftN`函数族](elevated-world.html#lift)'
- en: '[The `zip` function and ZipList world](elevated-world.html#zip)'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`zip`函数和ZipList世界](elevated-world.html#zip)'
- en: '**Part 2: How to compose world-crossing functions**'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二部分：如何编写跨世界函数**'
- en: '[The `bind` function](elevated-world-2.html#bind)'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[绑定（`bind`）函数](elevated-world-2.html#bind)'
- en: '[List is not a monad. Option is not a monad.](elevated-world-2.html#not-a-monad)'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[列表不是单子。选项不是单子。](elevated-world-2.html#not-a-monad)'
- en: '**Part 3: Using the core functions in practice**'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三部分：实践中使用核心函数**'
- en: '[Independent and dependent data](elevated-world-3.html#dependent)'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[独立和依赖数据](elevated-world-3.html#dependent)'
- en: '[Example: Validation using applicative style and monadic style](elevated-world-3.html#validation)'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：使用应用风格和单子风格进行验证](elevated-world-3.html#validation)'
- en: '[Lifting to a consistent world](elevated-world-3.html#consistent)'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提升到一致的世界](elevated-world-3.html#consistent)'
- en: '[Kleisli world](elevated-world-3.html#kleisli)'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kleisli世界](elevated-world-3.html#kleisli)'
- en: '**Part 4: Mixing lists and elevated values**'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第四部分：混合列表和提升值**'
- en: '[Mixing lists and elevated values](elevated-world-4.html#mixing)'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[混合列表和提升值](elevated-world-4.html#mixing)'
- en: '[The `traverse`/`MapM` function](elevated-world-4.html#traverse)'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[遍历（`traverse`）/`MapM`函数](elevated-world-4.html#traverse)'
- en: '[The `sequence` function](elevated-world-4.html#sequence)'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[序列（`sequence`）函数](elevated-world-4.html#sequence)'
- en: '["Sequence" as a recipe for ad-hoc implementations](elevated-world-4.html#adhoc)'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“序列”作为临时实现的配方](elevated-world-4.html#adhoc)'
- en: '[Readability vs. performance](elevated-world-4.html#readability)'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可读性与性能](elevated-world-4.html#readability)'
- en: '[Dude, where''s my `filter`?](elevated-world-4.html#filter)'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[伙计，我的`filter`在哪里？](elevated-world-4.html#filter)'
- en: '**Part 5: A real-world example that uses all the techniques**'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第五部分：使用所有技术的真实示例**'
- en: '[Example: Downloading and processing a list of websites](elevated-world-5.html#asynclist)'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：下载和处理网站列表](elevated-world-5.html#asynclist)'
- en: '[Treating two worlds as one](elevated-world-5.html#asyncresult)'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将两个世界视为一个](elevated-world-5.html#asyncresult)'
- en: '**Part 6: Designing your own elevated world**'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第六部分：设计您自己的提升世界**'
- en: '[Designing your own elevated world](elevated-world-6.html#part6)'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[设计您自己的提升世界](elevated-world-6.html#part6)'
- en: '[Filtering out failures](elevated-world-6.html#filtering)'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[过滤失败](elevated-world-6.html#filtering)'
- en: '[The Reader monad](elevated-world-6.html#readermonad)'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[读取器单子](elevated-world-6.html#readermonad)'
- en: '**Part 7: Summary**'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第七部分：总结**'
- en: '[List of operators mentioned](elevated-world-7.html#operators)'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提到的运算符列表](elevated-world-7.html#operators)'
- en: '[Further reading](elevated-world-7.html#further-reading)'
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[进一步阅读](elevated-world-7.html#further-reading)'
- en: '* * *'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Part 2: How to compose world-crossing functions'
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '第二部分: 如何组合跨世界函数'
- en: '* * *'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The `bind` function
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`bind` 函数'
- en: '**Common Names**: `bind`, `flatMap`, `andThen`, `collect`, `SelectMany`'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见名称**: `bind`, `flatMap`, `andThen`, `collect`, `SelectMany`'
- en: '**Common Operators**: `>>=` (left to right), `=<<` (right to left )'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见操作符**: `>>=` (从左到右), `=<<` (从右到左)'
- en: '**What it does**: Allows you to compose world-crossing ("monadic") functions'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能**: 允许您组合跨世界（“单子”）函数'
- en: '**Signature**: `(a->E<b>) -> E<a> -> E<b>`. Alternatively with the parameters
    reversed: `E<a> -> (a->E<b>) -> E<b>`'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**签名**: `(a->E<b>) -> E<a> -> E<b>`。或者参数颠倒: `E<a> -> (a->E<b>) -> E<b>`'
- en: Description
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: We frequently have to deal with functions that cross between the normal world
    and the elevated world.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要处理在正常世界和提升世界之间穿越的函数。
- en: 'For example: a function that parses a `string` to an `int` might return an
    `Option<int>` rather than a normal `int`, a function that reads lines from a file
    might return `IEnumerable<string>`, a function that fetches a web page might return
    `Async<string>`, and so on.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '例如: 一个将`string`解析为`int`的函数可能返回一个`Option<int>`而不是普通的`int`，一个从文件中读取行的函数可能返回`IEnumerable<string>`，一个获取网页的函数可能返回`Async<string>`，等等。'
- en: These kinds of "world-crossing" functions are recognizable by their signature
    `a -> E<b>`; their input is in the normal world but their output is in the elevated
    world. Unfortunately, this means that these kinds of functions cannot be linked
    together using standard composition.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这类“跨世界”函数以它们的签名`a -> E<b>`可识别; 它们的输入在正常世界，但它们的输出在提升世界。不幸的是，这意味着这类函数不能使用标准组合链接在一起。
- en: '![](vgfp_bind_noncomposition.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_bind_noncomposition.png)'
- en: What "bind" does is transform a world-crossing function (commonly known as a
    "monadic function") into a lifted function `E<a> -> E<b>`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: “bind”的作用是将一个跨世界函数（通常称为“单子函数”）转换为一个提升的函数 `E<a> -> E<b>`。
- en: '![](vgfp_bind.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_bind.png)'
- en: The benefit of doing this is that the resulting lifted functions live purely
    in the elevated world, and so can be combined easily by composition.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是生成的提升函数纯粹存在于提升世界中，因此可以轻松地通过组合结合在一起。
- en: For example, a function of type `a -> E<b>` cannot be directly composed with
    a function of type `b -> E<c>`, but after `bind` is used, the second function
    becomes of type `E<b> -> E<c>`, which *can* be composed.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，类型为 `a -> E<b>` 的函数不能直接与类型为 `b -> E<c>` 的函数组合，但在使用 `bind` 后，第二个函数变成了类型为 `E<b>
    -> E<c>` 的函数，可以进行组合。
- en: '![](vgfp_bind_composition.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_bind_composition.png)'
- en: In this way, `bind` lets us chain together any number of monadic functions.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`bind`让我们能够链式地连接任意数量的单子函数。
- en: Alternative interpretation
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另一种解释
- en: An alternative interpretation of `bind` is that it is a *two* parameter function
    that takes a elevated value (`E<a>`) and a "monadic function" (`a -> E<b>`), and
    returns a new elevated value (`E<b>`) generated by "unwrapping" the value inside
    the input, and running the function `a -> E<b>` against it. Of course, the "unwrapping"
    metaphor does not work for every elevated world, but still it can often be useful
    to think of it this way.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `bind` 的另一种解释是，它是一个 *双* 参数函数，它接受一个提升的值（`E<a>`）和一个“单子函数”（`a -> E<b>`），并返回通过“解包”输入中的值，并对其运行函数
    `a -> E<b>` 生成的新提升值（`E<b>`）。当然，“解包”这个隐喻并不适用于每一个提升世界，但仍然经常有用地这样思考它。
- en: '![](vgfp_bind2.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_bind2.png)'
- en: Implementation examples
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现示例
- en: 'Here are some examples of defining `bind` for two different types in F#:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '这里是在 F# 中为两种不同类型定义 `bind` 的一些例子:'
- en: '[PRE27]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Notes:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '注:'
- en: Of course, in these two particular cases, the functions already exist in F#,
    called `Option.bind` and `List.collect`.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，在这两种特定情况下，这些函数已经存在于 F# 中，称为 `Option.bind` 和 `List.collect`。
- en: For `List.bind` I'm cheating again and using `for..in..do`, but I think that
    this particular implementation shows clearly how bind works with lists. There
    is a purer recursive implementation, but I won't show that here.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `List.bind`，我又作弊了，使用了`for..in..do`，但我认为这个特定的实现清楚地展示了绑定如何与列表一起工作。有一个更纯净的递归实现，但我不会在这里展示它。
- en: Usage example
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用示例
- en: As explained at the beginning of this section, `bind` can be used to compose
    cross-world functions. Let's see how this works in practice with a simple example.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节开头所解释的，`bind`可以用来组合跨世界函数。让我们通过一个简单的例子来看看这是如何实践的。
- en: 'First let''s say we have a function that parses certain `string`s into `int`s.
    Here''s a very simple implementation:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '首先让我们假设我们有一个将特定的`string`解析为`int`的函数。这是一个非常简单的实现:'
- en: '[PRE28]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Sometimes it returns a int, sometimes not. So the signature is `string -> int
    option` -- a cross-world function.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 有时它返回一个int，有时不返回。因此签名是`string -> int option` -- 一个跨世界函数。
- en: 'And let''s say we have another function that takes an `int` as input and returns
    a `OrderQty` type:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有另一个以`int`为输入并返回`OrderQty`类型的函数：
- en: '[PRE29]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Again, it might not return an `OrderQty` if the input is not positive. The signature
    is therefore `int -> OrderQty option` -- another cross-world function.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果输入不是正数，它可能不会返回`OrderQty`。因此签名是`int -> OrderQty option` -- 另一个跨世界函数。
- en: Now, how can we create a function that starts with an string and returns an
    `OrderQty` in one step?
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何创建一个从字符串开始并在一步中返回`OrderQty`的函数？
- en: The output of `parseInt` cannot be fed directly into `toOrderQty`, so this is
    where `bind` comes to the rescue!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseInt`的输出不能直接输入`toOrderQty`，这就是`bind`发挥作用的地方！'
- en: Doing `Option.bind toOrderQty` lifts it to a `int option -> OrderQty option`
    function and so the output of `parseInt` can be used as input, just as we need.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`Option.bind toOrderQty`将其提升为一个`int option -> OrderQty option`函数，因此`parseInt`的输出可以作为输入使用，正如我们需要的那样。
- en: '[PRE30]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The signature of our new `parseOrderQty` is `string -> OrderQty option`, yet
    another cross-world function. So if we want to do something with the `OrderQty`
    that is output we may well have to use `bind` again on the next function in the
    chain.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的`parseOrderQty`的签名是`string -> OrderQty option`，又一个跨世界函数。因此，如果我们想对输出的`OrderQty`做些什么，我们很可能需要在链中的下一个函数上再次使用`bind`。
- en: Infix version of bind
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`bind`的中缀版本'
- en: As with `apply`, using the named `bind` function can be awkward, so it is common
    to create an infix version, typically called `>>=` (for left to right data flow)
    or `=<<` (for right to left data flow) .
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 与`apply`一样，使用命名的`bind`函数可能会很麻烦，因此通常创建一个中缀版本，通常称为`>>=`（用于左到右数据流）或`=<<`（用于右到左数据流）。
- en: 'With this in place you can write an alternative version of `parseOrderQty`
    like this:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，你可以像这样编写`parseOrderQty`的另一种版本：
- en: '[PRE31]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can see that `>>=` performs the same kind of role as pipe (`|>`) does, except
    that it works to pipe "elevated" values into cross-world functions.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`>>=`扮演的角色与管道(`|>`)相同，只是它用于将"提升"值传递给跨世界函数。
- en: Bind as a "programmable semicolon"
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`bind`作为一个"可编程分号"'
- en: 'Bind can be used to chain any number of functions or expressions together,
    so you often see code looking something like this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`可以用来链接任意数量的函数或表达式，因此你经常看到类似这样的代码：'
- en: '[PRE32]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is not too different from how an imperative program might look if you
    replace the `>>=` with a `;`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这与将`>>=`替换为`;`后的命令式程序看起来并没有太大的不同：
- en: '[PRE33]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Because of this, `bind` is sometimes called a "programmable semicolon".
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有时将`bind`称为"可编程分号"。
- en: Language support for bind/return
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对`bind/return`的语言支持
- en: Most functional programming languages have some kind of syntax support for `bind`
    that lets you avoid having to write a series of continuations or use explicit
    binds.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数函数式编程语言都有某种形式的语法支持`bind`，让你避免编写一系列的延续或使用显式的绑定。
- en: 'In F# it is (one component) of computation expressions, so the following explicit
    chaining of `bind`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在F#中，它是计算表达式的一个组件，因此以下显式的`bind`链接：
- en: '[PRE34]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'becomes implicit, using `let!` syntax:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 变得隐式，使用`let!`语法：
- en: '[PRE35]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In Haskell, the equivalent is the "do notation":'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell中，等价的是"do notation"：
- en: '[PRE36]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And in Scala, the equivalent is the "for comprehension":'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，等价的是"for comprehension"：
- en: '[PRE37]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It's important to emphasize that you do not *have* to use the special syntax
    when using bind/return. You can always use `bind` or `>>=` in the same way as
    any other function.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 强调重要的是，当使用`bind/return`时，你不一定*必须*使用特殊的语法。你始终可以像使用任何其他函数一样使用`bind`或`>>=`��
- en: Bind vs. Apply vs. Map
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Bind vs. Apply vs. Map
- en: The combination of `bind` and `return` are considered even more powerful than
    `apply` and `return`, because if you have `bind` and `return`, you can construct
    `map` and `apply` from them, but not vice versa.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`和`return`的组合被认为比`apply`和`return`更强大，因为如果你有`bind`和`return`，你可以从中构建`map`和`apply`，但反之则不行。'
- en: 'Here''s how bind can be used to emulate `map`, for example:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`bind`如何用来模拟`map`的示例：
- en: First, you construct a world-crossing function from a normal function by applying
    `return` to the output.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，通过将输出应用于`return`，从普通函数构造一个跨世界函数。
- en: Next, convert this world-crossing function into a lifted function using `bind`.
    This gives you the same result as if you had simply done `map` in the first place.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，使用`bind`将这个跨世界函数转换为一个提升函数。这将给你与一开始使用`map`时相同的结果。
- en: '![](vgfp_bind_vs_map.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_bind_vs_map.png)'
- en: 'Similarly, `bind` can emulate `apply`. Here is how `map` and `apply` can be
    defined using `bind` and `return` for Options in F#:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`bind`可以模拟`apply`。以下是如何为F#中的Options使用`bind`和`return`定义`map`和`apply`：
- en: '[PRE38]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At this point, people often ask "why should I use `apply` instead of `bind`
    when `bind` is more powerful?"
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，人们经常会问：“为什么在`bind`更强大的情况下，我应该使用`apply`呢？”
- en: The answer is that just because `apply` *can* be emulated by `bind`, doesn't
    mean it *should* be. For example, it is possible to implement `apply` in a way
    that cannot be emulated by a `bind` implementation.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，仅仅因为`apply` *可以*被`bind`模拟，并不意味着它*应该*被模拟。例如，可以以一种无法被`bind`实现模拟的方式实现`apply`。
- en: In fact, using `apply` ("applicative style") or `bind` ("monadic style") can
    have a profound effect on how your program works! We'll discuss these two approaches
    in more detail in [part 3 of this post](elevated-world-3.html#dependent).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使用`apply`（“应用风格”）或`bind`（“单子风格”）对程序的工作方式有着深远的影响！我们将在[本文第3部分](elevated-world-3.html#dependent)中更详细地讨论这两种方法。
- en: The properties of a correct bind/return implementation
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确的`bind`/`return`实现的属性
- en: As with `map`, and as with `apply`/`return`, a correct implementation of the
    `bind`/`return` pair should have some properties that are true no matter what
    elevated world we are working with.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`map`一样，以及`apply`/`return`一样，`bind`/`return`对的正确实现应该具有一些性质，无论我们正在处理哪个升级世界。
- en: 'There are three so-called ["Monad Laws"](https://en.wikibooks.org/wiki/Haskell/Understanding_monads#Monad_Laws),
    and one way of defining a **Monad** (in the programming sense) is to say that
    it consists of three things: a generic type constructor `E<T>` plus a pair of
    functions (`bind` and `return`) that obey the monad laws. This is not the only
    way to define a monad, and mathematicians typically use a slightly different definition,
    but this one is most useful to programmers.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个所谓的["单子律"](https://en.wikibooks.org/wiki/Haskell/Understanding_monads#Monad_Laws)，定义**Monad**（在编程意义上）的一种方式是说它由三个部分组成：一个通用类型构造器`E<T>`加上一对遵守单子律的函数（`bind`和`return`）。这不是定义单子的唯一方式，数学家通常使用略有不同的定义，但对程序员来说，这种定义最有用。
- en: Just as with the the Functor and Applicative laws we saw earlier, these laws
    are quite sensible.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前看到的函子和应用律一样，这些律法是相当合理的。
- en: 'First, note that `return` function is itself a cross-world function:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意`return`函数本身就是一个跨世界函数：
- en: '![](vgfp_monad_law1_a.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_monad_law1_a.png)'
- en: That means that we can use `bind` to lift it into a function in the elevated
    world. And what does this lifted function do? Hopefully, nothing! It should just
    return its input.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以使用`bind`将其提升到升级世界中的函数中。这个提升的函数做什么？希望什么都不做！它应该只是返回其输入。
- en: 'So that is exactly the first monad law: it says that this lifted function must
    be the same as the `id` function in the elevated world.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是第一个单子律：它说这个提升的函数必须与升级世界中的`id`函数相同。
- en: '![](vgfp_monad_law1_b.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_monad_law1_b.png)'
- en: The second law is similar but with `bind` and `return` reversed. Say that we
    have a normal value `a` and cross-world function `f` that turns an `a` into a
    `E<b>`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个律则是类似的，但是`bind`和`return`被颠倒了。假设我们有一个普通值`a`和一个跨世界函数`f`，将`a`转换为`E<b>`。
- en: '![](vgfp_monad_law2_a.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_monad_law2_a.png)'
- en: Let's lift both of them to the elevated world, using `bind` on `f` and `return`
    on `a`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将它们都提升到升级世界中，使用`bind`在`f`上和`return`在`a`上。
- en: '![](vgfp_monad_law2_b.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_monad_law2_b.png)'
- en: Now if we apply the elevated version of `f` to the elevated verson of `a` we
    get some value `E<b>`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们将`f`的升级版本应用于`a`的升级版本，我们会得到一些值`E<b>`。
- en: '![](vgfp_monad_law2_c.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_monad_law2_c.png)'
- en: On the other hand if we apply the normal version of `f` to the normal verson
    of `a` we *also* get some value `E<b>`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们将`f`的普通版本应用于`a`的普通版本，我们同样会得到一些值`E<b>`。
- en: '![](vgfp_monad_law2_d.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_monad_law2_d.png)'
- en: The second monad law says that these two elevated values (`E<b>`) should be
    the same. In other words, all this binding and returning should not distort the
    data.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个单子律说这两个升级值（`E<b>`）应该是相同的。换句话说，所有这些绑定和返回不应该扭曲数据。
- en: The third monad law is about associativity.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个单子律是关于结合性的。
- en: In the normal world, function composition is associative. For example, we could
    pipe a value into a function `f` and then take that result and pipe it into another
    function `g`. Alternatively, we can compose `f` and `g` first into a single function
    and then pipe `a` into it.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常世界中，函数组合是结合的。例如，我们可以将一个值传递给函数`f`，然后���该结果传递给另一个函数`g`。或者，我们可以首先将`f`和`g`组合成一个单一函数，然后将`a`传递给它。
- en: '[PRE39]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the normal world, we expect both of these alternatives to give the same answer.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常世界中，我们期望这两种替代方案给出相同的答案。
- en: 'The third monad law says that, after using `bind` and `return`, the grouping
    doesn''t matter either. The two examples below correspond to the examples above:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个单子定律表示，在使用`bind`和`return`之后，分组也不重要。下面的两个示例对应上面的示例：
- en: '[PRE40]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: And again, we expect both of these to give the same answer.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 而且再次，我们期望这两者给出相同的答案。
- en: '* * *'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: List is not a monad. Option is not a monad.
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: List不是单子。Option也不是单子。
- en: If you look at the definition above, a monad has a type constructor (a.k.a "generic
    type") *and* two functions *and* a set of properties that must be satisfied.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看上面的定义，一个单子有一个类型构造函数（也称为“泛型类型”）*和*两个函数*和*一组必须满足的属性。
- en: The `List` data type is therefore just one component of a monad, as is the `Option`
    data type. `List` and `Option`, by themselves, are not monads.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`List`数据类型只是单子的一个组成部分，就像`Option`数据类型一样。`List`和`Option`本身并不是单子。
- en: It might be better to think of a monad as a *transformation*, so that the "List
    monad" is the transformation that converts the normal world to the elevated "List
    world", and the "Option monad" is the transformation that converts the normal
    world to the elevated "Option world".
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 或许更好的想法是将单子视为一种*转换*，因此，“List单子”是将正常世界转换为升高的“List世界”的转换，“Option单子”是将正常世界转换为升高的“Option世界”的转换。
- en: 'I think this is where a lot of the confusion comes in. The word "List" can
    mean many different things:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这就是很多混淆的来源。单词“List”可以有许多不同的含义：
- en: A concrete type or data structure such as `List<int>`.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个具体的类型或数据结构，比如`List<int>`。
- en: 'A type constructor (generic type): `List<T>`.'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个类型构造函数（泛型类型）：`List<T>`。
- en: A type constructor and some operations, such as a `List` class or module.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个类型构造函数和一些操作，比如一个`List`类或模块。
- en: A type constructor and some operations and the operations satisfy the monad
    laws.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个类型构造函数和一些操作，这些操作满足单子定律。
- en: Only the last one is a monad! The other meanings are valid but contribute to
    the confusion.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 只有最后一个是单子！其他含义都是有效的，但会增加混淆。
- en: Also the last two cases are hard to tell apart by looking at the code. Unfortunately,
    there have been cases where implementations did not satisfy the monad laws. Just
    because it's a "Monad" doesn't mean that it's a monad.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 而且通过查看代码，最后两种情况很难区分。不幸的是，有些情况下实现并不满足单子定律。仅仅因为它是一个“单子”，并不意味着它是一个单子。
- en: Personally, I try to avoid using the word "monad" on this site and focus on
    the `bind` function instead, as part of a toolkit of functions for solving problems
    rather than an abstract concept.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我尽量避免在本网站上使用“单子”这个词，而是专注于`bind`函数，将其视为解决问题的一套工具函数的一部分，而不是一个抽象概念。
- en: 'So don''t ask: Do I have a monad?'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 所以不要问：我有单子吗？
- en: 'Do ask: Do I have useful bind and return functions? And are they implemented
    correctly?'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 请问：我有有用的绑定和返回函数吗？它们是否被正确实现了？
- en: '* * *'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Summary
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'We now have a set of four core functions: `map`, `return`, `apply`, and `bind`,
    and I hope that you are clear on what each one does.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一组四个核心函数：`map`、`return`、`apply`和`bind`，我希望你清楚地知道每个函数的作用。
- en: But there are some questions that have not been addressed yet, such as "why
    should I choose `apply` instead of `bind`?", or "how can I deal with multiple
    elevated worlds at the same time?"
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有一些问题尚未解决，比如“为什么我应该选择`apply`而不是`bind`？”或者“我如何处理多个升高的世界？”
- en: In the [next post](elevated-world-3.html) we'll address these questions and
    demonstrate how to use the toolset with a series of practical examples.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在[下一篇文章](elevated-world-3.html)中，我们将解决这些问题，并演示如何使用这套工具集进行一系列实际示例。
- en: '*UPDATE: Fixed error in monad laws pointed out by @joseanpg. Thanks!*'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '*更新：修复了由@joseanpg指出的单子定律中的错误。谢谢！*'
- en: Using the core functions in practice
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实践中使用核心函数
- en: Using the core functions in practice
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实践中使用核心函数
- en: 'This post is the third in a series. In the [previous two posts](elevated-world.html),
    I described some of the core functions for dealing with generic data types: `map`,
    `apply`, `bind`, and so on.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 本文是系列的第三篇。在[前两篇文章](elevated-world.html)中，我描述了处理通用数据类型的一些核心函数：`map`、`apply`、`bind`等等。
- en: In this post, I'll show how to use these functions in practice, and will explain
    the difference between the so-called "applicative" and "monadic" styles.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我将展示如何在实践中使用这些函数，并解释所谓的“应用”和“单子”风格之间的区别。
- en: Series contents
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系列内容
- en: 'Here''s a list of shortcuts to the various functions mentioned in this series:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了本系列中提到的各种函数的快捷方式：
- en: '**Part 1: Lifting to the elevated world**'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 1 部分：提升到提升世界**'
- en: '[The `map` function](elevated-world.html#map)'
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[The `map` function](elevated-world.html#map)'
- en: '[The `return` function](elevated-world.html#return)'
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[The `return` function](elevated-world.html#return)'
- en: '[The `apply` function](elevated-world.html#apply)'
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[The `apply` function](elevated-world.html#apply)'
- en: '[The `liftN` family of functions](elevated-world.html#lift)'
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[The `liftN` family of functions](elevated-world.html#lift)'
- en: '[The `zip` function and ZipList world](elevated-world.html#zip)'
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[The `zip` function and ZipList 世界](elevated-world.html#zip)'
- en: '**Part 2: How to compose world-crossing functions**'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 2 部分：如何组合跨世界函数**'
- en: '[The `bind` function](elevated-world-2.html#bind)'
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[The `bind` function](elevated-world-2.html#bind)'
- en: '[List is not a monad. Option is not a monad.](elevated-world-2.html#not-a-monad)'
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[列表不是一个单调。选项不是一个单调。](elevated-world-2.html#not-a-monad)'
- en: '**Part 3: Using the core functions in practice**'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 3 部分：在实践中使用核心函数**'
- en: '[Independent and dependent data](elevated-world-3.html#dependent)'
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[独立和依赖数据](elevated-world-3.html#dependent)'
- en: '[Example: Validation using applicative style and monadic style](elevated-world-3.html#validation)'
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：使用应用程序样式和单调样式进行验证](elevated-world-3.html#validation)'
- en: '[Lifting to a consistent world](elevated-world-3.html#consistent)'
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提升到一致的世界](elevated-world-3.html#consistent)'
- en: '[Kleisli world](elevated-world-3.html#kleisli)'
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kleisli 世界](elevated-world-3.html#kleisli)'
- en: '**Part 4: Mixing lists and elevated values**'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 4 部分：混合列表和提升值**'
- en: '[Mixing lists and elevated values](elevated-world-4.html#mixing)'
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[混合列表和提升值](elevated-world-4.html#mixing)'
- en: '[The `traverse`/`MapM` function](elevated-world-4.html#traverse)'
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[The `traverse`/`MapM` function](elevated-world-4.html#traverse)'
- en: '[The `sequence` function](elevated-world-4.html#sequence)'
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[The `sequence` function](elevated-world-4.html#sequence)'
- en: '["Sequence" as a recipe for ad-hoc implementations](elevated-world-4.html#adhoc)'
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '["序列" 作为临时实现的配方](elevated-world-4.html#adhoc)'
- en: '[Readability vs. performance](elevated-world-4.html#readability)'
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可读性 vs. 性能](elevated-world-4.html#readability)'
- en: '[Dude, where''s my `filter`?](elevated-world-4.html#filter)'
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[小伙子，我的 `filter` 呢？](elevated-world-4.html#filter)'
- en: '**Part 5: A real-world example that uses all the techniques**'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 5 部分：使用所有技术的真实示例**'
- en: '[Example: Downloading and processing a list of websites](elevated-world-5.html#asynclist)'
  id: totrans-473
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：下载和处理网站列表](elevated-world-5.html#asynclist)'
- en: '[Treating two worlds as one](elevated-world-5.html#asyncresult)'
  id: totrans-474
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将两个世界视为一个](elevated-world-5.html#asyncresult)'
- en: '**Part 6: Designing your own elevated world**'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 6 部分：设计您自己的提升世界**'
- en: '[Designing your own elevated world](elevated-world-6.html#part6)'
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[设计您自己的提升世界](elevated-world-6.html#part6)'
- en: '[Filtering out failures](elevated-world-6.html#filtering)'
  id: totrans-477
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[过滤出失败](elevated-world-6.html#filtering)'
- en: '[The Reader monad](elevated-world-6.html#readermonad)'
  id: totrans-478
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Reader 单调](elevated-world-6.html#readermonad)'
- en: '**Part 7: Summary**'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 7 部分：摘要**'
- en: '[List of operators mentioned](elevated-world-7.html#operators)'
  id: totrans-480
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提到的运算符列表](elevated-world-7.html#operators)'
- en: '[Further reading](elevated-world-7.html#further-reading)'
  id: totrans-481
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[进一步阅读](elevated-world-7.html#further-reading)'
- en: '* * *'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Part 3: Using the core functions in practice'
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 部分：在实践中使用核心函数
- en: Now that we have the basic tools for lifting normal values to elevated values
    and working with cross-world functions, it's time to start working with them!
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了将普通值提升到提升值并处理跨世界函数的基本工具，是时候开始使用它们了！
- en: In this section, we'll look at some examples how these functions are actually
    used.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一些实际使用这些函数的示例。
- en: '* * *'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Independent vs. dependent data
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立 vs. 依赖数据
- en: I briefly mentioned earlier that there is a important difference between using
    `apply` and `bind`. Let's go into this now.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前简要提到使用 `apply` 和 `bind` 之间存在重要区别。现在让我们深入探讨一下。
- en: When using `apply`, you can see that each parameter (`E<a>`, `E<b>`) is completely
    independent of the other. The value of `E<b>` does not depend on what `E<a>` is.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `apply` 时，您可以看到每个参数（`E<a>`、`E<b>`）完全独立于其他参数。`E<b>` 的值不取决于 `E<a>` 是什么。
- en: '![](vgfp_apply3.png)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_apply3.png)'
- en: On the other hand, when using `bind`, the value of `E<b>` *does* depend on what
    `E<a>` is.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当使用 `bind` 时，`E<b>` 的值 *确实* 取决于 `E<a>` 是什么。
- en: '![](vgfp_bind.png)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_bind.png)'
- en: 'The distinction between working with independent values or dependent values
    leads to two different styles:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 处理独立值或依赖值之间的区别导致了两种不同的样式：
- en: The so-called "applicative" style uses functions such as `apply`, `lift`, and
    `combine` where each elevated value is independent.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所谓的“应用程序”样式使用诸如 `apply`、`lift` 和 `combine` 的函数，其中每个提升值都是独立的。
- en: The so-called "monadic" style uses functions such as `bind` to chain together
    functions that are dependent on a previous value.
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所谓的“单调”样式使用诸如 `bind` 的函数将依赖于前一个值的函数链接在一起。
- en: What does that mean in practice? Well, let's look at an example where you could
    choose from both approaches.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上这意味着什么呢？好吧，让我们看一个例子，你可以从两种方法中选择。
- en: Say that you have to download data from three websites and combine them. And
    say that we have an action, say `GetURL`, that gets the data from a website on
    demand.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你必须从三个网站下载数据并将它们组合起来。再假设我们有一个动作，比如`GetURL`，它会按需从网站获取数据。
- en: 'Now you have a choice:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个选择：
- en: '**Do you want to fetch all the URLs in parallel?** If so, treat the `GetURL`s
    as independent data and use the applicative style.'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你想要并行获取所有URL吗？** 如果是这样，请将`GetURL`视为独立数据并使用应用风格。'
- en: '**Do you want to fetch each URL one at a time, and skip the next in line if
    the previous one fails?** If so, treat the `GetURL`s as dependent data and use
    the monadic style. This linear approach will be slower overall than the "applicative"
    version above, but will also avoid unnecessary I/O.'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你想要一次获取一个URL，并在前一个失败时跳过下一个吗？** 如果是这样，请将`GetURL`视为依赖数据并使用单调风格。这种线性方法总体上会比上面的“应用”版本慢，但也会避免不必要的I/O。'
- en: '**Does the URL for the next site depend on what you download from the previous
    site?** In this case, you are *forced* to use "monadic" style, because each `GetURL`
    depends on the output of the previous one.'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下一个网站的URL是否取决于你从前一个网站下载的内容？** 在这种情况下，你被*迫*使用“单调”风格，因为每个`GetURL`取决于前一个的输出。'
- en: As you can see, the choice between applicative style and monadic style is not
    clear cut; it depends on what you want to do.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，选择应用风格和单调风格之间并不是一成不变的；它取决于你想做什么。
- en: We'll look at a real implementation of this example in the [final post of this
    series](elevated-world-5.html#asynclist).
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[此系列的最后一篇文章](elevated-world-5.html#asynclist)中看一个这个例子的真实实现。
- en: '**but...**'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '**但是...**'
- en: It's important to say that just because you *choose* a style doesn't mean it
    will be implemented as you expect. As we have seen, you can easily implement `apply`
    in terms of `bind`, so even if you use `<*>` in your code, the implementation
    may be proceeding monadically.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一种风格并不意味着它会按照你的预期实施。正如我们所见，你可以轻松地用`bind`来实现`apply`，所以即使你在代码中使用`<*>`，实现可能也是以单调方式进行的。
- en: In the example above, the implementation does not have to run the downloads
    in parallel. It could run them serially instead. By using applicative style, you're
    just saying that you don't care about dependencies and so they *could* be downloaded
    in parallel.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，实现并不一定要并行运行下载。它可以改为串行运行它们。通过使用应用风格，你只是表示你不关心依赖关系，因此它们*可能*会并行下载。
- en: Static vs. dynamic structure
  id: totrans-507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态与动态结构
- en: If you use the applicative style, that means that you define all the actions
    up front -- "statically", as it were.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用应用风格，这意味着你预先定义了所有操作 -- 就像是“静态的”一样。
- en: In the downloading example, the applicative style requires that you specific
    *in advance* which URLs will be visited. And because there is more knowledge up
    front it means that we can potentially do things like parallelization or other
    optimizations.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在下载示例中，应用风格要求你提前指定将访问哪些URL。由于需要更多的预先知识，这意味着我们可能可以做诸如并行化或其他优化的事情。
- en: On the other hand, the monadic style means that only the initial action is known
    up front. The remainder of the actions are determined dynamically, based on the
    output of previous actions. This is more flexible, but also limits our ability
    to see the big picture in advance.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，单调风格意味着只有最初的操作是预先知道的。其余的操作是根据以前操作的输出动态确定的。这更灵活，但也限制了我们预先了解整体情况的能力。
- en: Order of evaluation vs. dependency
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估顺序与依赖关系
- en: Sometimes *dependency* is confused with *order of evaluation*.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 有时*依赖性*与*评估顺序*混淆。
- en: Certainly, if one value depends on another then the first value must be evaluated
    before the second value. And in theory, if the values are completely independent
    (and have no side effects), then they can be evaluated in any order.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值依赖于另一个值时，第一个值必须在第二个值之前被评估。理论上，如果值是完全独立的（且没有副作用），那么它们可以以任何顺序被评估。
- en: However, even if the values are completely independent, there can still be an
    *implicit* order in how they are evaluated.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使值完全独立，它们评估的顺序仍然可能存在*隐含的*顺序。
- en: For example, even if the list of `GetURL`s is done in parallel, it's likely
    that the urls will begin to be fetched in the order in which they are listed,
    starting with the first one.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，即使`GetURL`的列表是并行完成的，但这些网址很可能会按照它们被列出的顺序开始获取，从第一个开始。
- en: And in the `List.apply` implemented in the previous post, we saw that `[f; g]
    apply [x; y]` resulted in `[f x; f y; g x; g y]` rather than `[f x; g x; f y;
    g y]`. That is, all the `f` values are first, then all the `g` values.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇文章中实现的`List.apply`中，我们看到`[f; g] apply [x; y]`的结果是`[f x; f y; g x; g y]`，而不是`[f
    x; g x; f y; g y]`。也就是说，所有的`f`值先出现，然后是所有的`g`值。
- en: In general, then, there is a convention that values are evaluated in a left
    to right order, even if they are independent.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，就是有一个约定，即值按从左到右的顺序评估，即使它们是独立的。
- en: '* * *'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Example: Validation using applicative style and monadic style'
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例如：使用适用风格和单子风格进行验证
- en: To see how both the applicative style and monadic style can be used, let's look
    at an example using validation.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何同时使用适用风格和单子风格，让我们看一个使用验证的示例。
- en: Say that we have a simple domain containing a `CustomerId`, an `EmailAddress`,
    and a `CustomerInfo` which is a record containing both of these.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个简单的领域，包含一个`CustomerId`，一个`EmailAddress`，以及一个`CustomerInfo`，它是一个包含这两者的记录。
- en: '[PRE41]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: And let's say that there is some validation around creating a `CustomerId`.
    For example, that the inner `int` must be positive. And of course, there will
    be some validation around creating a `EmailAddress` too. For example, that it
    must contain an "@" sign at least.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 并假设在创建`CustomerId`时存在一些验证。例如，内部的`int`必须是正数。当然，在创建`EmailAddress`时也会有一些验证。例如，它必须至少包含一个"@"符号。
- en: How would we do this?
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该怎么做？
- en: First we create a type to represent the success/failure of validation.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们创建一个类型来表示验证的成功/失败。
- en: '[PRE42]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that I have defined the `Failure` case to contain a *list* of strings,
    not just one. This will become important later.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我已经定义了`Failure`情况包含一个*字符串列表*，而不仅仅是一个。这将在以后变得重要。
- en: 'With `Result` in hand, we can go ahead and define the two constructor/validation
    functions as required:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`Result`，我们就可以定义两个构造函数/验证函数了：
- en: '[PRE43]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Notice that `createCustomerId` has type `int -> Result<CustomerId>`, and `createEmailAddress`
    has type `string -> Result<EmailAddress>`.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`createCustomerId`的类型为`int -> Result<CustomerId>`，而`createEmailAddress`的类型为`string
    -> Result<EmailAddress>`。
- en: That means that both of these validation functions are world-crossing functions,
    going from the normal world to the `Result<_>` world.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这两个验证函数都是跨世界的函数，从正常世界到`Result<_>`世界。
- en: Defining the core functions for `Result`
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义`Result`的核心函数
- en: Since we are dealing with world-crossing functions, we know that we will have
    to use functions like `apply` and `bind`, so let's define them for our `Result`
    type.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理跨世界的函数，我们知道我们将不得不使用`apply`和`bind`等函数，所以让我们为我们的`Result`类型定义它们。
- en: '[PRE44]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we check the signatures, we can see that they are exactly as we want:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查签名，我们可以看到它们正是我们想要的：
- en: '`map` has signature: `(''a -> ''b) -> Result<''a> -> Result<''b>`'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`的签名是：`(''a -> ''b) -> Result<''a> -> Result<''b>`'
- en: '`retn` has signature: `''a -> Result<''a>`'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retn`的签名是：`''a -> Result<''a>`'
- en: '`apply` has signature: `Result<(''a -> ''b)> -> Result<''a> -> Result<''b>`'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply`的签名是：`Result<(''a -> ''b)> -> Result<''a> -> Result<''b>`'
- en: '`bind` has signature: `(''a -> Result<''b>) -> Result<''a> -> Result<''b>`'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bind`的签名是：`(''a -> Result<''b>) -> Result<''a> -> Result<''b>`'
- en: I defined a `retn` function in the module to be consistent, but I don't bother
    to use it very often. The *concept* of `return` is important, but in practice,
    I'll probably just use the `Success` constructor directly. In languages with type
    classes, such as Haskell, `return` is used much more.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 我在模块中定义了一个`retn`函数以保持一致，但我并不经常使用它。`return`的*概念*很重要，但实际上，我可能会直接使用`Success`构造函数。在具有类型类的语言中，例如Haskell，`return`的使用要多得多。
- en: Also note that `apply` will concat the error messages from each side if both
    parameters are failures. This allows us to collect all the failures without discarding
    any. This is the reason why I made the `Failure` case have a list of strings,
    rather than a single string.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，如果两个参数都是失败的话，`apply`将连接每一边的错误消息。这使我们能够收集所有失败而不丢弃任何失败。这就是为什么我让`Failure`情况有一个字符串列表，而不是一个字符串的原因。
- en: '*NOTE: I''m using `string` for the failure case to make the demonstration easier.
    In a more sophisticated design I would list the possible failures explicitly.
    See my [functional error handling](http://fsharpforfunandprofit.com/rop/) talk
    for more details.*'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：我在失败案例中使用`string`是为了使演示更容易。在更复杂的设计中，我会明确列出可能的失败。更多细节请参见我的[函数式错误处理](http://fsharpforfunandprofit.com/rop/)讲座。*'
- en: Validation using applicative style
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用应用风格进行验证
- en: Now that we have have the domain and the toolset around `Result`, let's try
    using the applicative style to create a `CustomerInfo` record.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了围绕`Result`的领域和工具集，让我们尝试使用应用风格来创建一个`CustomerInfo`记录。
- en: The outputs of the validation are already elevated to `Result`, so we know we'll
    need to use some sort of "lifting" approach to work with them.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 验证的输出已经提升到`Result`，所以我们知道我们需要使用某种“提升”方法来处理它们。
- en: 'First we''ll create a function in the normal world that creates a `CustomerInfo`
    record given a normal `CustomerId` and a normal `EmailAddress`:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在正常世界中创建一个函数，根据普通的`CustomerId`和普通的`EmailAddress`创建一个`CustomerInfo`记录：
- en: '[PRE45]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that the signature is `CustomerId -> EmailAddress -> CustomerInfo`.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，签名是`CustomerId -> EmailAddress -> CustomerInfo`。
- en: 'Now we can use the lifting technique with `<!>` and `<*>` that was explained
    in the previous post:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用前一篇文章中解释的`<!>`和`<*>`的提升技术：
- en: '[PRE46]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The signature of this shows that we start with a normal `int` and `string` and
    return a `Result<CustomerInfo>`
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这个签名显示我们从普通的`int`和`string`开始，返回一个`Result<CustomerInfo>`
- en: '![](vgfp_applicative_style.png)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_applicative_style.png)'
- en: 'Let''s try it out with some good and bad data:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下一些好的和坏的数据：
- en: '[PRE47]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `goodCustomerA` is a `Success` and contains the right data, but the `badCustomerA`
    is a `Failure` and contains two validation error messages. Excellent!
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '`goodCustomerA`是一个`Success`，包含正确的数据，但`badCustomerA`是一个`Failure`，包含两个验证错误消息。太棒了！'
- en: Validation using monadic style
  id: totrans-556
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用单子风格进行验证
- en: 'Now let''s do another implementation, but this time using monadic style. In
    this version the logic will be:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们做另一个实现，但这次使用单子风格。在这个版本中，逻辑将是：
- en: try to convert an int into a `CustomerId`
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试将int转换为`CustomerId`
- en: if that is successful, try to convert a string into a `EmailAddress`
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果成功，尝试将字符串转换为`EmailAddress`
- en: if that is successful, create a `CustomerInfo` from the customerId and email.
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果成功，从customerId和email创建一个`CustomerInfo`。
- en: 'Here''s the code:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '[PRE48]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The signature of the monadic-style `createCustomerResultM` is exactly the same
    as the applicative-style `createCustomerResultA` but internally it is doing something
    different, which will be reflected in the different results we get.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 单子风格`createCustomerResultM`的签名与应用风格`createCustomerResultA`完全相同，但内部执行的操作是不同的，这将反映在我们得到的不同结果中。
- en: '![](vgfp_monadic_style.png)'
  id: totrans-564
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_monadic_style.png)'
- en: '[PRE49]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the good customer case, the end result is the same, but in the bad customer
    case, only *one* error is returned, the first one. The rest of the validation
    was short circuited after the `CustomerId` creation failed.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在良好的客户案例中，最终结果是相同的，但在糟糕的客户案例中，只返回*一个*错误，即第一个错误。在`CustomerId`创建失败后，其余验证被短路。
- en: Comparing the two styles
  id: totrans-567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较两种风格
- en: This example has demonstrated the difference between applicative and monadic
    style quite well, I think.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很好地展示了应用风格和单子风格之间的区别，我认为。
- en: The *applicative* example did all the validations up front, and then combined
    the results. The benefit was that we didn't lose any of the validation errors.
    The downside was we did work that we might not have needed to do.
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用*示例首先进行了所有验证，然后组合了结果。好处是我们没有丢失任何验证错误。缺点是我们可能做了一些不需要做的工作。'
- en: '![](vgfp_applicative_style.png)'
  id: totrans-570
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_applicative_style.png)'
- en: On the other hand, the monadic example did one validation at a time, chained
    together. The benefit was that we short-circuited the rest of the chain as soon
    as an error occurred and avoided extra work. The downside was that we only got
    the *first* error.
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，单子示例一次执行一个验证，链接在一起。好处是一旦发生错误，我们就会短路链的其余部分，避免额外工作。缺点是我们只得到*第一个*错误。
- en: '![](vgfp_monadic_style.png)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_monadic_style.png)'
- en: Mixing the two styles
  id: totrans-573
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合两种风格
- en: Now there is nothing to say that we can't mix and match applicative and monadic
    styles.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 现在没有什么可以阻止我们混合和匹配应用和单子风格。
- en: For example, we might build a `CustomerInfo` using applicative style, so that
    we don't lose any errors, but later on in the program, when a validation is followed
    by a database update, we probably want to use monadic style, so that the database
    update is skipped if the validation fails.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用应用样式构建`CustomerInfo`，以便不丢失任何错误，但在程序的后续部分，当验证后跟着数据库更新时，我们可能希望使用单子样式，以便如果验证失败，则跳过数据库更新。
- en: Using F# computation expressions
  id: totrans-576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用F#计算表达式
- en: Finally, let's build a computation expression for these `Result` types.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们为这些`Result`类型构建一个计算表达式。
- en: 'To do this, we just define a class with members called `Return` and `Bind`,
    and then we create an instance of that class, called `result`, say:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们只需定义一个具有名为`Return`和`Bind`的成员的类，然后我们创建该类的一个实例，称为`result`，如下所示：
- en: '[PRE50]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can then rewrite the `createCustomerResultM` function to look like this:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将`createCustomerResultM`函数重写为以下形式：
- en: '[PRE51]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This computation expression version looks almost like using an imperative language.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算表达式版本几乎看起来像是使用命令式语言。
- en: Note that F# computation expressions are always monadic, as is Haskell do-notation
    and Scala for-comprehensions. That's not generally a problem, because if you need
    applicative style it is very easy to write without any language support.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，F#计算表达式始终是单子的，就像Haskell的do-notation和Scala的for-comprehensions一样。这通常不是问题，因为如果你需要应用样式，那么很容易在没有任何语言支持的情况下编写。
- en: '* * *'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Lifting to a consistent world
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升到一致的世界
- en: In practice, we often have a mish-mash of different kinds of values and functions
    that we need to combine together.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们经常需要将各种不同类型的值和函数组合在一起。
- en: The trick for doing this is to convert all them to the *same* type, after which
    they can be combined easily.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的技巧是将它们全部转换为*相同*类型，之后它们就可以轻松地组合在一起。
- en: Making values consistent
  id: totrans-588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使值一致
- en: 'Let''s revisit the previous validation example, but let''s change the record
    so that it has an extra property, a `name` of type string:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视以前的验证示例，但让我们改变记录，使其具有额外的属性，即类型为字符串的`name`：
- en: '[PRE52]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As before, we want to create a function in the normal world that we will later
    lift to the `Result` world.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们希望创建一个在正常世界中的函数，稍后我们将将其提升到`Result`世界中。
- en: '[PRE53]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now we are ready to update the lifted `createCustomer` with the extra parameter:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备使用额外的参数更新提升的`createCustomer`：
- en: '[PRE54]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: But this won't compile! In the series of parameters `idResult <*> name <*> emailResult`
    one of them is not like the others. The problem is that `idResult` and `emailResult`
    are both Results, but `name` is still a string.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这不会编译通过！在参数系列`idResult <*> name <*> emailResult`中，有一个与其他不同。问题在于`idResult`和`emailResult`都是Results，但`name`仍然是一个字符串。
- en: 'The fix is just to lift `name` into the world of results (say `nameResult`)
    by using `return`, which for `Result` is just `Success`. Here is the corrected
    version of the function that does work:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 修复的方法只是通过使用`return`将`name`提升到结果的世界中（比如说`nameResult`），这对于`Result`来说只是`Success`。这是修正后的确实有效的函数版本：
- en: '[PRE55]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Making functions consistent
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使函数一致
- en: The same trick can be used with functions too.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的技巧也可以用于函数。
- en: 'For example, let''s say that we have a simple customer update workflow with
    four steps:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个包含四个步骤的简单客户更新工作流程：
- en: First, we validate the input. The output of this is the same kind of `Result`
    type we created above. Note that this validation function could *itself* be the
    result of combining other, smaller validation functions using `apply`.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们验证输入。这个输出与我们上面创建的相同类型的`Result`类型相同。请注意，这个验证函数本身可能是通过使用`apply`结合其他更小的验证函数的结果。
- en: 'Next, we canonicalize the data. For example: lowercasing emails, trimming whitespace,
    etc. This step never raises an error.'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们规范化数据。例如：将电子邮件转换为小写，去除空白等。这一步永远不会引发错误。
- en: Next, we fetch the existing record from the database. For example, getting a
    customer for the `CustomerId`. This step could fail with an error too.
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们从数据库中获取现有记录。例如，获取`CustomerId`的客户。这一步也可能失败。
- en: Finally, we update the database. This step is a "dead-end" function -- there
    is no output.
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们更新数据库。这一步是一个“死胡同”函数——没有输出。
- en: 'For error handling, I like to think of there being two tracks: a Success track
    and a Failure track. In this model, an error-generating function is analogous
    to a railway switch (US) or points (UK).'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 对于错误处理，我喜欢把它看作是两个轨道：一个成功轨道和一个失败轨道。在这个模型中，生成错误的函数类似于铁路开关（美国）或交叉渡线（英国）。
- en: '![](vgfp_rop_before.png)'
  id: totrans-606
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_rop_before.png)'
- en: The problem is that these functions cannot be glued together; they are all different
    shapes.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在于这些函数无法粘合在一起；它们都是不同的形状。
- en: The solution is to convert all of them to the *same* shape, in this case the
    two-track model with success and failure on different tracks. Let's call this
    *Two-Track world*!
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将它们全部转换为*相同*的形状，在本例中是具有不同轨道上的成功和失败的双轨道模型。我们称之为*双轨道世界*！
- en: Transforming functions using the toolset
  id: totrans-609
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用工具集转换函数
- en: Each original function, then, needs to be elevated to Two-Track world, and we
    know just the tools that can do this!
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个原始函数都需要提升到双轨道世界，我们知道可以做到这一点的工具！
- en: The `Canonicalize` function is a single track function. We can turn it into
    a two-track function using `map`.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canonicalize` 函数是一个单轨道函数。我们可以使用 `map` 将其转换为双轨道函数。'
- en: '![](vgfp_rop_map.png)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_rop_map.png)'
- en: The `DbFetch` function is a world-crossing function. We can turn it into a wholly
    two-track function using `bind`.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '`DbFetch` 函数是一个跨世界函数。我们可以使用 `bind` 将其转换为完全双轨道函数。'
- en: '![](vgfp_rop_bind.png)'
  id: totrans-614
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_rop_bind.png)'
- en: The `DbUpdate` function is more complicated. We don't like dead-end functions,
    so first we need to transform it to a function where the data keeps flowing. I'll
    call this function `tee`. The output of `tee` has one track in and one track out,
    so we need to convert it to a two-track function, again using `map`.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '`DbUpdate` 函数更复杂一些。我们不喜欢死胡同函数，所以首先需要将其转换为数据保持流动的函数。我将这个函数称为 `tee`。`tee` 的输出有一个输入轨道和一个输出轨道，因此我们需要再次使用
    `map` 将其转换为双轨道函数。'
- en: '![](vgfp_rop_tee.png)'
  id: totrans-616
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_rop_tee.png)'
- en: 'After all these transformations, we can reassemble the new versions of these
    functions. The result looks like this:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些转换之后，我们可以重新组装这些函数的新版本。结果如下所示：
- en: '![](vgfp_rop_after.png)'
  id: totrans-618
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_rop_after.png)'
- en: 'And of course, these functions can now be composed together very easily, so
    that we end up with a single function looking like this, with one input and a
    success/failure output:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些函数现在可以非常容易地组合在一起，以便我们最终得到一个单一函数，形式如下，具有一个输入和一个成功/失败的输出：
- en: '![](vgfp_rop_after2.png)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_rop_after2.png)'
- en: This combined function is yet another world-crossing function of the form `a->Result<b>`,
    and so it in turn can be used as a component part of a even bigger function.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组合函数又是另一个形式为 `a->Result<b>` 的跨世界函数，因此它反过来可以用作更大函数的组成部分。
- en: For more examples of this "elevating everything to the same world" approach,
    see my posts on [functional error handling](http://fsharpforfunandprofit.com/rop/)
    and [threading state](handling-state.html).
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多关于“将一切提升到相同世界”的示例，请参阅我的[函数式错误处理](http://fsharpforfunandprofit.com/rop/)和[线程状态](handling-state.html)的帖子。
- en: '* * *'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Kleisli world
  id: totrans-624
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kleisli 世界
- en: There is an alternative world which can be used as a basic for consistency which
    I will call "Kleisli" world, named after [Professor Kleisli](https://en.wikipedia.org/wiki/Heinrich_Kleisli)
    -- a mathematician, of course!
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个备选世界可以用作一致性的基础，我将其称为“Kleisli”世界，以 [Kleisli 教授](https://en.wikipedia.org/wiki/Heinrich_Kleisli)
    的名字命名 -- 当然是一位数学家！
- en: In Kleisli world *everything* is a cross-world function! Or, using the railway
    track analogy, everything is a switch (or points).
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kleisli 世界中，*一切*都是跨世界函数！或者用铁路轨道的类比来说，一切都是开关（或点）。
- en: In Kleisli world, the cross-world functions *can* be composed directly, using
    an operator called `>=>` for left-to-right composition or `<=<` for right-to-left
    composition.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kleisli 世界中，跨世界函数可以直接组合，使用一个称为 `>=>` 的操作符进行从左到右的组合，或者使用 `<=<` 进行从右到左的组合。
- en: '![](vgfp_kleisli_3.png)'
  id: totrans-628
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_kleisli_3.png)'
- en: Using the same example as before, we can lift all our functions to Kleisli world.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前相同的例子，我们可以将所有函数提升到 Kleisli 世界。
- en: The `Validate` and `DbFetch` functions are already in the right form so they
    don't need to be changed.
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Validate` 和 `DbFetch` 函数已经处于正确的形式，因此不需要改变。'
- en: The one-track `Canonicalize` function can be lifted to a switch just by lifting
    the output to a two-track value. Let's call this `toSwitch`.
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单轨道 `Canonicalize` 函数可以通过将输出提升为双轨道值而轻松提升为开关。我们称之为 `toSwitch`。
- en: '![](vgfp_kleisli_1.png)'
  id: totrans-632
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_kleisli_1.png)'
- en: The tee-d `DbUpdate` function can be also lifted to a switch just by doing `toSwitch`
    after the tee.
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程-d 的 `DbUpdate` 函数也可以通过在线程之后执行 `toSwitch` 来提升为开关。
- en: '![](vgfp_kleisli_2.png)'
  id: totrans-634
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_kleisli_2.png)'
- en: 'Once all the functions have been lifted to Kleisli world, they can be composed
    with Kleisli composition:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有函数都被提升到 Kleisli 世界，它们就可以使用 Kleisli 组合进行组合：
- en: '![](vgfp_kleisli_4.png)'
  id: totrans-636
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_kleisli_4.png)'
- en: Kleisli world has some nice properties that Two-Track world doesn't but on the
    other hand, I find it hard to get my head around it! So I generally stick to using
    Two-Track world as my foundation for things like this.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 克莱斯利世界有一些好的特性，两轨道世界没有，但另一方面，我发现很难理解它！所以我通常将两轨道世界作为我的基础，用于这样的事情。
- en: Summary
  id: totrans-638
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概要
- en: In this post, we learned about "applicative" vs "monadic" style, and why the
    choice could have an important effect on which actions are executed, and what
    results are returned.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们学习了"应用"与"单子"风格的区别，以及为什么选择可能对执行哪些操作以及返回什么结果具有重要影响。
- en: We also saw how to lift different kinds values and functions to a a consistent
    world so that the could be worked with easily.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何将不同类型的值和函数提升到一个一致的世界，以便可以轻松地使用它们。
- en: 'In the [next post](elevated-world-4.html) we''ll look at a common problem:
    working with lists of elevated values.'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 在[下一篇文章](elevated-world-4.html)中，我们将讨论一个常见的问题：如何处理提高值的列表。
- en: Understanding traverse and sequence
  id: totrans-642
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 traverse 和 sequence
- en: Understanding traverse and sequence
  id: totrans-643
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 traverse 和 sequence
- en: 'This post is one in a series. In the [first two posts](elevated-world.html),
    I described some of the core functions for dealing with generic data types: `map`,
    `bind`, and so on. In the [previous post](elevated-world-3.html), I discussed
    "applicative" vs "monadic" style, and how to lift values and functions to be consistent
    with each other.'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 本文是系列文章之一。在[前两篇文章](elevated-world.html)中，我描述了一些用于处理通用数据类型的核心函数：`map`、`bind`等等。在[上一篇文章](elevated-world-3.html)中，我讨论了"应用"与"单子"风格，以及如何提升值和函数以使它们彼此一致。
- en: 'In this post, we''ll look at a common problem: working with lists of elevated
    values.'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们将讨论一个常见的问题：如何处理提高值的列表。
- en: Series contents
  id: totrans-646
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系列内容
- en: 'Here''s a list of shortcuts to the various functions mentioned in this series:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快捷方式列表，可用于查看本系列中提到的各种函数：
- en: '**Part 1: Lifting to the elevated world**'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一部分：抬升到提高的世界**'
- en: '[The `map` function](elevated-world.html#map)'
  id: totrans-649
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`map` 函数](elevated-world.html#map)'
- en: '[The `return` function](elevated-world.html#return)'
  id: totrans-650
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`return` 函数](elevated-world.html#return)'
- en: '[The `apply` function](elevated-world.html#apply)'
  id: totrans-651
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`apply` 函数](elevated-world.html#apply)'
- en: '[The `liftN` family of functions](elevated-world.html#lift)'
  id: totrans-652
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`liftN` 函数系列](elevated-world.html#lift)'
- en: '[The `zip` function and ZipList world](elevated-world.html#zip)'
  id: totrans-653
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`zip` 函数和 ZipList 世界](elevated-world.html#zip)'
- en: '**Part 2: How to compose world-crossing functions**'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二部分：如何组合跨世界函数**'
- en: '[The `bind` function](elevated-world-2.html#bind)'
  id: totrans-655
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`bind` 函数](elevated-world-2.html#bind)'
- en: '[List is not a monad. Option is not a monad.](elevated-world-2.html#not-a-monad)'
  id: totrans-656
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[列表不是单子。选项不是单子。](elevated-world-2.html#not-a-monad)'
- en: '**Part 3: Using the core functions in practice**'
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三部分：在实践中使用核心函数**'
- en: '[Independent and dependent data](elevated-world-3.html#dependent)'
  id: totrans-658
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[独立和依赖数据](elevated-world-3.html#dependent)'
- en: '[Example: Validation using applicative style and monadic style](elevated-world-3.html#validation)'
  id: totrans-659
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：使用应用样式和单子样式进行验证](elevated-world-3.html#validation)'
- en: '[Lifting to a consistent world](elevated-world-3.html#consistent)'
  id: totrans-660
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提升到一致的世界](elevated-world-3.html#consistent)'
- en: '[Kleisli world](elevated-world-3.html#kleisli)'
  id: totrans-661
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[克莱斯利世界](elevated-world-3.html#kleisli)'
- en: '**Part 4: Mixing lists and elevated values**'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第四部分：混合列表和提升值**'
- en: '[Mixing lists and elevated values](elevated-world-4.html#mixing)'
  id: totrans-663
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[混合列表和提升值](elevated-world-4.html#mixing)'
- en: '[The `traverse`/`MapM` function](elevated-world-4.html#traverse)'
  id: totrans-664
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`traverse`/`MapM` 函数](elevated-world-4.html#traverse)'
- en: '[The `sequence` function](elevated-world-4.html#sequence)'
  id: totrans-665
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`sequence` 函数](elevated-world-4.html#sequence)'
- en: '["Sequence" as a recipe for ad-hoc implementations](elevated-world-4.html#adhoc)'
  id: totrans-666
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为临时实现的"Sequence"配方
- en: '[Readability vs. performance](elevated-world-4.html#readability)'
  id: totrans-667
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可读性与性能](elevated-world-4.html#readability)'
- en: '[Dude, where''s my `filter`?](elevated-world-4.html#filter)'
  id: totrans-668
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[伙计，我的`filter`在哪里？](elevated-world-4.html#filter)'
- en: '**Part 5: A real-world example that uses all the techniques**'
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第五部分：一个使用所有技术的真实示例**'
- en: '[Example: Downloading and processing a list of websites](elevated-world-5.html#asynclist)'
  id: totrans-670
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：下载和处理网站列表](elevated-world-5.html#asynclist)'
- en: '[Treating two worlds as one](elevated-world-5.html#asyncresult)'
  id: totrans-671
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将两个世界视为一个](elevated-world-5.html#asyncresult)'
- en: '**Part 6: Designing your own elevated world**'
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第六部分：设计您自己的提升世界**'
- en: '[Designing your own elevated world](elevated-world-6.html#part6)'
  id: totrans-673
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[设计您自己的提升世界](elevated-world-6.html#part6)'
- en: '[Filtering out failures](elevated-world-6.html#filtering)'
  id: totrans-674
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[过滤掉失败](elevated-world-6.html#filtering)'
- en: '[The Reader monad](elevated-world-6.html#readermonad)'
  id: totrans-675
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[阅读器单子](elevated-world-6.html#readermonad)'
- en: '**Part 7: Summary**'
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第七部分：概要**'
- en: '[List of operators mentioned](elevated-world-7.html#operators)'
  id: totrans-677
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提到的运算符列表](elevated-world-7.html#operators)'
- en: '[Further reading](elevated-world-7.html#further-reading)'
  id: totrans-678
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[进一步阅读](elevated-world-7.html#further-reading)'
- en: '* * *'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Part 4: Mixing lists and elevated values'
  id: totrans-680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四部分：混合列表和提升值
- en: A common issue is how to deal with lists or other collections of elevated values.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 处理列表或其他提升值集合的常见问题是如何处理。
- en: 'Here are some examples:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '**Example 1:** We have a `parseInt` with signature `string -> int option`,
    and we have a list of strings. We want to parse all the strings at once. Now of
    course we can use `map` to convert the list of strings to a list of options. But
    what we *really* want is not a "list of options" but an "option of list", a list
    of parsed ints, wrapped in an option in case any fail.'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例 1：** 我们有一个签名为`string -> int option`的`parseInt`，以及一个字符串列表。我们想一次解析所有字符串。当然，我们可以使用`map`将字符串列表转换为选项列表。但我们*真正*想要的不是“选项列表”，而是“列表的选项”，即一个包含解析整数的列表，以防有任何失败的选项。'
- en: '**Example 2:** We have a `readCustomerFromDb` function with signature `CustomerId
    -> Result<Customer>`, that will return `Success` if the record can be found and
    returned, and `Failure` otherwise. And say we have a list of `CustomerId`s and
    we want to read all the customers at once. Again, we can use `map` to convert
    the list of ids to a list of results. But what we *really* want is not a list
    of `Result<Customer>`, but a `Result` containing a `Customer list`, with the `Failure`
    case in case of errors.'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例 2：** 我们有一个签名为`CustomerId -> Result<Customer>`的`readCustomerFromDb`函数，如果可以找到并返回记录，则返回`Success`，否则返回`Failure`。假设我们有一个`CustomerId`列表，我们想一次读取所有客户。同样，我们可以使用`map`将id列表转换为结果列表。但我们*真正*想要的不是`Result<Customer>`列表，而是包含`Customer
    list`的`Result`，在出现错误时包含`Failure`情况。'
- en: '**Example 3:** We have a `fetchWebPage` function with signature `Uri -> Async<string>`,
    that will return a task that will download the page contents on demand. And say
    we have a list of `Uris`s and we want to fetch all the pages at once. Again, we
    can use `map` to convert the list of `Uri`s to a list of `Async`s. But what we
    *really* want is not a list of `Async`, but a `Async` containing a list of strings.'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**示例 3：** 我们有一个签名为`Uri -> Async<string>`的`fetchWebPage`函数，它将返回一个任务，根据需要下载页面内容。假设我们有一个`Uri`列表，我们想一次获取所有页面。同样，我们可以使用`map`将`Uri`列表转换为`Async`列表。但我们*真正*想要的不是`Async`列表，而是包含字符串列表的`Async`。'
- en: Mapping an Option generating function
  id: totrans-686
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射一个生成选项的函数
- en: Let's start by coming up with a solution for the first case and then seeing
    if we can generalize it to the others.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为第一个情况找出一个解决方案，然后看看我们是否可以将其推广到其他情况。
- en: 'The obvious approach would be:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的方法是：
- en: First, use `map` to turn the list of `string` into a list of `Option<int>`.
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，使用`map`将`string`列表转换为`Option<int>`列表。
- en: Next, create a function that turns the list of `Option<int>` into an `Option<int
    list>`.
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，创建一个将`Option<int>`列表转换为`Option<int list>`的函数。
- en: But this requires *two* passes through the list. Can we do it in one pass?
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 但这需要*两次*通过列表。我们能否一次完成？
- en: Yes! If we think about how a list is built, there is a "cons" function (`::`
    in F#) that is used to join the head to the tail. If we elevate this to the `Option`
    world, we can use `Option.apply` to join a head `Option` to a tail `Option` using
    the lifted version of `cons`.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！如果我们考虑列表是如何构建的，有一个“cons”函数（在F#中是`::`）用于将头部连接到尾部。如果我们将这个提升到`Option`世界，我们可以使用`Option.apply`来使用`cons`的提升版本将头部`Option`与尾部`Option`连接起来。
- en: '[PRE56]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*NOTE: I defined `cons` explicitly because `::` is not a function and `List.Cons`
    takes a tuple and is thus not usable in this context.*'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：我明确定义了`cons`，因为`::`不是一个函数，而`List.Cons`接受一个元组，因此在这种情况下无法使用。*'
- en: 'Here is the implementation as a diagram:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个作为图表的实现：
- en: '![](vgfp_mapOption.png)'
  id: totrans-696
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_mapOption.png)'
- en: If you are confused as to how this works, please read the section on `apply`
    in the first post in this series.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对此如何工作感到困惑，请阅读本系列中第一篇文章中关于`apply`的部分。
- en: Note also that I am explicitly defining `retn` and using it in the implementation
    rather than just using `Some`. You'll see why in the next section.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我明确定义了`retn`并在实现中使用它，而不仅仅使用`Some`。您将在下一节中看到原因。
- en: Now let's test it!
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来测试一下！
- en: '[PRE57]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We start by defining `parseInt` of type `string -> int option` (piggybacking
    on the existing .NET library).
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义类型为`string -> int option`的`parseInt`（借助现有的.NET库）。
- en: We use `mapOption` to run it against a list of good values, and we get `Some
    [1; 2; 3]`, with the list *inside* the option, just as we want.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`mapOption`对一组良好的值运行它，我们得到`Some [1; 2; 3]`，列表*在*选项内，正如我们所希望的那样。
- en: And if we use a list where some of the values are bad, we get `None` for the
    entire result.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的列表中有一些坏值，那么整个结果都会得到`None`。
- en: Mapping a Result generating function
  id: totrans-704
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射一个生成Result的函数
- en: Let's repeat this, but this time using the `Result` type from the earlier validation
    example.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重复这个过程，但这次使用先前验证示例中的`Result`类型。
- en: 'Here''s the `mapResult` function:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`mapResult`函数：
- en: '[PRE58]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Again I am explicitly defining a `retn` rather than just using `Success`. And
    because of this, the body of the code for `mapResult` and `mapOption` is *exactly
    the same*!
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我明确地定义了一个`retn`，而不是仅仅使用`Success`。因此，`mapResult`和`mapOption`的代码体*完全相同*！
- en: 'Now let''s change `parseInt` to return a `Result` rather than an `Option`:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将`parseInt`更改为返回`Result`而不是`Option`：
- en: '[PRE59]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And then we can rerun the tests again, but this time getting more informative
    errors in the failure case:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以再次运行测试，但这次在失败的情况下获得更多的信息性错误：
- en: '[PRE60]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Can we make a generic mapXXX function?
  id: totrans-713
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们能否制作一个通用的mapXXX函数？
- en: The implementations of `mapOption` and `mapResult` have exactly the same code,
    the only difference is the different `retn` and `<*>` functions (from Option and
    Result, respectively).
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapOption`和`mapResult`的实现代码完全相同，唯一的区别是不同的`retn`和`<*>`函数（分别来自Option和Result）。'
- en: So the question naturally arises, rather than having `mapResult`, `mapOption`,
    and other specific implementations for each elevated type, can we make a completely
    generic version of `mapXXX` that works for *all* elevated types?
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 所以自然而然地提出了一个问题，我们是否可以为*所有*提升的类型制作一个完全通用的`mapXXX`版本？
- en: 'The obvious thing would be able to pass these two functions in as an extra
    parameter, like this:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的是，我们可以将这两个函数作为额外参数传递进来，就像这样：
- en: '[PRE61]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: There are some problems with this though. First, this code doesn't compile in
    F#! But even if it did, we'd want to make sure that the *same* two parameters
    were passed around everywhere.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这样做也存在一些问题。首先，这段代码在F#中无法编译！但即使可以，我们也希望确保*相同的*两个参数在任何地方都被传递。
- en: 'We might attempt this by creating a record structure containing the two parameters,
    and then create one instance for each type of elevated world:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会尝试通过创建一个包含两个参数的记录结构，然后为每种类型的提升的世界创建一个实例来实现此目的：
- en: '[PRE62]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The instance of the `Applicative` record (`appl` say) would be an extra parameter
    to our generic `mapE` function, like this:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '`Applicative`记录（比如`appl`）的实例将是我们通用的`mapE`函数的额外参数，就像这样：'
- en: '[PRE63]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In use, we would pass in the specific applicative instance that we want, like
    this:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用时，我们会传入我们想要的特定applicative实例，就像这样：
- en: '[PRE64]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Unfortunately, none of this works either, at least in F#. The `Applicative`
    type, as defined, won't compile. This is because F# does not support "higher-kinded
    types". That is, we can't parameterize the `Applicative` type with a generic type,
    only with concrete types.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这些方法都不起作用，至少在F#中不起作用。如定义的那样，`Applicative`类型无法编译。这是因为F#不支持“高种类类型”。也就是说，我们不能使用泛型类型，只能使用具体类型来参数化`Applicative`类型。
- en: In Haskell and languages that *do* support "higher-kinded types", the `Applicative`
    type that we've defined is similar to a "type class". What's more, with type classes,
    we don't have to pass around the functions explicitly -- the compiler will do
    that for us.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell和支持“高种类类型”的语言中，我们定义的`Applicative`类型类似于“类型类”。更重要的是，使用类型类时，我们不必显式传递函数
    - 编译器会为我们做这个工作。
- en: There is actually a clever (and hacky) way of getting the same effect in F#
    though using static type constraints. I'm not going to discuss it here, but you
    can see it used in the [FSharpx library](https://github.com/fsprojects/FSharpx.Extras/blob/master/src/FSharpx.Extras/ComputationExpressions/Monad.fs).
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有一种聪明（而且有些狡猾）的方法可以在F#中获得相同的效果，即使用静态类型约束。我不打算在这里讨论它，但你可以在[FSharpx库](https://github.com/fsprojects/FSharpx.Extras/blob/master/src/FSharpx.Extras/ComputationExpressions/Monad.fs)中看到它的使用。
- en: 'The alternative to all this abstraction is just creating a `mapXXX` function
    for each elevated world that we want to work with: `mapOption`, `mapResult`, `mapAsync`
    and so on.'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些抽象的替代方法就是为我们想要使用的每个提升的世界创建一个`mapXXX`函数：`mapOption`，`mapResult`，`mapAsync`等等。
- en: Personally I am OK with this cruder approach. There are not that many elevated
    worlds that you work with regularly, and even though you lose out on abstraction,
    you gain on explicitness, which is often useful when working in a team of mixed
    abilities.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我认为这种粗略的方法是可以接受的。你经常与之一起工作的提升的世界并不多，即使你在抽象上失去了，你在明确性上获得了，这在一个能力参差不齐的团队中工作时通常是有用的。
- en: So let's look at these `mapXXX` functions, also called `traverse`.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们看看这些`mapXXX`函数，也称为`traverse`。
- en: '* * *'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The `traverse` / `mapM` function
  id: totrans-732
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`traverse` / `mapM`函数'
- en: '**Common Names**: `mapM`, `traverse`, `for`'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '**常用名称**：`mapM`、`traverse`、`for`'
- en: '**Common Operators**: None'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '**常用运算符**：无'
- en: '**What it does**: Transforms a world-crossing function into a world-crossing
    function that works with collections'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '**它的作用**：将一个跨世界函数转换为一个适用于集合的跨世界函数'
- en: '**Signature**: `(a->E<b>) -> a list -> E<b list>` (or variants where list is
    replaced with other collection types)'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '**签名**：`(a->E<b>) -> a list -> E<b list>`（或者替换list为其他集合类型的变体）'
- en: Description
  id: totrans-737
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: We saw above that we can define a set of `mapXXX` functions, where XXX stands
    for an applicative world -- a world that has `apply` and `return`. Each of these
    `mapXXX` functions transforms a world-crossing function into a world-crossing
    function that works with collections.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，我们可以定义一组`mapXXX`函数，其中XXX代表一个应用世界--一个具有`apply`和`return`的世界。每个`mapXXX`函数将一个跨世界函数转换为一个适用于集合的跨世界函数。
- en: '![](vgfp_traverse.png)'
  id: totrans-739
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_traverse.png)'
- en: And as we noted above, if the language supports type classes, we can get away
    with a single implementation, called `mapM` or `traverse`. I'm going to call the
    general concept `traverse` from now on to make it clear that is different from
    `map`.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们上面所指出的，如果语言支持类型类，我们可以通过一个单一实现来完成，称为`mapM`或`traverse`。从现在开始，我将称这个通用概念为`traverse`，以明确表示它与`map`不同。
- en: Map vs. Traverse
  id: totrans-741
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Map vs. Traverse
- en: Understanding the difference between `map` and `traverse` can be hard, so let's
    see if we can explain it in pictures.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`map`和`traverse`之间的区别可能很困难，所以让我们看看是否可以用图片来解释。
- en: First, let's introduce some visual notation using the analogy of an "elevated"
    world sitting above a "normal" world.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用“高级”世界位于“正常”世界上方的类比来引入一些视觉符号。
- en: Some of these elevated worlds (in fact almost all of them!) have `apply` and
    `return` functions. We'll call these "Applicative worlds". Examples include `Option`,
    `Result`, `Async`, etc.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 一些高级世界（实际上几乎所有！）具有`apply`和`return`函数。我们将这些称为“应用世界”。示例包括`Option`、`Result`、`Async`等。
- en: And some of these elevated worlds have a `traverse` function. We'll call these
    "Traversable worlds", and we'll use `List` as a classic example.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 一些高级世界中有一个`traverse`函数。我们将这些称为“可遍历世界”，并且我们将以`List`作为经典示例。
- en: If a Traversable world is on top, that produces a type such as `List<a>`, and
    if an Applicative world is on top, that produces a type such as `Result<a>`.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个可遍历世界在顶部，那会产生一个类型，比如`List<a>`，如果一个应用世界在顶部，那会产生一个类型，比如`Result<a>`。
- en: '![](vgfp_mstack_1.png)'
  id: totrans-747
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_mstack_1.png)'
- en: '*IMPORTANT: I will be using the syntax `List<_>` to represent "List world"
    for consistency with `Result<_>`, etc. This is* not *meant to be the same as the
    .NET List class! In F#, this would be implemented by the immutable `list` type*.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '*重要提示：我将使用语法`List<_>`来表示“List世界”，以保持与`Result<_>`等的一致性。这*不*意味着与.NET List类相同！在F#中，这将由不可变的`list`类型实现*。'
- en: But from now on we are going to be dealing with *both* kinds of elevated worlds
    in the same "stack".
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 但从现在开始，我们将处理*两种*类型的高级世界在同一个“堆栈”中。
- en: The Traversable world can be stacked on top of the Applicative world, which
    produces a type such as `List<Result<a>>`, or alternatively, the Applicative world
    world can be stacked on top of the Traversable world, which produces a type such
    as `Result<List<a>>`.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 可遍历世界可以堆叠在应用世界上，产生诸如`List<Result<a>>`之类的类型，或者，应用世界可以堆叠在可遍历世界上，产生诸如`Result<List<a>>`之类的类型。
- en: '![](vgfp_mstack_2.png)'
  id: totrans-751
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_mstack_2.png)'
- en: Now let's see what the different kinds of functions look like using this notation.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看使用这种符号的不同种类的函数是什么样子的。
- en: Let's start with a plain cross-world function such as `a -> Result<b>`, where
    the target world is an applicative world. In the diagram, the input is a normal
    world (on the left), and the output (on the right) is an applicative world stacked
    on top of the normal world.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的跨世界函数开始，比如`a -> Result<b>`，其中目标世界是一个应用世界。在图中，输入是一个正常世界（在左侧），输出（在右侧）是一个堆叠在正常世界上方的应用世界。
- en: '![](vgfp_traverse_cross.png)'
  id: totrans-754
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_traverse_cross.png)'
- en: Now if we have a list of normal `a` values, and then we use `map` to transform
    each `a` value using a function like `a -> Result<b>`, the result will also be
    a list, but where the contents are `Result<b>` values instead of `a` values.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们有一组普通的`a`值，然后我们使用`map`来使用类似`a -> Result<b>`的函数转换每个`a`值，结果也将是一个列表，但其中的内容是`Result<b>`值而不是`a`值。
- en: '![](vgfp_traverse_map.png)'
  id: totrans-756
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_traverse_map.png)'
- en: When it comes to `traverse` the effect is quite different. If we use `traverse`
    to transform a list of `a` values using that function, the output will be a `Result`,
    not a list. And the contents of the `Result` will be a `List<b>`.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到`traverse`时，效果是完全不同的。如果我们使用`traverse`来使用该函数转换`a`值的列表，输出将是一个`Result`，而不是一个列表。而`Result`的内容将是一个`List<b>`。
- en: '![](vgfp_traverse_traverse.png)'
  id: totrans-758
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_traverse_traverse.png)'
- en: In other words, with `traverse`, the `List` stays attached to the normal world,
    and the Applicative world (such as `Result`) is added at the top.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，使用`traverse`，`List`保持连接到正常世界，而Applicative世界（比如`Result`）则添加在顶部。
- en: Ok, I know this all sounds very abstract, but it is actually a very useful technique.
    We'll see an example of this is used in practice below.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我知道这听起来很抽象，但实际上这是一种非常有用的技术。我们将在下面看到一个实际应用的例子。
- en: Applicative vs. monadic versions of `traverse`
  id: totrans-761
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Applicative与monadic版本的`traverse`
- en: It turns out that `traverse` can be implemented in an applicative style or a
    monadic style, so there are often two separate implementations to choose from.
    The applicative versions tend to end in `A` and the monadic versions end in `M`,
    which is helpful!
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，`traverse`可以以applicative风格或monadic风格实现，因此通常有两种不同的实现可供选择。applicative版本通常以`A`结尾，而monadic版本以`M`结尾，这很有帮助！
- en: Let's see how this works with our trusty `Result` type.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这如何与我们可靠的`Result`类型配合使用。
- en: First, we'll implement `traverseResult` using both applicative and monadic approaches.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用applicative和monadic方法实现`traverseResult`。
- en: '[PRE65]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The applicative version is the same implementation that we used earlier.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: applicative版本是我们之前使用的相同实现。
- en: The monadic version applies the function `f` to the first element and then passes
    it to `bind`. As always with monadic style, if the result is bad the rest of the
    list will be skipped.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: Monadic版本将函数`f`应用于第一个元素，然后将其传递给`bind`。与monadic风格一样，如果结果不好，列表的其余部分将被跳过。
- en: On the other hand, if the result is good, the next element in the list is processed,
    and so on. Then the results are cons'ed back together again.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果结果是好的，那么列表中的下一个元素就会被处理，依此类推。然后结果再次连接在一起。
- en: '*NOTE: These implementations are for demonstration only! Neither of these implementations
    are tail-recursive, and so they will fail on large lists!*'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：这些实现仅用于演示！这些实现都不是尾递归的，因此在大型列表上会失败！*'
- en: 'Alright, let''s test the two functions and see how they differ. First we need
    our `parseInt` function:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们测试这两个函数，看看它们有何不同。首先我们需要我们的`parseInt`函数：
- en: '[PRE66]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now if we pass in a list of good values (all parsable), the result for both
    implementations is the same.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们传入一组良好的值（全部可解析），那么两种实现的结果是相同的。
- en: '[PRE67]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: But if we pass in a list with some bad values, the results differ.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们���入一些坏值的列表，结果就会有所不同。
- en: '[PRE68]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The applicative version returns *all* the errors, while the monadic version
    returns only the first error.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: Applicative版本返回*所有*的错误，而monadic版本只返回第一个错误。
- en: Implementing `traverse` using `fold`
  id: totrans-777
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`fold`实现`traverse`
- en: I mentioned above that the "from-scratch" implementation was not tail recursive
    and would fail for large lists. That could be fixed of course, at the price of
    making the code more complicated.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 我上面提到“从头开始”的实现不是尾递归的，对于大型列表会失败。当然，这可以修复，但代价是使代码更复杂。
- en: On the other hand, if your collection type has a "right fold" function, as `List`
    does, then you can use that to make the implementation simpler, faster, and safer
    too.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你的集合类型有一个“右折叠”函数，就像`List`一样，那么你可以使用它来使实现更简单、更快速，也更安全。
- en: In fact, I always like to use `fold` and its ilk wherever possible so that I
    never have to worry about getting tail-recursion right!
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我总是喜欢在可能的情况下使用`fold`及其类似物，这样我就永远不必担心尾递归是否正确！
- en: So, here are the re-implementations of `traverseResult`, using `List.foldBack`.
    I have kept the code as similar as possible, but delegated the looping over the
    list to the fold function, rather than creating a recursive function.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里是使用`List.foldBack`重新实现的`traverseResult`。我尽可能保持代码的相似性，但将循环列表的工作委托给了fold函数，而不是创建一个递归函数。
- en: '[PRE69]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note that this approach will not work for all collection classes. Some types
    do not have a right fold, so `traverse` must be implemented differently.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种方法并不适用于所有集合类。一些类型没有右折叠，因此`traverse`必须以不同的方式实现。
- en: What about types other than lists?
  id: totrans-784
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除了列表之外的类型呢？
- en: All these examples have used the `list` type as the collection type. Can we
    implement `traverse` for other types too?
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例都使用`list`类型作为集合类型。我们能为其他类型实现`traverse`吗？
- en: Yes. For example, an `Option` can be considered a one-element list, and we can
    use the same trick.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。例如，`Option` 可以被认为是一个单元素列表，我们可以使用相同的技巧。
- en: For example, here's an implementation of `traverseResultA` for `Option`
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是 `Option` 的 `traverseResultA` 的一个实现
- en: '[PRE70]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now we can wrap a string in an `Option` and use `parseInt` on it. Rather than
    getting a `Option` of `Result`, we invert the stack and get a `Result` of `Option`.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将字符串包装在 `Option` 中，并对其使用 `parseInt`。而不是得到 `Result` 的 `Option`，我们反转栈并得到
    `Result` 的 `Option`。
- en: '[PRE71]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If we pass in an unparsable string, we get failure:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传入一个无法解析的字符串，我们得到失败：
- en: '[PRE72]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If we pass in `None`, we get `Success` containing `None`!
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传入 `None`，我们得到包含 `None` 的 `Success`！
- en: '[PRE73]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This last result might be surprising at first glance, but think of it this way,
    the parsing didn't fail, so there was no `Failure` at all.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的结果一开始可能会让人感到惊讶，但是这样想一下，解析并没有失败，所以根本没有`Failure`。
- en: Traversables
  id: totrans-796
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可遍历的
- en: Types that can implement a function like `mapXXX` or `traverseXXX` are called
    *Traversable*. For example, collection types are Traversables as well as some
    others.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 能够实现类似 `mapXXX` 或 `traverseXXX` 这样函数的类型称为*可遍历*。例如，集合类型和一些其他类型都是可遍历的。
- en: As we saw above, in a language with type classes a Traversable type can get
    away with just one implementation of `traverse`, but in a language without type
    classes a Traversable type will need one implementation per elevated type.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们上面所看到的，在一个具有类型类的语言中，可遍历类型可以仅使用一个 `traverse` 实现，但在一个没有类型类的语言中，可遍历类型将需要每个提升类型一个实现。
- en: Also note that, unlike all the generic functions we have created before, the
    type being acted on (inside the collection) must have appropriate `apply` and
    `return` functions in order for `traverse` to be implemented. That is, the inner
    type must be an Applicative.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，与我们之前创建的所有通用函数不同，被操作的类型（集合内部）必须具有适当的 `apply` 和 `return` 函数，以便实现 `traverse`。也就是说，内部类型必须是一个
    Applicative。
- en: The properties of a correct `traverse` implementation
  id: totrans-800
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确的 `traverse` 实现的属性
- en: As always, a correct implementation of `traverse` should have some properties
    that are true no matter what elevated world we are working with.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，`traverse` 的正确实现应该具有一些无论我们使用的提升世界如何都成立的属性。
- en: These are the ["Traversable Laws"](https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Traversable.html),
    and a **Traversable** is defined as a generic data type constructor -- `E<T>`
    -- plus a set of functions (`traverse` or `traverseXXX` ) that obey these laws.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是["可遍历法则"](https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Traversable.html)，**可遍历**被定义为一个通用的数据类型构造函数
    -- `E<T>` -- 加上一组遵守这些法则的函数（`traverse` 或 `traverseXXX`）。
- en: The laws are similar to the previous ones. For example, the identity function
    should be mapped correctly, composition should be preserved, etc.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 这些法则与以前的法则类似。例如，标识函数应该正确地映射，组合应该被保留，等等。
- en: '* * *'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The `sequence` function
  id: totrans-805
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`sequence` 函数'
- en: '**Common Names**: `sequence`'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见名称**: `sequence`'
- en: '**Common Operators**: None'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见运算符**: 无'
- en: '**What it does**: Transforms a list of elevated values into an elevated value
    containing a list'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能**: 将提升的值列表转换为包含列表的提升值'
- en: '**Signature**: `E<a> list -> E<a list>` (or variants where list is replaced
    with other collection types)'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '**签名**: `E<a> list -> E<a list>`（或替换 list 为其他集合类型的变体）'
- en: Description
  id: totrans-810
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 描述
- en: We saw above how you can use the `traverse` function as a substitute for `map`
    when you have a function that generates an applicative type such as `Result`.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面看到了当你有一个生成应用类型（如 `Result`）的函数时，可以使用 `traverse` 函数作为 `map` 的替代品。
- en: 'But what happens if you are just handed a `List<Result>` and you need to change
    it to a `Result<List>`. That is, you need to swap the order of the worlds on the
    stack:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你手头只有一个 `List<Result>`，而你需要将其更改为 `Result<List>`。也就是说，你需要交换栈上世界的顺序：
- en: '![](vgfp_sequence_stack.png)'
  id: totrans-813
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_sequence_stack.png)'
- en: This is where `sequence` is useful -- that's exactly what it does! The `sequence`
    function "swaps layers".
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `sequence` 有用的地方 -- 这正是它的作用！`sequence` 函数"交换层"。
- en: 'The order of swapping is fixed:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 交换的顺序是固定的：
- en: The Traversable world starts higher and is swapped *down*.
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可遍历世界从较高处开始，并向*下*交换。
- en: The Applicative world starts lower and is swapped *up*.
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Applicative 世界从较低处开始，并向*上*交换。
- en: Note that if you aleady have an implementation of `traverse`, then `sequence`
    can be derived from it easily. In fact, you can think of `sequence` as `traverse`
    with the `id` function baked in.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您已经有了一个 `traverse` 的实现，那么 `sequence` 可以很容易地从中导出。实际上，您可以将 `sequence` 视为带有
    `id` 函数的 `traverse`。
- en: Applicative vs Monadic versions of `sequence`
  id: totrans-819
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`sequence`的适用版本与单子版本'
- en: 'Just as with `traverse`, there can be applicative and monadic versions of `sequence`:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`traverse`一样，`sequence`可以有适用版本和单子版本：
- en: '`sequenceA` for the applicative one.'
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用版本的`sequenceA`。
- en: '`sequenceM` (or just `sequence`) for the monadic one.'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单子版本的`sequenceM`（或者只是`sequence`）。
- en: A simple example
  id: totrans-823
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个简单的例子
- en: 'Let''s implement and test a `sequence` implementation for `Result`:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`Result`实现一个`sequence`实现并进行测试：
- en: '[PRE74]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Ok, that was too easy! Now let''s test it, starting with the applicative version:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这太容易了！现在让我们来测试它，从适用版本开始：
- en: '[PRE75]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'and then the monadic version:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 然后单子版本：
- en: '[PRE76]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: As before, we get back a `Result<List>`, and as before the monadic version stops
    on the first error, while the applicative version accumulates all the errors.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 与以往一样，我们会得到一个`Result<List>`，与单子版本一样，在遇到第一个错误时停止，而适用版本会累积所有的错误。
- en: '* * *'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '"Sequence" as a recipe for ad-hoc implementations'
  id: totrans-832
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '"Sequence"作为一种特定实现的配方'
- en: We saw above that having type classes like Applicative means that you only need
    to implement `traverse` and `sequence` once. In F# and other languages without
    high-kinded types you have to create an implementation for each type that you
    want to traverse over.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上面看到，拥有类似Applicative的类型类意味着您只需要一次实现`traverse`和`sequence`。在F#和其他没有高种类型的语言中，您必须为要遍历的每种类型创建一个实现。
- en: Does that mean that the concepts of `traverse` and `sequence` are irrelevant
    or too abstract? I don't think so.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着`traverse`和`sequence`的概念是无关紧要或太抽象了？我不这么认为。
- en: Instead of thinking of them as library functions, I find that it is useful to
    think of them as *recipes* -- a set of instructions that you can follow mechanically
    to solve a particular problem.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将它们视为库函数，我发现将它们视为*配方*更有用--一套机械化地解决特定问题的指令。
- en: In many cases, the problem is unique to a context, and there is no need to create
    a library function -- you can create a helper function as needed.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，问题是唯一的上下文相关的，并且没有必要创建库函数--您可以根据需要创建辅助函数。
- en: 'Let me demonstrate with an example. Say that you are given a list of options,
    where each option contains a tuple, like this:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 让我用一个例子来演示。假设您有一个选项列表，其中每个选项包含一个元组，像这样：
- en: '[PRE77]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This data is in the form `List<Option<Tuple<int>>>`. And now say, that for
    some reason, you need to turn it into a *tuple* of two lists, where each list
    contains options, like this:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据以`List<Option<Tuple<int>>>`的形式呈现。现在假设，出于某种原因，您需要将其转换为包含选项的两个列表的*元组*，像这样：
- en: '[PRE78]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The desired result is in the form `Tuple<List<Option<int>>>`.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的结果是`Tuple<List<Option<int>>>`的形式。
- en: So, how would you write a function to do this? Quick!
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您将如何编写执行此操作的函数？快点！
- en: No doubt you could come up with one, but it might require a bit of thought and
    testing to be sure you get it right.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，您可以想出一个，但是为了确保正确，您可能需要一点思考和测试。
- en: On the other hand, if you recognize that this task is just transforming a stack
    of worlds to another stack, you can create a function *mechanically*, almost without
    thinking.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您认识到这个任务只是将一堆世界转换为另一堆世界，您几乎可以*机械化*地创建一个函数，几乎不用思考。
- en: '![](vgfp_tuple_sequence-1.png)'
  id: totrans-845
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_tuple_sequence-1.png)'
- en: Designing the solution
  id: totrans-846
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计解决方案
- en: To design the solution, we need to pay attention to which worlds move up and
    which worlds move down.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 要设计解决方案，我们需要注意哪些世界向上移动，哪些世界向下移动。
- en: The tuple world needs to end up at the top, so it will have to be swapped "up",
    which in turn means that it will play the role of "applicative".
  id: totrans-848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组世界需要最终位于顶部，因此它将不得不向上交换，这反过来意味着它将扮演“适用”的角色。
- en: The option and list worlds need to be swapped "down", which in turn means that
    they will both play the role of "traversable".
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项和列表世界需要向下交换，这反过来意味着它们都将扮演“可遍历”的角色。
- en: 'In order to do this transform then, I will need two helper functions:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了执行此转换，我将需要两个辅助函数：
- en: '`optionSequenceTuple` will move an option down and a tuple up.'
  id: totrans-851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`optionSequenceTuple`会将一个选项向下移动，一个元组向上移动。'
- en: '![](vgfp_tuple_sequence-2.png)'
  id: totrans-852
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_tuple_sequence-2.png)'
- en: '`listSequenceTuple` will move a list down and a tuple up.'
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listSequenceTuple`会将一个列表向下移动，一个元组向上移动。'
- en: '![](vgfp_tuple_sequence-3.png)'
  id: totrans-854
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_tuple_sequence-3.png)'
- en: Do these helper functions need to be in a library? No. It's unlikely that I
    will need them again, and even I need them occasionally, I'd prefer to write them
    scratch to avoid having to take a dependency.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 这些辅助函数是否需要在库中？不。我不太可能再次需要它们，即使我偶尔需要它们，我也更愿意从头开始编写它们，以避免必须承担依赖关系。
- en: On the other hand, the `List.sequenceResult` function implemented earlier that
    converts a `List<Result<a>>` to a `Result<List<a>>` is something I do use frequently,
    and so that one *is* worth centralizing.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，之前实现的`List.sequenceResult`函数，将`List<Result<a>>`转换为`Result<List<a>>`是我经常使用的，所以这个函数值得集中处理。
- en: Implementing the solution
  id: totrans-857
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现解决方案
- en: Once we know how the solution will look, we can start coding mechanically.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道解决方案的样子，我们就可以开始机械地编码了。
- en: 'First, the tuple is playing the role of the applicative, so we need to define
    the `apply` and `return` functions:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，元组扮演应用型的角色，所以我们需要定义`apply`和`return`函数：
- en: '[PRE79]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next, define `listSequenceTuple` using exactly the same right fold template
    as we did before, with `List` as the traversable and tuple as the applicative:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用与之前完全相同的右折叠模板定义`listSequenceTuple`，其中`List`是可遍历的，元组是应用型的：
- en: '[PRE80]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: There is no thinking going on here. I'm just following the template!
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有思考。我只是在按照模板来！
- en: 'We can test it immediately:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即测试它：
- en: '[PRE81]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: And it gives a tuple with two lists, as expected.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 它给出了一个包含两个列表的元组，如预期的那样。
- en: 'Similarly, define `optionSequenceTuple` using the same right fold template
    again. This time `Option` is the traversable and tuple is still the applicative:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，再次使用相同的右折叠模板定义`optionSequenceTuple`。这次`Option`是可遍历的，元组仍然是应用型的：
- en: '[PRE82]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We can test it too:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以测试一下：
- en: '[PRE83]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: And it gives a tuple with two options, as expected.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 它给出了一个包含两个选项的元组，如预期的那样。
- en: Finally, we can glue all the parts together. Again, no thinking required!
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将所有部分粘合在一起。同样，不需要思考！
- en: '[PRE84]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'And if we use it, we get just what we wanted:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用它，我们就得到了我们想要的：
- en: '[PRE85]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Ok, this solution is more work than having one reusable function, but because
    it is mechanical, it only takes a few minutes to code, and is still easier than
    trying to come up with your own solution!
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这个解决方案比有一个可重用函数更费力，但因为它是机械的，编码只需要几分钟，而且比尝试想出自己的解决方案还要容易！
- en: '*Want more? For an example of using `sequence` in a real-world problem, please
    read [this post](recursive-types-and-folds-3b.html#json-with-error-handling).*'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '*还想了解更多？关于在实际问题中使用`sequence`的示例，请阅读[此帖子](recursive-types-and-folds-3b.html#json-with-error-handling)。*'
- en: '* * *'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Readability vs. performance
  id: totrans-879
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可读性与性能
- en: At the beginning of this post I noted our tendency as functional programmers
    to `map` first and ask questions later.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文的开头，我提到了我们作为函数式程序员倾向于先`map`再问问题的倾向。
- en: 'In other words, given a `Result` producing function like `parseInt`, we would
    start by collecting the results and only then figure out how to deal with them.
    Our code would look something like this, then:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，给定一个像`parseInt`这样产生`Result`的函数，我们会先收集结果，然后再想办法处理它们。那么我们的代码会是这样的：
- en: '[PRE86]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'But of course, this does involve two passes over the list, and we saw how `traverse`
    could combine the `map` and the `sequence` in one step, making only one pass over
    the list, like this:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 但当然，这确实涉及两次对列表的遍历，我们已经看到`traverse`如何将`map`和`sequence`结合到一个步骤中，只对列表进行一次遍历，就像这样：
- en: '[PRE87]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: So if `traverse` is more compact and potentially faster, why ever use `sequence`?
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果`traverse`更紧凑且潜在地更快，为什么还要使用`sequence`？
- en: Well, sometimes you are given a certain structure and you have no choice, but
    in other situations I might still prefer the two-step `map-sequence` approach
    just because it is easier to understand. The mental model for "map" then "swap"
    seems easier to grasp for most people than the one-step traverse.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，有时候你会被给定一个特定的结构，你别无选择，但在其他情况下，我可能仍然更喜欢两步的`map-sequence`方法，只因为它更容易理解。对于大多数人来说，“map”然后“swap”的思维模型似乎更容易理解，比一步到位的遍历要容易。
- en: In other words, I would always go for readability unless you can prove that
    performance is impacted. Many people are still learning FP, and being overly cryptic
    is not helpful, in my experience.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我总是会选择可读性，除非你能证明性能受到影响。在我看来，过度神秘并不是有用的，因为许多人仍在学习FP。
- en: '* * *'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Dude, where's my `filter`?
  id: totrans-889
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伙计，我的`filter`在哪里？
- en: We've seen that functions like `map` and `sequence` work on lists to transform
    them into other types, but what about filtering? How can I filter things using
    these methods?
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到像`map`和`sequence`这样的函数在列表上起作用，将它们转换为其他类型，但过滤呢？我怎样才能使用这些方法来过滤事物？
- en: The answer is -- you can't! `map`, and `traverse` and `sequence` are all "structure
    preserving". If you start with a list of 10 things you still have a list of 10
    things afterwards, albeit somewhere else in the stack. Or if you start with a
    tree with three branches, you still have a tree of three branches at the end.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是——你做不到！`map`、`traverse` 和 `sequence` 都是“保持结构不变”的。如果你从一个包含 10 个元素的列表开始，之后你仍然有一个包含
    10 个元素的列表，只是在堆栈的其他位置。或者如果你从一个有三个分支的树开始，最后你仍然有一个有三个分支的树。
- en: In the tuple example above, the original list had four elements, and after the
    transformation, the two new lists in the tuple also had four elements.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的元组示例中，原始列表有四个元素，转换后，元组中的两个新列表也有四个元素。
- en: If you need to *change* the structure of a type, you need to use something like
    `fold`. Fold allows you to build a new structure from an old one, which means
    that you can use it to create a new list with some elements missing (i.e. a filter).
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要*改变*类型的结构，你需要使用类似 `fold` 的东西。Fold 允许你从旧结构中构建一个新结构，这意味着你可以用它来创建一个新列表，其中一些元素缺失（即过滤器）。
- en: The various uses of fold are worthy of their own series, so I'm going to save
    a discussion of filtering for another time.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 对 fold 的各种用法值得拿出一个系列来讨论，所以我将把过滤的讨论留到另一个时机。
- en: Summary
  id: totrans-895
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概要
- en: In this post, we learned about `traverse` and `sequence` as a way of working
    with lists of elevated values.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们学习了使用 traverse 和 sequence 处理提升值列表的方法。
- en: In the [next post](elevated-world-5.html) we'll finish up by working through
    a practical example that uses all the techniques that have been discussed.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 在[下一篇文章](elevated-world-5.html)中，我们将通过一个实际示例来完成，该示例使用了所有已讨论的技术。
- en: Using map, apply, bind and sequence in practice
  id: totrans-898
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实践中使用 map、apply、bind 和 sequence
- en: Using map, apply, bind and sequence in practice
  id: totrans-899
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实践中使用 map、apply、bind 和 sequence
- en: 'This post is the fifth in a series. In the [first two posts](elevated-world.html),
    I described some of the core functions for dealing with generic data types: `map`,
    `bind`, and so on. In the [third post](elevated-world-3.html), I discussed "applicative"
    vs "monadic" style, and how to lift values and functions to be consistent with
    each other. In the [previous post](elevated-world-4.html), I introduced `traverse`
    and `sequence` as a way of working with lists of elevated values.'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 本文是系列的第五篇。在[前两篇文章](elevated-world.html)中，我描述了一些处理通用数据类型的核心函数：map、bind 等等。在[第三篇文章](elevated-world-3.html)中，我讨论了“应用”与“单子”风格，以及如何提升值和函数使它们彼此一致。在[上一篇文章](elevated-world-4.html)中，我介绍了使用
    traverse 和 sequence 处理提升值列表的方法。
- en: In this post, we'll finish up by working through a practical example that uses
    all the techniques that have been discussed so far.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将通过一个实际示例来完成，该示例使用了到目前为止已讨论的所有技术。
- en: Series contents
  id: totrans-902
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系列内容
- en: 'Here''s a list of shortcuts to the various functions mentioned in this series:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是提及本系列各种函数的快捷方式列表：
- en: '**Part 1: Lifting to the elevated world**'
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一部分：提升到提升世界**'
- en: '[The `map` function](elevated-world.html#map)'
  id: totrans-905
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[map 函数](elevated-world.html#map)'
- en: '[The `return` function](elevated-world.html#return)'
  id: totrans-906
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[return 函数](elevated-world.html#return)'
- en: '[The `apply` function](elevated-world.html#apply)'
  id: totrans-907
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[apply 函数](elevated-world.html#apply)'
- en: '[The `liftN` family of functions](elevated-world.html#lift)'
  id: totrans-908
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[liftN 函数族](elevated-world.html#lift)'
- en: '[The `zip` function and ZipList world](elevated-world.html#zip)'
  id: totrans-909
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[zip 函数和 ZipList 世界](elevated-world.html#zip)'
- en: '**Part 2: How to compose world-crossing functions**'
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二部分：如何组合跨世界函数**'
- en: '[The `bind` function](elevated-world-2.html#bind)'
  id: totrans-911
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[bind 函数](elevated-world-2.html#bind)'
- en: '[List is not a monad. Option is not a monad.](elevated-world-2.html#not-a-monad)'
  id: totrans-912
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[列表不是一个单子。选项不是一个单子。](elevated-world-2.html#not-a-monad)'
- en: '**Part 3: Using the core functions in practice**'
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三部分：在实践中使用核心函数**'
- en: '[Independent and dependent data](elevated-world-3.html#dependent)'
  id: totrans-914
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[独立和依赖数据](elevated-world-3.html#dependent)'
- en: '[Example: Validation using applicative style and monadic style](elevated-world-3.html#validation)'
  id: totrans-915
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：使用应用风格和单子风格进行验证](elevated-world-3.html#validation)'
- en: '[Lifting to a consistent world](elevated-world-3.html#consistent)'
  id: totrans-916
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提升到一致世界](elevated-world-3.html#consistent)'
- en: '[Kleisli world](elevated-world-3.html#kleisli)'
  id: totrans-917
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kleisli 世界](elevated-world-3.html#kleisli)'
- en: '**Part 4: Mixing lists and elevated values**'
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第四部分：混合列表和提升值**'
- en: '[Mixing lists and elevated values](elevated-world-4.html#mixing)'
  id: totrans-919
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[混合列表和提升值](elevated-world-4.html#mixing)'
- en: '[The `traverse`/`MapM` function](elevated-world-4.html#traverse)'
  id: totrans-920
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[traverse/MapM 函数](elevated-world-4.html#traverse)'
- en: '[The `sequence` function](elevated-world-4.html#sequence)'
  id: totrans-921
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[序列函数](elevated-world-4.html#sequence)'
- en: '["Sequence" as a recipe for ad-hoc implementations](elevated-world-4.html#adhoc)'
  id: totrans-922
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“序列”作为即兴实现的配方](elevated-world-4.html#adhoc)'
- en: '[Readability vs. performance](elevated-world-4.html#readability)'
  id: totrans-923
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可读性 vs. 性能](elevated-world-4.html#readability)'
- en: '[Dude, where''s my `filter`?](elevated-world-4.html#filter)'
  id: totrans-924
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[伙计，我的`filter`在哪里？](elevated-world-4.html#filter)'
- en: '**Part 5: A real-world example that uses all the techniques**'
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 5 部分：使用所有技术的真实示例**'
- en: '[Example: Downloading and processing a list of websites](elevated-world-5.html#asynclist)'
  id: totrans-926
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：下载和处理网站列表](elevated-world-5.html#asynclist)'
- en: '[Treating two worlds as one](elevated-world-5.html#asyncresult)'
  id: totrans-927
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将两个世界视为一个](elevated-world-5.html#asyncresult)'
- en: '**Part 6: Designing your own elevated world**'
  id: totrans-928
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 6 部分：设计自己的升级世界**'
- en: '[Designing your own elevated world](elevated-world-6.html#part6)'
  id: totrans-929
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[设计自己的升级世界](elevated-world-6.html#part6)'
- en: '[Filtering out failures](elevated-world-6.html#filtering)'
  id: totrans-930
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[过滤失败](elevated-world-6.html#filtering)'
- en: '[The Reader monad](elevated-world-6.html#readermonad)'
  id: totrans-931
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Reader monad](elevated-world-6.html#readermonad)'
- en: '**Part 7: Summary**'
  id: totrans-932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 7 部分：摘要**'
- en: '[List of operators mentioned](elevated-world-7.html#operators)'
  id: totrans-933
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[提及的运算符列表](elevated-world-7.html#operators)'
- en: '[Further reading](elevated-world-7.html#further-reading)'
  id: totrans-934
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[进一步阅读](elevated-world-7.html#further-reading)'
- en: '* * *'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Part 5: A real-world example that uses all the techniques'
  id: totrans-936
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 5 部分：使用所有技术的真实示例
- en: '* * *'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Example: Downloading and processing a list of websites'
  id: totrans-938
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：下载和处理网站列表
- en: 'The example will be a variant of the one mentioned at the beginning of the
    [third post](elevated-world-3.html):'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例将是在[第三篇文章](elevated-world-3.html)开头提到的一个变体：
- en: Given a list of websites, create an action that finds the site with the largest
    home page.
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个网站列表，创建一个找到具有最大主页的站点的操作。
- en: 'Let''s break this down into steps:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分步进行：
- en: First we'll need to transform the urls into a list of actions, where each action
    downloads the page and gets the size of the content.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将网址转换成一个操作列表，其中每个操作都会下载页面并获取内容的大小。
- en: And then we need to find the largest content, but in order to do this we'll
    have to convert the list of actions into a single action containing a list of
    sizes. And that's where `traverse` or `sequence` will come in.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要找到最大的内容，但为了做到这一点，我们将不得不将操作列表转换为包含大小列表的单个操作。这就是`traverse`或`sequence`会发挥作用的地方。
- en: Let's get started!
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: The downloader
  id: totrans-945
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载程序
- en: First we need to create a downloader. I would use the built-in `System.Net.WebClient`
    class, but for some reason it doesn't allow override of the timeout. I'm going
    to want to have a small timeout for the later tests on bad uris, so this is important.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个下载器。我会使用内置的`System.Net.WebClient`类，但出于某种原因它不允许超时的重写。我将希望在后面对坏的URIs进行较小的超时测试，因此这很重要。
- en: 'One trick is to just subclass `WebClient` and intercept the method that builds
    a request. So here it is:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 一个技巧是简单地对`WebClient`进行子类化并拦截构建请求的方法。所以这里是：
- en: '[PRE88]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Notice that I'm using units of measure for the timeout value. I find that units
    of measure are invaluable to distiguish seconds from milliseconds. I once accidentally
    set a timeout to 2000 seconds rather than 2000 milliseconds and I don't want to
    make that mistake again!
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我在超时值上使用的计量单位。我发现计量单位对于区分秒和毫秒非常宝贵。我曾经不小心将超时设置为2000秒而不是2000毫秒，我不想再犯这个错误！
- en: The next bit of code defines our domain types. We want to be able to keep the
    url and the size together as we process them. We could use a tuple, but I am a
    proponent of [using types to model your domain](designing-with-types-single-case-dus.html),
    if only for documentation.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分代码定义了我们的领域类型。我们希望在处理它们时能够将网址和大小保持在一起。我们可以使用元组，但我主张[使用类型来模拟您的领域](designing-with-types-single-case-dus.html)，即使只是用于文档目的。
- en: '[PRE89]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Yes, this might be overkill for a trivial example like this, but in a more serious
    project I think it is very much worth doing.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这对于像这样的琐事示例可能有些大材小用，但在一个更严肃的项目中，我认为这是非常值得做的。
- en: 'Now for the code that does the downloading:'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是执行下载的代码：
- en: '[PRE90]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Notes:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: The .NET library will throw on various errors, so I am catching that and turning
    it into a `Failure`.
  id: totrans-956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET库会在各种错误上抛出异常，所以我正在捕获并将其转换为`Failure`。
- en: The `use client =` section ensures that the client will be correctly disposed
    at the end of the block.
  id: totrans-957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use client =` 部分确保在块结束时客户端将被正确处理。'
- en: The whole operation is wrapped in an `async` workflow, and the `let! html =
    client.AsyncDownloadString` is where the download happens asynchronously.
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个操作都包装在一个`async`工作流中，而`let! html = client.AsyncDownloadString`就是异步下载发生的地方。
- en: I've added some `printfn`s for tracing, just for this example. In real code,
    I wouldn't do this of course!
  id: totrans-959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我添加了一些 `printfn` 用于跟踪，仅供此示例使用。在真实代码中，我当然不会这样做！
- en: 'Before moving on, let''s test this code interactively. First we need a helper
    to print the result:'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们交互式地测试这段代码。首先我们需要一个辅助函数来打印结果：
- en: '[PRE91]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'And then we can try it out on a good site:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在一个好的网站上试一试：
- en: '[PRE92]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'and a bad one:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不好的例子：
- en: '[PRE93]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Extending the Async type with `map` and `apply` and `bind`
  id: totrans-966
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `map`、`apply` 和 `bind` 扩展 Async 类型
- en: 'At this point, we know that we are going to be dealing with the world of `Async`,
    so before we go any further, let''s make sure that we have our four core functions
    available:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们知道我们将要处理 `Async` 的世界，所以在继续之前，让我们确保我们有我们的四个核心函数可用：
- en: '[PRE94]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'These implementations are straightforward:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实现很简单：
- en: I'm using the `async` workflow to work with `Async` values.
  id: totrans-970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我正在使用 `async` 工作流来处理 `Async` 值。
- en: The `let!` syntax in `map` extracts the content from the `Async` (meaning run
    it and await the result).
  id: totrans-971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map` 中的 `let!` 语法提取 `Async` 中的内容（意味着运行它并等待结果）。'
- en: The `return` syntax in `map`, `retn`, and `apply` lifts the value to an `Async`
    using `return`.
  id: totrans-972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`、`retn` 和 `apply` 中的 `return` 语法使用 `return` 将值提升为 `Async`。'
- en: The `apply` function runs the two parameters in parallel using a fork/join pattern.
    If I had instead written `let! fChild = ...` followed by a `let! xChild = ...`
    that would have been monadic and sequential, which is not what I wanted.
  id: totrans-973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply` 函数使用 fork/join 模式并行运行两个参数。如果我改为写 `let! fChild = ...` 然后是 `let! xChild
    = ...`，那将是单调和顺序的，这不是我想要的。'
- en: The `return!` syntax in `bind` means that the value is already lifted and *not*
    to call `return` on it.
  id: totrans-974
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bind` 中的 `return!` 语法意味着该值已经被提升，*不*需要调用 `return`。'
- en: Getting the size of the downloaded page
  id: totrans-975
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取已下载页面的大小
- en: 'Getting back on track, we can continue from the downloading step and move on
    to the process of converting the result to a `UriContentSize`:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 回到正轨，我们可以从下载步骤继续，然后转换结果为 `UriContentSize` 的过程：
- en: '[PRE95]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: If the input html is null or empty we'll treat this an error, otherwise we'll
    return a `UriContentSize`.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入的 html 为 null 或空，我们将视其为错误，否则我们将返回一个 `UriContentSize`。
- en: 'Now we have two functions and we want to combine them into one "get UriContentSize
    given a Uri" function. The problem is that the outputs and inputs don''t match:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个函数，我们想将它们合并成一个“给定 Uri 获取 UriContentSize”的函数。问题在于输出和输入不匹配：
- en: '`getUriContent` is `Uri -> Async<Result<UriContent>>`'
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getUriContent` 是 `Uri -> Async<Result<UriContent>>`'
- en: '`makeContentSize` is `UriContent -> Result<UriContentSize>`'
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`makeContentSize` 是 `UriContent -> Result<UriContentSize>`'
- en: The answer is to transform `makeContentSize` from a function that takes a `UriContent`
    as input into a function that takes a `Async<Result<UriContent>>` as input. How
    can we do that?
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是将 `makeContentSize` 从一个以 `UriContent` 作为输入的函数转换为一个以 `Async<Result<UriContent>>`
    作为输入的函数。我们该如何做呢？
- en: First, use `Result.bind` to convert it from an `a -> Result<b>` function to
    a `Result<a> -> Result<b>` function. In this case, `UriContent -> Result<UriContentSize>`
    becomes `Result<UriContent> -> Result<UriContentSize>`.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `Result.bind` 将其从一个 `a -> Result<b>` 函数转换为一个 `Result<a> -> Result<b>`
    函数。在这种情况下，`UriContent -> Result<UriContentSize>` 变为 `Result<UriContent> -> Result<UriContentSize>`。
- en: Next, use `Async.map` to convert it from an `a -> b` function to a `Async<a>
    -> Async<b>` function. In this case, `Result<UriContent> -> Result<UriContentSize>`
    becomes `Async<Result<UriContent>> -> Async<Result<UriContentSize>>`.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `Async.map` 将其从一个 `a -> b` 函数转换为一个 `Async<a> -> Async<b>` 函数。在这种情况下，`Result<UriContent>
    -> Result<UriContentSize>` 变为 `Async<Result<UriContent>> -> Async<Result<UriContentSize>`。
- en: '![](vgfp_urlcontentsize.png)'
  id: totrans-985
  prefs: []
  type: TYPE_IMG
  zh: '![](vgfp_urlcontentsize.png)'
- en: 'And now that it has the right kind of input, so we can compose it with `getUriContent`:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它有了正确类型的输入，所以我们可以与 `getUriContent` 组合：
- en: '[PRE96]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: That's some gnarly type signature, and it's only going to get worse! It's at
    times like these that I really appreciate type inference.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些复杂的类型签名，而且它只会变得更糟！在这种时候，我真的很感激类型推断。
- en: 'Let''s test again. First a helper to format the result:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次测试。首先是一个格式化结果的辅助函数：
- en: '[PRE97]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'And then we can try it out on a good site:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在一个好的网站上试一试：
- en: '[PRE98]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'and a bad one:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不好的例子：
- en: '[PRE99]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Getting the largest size from a list
  id: totrans-995
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从列表中获取最大的大小
- en: The last step in the process is to find the largest page size.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 过程中的最后一步是找到最大的页面大小。
- en: 'That''s easy. Once we have a list of `UriContentSize`, we can easily find the
    largest one using `List.maxBy`:'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 那很容易。一旦我们有一个 `UriContentSize` 列表，我们可以很容易地使用 `List.maxBy` 找到最大的一个：
- en: '[PRE100]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Putting it all together
  id: totrans-999
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: 'We''re ready to assemble all the pieces now, using the following algorithm:'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: Start with a list of urls
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn the list of strings into a list of uris (`Uri list`)
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn the list of `Uri`s into a list of actions (`Async<Result<UriContentSize>>
    list`)
  id: totrans-1003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next we need to swap the top two parts of the stack. That is, transform a `List<Async>`
    into a `Async<List>`.
  id: totrans-1004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](vgfp_download_stack_1.png)'
  id: totrans-1005
  prefs: []
  type: TYPE_IMG
- en: Next we need to swap the *bottom* two parts of the stack -- transform a `List<Result>`
    into a `Result<List>`. But the two bottom parts of the stack are wrapped in an
    `Async` so we need to use `Async.map` to do this.
  id: totrans-1006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](vgfp_download_stack_2.png)'
  id: totrans-1007
  prefs: []
  type: TYPE_IMG
- en: Finally we need to use `List.maxBy` on the bottom `List` to convert it into
    a single value. That is, transform a `List<UriContentSize>` into a `UriContentSize`.
    But the bottom of the stack is wrapped in a `Result` wrapped in an `Async` so
    we need to use `Async.map` and `Result.map` to do this.
  id: totrans-1008
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](vgfp_download_stack_3.png)'
  id: totrans-1009
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the complete code:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This function has signature `string list -> Async<Result<UriContentSize>>`,
    which is just what we wanted!
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two `sequence` functions involved here: `sequenceAsyncA` and `sequenceResultA`.
    The implementations are as you would expect from all the previous discussion,
    but I''ll show the code anyway:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Adding a timer
  id: totrans-1015
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It will be interesting to see how long the download takes for different scenarios,
    so let''s create a little timer that runs a function a certain number of times
    and takes the average:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Ready to download at last
  id: totrans-1018
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's download some sites for real!
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll define two lists of sites: a "good" one, where all the sites should
    be accessible, and a "bad" one, containing invalid sites.'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Let''s start by running `largestPageSizeA` 10 times with the good sites list:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The output is something like this:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: We can see immediately that the downloads are happening in parallel -- they
    have all started before the first one has finished.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: Now what about if some of the sites are bad?
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The output is something like this:'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Again, all the downloads are happening in parallel, and all four failures are
    returned.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: Optimizations
  id: totrans-1032
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `largestPageSizeA` has a series of maps and sequences in it which means
    that the list is being iterated over three times and the async mapped over twice.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: As [I said earlier](elevated-world-4.html#readability), I prefer clarity over
    micro-optimizations unless there is proof otherwise, and so this does not bother
    me.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: However, let's look at what you *could* do if you wanted to.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the original version, with comments removed:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The first two `List.map`s could be combined:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The `map-sequence` can be replaced with a `traverse`:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'and finally the two `Async.map`s can be combined too:'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Personally, I think we've gone too far here. I prefer the original version to
    this one!
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, one way to get the best of both worlds is to use a "streams" library
    that automatically merges the maps for you. In F#, a good one is [Nessos Streams](https://nessos.github.io/Streams/).
    Here is [a blog post showing the difference](http://trelford.com/blog/post/SeqVsStream.aspx)
    between streams and the standard `seq`.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the monadic way
  id: totrans-1046
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's reimplement the downloading logic using monadic style and see what difference
    it makes.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need a monadic version of the downloader:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: This one uses the monadic `sequence` functions (I won't show them -- the implementation
    is as you expect).
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run `largestPageSizeM` 10 times with the good sites list and see if
    there is any difference from the applicative version:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The output is something like this:'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: There is a big difference now -- it is obvious that the downloads are happening
    in series -- each one starts only when the previous one has finished.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the average time is 955ms per run, almost twice that of the applicative
    version.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: Now what about if some of the sites are bad? What should we expect? Well, because
    it's monadic, we should expect that after the first error, the remaining sites
    are skipped, right? Let's see if that happens!
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The output is something like this:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Well that was unexpected! All of the sites were visited in series, even though
    the first one had an error. But in that case, why is only the *first* error returned,
    rather than *all* the the errors?
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: Can you see what went wrong?
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the problem
  id: totrans-1063
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason why the implementation did not work as expected is that the chaining
    of the `Async`s was independent of the chaining of the `Result`s.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: 'If you step through this in a debugger you can see what is happening:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: The first `Async` in the list was run, resulting in a failure.
  id: totrans-1066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Async.bind` was used with the next `Async` in the list. But `Async.bind` has
    no concept of error, so the next `Async` was run, producing another failure.'
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this way, all the `Async`s were run, producing a list of failures.
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list of failures was then traversed using `Result.bind`. Of course, because
    of the bind, only the first one was processed and the rest ignored.
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final result was that all the `Async`s were run but only the first failure
    was returned.
  id: totrans-1070
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: Treating two worlds as one
  id: totrans-1072
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fundamental problem is that we are treating the `Async` list and `Result`
    list as *separate* things to be traversed over. But that means that a failed `Result`
    has no influence on whether the next `Async` is run.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: What we want to do, then, is tie them together so that a bad result *does* determine
    whether the next `Async` is run.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: And in order to do that, we need to treat the `Async` and the `Result` as a
    *single* type -- let's imaginatively call it `AsyncResult`.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: 'If they are a single type, then `bind` looks like this:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_asyncresult-1.png)'
  id: totrans-1077
  prefs: []
  type: TYPE_IMG
- en: meaning that the previous value will determine the next value.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: 'And also, the "swapping" becomes much simpler:'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_asyncresult-2.png)'
  id: totrans-1080
  prefs: []
  type: TYPE_IMG
- en: Defining the AsyncResult type
  id: totrans-1081
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OK, let's define the `AsyncResult` type and it's associated `map`, `return`,
    `apply` and `bind` functions.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Notes:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: The type alias is optional. We can use `Async<Result<'a>>` directly in the code
    and it wil work fine. The point is that *conceptually* `AsyncResult` is a separate
    type.
  id: totrans-1085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bind` implementation is new. The continuation function `f` is now crossing
    *two* worlds, and has the signature `'a -> Async<Result<'b>>`.
  id: totrans-1086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the inner `Result` is successful, the continuation function `f` is evaluated
    with the result. The `return!` syntax means that the return value is already lifted.
  id: totrans-1087
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the inner `Result` is a failure, we have to lift the failure to an Async.
  id: totrans-1088
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the traverse and sequence functions
  id: totrans-1089
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With `bind` and `return` in place, we can create the appropriate `traverse`
    and `sequence` functions for `AsyncResult`:'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Defining and testing the downloading functions
  id: totrans-1092
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, the `largestPageSize` function is simpler now, with only one sequence
    needed.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Let''s run `largestPageSizeM_AR` 10 times with the good sites list and see
    if there is any difference from the applicative version:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The output is something like this:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Again, the downloads are happening in series. And again, the time per run is
    almost twice that of the applicative version.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: And now the moment we've been waiting for! Will it skip the downloading after
    the first bad site?
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The output is something like this:'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Success! The error from the first bad site prevented the rest of the downloads,
    and the short run time is proof of that.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post, we worked through a small practical example. I hope that this
    example demonstrated that `map`, `apply`, `bind`, `traverse`, and `sequence` are
    not just academic abstractions but essential tools in your toolbelt.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: In the [next post](elevated-world-6.html) we'll working through another practical
    example, but this time we will end up creating our *own* elevated world. See you
    then!
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: Reinventing the Reader monad
  id: totrans-1108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reinventing the Reader monad
  id: totrans-1109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This post is the sixth in a series. In the [first two posts](elevated-world.html),
    I described some of the core functions for dealing with generic data types: `map`,
    `bind`, and so on. In the [third post](elevated-world-3.html), I discussed "applicative"
    vs "monadic" style, and how to lift values and functions to be consistent with
    each other. In the [fourth](elevated-world-4.html) and [previous](elevated-world-5.html)
    posts, I introduced `traverse` and `sequence` as a way of working with lists of
    elevated values, and we saw this used in a practical example: downloading some
    URLs.'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we'll finish up by working through another practical example,
    but this time we'll create our own "elevated world" as a way to deal with awkward
    code. We'll see that this approach is so common that it has a name -- the "Reader
    monad".
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  id: totrans-1112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a list of shortcuts to the various functions mentioned in this series:'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Lifting to the elevated world**'
  id: totrans-1114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `map` function](elevated-world.html#map)'
  id: totrans-1115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `return` function](elevated-world.html#return)'
  id: totrans-1116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `apply` function](elevated-world.html#apply)'
  id: totrans-1117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `liftN` family of functions](elevated-world.html#lift)'
  id: totrans-1118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `zip` function and ZipList world](elevated-world.html#zip)'
  id: totrans-1119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: How to compose world-crossing functions**'
  id: totrans-1120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `bind` function](elevated-world-2.html#bind)'
  id: totrans-1121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List is not a monad. Option is not a monad.](elevated-world-2.html#not-a-monad)'
  id: totrans-1122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Using the core functions in practice**'
  id: totrans-1123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Independent and dependent data](elevated-world-3.html#dependent)'
  id: totrans-1124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Validation using applicative style and monadic style](elevated-world-3.html#validation)'
  id: totrans-1125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lifting to a consistent world](elevated-world-3.html#consistent)'
  id: totrans-1126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kleisli world](elevated-world-3.html#kleisli)'
  id: totrans-1127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Mixing lists and elevated values**'
  id: totrans-1128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mixing lists and elevated values](elevated-world-4.html#mixing)'
  id: totrans-1129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `traverse`/`MapM` function](elevated-world-4.html#traverse)'
  id: totrans-1130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `sequence` function](elevated-world-4.html#sequence)'
  id: totrans-1131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '["Sequence" as a recipe for ad-hoc implementations](elevated-world-4.html#adhoc)'
  id: totrans-1132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Readability vs. performance](elevated-world-4.html#readability)'
  id: totrans-1133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dude, where''s my `filter`?](elevated-world-4.html#filter)'
  id: totrans-1134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: A real-world example that uses all the techniques**'
  id: totrans-1135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Downloading and processing a list of websites](elevated-world-5.html#asynclist)'
  id: totrans-1136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Treating two worlds as one](elevated-world-5.html#asyncresult)'
  id: totrans-1137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Designing your own elevated world**'
  id: totrans-1138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Designing your own elevated world](elevated-world-6.html#part6)'
  id: totrans-1139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering out failures](elevated-world-6.html#filtering)'
  id: totrans-1140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Reader monad](elevated-world-6.html#readermonad)'
  id: totrans-1141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 7: Summary**'
  id: totrans-1142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List of operators mentioned](elevated-world-7.html#operators)'
  id: totrans-1143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Further reading](elevated-world-7.html#further-reading)'
  id: totrans-1144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 6: Designing your own elevated world'
  id: totrans-1146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The scenario we''ll be working with in this post is just this:'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: '*A customer comes to your site and wants to view information about the products
    they have purchased.*'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll assume that you have a API for a key/value store (such
    as Redis or a NoSql database), and all the information you need is stored there.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: 'So the code we need will look something like this:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: How hard can that be?
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: Well, it turns out to be surprisingly tricky! Luckily, we can find a way to
    make it easier using the concepts in this series.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: Defining the domain and a dummy ApiClient
  id: totrans-1155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First let''s define the domain types:'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: There will be a `CustomerId` and `ProductId` of course.
  id: totrans-1157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the product information, we'll just define a simple `ProductInfo` with a
    `ProductName` field.
  id: totrans-1158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the types:'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: For testing our api, let's create an `ApiClient` class with some `Get` and `Set`
    methods, backed by a static mutable dictionary. This is based on similar APIs
    such as the Redis client.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: 'Notes:'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: The `Get` and `Set` both work with objects, so I've added a casting mechanism.
  id: totrans-1163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case of errors such as a failed cast, or a missing key, I'm using the `Result`
    type that we've been using throughout this series. Therefore, both `Get` and `Set`
    return `Result`s rather than plain objects.
  id: totrans-1164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make it more realistic, I've also added dummy methods for `Open`, `Close`
    and `Dispose`.
  id: totrans-1165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All methods trace a log to the console.
  id: totrans-1166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Let''s do some tests:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'And the results are:'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-1171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '* * *'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: A first implementation attempt
  id: totrans-1173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our first attempt at implementing the scenario, let''s start with the pseudo-code
    from above:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: So far so good, but there is a bit of a problem already.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: The `getPurchaseInfo` function takes a `CustId` as input, but it can't just
    output a list of `ProductInfo`s, because there might be a failure. That means
    that the return type needs to be `Result<ProductInfo list>`.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: Ok, how do we create our `productInfosResult`?
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: Well that should be easy. If the `productIdsResult` is Success, then loop through
    each id and get the info for each id. If the `productIdsResult` is Failure, then
    just return that failure.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-1180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Hmmm. It's looking a bit ugly. And I'm having to use a mutable data structure
    (`productInfos`) to accumulate each product info and then wrap it in `Success`.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: And there's a worse problem The `productInfo` that I'm getting from `api.Get<ProductInfo>`
    is not a `ProductInfo` at all, but a `Result<ProductInfo>`, so `productInfos`
    is not the right type at all!
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: Let's add code to test each `ProductInfo` result. If it's a success, then add
    it to the list of product infos, and if it's a failure, then return the failure.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-1184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Um, no. That won't work at all. The code above will not compile. We can't do
    an "early return" in the loop when a failure happens.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: So what do we have so far? Some really ugly code that won't even compile.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: There has to be a better way.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: A second implementation attempt
  id: totrans-1189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It would be great if we could hide all this unwrapping and testing of `Result`s.
    And there is -- computation expressions to the rescue.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: 'If we create a computation expression for `Result` we can write the code like
    this:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: In `let productInfosResult = Result.result { .. }` code we create a `result`
    computation expression that simplifies all the unwrapping (with `let!`) and wrapping
    (with `return`).
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: And so this implementation has no explicit `xxxResult` values anywhere. However,
    it still has to use a mutable collection class to do the accumulation, because
    the `for productId in productIds do` is not actually a real `for` loop, and we
    can't replace it with `List.map`, say.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: The `result` computation expression.
  id: totrans-1195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Which brings us onto the implementation of the `result` computation expression.
    In the previous posts, `ResultBuilder` only had two methods, `Return` and `Bind`,
    but in order to get the `for..in..do` functionality, we have to implement a lot
    of other methods too, and it ends up being a bit more complicated.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: I have a series about the [internals of computation expressions](computation-expressions.html),
    so I don't want to explain all that code here. Instead, for the rest of the post
    we'll work on refactoring `getPurchaseInfo`, and by the end of it we'll see that
    we don't need the `result` computation expression at all.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the function
  id: totrans-1200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The problem with the `getPurchaseInfo` function as it stands is that it mixes
    concerns: it both creates the `ApiClient` and does some work with it.'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: 'There a number of problems with this approach:'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: If we want to do different work with the API, we have to repeat the open/close
    part of this code. And it's possible that one of the implementations might open
    the API but forget to close it.
  id: totrans-1203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not testable with a mock API client.
  id: totrans-1204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can solve both of these problems by separating the creation of an `ApiClient`
    from its use by parameterizing the action, like this.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The action function that is passed in would look like this, with a parameter
    for the `ApiClient` as well as for the `CustId`:'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-1208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Note that `getPurchaseInfo` has *two* parameters, but `executeApiAction` expects
    a function with only one.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: 'No problem! Just use partial application to bake in the first parameter:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: That's why the `ApiClient` is the *second* parameter in the parameter list --
    so that we can do partial application.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: More refactoring
  id: totrans-1213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We might need to get the product ids for some other purpose, and also the productInfo,
    so let''s refactor those out into separate functions too:'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-1215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Now, we have these nice core functions `getPurchaseIds` and `getProductInfo`,
    but I'm annoyed that I have to write messy code to glue them together in `getPurchaseInfo`.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, what I''d like to do is pipe the output of `getPurchaseIds` into `getProductInfo`
    like this:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Or as a diagram:'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_pipe.png)'
  id: totrans-1220
  prefs: []
  type: TYPE_IMG
- en: 'But I can''t, and there are two reasons why:'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: First, `getProductInfo` has *two* parameters. Not just a `ProductId` but also
    the `ApiClient`.
  id: totrans-1222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, even if `ApiClient` wasn't there, the input of `getProductInfo` is a
    simple `ProductId` but the output of `getPurchaseIds` is a `Result`.
  id: totrans-1223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wouldn't it be great if we could solve both of these problems!
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: Introducing our own elevated world
  id: totrans-1226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's address the first problem. How can we compose functions when the extra
    `ApiClient` parameter keeps getting in the way?
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a typical API calling function looks like:'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_action1.png)'
  id: totrans-1229
  prefs: []
  type: TYPE_IMG
- en: 'If we look at the type signature we see this, a function with two parameters:'
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_action2.png)'
  id: totrans-1231
  prefs: []
  type: TYPE_IMG
- en: But *another* way to interpret this function is as a function with *one* parameter
    that returns another function. The returned function has an `ApiClient` parameter
    and returns the final ouput.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_action3.png)'
  id: totrans-1233
  prefs: []
  type: TYPE_IMG
- en: 'You might think of it like this: I have an input right now, but I won''t have
    an actual `ApiClient` until later, so let me use the input to create a api-consuming
    function that can I glue together in various ways right now, without needing a
    `ApiClient` at all.'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: Let's give this api-consuming function a name. Let's call it `ApiAction`.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_action4.png)'
  id: totrans-1236
  prefs: []
  type: TYPE_IMG
- en: In fact, let's do more than that -- let's make it a type!
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-1238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Unfortunately, as it stands, this is just a type alias for a function, not a
    separate type. We need to wrap it in a [single case union](designing-with-types-single-case-dus.html)
    to make it a distinct type.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-1240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Rewriting to use ApiAction
  id: totrans-1241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have a real type to use, we can rewrite our core domain functions
    to use it.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: 'First `getPurchaseIds`:'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-1244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The signature is now `CustId -> ApiAction<Result<ProductId list>>`, which you
    can interpret as meaning: "give me a CustId and I will give a you a ApiAction
    that, when given an api, will make a list of ProductIds".'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, `getProductInfo` can be rewritten to return an `ApiAction`:'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-1247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Notice those signatures:'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: '`CustId -> ApiAction<Result<ProductId list>>`'
  id: totrans-1249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductId -> ApiAction<Result<ProductInfo>>`'
  id: totrans-1250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is starting to look awfully familiar. Didn't we see something just like
    this in the previous post, with `Async<Result<_>>`?
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: ApiAction as an elevated world
  id: totrans-1252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we draw diagrams of the various types involved in these two functions, we
    can clearly see that `ApiAction` is an elevated world, just like `List` and `Result`.
    And that means that we should be able to use the *same* techniques as we have
    used before: `map`, `bind`, `traverse`, etc.'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s `getPurchaseIds` as a stack diagram. The input is a `CustId` and the
    output is an `ApiAction<Result<List<ProductId>>>`:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_getpurchaseids.png)'
  id: totrans-1255
  prefs: []
  type: TYPE_IMG
- en: 'and with `getProductInfo` the input is a `ProductId` and the output is an `ApiAction<Result<ProductInfo>>`:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_getproductinfo.png)'
  id: totrans-1257
  prefs: []
  type: TYPE_IMG
- en: 'The combined function that we want, `getPurchaseInfo`, should look like this:'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_getpurchaseinfo.png)'
  id: totrans-1259
  prefs: []
  type: TYPE_IMG
- en: 'And now the problem in composing the two functions is very clear: the output
    of `getPurchaseIds` can not be used as the input for `getProductInfo`:'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_noncompose.png)'
  id: totrans-1261
  prefs: []
  type: TYPE_IMG
- en: But I think that you can see that we have some hope! There should be some way
    of manipulating these layers so that they *do* match up, and then we can compose
    them easily.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: So that's what we will work on next.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: Introducting ApiActionResult
  id: totrans-1264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last post we merged `Async` and `Result` into the compound type `AsyncResult`.
    We can do the same here, and create the type `ApiActionResult`.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: 'When we make this change, our two functions become slightly simpler:'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_apiactionresult_functions.png)'
  id: totrans-1267
  prefs: []
  type: TYPE_IMG
- en: Enough diagrams -- let's write some code now.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define `map`, `apply`, `return` and `bind` for `ApiAction`:'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-1270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Note that all the functions use a helper function called `run` which unwraps
    an `ApiAction` to get the function inside, and applies this to the `api` that
    is also passed in. The result is the value wrapped in the `ApiAction`.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we had an `ApiAction<int>` then `run api myAction` would result
    in an `int`.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: And at the bottom, there is a `execute` function that creates an `ApiClient`,
    opens the connection, runs the action, and then closes the connection.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: 'And with the core functions for `ApiAction` defined, we can go ahead and define
    the functions for the compound type `ApiActionResult`, just as we did for `AsyncResult`
    in the [previous post](elevated-world-5.html#asyncresult):'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-1275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Working out the transforms
  id: totrans-1276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have all the tools in place, we must decide on what transforms to
    use to change the shape of `getProductInfo` so that the input matches up.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: Should we choose `map`, or `bind`, or `traverse`?
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: Let's play around with the stacks visually and see what happens for each kind
    of transform.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get started, let''s be explicit about what we are trying to achieve:'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: We have two functions `getPurchaseIds` and `getProductInfo` that we want to
    combine into a single function `getPurchaseInfo`.
  id: totrans-1281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to manipulate the *left* side (the input) of `getProductInfo` so that
    it matches the output of `getPurchaseIds`.
  id: totrans-1282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to manipulate the *right* side (the output) of `getProductInfo` so that
    it matches the output of our ideal `getPurchaseInfo`.
  id: totrans-1283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](vgfp_api_wanted.png)'
  id: totrans-1284
  prefs: []
  type: TYPE_IMG
- en: Map
  id: totrans-1285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a reminder, `map` adds a new stack on both sides. So if we start with a
    generic world-crossing function like this:'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_generic.png)'
  id: totrans-1287
  prefs: []
  type: TYPE_IMG
- en: Then, after `List.map` say, we will have a new `List` stack on each site.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_map_generic.png)'
  id: totrans-1289
  prefs: []
  type: TYPE_IMG
- en: 'Here''s our `getProductInfo` before transformation:'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_getproductinfo2.png)'
  id: totrans-1291
  prefs: []
  type: TYPE_IMG
- en: And here is what it would look like after using `List.map`
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_map_getproductinfo.png)'
  id: totrans-1293
  prefs: []
  type: TYPE_IMG
- en: This might seem promising -- we have a `List` of `ProductId` as input now, and
    if we can stack a `ApiActionResult` on top we would match the output of `getPurchaseId`.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: But the output is all wrong. We want the `ApiActionResult` to stay on the top.
    That is, we don't want a `List` of `ApiActionResult` but a `ApiActionResult` of
    `List`.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: Bind
  id: totrans-1296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ok, what about `bind`?
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, `bind` turns a "diagonal" function into a horizontal function
    by adding a new stack on the *left* sides. So for example, whatever the top elevated
    world is on the right, that will be added to the left.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_generic.png)'
  id: totrans-1299
  prefs: []
  type: TYPE_IMG
- en: '![](vgfp_api_bind_generic.png)'
  id: totrans-1300
  prefs: []
  type: TYPE_IMG
- en: And here is what our `getProductInfo` would look like after using `ApiActionResult.bind`
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_bind_getproductinfo.png)'
  id: totrans-1302
  prefs: []
  type: TYPE_IMG
- en: This is no good to us. We need to have a `List` of `ProductId` as input.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: Traverse
  id: totrans-1304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, let's try `traverse`.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: '`traverse` turns a diagonal function of values into diagonal function with
    lists wrapping the values. That is, `List` is added as the top stack on the left
    hand side, and the second-from-top stack on the right hand side.'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_generic.png)'
  id: totrans-1307
  prefs: []
  type: TYPE_IMG
- en: '![](vgfp_api_traverse_generic.png)'
  id: totrans-1308
  prefs: []
  type: TYPE_IMG
- en: if we try that out on `getProductInfo` we get something very promising.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_traverse_getproductinfo.png)'
  id: totrans-1310
  prefs: []
  type: TYPE_IMG
- en: The input is a list as needed. And the output is perfect. We wanted a `ApiAction<Result<List<ProductInfo>>>`
    and we now have it.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
- en: So all we need to do now is add an `ApiActionResult` to the left side.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: Well, we just saw this! It's `bind`. So if we do that as well, we are finished.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_complete_getproductinfo.png)'
  id: totrans-1314
  prefs: []
  type: TYPE_IMG
- en: 'And here it is expressed as code:'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-1316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Or to make it a bit less ugly:'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-1318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Let''s compare that with the earlier version of `getPurchaseInfo`:'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-1320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Let''s compare the two versions in a table:'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: '| Earlier verson | Latest function |'
  id: totrans-1322
  prefs: []
  type: TYPE_TB
- en: '| Composite function is non-trivial and needs special code to glue the two
    smaller functions together | Composite function is just piping and composition
    |'
  id: totrans-1323
  prefs: []
  type: TYPE_TB
- en: '| Uses the "result" computation expression | No special syntax needed |'
  id: totrans-1324
  prefs: []
  type: TYPE_TB
- en: '| Has special code to loop through the results | Uses "traverse" |'
  id: totrans-1325
  prefs: []
  type: TYPE_TB
- en: '| Uses a intermediate (and mutable) List object to accumulate the list of product
    infos | No intermediate values needed. Just a data pipeline. |'
  id: totrans-1326
  prefs: []
  type: TYPE_TB
- en: Implementing traverse
  id: totrans-1327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code above uses `traverse`, but we haven't implemented it yet. As I noted
    earlier, it can be implemented mechanically, following a template.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: 'Here it is:'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-1330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Testing the implementation
  id: totrans-1331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's test it!
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need a helper function to show results:'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-1334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Next, we need to load the API with some test data:'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-1336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Customer C1 has purchased two products: P1 and P2.'
  id: totrans-1337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Customer C2 has purchased two products: PX and P2.'
  id: totrans-1338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Products P1 and P2 have some info.
  id: totrans-1339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product PX does *not* have any info.
  id: totrans-1340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see how this works out for different customer ids.
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with Customer C1\. For this customer we expect both product infos
    to be returned:'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-1343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'And here are the results:'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-1345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: What happens if we use a missing customer, such as CX?
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-1347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: As expected, we get a nice "key not found" failure, and the rest of the operations
    are skipped as soon as the key is not found.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-1349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: What about if one of the purchased products has no info? For example, customer
    C2 purchased PX and P2, but there is no info for PX.
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-1351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The overall result is a failure. Any bad product causes the whole operation
    to fail.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-1353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: But note that the data for product P2 is fetched even though product PX failed.
    Why? Because we are using the applicative version of `traverse`, so every element
    of the list is fetched "in parallel".
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to only fetch P2 once we knew that PX existed, then we should be
    using monadic style instead. We already seen how to write a monadic version of
    `traverse`, so I leave that as an exercise for you!
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: Filtering out failures
  id: totrans-1357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the implementation above, the `getPurchaseInfo` function failed if *any*
    product failed to be found. Harsh!
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: A real application would probably be more forgiving. Probably what should happen
    is that the failed products are logged, but all the successes are accumulated
    and returned.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: How could we do this?
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: The answer is simple -- we just need to modify the `traverse` function to skip
    failures.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a new helper function for `ApiActionResult`. It will
    allow us to pass in two functions, one for the success case and one for the error
    case:'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-1363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: This helper function helps us match both cases inside a `ApiAction` without
    doing complicated unwrapping. We will need this for our `traverse` that skips
    failures.
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, note that `ApiActionResult.bind` can be defined in terms of `either`:'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-1366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Now we can define our "traverse with logging of failures" function:'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-1368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The only difference between this and the previous implementation is this bit:'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-1370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'This says that:'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
- en: If the new first element (`f head`) is a success, lift the inner value (`retn
    h`) and `cons` it with the tail to build a new list.
  id: totrans-1372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But if the new first element is a failure, then log the inner errors (`errs`)
    with the passed in logging function (`log`) and just reuse the current tail. In
    this way, failed elements are not added to the list, but neither do they cause
    the whole function to fail.
  id: totrans-1373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a new function `getPurchasesInfoWithLog` and try it with customer
    C2 and the missing product PX:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-1375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: The result is a Success now, but only one `ProductInfo`, for P2, is returned.
    The log shows that PX was skipped.
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-1377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '* * *'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: The Reader monad
  id: totrans-1379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look closely at the `ApiResult` module, you will see that `map`, `bind`,
    and all the other functions do not use any information about the `api` that is
    passed around. We could have made it any type and those functions would still
    have worked.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: So in the spirit of "parameterize all the things", why not make it a parameter?
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: 'That means that we could have defined `ApiAction` as follows:'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-1383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: But if it can be *anything*, why call it `ApiAction` any more? It could represent
    any set of things that depend on an object (such as an `api`) being passed in
    to them.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not the first people to discover this! This type is commonly called
    the `Reader` type and is defined like this:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-1386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: The extra type `'environment` plays the same role that `ApiClient` did in our
    definition of `ApiAction`. There is some environment that is passed around as
    an extra parameter to all your functions, just as a `api` instance was.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, we can actually define `ApiAction` in terms of `Reader` very easily:'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The set of functions for `Reader` are exactly the same as for `ApiAction`. I
    have just taken the code and replaced `ApiAction` with `Reader` and `api` with
    `environment`!
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-1391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: The type signatures are a bit harder to read now though!
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: The `Reader` type, plus `bind` and `return`, plus the fact that `bind` and `return`
    implement the monad laws, means that `Reader` is typically called "the Reader
    monad" .
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: I'm not going to delve into the Reader monad here, but I hope that you can see
    how it is actually a useful thing and not some bizarre ivory tower concept.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: The Reader monad vs. an explicit type
  id: totrans-1395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now if you like, you could replace all the `ApiAction` code above with `Reader`
    code, and it would work just the same. But *should* you?
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I think that while understanding the concept behind the Reader monad
    is important and useful, I prefer the actual implementation of `ApiAction` as
    I defined it originally, an explicit type rather than an alias for `Reader<ApiClient,'a>`.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: Why? Well, F# doesn't have typeclasses, F# doesn't have partial application
    of type constructors, F# doesn't have "newtype". Basically, F# isn't Haskell!
    I don't think that idioms that work well in Haskell should be carried over to
    F# directly when the language does not offer support for it.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: If you understand the concepts, you can implement all the necessary transformations
    in a few lines of code. Yes, it's a little extra work, but the upside is less
    abstraction and fewer dependencies.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
- en: I would make an exception, perhaps, if your team were all Haskell experts, and
    the Reader monad was familiar to everyone. But for teams of different abilities,
    I would err on being too concrete rather than too abstract.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post, we worked through another practical example, created our own elevated
    world which made things *much* easier, and in the process, accidentally re-invented
    the reader monad.
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: If you liked this, you can see a similar practical example, this time for the
    State monad, in my series on ["Dr Frankenfunctor and the Monadster"](monadster.html).
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: The [next and final post](elevated-world-7.html) has a quick summary of the
    series, and some further reading.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: Map and Bind and Apply, a summary
  id: totrans-1405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Map and Bind and Apply, a summary
  id: totrans-1406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Series summary
  id: totrans-1407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, [this series](map-and-bind-and-apply-oh-my.html) turned out to be longer
    than I originally planned. Thanks for making it to the end!
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: I hope that this discussion has been helpful in understanding the various function
    transformations like `map` and `bind`, and given you some useful techniques for
    dealing with world-crossing functions -- maybe even demystified the m-word a bit!
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to start using these kinds of functions in your own code, I hope
    that you can see how easy they are to write, but you should also consider using
    one of the excellent F# utility libraries that contain these and much more:'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: '**ExtCore** ([source](https://github.com/jack-pappas/ExtCore), [NuGet](https://www.nuget.org/packages/ExtCore/)).
    ExtCore provides extensions to the F# core library (FSharp.Core) and aims to help
    you build industrial-strength F# applications. These extensions include additional
    functions for modules such as Array, List, Set, and Map; immutable IntSet, IntMap,
    LazyList, and Queue collections; a variety of computation expressions (workflows);
    and "workflow collections" -- collections modules which have been adapted to work
    seamlessly from within workflows.'
  id: totrans-1411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FSharpx.Extras** ([home page](https://fsprojects.github.io/FSharpx.Extras/)).
    FSharpx.Extras is part of the FSharpx series of libraries. It implements several
    standard monads (State, Reader, Writer, Either, Continuation, Distribution), validation
    with applicative functors, general functions like flip, and some asynchronous
    programming utilities, and functions to make C# - F# interop easier.'
  id: totrans-1412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, the monadic traverse `List.traverseResultM` that I implemented
    [in this post](elevated-world-4.html#traverse) is already available in ExtCore
    [here](https://github.com/jack-pappas/ExtCore/blob/4fc2302e74a9b5217d980e5ce2680f0b3db26c3d/ExtCore/ControlCollections.Choice.fs#L398).
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: And if you liked this series, I have posts explaining the State monad in my
    series on ["Dr Frankenfunctor and the Monadster"](monadster.html) and the Either
    monad in my talk ["Railway Oriented Programming"](http://fsharpforfunandprofit.com/rop/).
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: As I said at the very beginning, writing this up has been a learning process
    for me too. I am not an expert, so if I have made any errors please do let me
    know.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: Thanks!
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  id: totrans-1417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a list of shortcuts to the various functions mentioned in this series:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Lifting to the elevated world**'
  id: totrans-1419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `map` function](elevated-world.html#map)'
  id: totrans-1420
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `return` function](elevated-world.html#return)'
  id: totrans-1421
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `apply` function](elevated-world.html#apply)'
  id: totrans-1422
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `liftN` family of functions](elevated-world.html#lift)'
  id: totrans-1423
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `zip` function and ZipList world](elevated-world.html#zip)'
  id: totrans-1424
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: How to compose world-crossing functions**'
  id: totrans-1425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `bind` function](elevated-world-2.html#bind)'
  id: totrans-1426
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List is not a monad. Option is not a monad.](elevated-world-2.html#not-a-monad)'
  id: totrans-1427
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Using the core functions in practice**'
  id: totrans-1428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Independent and dependent data](elevated-world-3.html#dependent)'
  id: totrans-1429
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Validation using applicative style and monadic style](elevated-world-3.html#validation)'
  id: totrans-1430
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lifting to a consistent world](elevated-world-3.html#consistent)'
  id: totrans-1431
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kleisli world](elevated-world-3.html#kleisli)'
  id: totrans-1432
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Mixing lists and elevated values**'
  id: totrans-1433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mixing lists and elevated values](elevated-world-4.html#mixing)'
  id: totrans-1434
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `traverse`/`MapM` function](elevated-world-4.html#traverse)'
  id: totrans-1435
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `sequence` function](elevated-world-4.html#sequence)'
  id: totrans-1436
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '["Sequence" as a recipe for ad-hoc implementations](elevated-world-4.html#adhoc)'
  id: totrans-1437
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Readability vs. performance](elevated-world-4.html#readability)'
  id: totrans-1438
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dude, where''s my `filter`?](elevated-world-4.html#filter)'
  id: totrans-1439
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: A real-world example that uses all the techniques**'
  id: totrans-1440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Downloading and processing a list of websites](elevated-world-5.html#asynclist)'
  id: totrans-1441
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Treating two worlds as one](elevated-world-5.html#asyncresult)'
  id: totrans-1442
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Designing your own elevated world**'
  id: totrans-1443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Designing your own elevated world](elevated-world-6.html#part6)'
  id: totrans-1444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering out failures](elevated-world-6.html#filtering)'
  id: totrans-1445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Reader monad](elevated-world-6.html#readermonad)'
  id: totrans-1446
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 7: Summary**'
  id: totrans-1447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List of operators mentioned](elevated-world-7.html#operators)'
  id: totrans-1448
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Further reading](elevated-world-7.html#further-reading)'
  id: totrans-1449
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix: List of operators mentioned'
  id: totrans-1451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike OO languages, functional programming languages are known for their [strange
    operators](http://en.cppreference.com/w/cpp/language/operator_precedence), so
    I thought it would be helpful to document the ones that have been used in this
    series, with links back to the relevant discussion.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Equivalent function | Discussion |'
  id: totrans-1453
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-1454
  prefs: []
  type: TYPE_TB
- en: '| `>>` | Left-to-right composition | Not part of this series, but [discussed
    here](function-composition.html) |'
  id: totrans-1455
  prefs: []
  type: TYPE_TB
- en: '| `<<` | Right-to-left composition | As above |'
  id: totrans-1456
  prefs: []
  type: TYPE_TB
- en: '| `&#124;>` | Left-to-right piping | As above |'
  id: totrans-1457
  prefs: []
  type: TYPE_TB
- en: '| `<&#124;` | Right-to-left piping | As above |'
  id: totrans-1458
  prefs: []
  type: TYPE_TB
- en: '| `<!>` | `map` | [Discussed here](elevated-world.html#map) |'
  id: totrans-1459
  prefs: []
  type: TYPE_TB
- en: '| `<$>` | `map` | Haskell operator for map, but not a valid operator in F#,
    so I''m using `<!>` in this series. |'
  id: totrans-1460
  prefs: []
  type: TYPE_TB
- en: '| `<*>` | `apply` | [Discussed here](elevated-world.html#apply) |'
  id: totrans-1461
  prefs: []
  type: TYPE_TB
- en: '| `<*` | - | One sided combiner. [Discussed here](elevated-world.html#lift)
    |'
  id: totrans-1462
  prefs: []
  type: TYPE_TB
- en: '| `*>` | - | One sided combiner. [Discussed here](elevated-world.html#lift)
    |'
  id: totrans-1463
  prefs: []
  type: TYPE_TB
- en: '| `>>=` | Left-to-right `bind` | [Discussed here](elevated-world-2.html#bind)
    |'
  id: totrans-1464
  prefs: []
  type: TYPE_TB
- en: '| `=<<` | Right-to-left `bind` | As above |'
  id: totrans-1465
  prefs: []
  type: TYPE_TB
- en: '| `>=>` | Left-to-right Kleisli composition | [Discussed here](elevated-world-3.html#kleisli)
    |'
  id: totrans-1466
  prefs: []
  type: TYPE_TB
- en: '| `<=<` | Right-to-left Kleisli composition | As above |'
  id: totrans-1467
  prefs: []
  type: TYPE_TB
- en: '* * *'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix: Further reading'
  id: totrans-1469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternative tutorials:'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: '[You Could Have Invented Monads! (And Maybe You Already Have)](http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html).'
  id: totrans-1471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Functors, Applicatives and Monads in pictures](http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html).'
  id: totrans-1472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kleisli composition ? la Up-Goer Five](http://mergeconflict.com/kleisli-composition-a-la-up-goer-five/).
    I think this one is funny.'
  id: totrans-1473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eric Lippert''s series on monads in C#](http://ericlippert.com/category/monads/).'
  id: totrans-1474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the academically minded:'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: '[Monads for Functional Programming](http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf)
    (PDF), by Philip Wadler. One of the first monad papers.'
  id: totrans-1476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Applicative Programming with Effects](http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf)
    (PDF), by Conor McBride and Ross Paterson.'
  id: totrans-1477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Essence of the Iterator Pattern](http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf)
    (PDF), by Jeremy Gibbons and Bruno Oliveira.'
  id: totrans-1478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F# examples:'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: '[F# ExtCore](https://github.com/jack-pappas/ExtCore) and [FSharpx.Extras](https://github.com/fsprojects/FSharpx.Extras/blob/master/src/FSharpx.Extras/ComputationExpressions/Monad.fs)
    have lots of useful code.'
  id: totrans-1480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FSharpx.Async](https://github.com/fsprojects/FSharpx.Async/blob/master/src/FSharpx.Async/Async.fs)
    has `map`, `apply`, `liftN` (called "Parallel"), `bind`, and other useful extensions
    for `Async`.'
  id: totrans-1481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Applicatives are very well suited for parsing, as explained in these posts:'
  id: totrans-1482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parsing with applicative functors in F#](http://bugsquash.blogspot.co.uk/2011/01/parsing-with-applicative-functors-in-f.html).'
  id: totrans-1483
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dive into parser combinators: parsing search queries with F# and FParsec in
    Kiln](http://blog.fogcreek.com/fparsec/).'
  id: totrans-1484
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
