- en: The "Map and Bind and Apply, Oh my!" Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this series of posts, I'll attempt to describe some of the core functions
    for dealing with generic data types (such as `Option` and `List`). This is a follow-up
    post to [my talk on functional patterns](http://fsharpforfunandprofit.com/fppatterns/).
  prefs: []
  type: TYPE_NORMAL
- en: Yes, I know that [I promised not to do this kind of thing](why-i-wont-be-writing-a-monad-tutorial.html),
    but for this post I thought I'd take a different approach from most people. Rather
    than talking about abstractions such as type classes, I thought it might be useful
    to focus on the core functions themselves and how they are used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, a sort of "man page" for `map`, `return`, `apply`, and `bind`.
  prefs: []
  type: TYPE_NORMAL
- en: So, there is a section for each function, describing their name (and common
    aliases), common operators, their type signature, and then a detailed description
    of why they are needed and how they are used, along with some visuals (which I
    always find helpful).
  prefs: []
  type: TYPE_NORMAL
- en: '[Understanding map and apply](elevated-world.html). A toolset for working with
    elevated worlds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Understanding bind](elevated-world-2.html). Or, how to compose world-crossing
    functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using the core functions in practice](elevated-world-3.html). Working with
    independent and dependent data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Understanding traverse and sequence](elevated-world-4.html). Mixing lists
    and elevated values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using map, apply, bind and sequence in practice](elevated-world-5.html). A
    real-world example that uses all the techniques.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reinventing the Reader monad](elevated-world-6.html). Or, designing your own
    elevated world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Map and Bind and Apply, a summary](elevated-world-7.html). .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding map and apply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding map and apply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this series of posts, I'll attempt to describe some of the core functions
    for dealing with generic data types (such as `Option` and `List`). This is a follow-up
    post to [my talk on functional patterns](http://fsharpforfunandprofit.com/fppatterns/).
  prefs: []
  type: TYPE_NORMAL
- en: Yes, I know that [I promised not to do this kind of thing](why-i-wont-be-writing-a-monad-tutorial.html),
    but for this post I thought I'd take a different approach from most people. Rather
    than talking about abstractions such as type classes, I thought it might be useful
    to focus on the core functions themselves and how they are used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, a sort of ["man page"](https://en.wikipedia.org/wiki/Man_page)
    for `map`, `return`, `apply`, and `bind`.
  prefs: []
  type: TYPE_NORMAL
- en: So, there is a section for each function, describing their name (and common
    aliases), common operators, their type signature, and then a detailed description
    of why they are needed and how they are used, along with some visuals (which I
    always find helpful).
  prefs: []
  type: TYPE_NORMAL
- en: Haskellers and category-theorists may want to look away now! There will be no
    mathematics and quite a lot of hand-waving. I am going to avoid jargon and Haskell-specific
    concepts such as type classes and focus on the big picture as much as possible.
    The concepts here should be applicable to any kind of functional programming in
    any language.
  prefs: []
  type: TYPE_NORMAL
- en: I know that some people might dislike this approach. That's fine. There is [no
    shortage](https://wiki.haskell.org/Monad_tutorials_timeline) of more academic
    explanations on the web. Start with [this](http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf)
    and [this](http://www.soi.city.ac.uk/~ross/papers/Applicative.html).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as with most of the posts on this site, I am writing this up for my
    own benefit as well, as part of my own learning process. I don't claim to be an
    expert at all, so if I have made any errors please let me know.
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start with, let me provide the background and some terminology.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that there are two worlds that we could program in: a "normal" everyday
    world and a world that I will call the "elevated world" (for reasons that I will
    explain shortly).'
  prefs: []
  type: TYPE_NORMAL
- en: The elevated world is very similar to the normal world. In fact, every thing
    in the normal world has a corresponding thing in the elevated world.
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, we have the set of values called `Int` in the normal world,
    and in the elevated world there is a parallel set of values called, say, `E<Int>`.
    Similarly, we have the set of values called `String` in the normal world, and
    in the elevated world there is a parallel set of values called `E<String>`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_e_values.png)'
  prefs: []
  type: TYPE_IMG
- en: Also, just as there are functions between `Int`s and `String`s in the normal
    world, so there are functions between `E<Int>`s and `E<String>`s in the elevated
    world.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_e_functions.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that I am deliberately using the term "world" rather than "type" to emphasis
    that the *relationships* between values in the world are just as important as
    the underlying data type.
  prefs: []
  type: TYPE_NORMAL
- en: What exactly is an elevated world?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I can't define what an elevated world is exactly, because there are too many
    different kinds of elevated worlds, and they don't have anything in common.
  prefs: []
  type: TYPE_NORMAL
- en: Some of them represent data structures (`Option<T>`), some of them represent
    workflows (`State<T>`), some of them represent signals (`Observable<T>`), or asychronous
    values (`Async<T>`), or other concepts.
  prefs: []
  type: TYPE_NORMAL
- en: But even though the various elevated worlds have nothing in common specifically,
    there *are* commonalities in the way they can be worked with. We find that certain
    issues occur over and over again in different elevated worlds, and we can use
    standard tools and patterns to deal with these issues.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this series will attempt to document these tools and patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This series is developed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, I'll discuss the tools we have for lifting normal things into the elevated
    world. This includes functions such as `map`, `return`, `apply` and `bind`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, I'll discuss how you can combine elevated values in different ways, based
    on whether the values are independent or dependent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we'll look at some ways of mixing lists with other elevated values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we'll look at two real-world examples that put all these techniques
    to use, and we'll find ourselves accidentally inventing the Reader monad.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a list of shortcuts to the various functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Lifting to the elevated world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `map` function](elevated-world.html#map)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `return` function](elevated-world.html#return)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `apply` function](elevated-world.html#apply)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `liftN` family of functions](elevated-world.html#lift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `zip` function and ZipList world](elevated-world.html#zip)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: How to compose world-crossing functions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `bind` function](elevated-world-2.html#bind)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List is not a monad. Option is not a monad.](elevated-world-2.html#not-a-monad)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Using the core functions in practice**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Independent and dependent data](elevated-world-3.html#dependent)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Validation using applicative style and monadic style](elevated-world-3.html#validation)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lifting to a consistent world](elevated-world-3.html#consistent)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kleisli world](elevated-world-3.html#kleisli)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Mixing lists and elevated values**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mixing lists and elevated values](elevated-world-4.html#mixing)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `traverse`/`MapM` function](elevated-world-4.html#traverse)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `sequence` function](elevated-world-4.html#sequence)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '["Sequence" as a recipe for ad-hoc implementations](elevated-world-4.html#adhoc)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Readability vs. performance](elevated-world-4.html#readability)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dude, where''s my `filter`?](elevated-world-4.html#filter)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: A real-world example that uses all the techniques**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Downloading and processing a list of websites](elevated-world-5.html#asynclist)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Treating two worlds as one](elevated-world-5.html#asyncresult)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Designing your own elevated world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Designing your own elevated world](elevated-world-6.html#part6)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering out failures](elevated-world-6.html#filtering)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Reader monad](elevated-world-6.html#readermonad)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 7: Summary**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List of operators mentioned](elevated-world-7.html#operators)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Further reading](elevated-world-7.html#further-reading)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 1: Lifting to the elevated world'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first challenge is: how do we get from the normal world to the elevated
    world?'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will assume that for any particular elevated world:'
  prefs: []
  type: TYPE_NORMAL
- en: Every type in the normal world has a corresponding type in the elevated world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every value in the normal world has a corresponding value in the elevated world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every function in the normal world has a corresponding function in the elevated
    world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of moving something from the normal world to the elevated world
    is called "lifting" (which is why I used the term "elevated world" in the first
    place).
  prefs: []
  type: TYPE_NORMAL
- en: We'll call these corresponding things "lifted types" and "lifted values" and
    "lifted functions".
  prefs: []
  type: TYPE_NORMAL
- en: Now because each elevated world is different, there is no common implementation
    for lifting, but we can give names to the various "lifting" patterns, such as
    `map` and `return`.
  prefs: []
  type: TYPE_NORMAL
- en: '*NOTE: There is no standard name for these lifted types. I have seen them called
    "wrapper types" or "augmented types" or "monadic types". I''m not really happy
    with any of these names, so I invented [a new one](https://xkcd.com/927/)! Also,
    I''m trying avoid any assumptions, so I don''t want to imply that the lifted types
    are somehow better or contain extra information. I hope that by using the word
    "elevated" in this post, I can focus on the* lifting process *rather than on the
    types themselves.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*As for using the word "monadic", that would be inaccurate, as there is no
    requirement that these types are part of a monad.*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The `map` function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Common Names**: `map`, `fmap`, `lift`, `Select`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Operators**: `<$>` `<!>`'
  prefs: []
  type: TYPE_NORMAL
- en: '**What it does**: Lifts a function into the elevated world'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signature**: `(a->b) -> E<a> -> E<b>`. Alternatively with the parameters
    reversed: `E<a> -> (a->b) -> E<b>`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '"map" is the generic name for something that takes a function in the normal
    world and transforms it into a corresponding function in the elevated world.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_map.png)'
  prefs: []
  type: TYPE_IMG
- en: Each elevated world will have its own implementation of map.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative interpretation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative interpretation of `map` is that it is a *two* parameter function
    that takes an elevated value (`E<a>`) and a normal function (`a->b`), and returns
    a new elevated value (`E<b>`) generated by applying the function `a->b` to the
    internal elements of `E<a>`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_map2.png)'
  prefs: []
  type: TYPE_IMG
- en: In languages where functions are curried by default, such as F#, both these
    interpretation are the same. In other languages, you may need to curry/uncurry
    to switch between the two uses.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the *two* parameter version often has the signature `E<a> -> (a->b)
    -> E<b>`, with the elevated value first and the normal function second. From an
    abstract point of view, there's no difference between them -- the map concept
    is the same -- but obviously, the parameter order affects how you might use map
    functions in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are two examples of how map can be defined for options and lists in F#.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These functions are built-in of course, so we don't need to define them, I've
    done it just to show what they might look for some common types.
  prefs: []
  type: TYPE_NORMAL
- en: Usage examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some examples of how map can be used in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With these mapped versions in place you can write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In many cases, we don''t bother to create an intermediate function -- partial
    application is used instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The properties of a correct map implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I said earlier that the elevated world is in some ways a mirror of the normal
    world. Every function in the normal world has a corresponding function in the
    elevated world, and so on. We want `map` to return this corresponding elevated
    function in a sensible way.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `map` of `add` should not (wrongly) return the elevated version
    of `multiply`, and `map` of `lowercase` should not return the elevated version
    of `uppercase`! But how can we be *sure* that a particular implementation of map
    does indeed return the *correct* corresponding function?
  prefs: []
  type: TYPE_NORMAL
- en: In [my post on property based testing](http://fsharpforfunandprofit.com/pbt/)
    I showed how a correct implementation of a function can be defined and tested
    using general properties rather than specific examples.
  prefs: []
  type: TYPE_NORMAL
- en: This is true for `map` as well. The implementation will vary with the specific
    elevated world, but in all cases, there are certain properties that the implementation
    should satisfy to avoid strange behavior.
  prefs: []
  type: TYPE_NORMAL
- en: First, if you take the `id` function in the normal world, and you lift it into
    the elevated world with `map`, the new function must be the *same* as the `id`
    function in the elevated world.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_functor_law_id.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, if you take two functions `f` and `g` in the normal world, and you compose
    them (into `h`, say), and then lift the resulting function using `map`, the resulting
    function should be the *same* as if you lifted `f` and `g` into the elevated world
    *first*, and then composed them there afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_functor_law_compose.png)'
  prefs: []
  type: TYPE_IMG
- en: These two properties are the so-called ["Functor Laws"](https://en.wikibooks.org/wiki/Haskell/The_Functor_class#The_functor_laws),
    and a **Functor** (in the programming sense) is defined as a generic data type
    -- `E<T>` in our case -- plus a `map` function that obeys the functor laws.
  prefs: []
  type: TYPE_NORMAL
- en: '*NOTE: "Functor" is a confusing word. There is "functor" in the category theory
    sense, and there is "functor" in the programming sense (as defined above). There
    are also things called "functors" defined in libraries, such as [the `Functor`
    type class in Haskell](https://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Functor.html),
    and the [`Functor` trait in Scalaz](https://scalaz.github.io/scalaz/scalaz-2.9.0-1-6.0/doc.sxr/scalaz/Functor.scala.html),
    not to mention functors in SML and [OCaml](https://realworldocaml.org/v1/en/html/functors.html)
    (and [C++](http://www.cprogramming.com/tutorial/functors-function-objects-in-c++.html)),
    which are different yet again!*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Conseqently, I prefer to talk about "mappable" worlds. In practical programming,
    you will almost never run into a elevated world that does not support being mapped
    over somehow.*'
  prefs: []
  type: TYPE_NORMAL
- en: Variants of map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are some variants of map that are common:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Const map**. A const or "replace-by" map replaces all values with a constant
    rather than the output of a function. In some cases, a specialized function like
    this can allow for a more efficient implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maps that work with cross-world functions**. The map function `a->b` lives
    entirely in the normal world. But what if the function you want to map with does
    not return something in the normal world, but a value in another, different, enhanced
    world? We''ll see how to address this challenge in [a later post](elevated-world-4.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The `return` function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Common Names**: `return`, `pure`, `unit`, `yield`, `point`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Operators**: None'
  prefs: []
  type: TYPE_NORMAL
- en: '**What it does**: Lifts a single value into the elevated world'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signature**: `a -> E<a>`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '"return" (also known as "unit" or "pure") simply creates a elevated value from
    a normal value.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_return.png)'
  prefs: []
  type: TYPE_IMG
- en: This function goes by many names, but I'm going to be consistent and call it
    `return` as that is the common term for it in F#, and is the term used in computation
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '*NOTE: I''m ignoring the difference between `pure` and `return`, because type
    classes are not the focus of this post.*'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are two examples of `return` implementations in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we don't need to define special functions like this for options and
    lists. Again, I've just done it to show what `return` might look for some common
    types.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The `apply` function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Common Names**: `apply`, `ap`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Operators**: `<*>`'
  prefs: []
  type: TYPE_NORMAL
- en: '**What it does**: Unpacks a function wrapped inside a elevated value into a
    lifted function `E<a> -> E<b>`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signature**: `E<(a->b)> -> E<a> -> E<b>`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '"apply" unpacks a function wrapped inside a elevated value (`E<(a->b)>`) into
    a lifted function `E<a> -> E<b>`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_apply.png)'
  prefs: []
  type: TYPE_IMG
- en: This might seem unimportant, but is actually very valuable, as it allows you
    to lift a multi-parameter function in the normal world into a multi-parameter
    function in the elevated world, as we'll see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative interpretation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative interpretation of `apply` is that it is a *two* parameter function
    that takes a elevated value (`E<a>`) and a elevated function (`E<(a->b)>`), and
    returns a new elevated value (`E<b>`) generated by applying the function `a->b`
    to the internal elements of `E<a>`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have a one-parameter function (`E<(a->b)>`), you can apply
    it to a single elevated parameter to get the output as another elevated value.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_apply2.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have a two-parameter function (`E<(a->b->c)>`), you can use `apply` twice
    in succession with two elevated parameters to get the elevated output.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_apply3.png)'
  prefs: []
  type: TYPE_IMG
- en: You can continue to use this technique to work with as many parameters as you
    wish.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some examples of defining `apply` for two different types in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, rather than have names like `applyOption` and `applyList`, I have
    given the functions the same name but put them in a per-type module.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the `List.apply` implementation, each function in the first list
    is applied to each value in the second list, resulting in a "cross-product" style
    result. That is, the list of functions `[f; g]` applied to the list of values
    `[x; y]` becomes the four-element list `[f x; f y; g x; g y]`. We'll see shortly
    that this is not the only way to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Also, of course, I'm cheating by building this implementation on a `for..in..do`
    loop -- functionality that already exists!
  prefs: []
  type: TYPE_NORMAL
- en: I did this for clarity in showing how `apply` works. It's easy enough to create
    a "from scratch" recursive implementation, (though it is not so easy to create
    one that is properly tail-recursive!) but I want to focus on the concepts not
    on the implementation for now.
  prefs: []
  type: TYPE_NORMAL
- en: Infix version of apply
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the `apply` function as it stands can be awkward, so it is common to
    create an infix version, typically called `<*>`. With this in place you can write
    code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Apply vs. Map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The combination of `apply` and `return` is considered "more powerful" than `map`,
    because if you have `apply` and `return`, you can construct `map` from them, but
    not vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how it works: to construct a lifted function from a normal function,
    just use `return` on the normal function and then `apply`. This gives you the
    same result as if you had simply done `map` in the first place.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_apply_vs_map.png)'
  prefs: []
  type: TYPE_IMG
- en: This trick also means that our infix notation can be simplified a little. The
    initial `return` then `apply` can be replaced with `map`, and we so typically
    create an infix operator for `map` as well, such as `<!>` in F#.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This makes the code look more like using the function normally. That is, instead
    of the normal `add x y`, we can use the similar looking `add <!> x <*> y`, but
    now `x` and `y` can be elevated values rather than normal values. Some people
    have even called this style "overloaded whitespace"!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s one more for fun:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The properties of a correct apply/return implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with `map`, a correct implementation of the `apply`/`return` pair should
    have some properties that are true no matter what elevated world we are working
    with.
  prefs: []
  type: TYPE_NORMAL
- en: There are four so-called ["Applicative Laws"](https://en.wikibooks.org/wiki/Haskell/Applicative_functors#Applicative_functor_laws),
    and an **Applicative Functor** (in the programming sense) is defined as a generic
    data type constructor -- `E<T>` -- plus a pair of functions (`apply` and `return`)
    that obey the applicative laws.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the laws for `map`, these laws are quite sensible. I'll show two
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: The first law says that if you take the `id` function in the normal world, and
    you lift it into the elevated world with `return`, and then you do `apply`, the
    new function, which is of type `E<a> -> E<a>`, should be the same as the `id`
    function in the elevated world.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_apply_law_id.png)'
  prefs: []
  type: TYPE_IMG
- en: The second law says that if you take a function `f` and a value `x` in the normal
    world, and you apply `f` to `x` to get a result (`y`, say), and then lift the
    result using `return`, the resulting value should be the same as if you lifted
    `f` and `x` into the elevated world *first*, and then applied them there afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_apply_law_homomorphism.png)'
  prefs: []
  type: TYPE_IMG
- en: The other two laws are not so easily diagrammed, so I won't document them here,
    but together the laws ensure that any implementation is sensible.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The `liftN` family of functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Common Names**: `lift2`, `lift3`, `lift4` and similar'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Operators**: None'
  prefs: []
  type: TYPE_NORMAL
- en: '**What it does**: Combines two (or three, or four) elevated values using a
    specified function'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signature**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'lift2: `(a->b->c) -> E<a> -> E<b> -> E<c>`,'
  prefs: []
  type: TYPE_NORMAL
- en: 'lift3: `(a->b->c->d) -> E<a> -> E<b> -> E<c> -> E<d>`,'
  prefs: []
  type: TYPE_NORMAL
- en: etc.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `apply` and `return` functions can be used to define a series of helper
    functions `liftN` (`lift2`, `lift3`, `lift4`, etc) that take a normal function
    with N parameters (where N=2,3,4, etc) and transform it to a corresponding elevated
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `lift1` is just `map`, and so it is not usually defined as a separate
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what an implementation might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a visual representation of `lift2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_lift2.png)'
  prefs: []
  type: TYPE_IMG
- en: The `lift` series of functions can be used to make code a bit more readable
    because, by using one of the pre-made `lift` functions, we can avoid the `<*>`
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here''s an example of lifting a two-parameter function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s an example of lifting a three-parameter function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Interpreting "lift2" as a "combiner"
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is an alternative interpretation of `apply` as a "combiner" of elevated
    values, rather than as function application.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when using `lift2`, the first parameter is a parameter specifying
    how to combine the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example where the same values are combined in two different ways:
    first with addition, then with multiplication.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Going further, can we eliminate the need for this first function parameter and
    have a *generic* way of combining the values?
  prefs: []
  type: TYPE_NORMAL
- en: Why, yes we can! We can just use a tuple constructor to combine the values.
    When we do this we are combining the values without making any decision about
    how they will be used yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what it looks like in a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_apply_combine.png)'
  prefs: []
  type: TYPE_IMG
- en: 'and here''s how you might implement it for options and lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what happens when we use the combiners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have an elevated tuple, we can work with the pair in any way we
    want, we just need to use `map` to do the actual combining.
  prefs: []
  type: TYPE_NORMAL
- en: 'Want to add the values? Just use `+` in the `map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Want to multiply the values? Just use `*` in the `map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: And so on. Obviously, real-world uses would be somewhat more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Defining `apply` in terms of `lift2`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interestingly, the `lift2` function above can be actually used as an alternative
    basis for defining `apply`.
  prefs: []
  type: TYPE_NORMAL
- en: That is, we can define `apply` in terms of the `lift2` function by setting the
    combining function to be just function application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a demonstration of how this works for `Option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This alternative approach is worth knowing about because for some types it's
    easier to define `lift2` than `apply`.
  prefs: []
  type: TYPE_NORMAL
- en: Combining missing or bad data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that in all the combiners we've looked at, if one of the elevated values
    is "missing" or "bad" somehow, then the overall result is also bad.
  prefs: []
  type: TYPE_NORMAL
- en: For example, with `combineList`, if one of the parameters is an empty list,
    the result is also an empty list, and with `combineOpt`, if one of the parameters
    is `None`, the result is also `None`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It's possible to create an alternative kind of combiner that ignores missing
    or bad values, just as adding "0" to a number is ignored. For more information,
    see my post on ["Monoids without tears"](monoids-without-tears.html).
  prefs: []
  type: TYPE_NORMAL
- en: One sided combiners `<*` and `*>`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some cases you might have two elevated values, and want to discard the value
    from one side or the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example for lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can then combine a 2-element list and a 3-element list to get a 6-element
    list as expected, but the contents come from only one side or the other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can turn this into a feature! We can replicate a value N times by crossing
    it with `[1..n]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this is by no means an efficient way to replicate a value, but it
    does show that starting with just the two functions `apply` and `return`, you
    can build up some quite complex behavior.
  prefs: []
  type: TYPE_NORMAL
- en: On a more practical note though, why might this "throwing away data" be useful?
    Well in many cases, we might not want the values, but we *do* want the effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in a parser, you might see code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, `readQuoteChar` means "match and read a quote character from
    the input stream" and `readNonQuoteChars` means "read a series of non-quote characters
    from the input stream".
  prefs: []
  type: TYPE_NORMAL
- en: When we are parsing a quoted string we want ensure the input stream that contains
    the quote character is read, but we don't care about the quote characters themselves,
    just the inner content.
  prefs: []
  type: TYPE_NORMAL
- en: Hence the use of `*>` to ignore the leading quote and `<*` to ignore the trailing
    quote.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The `zip` function and ZipList world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Common Names**: `zip`, `zipWith`, `map2`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Operators**: `<*>` (in the context of ZipList world)'
  prefs: []
  type: TYPE_NORMAL
- en: '**What it does**: Combines two lists (or other enumerables) using a specified
    function'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signature**: `E<(a->b->c)> -> E<a> -> E<b> -> E<c>` where `E` is a list or
    other enumerable type, or `E<a> -> E<b> -> E<a,b>` for the tuple-combined version.'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some data types might have more than one valid implementation of `apply`. For
    example, there is another possible implementation of `apply` for lists, commonly
    called `ZipList` or some variant of that.
  prefs: []
  type: TYPE_NORMAL
- en: In this implementation, the corresponding elements in each list are processed
    at the same time, and then both lists are shifted to get the next element. That
    is, the list of functions `[f; g]` applied to the list of values `[x; y]` becomes
    the two-element list `[f x; g y]`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*WARNING: This implementation is just for demonstration. It''s not tail-recursive,
    so don''t use it for large lists!*'
  prefs: []
  type: TYPE_NORMAL
- en: If the lists are of different lengths, some implementations throw an exception
    (as the F# library functions `List.map2` and `List.zip` do), while others silently
    ignore the extra data (as the implementation above does).
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, let''s see it in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that the result is `[11; 22; 33]` -- only three elements. If we had used
    the standard `List.apply`, there would have been nine elements.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting "zip" as a "combiner"
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We saw above that `List.apply`, or rather `List.lift2`, could be intepreted
    as a combiner. Similarly, so can `zipList`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can't just have *one* `add` function in the first list -- we have
    to have one `add` for every element in the second and third lists!
  prefs: []
  type: TYPE_NORMAL
- en: That could get annoying, so often, a "tupled" version of `zip` is used, whereby
    you don't specify a combining function at all, and just get back a list of tuples
    instead, which you can then process later using `map`. This is the same approach
    as was used in the `combine` functions discussed above, but for `zipList`.
  prefs: []
  type: TYPE_NORMAL
- en: ZipList world
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In standard List world, there is an `apply` and a `return`. But with our different
    version of `apply` we can create a different version of List world called ZipList
    world.
  prefs: []
  type: TYPE_NORMAL
- en: ZipList world is quite different from the standard List world.
  prefs: []
  type: TYPE_NORMAL
- en: In ZipList world, the `apply` function is implemented as above. But more interestingly,
    ZipList world has a *completely different* implementation of `return` compared
    with standard List world. In the standard List world, `return` is just a list
    with a single element, but for ZipList world, it has to be an infinitely repeated
    value!
  prefs: []
  type: TYPE_NORMAL
- en: 'In a non-lazy language like F#, we can''t do this, but if we replace `List`
    with `Seq` (aka `IEnumerable`) then we *can* create an infinitely repeated value,
    as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates that an elevated world is *not* just a data type (like
    the List type) but consists of the datatype *and* the functions that work with
    it. In this particular case, "List world" and "ZipList world" share the same data
    type but have quite different environments.
  prefs: []
  type: TYPE_NORMAL
- en: What types support `map` and `apply` and `return`?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we have defined all these useful functions in an abstract way. But how
    easy is it to find real types that have implementations of them, including all
    the various laws?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is: very easy! In fact *almost all* types support these set of functions.
    You''d be hard-pressed to find a useful type that didn''t.'
  prefs: []
  type: TYPE_NORMAL
- en: That means that `map` and `apply` and `return` are available (or can be easily
    implemented) for standard types such as `Option`, `List`, `Seq`, `Async`, etc.,
    and also any types you are likely to define yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this post, I described three core functions for lifting simple "normal"
    values to elevated worlds: `map`, `return`, and `apply`, plus some derived functions
    like `liftN` and `zip`.'
  prefs: []
  type: TYPE_NORMAL
- en: In practice however, things are not that simple. We frequently have to work
    with functions that cross between the worlds. Their input is in the normal world
    but their output is in the elevated world.
  prefs: []
  type: TYPE_NORMAL
- en: In the [next post](elevated-world-2.html) we'll show how these world-crossing
    functions can be lifted to the elevated world as well.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding bind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding bind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This post is the second in a series. In the [previous post](elevated-world.html),
    I described some of the core functions for lifting a value from a normal world
    to an elevated world.
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we'll look at "world-crossing" functions, and how they can be
    tamed with the `bind` function.
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a list of shortcuts to the various functions mentioned in this series:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Lifting to the elevated world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `map` function](elevated-world.html#map)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `return` function](elevated-world.html#return)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `apply` function](elevated-world.html#apply)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `liftN` family of functions](elevated-world.html#lift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `zip` function and ZipList world](elevated-world.html#zip)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: How to compose world-crossing functions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `bind` function](elevated-world-2.html#bind)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List is not a monad. Option is not a monad.](elevated-world-2.html#not-a-monad)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Using the core functions in practice**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Independent and dependent data](elevated-world-3.html#dependent)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Validation using applicative style and monadic style](elevated-world-3.html#validation)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lifting to a consistent world](elevated-world-3.html#consistent)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kleisli world](elevated-world-3.html#kleisli)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Mixing lists and elevated values**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mixing lists and elevated values](elevated-world-4.html#mixing)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `traverse`/`MapM` function](elevated-world-4.html#traverse)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `sequence` function](elevated-world-4.html#sequence)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '["Sequence" as a recipe for ad-hoc implementations](elevated-world-4.html#adhoc)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Readability vs. performance](elevated-world-4.html#readability)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dude, where''s my `filter`?](elevated-world-4.html#filter)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: A real-world example that uses all the techniques**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Downloading and processing a list of websites](elevated-world-5.html#asynclist)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Treating two worlds as one](elevated-world-5.html#asyncresult)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Designing your own elevated world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Designing your own elevated world](elevated-world-6.html#part6)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering out failures](elevated-world-6.html#filtering)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Reader monad](elevated-world-6.html#readermonad)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 7: Summary**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List of operators mentioned](elevated-world-7.html#operators)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Further reading](elevated-world-7.html#further-reading)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: How to compose world-crossing functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The `bind` function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Common Names**: `bind`, `flatMap`, `andThen`, `collect`, `SelectMany`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Operators**: `>>=` (left to right), `=<<` (right to left )'
  prefs: []
  type: TYPE_NORMAL
- en: '**What it does**: Allows you to compose world-crossing ("monadic") functions'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signature**: `(a->E<b>) -> E<a> -> E<b>`. Alternatively with the parameters
    reversed: `E<a> -> (a->E<b>) -> E<b>`'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We frequently have to deal with functions that cross between the normal world
    and the elevated world.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example: a function that parses a `string` to an `int` might return an
    `Option<int>` rather than a normal `int`, a function that reads lines from a file
    might return `IEnumerable<string>`, a function that fetches a web page might return
    `Async<string>`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of "world-crossing" functions are recognizable by their signature
    `a -> E<b>`; their input is in the normal world but their output is in the elevated
    world. Unfortunately, this means that these kinds of functions cannot be linked
    together using standard composition.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_bind_noncomposition.png)'
  prefs: []
  type: TYPE_IMG
- en: What "bind" does is transform a world-crossing function (commonly known as a
    "monadic function") into a lifted function `E<a> -> E<b>`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_bind.png)'
  prefs: []
  type: TYPE_IMG
- en: The benefit of doing this is that the resulting lifted functions live purely
    in the elevated world, and so can be combined easily by composition.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a function of type `a -> E<b>` cannot be directly composed with
    a function of type `b -> E<c>`, but after `bind` is used, the second function
    becomes of type `E<b> -> E<c>`, which *can* be composed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_bind_composition.png)'
  prefs: []
  type: TYPE_IMG
- en: In this way, `bind` lets us chain together any number of monadic functions.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative interpretation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative interpretation of `bind` is that it is a *two* parameter function
    that takes a elevated value (`E<a>`) and a "monadic function" (`a -> E<b>`), and
    returns a new elevated value (`E<b>`) generated by "unwrapping" the value inside
    the input, and running the function `a -> E<b>` against it. Of course, the "unwrapping"
    metaphor does not work for every elevated world, but still it can often be useful
    to think of it this way.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_bind2.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementation examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some examples of defining `bind` for two different types in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Notes:'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in these two particular cases, the functions already exist in F#,
    called `Option.bind` and `List.collect`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `List.bind` I'm cheating again and using `for..in..do`, but I think that
    this particular implementation shows clearly how bind works with lists. There
    is a purer recursive implementation, but I won't show that here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As explained at the beginning of this section, `bind` can be used to compose
    cross-world functions. Let's see how this works in practice with a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s say we have a function that parses certain `string`s into `int`s.
    Here''s a very simple implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes it returns a int, sometimes not. So the signature is `string -> int
    option` -- a cross-world function.
  prefs: []
  type: TYPE_NORMAL
- en: 'And let''s say we have another function that takes an `int` as input and returns
    a `OrderQty` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Again, it might not return an `OrderQty` if the input is not positive. The signature
    is therefore `int -> OrderQty option` -- another cross-world function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how can we create a function that starts with an string and returns an
    `OrderQty` in one step?
  prefs: []
  type: TYPE_NORMAL
- en: The output of `parseInt` cannot be fed directly into `toOrderQty`, so this is
    where `bind` comes to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: Doing `Option.bind toOrderQty` lifts it to a `int option -> OrderQty option`
    function and so the output of `parseInt` can be used as input, just as we need.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The signature of our new `parseOrderQty` is `string -> OrderQty option`, yet
    another cross-world function. So if we want to do something with the `OrderQty`
    that is output we may well have to use `bind` again on the next function in the
    chain.
  prefs: []
  type: TYPE_NORMAL
- en: Infix version of bind
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with `apply`, using the named `bind` function can be awkward, so it is common
    to create an infix version, typically called `>>=` (for left to right data flow)
    or `=<<` (for right to left data flow) .
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place you can write an alternative version of `parseOrderQty`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can see that `>>=` performs the same kind of role as pipe (`|>`) does, except
    that it works to pipe "elevated" values into cross-world functions.
  prefs: []
  type: TYPE_NORMAL
- en: Bind as a "programmable semicolon"
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bind can be used to chain any number of functions or expressions together,
    so you often see code looking something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not too different from how an imperative program might look if you
    replace the `>>=` with a `;`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Because of this, `bind` is sometimes called a "programmable semicolon".
  prefs: []
  type: TYPE_NORMAL
- en: Language support for bind/return
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most functional programming languages have some kind of syntax support for `bind`
    that lets you avoid having to write a series of continuations or use explicit
    binds.
  prefs: []
  type: TYPE_NORMAL
- en: 'In F# it is (one component) of computation expressions, so the following explicit
    chaining of `bind`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'becomes implicit, using `let!` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In Haskell, the equivalent is the "do notation":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And in Scala, the equivalent is the "for comprehension":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: It's important to emphasize that you do not *have* to use the special syntax
    when using bind/return. You can always use `bind` or `>>=` in the same way as
    any other function.
  prefs: []
  type: TYPE_NORMAL
- en: Bind vs. Apply vs. Map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The combination of `bind` and `return` are considered even more powerful than
    `apply` and `return`, because if you have `bind` and `return`, you can construct
    `map` and `apply` from them, but not vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how bind can be used to emulate `map`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you construct a world-crossing function from a normal function by applying
    `return` to the output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, convert this world-crossing function into a lifted function using `bind`.
    This gives you the same result as if you had simply done `map` in the first place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](vgfp_bind_vs_map.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, `bind` can emulate `apply`. Here is how `map` and `apply` can be
    defined using `bind` and `return` for Options in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: At this point, people often ask "why should I use `apply` instead of `bind`
    when `bind` is more powerful?"
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that just because `apply` *can* be emulated by `bind`, doesn't
    mean it *should* be. For example, it is possible to implement `apply` in a way
    that cannot be emulated by a `bind` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, using `apply` ("applicative style") or `bind` ("monadic style") can
    have a profound effect on how your program works! We'll discuss these two approaches
    in more detail in [part 3 of this post](elevated-world-3.html#dependent).
  prefs: []
  type: TYPE_NORMAL
- en: The properties of a correct bind/return implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with `map`, and as with `apply`/`return`, a correct implementation of the
    `bind`/`return` pair should have some properties that are true no matter what
    elevated world we are working with.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three so-called ["Monad Laws"](https://en.wikibooks.org/wiki/Haskell/Understanding_monads#Monad_Laws),
    and one way of defining a **Monad** (in the programming sense) is to say that
    it consists of three things: a generic type constructor `E<T>` plus a pair of
    functions (`bind` and `return`) that obey the monad laws. This is not the only
    way to define a monad, and mathematicians typically use a slightly different definition,
    but this one is most useful to programmers.'
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the the Functor and Applicative laws we saw earlier, these laws
    are quite sensible.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, note that `return` function is itself a cross-world function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_monad_law1_a.png)'
  prefs: []
  type: TYPE_IMG
- en: That means that we can use `bind` to lift it into a function in the elevated
    world. And what does this lifted function do? Hopefully, nothing! It should just
    return its input.
  prefs: []
  type: TYPE_NORMAL
- en: 'So that is exactly the first monad law: it says that this lifted function must
    be the same as the `id` function in the elevated world.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_monad_law1_b.png)'
  prefs: []
  type: TYPE_IMG
- en: The second law is similar but with `bind` and `return` reversed. Say that we
    have a normal value `a` and cross-world function `f` that turns an `a` into a
    `E<b>`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_monad_law2_a.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's lift both of them to the elevated world, using `bind` on `f` and `return`
    on `a`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_monad_law2_b.png)'
  prefs: []
  type: TYPE_IMG
- en: Now if we apply the elevated version of `f` to the elevated verson of `a` we
    get some value `E<b>`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_monad_law2_c.png)'
  prefs: []
  type: TYPE_IMG
- en: On the other hand if we apply the normal version of `f` to the normal verson
    of `a` we *also* get some value `E<b>`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_monad_law2_d.png)'
  prefs: []
  type: TYPE_IMG
- en: The second monad law says that these two elevated values (`E<b>`) should be
    the same. In other words, all this binding and returning should not distort the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The third monad law is about associativity.
  prefs: []
  type: TYPE_NORMAL
- en: In the normal world, function composition is associative. For example, we could
    pipe a value into a function `f` and then take that result and pipe it into another
    function `g`. Alternatively, we can compose `f` and `g` first into a single function
    and then pipe `a` into it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the normal world, we expect both of these alternatives to give the same answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third monad law says that, after using `bind` and `return`, the grouping
    doesn''t matter either. The two examples below correspond to the examples above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: And again, we expect both of these to give the same answer.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: List is not a monad. Option is not a monad.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look at the definition above, a monad has a type constructor (a.k.a "generic
    type") *and* two functions *and* a set of properties that must be satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: The `List` data type is therefore just one component of a monad, as is the `Option`
    data type. `List` and `Option`, by themselves, are not monads.
  prefs: []
  type: TYPE_NORMAL
- en: It might be better to think of a monad as a *transformation*, so that the "List
    monad" is the transformation that converts the normal world to the elevated "List
    world", and the "Option monad" is the transformation that converts the normal
    world to the elevated "Option world".
  prefs: []
  type: TYPE_NORMAL
- en: 'I think this is where a lot of the confusion comes in. The word "List" can
    mean many different things:'
  prefs: []
  type: TYPE_NORMAL
- en: A concrete type or data structure such as `List<int>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A type constructor (generic type): `List<T>`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A type constructor and some operations, such as a `List` class or module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A type constructor and some operations and the operations satisfy the monad
    laws.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only the last one is a monad! The other meanings are valid but contribute to
    the confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Also the last two cases are hard to tell apart by looking at the code. Unfortunately,
    there have been cases where implementations did not satisfy the monad laws. Just
    because it's a "Monad" doesn't mean that it's a monad.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I try to avoid using the word "monad" on this site and focus on
    the `bind` function instead, as part of a toolkit of functions for solving problems
    rather than an abstract concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'So don''t ask: Do I have a monad?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Do ask: Do I have useful bind and return functions? And are they implemented
    correctly?'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have a set of four core functions: `map`, `return`, `apply`, and `bind`,
    and I hope that you are clear on what each one does.'
  prefs: []
  type: TYPE_NORMAL
- en: But there are some questions that have not been addressed yet, such as "why
    should I choose `apply` instead of `bind`?", or "how can I deal with multiple
    elevated worlds at the same time?"
  prefs: []
  type: TYPE_NORMAL
- en: In the [next post](elevated-world-3.html) we'll address these questions and
    demonstrate how to use the toolset with a series of practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: '*UPDATE: Fixed error in monad laws pointed out by @joseanpg. Thanks!*'
  prefs: []
  type: TYPE_NORMAL
- en: Using the core functions in practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the core functions in practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This post is the third in a series. In the [previous two posts](elevated-world.html),
    I described some of the core functions for dealing with generic data types: `map`,
    `apply`, `bind`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: In this post, I'll show how to use these functions in practice, and will explain
    the difference between the so-called "applicative" and "monadic" styles.
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a list of shortcuts to the various functions mentioned in this series:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Lifting to the elevated world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `map` function](elevated-world.html#map)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `return` function](elevated-world.html#return)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `apply` function](elevated-world.html#apply)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `liftN` family of functions](elevated-world.html#lift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `zip` function and ZipList world](elevated-world.html#zip)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: How to compose world-crossing functions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `bind` function](elevated-world-2.html#bind)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List is not a monad. Option is not a monad.](elevated-world-2.html#not-a-monad)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Using the core functions in practice**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Independent and dependent data](elevated-world-3.html#dependent)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Validation using applicative style and monadic style](elevated-world-3.html#validation)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lifting to a consistent world](elevated-world-3.html#consistent)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kleisli world](elevated-world-3.html#kleisli)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Mixing lists and elevated values**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mixing lists and elevated values](elevated-world-4.html#mixing)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `traverse`/`MapM` function](elevated-world-4.html#traverse)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `sequence` function](elevated-world-4.html#sequence)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '["Sequence" as a recipe for ad-hoc implementations](elevated-world-4.html#adhoc)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Readability vs. performance](elevated-world-4.html#readability)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dude, where''s my `filter`?](elevated-world-4.html#filter)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: A real-world example that uses all the techniques**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Downloading and processing a list of websites](elevated-world-5.html#asynclist)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Treating two worlds as one](elevated-world-5.html#asyncresult)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Designing your own elevated world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Designing your own elevated world](elevated-world-6.html#part6)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering out failures](elevated-world-6.html#filtering)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Reader monad](elevated-world-6.html#readermonad)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 7: Summary**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List of operators mentioned](elevated-world-7.html#operators)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Further reading](elevated-world-7.html#further-reading)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Using the core functions in practice'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the basic tools for lifting normal values to elevated values
    and working with cross-world functions, it's time to start working with them!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll look at some examples how these functions are actually
    used.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Independent vs. dependent data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I briefly mentioned earlier that there is a important difference between using
    `apply` and `bind`. Let's go into this now.
  prefs: []
  type: TYPE_NORMAL
- en: When using `apply`, you can see that each parameter (`E<a>`, `E<b>`) is completely
    independent of the other. The value of `E<b>` does not depend on what `E<a>` is.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_apply3.png)'
  prefs: []
  type: TYPE_IMG
- en: On the other hand, when using `bind`, the value of `E<b>` *does* depend on what
    `E<a>` is.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_bind.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The distinction between working with independent values or dependent values
    leads to two different styles:'
  prefs: []
  type: TYPE_NORMAL
- en: The so-called "applicative" style uses functions such as `apply`, `lift`, and
    `combine` where each elevated value is independent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The so-called "monadic" style uses functions such as `bind` to chain together
    functions that are dependent on a previous value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does that mean in practice? Well, let's look at an example where you could
    choose from both approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Say that you have to download data from three websites and combine them. And
    say that we have an action, say `GetURL`, that gets the data from a website on
    demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you have a choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Do you want to fetch all the URLs in parallel?** If so, treat the `GetURL`s
    as independent data and use the applicative style.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do you want to fetch each URL one at a time, and skip the next in line if
    the previous one fails?** If so, treat the `GetURL`s as dependent data and use
    the monadic style. This linear approach will be slower overall than the "applicative"
    version above, but will also avoid unnecessary I/O.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Does the URL for the next site depend on what you download from the previous
    site?** In this case, you are *forced* to use "monadic" style, because each `GetURL`
    depends on the output of the previous one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the choice between applicative style and monadic style is not
    clear cut; it depends on what you want to do.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at a real implementation of this example in the [final post of this
    series](elevated-world-5.html#asynclist).
  prefs: []
  type: TYPE_NORMAL
- en: '**but...**'
  prefs: []
  type: TYPE_NORMAL
- en: It's important to say that just because you *choose* a style doesn't mean it
    will be implemented as you expect. As we have seen, you can easily implement `apply`
    in terms of `bind`, so even if you use `<*>` in your code, the implementation
    may be proceeding monadically.
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, the implementation does not have to run the downloads
    in parallel. It could run them serially instead. By using applicative style, you're
    just saying that you don't care about dependencies and so they *could* be downloaded
    in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Static vs. dynamic structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you use the applicative style, that means that you define all the actions
    up front -- "statically", as it were.
  prefs: []
  type: TYPE_NORMAL
- en: In the downloading example, the applicative style requires that you specific
    *in advance* which URLs will be visited. And because there is more knowledge up
    front it means that we can potentially do things like parallelization or other
    optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the monadic style means that only the initial action is known
    up front. The remainder of the actions are determined dynamically, based on the
    output of previous actions. This is more flexible, but also limits our ability
    to see the big picture in advance.
  prefs: []
  type: TYPE_NORMAL
- en: Order of evaluation vs. dependency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes *dependency* is confused with *order of evaluation*.
  prefs: []
  type: TYPE_NORMAL
- en: Certainly, if one value depends on another then the first value must be evaluated
    before the second value. And in theory, if the values are completely independent
    (and have no side effects), then they can be evaluated in any order.
  prefs: []
  type: TYPE_NORMAL
- en: However, even if the values are completely independent, there can still be an
    *implicit* order in how they are evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: For example, even if the list of `GetURL`s is done in parallel, it's likely
    that the urls will begin to be fetched in the order in which they are listed,
    starting with the first one.
  prefs: []
  type: TYPE_NORMAL
- en: And in the `List.apply` implemented in the previous post, we saw that `[f; g]
    apply [x; y]` resulted in `[f x; f y; g x; g y]` rather than `[f x; g x; f y;
    g y]`. That is, all the `f` values are first, then all the `g` values.
  prefs: []
  type: TYPE_NORMAL
- en: In general, then, there is a convention that values are evaluated in a left
    to right order, even if they are independent.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Validation using applicative style and monadic style'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see how both the applicative style and monadic style can be used, let's look
    at an example using validation.
  prefs: []
  type: TYPE_NORMAL
- en: Say that we have a simple domain containing a `CustomerId`, an `EmailAddress`,
    and a `CustomerInfo` which is a record containing both of these.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: And let's say that there is some validation around creating a `CustomerId`.
    For example, that the inner `int` must be positive. And of course, there will
    be some validation around creating a `EmailAddress` too. For example, that it
    must contain an "@" sign at least.
  prefs: []
  type: TYPE_NORMAL
- en: How would we do this?
  prefs: []
  type: TYPE_NORMAL
- en: First we create a type to represent the success/failure of validation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that I have defined the `Failure` case to contain a *list* of strings,
    not just one. This will become important later.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `Result` in hand, we can go ahead and define the two constructor/validation
    functions as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `createCustomerId` has type `int -> Result<CustomerId>`, and `createEmailAddress`
    has type `string -> Result<EmailAddress>`.
  prefs: []
  type: TYPE_NORMAL
- en: That means that both of these validation functions are world-crossing functions,
    going from the normal world to the `Result<_>` world.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the core functions for `Result`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we are dealing with world-crossing functions, we know that we will have
    to use functions like `apply` and `bind`, so let's define them for our `Result`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If we check the signatures, we can see that they are exactly as we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '`map` has signature: `(''a -> ''b) -> Result<''a> -> Result<''b>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retn` has signature: `''a -> Result<''a>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apply` has signature: `Result<(''a -> ''b)> -> Result<''a> -> Result<''b>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bind` has signature: `(''a -> Result<''b>) -> Result<''a> -> Result<''b>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I defined a `retn` function in the module to be consistent, but I don't bother
    to use it very often. The *concept* of `return` is important, but in practice,
    I'll probably just use the `Success` constructor directly. In languages with type
    classes, such as Haskell, `return` is used much more.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that `apply` will concat the error messages from each side if both
    parameters are failures. This allows us to collect all the failures without discarding
    any. This is the reason why I made the `Failure` case have a list of strings,
    rather than a single string.
  prefs: []
  type: TYPE_NORMAL
- en: '*NOTE: I''m using `string` for the failure case to make the demonstration easier.
    In a more sophisticated design I would list the possible failures explicitly.
    See my [functional error handling](http://fsharpforfunandprofit.com/rop/) talk
    for more details.*'
  prefs: []
  type: TYPE_NORMAL
- en: Validation using applicative style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have have the domain and the toolset around `Result`, let's try
    using the applicative style to create a `CustomerInfo` record.
  prefs: []
  type: TYPE_NORMAL
- en: The outputs of the validation are already elevated to `Result`, so we know we'll
    need to use some sort of "lifting" approach to work with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we''ll create a function in the normal world that creates a `CustomerInfo`
    record given a normal `CustomerId` and a normal `EmailAddress`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note that the signature is `CustomerId -> EmailAddress -> CustomerInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use the lifting technique with `<!>` and `<*>` that was explained
    in the previous post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The signature of this shows that we start with a normal `int` and `string` and
    return a `Result<CustomerInfo>`
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_applicative_style.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try it out with some good and bad data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `goodCustomerA` is a `Success` and contains the right data, but the `badCustomerA`
    is a `Failure` and contains two validation error messages. Excellent!
  prefs: []
  type: TYPE_NORMAL
- en: Validation using monadic style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let''s do another implementation, but this time using monadic style. In
    this version the logic will be:'
  prefs: []
  type: TYPE_NORMAL
- en: try to convert an int into a `CustomerId`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if that is successful, try to convert a string into a `EmailAddress`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if that is successful, create a `CustomerInfo` from the customerId and email.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The signature of the monadic-style `createCustomerResultM` is exactly the same
    as the applicative-style `createCustomerResultA` but internally it is doing something
    different, which will be reflected in the different results we get.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_monadic_style.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the good customer case, the end result is the same, but in the bad customer
    case, only *one* error is returned, the first one. The rest of the validation
    was short circuited after the `CustomerId` creation failed.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the two styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example has demonstrated the difference between applicative and monadic
    style quite well, I think.
  prefs: []
  type: TYPE_NORMAL
- en: The *applicative* example did all the validations up front, and then combined
    the results. The benefit was that we didn't lose any of the validation errors.
    The downside was we did work that we might not have needed to do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](vgfp_applicative_style.png)'
  prefs: []
  type: TYPE_IMG
- en: On the other hand, the monadic example did one validation at a time, chained
    together. The benefit was that we short-circuited the rest of the chain as soon
    as an error occurred and avoided extra work. The downside was that we only got
    the *first* error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](vgfp_monadic_style.png)'
  prefs: []
  type: TYPE_IMG
- en: Mixing the two styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now there is nothing to say that we can't mix and match applicative and monadic
    styles.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we might build a `CustomerInfo` using applicative style, so that
    we don't lose any errors, but later on in the program, when a validation is followed
    by a database update, we probably want to use monadic style, so that the database
    update is skipped if the validation fails.
  prefs: []
  type: TYPE_NORMAL
- en: Using F# computation expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, let's build a computation expression for these `Result` types.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we just define a class with members called `Return` and `Bind`,
    and then we create an instance of that class, called `result`, say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then rewrite the `createCustomerResultM` function to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This computation expression version looks almost like using an imperative language.
  prefs: []
  type: TYPE_NORMAL
- en: Note that F# computation expressions are always monadic, as is Haskell do-notation
    and Scala for-comprehensions. That's not generally a problem, because if you need
    applicative style it is very easy to write without any language support.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Lifting to a consistent world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In practice, we often have a mish-mash of different kinds of values and functions
    that we need to combine together.
  prefs: []
  type: TYPE_NORMAL
- en: The trick for doing this is to convert all them to the *same* type, after which
    they can be combined easily.
  prefs: []
  type: TYPE_NORMAL
- en: Making values consistent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s revisit the previous validation example, but let''s change the record
    so that it has an extra property, a `name` of type string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As before, we want to create a function in the normal world that we will later
    lift to the `Result` world.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to update the lifted `createCustomer` with the extra parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: But this won't compile! In the series of parameters `idResult <*> name <*> emailResult`
    one of them is not like the others. The problem is that `idResult` and `emailResult`
    are both Results, but `name` is still a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fix is just to lift `name` into the world of results (say `nameResult`)
    by using `return`, which for `Result` is just `Success`. Here is the corrected
    version of the function that does work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Making functions consistent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The same trick can be used with functions too.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say that we have a simple customer update workflow with
    four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we validate the input. The output of this is the same kind of `Result`
    type we created above. Note that this validation function could *itself* be the
    result of combining other, smaller validation functions using `apply`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we canonicalize the data. For example: lowercasing emails, trimming whitespace,
    etc. This step never raises an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we fetch the existing record from the database. For example, getting a
    customer for the `CustomerId`. This step could fail with an error too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we update the database. This step is a "dead-end" function -- there
    is no output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For error handling, I like to think of there being two tracks: a Success track
    and a Failure track. In this model, an error-generating function is analogous
    to a railway switch (US) or points (UK).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_rop_before.png)'
  prefs: []
  type: TYPE_IMG
- en: The problem is that these functions cannot be glued together; they are all different
    shapes.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to convert all of them to the *same* shape, in this case the
    two-track model with success and failure on different tracks. Let's call this
    *Two-Track world*!
  prefs: []
  type: TYPE_NORMAL
- en: Transforming functions using the toolset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each original function, then, needs to be elevated to Two-Track world, and we
    know just the tools that can do this!
  prefs: []
  type: TYPE_NORMAL
- en: The `Canonicalize` function is a single track function. We can turn it into
    a two-track function using `map`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_rop_map.png)'
  prefs: []
  type: TYPE_IMG
- en: The `DbFetch` function is a world-crossing function. We can turn it into a wholly
    two-track function using `bind`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_rop_bind.png)'
  prefs: []
  type: TYPE_IMG
- en: The `DbUpdate` function is more complicated. We don't like dead-end functions,
    so first we need to transform it to a function where the data keeps flowing. I'll
    call this function `tee`. The output of `tee` has one track in and one track out,
    so we need to convert it to a two-track function, again using `map`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_rop_tee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After all these transformations, we can reassemble the new versions of these
    functions. The result looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_rop_after.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And of course, these functions can now be composed together very easily, so
    that we end up with a single function looking like this, with one input and a
    success/failure output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_rop_after2.png)'
  prefs: []
  type: TYPE_IMG
- en: This combined function is yet another world-crossing function of the form `a->Result<b>`,
    and so it in turn can be used as a component part of a even bigger function.
  prefs: []
  type: TYPE_NORMAL
- en: For more examples of this "elevating everything to the same world" approach,
    see my posts on [functional error handling](http://fsharpforfunandprofit.com/rop/)
    and [threading state](handling-state.html).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Kleisli world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an alternative world which can be used as a basic for consistency which
    I will call "Kleisli" world, named after [Professor Kleisli](https://en.wikipedia.org/wiki/Heinrich_Kleisli)
    -- a mathematician, of course!
  prefs: []
  type: TYPE_NORMAL
- en: In Kleisli world *everything* is a cross-world function! Or, using the railway
    track analogy, everything is a switch (or points).
  prefs: []
  type: TYPE_NORMAL
- en: In Kleisli world, the cross-world functions *can* be composed directly, using
    an operator called `>=>` for left-to-right composition or `<=<` for right-to-left
    composition.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_kleisli_3.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the same example as before, we can lift all our functions to Kleisli world.
  prefs: []
  type: TYPE_NORMAL
- en: The `Validate` and `DbFetch` functions are already in the right form so they
    don't need to be changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The one-track `Canonicalize` function can be lifted to a switch just by lifting
    the output to a two-track value. Let's call this `toSwitch`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](vgfp_kleisli_1.png)'
  prefs: []
  type: TYPE_IMG
- en: The tee-d `DbUpdate` function can be also lifted to a switch just by doing `toSwitch`
    after the tee.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](vgfp_kleisli_2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once all the functions have been lifted to Kleisli world, they can be composed
    with Kleisli composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_kleisli_4.png)'
  prefs: []
  type: TYPE_IMG
- en: Kleisli world has some nice properties that Two-Track world doesn't but on the
    other hand, I find it hard to get my head around it! So I generally stick to using
    Two-Track world as my foundation for things like this.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post, we learned about "applicative" vs "monadic" style, and why the
    choice could have an important effect on which actions are executed, and what
    results are returned.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how to lift different kinds values and functions to a a consistent
    world so that the could be worked with easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the [next post](elevated-world-4.html) we''ll look at a common problem:
    working with lists of elevated values.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding traverse and sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding traverse and sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This post is one in a series. In the [first two posts](elevated-world.html),
    I described some of the core functions for dealing with generic data types: `map`,
    `bind`, and so on. In the [previous post](elevated-world-3.html), I discussed
    "applicative" vs "monadic" style, and how to lift values and functions to be consistent
    with each other.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this post, we''ll look at a common problem: working with lists of elevated
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a list of shortcuts to the various functions mentioned in this series:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Lifting to the elevated world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `map` function](elevated-world.html#map)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `return` function](elevated-world.html#return)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `apply` function](elevated-world.html#apply)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `liftN` family of functions](elevated-world.html#lift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `zip` function and ZipList world](elevated-world.html#zip)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: How to compose world-crossing functions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `bind` function](elevated-world-2.html#bind)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List is not a monad. Option is not a monad.](elevated-world-2.html#not-a-monad)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Using the core functions in practice**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Independent and dependent data](elevated-world-3.html#dependent)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Validation using applicative style and monadic style](elevated-world-3.html#validation)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lifting to a consistent world](elevated-world-3.html#consistent)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kleisli world](elevated-world-3.html#kleisli)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Mixing lists and elevated values**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mixing lists and elevated values](elevated-world-4.html#mixing)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `traverse`/`MapM` function](elevated-world-4.html#traverse)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `sequence` function](elevated-world-4.html#sequence)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '["Sequence" as a recipe for ad-hoc implementations](elevated-world-4.html#adhoc)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Readability vs. performance](elevated-world-4.html#readability)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dude, where''s my `filter`?](elevated-world-4.html#filter)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: A real-world example that uses all the techniques**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Downloading and processing a list of websites](elevated-world-5.html#asynclist)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Treating two worlds as one](elevated-world-5.html#asyncresult)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Designing your own elevated world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Designing your own elevated world](elevated-world-6.html#part6)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering out failures](elevated-world-6.html#filtering)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Reader monad](elevated-world-6.html#readermonad)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 7: Summary**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List of operators mentioned](elevated-world-7.html#operators)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Further reading](elevated-world-7.html#further-reading)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Mixing lists and elevated values'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common issue is how to deal with lists or other collections of elevated values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 1:** We have a `parseInt` with signature `string -> int option`,
    and we have a list of strings. We want to parse all the strings at once. Now of
    course we can use `map` to convert the list of strings to a list of options. But
    what we *really* want is not a "list of options" but an "option of list", a list
    of parsed ints, wrapped in an option in case any fail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example 2:** We have a `readCustomerFromDb` function with signature `CustomerId
    -> Result<Customer>`, that will return `Success` if the record can be found and
    returned, and `Failure` otherwise. And say we have a list of `CustomerId`s and
    we want to read all the customers at once. Again, we can use `map` to convert
    the list of ids to a list of results. But what we *really* want is not a list
    of `Result<Customer>`, but a `Result` containing a `Customer list`, with the `Failure`
    case in case of errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example 3:** We have a `fetchWebPage` function with signature `Uri -> Async<string>`,
    that will return a task that will download the page contents on demand. And say
    we have a list of `Uris`s and we want to fetch all the pages at once. Again, we
    can use `map` to convert the list of `Uri`s to a list of `Async`s. But what we
    *really* want is not a list of `Async`, but a `Async` containing a list of strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping an Option generating function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's start by coming up with a solution for the first case and then seeing
    if we can generalize it to the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The obvious approach would be:'
  prefs: []
  type: TYPE_NORMAL
- en: First, use `map` to turn the list of `string` into a list of `Option<int>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, create a function that turns the list of `Option<int>` into an `Option<int
    list>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But this requires *two* passes through the list. Can we do it in one pass?
  prefs: []
  type: TYPE_NORMAL
- en: Yes! If we think about how a list is built, there is a "cons" function (`::`
    in F#) that is used to join the head to the tail. If we elevate this to the `Option`
    world, we can use `Option.apply` to join a head `Option` to a tail `Option` using
    the lifted version of `cons`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '*NOTE: I defined `cons` explicitly because `::` is not a function and `List.Cons`
    takes a tuple and is thus not usable in this context.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation as a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_mapOption.png)'
  prefs: []
  type: TYPE_IMG
- en: If you are confused as to how this works, please read the section on `apply`
    in the first post in this series.
  prefs: []
  type: TYPE_NORMAL
- en: Note also that I am explicitly defining `retn` and using it in the implementation
    rather than just using `Some`. You'll see why in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's test it!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We start by defining `parseInt` of type `string -> int option` (piggybacking
    on the existing .NET library).
  prefs: []
  type: TYPE_NORMAL
- en: We use `mapOption` to run it against a list of good values, and we get `Some
    [1; 2; 3]`, with the list *inside* the option, just as we want.
  prefs: []
  type: TYPE_NORMAL
- en: And if we use a list where some of the values are bad, we get `None` for the
    entire result.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping a Result generating function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's repeat this, but this time using the `Result` type from the earlier validation
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `mapResult` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Again I am explicitly defining a `retn` rather than just using `Success`. And
    because of this, the body of the code for `mapResult` and `mapOption` is *exactly
    the same*!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s change `parseInt` to return a `Result` rather than an `Option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we can rerun the tests again, but this time getting more informative
    errors in the failure case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Can we make a generic mapXXX function?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implementations of `mapOption` and `mapResult` have exactly the same code,
    the only difference is the different `retn` and `<*>` functions (from Option and
    Result, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: So the question naturally arises, rather than having `mapResult`, `mapOption`,
    and other specific implementations for each elevated type, can we make a completely
    generic version of `mapXXX` that works for *all* elevated types?
  prefs: []
  type: TYPE_NORMAL
- en: 'The obvious thing would be able to pass these two functions in as an extra
    parameter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: There are some problems with this though. First, this code doesn't compile in
    F#! But even if it did, we'd want to make sure that the *same* two parameters
    were passed around everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might attempt this by creating a record structure containing the two parameters,
    and then create one instance for each type of elevated world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The instance of the `Applicative` record (`appl` say) would be an extra parameter
    to our generic `mapE` function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In use, we would pass in the specific applicative instance that we want, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, none of this works either, at least in F#. The `Applicative`
    type, as defined, won't compile. This is because F# does not support "higher-kinded
    types". That is, we can't parameterize the `Applicative` type with a generic type,
    only with concrete types.
  prefs: []
  type: TYPE_NORMAL
- en: In Haskell and languages that *do* support "higher-kinded types", the `Applicative`
    type that we've defined is similar to a "type class". What's more, with type classes,
    we don't have to pass around the functions explicitly -- the compiler will do
    that for us.
  prefs: []
  type: TYPE_NORMAL
- en: There is actually a clever (and hacky) way of getting the same effect in F#
    though using static type constraints. I'm not going to discuss it here, but you
    can see it used in the [FSharpx library](https://github.com/fsprojects/FSharpx.Extras/blob/master/src/FSharpx.Extras/ComputationExpressions/Monad.fs).
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative to all this abstraction is just creating a `mapXXX` function
    for each elevated world that we want to work with: `mapOption`, `mapResult`, `mapAsync`
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Personally I am OK with this cruder approach. There are not that many elevated
    worlds that you work with regularly, and even though you lose out on abstraction,
    you gain on explicitness, which is often useful when working in a team of mixed
    abilities.
  prefs: []
  type: TYPE_NORMAL
- en: So let's look at these `mapXXX` functions, also called `traverse`.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The `traverse` / `mapM` function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Common Names**: `mapM`, `traverse`, `for`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Operators**: None'
  prefs: []
  type: TYPE_NORMAL
- en: '**What it does**: Transforms a world-crossing function into a world-crossing
    function that works with collections'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signature**: `(a->E<b>) -> a list -> E<b list>` (or variants where list is
    replaced with other collection types)'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We saw above that we can define a set of `mapXXX` functions, where XXX stands
    for an applicative world -- a world that has `apply` and `return`. Each of these
    `mapXXX` functions transforms a world-crossing function into a world-crossing
    function that works with collections.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_traverse.png)'
  prefs: []
  type: TYPE_IMG
- en: And as we noted above, if the language supports type classes, we can get away
    with a single implementation, called `mapM` or `traverse`. I'm going to call the
    general concept `traverse` from now on to make it clear that is different from
    `map`.
  prefs: []
  type: TYPE_NORMAL
- en: Map vs. Traverse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Understanding the difference between `map` and `traverse` can be hard, so let's
    see if we can explain it in pictures.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's introduce some visual notation using the analogy of an "elevated"
    world sitting above a "normal" world.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these elevated worlds (in fact almost all of them!) have `apply` and
    `return` functions. We'll call these "Applicative worlds". Examples include `Option`,
    `Result`, `Async`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: And some of these elevated worlds have a `traverse` function. We'll call these
    "Traversable worlds", and we'll use `List` as a classic example.
  prefs: []
  type: TYPE_NORMAL
- en: If a Traversable world is on top, that produces a type such as `List<a>`, and
    if an Applicative world is on top, that produces a type such as `Result<a>`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_mstack_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*IMPORTANT: I will be using the syntax `List<_>` to represent "List world"
    for consistency with `Result<_>`, etc. This is* not *meant to be the same as the
    .NET List class! In F#, this would be implemented by the immutable `list` type*.'
  prefs: []
  type: TYPE_NORMAL
- en: But from now on we are going to be dealing with *both* kinds of elevated worlds
    in the same "stack".
  prefs: []
  type: TYPE_NORMAL
- en: The Traversable world can be stacked on top of the Applicative world, which
    produces a type such as `List<Result<a>>`, or alternatively, the Applicative world
    world can be stacked on top of the Traversable world, which produces a type such
    as `Result<List<a>>`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_mstack_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Now let's see what the different kinds of functions look like using this notation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a plain cross-world function such as `a -> Result<b>`, where
    the target world is an applicative world. In the diagram, the input is a normal
    world (on the left), and the output (on the right) is an applicative world stacked
    on top of the normal world.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_traverse_cross.png)'
  prefs: []
  type: TYPE_IMG
- en: Now if we have a list of normal `a` values, and then we use `map` to transform
    each `a` value using a function like `a -> Result<b>`, the result will also be
    a list, but where the contents are `Result<b>` values instead of `a` values.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_traverse_map.png)'
  prefs: []
  type: TYPE_IMG
- en: When it comes to `traverse` the effect is quite different. If we use `traverse`
    to transform a list of `a` values using that function, the output will be a `Result`,
    not a list. And the contents of the `Result` will be a `List<b>`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_traverse_traverse.png)'
  prefs: []
  type: TYPE_IMG
- en: In other words, with `traverse`, the `List` stays attached to the normal world,
    and the Applicative world (such as `Result`) is added at the top.
  prefs: []
  type: TYPE_NORMAL
- en: Ok, I know this all sounds very abstract, but it is actually a very useful technique.
    We'll see an example of this is used in practice below.
  prefs: []
  type: TYPE_NORMAL
- en: Applicative vs. monadic versions of `traverse`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It turns out that `traverse` can be implemented in an applicative style or a
    monadic style, so there are often two separate implementations to choose from.
    The applicative versions tend to end in `A` and the monadic versions end in `M`,
    which is helpful!
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how this works with our trusty `Result` type.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll implement `traverseResult` using both applicative and monadic approaches.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The applicative version is the same implementation that we used earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The monadic version applies the function `f` to the first element and then passes
    it to `bind`. As always with monadic style, if the result is bad the rest of the
    list will be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the result is good, the next element in the list is processed,
    and so on. Then the results are cons'ed back together again.
  prefs: []
  type: TYPE_NORMAL
- en: '*NOTE: These implementations are for demonstration only! Neither of these implementations
    are tail-recursive, and so they will fail on large lists!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, let''s test the two functions and see how they differ. First we need
    our `parseInt` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now if we pass in a list of good values (all parsable), the result for both
    implementations is the same.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: But if we pass in a list with some bad values, the results differ.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The applicative version returns *all* the errors, while the monadic version
    returns only the first error.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing `traverse` using `fold`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I mentioned above that the "from-scratch" implementation was not tail recursive
    and would fail for large lists. That could be fixed of course, at the price of
    making the code more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if your collection type has a "right fold" function, as `List`
    does, then you can use that to make the implementation simpler, faster, and safer
    too.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, I always like to use `fold` and its ilk wherever possible so that I
    never have to worry about getting tail-recursion right!
  prefs: []
  type: TYPE_NORMAL
- en: So, here are the re-implementations of `traverseResult`, using `List.foldBack`.
    I have kept the code as similar as possible, but delegated the looping over the
    list to the fold function, rather than creating a recursive function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Note that this approach will not work for all collection classes. Some types
    do not have a right fold, so `traverse` must be implemented differently.
  prefs: []
  type: TYPE_NORMAL
- en: What about types other than lists?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All these examples have used the `list` type as the collection type. Can we
    implement `traverse` for other types too?
  prefs: []
  type: TYPE_NORMAL
- en: Yes. For example, an `Option` can be considered a one-element list, and we can
    use the same trick.
  prefs: []
  type: TYPE_NORMAL
- en: For example, here's an implementation of `traverseResultA` for `Option`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now we can wrap a string in an `Option` and use `parseInt` on it. Rather than
    getting a `Option` of `Result`, we invert the stack and get a `Result` of `Option`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If we pass in an unparsable string, we get failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: If we pass in `None`, we get `Success` containing `None`!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This last result might be surprising at first glance, but think of it this way,
    the parsing didn't fail, so there was no `Failure` at all.
  prefs: []
  type: TYPE_NORMAL
- en: Traversables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Types that can implement a function like `mapXXX` or `traverseXXX` are called
    *Traversable*. For example, collection types are Traversables as well as some
    others.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw above, in a language with type classes a Traversable type can get
    away with just one implementation of `traverse`, but in a language without type
    classes a Traversable type will need one implementation per elevated type.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that, unlike all the generic functions we have created before, the
    type being acted on (inside the collection) must have appropriate `apply` and
    `return` functions in order for `traverse` to be implemented. That is, the inner
    type must be an Applicative.
  prefs: []
  type: TYPE_NORMAL
- en: The properties of a correct `traverse` implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As always, a correct implementation of `traverse` should have some properties
    that are true no matter what elevated world we are working with.
  prefs: []
  type: TYPE_NORMAL
- en: These are the ["Traversable Laws"](https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Traversable.html),
    and a **Traversable** is defined as a generic data type constructor -- `E<T>`
    -- plus a set of functions (`traverse` or `traverseXXX` ) that obey these laws.
  prefs: []
  type: TYPE_NORMAL
- en: The laws are similar to the previous ones. For example, the identity function
    should be mapped correctly, composition should be preserved, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The `sequence` function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Common Names**: `sequence`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Operators**: None'
  prefs: []
  type: TYPE_NORMAL
- en: '**What it does**: Transforms a list of elevated values into an elevated value
    containing a list'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signature**: `E<a> list -> E<a list>` (or variants where list is replaced
    with other collection types)'
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We saw above how you can use the `traverse` function as a substitute for `map`
    when you have a function that generates an applicative type such as `Result`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what happens if you are just handed a `List<Result>` and you need to change
    it to a `Result<List>`. That is, you need to swap the order of the worlds on the
    stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_sequence_stack.png)'
  prefs: []
  type: TYPE_IMG
- en: This is where `sequence` is useful -- that's exactly what it does! The `sequence`
    function "swaps layers".
  prefs: []
  type: TYPE_NORMAL
- en: 'The order of swapping is fixed:'
  prefs: []
  type: TYPE_NORMAL
- en: The Traversable world starts higher and is swapped *down*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Applicative world starts lower and is swapped *up*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that if you aleady have an implementation of `traverse`, then `sequence`
    can be derived from it easily. In fact, you can think of `sequence` as `traverse`
    with the `id` function baked in.
  prefs: []
  type: TYPE_NORMAL
- en: Applicative vs Monadic versions of `sequence`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as with `traverse`, there can be applicative and monadic versions of `sequence`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sequenceA` for the applicative one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sequenceM` (or just `sequence`) for the monadic one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s implement and test a `sequence` implementation for `Result`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Ok, that was too easy! Now let''s test it, starting with the applicative version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'and then the monadic version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: As before, we get back a `Result<List>`, and as before the monadic version stops
    on the first error, while the applicative version accumulates all the errors.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '"Sequence" as a recipe for ad-hoc implementations'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw above that having type classes like Applicative means that you only need
    to implement `traverse` and `sequence` once. In F# and other languages without
    high-kinded types you have to create an implementation for each type that you
    want to traverse over.
  prefs: []
  type: TYPE_NORMAL
- en: Does that mean that the concepts of `traverse` and `sequence` are irrelevant
    or too abstract? I don't think so.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of thinking of them as library functions, I find that it is useful to
    think of them as *recipes* -- a set of instructions that you can follow mechanically
    to solve a particular problem.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, the problem is unique to a context, and there is no need to create
    a library function -- you can create a helper function as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me demonstrate with an example. Say that you are given a list of options,
    where each option contains a tuple, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This data is in the form `List<Option<Tuple<int>>>`. And now say, that for
    some reason, you need to turn it into a *tuple* of two lists, where each list
    contains options, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The desired result is in the form `Tuple<List<Option<int>>>`.
  prefs: []
  type: TYPE_NORMAL
- en: So, how would you write a function to do this? Quick!
  prefs: []
  type: TYPE_NORMAL
- en: No doubt you could come up with one, but it might require a bit of thought and
    testing to be sure you get it right.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you recognize that this task is just transforming a stack
    of worlds to another stack, you can create a function *mechanically*, almost without
    thinking.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_tuple_sequence-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Designing the solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To design the solution, we need to pay attention to which worlds move up and
    which worlds move down.
  prefs: []
  type: TYPE_NORMAL
- en: The tuple world needs to end up at the top, so it will have to be swapped "up",
    which in turn means that it will play the role of "applicative".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The option and list worlds need to be swapped "down", which in turn means that
    they will both play the role of "traversable".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to do this transform then, I will need two helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`optionSequenceTuple` will move an option down and a tuple up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](vgfp_tuple_sequence-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '`listSequenceTuple` will move a list down and a tuple up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](vgfp_tuple_sequence-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Do these helper functions need to be in a library? No. It's unlikely that I
    will need them again, and even I need them occasionally, I'd prefer to write them
    scratch to avoid having to take a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `List.sequenceResult` function implemented earlier that
    converts a `List<Result<a>>` to a `Result<List<a>>` is something I do use frequently,
    and so that one *is* worth centralizing.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we know how the solution will look, we can start coding mechanically.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the tuple is playing the role of the applicative, so we need to define
    the `apply` and `return` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define `listSequenceTuple` using exactly the same right fold template
    as we did before, with `List` as the traversable and tuple as the applicative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: There is no thinking going on here. I'm just following the template!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test it immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: And it gives a tuple with two lists, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, define `optionSequenceTuple` using the same right fold template
    again. This time `Option` is the traversable and tuple is still the applicative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test it too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: And it gives a tuple with two options, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can glue all the parts together. Again, no thinking required!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we use it, we get just what we wanted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Ok, this solution is more work than having one reusable function, but because
    it is mechanical, it only takes a few minutes to code, and is still easier than
    trying to come up with your own solution!
  prefs: []
  type: TYPE_NORMAL
- en: '*Want more? For an example of using `sequence` in a real-world problem, please
    read [this post](recursive-types-and-folds-3b.html#json-with-error-handling).*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Readability vs. performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of this post I noted our tendency as functional programmers
    to `map` first and ask questions later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, given a `Result` producing function like `parseInt`, we would
    start by collecting the results and only then figure out how to deal with them.
    Our code would look something like this, then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'But of course, this does involve two passes over the list, and we saw how `traverse`
    could combine the `map` and the `sequence` in one step, making only one pass over
    the list, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: So if `traverse` is more compact and potentially faster, why ever use `sequence`?
  prefs: []
  type: TYPE_NORMAL
- en: Well, sometimes you are given a certain structure and you have no choice, but
    in other situations I might still prefer the two-step `map-sequence` approach
    just because it is easier to understand. The mental model for "map" then "swap"
    seems easier to grasp for most people than the one-step traverse.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, I would always go for readability unless you can prove that
    performance is impacted. Many people are still learning FP, and being overly cryptic
    is not helpful, in my experience.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Dude, where's my `filter`?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen that functions like `map` and `sequence` work on lists to transform
    them into other types, but what about filtering? How can I filter things using
    these methods?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is -- you can't! `map`, and `traverse` and `sequence` are all "structure
    preserving". If you start with a list of 10 things you still have a list of 10
    things afterwards, albeit somewhere else in the stack. Or if you start with a
    tree with three branches, you still have a tree of three branches at the end.
  prefs: []
  type: TYPE_NORMAL
- en: In the tuple example above, the original list had four elements, and after the
    transformation, the two new lists in the tuple also had four elements.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to *change* the structure of a type, you need to use something like
    `fold`. Fold allows you to build a new structure from an old one, which means
    that you can use it to create a new list with some elements missing (i.e. a filter).
  prefs: []
  type: TYPE_NORMAL
- en: The various uses of fold are worthy of their own series, so I'm going to save
    a discussion of filtering for another time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post, we learned about `traverse` and `sequence` as a way of working
    with lists of elevated values.
  prefs: []
  type: TYPE_NORMAL
- en: In the [next post](elevated-world-5.html) we'll finish up by working through
    a practical example that uses all the techniques that have been discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Using map, apply, bind and sequence in practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using map, apply, bind and sequence in practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This post is the fifth in a series. In the [first two posts](elevated-world.html),
    I described some of the core functions for dealing with generic data types: `map`,
    `bind`, and so on. In the [third post](elevated-world-3.html), I discussed "applicative"
    vs "monadic" style, and how to lift values and functions to be consistent with
    each other. In the [previous post](elevated-world-4.html), I introduced `traverse`
    and `sequence` as a way of working with lists of elevated values.'
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we'll finish up by working through a practical example that uses
    all the techniques that have been discussed so far.
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a list of shortcuts to the various functions mentioned in this series:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Lifting to the elevated world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `map` function](elevated-world.html#map)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `return` function](elevated-world.html#return)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `apply` function](elevated-world.html#apply)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `liftN` family of functions](elevated-world.html#lift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `zip` function and ZipList world](elevated-world.html#zip)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: How to compose world-crossing functions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `bind` function](elevated-world-2.html#bind)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List is not a monad. Option is not a monad.](elevated-world-2.html#not-a-monad)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Using the core functions in practice**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Independent and dependent data](elevated-world-3.html#dependent)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Validation using applicative style and monadic style](elevated-world-3.html#validation)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lifting to a consistent world](elevated-world-3.html#consistent)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kleisli world](elevated-world-3.html#kleisli)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Mixing lists and elevated values**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mixing lists and elevated values](elevated-world-4.html#mixing)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `traverse`/`MapM` function](elevated-world-4.html#traverse)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `sequence` function](elevated-world-4.html#sequence)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '["Sequence" as a recipe for ad-hoc implementations](elevated-world-4.html#adhoc)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Readability vs. performance](elevated-world-4.html#readability)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dude, where''s my `filter`?](elevated-world-4.html#filter)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: A real-world example that uses all the techniques**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Downloading and processing a list of websites](elevated-world-5.html#asynclist)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Treating two worlds as one](elevated-world-5.html#asyncresult)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Designing your own elevated world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Designing your own elevated world](elevated-world-6.html#part6)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering out failures](elevated-world-6.html#filtering)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Reader monad](elevated-world-6.html#readermonad)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 7: Summary**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List of operators mentioned](elevated-world-7.html#operators)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Further reading](elevated-world-7.html#further-reading)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 5: A real-world example that uses all the techniques'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Downloading and processing a list of websites'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The example will be a variant of the one mentioned at the beginning of the
    [third post](elevated-world-3.html):'
  prefs: []
  type: TYPE_NORMAL
- en: Given a list of websites, create an action that finds the site with the largest
    home page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s break this down into steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First we'll need to transform the urls into a list of actions, where each action
    downloads the page and gets the size of the content.
  prefs: []
  type: TYPE_NORMAL
- en: And then we need to find the largest content, but in order to do this we'll
    have to convert the list of actions into a single action containing a list of
    sizes. And that's where `traverse` or `sequence` will come in.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: The downloader
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First we need to create a downloader. I would use the built-in `System.Net.WebClient`
    class, but for some reason it doesn't allow override of the timeout. I'm going
    to want to have a small timeout for the later tests on bad uris, so this is important.
  prefs: []
  type: TYPE_NORMAL
- en: 'One trick is to just subclass `WebClient` and intercept the method that builds
    a request. So here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I'm using units of measure for the timeout value. I find that units
    of measure are invaluable to distiguish seconds from milliseconds. I once accidentally
    set a timeout to 2000 seconds rather than 2000 milliseconds and I don't want to
    make that mistake again!
  prefs: []
  type: TYPE_NORMAL
- en: The next bit of code defines our domain types. We want to be able to keep the
    url and the size together as we process them. We could use a tuple, but I am a
    proponent of [using types to model your domain](designing-with-types-single-case-dus.html),
    if only for documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Yes, this might be overkill for a trivial example like this, but in a more serious
    project I think it is very much worth doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the code that does the downloading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Notes:'
  prefs: []
  type: TYPE_NORMAL
- en: The .NET library will throw on various errors, so I am catching that and turning
    it into a `Failure`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `use client =` section ensures that the client will be correctly disposed
    at the end of the block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The whole operation is wrapped in an `async` workflow, and the `let! html =
    client.AsyncDownloadString` is where the download happens asynchronously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I've added some `printfn`s for tracing, just for this example. In real code,
    I wouldn't do this of course!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before moving on, let''s test this code interactively. First we need a helper
    to print the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we can try it out on a good site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'and a bad one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Extending the Async type with `map` and `apply` and `bind`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, we know that we are going to be dealing with the world of `Async`,
    so before we go any further, let''s make sure that we have our four core functions
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'These implementations are straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: I'm using the `async` workflow to work with `Async` values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `let!` syntax in `map` extracts the content from the `Async` (meaning run
    it and await the result).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `return` syntax in `map`, `retn`, and `apply` lifts the value to an `Async`
    using `return`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `apply` function runs the two parameters in parallel using a fork/join pattern.
    If I had instead written `let! fChild = ...` followed by a `let! xChild = ...`
    that would have been monadic and sequential, which is not what I wanted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `return!` syntax in `bind` means that the value is already lifted and *not*
    to call `return` on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the size of the downloaded page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Getting back on track, we can continue from the downloading step and move on
    to the process of converting the result to a `UriContentSize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: If the input html is null or empty we'll treat this an error, otherwise we'll
    return a `UriContentSize`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have two functions and we want to combine them into one "get UriContentSize
    given a Uri" function. The problem is that the outputs and inputs don''t match:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getUriContent` is `Uri -> Async<Result<UriContent>>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`makeContentSize` is `UriContent -> Result<UriContentSize>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The answer is to transform `makeContentSize` from a function that takes a `UriContent`
    as input into a function that takes a `Async<Result<UriContent>>` as input. How
    can we do that?
  prefs: []
  type: TYPE_NORMAL
- en: First, use `Result.bind` to convert it from an `a -> Result<b>` function to
    a `Result<a> -> Result<b>` function. In this case, `UriContent -> Result<UriContentSize>`
    becomes `Result<UriContent> -> Result<UriContentSize>`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, use `Async.map` to convert it from an `a -> b` function to a `Async<a>
    -> Async<b>` function. In this case, `Result<UriContent> -> Result<UriContentSize>`
    becomes `Async<Result<UriContent>> -> Async<Result<UriContentSize>>`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_urlcontentsize.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And now that it has the right kind of input, so we can compose it with `getUriContent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: That's some gnarly type signature, and it's only going to get worse! It's at
    times like these that I really appreciate type inference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test again. First a helper to format the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we can try it out on a good site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'and a bad one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Getting the largest size from a list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last step in the process is to find the largest page size.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s easy. Once we have a list of `UriContentSize`, we can easily find the
    largest one using `List.maxBy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Putting it all together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''re ready to assemble all the pieces now, using the following algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with a list of urls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn the list of strings into a list of uris (`Uri list`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn the list of `Uri`s into a list of actions (`Async<Result<UriContentSize>>
    list`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next we need to swap the top two parts of the stack. That is, transform a `List<Async>`
    into a `Async<List>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](vgfp_download_stack_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Next we need to swap the *bottom* two parts of the stack -- transform a `List<Result>`
    into a `Result<List>`. But the two bottom parts of the stack are wrapped in an
    `Async` so we need to use `Async.map` to do this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](vgfp_download_stack_2.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally we need to use `List.maxBy` on the bottom `List` to convert it into
    a single value. That is, transform a `List<UriContentSize>` into a `UriContentSize`.
    But the bottom of the stack is wrapped in a `Result` wrapped in an `Async` so
    we need to use `Async.map` and `Result.map` to do this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](vgfp_download_stack_3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This function has signature `string list -> Async<Result<UriContentSize>>`,
    which is just what we wanted!
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two `sequence` functions involved here: `sequenceAsyncA` and `sequenceResultA`.
    The implementations are as you would expect from all the previous discussion,
    but I''ll show the code anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Adding a timer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It will be interesting to see how long the download takes for different scenarios,
    so let''s create a little timer that runs a function a certain number of times
    and takes the average:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Ready to download at last
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's download some sites for real!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll define two lists of sites: a "good" one, where all the sites should
    be accessible, and a "bad" one, containing invalid sites.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by running `largestPageSizeA` 10 times with the good sites list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: We can see immediately that the downloads are happening in parallel -- they
    have all started before the first one has finished.
  prefs: []
  type: TYPE_NORMAL
- en: Now what about if some of the sites are bad?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Again, all the downloads are happening in parallel, and all four failures are
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `largestPageSizeA` has a series of maps and sequences in it which means
    that the list is being iterated over three times and the async mapped over twice.
  prefs: []
  type: TYPE_NORMAL
- en: As [I said earlier](elevated-world-4.html#readability), I prefer clarity over
    micro-optimizations unless there is proof otherwise, and so this does not bother
    me.
  prefs: []
  type: TYPE_NORMAL
- en: However, let's look at what you *could* do if you wanted to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the original version, with comments removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two `List.map`s could be combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The `map-sequence` can be replaced with a `traverse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'and finally the two `Async.map`s can be combined too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Personally, I think we've gone too far here. I prefer the original version to
    this one!
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, one way to get the best of both worlds is to use a "streams" library
    that automatically merges the maps for you. In F#, a good one is [Nessos Streams](https://nessos.github.io/Streams/).
    Here is [a blog post showing the difference](http://trelford.com/blog/post/SeqVsStream.aspx)
    between streams and the standard `seq`.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the monadic way
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's reimplement the downloading logic using monadic style and see what difference
    it makes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need a monadic version of the downloader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: This one uses the monadic `sequence` functions (I won't show them -- the implementation
    is as you expect).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run `largestPageSizeM` 10 times with the good sites list and see if
    there is any difference from the applicative version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: There is a big difference now -- it is obvious that the downloads are happening
    in series -- each one starts only when the previous one has finished.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the average time is 955ms per run, almost twice that of the applicative
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Now what about if some of the sites are bad? What should we expect? Well, because
    it's monadic, we should expect that after the first error, the remaining sites
    are skipped, right? Let's see if that happens!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Well that was unexpected! All of the sites were visited in series, even though
    the first one had an error. But in that case, why is only the *first* error returned,
    rather than *all* the the errors?
  prefs: []
  type: TYPE_NORMAL
- en: Can you see what went wrong?
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason why the implementation did not work as expected is that the chaining
    of the `Async`s was independent of the chaining of the `Result`s.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you step through this in a debugger you can see what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: The first `Async` in the list was run, resulting in a failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Async.bind` was used with the next `Async` in the list. But `Async.bind` has
    no concept of error, so the next `Async` was run, producing another failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this way, all the `Async`s were run, producing a list of failures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list of failures was then traversed using `Result.bind`. Of course, because
    of the bind, only the first one was processed and the rest ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final result was that all the `Async`s were run but only the first failure
    was returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Treating two worlds as one
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fundamental problem is that we are treating the `Async` list and `Result`
    list as *separate* things to be traversed over. But that means that a failed `Result`
    has no influence on whether the next `Async` is run.
  prefs: []
  type: TYPE_NORMAL
- en: What we want to do, then, is tie them together so that a bad result *does* determine
    whether the next `Async` is run.
  prefs: []
  type: TYPE_NORMAL
- en: And in order to do that, we need to treat the `Async` and the `Result` as a
    *single* type -- let's imaginatively call it `AsyncResult`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If they are a single type, then `bind` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_asyncresult-1.png)'
  prefs: []
  type: TYPE_IMG
- en: meaning that the previous value will determine the next value.
  prefs: []
  type: TYPE_NORMAL
- en: 'And also, the "swapping" becomes much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_asyncresult-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Defining the AsyncResult type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OK, let's define the `AsyncResult` type and it's associated `map`, `return`,
    `apply` and `bind` functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Notes:'
  prefs: []
  type: TYPE_NORMAL
- en: The type alias is optional. We can use `Async<Result<'a>>` directly in the code
    and it wil work fine. The point is that *conceptually* `AsyncResult` is a separate
    type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bind` implementation is new. The continuation function `f` is now crossing
    *two* worlds, and has the signature `'a -> Async<Result<'b>>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the inner `Result` is successful, the continuation function `f` is evaluated
    with the result. The `return!` syntax means that the return value is already lifted.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the inner `Result` is a failure, we have to lift the failure to an Async.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the traverse and sequence functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With `bind` and `return` in place, we can create the appropriate `traverse`
    and `sequence` functions for `AsyncResult`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Defining and testing the downloading functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, the `largestPageSize` function is simpler now, with only one sequence
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run `largestPageSizeM_AR` 10 times with the good sites list and see
    if there is any difference from the applicative version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Again, the downloads are happening in series. And again, the time per run is
    almost twice that of the applicative version.
  prefs: []
  type: TYPE_NORMAL
- en: And now the moment we've been waiting for! Will it skip the downloading after
    the first bad site?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Success! The error from the first bad site prevented the rest of the downloads,
    and the short run time is proof of that.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post, we worked through a small practical example. I hope that this
    example demonstrated that `map`, `apply`, `bind`, `traverse`, and `sequence` are
    not just academic abstractions but essential tools in your toolbelt.
  prefs: []
  type: TYPE_NORMAL
- en: In the [next post](elevated-world-6.html) we'll working through another practical
    example, but this time we will end up creating our *own* elevated world. See you
    then!
  prefs: []
  type: TYPE_NORMAL
- en: Reinventing the Reader monad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reinventing the Reader monad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This post is the sixth in a series. In the [first two posts](elevated-world.html),
    I described some of the core functions for dealing with generic data types: `map`,
    `bind`, and so on. In the [third post](elevated-world-3.html), I discussed "applicative"
    vs "monadic" style, and how to lift values and functions to be consistent with
    each other. In the [fourth](elevated-world-4.html) and [previous](elevated-world-5.html)
    posts, I introduced `traverse` and `sequence` as a way of working with lists of
    elevated values, and we saw this used in a practical example: downloading some
    URLs.'
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we'll finish up by working through another practical example,
    but this time we'll create our own "elevated world" as a way to deal with awkward
    code. We'll see that this approach is so common that it has a name -- the "Reader
    monad".
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a list of shortcuts to the various functions mentioned in this series:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Lifting to the elevated world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `map` function](elevated-world.html#map)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `return` function](elevated-world.html#return)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `apply` function](elevated-world.html#apply)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `liftN` family of functions](elevated-world.html#lift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `zip` function and ZipList world](elevated-world.html#zip)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: How to compose world-crossing functions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `bind` function](elevated-world-2.html#bind)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List is not a monad. Option is not a monad.](elevated-world-2.html#not-a-monad)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Using the core functions in practice**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Independent and dependent data](elevated-world-3.html#dependent)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Validation using applicative style and monadic style](elevated-world-3.html#validation)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lifting to a consistent world](elevated-world-3.html#consistent)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kleisli world](elevated-world-3.html#kleisli)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Mixing lists and elevated values**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mixing lists and elevated values](elevated-world-4.html#mixing)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `traverse`/`MapM` function](elevated-world-4.html#traverse)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `sequence` function](elevated-world-4.html#sequence)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '["Sequence" as a recipe for ad-hoc implementations](elevated-world-4.html#adhoc)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Readability vs. performance](elevated-world-4.html#readability)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dude, where''s my `filter`?](elevated-world-4.html#filter)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: A real-world example that uses all the techniques**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Downloading and processing a list of websites](elevated-world-5.html#asynclist)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Treating two worlds as one](elevated-world-5.html#asyncresult)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Designing your own elevated world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Designing your own elevated world](elevated-world-6.html#part6)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering out failures](elevated-world-6.html#filtering)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Reader monad](elevated-world-6.html#readermonad)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 7: Summary**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List of operators mentioned](elevated-world-7.html#operators)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Further reading](elevated-world-7.html#further-reading)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 6: Designing your own elevated world'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The scenario we''ll be working with in this post is just this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A customer comes to your site and wants to view information about the products
    they have purchased.*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll assume that you have a API for a key/value store (such
    as Redis or a NoSql database), and all the information you need is stored there.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the code we need will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: How hard can that be?
  prefs: []
  type: TYPE_NORMAL
- en: Well, it turns out to be surprisingly tricky! Luckily, we can find a way to
    make it easier using the concepts in this series.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the domain and a dummy ApiClient
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First let''s define the domain types:'
  prefs: []
  type: TYPE_NORMAL
- en: There will be a `CustomerId` and `ProductId` of course.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the product information, we'll just define a simple `ProductInfo` with a
    `ProductName` field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: For testing our api, let's create an `ApiClient` class with some `Get` and `Set`
    methods, backed by a static mutable dictionary. This is based on similar APIs
    such as the Redis client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Get` and `Set` both work with objects, so I've added a casting mechanism.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case of errors such as a failed cast, or a missing key, I'm using the `Result`
    type that we've been using throughout this series. Therefore, both `Get` and `Set`
    return `Result`s rather than plain objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make it more realistic, I've also added dummy methods for `Open`, `Close`
    and `Dispose`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All methods trace a log to the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do some tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'And the results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: A first implementation attempt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our first attempt at implementing the scenario, let''s start with the pseudo-code
    from above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: So far so good, but there is a bit of a problem already.
  prefs: []
  type: TYPE_NORMAL
- en: The `getPurchaseInfo` function takes a `CustId` as input, but it can't just
    output a list of `ProductInfo`s, because there might be a failure. That means
    that the return type needs to be `Result<ProductInfo list>`.
  prefs: []
  type: TYPE_NORMAL
- en: Ok, how do we create our `productInfosResult`?
  prefs: []
  type: TYPE_NORMAL
- en: Well that should be easy. If the `productIdsResult` is Success, then loop through
    each id and get the info for each id. If the `productIdsResult` is Failure, then
    just return that failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Hmmm. It's looking a bit ugly. And I'm having to use a mutable data structure
    (`productInfos`) to accumulate each product info and then wrap it in `Success`.
  prefs: []
  type: TYPE_NORMAL
- en: And there's a worse problem The `productInfo` that I'm getting from `api.Get<ProductInfo>`
    is not a `ProductInfo` at all, but a `Result<ProductInfo>`, so `productInfos`
    is not the right type at all!
  prefs: []
  type: TYPE_NORMAL
- en: Let's add code to test each `ProductInfo` result. If it's a success, then add
    it to the list of product infos, and if it's a failure, then return the failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Um, no. That won't work at all. The code above will not compile. We can't do
    an "early return" in the loop when a failure happens.
  prefs: []
  type: TYPE_NORMAL
- en: So what do we have so far? Some really ugly code that won't even compile.
  prefs: []
  type: TYPE_NORMAL
- en: There has to be a better way.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: A second implementation attempt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It would be great if we could hide all this unwrapping and testing of `Result`s.
    And there is -- computation expressions to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we create a computation expression for `Result` we can write the code like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: In `let productInfosResult = Result.result { .. }` code we create a `result`
    computation expression that simplifies all the unwrapping (with `let!`) and wrapping
    (with `return`).
  prefs: []
  type: TYPE_NORMAL
- en: And so this implementation has no explicit `xxxResult` values anywhere. However,
    it still has to use a mutable collection class to do the accumulation, because
    the `for productId in productIds do` is not actually a real `for` loop, and we
    can't replace it with `List.map`, say.
  prefs: []
  type: TYPE_NORMAL
- en: The `result` computation expression.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Which brings us onto the implementation of the `result` computation expression.
    In the previous posts, `ResultBuilder` only had two methods, `Return` and `Bind`,
    but in order to get the `for..in..do` functionality, we have to implement a lot
    of other methods too, and it ends up being a bit more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: I have a series about the [internals of computation expressions](computation-expressions.html),
    so I don't want to explain all that code here. Instead, for the rest of the post
    we'll work on refactoring `getPurchaseInfo`, and by the end of it we'll see that
    we don't need the `result` computation expression at all.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The problem with the `getPurchaseInfo` function as it stands is that it mixes
    concerns: it both creates the `ApiClient` and does some work with it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There a number of problems with this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to do different work with the API, we have to repeat the open/close
    part of this code. And it's possible that one of the implementations might open
    the API but forget to close it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not testable with a mock API client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can solve both of these problems by separating the creation of an `ApiClient`
    from its use by parameterizing the action, like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The action function that is passed in would look like this, with a parameter
    for the `ApiClient` as well as for the `CustId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Note that `getPurchaseInfo` has *two* parameters, but `executeApiAction` expects
    a function with only one.
  prefs: []
  type: TYPE_NORMAL
- en: 'No problem! Just use partial application to bake in the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: That's why the `ApiClient` is the *second* parameter in the parameter list --
    so that we can do partial application.
  prefs: []
  type: TYPE_NORMAL
- en: More refactoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We might need to get the product ids for some other purpose, and also the productInfo,
    so let''s refactor those out into separate functions too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have these nice core functions `getPurchaseIds` and `getProductInfo`,
    but I'm annoyed that I have to write messy code to glue them together in `getPurchaseInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, what I''d like to do is pipe the output of `getPurchaseIds` into `getProductInfo`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Or as a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_pipe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But I can''t, and there are two reasons why:'
  prefs: []
  type: TYPE_NORMAL
- en: First, `getProductInfo` has *two* parameters. Not just a `ProductId` but also
    the `ApiClient`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, even if `ApiClient` wasn't there, the input of `getProductInfo` is a
    simple `ProductId` but the output of `getPurchaseIds` is a `Result`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wouldn't it be great if we could solve both of these problems!
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing our own elevated world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's address the first problem. How can we compose functions when the extra
    `ApiClient` parameter keeps getting in the way?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a typical API calling function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_action1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we look at the type signature we see this, a function with two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_action2.png)'
  prefs: []
  type: TYPE_IMG
- en: But *another* way to interpret this function is as a function with *one* parameter
    that returns another function. The returned function has an `ApiClient` parameter
    and returns the final ouput.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_action3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You might think of it like this: I have an input right now, but I won''t have
    an actual `ApiClient` until later, so let me use the input to create a api-consuming
    function that can I glue together in various ways right now, without needing a
    `ApiClient` at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's give this api-consuming function a name. Let's call it `ApiAction`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_action4.png)'
  prefs: []
  type: TYPE_IMG
- en: In fact, let's do more than that -- let's make it a type!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, as it stands, this is just a type alias for a function, not a
    separate type. We need to wrap it in a [single case union](designing-with-types-single-case-dus.html)
    to make it a distinct type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Rewriting to use ApiAction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have a real type to use, we can rewrite our core domain functions
    to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First `getPurchaseIds`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature is now `CustId -> ApiAction<Result<ProductId list>>`, which you
    can interpret as meaning: "give me a CustId and I will give a you a ApiAction
    that, when given an api, will make a list of ProductIds".'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, `getProductInfo` can be rewritten to return an `ApiAction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice those signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CustId -> ApiAction<Result<ProductId list>>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductId -> ApiAction<Result<ProductInfo>>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is starting to look awfully familiar. Didn't we see something just like
    this in the previous post, with `Async<Result<_>>`?
  prefs: []
  type: TYPE_NORMAL
- en: ApiAction as an elevated world
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we draw diagrams of the various types involved in these two functions, we
    can clearly see that `ApiAction` is an elevated world, just like `List` and `Result`.
    And that means that we should be able to use the *same* techniques as we have
    used before: `map`, `bind`, `traverse`, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s `getPurchaseIds` as a stack diagram. The input is a `CustId` and the
    output is an `ApiAction<Result<List<ProductId>>>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_getpurchaseids.png)'
  prefs: []
  type: TYPE_IMG
- en: 'and with `getProductInfo` the input is a `ProductId` and the output is an `ApiAction<Result<ProductInfo>>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_getproductinfo.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The combined function that we want, `getPurchaseInfo`, should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_getpurchaseinfo.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And now the problem in composing the two functions is very clear: the output
    of `getPurchaseIds` can not be used as the input for `getProductInfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_noncompose.png)'
  prefs: []
  type: TYPE_IMG
- en: But I think that you can see that we have some hope! There should be some way
    of manipulating these layers so that they *do* match up, and then we can compose
    them easily.
  prefs: []
  type: TYPE_NORMAL
- en: So that's what we will work on next.
  prefs: []
  type: TYPE_NORMAL
- en: Introducting ApiActionResult
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last post we merged `Async` and `Result` into the compound type `AsyncResult`.
    We can do the same here, and create the type `ApiActionResult`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we make this change, our two functions become slightly simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_apiactionresult_functions.png)'
  prefs: []
  type: TYPE_IMG
- en: Enough diagrams -- let's write some code now.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define `map`, `apply`, `return` and `bind` for `ApiAction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Note that all the functions use a helper function called `run` which unwraps
    an `ApiAction` to get the function inside, and applies this to the `api` that
    is also passed in. The result is the value wrapped in the `ApiAction`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we had an `ApiAction<int>` then `run api myAction` would result
    in an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: And at the bottom, there is a `execute` function that creates an `ApiClient`,
    opens the connection, runs the action, and then closes the connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'And with the core functions for `ApiAction` defined, we can go ahead and define
    the functions for the compound type `ApiActionResult`, just as we did for `AsyncResult`
    in the [previous post](elevated-world-5.html#asyncresult):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Working out the transforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have all the tools in place, we must decide on what transforms to
    use to change the shape of `getProductInfo` so that the input matches up.
  prefs: []
  type: TYPE_NORMAL
- en: Should we choose `map`, or `bind`, or `traverse`?
  prefs: []
  type: TYPE_NORMAL
- en: Let's play around with the stacks visually and see what happens for each kind
    of transform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get started, let''s be explicit about what we are trying to achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: We have two functions `getPurchaseIds` and `getProductInfo` that we want to
    combine into a single function `getPurchaseInfo`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to manipulate the *left* side (the input) of `getProductInfo` so that
    it matches the output of `getPurchaseIds`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to manipulate the *right* side (the output) of `getProductInfo` so that
    it matches the output of our ideal `getPurchaseInfo`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](vgfp_api_wanted.png)'
  prefs: []
  type: TYPE_IMG
- en: Map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a reminder, `map` adds a new stack on both sides. So if we start with a
    generic world-crossing function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_generic.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, after `List.map` say, we will have a new `List` stack on each site.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_map_generic.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s our `getProductInfo` before transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_getproductinfo2.png)'
  prefs: []
  type: TYPE_IMG
- en: And here is what it would look like after using `List.map`
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_map_getproductinfo.png)'
  prefs: []
  type: TYPE_IMG
- en: This might seem promising -- we have a `List` of `ProductId` as input now, and
    if we can stack a `ApiActionResult` on top we would match the output of `getPurchaseId`.
  prefs: []
  type: TYPE_NORMAL
- en: But the output is all wrong. We want the `ApiActionResult` to stay on the top.
    That is, we don't want a `List` of `ApiActionResult` but a `ApiActionResult` of
    `List`.
  prefs: []
  type: TYPE_NORMAL
- en: Bind
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ok, what about `bind`?
  prefs: []
  type: TYPE_NORMAL
- en: If you recall, `bind` turns a "diagonal" function into a horizontal function
    by adding a new stack on the *left* sides. So for example, whatever the top elevated
    world is on the right, that will be added to the left.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_generic.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](vgfp_api_bind_generic.png)'
  prefs: []
  type: TYPE_IMG
- en: And here is what our `getProductInfo` would look like after using `ApiActionResult.bind`
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_bind_getproductinfo.png)'
  prefs: []
  type: TYPE_IMG
- en: This is no good to us. We need to have a `List` of `ProductId` as input.
  prefs: []
  type: TYPE_NORMAL
- en: Traverse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, let's try `traverse`.
  prefs: []
  type: TYPE_NORMAL
- en: '`traverse` turns a diagonal function of values into diagonal function with
    lists wrapping the values. That is, `List` is added as the top stack on the left
    hand side, and the second-from-top stack on the right hand side.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_generic.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](vgfp_api_traverse_generic.png)'
  prefs: []
  type: TYPE_IMG
- en: if we try that out on `getProductInfo` we get something very promising.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_traverse_getproductinfo.png)'
  prefs: []
  type: TYPE_IMG
- en: The input is a list as needed. And the output is perfect. We wanted a `ApiAction<Result<List<ProductInfo>>>`
    and we now have it.
  prefs: []
  type: TYPE_NORMAL
- en: So all we need to do now is add an `ApiActionResult` to the left side.
  prefs: []
  type: TYPE_NORMAL
- en: Well, we just saw this! It's `bind`. So if we do that as well, we are finished.
  prefs: []
  type: TYPE_NORMAL
- en: '![](vgfp_api_complete_getproductinfo.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And here it is expressed as code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Or to make it a bit less ugly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compare that with the earlier version of `getPurchaseInfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compare the two versions in a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Earlier verson | Latest function |'
  prefs: []
  type: TYPE_TB
- en: '| Composite function is non-trivial and needs special code to glue the two
    smaller functions together | Composite function is just piping and composition
    |'
  prefs: []
  type: TYPE_TB
- en: '| Uses the "result" computation expression | No special syntax needed |'
  prefs: []
  type: TYPE_TB
- en: '| Has special code to loop through the results | Uses "traverse" |'
  prefs: []
  type: TYPE_TB
- en: '| Uses a intermediate (and mutable) List object to accumulate the list of product
    infos | No intermediate values needed. Just a data pipeline. |'
  prefs: []
  type: TYPE_TB
- en: Implementing traverse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code above uses `traverse`, but we haven't implemented it yet. As I noted
    earlier, it can be implemented mechanically, following a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Testing the implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's test it!
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need a helper function to show results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to load the API with some test data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Customer C1 has purchased two products: P1 and P2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Customer C2 has purchased two products: PX and P2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Products P1 and P2 have some info.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product PX does *not* have any info.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see how this works out for different customer ids.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with Customer C1\. For this customer we expect both product infos
    to be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'And here are the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: What happens if we use a missing customer, such as CX?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we get a nice "key not found" failure, and the rest of the operations
    are skipped as soon as the key is not found.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: What about if one of the purchased products has no info? For example, customer
    C2 purchased PX and P2, but there is no info for PX.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: The overall result is a failure. Any bad product causes the whole operation
    to fail.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: But note that the data for product P2 is fetched even though product PX failed.
    Why? Because we are using the applicative version of `traverse`, so every element
    of the list is fetched "in parallel".
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to only fetch P2 once we knew that PX existed, then we should be
    using monadic style instead. We already seen how to write a monadic version of
    `traverse`, so I leave that as an exercise for you!
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering out failures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the implementation above, the `getPurchaseInfo` function failed if *any*
    product failed to be found. Harsh!
  prefs: []
  type: TYPE_NORMAL
- en: A real application would probably be more forgiving. Probably what should happen
    is that the failed products are logged, but all the successes are accumulated
    and returned.
  prefs: []
  type: TYPE_NORMAL
- en: How could we do this?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is simple -- we just need to modify the `traverse` function to skip
    failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a new helper function for `ApiActionResult`. It will
    allow us to pass in two functions, one for the success case and one for the error
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: This helper function helps us match both cases inside a `ApiAction` without
    doing complicated unwrapping. We will need this for our `traverse` that skips
    failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, note that `ApiActionResult.bind` can be defined in terms of `either`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define our "traverse with logging of failures" function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference between this and the previous implementation is this bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'This says that:'
  prefs: []
  type: TYPE_NORMAL
- en: If the new first element (`f head`) is a success, lift the inner value (`retn
    h`) and `cons` it with the tail to build a new list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But if the new first element is a failure, then log the inner errors (`errs`)
    with the passed in logging function (`log`) and just reuse the current tail. In
    this way, failed elements are not added to the list, but neither do they cause
    the whole function to fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a new function `getPurchasesInfoWithLog` and try it with customer
    C2 and the missing product PX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: The result is a Success now, but only one `ProductInfo`, for P2, is returned.
    The log shows that PX was skipped.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The Reader monad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look closely at the `ApiResult` module, you will see that `map`, `bind`,
    and all the other functions do not use any information about the `api` that is
    passed around. We could have made it any type and those functions would still
    have worked.
  prefs: []
  type: TYPE_NORMAL
- en: So in the spirit of "parameterize all the things", why not make it a parameter?
  prefs: []
  type: TYPE_NORMAL
- en: 'That means that we could have defined `ApiAction` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: But if it can be *anything*, why call it `ApiAction` any more? It could represent
    any set of things that depend on an object (such as an `api`) being passed in
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not the first people to discover this! This type is commonly called
    the `Reader` type and is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: The extra type `'environment` plays the same role that `ApiClient` did in our
    definition of `ApiAction`. There is some environment that is passed around as
    an extra parameter to all your functions, just as a `api` instance was.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, we can actually define `ApiAction` in terms of `Reader` very easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: The set of functions for `Reader` are exactly the same as for `ApiAction`. I
    have just taken the code and replaced `ApiAction` with `Reader` and `api` with
    `environment`!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: The type signatures are a bit harder to read now though!
  prefs: []
  type: TYPE_NORMAL
- en: The `Reader` type, plus `bind` and `return`, plus the fact that `bind` and `return`
    implement the monad laws, means that `Reader` is typically called "the Reader
    monad" .
  prefs: []
  type: TYPE_NORMAL
- en: I'm not going to delve into the Reader monad here, but I hope that you can see
    how it is actually a useful thing and not some bizarre ivory tower concept.
  prefs: []
  type: TYPE_NORMAL
- en: The Reader monad vs. an explicit type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now if you like, you could replace all the `ApiAction` code above with `Reader`
    code, and it would work just the same. But *should* you?
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I think that while understanding the concept behind the Reader monad
    is important and useful, I prefer the actual implementation of `ApiAction` as
    I defined it originally, an explicit type rather than an alias for `Reader<ApiClient,'a>`.
  prefs: []
  type: TYPE_NORMAL
- en: Why? Well, F# doesn't have typeclasses, F# doesn't have partial application
    of type constructors, F# doesn't have "newtype". Basically, F# isn't Haskell!
    I don't think that idioms that work well in Haskell should be carried over to
    F# directly when the language does not offer support for it.
  prefs: []
  type: TYPE_NORMAL
- en: If you understand the concepts, you can implement all the necessary transformations
    in a few lines of code. Yes, it's a little extra work, but the upside is less
    abstraction and fewer dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: I would make an exception, perhaps, if your team were all Haskell experts, and
    the Reader monad was familiar to everyone. But for teams of different abilities,
    I would err on being too concrete rather than too abstract.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post, we worked through another practical example, created our own elevated
    world which made things *much* easier, and in the process, accidentally re-invented
    the reader monad.
  prefs: []
  type: TYPE_NORMAL
- en: If you liked this, you can see a similar practical example, this time for the
    State monad, in my series on ["Dr Frankenfunctor and the Monadster"](monadster.html).
  prefs: []
  type: TYPE_NORMAL
- en: The [next and final post](elevated-world-7.html) has a quick summary of the
    series, and some further reading.
  prefs: []
  type: TYPE_NORMAL
- en: Map and Bind and Apply, a summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Map and Bind and Apply, a summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Series summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, [this series](map-and-bind-and-apply-oh-my.html) turned out to be longer
    than I originally planned. Thanks for making it to the end!
  prefs: []
  type: TYPE_NORMAL
- en: I hope that this discussion has been helpful in understanding the various function
    transformations like `map` and `bind`, and given you some useful techniques for
    dealing with world-crossing functions -- maybe even demystified the m-word a bit!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to start using these kinds of functions in your own code, I hope
    that you can see how easy they are to write, but you should also consider using
    one of the excellent F# utility libraries that contain these and much more:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ExtCore** ([source](https://github.com/jack-pappas/ExtCore), [NuGet](https://www.nuget.org/packages/ExtCore/)).
    ExtCore provides extensions to the F# core library (FSharp.Core) and aims to help
    you build industrial-strength F# applications. These extensions include additional
    functions for modules such as Array, List, Set, and Map; immutable IntSet, IntMap,
    LazyList, and Queue collections; a variety of computation expressions (workflows);
    and "workflow collections" -- collections modules which have been adapted to work
    seamlessly from within workflows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FSharpx.Extras** ([home page](https://fsprojects.github.io/FSharpx.Extras/)).
    FSharpx.Extras is part of the FSharpx series of libraries. It implements several
    standard monads (State, Reader, Writer, Either, Continuation, Distribution), validation
    with applicative functors, general functions like flip, and some asynchronous
    programming utilities, and functions to make C# - F# interop easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, the monadic traverse `List.traverseResultM` that I implemented
    [in this post](elevated-world-4.html#traverse) is already available in ExtCore
    [here](https://github.com/jack-pappas/ExtCore/blob/4fc2302e74a9b5217d980e5ce2680f0b3db26c3d/ExtCore/ControlCollections.Choice.fs#L398).
  prefs: []
  type: TYPE_NORMAL
- en: And if you liked this series, I have posts explaining the State monad in my
    series on ["Dr Frankenfunctor and the Monadster"](monadster.html) and the Either
    monad in my talk ["Railway Oriented Programming"](http://fsharpforfunandprofit.com/rop/).
  prefs: []
  type: TYPE_NORMAL
- en: As I said at the very beginning, writing this up has been a learning process
    for me too. I am not an expert, so if I have made any errors please do let me
    know.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks!
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a list of shortcuts to the various functions mentioned in this series:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Lifting to the elevated world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `map` function](elevated-world.html#map)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `return` function](elevated-world.html#return)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `apply` function](elevated-world.html#apply)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `liftN` family of functions](elevated-world.html#lift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `zip` function and ZipList world](elevated-world.html#zip)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: How to compose world-crossing functions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `bind` function](elevated-world-2.html#bind)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List is not a monad. Option is not a monad.](elevated-world-2.html#not-a-monad)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Using the core functions in practice**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Independent and dependent data](elevated-world-3.html#dependent)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Validation using applicative style and monadic style](elevated-world-3.html#validation)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Lifting to a consistent world](elevated-world-3.html#consistent)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kleisli world](elevated-world-3.html#kleisli)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Mixing lists and elevated values**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mixing lists and elevated values](elevated-world-4.html#mixing)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `traverse`/`MapM` function](elevated-world-4.html#traverse)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The `sequence` function](elevated-world-4.html#sequence)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '["Sequence" as a recipe for ad-hoc implementations](elevated-world-4.html#adhoc)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Readability vs. performance](elevated-world-4.html#readability)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dude, where''s my `filter`?](elevated-world-4.html#filter)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: A real-world example that uses all the techniques**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Downloading and processing a list of websites](elevated-world-5.html#asynclist)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Treating two worlds as one](elevated-world-5.html#asyncresult)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Designing your own elevated world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Designing your own elevated world](elevated-world-6.html#part6)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Filtering out failures](elevated-world-6.html#filtering)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Reader monad](elevated-world-6.html#readermonad)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 7: Summary**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[List of operators mentioned](elevated-world-7.html#operators)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Further reading](elevated-world-7.html#further-reading)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix: List of operators mentioned'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike OO languages, functional programming languages are known for their [strange
    operators](http://en.cppreference.com/w/cpp/language/operator_precedence), so
    I thought it would be helpful to document the ones that have been used in this
    series, with links back to the relevant discussion.
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Equivalent function | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `>>` | Left-to-right composition | Not part of this series, but [discussed
    here](function-composition.html) |'
  prefs: []
  type: TYPE_TB
- en: '| `<<` | Right-to-left composition | As above |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;>` | Left-to-right piping | As above |'
  prefs: []
  type: TYPE_TB
- en: '| `<&#124;` | Right-to-left piping | As above |'
  prefs: []
  type: TYPE_TB
- en: '| `<!>` | `map` | [Discussed here](elevated-world.html#map) |'
  prefs: []
  type: TYPE_TB
- en: '| `<$>` | `map` | Haskell operator for map, but not a valid operator in F#,
    so I''m using `<!>` in this series. |'
  prefs: []
  type: TYPE_TB
- en: '| `<*>` | `apply` | [Discussed here](elevated-world.html#apply) |'
  prefs: []
  type: TYPE_TB
- en: '| `<*` | - | One sided combiner. [Discussed here](elevated-world.html#lift)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `*>` | - | One sided combiner. [Discussed here](elevated-world.html#lift)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `>>=` | Left-to-right `bind` | [Discussed here](elevated-world-2.html#bind)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `=<<` | Right-to-left `bind` | As above |'
  prefs: []
  type: TYPE_TB
- en: '| `>=>` | Left-to-right Kleisli composition | [Discussed here](elevated-world-3.html#kleisli)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<=<` | Right-to-left Kleisli composition | As above |'
  prefs: []
  type: TYPE_TB
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix: Further reading'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternative tutorials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[You Could Have Invented Monads! (And Maybe You Already Have)](http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Functors, Applicatives and Monads in pictures](http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kleisli composition ? la Up-Goer Five](http://mergeconflict.com/kleisli-composition-a-la-up-goer-five/).
    I think this one is funny.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Eric Lippert''s series on monads in C#](http://ericlippert.com/category/monads/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the academically minded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Monads for Functional Programming](http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf)
    (PDF), by Philip Wadler. One of the first monad papers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Applicative Programming with Effects](http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf)
    (PDF), by Conor McBride and Ross Paterson.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Essence of the Iterator Pattern](http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf)
    (PDF), by Jeremy Gibbons and Bruno Oliveira.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F# examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[F# ExtCore](https://github.com/jack-pappas/ExtCore) and [FSharpx.Extras](https://github.com/fsprojects/FSharpx.Extras/blob/master/src/FSharpx.Extras/ComputationExpressions/Monad.fs)
    have lots of useful code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FSharpx.Async](https://github.com/fsprojects/FSharpx.Async/blob/master/src/FSharpx.Async/Async.fs)
    has `map`, `apply`, `liftN` (called "Parallel"), `bind`, and other useful extensions
    for `Async`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Applicatives are very well suited for parsing, as explained in these posts:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parsing with applicative functors in F#](http://bugsquash.blogspot.co.uk/2011/01/parsing-with-applicative-functors-in-f.html).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dive into parser combinators: parsing search queries with F# and FParsec in
    Kiln](http://blog.fogcreek.com/fparsec/).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
