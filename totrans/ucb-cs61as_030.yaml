- en: The Substitution Model for Procedure Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying Compound Procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far we have seen how Racket breaks down and evaluates expressions such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 1 2)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 3 4 (* 2 5))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the procedure
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Evaluate the arguments
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the procedure to the arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have been slightly handwavy with step 3\. How exactly do you ''apply'' procedures?
    For primitive functions like `+`, `-` , `quote`, `or`, `and`, `not`, we can assume
    that it is built into the interpreter . We are more interested in something more
    complex: how do we apply compound (i.e. user defined) procedures? Since we can
    define arbitarily many compound procedures, they can''t all be built into the
    interpreter. There needs to be a a common step-by-step way to apply compound procedures.
    One way to think about this is the Substitution Model, which we will explore in
    this subsection.'
  prefs: []
  type: TYPE_NORMAL
- en: Substitution Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To apply a compound procedure with the Substitution Model, you substitute each
    formal parameter in the body with the corresponding argument''s value and evaluate
    it normally. What does this actually mean? It''s easier to see through an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `sum-of-squares` procedure from the very first lab, which can
    be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How does the Substitution Model handle `(sum-of-squares 3 4)` ?
  prefs: []
  type: TYPE_NORMAL
- en: We have a formal parameter, x which is called with the [argument](https://edge.edx.org/courses/uc-berkeley/cs61as-1x/SICP/wiki/cs61as-1x/argument/)
    3 and another formal parameter y which is called with the argument 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We substitute every occurence of x and y in the body with 3 and 4 respectively
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The body then becomes `(+ (square 3) (square 4))`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the definition of square, this reduces to `(+ (* 3 3) (* 4 4)).`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Applying both multiplications gives `(+ 9 16)`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Applying addition gives the result of `25`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Step 1 and 2 are the most crucial part of the Substitution Model: finding what
    values are passed into the function, and substituting every occurence of a variable
    in the body with its corresponding value.'
  prefs: []
  type: TYPE_NORMAL
- en: Formal Parameters' Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might have noticed by now that the names of formal parameters are arbitary.
    For example all of the followings are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (square x) (* x x))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (square apple) (* apple apple))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (square magikarp) (* magikarp magikarp))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Substitution Model handles all three equivalently, though it is best to
    pick a name that is easy to understand (In this case, the first definition is
    ideal). The main point is to stay consistent within the body. The following for
    example, might cause an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (square x) (* apple apple))`'
  prefs: []
  type: TYPE_NORMAL
- en: '![cube-shaped apple](http://foundersgrp.files.wordpress.com/2011/01/apple-cube.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we use Substitution Model with `(square 4)` with the definition above,
    you can notice that things are not properly defined. The procedure `square` accepts
    an argument, x which in this case is 4\. What do we do in the body? We need to
    find the value of `apple` and do `(* apple apple)`. What is the value of `apple`?
    We don't know! We only know what `x` is!
  prefs: []
  type: TYPE_NORMAL
- en: Substitution Model & Racket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Does Racket actually use the Substitution Model to apply compound procedures?
    Not quite. We use the Substitution Model to help us think about procedure application.
    Racket does something slightly more complicated, which we will explore in Unit
    3 and 4\. Later on, we will find that the Substitution Model is not sufficient
    to explain some functions in Racket. This model will serve as a framework which
    we will build on.
  prefs: []
  type: TYPE_NORMAL
- en: Applicative Order vs Normal Order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our method of evaluation by evaluating operator, evaluating the operands and
    then applying the operator is just one possible rule of evaluation. The ordering
    we have been using is called "Applicative Order". An alternative method of evaluation
    would be to not evaluate the operand until the value is needed. This method is
    called "Normal Order". We can see the difference between these 2 from the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(square (+ 3 2))`'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the input to square is (`+ 3 2).`
  prefs: []
  type: TYPE_NORMAL
- en: 'Applicative Order:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(square (+ 3 2))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(square 5)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(* 5 5)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`25`'
  prefs: []
  type: TYPE_NORMAL
- en: In Applicative Order, you would evaluate the parameter `x`, before you go the
    body of square, which is `(* x x)`. When you evaluate `(+ 3 2)`, you get `5` and
    this is what you pass into square. So `x` is bound to `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normal Order:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(square (+ 3 2))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(* (+ 3 2) (+ 3 2))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(* 5 5)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`25`'
  prefs: []
  type: TYPE_NORMAL
- en: In Normal Order, you don't evaluate `(+ 3 2)` until you absolutely need to.
    So in this case, the `x` in `(square x)` is bound to `(+ 3 2)`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, in Normal Order, since you don't evaluate the `x`, which is `(+
    3 2)`, until it's needed, you need to evaluate it twice. On the other hand, in
    Applicative Order, since you evaluate the operand `x` before applying the procedure,
    you only evaluate `(+ 3 2)` once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In Applicative Order, how many times is (+ 1 1) evaluated?
  prefs: []
  type: TYPE_NORMAL
- en: <ans text="2" explanation="Try again!" u00026gtu0003bu0003c="" ans=""></ans>
  prefs: []
  type: TYPE_NORMAL
