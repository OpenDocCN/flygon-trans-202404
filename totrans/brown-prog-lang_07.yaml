- en: 7Introduction to Structured Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|     [7.1 Understanding the Kinds of Compound Data](#%28part._.Understanding_the_.Kinds_of_.Compound_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|       [7.1.1 A First Peek at Structured Data](#%28part._.A_.First_.Peek_at_.Structured_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|       [7.1.2 A First Peek at Conditional Data](#%28part._.A_.First_.Peek_at_.Conditional_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|     [7.2 Defining and Creating Structured and Conditional Data](#%28part._.Defining_and_.Creating_.Structured_and_.Conditional_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|       [7.2.1 Defining and Creating Structured Data](#%28part._struct-data-eg%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|       [7.2.2 Annotations for Structured Data](#%28part._.Annotations_for_.Structured_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|       [7.2.3 Defining and Creating Conditional Data](#%28part._.Defining_and_.Creating_.Conditional_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|     [7.3 Programming with Structured and Conditional Data](#%28part._.Programming_with_.Structured_and_.Conditional_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|       [7.3.1 Extracting Fields from Structured Data](#%28part._.Extracting_.Fields_from_.Structured_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|       [7.3.2 Telling Apart Variants of Conditional Data](#%28part._.Telling_.Apart_.Variants_of_.Conditional_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|       [7.3.3 Processing Fields of Variants](#%28part._.Processing_.Fields_of_.Variants%29)
    |'
  prefs: []
  type: TYPE_TB
- en: Earlier we had our first look at types. Until now, we have only seen the types
    that Pyret provides us, which is an interesting but nevertheless quite limited
    set. Most programs we write will contain many more kinds of data.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1Understanding the Kinds of Compound Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 7.1.1A First Peek at Structured Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are times when a datum has many attributes, or parts. We need to keep
    them all together, and sometimes take them apart. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An iTunes entry contains a bunch of information about a single song: not only
    its name but also its singer, its length, its genre, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/a5746e5632ffd80a93693329e9ccfc68.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Your GMail application contains a bunch of information about a single message:
    its sender, the subject line, the conversation it’s part of, the body, and quite
    a bit more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/a40118b4022356546ffdd3780b31dfb6.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In examples like this, we see the need for structured data: a single datum
    has structure, i.e., it actually consists of many pieces. The number of pieces
    is fixed, but may be of different kinds (some might be numbers, some strings,
    some images, and different types may be mixed together in that one datum). Some
    might even be other structured data: for instance, a date usually has at least
    three parts, the day, month, and year. The parts of a structured datum are called
    its fields.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.2A First Peek at Conditional Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Then there are times when we want to represent different kinds of data under
    a single, collective umbrella. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A traffic light can be in different states: red, yellow, or green.Yes, in some
    countries there are different or more colors and color-combinations. Collectively,
    they represent one thing: a new type called a traffic light state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A zoo consists of many kinds of animals. Collectively, they represent one thing:
    a new type called an animal. Some condition determines which particular kind of
    animal a zookeeper might be dealing with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A social network consists of different kinds of pages. Some pages represent
    individual humans, some places, some organizations, some might stand for activities,
    and so on. Collectively, they represent a new type: a social media page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A notification application may report many kinds of events. Some are for email
    messages (which have many fields, as we’ve discussed), some are for reminders
    (which might have a timestamp and a note), some for instant messages (similar
    to an email message, but without a subject), some might even be for the arrival
    of a package by physical mail (with a timestamp, shipper, tracking number, and
    delivery note). Collectively, these all represent a new type: a notification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We call these “conditional” data because they represent an “or”: a traffic
    light is red or green or yellow; a social medium’s page is for a person or location
    or organization; and so on. Sometimes we care exactly which kind of thing we’re
    looking at: a driver behaves differently on different colors, and a zookeeper
    feeds each animal differently. At other times, we might not care: if we’re just
    counting how many animals are in the zoo, or how many pages are on a social network,
    or how many unread notifications we have, their details don’t matter. Therefore,
    there are times when we ignore the conditional and treat the datum as a member
    of the collective, and other times when we do care about the conditional and do
    different things depending on the individual datum. We will make all this concrete
    as we start to write programs.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.2Defining and Creating Structured and Conditional Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have used the word “data” above, but that’s actually been a bit of a lie.
    As we said earlier [REF], data are how we represent information in the computer.
    What we’ve been discussing above is really different kinds of information, not
    exactly how they are represented. But to write programs, we must wrestle concretely
    with representations. That’s what we will do now, i.e., actually show data representations
    of all this information.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2.1Defining and Creating Structured Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with defining structured data, such as an iTunes song record. Here’s
    a simplified version of the information such an app might store:'
  prefs: []
  type: TYPE_NORMAL
- en: The song’s name, which is a String.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The song’s singer, which is also a String.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The song’s year, which is a Number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s now introduce the syntax by which we can teach this to Pyret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells Pyret to introduce a new type of data, in this case called ITunesSongWe
    follow a convention that types always begin with a capital letter.. The way we
    actually make one of these data is by calling song with three parameters; for
    instance:It’s worth noting that music managers that are capable of making distinctions
    between, say, Dance, Electronica, and Electronic/Dance, classify two of these
    three songs by a single genre: “World”.<structured-examples> ::='
  prefs: []
  type: TYPE_NORMAL
- en: '|   song("La Vie en Rose", "Édith Piaf", 1945) |'
  prefs: []
  type: TYPE_TB
- en: '|   song("Stressed Out", "twenty one pilots", 2015) |'
  prefs: []
  type: TYPE_TB
- en: '|   song("Waqt Ne Kiya Kya Haseen Sitam", "Geeta Dutt", 1959) |'
  prefs: []
  type: TYPE_TB
- en: 'Always follow a data definition with a few concrete instances of the data!
    This makes sure you actually do know how to make data of that form. Indeed, it’s
    not essential but a good habit to give names to the data we’ve defined, so that
    we can use them later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 7.2.2Annotations for Structured Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall that in [REF] we discussed annotating our functions. Well, we can annotate
    our data, too! In particular, we can annotate both the definition of data and
    their creation. For the former, consider this data definition, which makes the
    annotation information we’d recorded informally in text a formal part of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can annotate the variables bound to examples of the data. But
    what should we write here?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Recall that annotations takes names of types, and the new type we’ve created
    is called ITunesSong. Therefore, we should write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if we instead write this?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What error do we get? How about if instead we write these?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make sure you familiarize yourself with the error messages that you get.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 7.2.3Defining and Creating Conditional Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The data construct in Pyret also lets us create conditional data, with a slightly
    different syntax. For instance, say we want to define the colors of a traffic
    light:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Conventionally, the names of the options begin in lower-case, but if they have
    no additional structure, we often capitalize the initial to make them look different
    from ordinary variables: i.e., Red rather than red. Each | (pronounced “stick”)
    introduces another option. You would make instances of traffic light colors as'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A more interesting and common example is when each condition has some structure
    to it; for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In Texas, there ain’t nothin’ in the middle of the road except a yellow line
    and a dead armadillo. We can make examples of them as you would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We call the different conditions variants.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How would you annotate the three variable bindings?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notice that the distinction between boas and armadillos is lost in the annotation.
    When we get to refinements [REF] we can recapture this distinction if we really
    want it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When defining a conditional datum the first stick is actually optional, but
    adding it makes the variants line up nicely. This helps us realize that our first
    example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: is really just the same as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: i.e., a conditional type with just one condition, where that one condition is
    structured.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3Programming with Structured and Conditional Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we’ve learned how to create structured and conditional data, but not
    yet how to take them apart or write any expressions that involve them. As you
    might expect, we need to figure out how to
  prefs: []
  type: TYPE_NORMAL
- en: take apart the fields of a structured datum, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tell apart the variants of a conditional datum.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we’ll see, Pyret also gives us a convenient way to do both together.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3.1Extracting Fields from Structured Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s write a function that tells us how old a song is. First, let’s think about
    what the function consumes (an ITunesSong) and produces (a Number). This gives
    us a rough skeleton for the function:<song-age> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '|   fun song-age(s :: ITunesSong) -> Number: |'
  prefs: []
  type: TYPE_TB
- en: '|     [<song-age-body>](#%28elem._song-age-body%29) |'
  prefs: []
  type: TYPE_TB
- en: '|   end |'
  prefs: []
  type: TYPE_TB
- en: We know that the form of the body must be roughly:<song-age-body> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '|   2016 - <get the song year> |'
  prefs: []
  type: TYPE_TB
- en: We can get the song year by using Pyret’s field access, which is a . followed
    by a field’s name—<wbr>in this case, year—<wbr>following the variable that holds
    the structured datum. Thus, we get the year field of s (the parameter to song-age)
    with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'So the entire function body is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be good to also record some examples ([<structured-examples>](#%28elem._structured-examples%29)),
    giving us a comprehensive definition of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 7.3.2Telling Apart Variants of Conditional Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s see how we tell apart variants. For this, we have to introduce another
    new piece of Pyret syntax: cases. A cases expression has several branches: exactly
    as many as there are in the data definition. Each branch corresponds to one of
    the variants. Thus, if we wanted to compute advice for a driver based on a traffic
    light’s state, we might write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that cases is followed by the name of the conditionally-defined type in
    parentheses (here, TLColor), and then an expression that computes a value of that
    type (in this case, c is already bound to such a value). Each variant is followed
    by =>, and then an expression that computes an answer for that variant.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if you leave out the =>?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if you leave out a variant? Leave out the Red Variant, then try both advice(Yellow)
    and advice(Red).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 7.3.3Processing Fields of Variants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, the variants had no fields. But if the variant has fields,
    Pyret expects you to list names of variables for those fields, and will then automatically
    bind those variables—<wbr>so you don’t need to use the .-notation to get the field
    values.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this, assume we want to get the name of any animal:<animal-name>
    ::=
  prefs: []
  type: TYPE_NORMAL
- en: '|   fun animal-name(a :: Animal) -> String: |'
  prefs: []
  type: TYPE_TB
- en: '|     [<animal-name-body>](#%28elem._animal-name-body%29) |'
  prefs: []
  type: TYPE_TB
- en: '|   end |'
  prefs: []
  type: TYPE_TB
- en: Because an Animal is conditionally defined, we know that we are likely to want
    a cases to pull it apart; furthermore, we should give names to each of the fields:Note
    that the names of the variables do not have to match the names of fields. Conventionally,
    we give longer, descriptive names to the field definitions and short names to
    the corresponding variables.<animal-name-body> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '|   cases (Animal) a: |'
  prefs: []
  type: TYPE_TB
- en: '|     &#124; boa(n, l) => ... |'
  prefs: []
  type: TYPE_TB
- en: '|     &#124; armadillo(n, l) => ... |'
  prefs: []
  type: TYPE_TB
- en: '|   end |'
  prefs: []
  type: TYPE_TB
- en: 'In both cases, we want to return the field n, giving us the complete function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
