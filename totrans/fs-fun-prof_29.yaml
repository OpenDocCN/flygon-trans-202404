- en: An introduction to property-based testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An introduction to property-based testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This post is part of the [F# Advent Calendar in English 2014](https://sergeytihon.wordpress.com/2014/11/24/f-advent-calendar-in-english-2014/)
    project. Check out all the other great posts there! And special thanks to Sergey
    Tihon for organizing this.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*UPDATE: I did a talk on property-based testing based on these posts. [Slides
    and video here.](http://fsharpforfunandprofit.com/pbt/)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a discussion that I hope never to have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'But seriously, my imaginary co-worker''s complaint has some validity: **How
    many tests are enough?**'
  prefs: []
  type: TYPE_NORMAL
- en: So now imagine that rather than being a developer, you are a test engineer who
    is responsible for testing that the "add" function is implemented correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately for you, the implementation is being written by a burned-out,
    always lazy and often malicious programmer, who I will call *The Enterprise Developer
    From Hell*, or "EDFH". (The EDFH has a [cousin who you might have heard of](https://en.wikipedia.org/wiki/Bastard_Operator_From_Hell)).
  prefs: []
  type: TYPE_NORMAL
- en: You are practising test-driven-development, enterprise-style, which means that
    you write a test, and then the EDFH implements code that passes the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'So you start with a test like this (using vanilla NUnit style):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The EDFH then implements the `add` function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And your test passes!
  prefs: []
  type: TYPE_NORMAL
- en: When you complain to the EDFH, they say that they are doing TDD properly, and
    only [writing the minimal code that will make the test pass](http://www.typemock.com/test-driven-development-tdd/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Fair enough. So you write another test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The EDFH then changes the implementation of the `add` function to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When you again complain to the EDFH, they point out that this approach is actually
    a best practice. Apparently it's called ["The Transformation Priority Premise"](http://blog.8thlight.com/uncle-bob/2013/05/27/TheTransformationPriorityPremise.html).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you start thinking that the EDFH is being malicious, and that
    this back-and-forth could go on forever!
  prefs: []
  type: TYPE_NORMAL
- en: Beating the malicious programmer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So the question is, what kind of test could you write so that a malicious programmer
    could not create an incorrect implementation, even if they wanted to?
  prefs: []
  type: TYPE_NORMAL
- en: Well, you could start with a much larger list of known results, and mix them
    up a bit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: But the EDFH is tireless, and will update the implementation to include all
    of these cases as well.
  prefs: []
  type: TYPE_NORMAL
- en: A much better approach is to generate random numbers and use those for inputs,
    so that a malicious programmer could not possibly know what to do in advance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If the test looks like this, then the EDFH will be *forced* to implement the
    `add` function correctly!
  prefs: []
  type: TYPE_NORMAL
- en: One final improvement -- the EDFH might just get lucky and have picked numbers
    that work by chance, so let's repeat the random number test a number of times,
    say 100 times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So now we're done!
  prefs: []
  type: TYPE_NORMAL
- en: Or are we?
  prefs: []
  type: TYPE_NORMAL
- en: Property based testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's just one problem. In order to test the `add` function, you're making
    use of the `+` function. In other words, you are using one implementation to test
    another.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases that is acceptable (see the use of "test oracles" in a following
    post), but in general, it's a bad idea to have your tests duplicate the code that
    you are testing! It's a waste of time and effort, and now you have two implementations
    to build and keep up to date.
  prefs: []
  type: TYPE_NORMAL
- en: So if you can't test by using `+`, how *can* you test?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is to create tests that focus on the *properties* of the function
    -- the "requirements". These properties should be things that are true for *any*
    correct implementation.
  prefs: []
  type: TYPE_NORMAL
- en: So let's think about what the properties of an `add` function are.
  prefs: []
  type: TYPE_NORMAL
- en: One way of getting started is to think about how `add` differs from other similar
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: So for example, what is the difference between `add` and `subtract`? Well, for
    `subtract`, the order of the parameters makes a difference, while for `add` it
    doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: So there's a good property to start with. It doesn't depend on addition itself,
    but it does eliminate a whole class of incorrect implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That's a good start, but it doesn't stop the EDFH. The EDFH could still implement
    `add` using `x * y` and this test would pass!
  prefs: []
  type: TYPE_NORMAL
- en: So now what about the difference between `add` and `multiply`? What does addition
    really mean?
  prefs: []
  type: TYPE_NORMAL
- en: 'We could start by testing with something like this, which says that `x + x`
    should the same as `x * 2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: But now we are assuming the existence of multiplication! Can we define a property
    that *only* depends on `add` itself?
  prefs: []
  type: TYPE_NORMAL
- en: One very useful approach is to see what happens when the function is repeated
    more than once. That is, what if you `add` and then `add` to the result of that?
  prefs: []
  type: TYPE_NORMAL
- en: 'That leads to the idea that two `add 1`s is the same as one `add 2`. Here''s
    the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That's great! `add` works perfectly with this test, while `multiply` doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: However, note that the EDFH could still implement `add` using `y - x` and this
    test would pass!
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we have the "parameter order" test above as well. So the combination
    of both of these tests should narrow it down so that there is only one correct
    implementation, surely?
  prefs: []
  type: TYPE_NORMAL
- en: 'After submitting this test suite we find out the EDFH has written an implementation
    that passes both these tests. Let''s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Aarrghh! What happened? Where did our approach go wrong?
  prefs: []
  type: TYPE_NORMAL
- en: Well, we forgot to force the implementation to actually use the random numbers
    we were generating!
  prefs: []
  type: TYPE_NORMAL
- en: So we need to ensure that the implementation does indeed *do* something with
    the parameters that are passed into it. We're going to have to check that the
    result is somehow connected to the input in a specific way.
  prefs: []
  type: TYPE_NORMAL
- en: Is there a trivial property of `add` that we know the answer to without reimplementing
    our own version?
  prefs: []
  type: TYPE_NORMAL
- en: Yes!
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you add zero to a number? You always get the same number back.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'So now we have a set of properties that can be used to test any implementation
    of `add`, and that force the EDFH to create a correct implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the common code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's quite a bit of duplicated code in these three tests. Let's do some refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll write a function called `propertyCheck` that does the work of generating
    100 pairs of random ints.
  prefs: []
  type: TYPE_NORMAL
- en: '`propertyCheck` will also need a parameter for the property itself. This will
    be a function that takes two ints and returns a bool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can redefine one of the tests by pulling out the property
    into a separate function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can also do the same thing for the other two properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the refactoring, the complete code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Reviewing what we have done so far
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have defined a set of properties that any implementation of `add` should
    satisfy:'
  prefs: []
  type: TYPE_NORMAL
- en: The parameter order doesn't matter ("commutativity" property)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing `add` twice with 1 is the same as doing `add` once with 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding zero does nothing ("identity" property)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's nice about these properties is that they work with *all* inputs, not
    just special magic numbers. But more importantly, they show us the core essence
    of addition.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, you can take this approach to the logical conclusion and actually *define*
    addition as anything that has these properties.
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly what mathematicians do. If you look up [addition on Wikipedia](https://en.wikipedia.org/wiki/Addition#Properties),
    you'll see that it is defined entirely in terms of commutativity, associativity,
    identity, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You'll note that in our experiment, we missed defining "associativity", but
    instead created a weaker property (`x+1+1 = x+2`). We'll see later that the EDFH
    can indeed write a malicious implementation that satisfies this property, and
    that associativity is better.
  prefs: []
  type: TYPE_NORMAL
- en: Alas, it's hard to get properties perfect on the first attempt, but even so,
    by using the three properties we came up with, we have got a much higher confidence
    that the implementation is correct, and in fact, we have learned something too
    -- we have understood the requirements in a deeper way.
  prefs: []
  type: TYPE_NORMAL
- en: Specification by properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A collection of properties like this can be considered a *specification*.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, unit tests, as well as being functional tests, have been [used
    as a sort of specification](https://en.wikipedia.org/wiki/Unit_testing#Documentation)
    as well. But an approach to specification using properties instead of tests with
    "magic" data is an alternative which I think is often shorter and less ambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking that only mathematical kinds of functions can be specified
    this way, but in future posts, we'll see how this approach can be used to test
    web services and databases too.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, not every business requirement can be expressed as properties like
    this, and we must not neglect the social component of software development. [Specification
    by example](https://en.wikipedia.org/wiki/Specification_by_example) and domain
    driven design can play a valuable role when working with non-technical customers.
  prefs: []
  type: TYPE_NORMAL
- en: You also might be thinking that designing all these properties is a lot of work
    -- and you'd be right! It is the hardest part. In a follow-up post, I'll present
    some tips for coming up with properties which might reduce the effort somewhat.
  prefs: []
  type: TYPE_NORMAL
- en: But even with the extra effort involved upfront (the technical term for this
    activity is called "thinking about the problem", by the way) the overall time
    saved by having automated tests and unambigous specifications will more than pay
    for the upfront cost later.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the arguments that are used to promote the benefits of unit testing
    can equally well be applied to property-based testing! So if a TDD fan tells you
    that they don't have the time to come up with property-based tests, then they
    might not be looking at the big picture.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing QuickCheck and FsCheck
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have implemented our own property checking system, but there are quite a
    few problems with it:'
  prefs: []
  type: TYPE_NORMAL
- en: It only works with integer functions. It would be nice if we could use the same
    approach for functions that had string parameters, or in fact any type of parameter,
    including ones we defined ourselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It only works with two parameter functions (and we had to ignore one of them
    for the `adding1TwiceIsAdding2OnceProperty` and `identity` properties). It would
    be nice if we could use the same approach for functions with any number of parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there is a counter-example to the property, we don't know what it is! Not
    very helpful when the tests fail!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's no logging of the random numbers that we generated, and there's no way
    to set the seed, which means that we can't debug and reproduce errors easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not configurable. For example, we can't easily change the number of loops
    from 100 to something else.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It would be nice if there was a framework that did all that for us!
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully there is! The ["QuickCheck"](https://en.wikipedia.org/wiki/QuickCheck)
    library was originally developed for Haskell by Koen Claessen and John Hughes,
    and has been ported to many other languages.
  prefs: []
  type: TYPE_NORMAL
- en: The version of QuickCheck used in F# (and C# too) is the excellent ["FsCheck"](https://fsharp.github.io/FsCheck/)
    library created by Kurt Schelfthout. Although based on the Haskell QuickCheck,
    it has some nice additional features, including integration with test frameworks
    such as NUnit and xUnit.
  prefs: []
  type: TYPE_NORMAL
- en: So let's look at how FsCheck would do the same thing as our homemade property-testing
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Using FsCheck to test the addition properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, you need to install FsCheck and load the DLL (FsCheck can be a bit finicky
    -- see the bottom of this page for instructions and troubleshooting).
  prefs: []
  type: TYPE_NORMAL
- en: 'The top of your script file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once FsCheck is loaded, you can use `Check.Quick` and pass in any "property"
    function. For now, let's just say that a "property" function is any function (with
    any parameters) that returns a boolean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check one of the properties interactively, say with `Check.Quick commutativeProperty`,
    you''ll see the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using FsCheck to find unsatified properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see what happens when we have a malicious implementation of `add`. In
    the code below, the EDFH implements `add` as multiplication!
  prefs: []
  type: TYPE_NORMAL
- en: That implementation *will* satisfy the commutative property, but what about
    the `adding1TwiceIsAdding2OnceProperty`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The result from FsCheck is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That means that using `1` as the input to `adding1TwiceIsAdding2OnceProperty`
    will result in `false`, which you can easily see that it does.
  prefs: []
  type: TYPE_NORMAL
- en: The return of the malicious EDFH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using random testing, we have made it harder for a malicious implementor.
    They will have to change tactics now!
  prefs: []
  type: TYPE_NORMAL
- en: 'The EDFH notes that we are still using some magic numbers in the `adding1TwiceIsAdding2OnceProperty`
    -- namely 1 and 2, and decides to create an implementation that exploits this.
    They''ll use a correct implementation for low input values and an incorrect implementation
    for high input values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Oh no! If we retest all our properties, they all pass now!
  prefs: []
  type: TYPE_NORMAL
- en: That'll teach us to use magic numbers in our tests!
  prefs: []
  type: TYPE_NORMAL
- en: What's the alternative? Well, let's steal from the mathematicians and create
    an associative property test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Aha! Now we get a falsification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That means that using `(8+2)+10` is not the same as `8+(2+10)`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that not only has FsCheck found some inputs that break the property, but
    it has found a lowest example. It knows that the inputs `8,2,9` pass but going
    one higher (`8,2,10`) fails. That's very nice!
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding FsCheck: Generators'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have used FsCheck for real, let's pause and have a look at how it
    works.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that FsCheck does is generate random inputs for you. This is
    called "generation", and for each type, there is an associated generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to generate a list of sample data, you use the generator along
    with two parameters: the number of elements in the list and a "size". The precise
    meaning of "size" depends on the type being generated and the context. Examples
    of things "size" is used for are: the maximum value of an int; the length of a
    list; the depth of a tree; etc.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s some code that generates ints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the ints are not generated uniformly, but clustered around
    zero. You can see this for yourself with a little code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can see that most of the values are in the center (0 is generated 181 times,
    1 is generated 104 times), and the outlying values are rare (10 is generated only
    3 times).
  prefs: []
  type: TYPE_NORMAL
- en: You can repeat with larger samples too. This one generates 10000 elements in
    the range [-30,30]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There are plenty of other generator functions available as well as `Gen.sample`
    (more documentation [here](https://fsharp.github.io/FsCheck/TestData.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding FsCheck: Generating all sorts of types automatically'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What's great about the generator logic is that it will automatically generate
    compound values as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a generator for a tuple of three ints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have a generator for a base type, `option` and `list` generators follow.
    Here is a generator for `int option`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is a generator for `int list`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: And of course you can generate random strings too!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The best thing is that the generator will work with your own user-defined types
    too!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here's one that generates a user-defined record type containing another user-defined
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There are ways to have more fine-grained control over how your types are generated,
    but that will have to wait for another post!
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding FsCheck: Shrinking'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating minimum counter-examples is one of the cool things about QuickCheck-style
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: How does it do this?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two parts to the process that FsCheck uses:'
  prefs: []
  type: TYPE_NORMAL
- en: First it generates a sequence of random inputs, starting small and getting bigger.
    This is the "generator" phase as described above.
  prefs: []
  type: TYPE_NORMAL
- en: If any inputs cause the property to fail, it starts "shrinking" the first parameter
    to find a smaller number. The exact process for shrinking varies depending on
    the type (and you can override it too), but let's say that for numbers, they get
    smaller in a sensible way.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say that you have a silly property `isSmallerThan80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You have generated random numbers and found that then property fails for `100`,
    and you want to try a smaller number. `Arb.shrink` will generate a sequence of
    ints, all of which are smaller than 100. Each one of these is tried with the property
    in turn until the property fails again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For each element in the list, test the property against it until you find another
    failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The property failed with `88`, so shrink again using that as a starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The property failed with `83` now, so shrink again using that as a starting
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The property failed with `81`, so shrink again using that as a starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: After this point, shrinking on 80 doesn't work -- no smaller value will be found.
  prefs: []
  type: TYPE_NORMAL
- en: In this case then, FsCheck will report that `80` falsifies the property and
    that 4 shrinks were needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with generators, FsCheck will generate shrink sequences for almost
    any type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: And, as with generators, there are ways to customize how shrinking works if
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring FsCheck: Changing the number of tests'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I mentioned a silly property `isSmallerThan80` -- let's see how FsCheck does
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Oh dear! FsCheck didn't find a counter-example!
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can try a few things. First, we can try increasing the number
    of tests.
  prefs: []
  type: TYPE_NORMAL
- en: We do this by changing the default ("Quick") configuration. There is a field
    called `MaxTest` that we can set. The default is 100, so let's increase it to
    1000.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, to use a specific config, you'll need to use `Check.One(config,property)`
    rather than just `Check.Quick(property)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops! FsCheck didn''t find a counter-example with 1000 tests either! Let''s
    try once more with 10000 tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Ok, so we finally got it to work. But why did it take so many tests?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer lies in some other configuration settings: `StartSize` and `EndSize`.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the generators start with small numbers and gradually increase
    them. This is controlled by the `StartSize` and `EndSize` settings. By default,
    `StartSize` is 1 and `EndSize` is 100\. So at the end of the test, the "size"
    parameter to the generator will be 100.
  prefs: []
  type: TYPE_NORMAL
- en: But, as we saw, even if the size is 100, very few numbers are generated at the
    extremes. In this case it means that numbers greater than 80 are unlikely to be
    generated.
  prefs: []
  type: TYPE_NORMAL
- en: So let's change the `EndSize` to something larger and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: That's more like it! Only 21 tests needed now rather than 8660 tests!
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring FsCheck: Verbose mode and logging'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I mentioned that one of the benefits of FsCheck over a home-grown solution is
    the logging and reproducibility, so let's have a look at that.
  prefs: []
  type: TYPE_NORMAL
- en: We'll tweak the malicious implementation to have a boundary of `25`. Let's see
    how FsCheck detects this boundary via logging.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Again, FsCheck has found that `25` is the exact boundary point quite quickly.
    But how did it do it?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the simplest way to see what FsCheck is doing is to use "verbose" mode.
    That is, use `Check.Verbose` rather than `Check.Quick`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When do this, you'll see an output like that shown below. I've added all the
    comments to explain the various elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This display takes up a lot of space! Can we make it more compact?
  prefs: []
  type: TYPE_NORMAL
- en: Yes -- you can control how each test and shrink is displayed by writing your
    own custom functions, and telling FsCheck to use them via its `Config` structure.
  prefs: []
  type: TYPE_NORMAL
- en: These functions are generic, and the list of parameters is represented by a
    list of unknown length (`obj list`). But since I know I am testing a three parameter
    property I can hard-code a three-element list parameter and print them all on
    one line.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration also has a slot called `Replay` which is normally `None`,
    which means that each run will be different.
  prefs: []
  type: TYPE_NORMAL
- en: If you set `Replay` to `Some seed`, then the test will be replayed exactly the
    same way. The seed looks like `StdGen (someInt,someInt)` and is printed on each
    run, so if you want to preserve a run all you need to do is paste that seed into
    the config.
  prefs: []
  type: TYPE_NORMAL
- en: And again, to use a specific config, you'll need to use `Check.One(config,property)`
    rather than just `Check.Quick(property)`.
  prefs: []
  type: TYPE_NORMAL
- en: Here's the code with the default tracing functions changed, and the replay seed
    set explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is now much more compact, and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: So there you go -- it's quite easy to customize the FsCheck logging if you need
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how the shrinking was done in detail. The last set of inputs (46,-4,50)
    was false, so shrinking started.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll loop through the list `[0; 23; 35; 41; 44; 45]` stopping at the first
    element that causes the property to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The first element that caused a failure was `x=35`, as part of the inputs `(35,
    -4, 50)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we start at 35 and shrink that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The first element that caused a failure was now `x=27`, as part of the inputs
    `(27, -4, 50)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we start at 27 and keep going:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: At this point, `x=25` is as low as you can go. None of its shrink sequence caused
    a failure. So we're finished with the `x` parameter!
  prefs: []
  type: TYPE_NORMAL
- en: Now we just repeat this process with the `y` parameter
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: At this point, `y=1` is as low as you can go. None of its shrink sequence caused
    a failure. So we're finished with the `y` parameter!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we repeat this process with the `z` parameter
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: And now we're finished with all the parameters!
  prefs: []
  type: TYPE_NORMAL
- en: The final counter-example after shrinking is `(25,1,26)`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding pre-conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say that we have a new idea for a property to check. We'll create a property
    called `addition is not multiplication` which will help to stop any malicious
    (or even accidental) mixup in the implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our first attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Bt when we run this test, we get a failure!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Well duh, obviously `0+0` and `0*0` are equal. But how can we tell FsCheck to
    ignore just those inputs and leave all the other ones alone?
  prefs: []
  type: TYPE_NORMAL
- en: This is done via a "condition" or filter expression that is prepended to the
    property function using `==>` (an operator defined by FsCheck).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The new property is `additionIsNotMultiplication_withPreCondition` and can be
    passed to `Check.Quick` just like any other property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops! We forgot another case! Let''s fix up our precondition again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: And now this works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This kind of precondition should only be used if you want to filter out a small
    number of cases.
  prefs: []
  type: TYPE_NORMAL
- en: If most of the inputs will be invalid, then this filtering will be expensive.
    In this case there is a better way to do it, which will be discussed in a future
    post.
  prefs: []
  type: TYPE_NORMAL
- en: The FsCheck documentation has more on how you can tweak properties [here](https://fsharp.github.io/FsCheck/Properties.html).
  prefs: []
  type: TYPE_NORMAL
- en: Naming convention for properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These properties functions have a different purpose from "normal" functions,
    so how should we name them?
  prefs: []
  type: TYPE_NORMAL
- en: In the Haskell and Erlang world, properties are given a `prop_` prefix by convention.
    In the .NET world, it is more common to use a suffix like `AbcProperty`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in F# we have namespaces, modules, and attributes (like `[<Test>]`) that
    we can use to organize properties and distinguish them from other functions.
  prefs: []
  type: TYPE_NORMAL
- en: Combining multiple properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have a set of properties, you can combine them into a group (or even,
    gasp, a *specification*!), by adding them as static members of a class type.
  prefs: []
  type: TYPE_NORMAL
- en: You can then do `Check.QuickAll` and pass in the name of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here are our three addition properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the corresponding static class to be used with `Check.QuickAll`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Combining property-based tests with example-based tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of this post, I was dismissive of tests that used "magic" numbers
    to test a very small part of the input space.
  prefs: []
  type: TYPE_NORMAL
- en: However, I do think that example-based tests have a role that complements property-based
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: An example-based test is often easier to understand because it is less abstract,
    and so provides a good entry point and documentation in conjuction with the properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Using FsCheck from NUnit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use FsCheck from NUnit and other test frameworks, with an extra plugin
    (e.g. `FsCheck.NUnit` for Nunit).
  prefs: []
  type: TYPE_NORMAL
- en: Rather than marking a test with `Test` or `Fact`, you use the `Property` attribute.
    And unlike normal tests, these tests can have parameters!
  prefs: []
  type: TYPE_NORMAL
- en: Here's an example of some tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can change the configuration for each test (such as `Verbose`
    and `EndSize`) via properties of the annotation.
  prefs: []
  type: TYPE_NORMAL
- en: And the `QuietOnSuccess` flag is available to make FsCheck compatible with standard
    test frameworks, which are silent on success and only show messages if something
    goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post I've introduced you to the basics of property-based checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s much more to cover though! In future posts I will cover topics such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[How to come up with properties that apply to your code](property-based-testing-2)**.
    The properties don''t have to be mathematical. We''ll look at more general properties
    such as inverses (for testing serialization/deserialization), idempotence (for
    safe handling of multiple updates or duplicate messages), and also look at test
    oracles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to create your own generators and shrinkers**. We''ve seen that FsCheck
    can generate random values nicely. But what about values with constraints such
    as positive numbers, or valid email addresses, or phone numbers. FsCheck gives
    you the tools to build your own.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to do model-based testing**, and in particular, how to test for concurrency
    issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I've also introduced the notion of an evil malicious programmer. You might think
    that such a malicious programmer is unrealistic and over-the-top.
  prefs: []
  type: TYPE_NORMAL
- en: But in many cases *you* act like an unintentionally malicious programmer. You
    happily create a implementation that works for some special cases, but doesn't
    work more generally, not out of evil intent, but out of unawareness and blindness.
  prefs: []
  type: TYPE_NORMAL
- en: Like fish unaware of water, we are often unaware of the assumptions we make.
    Property-based testing can force us to become aware of them.
  prefs: []
  type: TYPE_NORMAL
- en: Until next time -- happy testing!
  prefs: []
  type: TYPE_NORMAL
- en: '*The code samples used in this post are [available on GitHub](https://github.com/swlaschin/PropertyBasedTesting/blob/master/part1.fsx)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Want more? I have written [a follow up post on choosing properties for property-based
    testing](http://fsharpforfunandprofit.com/posts/property-based-testing-2/)**'
  prefs: []
  type: TYPE_NORMAL
- en: '*UPDATE: I did a talk on property-based testing based on these posts. [Slides
    and video here.](http://fsharpforfunandprofit.com/pbt/)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix: Installing and troubleshooting FsCheck'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to make FsCheck available to you is to create an F# project
    and add the NuGet package "FsCheck.NUnit". This will install both FsCheck and
    NUnit in the `packages` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a FSX script file for interactive development, you''ll need
    to load the DLLs from the appropriate package location, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, test that FsCheck is working correctly by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If you get no errors, then everything is good.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you *do* get errors, it''s probably because you are on an older version
    of Visual Studio. Upgrade to VS2013 or failing that, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First make sure you have the latest F# core installed ([currently 3.1](https://stackoverflow.com/questions/20332046/correct-version-of-fsharp-core)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure your that your `app.config` has the [appropriate binding redirects](http://blog.ploeh.dk/2014/01/30/how-to-use-fsharpcore-430-when-all-you-have-is-431/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that your NUnit assemblies are being referenced locally rather than
    from the GAC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These steps should ensure that compiled code works.
  prefs: []
  type: TYPE_NORMAL
- en: 'With F# interactive, it can be trickier. If you are not using VS2013, you might
    run into errors such as `System.InvalidCastException: Unable to cast object of
    type ''Arrow''`.'
  prefs: []
  type: TYPE_NORMAL
- en: The best cure for this is to upgrade to VS2013! Failing that, you can use an
    older version of FsCheck, such as 0.9.2 (which I have tested successfully with
    VS2012)
  prefs: []
  type: TYPE_NORMAL
