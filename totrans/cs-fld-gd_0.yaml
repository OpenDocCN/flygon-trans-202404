- en: perface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文出处：[http://csfieldguide.org.nz/](http://csfieldguide.org.nz/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The "Computer Science Field Guide" is an online interactive resource for high
    school students learning about computer science, developed at the University of
    Canterbury in New Zealand.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. INTRODUCTION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1.1\. WHAT’S THE BIG PICTURE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why is it that people have a love-hate relationship with computers? Why are
    some people so fanatical about particular types of computers, while others have
    been so angry at digital devices that they have been physically violent with them?
    And what does this have to do with computer science? And what is computer science
    anyway?
  prefs: []
  type: TYPE_NORMAL
- en: I’m glad you asked! Put simply, computer science is about tools and techniques
    for designing and building applications that are very fast, have great interfaces,
    are reliable, secure, helpful — even fun.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of people confuse computer science with programming. It has been said
    that “computer science is no more about programming than astronomy is about telescopes”
    ([Mike Fellows](http://en.wikiquote.org/wiki/Computer_science)). Programming is
    the tool that computer scientists use to bring great ideas to life, but just knowing
    how to give programmed instructions to a computer isn’t enough to create software
    that delights and empowers people.
  prefs: []
  type: TYPE_NORMAL
- en: For example, computers can perform billions of operations every second, and
    yet people often complain that they are too slow. Humans can perceive delays of
    about one tenth of a second, and if your program takes longer than that to respond
    it will be regarded as sluggish, jerky or frustrating. You’ve got well under a
    second to delight the user! If you are searching millions of items of data, or
    displaying millions of pixels (megapixels), you can’t afford to do things the
    wrong way, and you can’t just tell your users that they should buy a faster computer
    ... they’ll probably just go out and buy someone’s faster software instead!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s some advice from Fred Wilson, who has invested in many high profile
    tech companies:'
  prefs: []
  type: TYPE_NORMAL
- en: First and foremost, we believe that speed is more than a feature. Speed is the
    most important feature. If your application is slow, people won’t use it. I see
    this more with mainstream users than I do with power users. I think that power
    users sometimes have a bit of sympathetic eye to the challenges of building really
    fast web apps, and maybe they’re willing to live with it, but when I look at my
    wife and kids, they’re my mainstream view of the world. If something is slow,
    they’re just gone. ... speed is more than a feature. It’s a requirement.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —[Fred Wilson](http://en.wikipedia.org/wiki/Fred_Wilson_(financier)) ([Source](http://triple-networks.com/2011/12/06/10-golden-principles-of-successful-web-apps/))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A key theme in computer science is working out how to make things run fast,
    especially if you want to be able to sell your software to the large market of
    people using old-generation smartphones, or run it in a data centre where you
    pay by the minute for computing time. You can’t just tell your customers to buy
    a faster device — you need to deliver efficient software.
  prefs: []
  type: TYPE_NORMAL
- en: Try using the following two calculators to make a simple calculation. They both
    have the same functionality (they can do the same calculations), but which is
    nicer to use? Why?
  prefs: []
  type: TYPE_NORMAL
- en: (This book has many interactives like this. If the first calculator doesn’t
    work properly, you may need to use a more recent browser. The interactive material
    in this book works in most recent browsers; Google Chrome is a particularly safe
    bet.)
  prefs: []
  type: TYPE_NORMAL
- en: The second calculator above is slower, and that can be frustrating. But it has
    a fancier interface — buttons expand when you point to them to highlight what
    you’re doing. Does this make it easier to use? Did you have problems because the
    “C” and “=” keys are so close?
  prefs: []
  type: TYPE_NORMAL
- en: How interfaces work is a core part of computer science. The aesthetics — images
    and layout — are important, but what’s much more crucial is the psychology of
    how people interact. For example, suppose the “OK” and “Cancel” buttons in dialogue
    boxes were occasionally reversed. You would always need to check carefully before
    clicking on one of them, instead of using the instinctive moves you’ve made countless
    times before. There are some very simple principles based on how people think
    and behave that you can take advantage of to design systems that people love.
  prefs: []
  type: TYPE_NORMAL
- en: Making software that can scale up is another important theme. Imagine you’ve
    built a web interface and have attracted thousands of customers. Everything goes
    well until your site goes viral overnight, and you suddenly have millions of customers.
    If the system becomes bogged down, people will become frustrated waiting for a
    response, and tomorrow you will have no customers — they’ll all have moved on
    to someone else’s system. But if your programs are designed so they can scale
    up to work with such large amounts of data your main problem will be dealing with
    offers to buy your company!
  prefs: []
  type: TYPE_NORMAL
- en: Some of these problems can be solved by buying more equipment, but that can
    be an expensive and wasteful option (not just for cost, but because of the impact
    on the environment, including the wasted power used to do the processing inefficiently).
    With mobile computing it’s even more important to keep things lean and efficient
    — heavy duty programs chew up valuable battery life, and processing and memory
    must be used sparingly as these affect the size, weight and even heat dissipation
    of devices.
  prefs: []
  type: TYPE_NORMAL
- en: And if your system continues be successful, pretty soon people will be trying
    to hack into it to steal valuable customer data or passwords. How can you design
    systems so that you know they are secure from such attacks and your customers
    can trust you with their personal information or business transactions?
  prefs: []
  type: TYPE_NORMAL
- en: All these questions and more are addressed by the field of computer science.
    The purpose of this guide is to introduce you to those ideas so that you have
    a better idea of whether this field is for you. It is aimed at high-school level,
    and is intended to bring you to the point where you have a good overview of the
    field, and are well prepared for further in-depth study to become an expert.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve broken computer science up into a whole lot of topics that you’ll often
    find in curricula around the world, such as algorithms, human-computer interaction,
    compression, cryptography, computer graphics, and artificial intelligence. The
    reality is that all these topics interact, so be on the lookout for the connections.
  prefs: []
  type: TYPE_NORMAL
- en: This guide isn’t a list of facts for you to memorise, or to copy and paste into
    projects! It is mainly a guide to things you can do — experiences that will engage
    you with the topics. In fact, we won’t go through all the topics in great detail,
    but will give you references to websites and books that explain things thoroughly.
    The idea of this guide is to give you enough background to understand the topics,
    and to do something meaningful with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'And what about programming? You can get through this whole guide without doing
    any programming, although we’ll suggest exercises. Ultimately, however, all the
    concepts here are reflected in programs that people write. If you want to learn
    programming there are many excellent courses available. It takes time and practice,
    and is well worth doing in parallel with working through the topics in this guide.
    There are a number of free online systems and books that you can use to teach
    yourself programming. A database of options for learning to program is being compiled
    by [code.org](http://www.code.org/), where there is also a popular video of some
    well-known high-fliers in computing which is good to show classes. Here are some
    other sources that might suit you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[The NCEA year 12 workbook](http://www.cs.otago.ac.nz/year12dt/) is a book
    (two actually) on programming in Java and Python, written for the NZ achievement
    standards. The authors are developing a second book for the year 13 programming
    standard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CodeAvengers](http://www.codeavengers.com/) is an online system where you
    can work through challenges that will introduce you to programming in Javascript.
    This system matches the NZ programming achievement standards from level 1 to 3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Interactive Python](http://interactivepython.org/) has a free online “book”
    called “How to Think Like a Computer Scientist: Interactive Edition” (also referred
    to as “Think Python”) which teaches the Python language, and enables students
    to edit and run Python examples within the web browser. The original book is open
    source and is also available in various non-interactive versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Codecademy](http://www.codecademy.com/) is an online system where you can
    learn languages including Python and Javascript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Coder Dojo](http://coderdojo.com/) is a “movement orientated around running
    free not-for-profit coding clubs and regular sessions for young people”.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[TryPython](http://trypython.org/) is an instant Python tutorial that runs
    in your web browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CodingBat](http://codingbat.com/) has hundreds of programming challenges that
    you can try to check on how you are progressing with learning to program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Greenfoot](http://greenfoot.org/) is a visual, interactive system that teaches
    object orientation with Java. You create ‘actors’ that live in ‘worlds’ to build
    games, simulations, and other graphical programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Khan Academy](http://www.khanacademy.org/cs/) has a “Computer Science” section;
    most of the material here is about programming rather than computer science in
    general.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Grok learning](https://groklearning.com/) is a new site for learning to code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following programming teaching systems are aimed more at younger students,
    or are based around a “drag and drop” language which is only intended as a teaching
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[ScratchEd](http://scratched.media.mit.edu/) provides extensive educational
    material for Scratch, which is a drag-and-drop programming language centred around
    creating 2D animations. Scratch has many of the features of more conventional
    languages. The [Snap (BYOB)](http://byob.berkeley.edu/) system is based on Scratch,
    and has some more advanced features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Computer Science Concepts in Scratch](http://stwww.weizmann.ac.il/g-cs/scratch/scratch_en.html) is
    a book on programming in Scratch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Alice](http://alice.org/) is an educational programming language based around
    creating 3D animations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kodu](http://www.kodugamelab.com/) is a visual programming tool that is also
    available of Xbox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Snake wrangling for kids](http://briggs.net.nz/snake-wrangling-for-kids.html) is
    a free downloadable book that introduces younger students to Python programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming is just one of the skills you’ll need to be a computer scientist.
    In this book you’ll be exercising many other skills — maths, psychology, and communication
    are important ones.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2\. HOW TO USE THIS GUIDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This guide is intended to support a variety of curricula, and teacher guides
    will become available for using it in different contexts. For students, we’ve
    designed most chapters so that they can stand alone; the few that build on previous
    chapters explain at the outset what preparation you need (the most useful general
    preparation is the chapter on data representation, because everything on a computer
    is stored using binary numbers and so they have an important role in many areas
    of computer science.)
  prefs: []
  type: TYPE_NORMAL
- en: Each chapter begins with a section about the “big picture” — why the topic is
    useful for understanding and designing computer systems, and what can be achieved
    using the main ideas in the chapter. You’ll then be introduced to key ideas and
    applications of the topic through examples, and wherever possible we’ll have interactive
    activities that enable you to work with the ideas first hand. Sometimes these
    will be simplified versions of the full sized problems that computer scientists
    need to deal with – our intention is for you to actually interact with the ideas,
    not just read about them. Make sure you give them a go!
  prefs: []
  type: TYPE_NORMAL
- en: We finish each chapter by talking about the “whole story,” giving hints about
    parts of the topic that we omitted because we didn’t want to make the chapter
    too overwhelming. There will be pointers for further reading, but be warned that
    some of it might be quite deep, and require advanced math or programming skills.
  prefs: []
  type: TYPE_NORMAL
- en: If you are doing this for formal study, you’ll end up having to do some sort
    of assessment. The chapters provide ideas for projects and activities that could
    be used for this, and the appendix has more detailed projects (currently designed
    for the New Zealand NCEA requirements).
  prefs: []
  type: TYPE_NORMAL
- en: 1.3\. ABOUT THIS GUIDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This guide is free for you to copy, share and even modify. We plan to make it
    available online, as a downloadable PDF file, and for ePub (e.g. for iBooks) and
    MOBI (e.g. for Kindle), although it’s much better viewed in the other formats
    because you can watch the videos and use the interactive activities.
  prefs: []
  type: TYPE_NORMAL
- en: This guide is licenced under a [Creative Commons Attribution-NonCommercial-ShareAlike
    licence](http://creativecommons.org/licenses/by-nc-sa/3.0/), which means that
    you are welcome to take copies and modify them. If you do make improvements, we
    ask that you share those, and acknowledge this guide by linking back to our web
    site. You can give away the guide (or any derivatives), but you’re not allowed
    to sell it.
  prefs: []
  type: TYPE_NORMAL
- en: Production of the guide was partially funded by a generous grant from Google
    Inc., and supported by the University of Canterbury. Of course, we welcome donations
    to support further work on the guide.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4\. FURTHER READING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each chapter gives suggestions for further reading for that particular. There
    are also plenty of general books and websites about computer science that you
    might want to read to keep your view of the topic broad.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [“Nested” Youtube channel](https://www.youtube.com/channel/UCp-hlYynzR5VW18ITtrcMtQ) is
    a video series that introduces different computer science topics (for example:
    binary search) and closely matches the topics in the Field Guide.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Books that we particularly recommend include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithmic adventures: from knowledge to magic, by Jurag Hromkovic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Turing Omnibus, by A.K. Dewdney
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Algorithmics, by David Harel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Computational fairy tales](http://computationaltales.blogspot.co.nz/), by
    Jeremy Kubica'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wikipedia has a fairly extensive [entry on computer science](http://en.wikipedia.org/wiki/Computer_science).
  prefs: []
  type: TYPE_NORMAL
- en: The AQA Computing A2 book(s), by Sylvia Langfield and Kevin Bond, give a more
    detailed account of many of these topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also some excellent general web sites about Computer Science, many
    of which we’ve referenced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Computer Science For Fun](http://www.cs4fn.org/) — a very readable collection
    of short articles about practical applications of topics in computer science'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Babbage’s bag](http://www.i-programmer.info/babbages-bag/) is an excellent
    collection of technical articles on many topics in computing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CS Bytes](http://www.nsf.gov/cise/csbytes/) has up-to-date articles about
    applications of computer science.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Thriving in our digital world](http://www.cs.utexas.edu/~engage/) has some
    excellent information and interactive material on topics from computer science.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Virginia tech online interactive modules for teaching computer science](http://courses.cs.vt.edu/csonline/) cover
    a range of relevant topics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CS animated](http://www.csanimated.com/) has interactive activities on computer
    science.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CS for All](http://www.cs.hmc.edu/csforall/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2\. ALGORITHMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2.1\. WHAT’S THE BIG PICTURE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every computer device you have ever used, from your school computers to your
    calculator, has been using algorithms to tell it how to do whatever it was doing.
    Algorithms are a very important topic in Computer Science because they help software
    developers create efficient and error free programs. The most important thing
    to remember about algorithms is that there can be many different algorithms for
    the same problem, but some are much better than others!
  prefs: []
  type: TYPE_NORMAL
- en: Click an image to play sorting animations
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad17424b90.gif)'
  prefs: []
  type: TYPE_IMG
- en: '**Selection sort**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad172e4630.gif)'
  prefs: []
  type: TYPE_IMG
- en: '**Quick sort**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Animations provided by David Martin from [www.sorting-algorithms.com](http://www.sorting-algorithms.com/)*'
  prefs: []
  type: TYPE_NORMAL
- en: Computers are incredibly fast at manipulating, moving and looking through data.
    However the amount of data computers use is often so large that it doesn’t matter
    how fast the computer is, it will take it far too long to examine every single
    piece of data (companies like Google, Facebook and Twitter process about 1 billion
    things per day). This is where algorithms come in. If a computer is given a better
    algorithm to process the data then it doesn’t matter how much information it has
    to look through, it will still be able to do it in a reasonable amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: If you have read through the Introduction chapter you may remember that the
    speed of an application on a computer makes a big difference to a human using
    it. If an application you create is too slow, people will get frustrated with
    it and won’t use it. It doesn’t matter if your program can solve all their life
    problems, if it takes too long they will simply get bored and close it!
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.1\. ALGORITHMS, PROGRAMS AND INFORMAL INSTRUCTIONS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this stage you might be thinking that algorithms and computer programs kind
    of sound like the same thing, but they are actually two very distinct concepts.
    Descriptions of these and another important concept, Informal Instructions, are
    below. They are each different ways of describing how to do something:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Informal Instruction**: An instruction using natural language. They are un-precise
    so computers cannot understand them, but humans are able to use their own intelligence
    to interpret them. This is the least precise of our three descriptions for doing
    things, and is typically used to give a very simple description of the general
    idea of an algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Algorithm**: step by step process that describes how to solve a problem and/or
    complete a task, which will always give a result. They are more precise than Informal
    Instructions and do not require any knowledge or intelligence to follow, however
    they are still not precise enough for a computer to follow. These are often expressed
    using [pseudo-code](http://en.wikipedia.org/wiki/Pseudocode), which matches a
    programming language fairly closely, but leaves out details that could easily
    be added later by a programmer, and doesn’t specify the kinds of commands that
    can be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Program**: a specific implementation of an algorithm, which is written in
    a specific programming language and will give a certain result. This is the most
    precise of these three descriptions and computers are able to follow and understand
    these.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example…
  prefs: []
  type: TYPE_NORMAL
- en: '**Informal Instruction**: “Get me a glass of water”. A human can understand
    what this means and can figure out how to accomplish this task by thinking, but
    a computer would have no idea how to do this!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Algorithm**: 1) Go to the kitchen. 2) Pick up a glass. 3) Turn on the tap.
    4) Put the glass under the running water and remove it once it is almost full.
    5) Turn off the tap. 6) Take the glass back to the person who gave the instruction.
    A human could follow these instructions easily, but a computer could not figure
    out exactly what to do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Program**: A computer program, written in a programming language, which would
    tell a robot exactly how to retrieve a glass of water and bring it back to the
    person who asked for the water.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.1.2\. ALGORITHM COST
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When Computer Scientists are comparing algorithms they often talk about the
    ‘cost’ of an algorithm. The cost of an algorithm can be interpreted in several
    different ways, but it is always related to how well an algorithm performs based
    on the size of its input, *n*. In this chapter we will talk about the cost of
    an algorithm as either the time it takes a program (which performs the algorithm)
    to complete, and the number of comparisons the algorithm makes before it finishes.
  prefs: []
  type: TYPE_NORMAL
- en: The amount of time a program which performs the algorithm takes to complete
    may seem like the simplest cost we could look at, but this can actually be affected
    by a lot of different things, like the speed of the computer being used, or the
    programming language the program has been written in. This means that if the time
    the program takes to complete is used to measure the cost of an algorithm it is
    important to use the same program and the same computer (or another computer with
    the same speed) for testing the algorithm with different numbers of inputs.
  prefs: []
  type: TYPE_NORMAL
- en: The number of comparisons an algorithm makes however will not change depending
    on the speed of a computer, or the programming language the program using the
    algorithm is written in. Some algorithms will always make the same number of comparisons
    for a certain input size, while others might vary.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to find out more about how the cost of an algorithm is described
    in industry, with ‘Big-O Notation’, then check out “The Whole Story!” section
    at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.3\. SEARCHING AND SORTING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter we will look at two of the most common and important types of
    algorithms, Searching and Sorting. You probably come across these kinds of algorithms
    every time you use a computer without even realising!
  prefs: []
  type: TYPE_NORMAL
- en: 2.2\. SEARCHING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Searching through collections of data is something computers have to do all
    the time. It happens every time you type in a search on Google, or when you type
    in a file name to search for on your computer. Computers deal with such huge amounts
    of data that we need fast algorithms to help us find information quickly. Lets
    investigate searching with a game…
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad171a0ed8.jpg)Click to load'
  prefs: []
  type: TYPE_NORMAL
- en: Searching Game - Part 1](http://csfieldguide.org.nz/_static/interactives/alg/searching/index.html?max=2)
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the numbers on the monsters and pets in the game were
    in a random order, which meant that finding the pet was basically luck! You might
    have found it on your first try, or if you were less lucky you might have had
    to look inside almost all the presents before you found it. This might not seem
    like such a bad thing since you had enough lives to look under all the boxes,
    but imagine if there had been 1,000 boxes, or worse 1,000,000! It would have taken
    far too long to look through all the boxes and the pet might have never been found.
  prefs: []
  type: TYPE_NORMAL
- en: Now this next game is slightly different. You have less lives, which makes things
    a bit more challenging, but this time the numbers inside the boxes will be in
    order. The monsters, or maybe the pet, with the smallest number is in the present
    on the far left, and the one with the largest number is in the present on the
    far right. Let’s see if you can collect all the pets without running out of lives…
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad11248654.jpg)Click to load'
  prefs: []
  type: TYPE_NORMAL
- en: Searching Game - Part 2](http://csfieldguide.org.nz/_static/interactives/alg/searching/index.html?level=3)
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have played through the whole game (and hopefully found all of
    the lost pets!) you may have noticed that even though you had less lives in the
    second part of the game, and lots of presents to search through, you were still
    able to find the pet. Why was this possible?
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.1\. TWO CONTRASTING SEARCH ALGORITHMS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since the boxes in the first game were in a random order there really wasn’t
    any strategy you could have used to find the pet, except simply keep opening presents
    one by one until you found the pet. This is very similar to the Linear Search
    Algorithm (sometimes called a sequential search). In plain english, this algorithm
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the first item in a list is the item you are searching for, if it is
    the one you are looking for, you are done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it isn’t the item you are searching for move on and check the next item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continue checking items until you find the one you are searching for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you used this algorithm you might get lucky and find what you are looking
    for on your first go, but if you were really unlucky you might have to look through
    everything in your list before you found the right object! For a list of 10 items
    this means on average you would only have to look at 5 items to find what you
    were looking for, but for a list of 10000 you would have to look through on average
    5000.
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity: Bozo Search**'
  prefs: []
  type: TYPE_NORMAL
- en: If you watched the video at the beginning of the chapter you might be thinking
    that what you did in the present searching game sounds more like Bozo Search than
    Linear Search, but actually Bozo Search is even sillier than this! If you were
    doing a Bozo Search then after unwrapping a present and finding a monster inside,
    you would wrap the present back up before you moved on to the next one! This means
    you might end up checking the same present again and again and again and you might
    never find the pet, even with a small number of presents!
  prefs: []
  type: TYPE_NORMAL
- en: A much better algorithm to use is called Binary Search. In the second part of
    the present searching game the boxes were in order, which meant you were able
    to be more clever when you were searching for the pet, and you might have been
    using a Binary Search without realising...
  prefs: []
  type: TYPE_NORMAL
- en: If you used a Binary Search on each of the levels then you would have always
    had enough lives to find the pet! Informally, the Binary Search algorithm is as
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the item in the centre of the list and compare it to what you are searching
    for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is what you are looking for then you are done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is larger than the item you are looking for then you can ignore all the
    items in the list which are larger than that item (if the list is from smallest
    to largest this means you can ignore all the items to the right of the centre
    item).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is smaller then you can ignore all the items in the list which are smaller
    than that centre item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now repeat the algorithm on the remaining half of the list, checking the middle
    of the list and choosing one of the halves, until you find the item you are searching
    for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary Search is a very powerful algorithm. If you had 1000 presents to Search
    through it would take you at most 10 checks for Binary search to find something
    and Linear search would take at most 1000 checks, but if you doubled the number
    of presents to search through how would this change the number of checks made
    by Binary Search and Linear search?
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully you’ve noticed that the answer for each of these algorithms would
    be different.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that you can only perform a Binary Search if the
    items you are searching through are sorted into order. This makes the sorting
    algorithms we will look at next even more important because without sorting algorithms
    we wouldn’t be able to use Binary Search to quickly look through data!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following files will run linear and binary search in various languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Scratch](http://csfieldguide.org.nz/_static/algorithms/files/linear-binary-search-scratch.zip)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python (Version 2)](http://csfieldguide.org.nz/_static/algorithms/files/linear-binary-search-python2.py)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python (Version 3)](http://csfieldguide.org.nz/_static/algorithms/files/linear-binary-search-python3.py)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.3\. SORTING ALGORITHMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sorting is another very important area of algorithms. Computers often have to
    sort large amounts of data into order based on some attribute of that data, such
    as sorting a list of files by their name or size, or emails by the date they were
    received, or a customer list according to people’s names. Most of the time this
    is done to make searching easier. For example you might have a large amount of
    data and each piece of data could be someone’s name and their phone number. If
    you want to search for someone by name it would help to first have the data sorted
    alphabetically according to everyones names, but if you then wanted to search
    for a phone number it would be more useful to have the data sorted according to
    people’s phone numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Like searching there are many different sorting algorithms, but some take much
    longer than others. In this section you will be introduced to two slower algorithms
    and one much better one.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.1\. SCALES INTERACTIVE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout this section you can use the sorting interactive to test out the
    algorithms we talk about. When you’re using it make sure you take note of the
    comparisons at the bottom of the screen, each time you compare two boxes the algorithm
    is making ‘one comparison’ so the total number of comparisons you have to make
    with each algorithm is the cost of that algorithm for the 8 boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Use the scales to compare the boxes (you can only compare two boxes at a time)
    and then arrange them along the bottom of the screen. Arrange them so that the
    lightest box is on the far left and the heaviest is on the far right. Once you
    think they are in order click ‘Test order’.
  prefs: []
  type: TYPE_NORMAL
- en: If the interactive does not run properly on your computer you can use a set
    of physical balance scales instead — just make sure you can only tell if one box
    is heavier than the other, not their exact weight (so not digital scales that
    show the exact weight).
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad10acf5c3.png)Click to load the'
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm Sorting interactive](http://csfieldguide.org.nz/_static/interactives/alg/sorting/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.2\. SELECTION SORT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most intuitive ways to sort a group of boxes into order, from lightest
    to heaviest, is to start by first finding the lightest (or the heaviest) box and
    placing that to the side. Try this with the scales interactive.
  prefs: []
  type: TYPE_NORMAL
- en: After finding the lightest box simply repeat the process again with the remaining
    boxes until you find the second lightest, now place that to the side alongside
    the lightest box. If you keep repeating this process you will eventually find
    you have placed each box into order. Try sorting the whole group of boxes in the
    scales interactive into order using this method and count how many comparisons
    you have to make.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip: Start by moving all the boxes to the right of the screen and then once
    you have found the lightest box place it to the far right (if you want to find
    the heaviest first instead then move them all to the left).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you record how many comparisons you had to make each time to find the next
    lightest box you might notice a pattern (hint: finding the lightest should take
    7 comparisons, and then finding the second lightest should take 6 comparisons…).
    If you can see the pattern then how many comparisons do you think it would take
    to then sort 9 boxes into order? What about 20? If you knew how many comparisons
    it would take to sort 1000 boxes, then how many more comparisons would it take
    to sort 1001 instead?'
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is called Selection sort, because each time you look through
    the list you are ‘selecting’ the next lightest box and putting it into the correct
    position. If you go back to the algorithms racing interactive at the top of the
    page you might now be able to watch the selection sort list and understand what
    it is doing at each step.
  prefs: []
  type: TYPE_NORMAL
- en: The selection sort algorithm can be described as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Find the smallest item in the list and place it to one side. This will be your
    sorted list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next find the smallest item in the remaining list, remove it and place it into
    your sorted list beside the item you previously put to the side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat this process until all items have been selected and moved into their
    correct position in the sorted list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can swap the word ‘smallest’ for ‘largest’ and the algorithm will still
    work, as long as you are consistent it doesn’t matter if you are looking for the
    smallest or the largest item each time.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.3\. INSERTION SORT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This algorithm works by removing each box from the original group of boxes and
    inserting it into its correct position in a new sorted list. Like Selection Sort,
    it is very intuitive and people often perform it when they are sorting objects
    themselves, like cards in their hands.
  prefs: []
  type: TYPE_NORMAL
- en: Try this with the scales interactive. Start by moving all the boxes to one side
    of the screen, this is your original, and unsorted, group. Now choose a box at
    random and place that on the other side of the screen, this is the start of your
    sorted group.
  prefs: []
  type: TYPE_NORMAL
- en: To insert another box into the sorted group, compare it to the box that is already
    in the sorted group and then arrange these two boxes in the correct order. Then
    to add the next box compare it to these boxes (depending on the weight of the
    box you might only have to compare it to one!) and then arrange these three boxes
    in the correct order. Continue inserting boxes until the sorted list is complete.
    Don’t forget to count how many comparisons you had to make!
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is called Insertion Sort. If you’re not quite sure if you’ve
    got the idea of the algorithm yet then have a look at [this animation](http://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif) from [Wikipedia](http://en.wikipedia.org/wiki/Insertion_sort).
  prefs: []
  type: TYPE_NORMAL
- en: 'Insertion sort can be described with informal instructions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Take an item from your unsorted list and place it to the side, this will be
    your sorted list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One by one, take each item from the unsorted list and insert it into the correct
    position in the sorted list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do this until all items have been sorted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: People often perform this when they physically sort items. It can also be a
    very useful algorithm to use if you already have a sorted set of data and want
    to add a new piece of data into the set. For example if you owned a library and
    purchased a new book you wouldn’t do a Selection Sort on the entire library just
    to place this new book, you would simply insert the new book in its correct place.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3.4\. QUICKSORT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Insertion and Selection Sort may seem like logical ways to sort things into
    order, but they both take far too many comparisons when they are used for large
    amounts of data. Remember computers often have to search through HUGE amounts
    of data, so even if they use a good searching algorithm like Binary Search to
    look through their data, if they use a bad sorting algorithm to first sort that
    data into order then finding anything will take far too long!
  prefs: []
  type: TYPE_NORMAL
- en: A much better sorting algorithm is Quicksort! (the name is a bit of a giveaway)
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad108d8a22.png)Click to load the'
  prefs: []
  type: TYPE_NORMAL
- en: Quick Sort interactive](http://csfieldguide.org.nz/_static/interactives/alg/sorting/index.html?method=quick)
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is a little more complicated, but is very powerful. To do this
    algorithm with the sorting interactive, start by randomly choosing a box and placing
    it on the scales. Now compare every other box to the one you selected; heavier
    boxes should be put on the right of the second row and lighter boxes are put on
    the left. When you are done, place the box you were comparing everything else
    to between these two groups, but to help you keep track of things, put it in the
    row below. The following example shows how it might look after this step. Note
    that the selected block is in the right place for the final sorted order, and
    everything on either side will remain on the side that it is on.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad106c6175.png)'
  prefs: []
  type: TYPE_IMG
- en: Now apply this process to each of the two groups of boxes (the lighter ones,
    then the heavier ones). Keep on doing this until they are all sorted. The boxes
    should then be in sorted order!
  prefs: []
  type: TYPE_NORMAL
- en: It might be worth trying this algorithm out a few times and counting the number
    of comparisons you perform each time. This is because sometimes you might be unlucky
    and happen to pick the heaviest, or the lightest box first. On the other hand
    you might be very lucky and choose the middle box to compare everything to first.
    Depending on this the number of comparisons you perform will change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quicksort can be described in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose an item from the list and compare every other item in the list to this
    (this item is often called the pivot).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Place all the items that are greater than it into one subgroup and all the items
    that are smaller into another subgroup. Place the pivot item in between these
    two subgroups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose a subgroup and repeat this process. Eventually each subgroup will contain
    only one item and at this stage the items will be in sorted order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following files will run quicksort in various languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Scratch](http://csfieldguide.org.nz/_static/algorithms/files/selection-quicksort-scratch.zip)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python (Version 2)](http://csfieldguide.org.nz/_static/algorithms/files/selection-quicksort-python2.py)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python (Version 3)](http://csfieldguide.org.nz/_static/algorithms/files/selection-quicksort-python3.py)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.4\. OTHER TOPICS IN ALGORITHMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is another searching algorithm which performs even better than Binary
    Search. It is called Hashing and can be investigated with the CS Unplugged[Battleships
    Game](http://csunplugged.org/searching-algorithms).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some problems for which no good algorithms have been found (and many
    people believe they will never be found). For more on these kinds of algorithms
    see the Complexity and Tractability chapter in the Field Guide.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.5\. THE WHOLE STORY!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve only really scraped the surface of algorithms in this chapter, as there
    are millions of different algorithms for millions of different problems! Algorithms
    are used in maths, route planning, network planning and operation, problem solving,
    artificial intelligence, genetic programming, computer vision, the list goes on
    and on! But by going through this chapter you should have gained an understanding
    of the key concepts of algorithms and will be well prepared to tackle more complicated
    ones in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we have only talked about the number of comparisons an algorithm
    makes, and the amount of time a program takes to complete as ‘costs’ of algorithms.
    There are actually many other ways of measuring the cost of an algorithm. These
    include the amount of memory the algorithm uses and its computational complexity.
    Computer Scientists use ‘Big O notation’ to more accurately describe the performance
    or complexity of an algorithm, and you are likely to come across this notation
    very quickly when investigating the performance of algorithms. It characterises
    the resources needed by an algorithm and is usually applied to the execution time
    required, or sometimes the space used by the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some Big O examples:'
  prefs: []
  type: TYPE_NORMAL
- en: O(1) - An algorithm with O(1) complexity will always execute in the same amount
    of time regardless of how much data you give it to process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: O(n) - The amount of time an algorithm with O(n) complexity will take to execute
    will increase linearly and in direct proportion to the amount of data you give
    it to process. Remember that Big O describes the worst case scenario so the algorithm
    might sometimes take less time, but the greatest amount of time it can take will
    increase in direct proportion to the amount of data it is given.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: O(n2) - The performance of an algorithm with this complexity is directly proportional
    to the square of the size of the input data set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: O(2n) - The amount of time an algorithm with this complexity will take to complete
    will double with each additional element added to the data set! Does this remind
    you of any of the algorithms you have looked at in this chapter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Big O Notation however requires some advanced mathematics to explore thoroughly
    so has been intentionally left out of this main chapter, but if you want to learn
    more check out the Useful Links section. These topics are looked at in more depth
    in the Complexity and Tractability chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To make things even more complicated, in practice algorithms are running on
    computers that have cached memory and virtual memory, where the time to access
    a particular value can be particularly short, or particularly long. There is a
    whole range of algorithms that are used for this situation to make sure that the
    algorithm still runs efficiently in such environments. Such algorithms are still
    based on the ideas we’ve looked at in this chapter, but require some clever adjustments
    to ensure that they work well.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6\. FURTHER READING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 2.6.1\. USEFUL LINKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CS Unplugged [Searching algorithms](http://csunplugged.org/searching-algorithms)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CS Unplugged [Sorting algorithms](http://csunplugged.org/sorting-algorithms)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Searching algorithm game, may not be suitable](http://csunplugged.org/divideAndConquer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wikipedia has more details on [Linear Search](http://en.wikipedia.org/wiki/Linear_search), [Binary
    Search](http://en.wikipedia.org/wiki/Binary_search), [Selection sort](http://en.wikipedia.org/wiki/Selection_sort), [Insertion
    sort](http://en.wikipedia.org/wiki/Insertion_sort) and [Quicksort](http://en.wikipedia.org/wiki/Quicksort).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Sorting Bricks game](http://mathsite.math.berkeley.edu/sorting/brick.html) is
    a great way to learn about several sorting algorithms (requires Java).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sorting Algorithms Visualisations](http://www.sorting-algorithms.com/) shows
    several different sorting algorithms racing and contains information and pseudocode
    for each.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Beginners Guide to Big O Notation](http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3\. HUMAN COMPUTER INTERACTION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3.1\. WHAT’S THE BIG PICTURE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: People often become frustrated with computers. At some point when using these
    devices, you will be annoyed that the computer did something you didn’t want it
    to do and you can’t figure out how to get the computer to do what you want, but
    why is that? Humans made computers, so why are computers often so frustrating
    to use by humans?
  prefs: []
  type: TYPE_NORMAL
- en: 'Computers are becoming hundreds of times more powerful every decade, yet there
    is one important component of the computer system that hasn’t changed significantly
    in performance since the first computers were developed in the 1940s: the human.
    For a computer system to work really well it needs to be designed by people who
    understand the human part of the system well.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll look at what typically makes good and bad interfaces.
    The idea is to make you sensitive to the main issues so that you can critique
    existing interfaces, and begin to think about how you might design good interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Often software developers create a computer program or system for a device that
    requires the user to spend some time to learn how to use the program. These interfaces
    might be easy to use for the developer since they know the system really well,
    but a user just wants to get the job done without spending too much time learning
    the software (they might switch to another program if it’s too hard to use). A
    developer might treat the program and the user separately, however the user is
    part of the system, and a developer needs to create the software with the user
    in mind, designing a program that they will find easy to use and intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: Human-computer interaction (HCI) is about trying to make programs useful, usable,
    and accessible to humans. It goes way beyond choosing layouts, colours, and fonts
    that aren’t Comics Sans for an interface. It’s strongly influenced by the psychology
    of how people interact with digital devices, which means understanding many issues
    about how people behave, how they perceive things, and how they understand things
    so that they feel that a system is working to help them and not hinder them. HCI
    “involves the study, planning, and design of the interaction between people (the
    users) and computers. It is often regarded as the intersection of computer science,
    behavioral sciences, design and several other fields of study.” By understanding
    HCI, developers are more likely to create software that is effective and popular.
    If you ask people if they have ever been frustrated using a computer system, you’ll
    probably get a clear message that HCI isn’t always done well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out the following interactive task, and get some friends to try it:'
  prefs: []
  type: TYPE_NORMAL
- en: Answer as many questions as you can
  prefs: []
  type: TYPE_NORMAL
- en: START
  prefs: []
  type: TYPE_NORMAL
- en: 15 seconds left
  prefs: []
  type: TYPE_NORMAL
- en: Did anyone get a wrong answer to the question even though you thought you got
    it right? You may have noticed that the “Yes” and “No” button sometimes swap.
    Inconsistency is normally a really bad thing in an interface, as it can easily
    fool the user into making an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The study of Human Computer Interaction involves a lot of psychology (how people
    behave) because this affects how they will use a system. As a simple example,
    the human short term memory only lasts for a matter of seconds (even in young
    people!) If a device delays a response for more than about 10 seconds, the user
    has to make a conscious effort to remember what they were doing, and that’s extra
    work for the user (which from their point of view, makes the system more tiring
    to use). Another example is that people get “captured” into sequences: if you
    start biking on a route that you take each day, you’ll soon find yourself arriving
    without thinking about every turn along the way, which is fine unless you were
    supposed to go somewhere else on the way. A similar effect occurs with confirmation
    dialogues; perhaps you often accidentally close a file without saving it, and
    the system says “Do you want to save it?”, so you press “Yes”. After you’ve done
    this a few times you’ll be captured into that sequence, so on the one occasion
    that you don’t want to overwrite your old file, you may accidentally click “Yes”
    anyway. A lot of people might blame themselves for such errors, but basic psychology
    says that this is a natural error to make, and a good system should protect users
    from such errors (for example, by allowing them to be undone).'
  prefs: []
  type: TYPE_NORMAL
- en: Designing good interfaces is *very* difficult. Just when you think you’ve got
    a clever idea, you’ll find that a whole group of people struggle to figure out
    how to use it, or it backfires in some situation. Even worse, some computer developers
    think that their users are dummies and that any interface problems are the user’s
    fault and not the developer’s. But the real problem is that the developer knows
    the system really well, whereas the user just wants to get their job done without
    having to spend a lot of time learning the software – if the software is too hard
    to use, they’ll just find something else that’s easier. Good interfaces are worth
    a lot in the market.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to evaluate and fine tune interfaces, and in this chapter
    we’ll look at some of these. One important principle is that one of the worst
    people to evaluate an interface is the person who designed and programmed it.
    They know all the details of how it works, they’ve probably been thinking about
    it for weeks, they know the bits that you’re not supposed to touch and the options
    that shouldn’t be selected, and of course they have a vested interest in finding
    out what is *right*with it rather than what is *wrong*. It’s also important that
    the interface should be evaluated by someone who is going to be a typical user;
    if you get a 12-year-old to evaluate a retirement planning system they may not
    know what the user will be interested in; and if you get a teacher to try out
    a system that students will use, they will know what the answers are and what
    the correct process is.
  prefs: []
  type: TYPE_NORMAL
- en: Often interfaces are evaluated by getting typical users to try them out, and
    carefully noting any problems they have. There are companies that do nothing but
    these kinds of user tests — they will be given a prototype product, and pay groups
    of people to try it out. A report on the product is then produced and given to
    the people who are working on it. This is an expensive process, but it makes the
    product a lot better, and may well give it a huge advantage over its competitors.
    Having it evaluated by a separate company means that you avoid any bias from people
    in your own company who want to prove (even subconsciously) that they’ve done
    a good job designing it, rather than uncover any niggling problems in the software
    that will annoy users.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at different ways to evaluate interfaces, we need to consider
    what is happening with an interface.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2\. USERS AND TASKS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A very important consideration when designing or evaluating an interface is
    who the users are likely to be. For example, the typical age of a user can be
    significant: very young children may have difficulty reading some words and prefer
    images and animations, while a business person who uses an interface frequently
    will want it to be very fast to use, perhaps using keyboard shortcuts only.'
  prefs: []
  type: TYPE_NORMAL
- en: What are some of the considerations you would make for the following user groups?
  prefs: []
  type: TYPE_NORMAL
- en: Senior citizens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gamers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casual users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foreign visitors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface is the only part of a program that the user sees (that’s the definition
    of an interface!), so if the interface doesn’t work for them, the program doesn’t
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to do when designing and evaluating an interface is
    to think about what tasks it is being used for. Advertisements for digital devices
    often hide the complexity of a task, and simply point out the features available
    for doing the task. For example, suppose a smartphone is advertised as having
    a high resolution camera. The real task that someone might want to do is to take
    a photo of something they’ve just spotted, and send it to a friend. If you look
    at what happens in reality, the smartphone might be in their pocket or bag, and
    if they see something cool going past, they need to get it out, perhaps unlock
    it, open the camera app, adjust the lighting and other settings, press a button
    (is it easy to find when you’re holding the camera up?), select the photo, choose
    an email option, type in the friend’s address (does the system help with that?),
    send it (what happens if you’re out of reception range?), and then put the phone
    away. If any one of these steps is slow or hard to remember, the whole experience
    can be frustrating, and it’s possible the photo opportunity will be missed, or
    for some other reason the friend won’t receive the photo.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s very important to think about the whole context when describing a task.
    As an exercise, can you provide an example of a real task, including context,
    for a real person for each of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: set an alarm clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: show a slide (Powerpoint) presentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important to think through all the parts of a task when discussing an interface,
    as it’s the small steps in a task that make all the difference between using the
    interface in a real situation, compared with a demonstration of some features
    of the device.
  prefs: []
  type: TYPE_NORMAL
- en: '3.2.1\. ACTIVITY: SENDING AN EMAIL FROM MULTIPLE DEVICES'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this activity, try sending an email from both a computer and a mobile phone.
    Take note of all the steps required from when you start using the device until
    the email is sent.
  prefs: []
  type: TYPE_NORMAL
- en: You will probably notice quite a few differences between the two interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '3.2.2\. ACTIVITY: DESIGNING STOVETOPS/REMOTE'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this activity, you will designing the top of a cooking stove. This isn’t
    a computer system, but will help demonstrate some of the issues that come up.
    Your task is to sketch three different configurations for the stovetop which includes
    the arrangement of the 4 elements and the 4 control knobs.
  prefs: []
  type: TYPE_NORMAL
- en: The task is [described in detail in the HCI CS Unplugged activity](http://csunplugged.org/human-interface-design).
  prefs: []
  type: TYPE_NORMAL
- en: 3.3\. INTERFACE USABILITY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Devices are often sold using catch phrases like “user friendly” and “intuitive”,
    but these are vague terms that are hard to pin down. In this section we will use
    the more technical term, [Usability](http://en.wikipedia.org/wiki/Usability),
    which is well understood by HCI experts, and gives us some ways to evaluate how
    suitable an interface is for a particular task. Usability isn’t just about an
    interface being nice to use: poor usability can lead to serious problems, and
    has been the cause of major disasters, such as airplane crashes, financial disasters,
    and medical mishaps. It is also important because an interface that requires a
    lot of dexterity, quick reactions or a good memory makes it less accessible to
    much of the population, when accessibility can be both a moral and legal expectation.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many elements that can be considered in usability, and we will mention
    a few that you are likely to come across when evaluating everyday interfaces.
    Bear in mind that the interfaces might not just be a computer — any digital device
    such as an alarm clock, air conditioning remote control, microwave oven, or burglar
    alarms can suffer from usability problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'One “golden rule” of usability is *consistency*. If a system keeps changing
    on you, it’s going to be frustrating to use. Earlier we had the example of a yes/no
    button pair that occasionally swapped places. A positive example is the consistent
    use of “control-C” and “control-V” in many different programs to copy and paste
    text or images. This also helps *learnability*: once you have learned copy and
    paste in one program, you know how to use it in many others. Imagine if every
    program used different menu commands and keystrokes for this!'
  prefs: []
  type: TYPE_NORMAL
- en: 'A related issue is the [*Mode error*](http://en.wikipedia.org/wiki/Mode_error#Mode_errors),
    where the behaviour of an action depends on what mode you are in. A simple example
    is having the caps lock key down (particularly for entering a password, where
    you can’t see the effect of the mode). A classic example is in Excel spreadsheets,
    where the effect of clicking on a cell depends on the mode: sometimes it selects
    the cell, and other times it puts the name of the cell you clicked on into another
    cell. Modes are considered bad practice in interface design because they can easily
    cause the user to make the wrong action, and should be avoided if possible.'
  prefs: []
  type: TYPE_NORMAL
- en: The speed at which an interface responds (its *reaction time*) has a significant
    effect on usability. This is closely related to human perception of time. If something
    happens fast enough, we will perceive it as being instant.
  prefs: []
  type: TYPE_NORMAL
- en: The following interactive lets you find out how fast “instant” is for you. As
    you click on each cell, there will sometimes be a random delay before it comes
    up; other cells won’t have a delay. Click on each cell, and if it seems to respond
    instantly, leave it as it is. However, if you perceive that there is a small delay
    before the image comes up, click it again (which makes the cell a little lighter).
    You can’t go back and change a cell, so just make a quick, gut-level decision
    the first time you click each one. The delay may be very short, but only make
    the cell gray if you are fairly sure you noticed a delay.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad235e0a1c.png)Click to load the'
  prefs: []
  type: TYPE_NORMAL
- en: delay interactive](http://csfieldguide.org.nz/_static/widgets/HCI/HCI-Delay/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: Once you have clicked on all the cells, click on the “Probability of perceiving
    delays” bar to see a graph of how often you thought there was a delay compared
    with how long the delay actually was. 100 ms is one tenth of a second; for most
    people this is where they are likely to start perceiving a delay; anything short
    (particularly around 50 ms) is very hard to notice. Longer delays (for example,
    350 ms, which is over a third of a second) are very easy to notice.
  prefs: []
  type: TYPE_NORMAL
- en: The point of this is that any interface element (such as a button or checkbox)
    that takes more than 100 ms to respond is likely to be perceived by the user as
    not working, and they may even click it again. In the case of a checkbox, this
    may lead to it staying off (from the two clicks), leading the user to think that
    it’s not working.
  prefs: []
  type: TYPE_NORMAL
- en: Click the checkbox
  prefs: []
  type: TYPE_NORMAL
- en: Clicked 0 times
  prefs: []
  type: TYPE_NORMAL
- en: So, as you evaluate interfaces, bear in mind that even very small delays can
    make a system hard to use.
  prefs: []
  type: TYPE_NORMAL
- en: Another important length of time to bear in mind is our *short term memory* time,
    which is usually a matter of seconds. To remember something for longer, the user
    needs to rehearse it (repeat it over) or make a note of the information, such
    as writing it down. If a system takes some time to respond (say, 10 seconds) then
    chances are the user may have forgotten some detail of what they were going to
    do with the system. For example, if you have a phone number to type in that someone
    has just told you, and it takes 12 seconds before you can type it, you may forget
    the number, whereas if you can access the interface within a couple of seconds,
    you can probably enter the number without much effort. For this reason, any part
    of a system that takes more than about 10 seconds to respond forces the user to
    rehearse or write down key information, which is more tiring.
  prefs: []
  type: TYPE_NORMAL
- en: Another important usability consideration is *spatial memory* — our ability
    to remember where things are located (such as where a button or icon is). Human
    spatial memory has a high capacity (you can probably remember the location of
    many places and objects), it is long lasting (people visiting a town they grew
    up in can often remember the layout), and we can remember things very quickly.
    A very simple aspect of usability that comes from this is that the layout of an
    interface shouldn’t keep changing. The interactive task at the start of this chapter
    was deliberately set up to be frustrating by swapping the two buttons occasionally;
    the reason people often make a mistake in that situation is that their spatial
    memory takes over, so the location of the button is more important than what is
    written on it. Systems that aren’t consistent in their spatial placement of the
    “OK” and “Cancel” buttons can be frustrating.
  prefs: []
  type: TYPE_NORMAL
- en: Another place that the layout of an interface changes quickly is when a tablet
    or smartphone is rotated. Some devices rearrange the icons for the new orientation,
    which loses the spatial layout, while others keep them the same (except they may
    not look right in the new rotation). Try a few different devices and see which
    ones change the layout when rotated.
  prefs: []
  type: TYPE_NORMAL
- en: What else can cause the layout of an interface to change suddenly?
  prefs: []
  type: TYPE_NORMAL
- en: Associated with spatial memory is our *muscle memory*, which helps us to locate
    items without having to look carefully. With some practice, you can probably select
    a common button with a mouse just by moving your hand the same distance that you
    always have, rather than having to look carefully. For example, working with a
    new keyboard can mean having to re-learn the muscle memory that you have developed,
    and so may slow you down a bit.
  prefs: []
  type: TYPE_NORMAL
- en: One common human error that an interface needs to take account of is the *off
    by one error*, where the user accidentally clicks or types on an item next to
    the one they intended. For example, if the “save” menu item is next to a “delete”
    menu item, that is risky because one small slip could cause the user to erase
    a file instead of saving it. A similar issue occurs on keyboards; for example,
    control-W might close just one window in a web browser, and control-Q might close
    the entire web-browser, so choosing these two adjacent keys is a problem. Of course,
    this can be fixed by either checking if the user quits, or by having all the windows
    saved so that the user just needs to open the browser again to get their work
    back. This can also occur in web forms, where there is a reset button next to
    the submit button, and the off-by-one error causes the user to lose all the data
    they just entered.
  prefs: []
  type: TYPE_NORMAL
- en: Another idea used by HCI designers is the *principle of commensurate effort*,
    which says that frequently done simple tasks should be easy to do, but it’s ok
    to require a complex procedure for a complex task. For example, in a word processor,
    printing a page as it is displayed should be easy, but it’s ok if some effort
    is required to make it double sided, two to a page, with a staple in the top left
    corner. In fact, sometimes more effort should be *required* if the command has
    a serious consequence, such as deleting a file, wiping a device, or closing an
    account. In such cases artificial tasks may be added, such as asking “Are you
    sure?”, or to get an extreme setting on a device (like setting a voltage for a
    power supply) might require pressing an “up” button many times, rather than letting
    the user type in an extra couple of zeroes.
  prefs: []
  type: TYPE_NORMAL
- en: These are just a few ideas from HCI that will help you to be aware of the kinds
    of issues that interfaces can have. In the following project you can observe these
    kinds of problems firsthand by watching *someone else* use an interface, noting
    any problems they have. It’s much easier to observe someone else than do this
    yourself, partly because it’s hard to concentrate on the interface and taking
    notes at the same time, and partly because you might already know the interface
    and have learned to overcome some of the less usable features.
  prefs: []
  type: TYPE_NORMAL
- en: '3.3.1\. PROJECT: COGNITIVE WALKTHROUGH'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *cognitive walkthrough* is a technique that HCI experts use to do a quick
    evaluation of an interface. [Details of how to do one are on the cs4fn site](http://www.cs4fn.org/usability/cogwalkthrough.php).
  prefs: []
  type: TYPE_NORMAL
- en: There is more information in the [Wikipedia entry for Cognitive Walkthrough](http://en.wikipedia.org/wiki/Cognitive_walkthrough).
  prefs: []
  type: TYPE_NORMAL
- en: 3.4\. USABILITY HEURISTICS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Evaluating an interface is best done by getting feedback from having lots of
    potential users try it out. However, this can be expensive and time-consuming,
    so HCI experts have come up with some quick rules of thumb that help us spot obvious
    problems quickly. The formal word for a rule of thumb is a *heuristic*, and in
    this section we will look at some common heuristics that can be used to critique
    an interface.
  prefs: []
  type: TYPE_NORMAL
- en: There are various sets of heuristics that people have proposed for evaluating
    interfaces, but a Danish researcher called Jakob Nielsen has come up with a set
    of 10 heuristics that have become very widely used, and we will describe them
    in this section. If you encounter a usability problem in an interface, it is almost
    certainly breaking one of these heuristics, and possibly a few of them. It’s not
    easy to design a system that doesn’t break any of the heuristics, and sometimes
    you wouldn’t want to follow them strictly — that’s why they are called heuristics,
    and not rules.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the [heuristics online on Jakob Nielsen’s website](http://www.nngroup.com/articles/ten-usability-heuristics/);
    below is an explanation of each one.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.1\. VISIBILITY OF SYSTEM STATUS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The system should always keep users informed about what is going on, through
    appropriate feedback within reasonable time.*'
  prefs: []
  type: TYPE_NORMAL
- en: This heuristic states that a user should be able to see what the device is doing
    (the system’s status), at all times. This varies from the user being able to tell
    if the device is turned on or off, to a range of actions. A classic example is
    the “caps lock” key, which may not clearly show if it is on, and when typing a
    password the user might not know why it is being rejected; a positive example
    of this is when a password entry box warns you that the caps lock key is on.
  prefs: []
  type: TYPE_NORMAL
- en: One of the simplest statuses for a device is on or off, which is usually a coloured
    light on the outside of the computer. However, some devices take a while to show
    the status (for example, some DVD players take a while to respond when switched
    on), and the user might press the power button again or otherwise get confused
    about the status.
  prefs: []
  type: TYPE_NORMAL
- en: There are many tasks that users ask computers to do that require some time including
    copying documents, downloading files, and loading video games. In this situation,
    one of the most common ways to keep a user informed of the task is the progress
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: 85% Complete
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad23528d53.gif)'
  prefs: []
  type: TYPE_IMG
- en: '![](563ad234920a4.gif)'
  prefs: []
  type: TYPE_IMG
- en: '[![](563ad233de2f6.png)](http://xkcd.com/612/)'
  prefs: []
  type: TYPE_NORMAL
- en: However, progress indicators aren’t always helpful; the spinning wheels above
    don’t indicate if you are going to have to wait a few seconds or a few minutes
    (or even hours) for the task to complete, which can be frustrating.
  prefs: []
  type: TYPE_NORMAL
- en: Giving feedback in a “reasonable time” is really important, and the “reasonable
    time” is often shorter than what you might think. In the section above there was
    an experiment to find out at what point people perceive a delayed reaction; you
    probably found that it was around a tenth of a second. If a computer takes longer
    than that to respond then it can be confusing to use. There’s more about this
    in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some other important delay periods in interface evaluation: a delay
    of around 1 second is where natural dialogues start to get awkward, and around
    10 seconds puts a lot of load on the user to remember what they were doing. Nielsen
    has an [article about the importance of these time periods](http://www.nngroup.com/articles/response-times-3-important-limits/).
    If you want to test these ideas, try having a conversation with someone where
    you wait 3 seconds before each response; or put random 10 second delays in when
    you’re working on a task!'
  prefs: []
  type: TYPE_NORMAL
- en: Getting computers to respond quickly often depends on the algorithms used (covered
    in the chapter on algorithms), and can also depend on the design of a program
    (such as whether it stores data on disk or waits for a network response before
    continuing). It is particularly noticeable on small devices like smartphones,
    which have limited computing power, and might take a second or two to open an
    app or respond to some input. It’s not too hard to find these sorts of delays
    in systems when you’re evaluating them.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.2\. MATCH BETWEEN SYSTEM AND THE REAL WORLD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The system should speak the users’ language, with words, phrases and concepts
    familiar to the user, rather than system-oriented terms. Follow real-world conventions,
    making information appear in a natural and logical order.*'
  prefs: []
  type: TYPE_NORMAL
- en: The language, colours and notation in an interface should match the user’s world,
    and while this seems obvious and sensible, it’s often something that is overlooked.
    Take for example the following two buttons — can you see what is confusing about
    them?
  prefs: []
  type: TYPE_NORMAL
- en: CONFIRM
  prefs: []
  type: TYPE_NORMAL
- en: CANCEL
  prefs: []
  type: TYPE_NORMAL
- en: The following interface is from a bank system for paying another person. Suppose
    you get an email asking someone to pay you $1699.50 dollars for a used car; try
    entering “$1699.50” into the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Payment Amount:'
  prefs: []
  type: TYPE_NORMAL
- en: The notation “$1699.50” is a common way to express a dollar amount, but this
    system forces you to follow its own conventions (probably to make things easier
    for the programmer who wrote the system).
  prefs: []
  type: TYPE_NORMAL
- en: Are there other ways of expressing dollar amounts that are valid, but this system
    rejects? This system should be flexible with the inputted text to prevent errors
    (we will talk more about this later on).
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.3\. USER CONTROL AND FREEDOM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Users often choose system functions by mistake and will need a clearly marked
    “emergency exit” to leave the unwanted state without having to go through an extended
    dialogue. Support undo and redo.*'
  prefs: []
  type: TYPE_NORMAL
- en: It is very frustrating to make a mistake and not be able to get out of it. It
    is particularly bad if one small action can wipe a lot of work that can’t be recovered
    (the reset button on some web forms is infamous for this — it is often next to
    the submit button, and you can wipe all your data with an off-by-one error.) A
    common way to provide user freedom is an “undo” feature, which means that not
    only can mistakes be fixed easily, but the user is encouraged to experiment, trying
    out features of the interface secure in the knowledge that they can just “undo”
    to get back to how things were, instead of worrying that they’ll end up in a state
    that they can’t fix. If “redo” is also available, they can flick back and forth,
    deciding which is best. (In fact, redo is really an undo for undo!)
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example of a button that doesn’t provide user control; if you press
    it, you’ll lose this whole page and have to find your way back (we warned you!)
  prefs: []
  type: TYPE_NORMAL
- en: Do you wish to close this window?
  prefs: []
  type: TYPE_NORMAL
- en: 'YES'
  prefs: []
  type: TYPE_NORMAL
- en: 'NO'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the interface can force the user into doing something the user does
    not want to do. For example, it is quite common for operating systems or programs
    to perform updates automatically that require a restart. Sometimes the interface
    may not give them the opportunity to cancel or delay this, and restart nevertheless.
    This is bad if it happens when the user is just about to give a presentation.
  prefs: []
  type: TYPE_NORMAL
- en: Another common form of this problem is not being able to quit a system. A positive
    example is the “home” button on smartphones, which almost always stops the current
    app that is in use.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.4\. CONSISTENCY AND STANDARDS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Users should not have to wonder whether different words, situations, or actions
    mean the same thing. Follow platform conventions.*'
  prefs: []
  type: TYPE_NORMAL
- en: Consistency (something being the same every time) is extremely useful for people
    using interfaces, and is sometimes called the “golden rule of HCI”. If an interface
    is consistent with other interfaces then learning in one interface transfers directly
    to another. One of the biggest examples of consistency in computer programs is
    copy and paste, which works the same way in most software, so users only have
    to learn the concept once. The shortcut keys for copy and paste are also fairly
    consistent between programs. But in some software, copy/paste behaves differently,
    and this can be confusing for users.
  prefs: []
  type: TYPE_NORMAL
- en: An example of inconsistency is generally found within spreadsheet programs,
    where the result of pushing “control-A” (select all) depends on whether you are
    editing a cell or just have the cell selected (this particular problem is a ‘mode’
    problem). While this may make sense to a user experienced with spreadsheets, a
    new user can be very confused when the same action causes a different response.
  prefs: []
  type: TYPE_NORMAL
- en: A lack of consistency is often the reason behind people not liking a new system.
    It is particularly noticeable between Mac and Windows user; someone who has only
    used one system can find the other very frustrating to use because so many things
    are different (consider the window controls for a start, which are in a different
    place and have different icons). An experienced user of one interface will think
    that it is “obvious”, and can’t understand why the other person finds it frustrating,
    which can lead to discussions of religious fervour on which interface is best.
    Similar problems can occur when a radically different version of an operating
    system comes out (such as Windows 8); a lot of the learning that has been done
    on the previous system needs to be undone, and the lack of consistency (i.e. losing
    prior learning) is frustrating.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.5\. ERROR PREVENTION
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Even better than good error messages is a careful design which prevents a
    problem from occurring in the first place. Either eliminate error-prone conditions
    or check for them and present users with a confirmation option before they commit
    to the action.*'
  prefs: []
  type: TYPE_NORMAL
- en: A computer program shouldn’t make it easy for people to make serious errors.
    An example of error prevention found in many programs is a menu item on a toolbar
    or dropdown being ‘greyed out’ or deactivated. It stops the user from using a
    function that shouldn’t be used in that situation, like trying to copy when nothing
    is selected. A good program would also inform the user why an item is not available
    (for example in a tooltip).
  prefs: []
  type: TYPE_NORMAL
- en: Below is a date picker; can you see what errors can be produced with it?
  prefs: []
  type: TYPE_NORMAL
- en: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31   January February March April May June July August September October November December   20152014201320122011201020092008200720062005200420032002200120001999199819971996199519941993199219911990198919881987198619851984198319821981198019791978197719761975197419731972197119701969196819671966196519641963196219611960195919581957195619551954195319521951195019491948194719461945194419431942194119401939193819371936
  prefs: []
  type: TYPE_NORMAL
- en: A related problem with dates is when a user needs to pick a start and end date
    (for example, booking flights or a hotel room); the system should prevent a date
    prior to the first date being selected for the second date.
  prefs: []
  type: TYPE_NORMAL
- en: Any time a dialogue box comes up that says you weren’t allowed to do a certain
    action, the system has failed to prevent an error. Of course, it may be difficult
    to do that because the error can depend on so many user choices, but it is ideal
    that the system doesn’t offer something that it can’t do.
  prefs: []
  type: TYPE_NORMAL
- en: MENU
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.6\. RECOGNITION RATHER THAN RECALL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Minimize the user’s memory load by making objects, actions, and options visible.
    The user should not have to remember information from one part of the dialogue
    to another. Instructions for use of the system should be visible or easily retrievable
    whenever appropriate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Humans are generally very good at recognising items, but computers are good
    at remembering them accurately. A good example of this is a menu system; if you
    click on the “Edit” menu in a piece of software, it will remind you of all the
    editing tasks available, and you can choose the appropriate one easily. If instead
    you had to type in a command from memory, that would put more load on the user.
    In general it’s good for the computer to “remember” details, and the user to be
    presented with options rather than having to remember them.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.7\. FLEXIBILITY AND EFFICIENCY OF USE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Accelerators – unseen by the novice user – may often speed up the interaction
    for the expert user such that the system can cater to both inexperienced and experienced
    users. Allow users to tailor frequent actions.*'
  prefs: []
  type: TYPE_NORMAL
- en: When someone is using software every day, they soon have common sequences of
    operations they do (such as “Open the file, find the next blank space, put in
    a record of what just happened”). It’s good to offer ways to make this quick to
    do, such as “macros” which do a sequence of actions from a single keystroke.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, it’s good to be able to customise software by allocating keystrokes
    for frequent actions (such as “file this email in the ‘pending’ folder”). Common
    tasks like copy and paste usually have keystrokes added to them, and these allow
    experienced users to perform the task without having to reach for a mouse.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.8\. AESTHETIC AND MINIMALIST DESIGN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Dialogues should not contain information which is irrelevant or rarely needed.
    Every extra unit of information in a dialogue competes with the relevant units
    of information and diminishes their relative visibility.*'
  prefs: []
  type: TYPE_NORMAL
- en: Software can contain many features, and if they are all visible at the same
    time (for example, on a toolbar) this can be overwhelming for a new user.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.9\. HELP USERS RECOGNIZE, DIAGNOSE, AND RECOVER FROM ERRORS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Error messages should be expressed in plain language (no codes), precisely
    indicate the problem, and constructively suggest a solution.*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s not hard to find error messages that don’t really tell you what’s wrong!
    The most common examples are messages like “Misc error”, “Error number -2431”,
    or “Error in one of the input values”. These force the user to go on a debugging
    mission to find out what went wrong, which could be anything from a disconnected
    cable or unfixable compatibility issue, to a missing digit in a number.
  prefs: []
  type: TYPE_NORMAL
- en: A variant of this is a message that gives two alternatives, such as “File may
    not exist, or it may already be in use”. A better message would save the user
    having to figure out which of these is the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4.10\. HELP AND DOCUMENTATION
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Even though it is better if the system can be used without documentation,
    it may be necessary to provide help and documentation. Any such information should
    be easy to search, focused on the user’s task, list concrete steps to be carried
    out, and not be too large.*'
  prefs: []
  type: TYPE_NORMAL
- en: CLICK ME FOR HELP
  prefs: []
  type: TYPE_NORMAL
- en: Often help is an afterthought, and tends to be feature-centred (e.g. a catalogue
    of menu items), rather than task-centred (the series of actions needed to complete
    typical tasks, which is more useful for the user). When a user needs help, they
    typically have a task to complete (such as upload photos from a camera), and good
    documentation should explain how to do common tasks, rather than explain each
    feature (such as “Setting the camera to USB mode”).
  prefs: []
  type: TYPE_NORMAL
- en: 3.5\. THE WHOLE STORY!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we’ve mainly looked at how to critique interfaces, but we haven’t
    said much about how to design good interfaces. That’s a whole new problem, although
    being able to see what’s wrong with an interface is a key idea. Many commercial
    systems are tested using the ideas above to check that people will find them easy
    to use; in fact, before releasing a new application, often they are tested many
    times with many users. Improvements are made, and then more tests need to be run
    to check that the improvements didn’t make some other aspect of the interface
    worse! It’s no wonder that good software can be expensive — there are many people
    and a lot of time involved in making sure that it’s easy to use before it’s released.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also haven’t talked much about accessibility: making a system usable for
    someone with a disability such as impaired vision or impaired use of their limbs
    provides extra challenges, but is also very worthwhile because the device itself
    may improve accessibility (such as software to browse the web using an audio interface,
    or a computer-controlled wheelchair that can avoid colliding with obstacles).'
  prefs: []
  type: TYPE_NORMAL
- en: There are many other ideas from psychology, physiology, sociology and even anthropology
    that HCI experts must draw on. Things that come into play include[Mental models](http://en.wikipedia.org/wiki/Mental_model),
    about how someone believes a system works compared with how it actually works
    (these are almost never the same e.g. double clicking on an icon that only needs
    to be single clicked), [Fitts’s law](http://en.wikipedia.org/wiki/Fitts's_law),
    about how long it takes to point to objects on a screen (such as clicking on a
    small button), the [Hick-Hyman law](http://en.wikipedia.org/wiki/Hick's_law),
    about how long it takes to make a decision between multiple choices (such as from
    a menu), [Miller’s law](http://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two) about
    the number of items a person can think about at once,[affordances](http://en.wikipedia.org/wiki/Affordance),
    about how properties of an object help us to perform actions on them, [interaction
    design (IxD)](http://en.wikipedia.org/wiki/Interaction_design), about creating
    digital devices that work for the people who will use the product, [the NASA TLX
    (Task Load Index)](http://en.wikipedia.org/wiki/NASA-TLX) for rating the perceived
    workload that a task puts on a user, and many more laws, observations and guidelines
    about designing interfaces that take account of human behaviour and how the human
    body functions.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6\. FURTHER READING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The book “Designing with the mind in mind” by Jeff Johnson provides excellent
    background reading for many of the issues discussed in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [cs4fn website has a lot of articles and activities on Human Computer Interaction](http://www.cs4fn.org/fundamentals/hci.php),
    such as [problems around reporting interface problems](http://www.cs4fn.org/chi-med/reportingincidents.php), [cultural
    issues in interface design](http://www.cs4fn.org/usability/tzeltal.php), and [The
    importance of Sushi](http://www.cs4fn.org/usability/importanceofsushi.php).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A classic book relating to usability is “The psychology of everyday things”
    (later changed to “The design of everyday things”) by Don Norman. It’s about everyday
    objects like doors and phones, and it was written a while ago, but it contains
    lots of thought provoking and often humorous examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3.6.1\. USEFUL LINKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[The ten usability heuristics on Nielsen’s website](http://www.nngroup.com/articles/ten-usability-heuristics/),
    and a [collection of articles about usability heuristics](http://www.nngroup.com/topic/heuristic-evaluation/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a [CS Unplugged activity on HCI](http://csunplugged.org/sites/default/files/activity_pdfs_full/unplugged-19-human_interface_design_0.pdf) which
    includes background information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is [extensive material on HCI on the cs4fn website](http://www.cs4fn.org/fundamentals/hci.php)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A [glossary of usability terms](http://www.usabilityfirst.com/glossary/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4\. PROGRAMMING LANGUAGES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4.1\. WHAT’S THE BIG PICTURE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programming, sometimes referred to as coding, is a nuts and bolts activity for
    computer science. While this book won’t teach you how to program (we’ve given
    some links to sites that can do this in the introduction), we are going to look
    at what a programming language is, and how computer scientists breath life into
    a language. From a programmer’s point of view, they type some instructions, and
    the computer follows them. But how does the computer know what to do? Bear in
    mind that you might be using one of the many languages such as Python, Java, Scratch,
    Basic or C#, yet computers only have the hardware to follow instructions in one
    particular language, which is usually a very simple “machine code” that is hard
    for humans to read and write. And if you invent a new programming language, how
    do you tell the computer how to use it?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll look at what happens when you write and run a program,
    and how this affects the way that you distribute the program for others to use.
  prefs: []
  type: TYPE_NORMAL
- en: We start with an optional subsection on what programming is, for those who have
    never programmed before and want an idea about what a program is. Examples of
    very simple programs in Python are provided, and these can be run and modified
    slightly. Working through this section should give you sufficient knowledge for
    the rest of this chapter to make sense; we won’t teach you how to program, but
    you will get to go through the process that programmers use to get a program to
    run. Feel free to skip this section if you are already know a bit about programming.
  prefs: []
  type: TYPE_NORMAL
- en: A subsection on what this chapter focuses on then follows. Everybody should
    read that section.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.1\. WHAT IS PROGRAMMING?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: This section is intended for those who are unfamiliar with programming.
    If you already know a little about programming, feel free to skip over this section.
    Otherwise, it will give you a quick overview so that the remainder of the chapter
    makes sense.'
  prefs: []
  type: TYPE_NORMAL
- en: An example of the simplest kind of program is as follows — it has five instructions
    (one on each line) that are followed one after the other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This program is written in a language called Python, and when the program runs,
    it will print the following text to the screen
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In order to run a Python program, we need something called a Python interpreter.
    A Python interpreter is able to read your program, and process it. Below is a
    Python interpreter that you can use to run your own programs. If you have a Python
    interpreter installed on your computer (ask your teacher if you are following
    this book for a class and are confused) and know how to start it and run programs
    in it, you can use that.
  prefs: []
  type: TYPE_NORMAL
- en: Run
  prefs: []
  type: TYPE_NORMAL
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: Try changing the program so that it says your name instead of *Student*. When
    you think you have it right, try running the program again to see. Make sure you
    don’t remove the double quotes or the parentheses (round brackets) in the program
    by mistake. What happens if you spelt “programming” wrong? Does the computer correct
    it? If you are completely stuck, ask your teacher for help before going any further.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully you figured out how to make the program print your name. You can also
    change the asterisks (*) to other symbols. What happens if you do remove one of
    the double quotes or one of the parentheses? Try it!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you change a critical symbol in the program you will probably find that
    the Python interpreter gives an error message. In the online Python interpreter
    linked to above, it says “ParseError: bad input on line 1”, although different
    interpreters will express the error in different ways. If you have trouble fixing
    the error again, just copy the program back into Python from above.'
  prefs: []
  type: TYPE_NORMAL
- en: Programming languages can do much more than print out text though. The following
    program is able to print out multiples of a number. Try running the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first line is a print statement, like those you saw earlier, which just
    tells the system to put the message on the screen. The second line is a *loop*,
    which says to repeat the lines after it 5 times. Each time it loops, the value
    of i changes. i.e. the first time i is 0, then 1, then 2, then 3, and finally
    4\. It may seem weird that it goes from 0 to 4 rather than 1 to 5, but programmers
    tend to like counting from 0 as it makes some things work out a bit simpler. The
    third line says to print the current value of i multiplied by 3 (because we want
    multiples of 3). Note that there is *not* double quotes around the last print
    statement, as they are only used when we want to print out a something literally
    as text. If we did put them in, this program would print the text “i*3” out 5
    times instead of the value we want!
  prefs: []
  type: TYPE_NORMAL
- en: Try make the following changes to the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make it print multiples of 5 instead of 3\. Hint: You need to change more than
    just the first line — you will need to make a change on the third line as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make it print the first 10 multiples instead of the first 5\. Make sure it printed
    10 multiples, and not 9 or 11!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also loop over a list of data. Try running the program below. It will
    generate a series of “spam” messages, one addressed to each person in the recipients
    list!
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the # symbol tells the computer that it should ignore the line, as
    it is a comment for the programmer.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Try changing the recipients or the letter. Look carefully at all the symbols
    that were used to include the recipient’s name in the letter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: The detailed requirements of a programming language about exactly which characters
    need to be used and where, is called its *syntax*. In the example above, the syntax
    for the list of names requires square brackets around the list, inverted commas
    around the names, and a comma between each one. If you make a mistake, such as
    leaving out one of the square brackets, the system will have a *syntax error*,
    and won’t be able to run the program. Every symbol counts, and one small error
    in a program can stop it running, or make it do the wrong thing.
  prefs: []
  type: TYPE_NORMAL
- en: Programs can also use *variables* to store the results of calculations in, receive
    user input, and make decisions (called *conditionals*, such as *if* statements).
    Try running this program. Enter a number of miles to convert when asked. Don’t
    put units on the number you enter; for example just put “12”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first line is a *print* statement (which you should be very familiar with
    by now!) The second line asks the user for a number of miles which is converted
    from input text (called a string) to an integer, the third line uses an *if* statement
    to check if the number entered was less than 0, so that it can print an error
    if it is. Otherwise if the number was ok, the program jumps into the *else* section
    (the error is not printed because the *if* was not true), calculates the number
    of kilometers (there are 0.6214 kilometers in a mile), stores it into a *variable* called
    number_of_kilometers for later reference, and then the last line prints it out.
    Again, we don’t have quotes around number_of_kilometers in the last line as we
    want to print the value out that is stored in the number_of_kilometers variable.
    If this doesn’t make sense, don’t worry. You aren’t expected to know how to program
    for this chapter, this introduction is only intended for you to have some idea
    of what a program is and the things it can do.
  prefs: []
  type: TYPE_NORMAL
- en: If you are keen, you could modify this program to calculate something else,
    such as pounds to kilograms or farenheit to celcius. It may be best to use an
    installed Python interpreter on your computer rather than the web version, as
    the web version can give very unhelpful error messages when your program has a
    mistake in it (although all interpreters give terrible error messages at least
    sometimes!)
  prefs: []
  type: TYPE_NORMAL
- en: Programs can do many more things, such as having a graphical user interface
    (like most computer programs you will be familiar with), being able to print graphics
    onto a screen, or being able to write to and from files on the computer in order
    to save information between each time you run the program.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.2\. WHERE ARE WE GOING?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you ran the programs, it might have seemed quite magical that the computer
    was able to instantly give you the output. Behind the scenes however, the computer
    was running your example programs through another program in order to convert
    them into a form that it could make sense of and then run.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, you might be wondering why we need languages such as Python, and why
    we can’t give computers instructions in English. If we typed into the computer
    “Okay computer, print me the first 5 multiples of 3”, there’s no reason that it
    would be able to understand. For starters, it would not know what a “multiple”
    is. And it would not even know how to go about this task. Computers cannot be
    told what every word means, and they cannot know how to accomplish every possible
    task. Understanding human language is a very difficult task for a computer, as
    you will find out in the Artificial Intelligence chapter. Unlike humans who have
    an understanding of the world, and see meaning, computers are only able to follow
    the precise instructions you give them. Therefore, we need languages that are
    constrained and unambiguous that the computer “understands” instructions in. These
    can be used to give the computer instructions, like those in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: It isn’t this simple though, a computer cannot run instructions given directly
    in these languages. At the lowest level, a computer has to use physical hardware
    to run the instructions. Arithmetic such as addition, subtraction, multiplication,
    and division, or simple comparisons such as less than, greater than, or equal
    to are done on numbers represented in binary by putting electricity through physical
    computer chips containing transistors. The output is also a number represented
    in binary. Building a fast and cheap circuit to do simple arithmetic such as this
    isn’t that hard, but the kind of instructions that people want to give computers
    (like “print the following sentence”, or “repeat the following 100 times”) are
    much harder to build circuitry for.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: The electronics in computers uses circuitry that mainly just works with two
    values (represented as high and low voltages) to make it reliable and fast. This
    system is called *binary*, and is often written on paper using zeroes and ones.
    There’s a lot more about binary in the [*Data representation*](http://csfieldguide.org.nz/DataRepresentation.html#data-representation) chapter,
    and it’s worth having a quick look at the first section of that now if you haven’t
    come across binary before.
  prefs: []
  type: TYPE_NORMAL
- en: So instead of building computers that can understand these high level instructions
    that you find in languages like Python (or Java, Basic, JavaScript, C and so on),
    we build computers that can follow a very limited set of instructions, and then
    we write programs that convert the instructions in the standard languages people
    write programs in into the simple instructions that the circuitry can directly
    carry out. The language of these simple instructions is a low level programming
    language often referred to as machine code.
  prefs: []
  type: TYPE_NORMAL
- en: The conversion from a high level to a low level language can involve *compiling*,
    which replaces the high level instructions with machine code instructions that
    can then be run, or it can be done by *interpreting*, where each instruction is
    converted and followed one by one, as the program is run. In reality, a lot of
    languages use a mixture of these, sometimes compiling a program to an intermediate
    language, then interpreting it (Java does this). The language we looked at earlier,
    Python, is an interpreted language. Other languages such as C++ are compiled.
    We will talk more about compiling and interpreting later.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with looking at some other programming languages that programmers
    use to give instructions to computers, then we will look at low level languages
    and how computers actually carry out the instructions in them, and then finally
    we will talk about how we convert programs that were written by humans in a high
    level language into a low level language that the computer can carry out.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2\. MACHINE CODE (LOW LEVEL LANGUAGES)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A computer has to carry out instructions on physical circuits. These circuits
    contain transistors laid out in a special way that will give a correct output
    based on the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Data such as numbers (represented using binary) have to be put into storage
    places called registers while the circuit is processing them. Registers can be
    set to values, or data from memory can be put into registers. Once in registers,
    they can be added, subtracted, multiplied, divided, or be checked for equality,
    greater than, or less than. The output is put into a register, where it can either
    be retrieved or used in further arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: All computers have a machine code language (commonly referred to as an instruction
    set) that is used to tell the computer to put values into registers, to carry
    out arithmetic with the values in certain registers and put the result into another
    specified register like what we talked about above. Machine code also contains
    instructions for loading and saving values from memory (into or out of registers),
    jumping to a certain line in the program (that is either before or after the current
    line), or to jump to the line only if a certain condition is met (by doing a specified
    comparisons on values in registers). There are also instructions for handling
    simple input/ output, and interacting with other hardware on the computer.
  prefs: []
  type: TYPE_NORMAL
- en: The instructions are quite different to the ones you will have seen before in
    high level languages. For example, the following program is written in a machine
    language called MIPS; which is used on some embedded computer systems. We will
    use MIPS in examples throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It starts by adding 2 numbers (that have been put in registers $t0 and $t1)
    and printing out the result. It then prints “Hello World!” Don’t worry, we aren’t
    about to make you learn how to actually program in this language! And if you don’t
    really understand the program, that’s also fine because many software engineers
    wouldn’t either! (We are showing it to you to help you to appreciate high level
    languages!)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run this program using an online MIPS emulator. This needs to be done
    in 2 steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Copy paste the code into the black box on the page from this link](http://alanhogan.com/asu/assembler.php) (remove
    ALL existing text in the box), and then click the Assemble button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Copy paste the output in the “Assembler Output” box into the box on the page
    from this link](http://alanhogan.com/asu/simulator.php) (remove ALL existing text
    in the box), and click the Simulate Execution button, and the output should appear
    in a box near the top of the page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have got the program working, try changing the values that are added.
    The comments tell you where these numbers that can be changed are. You should
    also be able to change the string (text) that is printed without too much trouble
    also. As a challenge, can you make it so that it subtracts rather than adds the
    numbers? Clue: instruction names are always very short. Unfortunately you won’t
    be able to make it multiply or divide using this emulator as this seems to not
    currently be supported. Remember that to rerun the program after changing it,
    you will have to follow both steps 1 and 2 again.'
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why you have to carry out both these steps. Because computers
    work in 1’s and 0’s, the instructions need to simply be converted into hexadecimal.
    Hexadecimal is a shorthand notation for binary numbers. *Don’t muddle this process
    with compiling or interpreting!* Unlike these, it is much simpler as in general
    each instruction from the source code ends up being one line in the hexadecimal.
  prefs: []
  type: TYPE_NORMAL
- en: One thing you might have noticed while reading over the possible instructions
    is that there is no loop instruction in MIPS. Using several instructions though,
    it actually is possible to write a loop using this simple language. Have another
    read of the paragraph that describes the various instructions in MIPS. Do you
    have any ideas on how to solve this problem? It requires being quite creative!
  prefs: []
  type: TYPE_NORMAL
- en: The jumping to a line, and jumping to a line if a condition is met can be used
    to make loops! A very simple program we could write that requires a loop is one
    that counts down from five and then says “Go!!!!” once it gets down to one. In
    Python we can easily write this program in three lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: But in MIPS, it isn’t that straight forward. We need to put values into registers,
    and we need to build the loop out of jump statements. Firstly, how can we design
    the loop?
  prefs: []
  type: TYPE_NORMAL
- en: And the full MIPS program for this is as follows. You can go away and change
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Can you change the Python program so that it counts down from 10? What about
    so it stops at 5? (You might have to try a couple of times, as it is somewhat
    counter intuitive. Remember that when i is the stopping number, it stops there
    and does not run the loop for that value!). And what about decrementing by 2 instead
    of 1? And changing the string (text) that is printed at the end?
  prefs: []
  type: TYPE_NORMAL
- en: You probably found the Python program not too difficult to modify. See if you
    can make these same changes to the MIPS program.
  prefs: []
  type: TYPE_NORMAL
- en: If that was too easy for you, can you make both programs print out “GO!!!!”
    twice instead of once? (you don’t have to use a loop for that). And if THAT was
    too easy, what about making each program print out “GO!!!!” 10 times? Because
    repeating a line in a program 10 times without a loop would be terrible programming
    practice, you’d need to use a loop for this task.
  prefs: []
  type: TYPE_NORMAL
- en: More than likely, you’re rather confused at this point and unable to modify
    the MIPS program with all these suggested changes. And if you do have an additional
    loop in your MIPS program correctly printing “GO!!!” 10 times, then you are well
    on your way to being a good programmer!
  prefs: []
  type: TYPE_NORMAL
- en: So, what was the point of all this? These low level instructions may seem tedious
    and a bit silly, but the computer is able to directly run them on hardware due
    to their simplicity. A programmer can write a program in this language if they
    know the language, and the computer would be able to run it directly without doing
    any further processing. As you have probably realised though, it is extremely
    time consuming to have to program in this way. Moving stuff in and out of registers,
    implementing loops using jump and branch statements, and printing strings and
    integers using a three line pattern that you’d probably never have guessed was
    for printing had we not told you leaves even more opportunities for bugs in the
    program. Not to mention, the resulting programs are extremely difficult to read
    and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Because computers cannot directly run the instructions in the languages that
    programmers like, high level programming languages by themselves are not enough.
    The solution to this problem of different needs is to use a compiler or interpreter
    that is able to convert a program in the high level programming language that
    the programmer used into the machine code that the computer is able to understand.
  prefs: []
  type: TYPE_NORMAL
- en: These days, few programmers program directly in these languages. In the early
    days of computers, programs written directly in machine language tended to be
    faster than those compiled from high level languages. This was because compilers
    weren’t very good at minimising the number of machine language instructions, referred
    to as *optimizing*, and people trained to write in machine code were better at
    it. These days however, compilers have been made a lot smarter, and can optimize
    code far better than most people can. Writing a program directly in machine code
    may result in a program that is *less* optimized than one that was compiled from
    a high level language. Don’t put in your report that low level languages are faster!
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t the full story; the MIPS machine code described here is something
    called a Reduced Instruction Set Architecture (RISC). Many computers these days
    use a Complex Instruction Set Architecture (CISC). This means that the computer
    chips can be a little more clever and can do more in a single step. This is well
    beyond the scope of this book though, and understanding the kinds of things RISC
    machine code can do, and the differences between MIPS and high level languages
    is fine at this level, and fine for most computer scientists and software engineers.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we require low level programming languages because the computer
    can understand them, and we require high level programming languages because humans
    can understand them. A later section talks more about compilers and interpreters;
    programs that are used to convert a program that is written in a high level language
    (for humans) into a low level language (for computers).
  prefs: []
  type: TYPE_NORMAL
- en: 4.3\. A BABEL OF PROGRAMMING LANGUAGES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many different programming languages. Here we have included a small
    subset of languages, to illustrate the range of purposes that languages are used
    for. There are many, many more languages that are used for various purposes, and
    have a strong following of people who find them particularly useful for their
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: For a much larger list you can [check Wikipedia here](http://en.wikipedia.org/wiki/List_of_programming_languages).
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.1\. PYTHON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python is a widely used language, that has also become very popular as a teaching
    language. Many people learn Python as their first programming language. In the
    introduction, we looked at some examples of Python programs, for those who have
    never programmed before.
  prefs: []
  type: TYPE_NORMAL
- en: Originally though, Python was intended to be a scripting language. Scripting
    languages have syntax that makes them quick to write programs for file processing
    in, and for doing repetitive tasks on a computer.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of a situation where Python is very useful, imagine your teacher
    has given 5 quizzes throughout the year, and recorded the results for each student
    in a file such as this (It could include more than 6 students), where each student’s
    name is followed by their scores. Some students didn’t bother going to class for
    all the quizzes, so have less than 5 results recorded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: She realises she needs to know the average (assuming 5 quizzes) that each student
    scored, and with many other things to do does not want to spend much time on this
    task. Using python, she can very quickly generate the data she needs in less than
    10 lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Note that understanding the details of this code is irrelevant to this chapter,
    particularly if you aren’t yet a programmer. Just read the comments (the things
    that start with a “#”) if you don’t understand, so that you can get a vague idea
    of how the problem was approached.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a file that contains each student’s name followed by the
    result of adding their scores and dividing the sum by 5\. You can try the code
    if you have python installed on your computer (it won’t work on the online interpreter,
    because it needs access to a file system). Just put the raw data into a file called
    “scores.txt” in the same format it was displayed above. As long as it is in the
    same directory as the source code file you make for the code, it will work.
  prefs: []
  type: TYPE_NORMAL
- en: This problem could of course be solved in any language, but some languages make
    it far simpler than others. Standard software engineering languages such as Java,
    which we talk about shortly, do not offer such straight forward file processing.
    Java requires the programmer to specify what to do if opening the file fails in
    order to prevent the program from crashing. Python does not require the programmer
    to do this, although does have the option to handle file opening failing should
    the programmer wish to. Both these approaches have advantages in different situations.
    For the teacher writing a quick script to process the quiz results, it does not
    matter if the program crashes so it is ideal to not waste time writing code to
    deal with it. For a large software system that many people use, crashes are inconvenient
    and a security risk. Forcing all programmers working on that system to handle
    this potential crash correctly could prevent a lot of trouble later on, which
    is where Java’s approach helps.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to straight forward file handling, Python did not require the code
    to be put inside a class or function, and it provided some very useful built in
    functions for solving the problem. For example, the function that found the sum
    of the list, and the line of code that was able to convert the raw line of text
    into a list of numbers (using a very commonly used pattern).
  prefs: []
  type: TYPE_NORMAL
- en: This same program written in Java would require at least twice as many lines
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other scripting languages in addition to Python, such as Perl,
    Bash, and Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.2\. SCRATCH
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scratch is a programming language used to teach people how to program. A drag
    and drop interface is used so that new programmers don’t have to worry so much
    about syntax, and programs written in Scratch are centered around controlling
    cartoon characters or other sprites on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Scratch is never used in programming in industry, only in teaching. If you are
    interested in trying Scratch, [you can try it out online here](http://scratch.mit.edu/projects/editor/?tip_bar=getStarted),
    no need to download or install anything.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad2b9ebc86.png)](http://scratch.mit.edu/projects/19711355/#editor)'
  prefs: []
  type: TYPE_NORMAL
- en: Click the image above to load the project and try it for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of a simple program in Scratch that is similar to the programs
    we have above for Python and Java. It asks the user for numbers until they say
    “stop” and then finds the average of the numbers given.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad2b8ec441.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And this is the output that will be displayed when the green flag is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad2b86b2d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Scratch can be used for simple calculations, creating games and animations.
    However it doesn’t have all the capabilities of other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Other educational languages include Alice and Logo. Alice also uses drag and
    drop, but in a 3D environment. Logo is a very old general purpose language based
    on Lisp. It is not used much anymore, but it was famous for having a turtle with
    a pen that could draw on the screen, much like Scratch. The design of Scratch
    was partially influenced by Logo. These languages are not used beyond educational
    purposes, as they are slow and inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.3\. JAVA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java is a popular general purpose software engineering language. It is used
    to build large software systems involving possibly hundreds or even thousands
    of software engineers. Unlike Python, it forces programmers to say how certain
    errors should be handled, and it forces them to state what type of data their
    variables are intended to hold, e.g. *int* (i.e. a number with no decimal places),
    or *String* (some text data). Python does not require types to be stated like
    this. All these features help to reduce the number of bugs in the code. Additionally,
    they can make it easier for other programmers to read the code, as they can easily
    see what type each variable is intended to hold (figuring this out in a python
    program written by somebody else can be challenging at times, making it very difficult
    to modify their code without breaking it!)
  prefs: []
  type: TYPE_NORMAL
- en: This is the Java code for solving the same problem that we looked at in Python;
    generating a file of averages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: While the code is longer, it ensures that the program doesn’t crash if something
    goes wrong. It says to *try* opening and reading the file, and if an error occurs,
    then it should *catch* that error and print out an error message to tell the user.
    The alternative (such as in Python) would be to just crash the program, preventing
    anything else from being able to run it. Regardless of whether or not an error
    occurs, the “I am finished!” line will be printed, because the error was safely
    “caught”. Python is able to do error handling like this, but it is up to the programmer
    to do it. Java will not even compile the code if this wasn’t done! This prevents
    programmers from forgetting or just being lazy.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other general software engineering languages, such as C# and
    C++. Python is sometimes used for making large software systems, although is generally
    not considered an ideal language for this role.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.4\. JAVASCRIPT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interpreted in a web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similar language: Actionscript (Flash)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that this section will be completed in a future version of the field guide.
    For now, you should refer to wikipedia page for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.5\. C
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Low level language with the syntax of a high level language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used commonly for programming operating systems, and embedded systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs written in C tend to be very fast (because it is designed in a way
    that makes it easy to compile it optimally into machine code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bug prone due to the low level details. Best not used in situations where it
    is unnecessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Related languages: C++ (somewhat)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that this section will be completed in a future version of the field guide.
    For now, you should refer to wikipedia page for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.6\. MATLAB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Used for writing programs that involve advanced math (calculus, linear algebra,
    etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not freely available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Related languages: Mathematica, Maple'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that this section will be completed in a future version of the field guide.
    For now, you should refer to wikipedia page for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.7\. ESOTERIC PROGRAMMING LANGUAGES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Anybody can make their own programming language. Doing so involves coming up
    with a syntax for your language, and writing a parser and compiler or interpreter
    so that programs in your language can be run. Most programming languages that
    people have made never become widely used.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to programming languages that have practical uses, people have made
    many programming languages that were intended to be nothing more than jokes, or
    to test the limits of how obscure a programming language can be. Some of them
    make the low level machine languages you saw earlier seem rather logical! Wikipedia
    has a list of such languages. [http://en.wikipedia.org/wiki/Esoteric_programming_language](http://en.wikipedia.org/wiki/Esoteric_programming_language)
  prefs: []
  type: TYPE_NORMAL
- en: You could even make your own programming language if you wanted to!
  prefs: []
  type: TYPE_NORMAL
- en: 4.4\. HOW DOES THE COMPUTER PROCESS YOUR PROGRAM?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A programming language such as Python or Java is implemented using a program
    itself — the thing that takes your Python program and runs it is a program that
    someone has written!
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the computer hardware can only run programs in a low level language (machine
    code), the programming system has to make it possible for your Python instructions
    to be executed using only machine language. There are two broad ways to do this:
    interpreting and compiling.'
  prefs: []
  type: TYPE_NORMAL
- en: '[This 1983 video](http://www.youtube.com/watch?v=_C5AHaS1mOA) provides a good
    analogy of the difference between an interpreter and a compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: The main difference is that a compiler is a program that converts your program
    to machine language, which is then run on the computer. An interpreter is a program
    that reads your program line by line, works out what those instructions are, and
    does them immediately.
  prefs: []
  type: TYPE_NORMAL
- en: There are advantages to both approaches, and each one suits some languages better
    than others. In reality, most modern languages use a mixture of compiling and
    interpreting. For example, most Java programs are *compiled* to an “intermediate
    language” called ByteCode, which is closer to machine code than Java. The ByteCode
    is then executed by an interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: If your program is to be distributed for widespread use, you will usually want
    it to be in machine code because it will run faster, the user doesn’t have to
    have an interpreter for your particular language installed, and when someone downloads
    the machine code, they aren’t getting a copy of your original high-level program.
    Languages where this happens include C#, Objective C (used for programming iOS
    devices), Java, and C.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreted programs have the advantage that they can be easier to program because
    you can test them quickly, trace what is happening in them more easily, and even
    sometimes type in single instructions to see what they do, without having to go
    through the whole compilation process. For this reason they are widely used for
    introductory languages (for example, Scratch and Alice are interpreted), and also
    for simple programs such as scripts that perform simple tasks, as they can be
    written and tested quickly (for example, languages like PHP, Ruby and Python are
    used in these situations).
  prefs: []
  type: TYPE_NORMAL
- en: The diagram below shows the difference between what happens in an interpreter
    and compiler if you write and run a program that sorts some numbers. The compiler
    produces a machine code program that will do the sorting, and the data is fed
    into that second program to get the sorted result. The interpreter simply does
    the sorting on the input by immediately following the instructions in the program.
    The compiler produces a machine code program that you can distribute, but it involves
    an extra phase in the process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad2b7d4ba1.png)'
  prefs: []
  type: TYPE_IMG
- en: 4.5\. THE WHOLE STORY!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many different programming languages, and new ones are always being
    invented. Each new language will need a new compiler and/or interpreter to be
    developed to support it. Fortunately there are good tools to help do this quickly,
    and some of these ideas will come up in the *Formal Languages* chapter, where
    things like regular expressions and grammars can be used to describe a language,
    and a compiler can be built automatically from the description.
  prefs: []
  type: TYPE_NORMAL
- en: The languages we have discussed in this chapter are ones that you are likely
    to come across in introductory programming, but there are some completely different
    styles of languages that have very important applications. There is an approach
    to programming called [Functional programming](http://en.wikipedia.org/wiki/Functional_programming) where
    all operations are formulated as mathematical functions. Common languages that
    use functional techniques include Lisp, Scheme, Haskel, Clojure and F#; even some
    conventional languages (such as Python) include ideas from functional programming.
    A pure functional programming style eliminates a problem called *side effects*,
    and without this problem it can be easier to make sure a program does exactly
    what it is intended to do. Another important type of programming is [logic programming](http://en.wikipedia.org/wiki/Logic_programming),
    where a program can be thought of as a set of rules stating what it should do,
    rather than instructions on how to do it. The most well-known logic programming
    language is Prolog.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6\. FURTHER READING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 4.6.1\. USEFUL LINKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [TeachICT lesson on programming languages](http://www.teach-ict.com/gcse_computing/ocr/216_programming/programming_languages/miniweb/index.htm) covers
    many of the topics in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CS Online has a [quick overview of this topic](http://courses.cs.vt.edu/~csonline/ProgrammingLanguages/Lessons/Introduction/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wikipedia entries on [Programming language](http://en.wikipedia.org/wiki/Programming_language), [High
    level language](http://en.wikipedia.org/wiki/High-level_programming_language),
    and [`](http://csfieldguide.org.nz/ProgrammingLanguages.html#id2)Low level language
    ’_
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[website including posters comparing programming languages](http://programming.dojo.net.nz/) by
    Samuel Williams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[tutorial comparing programming languages](http://holowczak.com/programming-concepts-tutorial-programmers/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a [discussion of interpreters and compilers](http://pathfinder.scar.utoronto.ca/~dyer/csca57/book_P/node7.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a [poster with full details of the file content in an executable file](http://code.google.com/p/corkami/wiki/PE101?show=content) (the
    exe format)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: David Bolton explains a [Programming Language](http://cplus.about.com/od/introductiontoprogramming/p/programming.htm), [Compiler](http://cplus.about.com/od/introductiontoprogramming/p/compiler.htm),
    and [the difference between Compilers and Interpreters](http://cplus.about.com/od/introductiontoprogramming/a/compinterp.htm).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Computerworld article on the A to Z of programming languages](http://www.computerworld.com.au/article/344826/z_programming_languages/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What is Python?](http://python.about.com/od/gettingstarted/ss/whatispython_4.htm) (compared
    with other languages)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A [very large poster showing a timeline of the development of programming languages](http://www.levenez.com/lang/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hello World program in hundreds of programming languages](http://www.roesler-ac.de/wolfram/hello.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[99 bottles of beer song in hundreds of programming languages](http://99-bottles-of-beer.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5\. DATA REPRESENTATION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5.1\. WHAT’S THE BIG PICTURE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computers are machines that do stuff with information. They let you view, listen,
    create, and edit information in documents, images, videos, sound, spreadsheets
    and databases. They let you play games in simulated worlds that don’t really exist
    except as information inside the computer’s memory and displayed on the screen.
    They let you compute and calculate with numerical information; they let you send
    and receive information over networks. Fundamental to all of this is that the
    computer has to represent that information in some way inside the computer’s memory,
    as well as storing it on disk or sending it over a network.
  prefs: []
  type: TYPE_NORMAL
- en: To make computers easier to build and keep them reliable, everything is represented
    using just two values. You may have seen these two values represented as 0 and
    1, but on a computer they are represented by anything that can be in two states.
    For example, in memory a high or low voltage is used to store each 0 or 1\. On
    a magnetic disk it’s stored with, surprisingly, magnetism (whether a tiny spot
    on the disk is magnetised north or south).
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write what is stored in a computer on paper, we normally use “0” for
    one of the states, and “1” for the other state. If a piece of computer memory
    had the following voltages: “low”, “low”, “high”, “low”, “high”, “high”, “high”,
    “high”, “low”, “high”, “low”, “low”, we could allocate “0” to “low”, and “1” to
    high” and write this sequence down as 001011110100\. While this notation is used
    extensively, and you may often hear the data being referred to as being “0’s and
    1’s”, it is important to remember that a computer does *not* store 0’s and 1’s;
    it has no way of doing this. They are just using physical mechanisms such as high
    and low voltage, north or south polarity, and light or dark materials.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: The use of the two digits 0 and 1 is so common that some of the best known computer
    jargon is used for them. Since there are only two digits, the system is called
    binary. The short word for a “binary digit” is made by taking the first two letters
    and the last letter — a *bit* is just a digit that can have two values.
  prefs: []
  type: TYPE_NORMAL
- en: Every file you save, every picture you make, every download, is just a whole
    lot of bits. Computer scientists don’t spend a lot of time reading bits themselves,
    but knowing how they are stored is really important because it affects the amount
    of space that data will use, the amount of time it takes to send the data to a
    friend (as data that takes more space takes longer to send!) and the quality of
    what is being stored. You may have come across things like “24-bit colour”, “128-bit
    encryption”, “32-bit IPv4 addresses” or “8-bit ASCII”. Understanding what the
    bits are doing enables you to work out how much space will be required to get
    high-quality colour, hard-to-crack secret codes, a unique ID for every device
    in the world, or text that uses more characters than the usual English alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is about some of the different methods that computers use to code
    different kinds of information in patterns of these bits, and how this affects
    the cost and quality of what we do on the computer, or even if something is feasible
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2\. GETTING STARTED
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More than 200 years ago a 15-year-old French boy invented a system for representing
    text using combinations of flat and raised dots on paper so that they could be
    read by touch. The system became very popular with people who had visual impairment
    as it provided a relatively fast and reliable way to “read” text without seeing
    it. Louis Braille’s system is an early example of a “binary” representation of
    data — there are only two symbols (raised and flat), and yet combinations of them
    can be used to represent reference books and works of literature. Each character
    in braille is represented with a cell of 6 dots. Each dot can either be raised
    or not raised. Different numbers and letters can be made by using different patterns
    of raised and not raised dots.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad41d6346e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s work out how many different patterns can be made using the 6 dots in a
    Braille character. When working through the material in this section, a good way
    to draw braille on paper without having to actually make raised dots is to draw
    a rectangle with 6 small circles in it, and to colour in the circles that are
    raised, and not colour in the ones that aren’t raised.
  prefs: []
  type: TYPE_NORMAL
- en: If braille used only 2 dots, there would be 4 patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad41cd8f2e.png)'
  prefs: []
  type: TYPE_IMG
- en: And with 3 dots there would be 8 patterns
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad41c1d181.png)'
  prefs: []
  type: TYPE_IMG
- en: You may have noticed that there are twice as many patterns with 3 dots as there
    are with 2 dots. It turns out that every time you add an extra dot, that gives
    twice as many patterns (why?), so with 4 dots there are 16 patterns, 5 dots has
    32 patterns, and 6 dots has 64 patterns.
  prefs: []
  type: TYPE_NORMAL
- en: So, Braille can make 64 patterns. That’s enough for all the letters of the alphabet,
    and other symbols too, such as digits and punctuation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Braille also illustrates why binary representation is so popular. It would
    be possible to have three kinds of dot: flat, half raised, and raised. A skilled
    braille reader could distinguish them, and with three values per dot, you would
    only need 4 dots to represent 64 patterns. The trouble is that you would need
    more accurate devices to create the dots, and people would need to be more accurate
    at sensing them. If a page was squashed, even very slightly, it could leave the
    information unreadable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Digital devices almost always use two values (binary) for similar reasons:
    computer disks and memory can be made cheaper and smaller if they only need to
    be able to distinguish between two extreme values (such as a high and low voltage),
    rather than fine-grained distinctions between very subtle differences in voltages.
    Arithmetic is also easy with binary values; if you have only two digits (0 and
    1), then there aren’t many rules to learn - adding digits only requires circuits
    to calculate 0+0, 0+1, 1+0 and 1+1\. You might like to work out how many combinations
    of decimal digits you need to be able to add if you’re doing conventional arithmetic!'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, every kind of file on a computer is represented using just a whole
    lot of binary digits — text, pictures, spreadsheets, web pages, songs — *everything* is
    stored using just two values. Even the programs (apps) that you run use binary
    representation — sometimes a program file that the computer can run is referred
    to as a “binary file”, which is a bit odd since every file on a computer is binary!
  prefs: []
  type: TYPE_NORMAL
- en: 5.3\. REPRESENTING TEXT WITH BITS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw above that 64 unique patterns can be made using 6 dots in Braille. Count
    how many different upper-case letters, lower-case letters, numbers, and symbols
    that you could insert into a text editor using your keyboard. (Don’t forget to
    count both of the symbols that share the number keys, and the symbols to the side
    that are for punctuation!) The collective name for these is *characters* e.g.
    a, D, 1, h, 6, *, ], and ~ are all characters.
  prefs: []
  type: TYPE_NORMAL
- en: Would 6 dots (which can represent 64 patterns) be enough to represent all these
    characters? If you counted correctly, you should find that there were more than
    64 characters! How many bits would you need to be able to represent all the characters
    you counted on your keyboard?
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that 7 dots is enough as this gives 128 possible patterns, and
    this is exactly what the ASCII code for text does. ASCII is one of the main systems
    that computers use to represent English text. It was first used commercially in
    1963, and despite the big changes in computers since then, it is still the basis
    of how English text is stored on computers.
  prefs: []
  type: TYPE_NORMAL
- en: ASCII assigned a different pattern of bits to each of the characters, along
    with a few other “control” characters that you don’t need to worry about yet.
    For reasons that we will get to later, each pattern in ASCII is usually stored
    in 8 bits, with one wasted bit, rather than 7 bits. However, the first bit in
    each 8-bit pattern is a 0, meaning there are still only 128 possible patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Below is a table that shows the patterns of bits that ASCII uses for each of
    the characters.
  prefs: []
  type: TYPE_NORMAL
- en: '| Binary | Char | Binary | Char | Binary | Char |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0100000 | Space | 1000000 | @ | 1100000 | [`](http://csfieldguide.org.nz/DataRepresentation.html#id2)
    |'
  prefs: []
  type: TYPE_TB
- en: '| 0100001 | ! | 1000001 | A | 1100001 | a |'
  prefs: []
  type: TYPE_TB
- en: '| 0100010 | “ | 1000010 | B | 1100010 | b |'
  prefs: []
  type: TYPE_TB
- en: '| 0100011 | # | 1000011 | C | 1100011 | c |'
  prefs: []
  type: TYPE_TB
- en: '| 0100100 | $ | 1000100 | D | 1100100 | d |'
  prefs: []
  type: TYPE_TB
- en: '| 0100101 | % | 1000101 | E | 1100101 | e |'
  prefs: []
  type: TYPE_TB
- en: '| 0100110 | & | 1000110 | F | 1100110 | f |'
  prefs: []
  type: TYPE_TB
- en: '| 0100111 | ‘ | 1000111 | G | 1100111 | g |'
  prefs: []
  type: TYPE_TB
- en: '| 0101000 | ( | 1001000 | H | 1101000 | h |'
  prefs: []
  type: TYPE_TB
- en: '| 0101001 | ) | 1001001 | I | 1101001 | i |'
  prefs: []
  type: TYPE_TB
- en: '| 0101010 | * | 1001010 | J | 1101010 | j |'
  prefs: []
  type: TYPE_TB
- en: '| 0101011 | + | 1001011 | K | 1101011 | k |'
  prefs: []
  type: TYPE_TB
- en: '| 0101100 | , | 1001100 | L | 1101100 | l |'
  prefs: []
  type: TYPE_TB
- en: '| 0101101 | - | 1001101 | M | 1101101 | m |'
  prefs: []
  type: TYPE_TB
- en: '| 0101110 | . | 1001110 | N | 1101110 | n |'
  prefs: []
  type: TYPE_TB
- en: '| 0101111 | / | 1001111 | O | 1101111 | o |'
  prefs: []
  type: TYPE_TB
- en: '| 0110000 | 0 | 1010000 | P | 1110000 | p |'
  prefs: []
  type: TYPE_TB
- en: '| 0110001 | 1 | 1010001 | Q | 1110001 | q |'
  prefs: []
  type: TYPE_TB
- en: '| 0110010 | 2 | 1010010 | R | 1110010 | r |'
  prefs: []
  type: TYPE_TB
- en: '| 0110011 | 3 | 1010011 | S | 1110011 | s |'
  prefs: []
  type: TYPE_TB
- en: '| 0110100 | 4 | 1010100 | T | 1110100 | t |'
  prefs: []
  type: TYPE_TB
- en: '| 0110101 | 5 | 1010101 | U | 1110101 | u |'
  prefs: []
  type: TYPE_TB
- en: '| 0110110 | 6 | 1010110 | V | 1110110 | v |'
  prefs: []
  type: TYPE_TB
- en: '| 0110111 | 7 | 1010111 | W | 1110111 | w |'
  prefs: []
  type: TYPE_TB
- en: '| 0111000 | 8 | 1011000 | X | 1111000 | x |'
  prefs: []
  type: TYPE_TB
- en: '| 0111001 | 9 | 1011001 | Y | 1111001 | y |'
  prefs: []
  type: TYPE_TB
- en: '| 0111010 | : | 1011010 | Z | 1111010 | z |'
  prefs: []
  type: TYPE_TB
- en: '| 0111011 | ; | 1011011 | [ | 1111011 | { |'
  prefs: []
  type: TYPE_TB
- en: '| 0111100 | < | 1011100 | \ | 1111100 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 0111101 | = | 1011101 | ] | 1111101 | } |'
  prefs: []
  type: TYPE_TB
- en: '| 0111110 | > | 1011110 | ^ | 1111110 | ~ |'
  prefs: []
  type: TYPE_TB
- en: '| 0111111 | ? | 1011111 | _ | 1111111 |  |'
  prefs: []
  type: TYPE_TB
- en: For example, the letter c (lower-case) in the table has the pattern “01100011”
    (the 0 at the front is just extra padding to make it up to 8 bits). The letter
    o has the pattern “01101111”. You could write a word out using this code, and
    if you give it to someone else, they should be able to decode it exactly.
  prefs: []
  type: TYPE_NORMAL
- en: Computers can represent pieces of text with sequences of these patterns, much
    like Braille does. For example, the word “computers” (all lower-case) would be
    01100011 01101111 01101101 01110000 01110101 01110100 01100101 01110010 01110011.
  prefs: []
  type: TYPE_NORMAL
- en: How would you represent the word “science” in ASCII? What about “Wellington”
    (note that it starts with an upper-case “W”)? How would you represent “358” in
    ASCII (it is three characters, even though it looks like a number)? What about
    the sentence “Hello, how are you?” (look for the comma, question mark, and space
    characters in the ASCII table).
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  prefs: []
  type: TYPE_NORMAL
- en: If you *only* wanted to represent the 26 letters of the alphabet, and weren’t
    worried about upper-case or lower-case, you could get away with using just 5 bits,
    which allows for up to 32 different patterns. Have a look at the last 5 bits of
    each of the 26 lower-case letters in ASCII. Do any of the 26 lower-case letters
    have the same last 5 bits? Have a look at the 26 upper-case letters. Do any of
    the upper-case letters have the same last 5 bits?
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that none of the lower-case letters have the same last
    5 bits, but they do have the same last 5 bits as their corresponding upper-case
    letter!
  prefs: []
  type: TYPE_NORMAL
- en: For example, a = 1100001 and A = 1000001, they both have 00001 as their last
    5 bits. As another example, s = 1110011 and S = 1010011, they both have 10011
    as their last 5 bits.
  prefs: []
  type: TYPE_NORMAL
- en: An easy way to allocate patterns in this 5 bit system would be to just use the
    last 5 bits for each character in the ASCII table. Therefore A would be 00001,
    b would be 00010, c would be 00011, etc.
  prefs: []
  type: TYPE_NORMAL
- en: The word “water” would be 10111 00001 10111 10100 10010
  prefs: []
  type: TYPE_NORMAL
- en: There’s an activity that uses [five-bit text codes hidden in music here](http://csunplugged.org/modem).
  prefs: []
  type: TYPE_NORMAL
- en: English text can easily be represented using ASCII, but what about languages
    such as Chinese where there are thousands of different characters? The 128 patterns
    aren’t nearly enough to represent such languages! That’s where codes that use
    more than 7 bits become important, and in a later section we’ll look at these,
    but first we need to explore binary number representation and develop some efficient
    ways to talk about longer binary numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  prefs: []
  type: TYPE_NORMAL
- en: The name “ASCII” stands for “American Standard Code for Information Interchange”,
    which was a particular way of assigning bit patterns to the characters on a typewriter.
    The ASCII system even includes “characters” for ringing a bell (useful for getting
    attention on old telegraph systems), deleting the previous character (kind of
    an early “undo”), and “end of transmission” (to let the receiver know that the
    message was finished). These days those characters are rarely used, but the codes
    for them still exist (they are the missing patterns in the table above). Nowadays
    ASCII has been surplanted by a code called “UTF-8”, which happens to be the same
    as ASCII if the extra left-hand bit is a 0, but opens up a huge range of characters
    if the left-hand bit is a 1.
  prefs: []
  type: TYPE_NORMAL
- en: There are several other codes that were popular before ASCII, including the [Baudot
    code](http://en.wikipedia.org/wiki/Baudot_code) and [EBCDIC](http://en.wikipedia.org/wiki/EBCDIC).
    A widely used variant of the Baudot code was the “Murray code”, named after New
    Zealand born inventor [Donald Murray](http://en.wikipedia.org/wiki/Donald_Murray_(inventor)).
    One of Murray’s significant improvements was to introduce the idea of “control
    characters”, such as the carriage return (new line). The “control” key still exists
    on modern keyboards.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4\. REPRESENTING NUMBERS WITH BITS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The number system that humans normally use is in base 10 (also known as decimal).
    It’s worth revising quickly, because binary numbers use the same ideas as decimal
    numbers, just with fewer digits!
  prefs: []
  type: TYPE_NORMAL
- en: In decimal, the value of each digit in a number depends on its place in the
    number. For example, in the amount $123, the 3 represents $3, whereas the 1 represents
    $100\. Each place value in a number is worth 10 times more than the place value
    to its right, i.e. there are the “ones”, the “tens”, the “hundreds”, the “thousands”
    the “ten thousands”, the “hundred thousands”, the “millions”, etc. Also, there
    are 10 different digits (0,1,2,3,4,5,6,7,8,9) that can be at each of those place
    values.
  prefs: []
  type: TYPE_NORMAL
- en: If you were only able to use one digit to represent a number, then the largest
    number would be 9\. After that, you need a second digit, which goes to the left,
    giving you the next ten numbers (10, 11, 12... 19). It’s because we have 10 digits
    that each one is worth 10 times as much as the one it its right.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have encountered different ways of expressing numbers using “expanded
    form”. For example, if you want to write the number 90328 in expanded form you
    might have written it as:'
  prefs: []
  type: TYPE_NORMAL
- en: 90328 = 90000 + 300 + 20 + 8
  prefs: []
  type: TYPE_NORMAL
- en: 'A more sophisticated way of writing it is:'
  prefs: []
  type: TYPE_NORMAL
- en: 90328 = (9 x 10000) + (0 x 1000) + (3 x 100) + (2 x 10) + (8 x 1)
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve learnt about exponents, you could write it as 90328 = (9 x 104) +
    (0 x 103) + (3 x 102) + (2 x 101) + (8 x 100)
  prefs: []
  type: TYPE_NORMAL
- en: Remember that any number to the power of 0 is 1\. i.e. the 8 x 100 is 8, because
    the 100 is 1.
  prefs: []
  type: TYPE_NORMAL
- en: The key ideas to notice from this are that the digit on the right (such as the
    8 in 90328) is the one that’s worth the least, and that because we have 10 digits,
    each place is worth 10 times as much as the one to the right (e.g. the 2 in 90328
    is the number of tens, the 3 is the number of 100s, and so on). Exactly the same
    happens with binary numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.1\. BINARY NUMBERS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed earlier, computers can only store information using bits, which
    only have 2 possible states. This means that they cannot represent base 10 numbers
    using digits 0 to 9, the way we write down numbers in decimal; instead, they use
    a base 2 number system, also called binary.
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  prefs: []
  type: TYPE_NORMAL
- en: The base 10 (decimal) system is sometimes called denary, which is more consistent
    with the the name binary for the base 2 system. The word “denary” also refers
    to the Roman denarius coin, which was worth ten asses (an “as” was a copper or
    bronze coin).
  prefs: []
  type: TYPE_NORMAL
- en: Because binary is base 2, there are only 2 possible digits (0 and 1), as opposed
    to the 10 in our standard number system, and each place value is 2 times bigger
    than the one to its right (in contrast to our base 10 number system where each
    place is 10 times bigger).
  prefs: []
  type: TYPE_NORMAL
- en: The interactive below illustrates how this binary number system represents decimal
    numbers. Have a play around with it to see what patterns you can see. The decimal
    (base 10) representation for the binary number currently shown is given by the
    interactive on the far right.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad41b5496e.png)Click to load the'
  prefs: []
  type: TYPE_NORMAL
- en: binary number interactive](http://csfieldguide.org.nz/_static/widgets/DR/DR-base-conversion/public_html/index.html?base=2&columns=7&lines=A,B,C&offset=0)
  prefs: []
  type: TYPE_NORMAL
- en: To ensure you are understanding correctly how to use the interactive, verify
    that when you enter the binary number 101101 it shows that the decimal representation
    is 45, that when you enter 100000 it shows that the decimal representation is
    32, and when you enter 001010 it shows the decimal representation is 10.
  prefs: []
  type: TYPE_NORMAL
- en: You should try using the interactive to convert a decimal number to binary.
    For example, choose a number less than 61 (perhaps your house number, a friend’s
    age, or the day of the month you were born on), set all the binary digits to zero,
    and then start with the *left-most* digit (32), trying out if it should be zero
    or one. See if you can find a method for converting the number without too much
    trial and error.
  prefs: []
  type: TYPE_NORMAL
- en: Can you figure out the binary representation for 23 without using the interactive?
    What about 4, 0, and 32? Check all your answers using the interactive to verify
    they are correct.
  prefs: []
  type: TYPE_NORMAL
- en: What is the largest number you can make with this binary interactive? What is
    the smallest? Is there any integer value in between the biggest and the smallest
    that you can’t make? Are there any numbers with more than one representation?
    Why/ why not?
  prefs: []
  type: TYPE_NORMAL
- en: You have probably noticed from the interactive that when set to 1, the leftmost
    bit (the “most significant bit”) adds 32 to the total, the next adds 16, and then
    the rest add 8, 4, 2, and 1 respectively. When set to 0, a bit does not add anything
    to the total. So the idea is to make numbers by adding some or all of 32, 16,
    8, 4, 2, and 1 together, and each of those numbers can only be included once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than just using trial and error to figure out what a decimal number
    is in binary, could you figure out a systematic approach? Have a look at what
    100000 is in binary. What about 011111? Is it possible to make a number over 32
    if the most significant bit is set to a 0? Why? And what about 001000 and 000111?
    Can you see a pattern that would lead to a systematic way of converting decimal
    numbers to binary? Hint: start with deciding the leftmost bit, and then work along
    to the right, bit by bit.'
  prefs: []
  type: TYPE_NORMAL
- en: So what happens if we have fewer than 6 bits? For example, with 5 bits, the
    place values would be 16, 8, 4, 2 and 1, so the largest value is 11111 in binary,
    or 31 in decimal. What’s the largest value you can store with 4 bits? 3 bits?
  prefs: []
  type: TYPE_NORMAL
- en: What would happen if we have 7 bits instead of 6? The seventh bit would have
    a value of 64, and it would be possible to store numbers up to 127.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extra for Experts**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Can you figure out a systematic approach to counting in binary? i.e. start
    with the number 0, then increment it to 1, then 2, then 3, etc, all the way up
    to the highest number that can be made with the 7 bits. Try counting from 0 to
    16, and see if you can detect a pattern. Hint: Think about how you add 1 to a
    number in base 10\. e.g. how do you work out 7 + 1, 38 + 1, 19 + 1, 99 + 1, 230899999
    + 1, etc? Can you apply that same idea to binary?'
  prefs: []
  type: TYPE_NORMAL
- en: Using your new knowledge of the binary number system, can you figure out a way
    to count to higher than 10 using your 10 fingers? What is the highest number you
    can represent using your 10 fingers? What if you included your 10 toes as well
    (so you have 20 fingers and toes to count with).
  prefs: []
  type: TYPE_NORMAL
- en: An important concept with binary numbers is the range of values that can be
    represented using a given number of bits. One bit on its own might not seem very
    useful, but it’s enough to store things like the state of a checkbox (checked
    or not checked). When we have 8 bits the binary numbers start to get useful —
    they can represent values from 0 to 255, so it is enough to store someone’s age,
    the day of the month, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Groups of 8 bits are so useful that they have their own name: a **byte**. Computer
    memory and disk space is usually divided up into bytes, and bigger values are
    stored using more than one byte. For example, two bytes (16 bits) are enough to
    store numbers from 0 to 65,535\. Four bytes (32 bits) can store numbers up to
    42,94,967,295\. You can check these numbers by working out the place values of
    the bits. Every bit that’s added will double the range of the number.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  prefs: []
  type: TYPE_NORMAL
- en: Candles on birthday cakes use the base 1 numbering system, where each place
    is worth 1 times the one to its right(!) For example, the number 3 is 111, and
    10 is 1111111111\. This can cause problems as you get older — if you’ve ever seen
    a cake with 100 candles on it, you’ll be aware that it’s a serious fire hazard.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad3dc32698.png)'
  prefs: []
  type: TYPE_IMG
- en: Luckily it’s possible to use binary notation for birthday candles — each candle
    is either lit or not lit. For example, if you are 18, the binary notation is 10010,
    and you need 5 candles (with only two of them lit).
  prefs: []
  type: TYPE_NORMAL
- en: There’s a [video on using binary notation for counting up to 1023 on your hands,
    as well as using it for birthday cakes](http://www.youtube.com/watch?v=GUqle9RE3Y8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad3db99b7d.png)'
  prefs: []
  type: TYPE_IMG
- en: 5.4.2\. SHORTHAND FOR BINARY NUMBERS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the time binary numbers are stored electronically, and we don’t need
    to worry about making sense of them. But sometimes it’s useful to be able to write
    down and share numbers, such as the unique identifier assigned to each digital
    device (MAC address), or the colours specified in an HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing out long binary numbers is tedious — for example, suppose you need
    to copy down the 16-bit number 0101001110010001\. A widely used shortcut is to
    break the number up into 4-bit groups (in this case, 0101 0011 1001 0001), and
    then write down the digit that each group represents (giving 5391). There’s just
    one small problem: each group of 4 bits can go up to 1111, which is 15, and the
    digits only go up to 9.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is simple: we introduce symbols for the digits for 1010 (10) to
    1111 (15), which are just the letters A to F. So, for example, the 16-bit binary
    number 1011 1000 1110 0001 can be written more concisely as B8E1\. The “B” represents
    the binary 1011, which is the decimal number 11, and the E represents binary 1110,
    which is decimal 14.'
  prefs: []
  type: TYPE_NORMAL
- en: Because we now have 16 digits, this representation is called hexadecimal (or
    hex for short). Converting between binary and hexadecimal is very simple, and
    that’s why hexadecimal is a very common way of writing down large binary numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a full table of all the 4-bit numbers and their hexadecimal digit equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Binary | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001
    | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |'
  prefs: []
  type: TYPE_TB
- en: '| Hex | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |'
  prefs: []
  type: TYPE_TB
- en: For example, the largest 8-bit binary number is 11111111\. This can be written
    as FF in hexadecimal. Both of those representations mean 255 in our conventional
    decimal system (you can check that by converting the binary number to decimal).
  prefs: []
  type: TYPE_NORMAL
- en: The largest 16 bit binary number is 1111111111111111, or FFFF in hexadecimal.
    Both of these represent 65535 in decimal.
  prefs: []
  type: TYPE_NORMAL
- en: The hexadecimal system is also known as base 16\. The following interactive
    converts hexadecimal numbers to decimal (base 10), which provides another way
    of thinking about them. But don’t forget that the main point is that hexadecimal
    is an easy shorthand for binary representation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad3d921d02.png)Click to load the widget](http://csfieldguide.org.nz/_static/widgets/DR/DR-base-conversion/public_html/index.html?base=16&columns=7&lines=A,B,C&offset=0)'
  prefs: []
  type: TYPE_NORMAL
- en: Which notation you use will depend on the situation; binary numbers represent
    what is actually stored, but can be confusing to read and write; hexadecimal numbers
    are a good shorthand; and decimal numbers are used if you’re trying to understand
    the meaning of the number. All three get used in computer science.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.3\. HOW TO BINARY NUMBERS AFFECT US?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The length of a binary number determines the range of values it can represent.
    Often on computers we are dealing with text, images and sound rather than numbers,
    but they do appear in quite a few places, and the accuracy with which they are
    represented can affect what we can do on a computer.
  prefs: []
  type: TYPE_NORMAL
- en: For example, numbers in spreadsheets usually have a finite precision. Try putting
    the formula “=1/3” into a spreadsheet, and have it represented with maximum accuracy.
    How many decimal places does it store? This will be dictated by the number of
    binary digits that the spreadsheet is storing.
  prefs: []
  type: TYPE_NORMAL
- en: Many programming languages allow the programmer to specify the number of bits
    used to represent each variable (e.g. in the C language a “short int” is 16 bits
    or more, and a “long int” is at least 32 bits); if you are working with a language
    then they could investigate limits on how numbers are represented. Note that some
    languages, including Python, seamlessly changes the size of the representation
    of an integer if it gets too large, so it’s harder to explore these issues in
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: Another situation where different numbers of bits in a representation is important
    is IP (Internet Protocol) and MAC (media access control) addresses for devices;
    the recent change from IPv4 to IPv6 was driven by the number of devices you could
    represent, and if you are interested in networks could explore the number of bits
    used for an address, and how many possible devices could exist before we run out
    of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5\. REPRESENTING IMAGES WITH BITS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: This section assumes that you understand binary numbers. If you are confused
    by binary numbers still, you should go back to the binary numbers section and
    work through the material there again until you understand it. The first part
    of this section is possible to understand without understanding binary numbers,
    although in order to actually use the material for assessment purposes, you will
    need to understand binary numbers, as the key idea is representing colours using*bits*,
    and the bits in colours are decided based on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: In school or art class you may have mixed different colours of paint or dye
    together in order to make new colours. This was probably very helpful if the exact
    colour you wanted was not present in your palette, in addition to just being fun
    to experiment with! When mixing paints, red and blue would give purple. If you
    mixed yellow and blue, you would get green. If you mixed red and yellow, you would
    get orange. If you mixed an even amount of the 3 primary colours; blue, red, and
    yellow together, you should get black, although often it would be a murky brown.
    By mixing together various amounts of the three primary colours, along with white
    and black, you can make many different colours.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, while the colours blue, red and yellow are commonly used in art classes,
    the very similar primary colours that work better for printing are cyan, magenta
    and yellow (CMY), which are commonly found in computer printers as well as printing
    presses. This kind of mixing is called “subtractive mixing”, because it starts
    with a white canvas or paper, and subtracts colour from it. The below interactive
    allows you to experiment with these in case you’re not familiar with them, or
    in case you just like mixing colours. We’ve also added a “black” mix; it’s not
    strictly necessary (you can get black by putting all the other colours on full),
    but it’s useful for printers because it’s such a common colour.
  prefs: []
  type: TYPE_NORMAL
- en: CMY COLOUR MIXER
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Cyan
  prefs: []
  type: TYPE_NORMAL
- en: 0182255
  prefs: []
  type: TYPE_NORMAL
- en: Magenta
  prefs: []
  type: TYPE_NORMAL
- en: 0183255
  prefs: []
  type: TYPE_NORMAL
- en: Yellow
  prefs: []
  type: TYPE_NORMAL
- en: '036255'
  prefs: []
  type: TYPE_NORMAL
- en: Computer screens and related devices also rely on mixing colours, except they
    go about it in quite a different way — they use a different set of primary colours,
    because they are *additive*, starting with a black screen and adding colour to
    it. For additive colour on computers, the colours red, green and blue (RGB) are
    used. Each pixel on a screen has 3 tiny lights; one red, one green, and one blue.
    By increasing and decreasing the amount of light coming out of each of these 3
    lights, all the different colours can be made.
  prefs: []
  type: TYPE_NORMAL
- en: You can try additive colours in the following interactive; try different combinations
    of each slider. How do you generate yellow? What happens if they are all at zero?
    All at full value (255)? Halfway? What happens if one colour is at full, and the
    other two are at halfway? How do you get shades of purple, yellow, orange, and
    pink? What happens when you have the same amount of each colour? How do you get
    black? How do you get white?
  prefs: []
  type: TYPE_NORMAL
- en: The key idea is that you can specify the colour of a pixel using three numbers.
    In the above example, each number is from 0 to 255\. With 256 possible values
    for each of the three components, that gives 256 x 256 x 256 = 16,777,216 possible
    colours, which is more than the human eye can detect. In other words, using just
    three numbers, you can specify pretty much any colour you want — and probably
    a lot that you don’t.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, a computer screen or printout doesn’t have just one colour on it
    — it has millions of small pixels, each of which has a particular colour.
  prefs: []
  type: TYPE_NORMAL
- en: The following interactive allows you to zoom in on an image to see the pixels
    that are used to represent it. Each pixel is a solid colour square, and the computer
    needs to store the colour for each pixel. If you zoom in far enough, the interactive
    will show you the red-green-blue values for each pixel. You can pick a pixel and
    put the values on the slider above - it should come out as the same colour as
    the pixel.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad3d6b6ddd.png)Click to load'
  prefs: []
  type: TYPE_NORMAL
- en: Pixel Interactive](http://csfieldguide.org.nz/_static/interactives/dr/pixel-values/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: The word **pixel** is short for “picture element”. On computer screens and printers
    an image is created by a grid of pixels, each one set to the required colour.
    A pixel is typically a fraction of a millimeter across, and images can be made
    up of millions of pixels (one megapixel is a million pixels).
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad3d5a5a58.jpg)](http://commons.wikimedia.org/wiki/File:Pixel_geometry_01_Pengo.jpg#file)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  prefs: []
  type: TYPE_NORMAL
- en: The human eye has millions of light sensors in it, and the ones that detect
    colour are called “cones”. There are three different kinds of cones, which detect
    red, blue, and green light respectively. Colours are perceived by the amount of
    red, blue, and green light in them. Computer screen pixels take advantage of this
    by releasing the amounts of red, blue, and green light that will be perceived
    as the desired colour by your eyes. So when you see “purple”, it’s really the
    red and blue cones in your eyes being stimulated, and your brain converts that
    to a perceived colour.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about RGB displays, see [RGB on Wikipedia](http://en.wikipedia.org/wiki/Rgb);
    for more information about the eye sensing the three colours, see [Cone cell](http://en.wikipedia.org/wiki/Cone_cell) and [trichromacy](http://en.wikipedia.org/wiki/Trichromacy) on
    Wikipedia.
  prefs: []
  type: TYPE_NORMAL
- en: Even the smallest computer screens have millions of *pixels* on them, and the
    computer needs to represent a colour for each one of those pixels. These days
    photographs are measured in *megapixels* (millions of pixels). To store the image,
    your computer is storing a colour for every one of those pixels, and each of those
    could be using the three numbers above. So a 2 megapixel photo, in its simplest
    form, needs 6 million numbers to be recorded to represent it accurately.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.1\. REPRESENTING HIGH QUALITY IMAGES USING BITS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So now, how can computers represent each possible colour using bits? You may
    have noticed in the above interactive that for each of red, green, and blue, there
    are 256 different positions the slider can be in (don’t forget to include setting
    the slider to 0). From the numbers section, you may remember that to get 256 different
    possibilities, you need 8 bits. So for example, to represent the current value
    of the red slider, you would need 8 bits (28 = 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 =
    256).
  prefs: []
  type: TYPE_NORMAL
- en: Because there are three primary colours, each of which has 256 different possible
    values, we need 24 bits in order to have enough possible bit patterns to represent
    all the possible colours that this scheme can represent (3 x 8 = 24).
  prefs: []
  type: TYPE_NORMAL
- en: If you calculate 224 (i.e. the number of bit patterns you can get with 24 bits),
    and 256 x 256 x 256 (i.e. the number of possible colours that can be represented
    using the above interactive), you will find that the result of these two calculations
    are the same; 16,777,216\. This means that there are 16,777,216 different possible
    colours that can be represented using this scheme, and that’s more colours than
    most people can distinguish, which is why 24-bit colour is regarded as high quality.
  prefs: []
  type: TYPE_NORMAL
- en: So now that we know we’ll need 24 bits to represent all the possible colours
    that can be made from the scheme in the interactive, how can we assign colours
    to bit patterns?
  prefs: []
  type: TYPE_NORMAL
- en: A sensible way is to use 3 binary numbers that represent the amount of each
    of red, green, and blue in the pixel. In order to do this, you can simply convert
    the decimal values on the interactive that specify how much of each of the primary
    colours is making up the resulting colour into binary, and put them side by side
    to make a full pattern of 24 bits. Because consistency is important in order for
    a computer to make sense of the bit pattern, the binary number for red should
    be put first, followed by green, and then finally blue.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad3d4a9804.png)'
  prefs: []
  type: TYPE_IMG
- en: As an example, suppose you have the colour that has red = 145, green = 50, and
    blue = 123 (it is a shade of purple shown in the square above; you can see it
    if you set the sliders to those values in the interactive above). You need to
    convert each of the 3 numbers into binary, using 8 bits for each. You can either
    do this by hand if you are confident with binary numbers, use [this binary number
    interactive with 8 columns](http://csfieldguide.org.nz/_static/widgets/DR/DR-base-conversion/public_html/index.html?base=16&columns=7&lines=A,B,C&offset=0),
    or use a [binary piano](http://csfieldguide.org.nz/_static/files/DR-BinaryPianoUC.pdf).
    You should get red = 10010001, green = 00110010, and blue = 01111011\. This can
    be written as 100100010011001001111011, which is the bit pattern for representing
    that shade of purple. Note that there are no spaces between the 3 numbers, as
    this is a pattern of bits rather than actually being 3 binary numbers, and computers
    don’t have any such concept of a space between bit patterns anyway — everything
    must be a 0 or a 1\. You could write it with spaces to make it easier to read,
    and to represent the idea that they are likely to be stored in 3 8-bit bytes,
    but inside the computer memory there is just a sequence of high and low voltages,
    so even writing 0 and 1 is an arbitrary notation. Note that all leading and trailing
    0’s on each of the components are kept — without them, it would be representing
    a shorter number. Make sure you work through this example yourself, to understand
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: As long as the computer knows this is a colour (typically because it has been
    taken from a file that is specifying colours, such as GIF or HTML), it will know
    that the first 8 bits specify the amount of red, the next 8 bits specify the amount
    of green, and the last 8 bits specify the amount of blue. The computer won’t actually
    convert the number into decimal, as it works with the binary directly — most of
    the process that takes the bits and makes the right pixels appear is typically
    done by a graphics card or a printer.
  prefs: []
  type: TYPE_NORMAL
- en: 24 bit colour is sometimes referred to in settings as “True Color” (because
    it is more accurate than the human eye can see). On Apple systems, it is called
    “Millions of colours”.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.2\. HEXADECIMAL COLOUR CODES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When writing HTML code, you often need to specify colours for text, backgrounds,
    etc. One way of doing this is to specify the colour name, for example “red”, “blue”,
    “purple”, or “gold”. The use of names limits the number of colours you can represent
    and the shade might not be exactly the one you wanted. A better way is to specify
    the 24 bit colour directly. The problem is that strings of 24 binary digits are
    hard to read, and so colours in HTML use hexadecimal codes as a quick way to write
    the 24 bits, for example #00FF9E. The hash sign just means that it should be interpreted
    as a hexadecimal representation, and since each hexadecimal digit corresponds
    to 4 bits, the 6 digits represent 24 bits of colour information. This “hex triplet”
    format is used in HTML pages to specify colours for things like the background
    of the page, the text, and the colour of links. It is also used in CSS, SVG, and
    other applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the 24 bit colour example earlier, the 24 bit pattern was 100100010011001001111011\.
    This can be broken up into groups of 4 bits: 1001 0001 0011 0010 0111 1011\. Substituting
    a hexadecimal digit for each of the 4-bit groups (using the table above) gives
    91327B. This is the hexadecimal code for this colour!'
  prefs: []
  type: TYPE_NORMAL
- en: The hexadecimal notation is extremely useful for people to read or write, as
    it is much easier to type 6 characters rather than 24 1’s and 0’s when specifying
    a colour!
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to specify the background colour of a page in HTML, the body tag
    can have a hexadecimal colour added to it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can use an HTML page to experiment with hexadecimal colours.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how these hexadecimal colour codes are derived also allows you
    to change them slightly without having to refer back the colour table, when the
    colour isn’t exactly the one you want. Remember that in the 24 bit color code,
    the first 8 bits specify the amount of red (so this is the first 2 digits of the
    hexadecimal code), the next 8 bits specify the amount of green (the next 2 digits
    of the hexadecimal code), and the last 8 bits specify the amount of blue (the
    last 2 digits of the hexadecimal code). To increase the amount of any one of these
    colours, you can change the appropriate hexadecimal letters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, #000000 has zero for red, green and blue, so setting a higher
    value to the middle two digits (such as #002300) will add some green to the colour.
    What colours will the following codes give? #FF0000, #FF00FF, #FFFFFF ? (You can
    try them out using an HTML file).'
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.3\. REPRESENTING COLOURS USING FEWER BITS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What if we were to use fewer than 24 bits to represent each colour, i.e. each
    slider didn’t have as many possible positions it could be in? The following interactive
    shows what would happen with this limitation. You can select a colour by clicking
    on the image on the left, and then try to match it with the 24-bit colour sliders
    (if it’s too difficult, the system will offer to help you; to move the sliders
    by small amounts, you can use the arrow keys).
  prefs: []
  type: TYPE_NORMAL
- en: It should be possible to get a perfect match using 24 bit colour. Now try the
    8-bit sliders. These ones have only 8 values for red and green, and just 4 values
    for blue!
  prefs: []
  type: TYPE_NORMAL
- en: The above system used 3 bits to specify the amount of red (8 possible values),
    3 bits to specify the amount of green (again 8 possible values), and 2 bits to
    specify the amount of blue (4 possible values). This gives a total of 8 bits (hence
    the name), which can be used to make 256 different bit patterns, and thus can
    represent 256 different colours.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this scheme to represent all the pixels of an image takes one third of
    the number of bits required for 24-bit colour, but it is not as good at showing
    smooth changes of colours or subtle shades, because there are only 256 possible
    colors for each pixel. This is one of the big tradeoffs in data representation:
    do you allocate less space (fewer bits), or do you want higher quality?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: The number of bits used to represent the colours of pixels in a particular image
    is sometimes referred to as its “colour depth” or “bit depth”. For example, an
    image or display with a colour depth of 8-bits has a choice of 256 colours for
    each pixel. There is [more information about this in Wikipedia](http://en.wikipedia.org/wiki/Color_depth).
    Drastically reducing the bit depth of an image can make it look very strange;
    sometimes this is used as a special effect called “posterisation” (ie. making
    it look like a poster that has been printed with just a few colours).
  prefs: []
  type: TYPE_NORMAL
- en: The following interactive shows what happens to images when you use a smaller
    range of colours (including right down to zero bits!) You can choose an image
    using the menu. In which cases is the change in quality most noticeable? In which
    is it not? In which would you actually care about the colours in the image? In
    which situations is colour actually not necessary (i.e. we are fine with two colours)?
  prefs: []
  type: TYPE_NORMAL
- en: One other interesting thing to think about is whether or not we’d want more
    than 24 bit colour. It turns out that the human eye can only differentiate around
    10 million colours, so the 16 million provided by 24 bit colour is already beyond
    what our eyes can distinguish. However, if the image were to be processed by some
    software that enhances the contrast, it may turn out that 24-bit colour isn’t
    sufficient. Choosing the representation isn’t simple!
  prefs: []
  type: TYPE_NORMAL
- en: So is it worth the space saving to put up with a lower quality image? An image
    represented using 24 bit colour would have 24 bits per pixel. In 600 x 800 pixel
    image (which is a reasonable size for a photo), this would contain 600 x 800 =
    480,000 pixels, and thus would use 480,000 x 24 bits = 11,520,000 bits. This works
    out to around 1.44 megabytes. If we use 8-bit colour instead, it will use a third
    of the memory, so it would save nearly a megabyte of storage.
  prefs: []
  type: TYPE_NORMAL
- en: 8 bit colour is not used much anymore, although it can still be helpful in situations
    such as accessing a computer desktop remotely on a slow internet connection, as
    the image of the desktop can instead be sent using 8 bit colour instead of 24
    bit colour. Even though this may cause the desktop to appear a bit strangely,
    it doesn’t stop you from getting whatever it was you needed to get done, done.
    There are also other situations where colour doesn’t matter at all, for example
    diagrams, and black and white printed images.
  prefs: []
  type: TYPE_NORMAL
- en: If space really is an issue, then this crude method of reducing the range of
    colours isn’t usually used; instead, compression methods such as JPEG, GIF and
    PNG are used. These make much more clever compromises to reduce the space that
    an image takes, without making it look so bad, including choosing a better palette
    of colours to use rather than just using the simple representation discussed above.
    However, compression methods require a lot more processing, and images need to
    be decoded to the representations discussed in this chapter before they can be
    displayed. We will look at compression methods in a later chapter. The ideas in
    this present chapter more commonly come up when designing systems (such as graphics
    interfaces) and working with high-quality images (such as RAW photographs), and
    typically the goal is to choose the best representation possible without wasting
    too much space.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of the New Zealand NCEA standards, reducing the bit depth of
    an image is ok as a second compression method to compare to specialised compression
    methods (JPEG, PNG, GIF etc.), but isn’t very suitable for explaining how compression
    works (in the Achieved level requirements).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how the 24 bit and 8 bit colour schemes work and how to represent
    them using bits, what are the implications of this in practice? The following
    interactive can be used to upload your own image, and experiment with allocating
    different numbers of bits to each colour. You can use it to demonstrate the effect
    of the different numbers of bits for this data representation.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6\. GENERAL REPRESENTATIONS OF TEXT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the introduction we looked at 8-bit ASCII representations of text (which
    really use 7 bits, allowing for 128 different symbols). As with any other kind
    of data represented in binary, we can get improvements by considering larger (or
    smaller) representations.
  prefs: []
  type: TYPE_NORMAL
- en: In the [*curiosity section*](http://csfieldguide.org.nz/DataRepresentation.html#curiosity-music) earlier
    we observed that 5 bits are sufficient for simple coding of the English alphabet,
    and for very slow coding systems (like the [video that contains hidden text using
    musical notes](http://www.youtube.com/watch?v=L-v4Awj_p7g)) using 5 bits instead
    of 8 can save some time. The braille system uses only 6 bits for each character,
    which allows for 64 different characters, and it is also better than using 8 bits
    since it would take more paper and more time to read if the longer code was used.
  prefs: []
  type: TYPE_NORMAL
- en: But some languages have way more than 32, or 64, or even 128 characters in their
    alphabet. In fact, the majority of the world’s population use such languages!
    In this case, longer codes are needed, and the most widely used approach is a
    system called *Unicode*. A commonly used version of Unicode allows 16 bits per
    character. Because every extra bit that is added doubles the number of patterns
    possible, 16-bit codes have many more representations than 8 bit codes. In fact,
    with 16 bits there are 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x
    2 x 2 = 216 = 65,536 patterns that can be represented. This is enough to assign
    a unique pattern of bits to the main characters in the most common languages,
    although there are also standards that allow 32 bits (4 bytes) for each character.
  prefs: []
  type: TYPE_NORMAL
- en: The Unicode table is far too big to display in this book, but you can find a
    variety of tables on the internet, and use them to look up codes. [This website
    displays all unicode characters](http://unicode-table.com/en/) with geographical
    data for appropriate characters. The 16- and 32-bit codes are usually written
    using hexadecimal since this is an easy abbreviation for the long binary codes,
    and sections of the Unicode alphabet (different languages) tend to be in multiples
    of 16.
  prefs: []
  type: TYPE_NORMAL
- en: The modern codes associated with Unicode are usually flexible in the size of
    the representation, so 8-bit characters can be used if that is sufficient, but
    16- or 32- bit characters can be invoked for larger alphabets. If you are investigating
    these codes, you will come across standards such as the Universal Character Set
    (UCS), the Unicode/UCS Transformation Format (UTF-8 UTF-16, etc.), and the GB
    18030 standard (which was mandated in the People’s Republic of China from the
    year 2000).
  prefs: []
  type: TYPE_NORMAL
- en: 5.7\. COMPUTERS REPRESENTING NUMBERS IN PRACTICE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common place that numbers are stored on computers is in spreadsheets or databases.
    Some of the things that we might think of as numbers, such as the telephone number
    (03) 555-1234, aren’t actually stored as numbers, as they contain important characters
    (like dashes and spaces) as well as the leading 0 which would be lost if it was
    stored as a number (the above number would come out as 35551234, which isn’t quite
    right). On the other hand, things that don’t look like a number (such as “30 January
    2014”) are often stored using a value that is converted to a format that is meaningful
    to the reader (try typing two dates into Excel, and then subtract one from the
    other — the result is a useful number). Numbers are commonly used to store things
    as diverse as student marks, prices, statistics, and scientific readings.
  prefs: []
  type: TYPE_NORMAL
- en: Any system that stores numbers needs to make a compromise between the number
    of bits allocated to store the number, and the range of values that can be stored.
    For example, Excel spreadsheets have a maximum value that can be stored — try
    calculating 1/3, and display it to as many places of accuracy as possible. In
    some systems (like the Java and C programming languages and databases) it’s possible
    to specify how accurately numbers should be stored; in others it is fixed in advance
    (such as in spreadsheets). Some are able to work with arbitrarily large numbers
    by increasing the space used to store them as necessary (e.g. integers in the
    Python programming language).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two commonly used kinds of numbers: integers and floating point numbers.
    Integers are what you might know as whole numbers, and can be positive or negative,
    whereas floating point numbers can have a decimal point in them, and can also
    be positive or negative. In this section we are just going to focus on integers,
    as representing floating point numbers is a bit more difficult to understand (but
    well worth understanding if you use them a lot)!'
  prefs: []
  type: TYPE_NORMAL
- en: The binary number representation in the previous section only allowed us to
    represent positive numbers. In practice, we will want to be able to represent
    negative numbers as well (such as when the amount of money earned goes to a negative
    amount, or the temperature falls below zero!) In our normal representation of
    base 10 numbers, we represent negative numbers by putting a minus sign in front
    of the number. On a computer we don’t have minus signs, but we can do it by allocating
    one extra bit, called a *sign* bit, to represent the minus sign. We can choose
    the leftmost bit as the sign bit — when the sign bit is set to “0”, that means
    the number is positive and when the sign bit is set to “1”, the number is negative
    (just as if there were a minus sign in front of it). For example, if we wanted
    to represent the number 41 using 6 bits (like above) along with an additional
    7th bit that is the sign bit, assuming the sign bit is first, we would represent
    it by 0101001\. The first bit is a 0, meaning the number is positive, then the
    remaining 6 bits give 41, meaning the number is +41\. If we wanted to make -59,
    this would be 1111011\. The first bit is a 1, meaning the number is negative,
    and then the remaining 6 bits give 59, meaning the number is -59.
  prefs: []
  type: TYPE_NORMAL
- en: Using 7 bits as described above (one for the sign, and 6 for the actual number),
    what would be the binary representations for 1, -1, -8, 34, -37, -88, and 102?
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have 8-bit numbers, with the left-most bit as a sign bit. What would
    the decimal values be for the following 10000110? 01111111? How about 10000000?
  prefs: []
  type: TYPE_NORMAL
- en: The representation 10000000 highlights a problem with this notation, as it represents
    the number -0, which is the same as 0\. That is, there are two ways to represent
    the number 0, which is wasteful, and potentially confusing.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that there’s a notation called “two’s complement” for negative
    numbers, which avoids this wastage, and more importantly, makes it easier to do
    arithmetic with negative numbers. It’s beyond what is needed for this topic, but
    the following box gives some more information if you’d like to look into it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extra for Experts**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Negative numbers are more often stored on computers using a system called “two’s
    complement”. This system makes it very easy to do arithmetic without having to
    treat negative numbers as a special case, so it’s faster and uses less circuitry.
    The principle is based on a fairly simple idea: for example, in decimal, if you
    had to subtract the number 4 from a value, it’s the same if you add 6 and subtract
    10\. Using the complement of the number -4 (i.e. 6) plus an indicator that it’s
    negative can make calculations quicker and simpler. A similar approach applies
    in binary, and it’s even easier because there are only two digits. More[information
    is available here on how negative numbers work](http://www.i-programmer.info/babbages-bag/200-binary-negative-numbers.html?start=1),
    and also on the [Wikipedia page about two’s complement](http://en.wikipedia.org/wiki/Two%27s_complement),
    although it’s quite technical.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  prefs: []
  type: TYPE_NORMAL
- en: In some programming languages there isn’t a check for when a number gets too
    big (overflows). For example, if you have an 8-bit number using two’s complement,
    then 01111111 is the largest number (127), and if you add one without checking,
    it will change to 10000000, which happens to be the number -128\. This can cause
    serious problems if not checked for, and is behind a variant of the Y2K problem,
    called the [Year 2038 problem](http://en.wikipedia.org/wiki/Year_2038_problem),
    involving a 32-bit number overflowing for dates on Tuesday, 19 January 2038.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad3d4208cc.png)](http://xkcd.com/571/)'
  prefs: []
  type: TYPE_NORMAL
- en: Because of the way computer memory is constructed, memory is most commonly used
    in chunks of 8 bits or 32 bits (or even 64 bits) at a time. That means that if
    the computer is representing an integer as a binary number with a sign bit, it
    will commonly use 32 bits, where the first bit is the sign bit, and the other
    31 bits represent the value of the number.
  prefs: []
  type: TYPE_NORMAL
- en: In a computer that uses 32 bits for a number, how many different numbers could
    it represent? What’s the largest number it could represent? Remember that every
    bit you add doubles how many numbers you can make. If you double 64 another 25
    times (so that it is up to 31 bits), i.e. 128, 256, 512, 1024, 2048.... you get
    an end result of 2,147,483,648\. This means that there 2,147,483,648 numbers that
    can be represented with 31 bits, the highest of which is 2,147,483,647\. This
    number is just over 2 billion. With the 32nd bit, the sign bit, this means that
    the number can be positive or negative. This is called a *signed 32 bit integer*.
    So with the signed 32 bit integer, you can represent any number between -2,147,483,647
    and +2,147,483,647.
  prefs: []
  type: TYPE_NORMAL
- en: There is also such thing as a **32 bit *unsigned* integer**. This does not have
    a signed bit, and the 32nd bit is included as part of the value. As a result,
    it can represent twice as many positive numbers (but no negative numbers) as the
    32 bit *signed* integer above. This would be 4,294,967,296 different numbers,
    with 4,294,967,295 being the highest.
  prefs: []
  type: TYPE_NORMAL
- en: How many people are in the world? Would a 32 bit integer like described above
    be large enough to store a different identifier number for each person in the
    world? How many bits of accuracy would you want to allow for possible population
    growth?
  prefs: []
  type: TYPE_NORMAL
- en: '| Type of Number | Unsigned Range | Signed Range |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 8 bit signed | 0 to 255 | -128 to 127 |'
  prefs: []
  type: TYPE_TB
- en: '| 16 bit signed | 0 to 65,535 | -32,768 to 32,767 |'
  prefs: []
  type: TYPE_TB
- en: '| 32 bit signed | 0 to 4,294,967,295 | −2,147,483,648 to 2,147,483,647 |'
  prefs: []
  type: TYPE_TB
- en: '| 64 bit signed | 0 to 18,446,744,073,709,551,615 | −9,223,372,036,854,775,808
    to 9,223,372,036,854,775,807 |'
  prefs: []
  type: TYPE_TB
- en: So when you are storing values on a computer with very limited space, you need
    to be careful to pick a suitable kind of integer that has enough space, but isn’t
    wasting space. You also need to think about whether or not a number could potentially
    be negative.
  prefs: []
  type: TYPE_NORMAL
- en: Think of a few different examples for different sized integers (both signed
    and unsigned ones) of a piece of data that you could store in that sized integer.
    For example, the age of a person could be stored in an 8 bit unsigned integer
    (people can’t be a negative age!), and the number of students in your school could
    be stored in an 8 bit or 16 bit integer, depending on how big your school is!
    What other examples can you think of?
  prefs: []
  type: TYPE_NORMAL
- en: What are some examples of numbers you could not represent using any of these
    integers?
  prefs: []
  type: TYPE_NORMAL
- en: '**Extra for Experts**'
  prefs: []
  type: TYPE_NORMAL
- en: Another type of number used in computer systems is the “floating point” value.
    While we won’t look at it in detail, to get a taste of what’s involved, consider
    the bit values in a 4-bit number, which are 8, 4, 2 and 1\. What would the value
    of a bit *to the right* of the one bit be? And to the right of that one?
  prefs: []
  type: TYPE_NORMAL
- en: The following version of the base conversion interactive has bits that are smaller
    than the 1-bit. Try representing the decimal number 3.5 using this system. How
    about 2.8125? What about 2.8?
  prefs: []
  type: TYPE_NORMAL
- en: This system is a fixed-point number system; floating point numbers are based
    on this idea, but allow for the number of digits to be fixed, but the position
    of the point to change (by giving an exponent value).
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad3ce7f8e6.png)Click to load the widget](http://csfieldguide.org.nz/_static/widgets/DR/DR-base-conversion/public_html/index.html?base=2&columns=14&lines=A,B,C&offset=-8)'
  prefs: []
  type: TYPE_NORMAL
- en: 5.7.1\. NUMBERS IN PROGRAMMING LANGUAGES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are programming in a language (e.g. Python, Java, C, C++, C#) then the
    limitations of data representations become important very quickly, as you will
    have to choose what kind of data representation you want to use, and if it is
    too small then it can “overflow”. For example, if you allocate a variable to be
    stored as a 16 bit unsigned integer, and you are counting how many characters
    there are in a file, then it will fail after 65,535 characters — that’s just a
    65 kilobyte file.
  prefs: []
  type: TYPE_NORMAL
- en: If the amount of memory your computer has to store its data in is very limited
    (for example, on a small portable device), you might not want to reserve 32 bits
    for a number if it is never going to be over 100\. Or even if there is plenty
    of memory, if you are storing millions of data values then using 16-bit integers
    instead of 8-bit integers will waste millions of bytes of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Working out the size of an integer used in a particular programming language
    may take some investigation, as they are usually declared with names like “int”
    and “long”, which don’t say explicitly how many bits they use. For example, in
    the Java programming language, there is a data type called the “byte”, which is
    an 8-bit integer that includes negative numbers (it goes from -128 to 127), whereas
    a “short” integer is 16 bits, an “int” is 32 bits, and a “long” is 64 bits. In
    some cases (such as the “int” type in C) the length of an integer depends on the
    version of the language of the type of computer it is running on, and in other
    cases (such as integers in Python) the representation is automatically changed
    for you if the number gets too big!
  prefs: []
  type: TYPE_NORMAL
- en: 5.8\. THE WHOLE STORY!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The kind of image representations covered here are the basic ones used in most
    digital systems, and the main point of this chapter is to understand how digital
    representations work, and the compromises needed between the number of bits, storage
    used, and quality.
  prefs: []
  type: TYPE_NORMAL
- en: The colour representation discussed is what is often referred to as “raw” or
    “bitmap” (bmp) representation. For large images, real systems use compression
    methods such as JPEG, GIF or PNG to reduce the space needed to store an image,
    but at the point where an image is being captured or displayed it is inevitably
    represented using the raw bits as described in this chapter, and the basic choices
    for capturing and displaying images will affect the quality and cost of a device.
    Compression is regarded as a form of encoding, and is covered in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The representation of numbers is a whole area of study in itself. The choice
    of representation affects how quickly arithmetic can be done on the numbers, how
    accurate the results are, and how much memory or disk space is used up storing
    the data. Even integers have issues like the order in which a large number is
    broken up across multiple bytes. Floating point numbers generally follow common
    standards (the IEEE 754 standard is the most common one) to make it easy to design
    compatible hardware to process them. Spreadsheets usually store numbers using
    a floating point format, which limits the precision of calculations (typically
    about 64 bits are used for each number). There are many experiments that can be
    done (such as calculating 1/3, or adding a very large number to a very small one)
    that demonstrate the limitations of floating point representations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter does not (yet) cover other forms of data representation, and you
    may wish to explore these as alternatives. The common ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: sound (wave files and related storage; for example, 16-bit samples are used
    for “CD quality”, but professional systems use 24-bit or even higher) — for some
    information, see the [Teach with ICT page on sound representation](http://teachwithict.weebly.com/6/post/2014/01/teaching-computer-science-day-15-everything-is-sound.html#sthash.8LIc3W01.dpbs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: video (which are based on multiple images being played one after the other;
    however, these files are so large that they are almost never stored as a “raw”
    representation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.9\. FURTHER READING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This puzzle can be solved using the pattern in binary numbers: [http://www.cs4fn.org/binary/lock/](http://www.cs4fn.org/binary/lock/)
  prefs: []
  type: TYPE_NORMAL
- en: '[This site](http://courses.cs.vt.edu/~csonline/NumberSystems/Lessons/index.html) has
    more complex activities with binary numbers, including fractions, multiplication
    and division.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.9.1\. USEFUL LINKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Basics of binary numbers](http://csunplugged.org/binary-numbers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Representing bits using sound](http://csunplugged.org/modem)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hex game](http://www.purposegames.com/game/049fc90a)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Thriving in our digital world](https://onramps.instructure.com/courses/723227) has
    good illustrations of data representation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6\. CODING — INTRODUCTION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 6.1\. WHAT’S THE BIG PICTURE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The word “code” has lots of meanings in computer science. It’s often used to
    talk about programming, and a program can be referred to as “source code”. However,
    in this chapter (and the next three chapters), we will use it to talk about representing
    information in useful ways, such as secret codes. In the previous chapter we looked
    at using binary representations to store all kinds of data — numbers, text, images
    and more. But often simple binary representations aren’t so useful. Sometimes
    they take up too much space, sometimes small errors in the data can cause big
    problems, and sometimes we worry that someone else could easily read our messages.
    Most of the the time all three of these things are a problem! The codes that we
    will look overcome all of these problems, and are widely used for storing and
    transmitting important information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three main reasons that we use more complex representations of binary data
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compression:** this reduces the amount of space the data needs (for example,
    coding an audio file using MP3 compression can reduce the size of an audio file
    to well under 10% of its original size)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encryption:** this changes the representation of data so that you need to
    have a “key” to unlock the message (for example, whenever your browser uses “https”
    instead of “http” to communicate with a website, encryption is being used to make
    sure that anyone eavesdropping on the connection can’t make any sense of the information)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error Control:** this adds extra information to your data so that if there
    are minor failures in the storage device or transmission, it is possible to detect
    that the data has been corrupted, and even reconstruct the information (for example,
    every bar code has an extra digit added to it so that if the bar code is scanned
    incorrectly in a checkout, it makes a warning sound instead of charging you for
    the wrong product).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often all three of these are applied to the same data; for example, a photo
    taken on a camera is often compressed using JPG, stored on the camera card with
    error correction, and stored on a backup disk with encryption so that if the disk
    was stolen the data couldn’t be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Without these forms of coding, digital devices would be very slow, have limited
    capacity, be unreliable, and be unable to keep your information private.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2\. THE WHOLE STORY!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of encoding data to make the representation more compact, robust or
    secure is centuries old, but the solid theory needed to support codes in the information
    age was developed in the 1940s — not surprisingly considering that technology
    played such an important role in World War II, where efficiency, reliability and
    secrecy were all very important. One of the most celebrated researchers in this
    area was Claude Shannon, who developed the field of “information theory”, which
    is all about how data can be represented effectively.
  prefs: []
  type: TYPE_NORMAL
- en: A key concept in Shannon’s work is a measure of information called “entropy”,
    which established mathematical limits like how small files could be compressed,
    and how many extra bits must be added to a message to achieve a given level of
    reliability. While the idea of entropy is beyond the scope of this section, there
    are some fun games that provide a taste of how you could measure information content
    by guessing what letter comes next; there’s an Unplugged activity called [Twenty
    Guesses](http://csunplugged.org/information-theory), and an [online game for guessing
    sentences](http://www.math.ucsd.edu/~crypto/java/ENTROPY).
  prefs: []
  type: TYPE_NORMAL
- en: 6.3\. FURTHER READING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'James Gleick’s book [The Information: A History, a Theory, a Flood](http://www.amazon.com/The-Information-History-Theory-Flood/dp/1400096235) provides
    an interesting view of the history of several areas relating to coding.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.3.1\. USEFUL LINKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good collection of resources related to all three kinds of coding is available
    in the [Bletchley Park Codes Resources](http://www.cimt.plymouth.ac.uk/resources/codes/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Entropy and information theory](http://en.wikipedia.org/wiki/Entropy_(information_theory))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[History of information theory and its relationship to entropy in thermodynamics](http://en.wikipedia.org/wiki/History_of_entropy#Information_theory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Timeline of information theory](http://en.wikipedia.org/wiki/Timeline_of_information_theory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Shannon’s seminal work in information theory](http://en.wikipedia.org/wiki/A_Mathematical_Theory_of_Communication)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7\. COMPRESSION CODING
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 7.1\. WHAT’S THE BIG PICTURE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data compression reduces the amount of space needed to store files. If you can
    halve the size of a file, you can store twice as many files for the same cost,
    or you can download the files twice as fast (and at half the cost if you’re paying
    for the download). Even though disks are getting bigger and high bandwidth is
    becoming common, it’s nice to get even more value by working with smaller, compressed
    files. For large data warehouses, like those kept by Google and Facebook, halving
    the amount of space taken can represent a massive reduction in the space and computing
    required, and consequently big savings in power consumption and cooling, and a
    huge reduction in the impact on the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Common forms of compression that are currently in use include JPEG (used for
    photos), MP3 (used for audio), MPEG (used for videos including DVDs), and ZIP
    (for many kinds of data). For example, the JPEG method reduces photos to a tenth
    or smaller of their original size, which means that a camera can store 10 times
    as many photos, and images on the web can be downloaded 10 times faster.
  prefs: []
  type: TYPE_NORMAL
- en: So what’s the catch? Well, there can be an issue with the quality of the data
    — for example, a highly compressed JPEG image doesn’t look as sharp as an image
    that hasn’t been compressed. Also, it takes processing time to compress and decompress
    the data. In most cases, the tradeoff is worth it, but not always.
  prefs: []
  type: TYPE_NORMAL
- en: Move your cursor or tap the image to compare the two images
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad56eb6251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Left is low quality JPEG (20Kb) - Right is high quality JPEG (88Kb)**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll look at how compression might be done, what the benefits
    are, and the costs associated with using compressed data that need to be considered
    when deciding whether or not to compress data. We’ll start with a simple example
    — Run Length Encoding — which gives some insight into the benefits and the issues
    around compression.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, students simulate writing some text using a method used by
    Jean-Dominique Bauby, who was completely unable to move except for blinking one
    eye. With a simple binary interface (blinking or not blinking) he was able to
    author an entire book. It is well worth getting students to work in pairs, and
    have one try to communicate a word or short phrase strictly by blinking only.
    It raises many questions, including how it could be done in the shortest time
    and with the minimum effort. Of course, the first step is to work out how to convey
    any text at all!
  prefs: []
  type: TYPE_NORMAL
- en: 7.2\. RUN LENGTH ENCODING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine we have the following simple black and white image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad56e2728e.png)'
  prefs: []
  type: TYPE_IMG
- en: One very simple way a computer can store this image is by using a format where
    0 means white and 1 means black. The above image would be represented in the following
    way
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There are 15 (rows) by 15 (columns) = 225 bits representing this image. Can
    we represent the same image using fewer bits, in a way that a computer would still
    be able to understand it? Imagine that you had to read it out to someone... after
    a while you might say things like “five zeroes” instead of “zero zero zero zero
    zero”. This technique is used to save space for storing digital images, and is
    known as run length encoding (RLE). In run length encoding, we replace each row
    with numbers that say how many consecutive pixels are the same colour, *always
    starting with the number of white pixels*. For example, the first row in the image
    above contains 1 white, 2 black, 4 white, 1 black, 4 white, 2 black, and 1 white
    pixel. This could be represented as;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For the second row, because we need to say what the number of white pixels is
    before we say the number of black, we need to explicitly say there are 0 at the
    start of the row. This would give
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And the third row contains 5 whites, 5 blacks, 5 whites. This would give
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we have determined that the first 3 rows of the file can be represented
    using RLE as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Work out what the other rows would be, and write them out as well.
  prefs: []
  type: TYPE_NORMAL
- en: Which representation takes less space to store?
  prefs: []
  type: TYPE_NORMAL
- en: One simple way to consider this is to imagine you were typing these representations,
    so you could think of each of the original bits being stored as one character,
    and each of the RLE codes using a character for each digit and comma (this is
    a bit crude, but it’s a starting point).
  prefs: []
  type: TYPE_NORMAL
- en: In the original representation, 225 bits were required to represent the image.
    Count up the number of commas and digits (but not spaces or newlines, ignore those)
    in the new representation. This is the number of characters required to represent
    the image with the new representation (to ensure you are on the right track, the
    first 3 rows that were given to you contain 29 characters)
  prefs: []
  type: TYPE_NORMAL
- en: Assuming you got the new image representation correct, and counted correctly,
    you should have found there are 119 characters in the new image (double check
    if your number differs!) This means that the new representation only requires
    around 53% as many characters to represent (calculated using 119/225)! This is
    a significant reduction in the amount of space required to store the image. The
    new representation is a *compressed* form of the old one.
  prefs: []
  type: TYPE_NORMAL
- en: In practice this method (with some extra tricks) can be used to compress images
    to about 15% of their original size. In real systems, the image only uses one
    bit for every pixel to store the black and white values (not one character, which
    we used for our calculations). The run length numbers are also stored much more
    efficiently, again using bit patterns that take very little space to represent
    the numbers. The bit patterns used are usually based on a technique called Huffman
    coding, but that is beyond what we want to get into here.
  prefs: []
  type: TYPE_NORMAL
- en: The main place that black and white scanned images are used now is on fax machines,
    which used this approach to compression. One reason that it works so well with
    scanned pages the number of consecutive white pixels is huge. In fact, there will
    be entire scanned lines that are nothing but white pixels. A typical fax page
    is 200 pixels across or more, so replacing 200 bits with one number is a big saving.
    The number itself can take a few bits to represent, and in some places on the
    scanned page only a few consecutive pixels are replaced with a number, but overall
    the saving is significant. In fact, fax machines would take 7 times longer to
    send pages if they didn’t use compression.
  prefs: []
  type: TYPE_NORMAL
- en: Just to ensure that we can reverse the compression process, what is the original
    representation (zeroes and ones) of this (compressed) image?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What is the image of? How good was the compression on this image? (Look back
    at the calculation above for the amount of compression).
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad56d61c9f.png)Click to load'
  prefs: []
  type: TYPE_NORMAL
- en: Run Length Encoding](http://csfieldguide.org.nz/_static/interactives/cc/run-length-encoding/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: Created by Hannah Taylor
  prefs: []
  type: TYPE_NORMAL
- en: As the compressed representation of the image can be converted back to the original
    representation, and both the original representation and the compressed representation
    would give the same image when read by a computer, this compression algorithm
    is called *lossless*, i.e. none of the data was lost from compressing the image,
    and as a result the compression could be undone exactly.
  prefs: []
  type: TYPE_NORMAL
- en: Not all compression algorithms are lossless. In some types of files, in particular
    photos, sound, and videos, we are willing to sacrifice a little bit of the quality
    (i.e. lose a little of the data representing the image) if it allows us to make
    the file size a lot smaller. For downloading very large files such as movies,
    this can be essential to ensure the file size is not so big that it is infeasible
    to download! These compression methods are called *lossy*. If some of the data
    is lost, it is impossible to convert the file back to the exactly the original
    form when lossy compression was used, but the person viewing the movie or listening
    to the music may not mind the lower quality if the files are smaller. Later in
    this chapter, we will investigate the effects some lossy compression algorithms
    have on images and sound.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how run length encoding works, you can come up with and compress
    your own black and white image, as well as uncompress an image that somebody else
    has given you.
  prefs: []
  type: TYPE_NORMAL
- en: Start by making your own picture with ones and zeroes. (Make sure it is rectangular
    — all the rows should have the same length.) You can either draw this on paper
    or prepare it on a computer (using a fixed width font, otherwise it can become
    really frustrating and confusing!) In order to make it easier, you could start
    by working out what you want your image to be on grid paper (such as that from
    a math exercise book) by shading in squares to represent the black ones, and leaving
    them blank to represent the white ones. Once you have done that, you could then
    write out the zeroes and ones for the image.
  prefs: []
  type: TYPE_NORMAL
- en: Work out the compressed representation of your image using run length coding,
    i.e. the run lengths separated by commas form that was explained above.
  prefs: []
  type: TYPE_NORMAL
- en: Now, swap a copy of the *compressed representation* (the run length codes, not
    the original uncompressed representation) with a classmate. You should each uncompress
    the other person’s image, to get back to the original uncompressed representations.
    Check to make sure the conversions back to the uncompressed representations was
    done correctly by making sure the images are the same.
  prefs: []
  type: TYPE_NORMAL
- en: Imagining that you and your friend are both computers, by doing this you have
    shown that images using these systems of representations can be compressed on
    one computer, and decompressed on another. It is very important for compression
    algorithms to have this property in order to be useful. It wouldn’t be very good
    if a friend gave you a song they’d compressed on their computer, but then your
    computer was unable to make sense of the representation the compressed song was
    using!
  prefs: []
  type: TYPE_NORMAL
- en: '**Extra for Experts**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the image with the best compression (i.e. an image that has a size that
    is a very small percentage of the original) that you can come up with? This is
    the best case performance for this compression algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: What about the worst compression? Can you find an image that actually has a *larger* compressed
    representation? (Don’t forget the commas in the version we used!) This is the
    worst case performance for this compression algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, any *lossless* compression algorithm will have cases where the compressed
    version of the file is larger than the uncompressed version! Computer scientists
    have even proven this to be the case, meaning it is impossible for anybody to
    ever come up with a lossless compression algorithm that makes *all* possible files
    smaller. In most cases this isn’t an issue though, as a good lossless compression
    algorithm will tend to give the best compression on common patterns of data, and
    the worst compression on ones that are highly unlikley to occur.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extra for Experts**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is actually an image format that uses the simple one-character-per-pixel
    representation we used at the start of this section. The format is called portable
    bitmap format (PBM). PBM files are saved with the file extension “.pbm”, and contain
    a simple header, along with the the image data. The data in the file can be viewed
    by opening it in a text editor, much like opening a .txt file, and the image itself
    can be viewed by opening it in a drawing or image viewing program that supports
    PBM files (they aren’t very well supported, but a number of image viewing and
    editing programs can display them). A pbm file for the diamond image used earlier
    would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first 2 lines are the header. The first line specifies the format of the
    file (P1 means that the file contains ASCII zeroes and ones. The second line specifies
    the width and then the height of the image in pixels. This allows the computer
    to know the size and dimensions of the image, even if the newline characters separating
    the rows in the file were missing. The rest of the data is the image, just like
    above. If you wanted to, you could copy and paste this representation (including
    the header) into a text file, and save it with the file extension .pbm. If you
    have a program on your computer able to open PBM files, you could then view the
    image with it. You could even write a program to output these files, and then
    display them as images.
  prefs: []
  type: TYPE_NORMAL
- en: There are variations of this format that pack the pixels into bits instead of
    characters, and variations that can be used for grey scale and colour images.
    More[information about this format is available on Wikipedia](http://en.wikipedia.org/wiki/Netpbm_format).
  prefs: []
  type: TYPE_NORMAL
- en: '7.3\. IMAGE COMPRESSION: JPEG'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Images can take up a lot of space, and most of the time that pictures are stored
    on a computer they are compressed to avoid wasting too much space. With a lot
    of images (especially photographs), there’s no need to store the image exactly
    as it was originally, because it contains way more detail than anyone can see.
    This can lead to considerable savings in space, especially if the details that
    are missing are the kind that people have trouble perceiving. This kind of compression
    is called lossy compression. There are other situations where images need to be
    stored exactly as they were in the original, such as for medical scans or very
    high quality photograph processing, and in these cases lossless methods are used,
    or the images aren’t compressed at all (e.g. using RAW format on cameras).
  prefs: []
  type: TYPE_NORMAL
- en: In the data representation section we looked at how the size of an image file
    can be reduced by using fewer bits to describe the colour of each pixel. However,
    image compression methods such as JPEG take advantage of patterns in the image
    to reduce the space needed to represent it, without impacting the image unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following three images show the difference between reducing bit depth and
    using a specialised image compression system. The left hand image is the original,
    which was 24 bits per pixel. The middle image has been compressed to one third
    of the original size using JPEG; while it is a “lossy” version of the original,
    the difference is unlikely to be perceptible. The right hand one has had the number
    of colours reduced to 256, so there are 8 bits per pixel instead of 24, which
    means it is also stored in a third of the original size. Even though it has lost
    just as many bits, the information removed has had much more impact on how it
    looks. This is the advantage of JPEG: it removes information in the image that
    doesn’t have so much impact on the perceived quality. Furthermore, with JPEG,
    you can choose the tradeoff between quality and file size.'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the number of bits (the colour depth) is sufficiently crude that we
    don’t really regard it as a compression method, but just a low quality representation.
    Image compression methods like JPEG, GIF and PNG are designed to take advantage
    of the patterns in an image to get a good reduction in file size without losing
    more quality than necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad5689cad1.png)'
  prefs: []
  type: TYPE_IMG
- en: For example, the following image shows a zoomed in view of the pixels that are
    part of the detail around an eye from the above (high quality) image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad56825c7f.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the colours in adjacent pixels are often very similar, even in this
    part of the picture that has a lot of detail. For example, the pixels shown in
    the red box below just change gradually from very dark to very light.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad5679ecd4.png)'
  prefs: []
  type: TYPE_IMG
- en: Run-length encoding wouldn’t work in this situation. You could use a variation
    that specifies a pixel’s colour, and then says how many of the following pixels
    are the same colour, but although most adjacent pixels are nearly the same, the
    chances of them being identical are very low, and there would be almost no runs
    of identical colours.
  prefs: []
  type: TYPE_NORMAL
- en: But there is a way to take advantage of the gradually changing colours. For
    the pixels in the red box above, you could generate an approximate version of
    those colours by specifying just the first and last one, and getting the computer
    to interpolate the ones in between smoothly. Instead of storing 5 pixel values,
    only 2 are needed, yet someone viewing it probably wouldn’t notice any difference.
    This would be *lossy* because you can’t reproduce the original exactly, but it
    would be good enough for a lot of purposes, and save a lot of space.
  prefs: []
  type: TYPE_NORMAL
- en: The JPEG system, which is widely used for photos, uses a more sophisticated
    version of this idea. Instead of taking a 5 by 1 run of pixels as we did above,
    it works with 8 by 8 blocks of pixels. And instead of estimating the values with
    a linear function, it uses combinations of cosine waves.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: A cosine wave form is from the trig function that is often used for calculating
    the sides of a triangle. If you plot the cosine value from 0 to 180 degrees, you
    get a smooth curve going from 1 to -1\. Variations of this plot can be used to
    approximate the value of pixels, going from one colour to another. If you add
    in a higher frequency cosine wave, you can produce interesting shapes. In theory,
    any pattern of pixels can be created by adding together different cosine waves!
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad567142a9.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see the 8 by 8 blocks of pixels if you zoom in on a heavily compressed
    JPEG image. For example, the following image has been very heavily compressed
    using JPEG (it is just 1.5% of its original size).
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad56603451.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we zoom in on the eye area , you can see the 8 x 8 blocks of pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad560553f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that there is very little variation across each block. In the following
    image the block in the red box only changes from top to bottom, and could probably
    be specified by giving just two values, and having the ones in between calculated
    by the decoder as for the line example before. The green square only varies from
    left to right, and again might only need 2 values stored instead of 64\. The blue
    block has only one colour in it! The yellow block is more complicated because
    there is more activity in that part of the image, which is where the cosine waves
    come in. A “wave” value varies up and down, so this one can be represented by
    a left-to-right variation from dark to light to dark, and a top-to-bottom variation
    mainly from dark to light. Thus still only a few values need to be stored instead
    of the full 64.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad55f7eb84.png)'
  prefs: []
  type: TYPE_IMG
- en: The quality is quite low, but the saving in space is huge — it’s more than 60
    times smaller (for example, it would download 60 times faster). Higher quality
    JPEG images store more detail for each 8 by 8 block, which makes it closer to
    the original image, but makes bigger files because more details are being stored.
    You can experiment with these tradeoffs by saving JPEGs with differing choices
    of the quality, and see how the file size changes. Most image processing software
    offers this option when you save an image as a JPEG.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: The name “JPEG” is short for “Joint Photographic Experts Group”, a committee
    that was formed in the 1980s to create standards so that digital photographs could
    be captured and displayed on different brands of devices. Because some file extensions
    are limited to three characters, it is often seen as the ”.jpg” extension.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extra for Experts**'
  prefs: []
  type: TYPE_NORMAL
- en: The cosine waves used for JPEG images are based on a “Discrete Cosine Transform”.
    The “Discrete” means that the waveform is digital — it is the opposite of continuous,
    where any value can occur. In a JPEG wave, there are only 8 x 8 values (for the
    block being coded), and each of those values can have a limited range of numbers
    (binary integers), rather than any value at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important issue arises because JPEG represents images as smoothly varying
    colours: what happens if the colours change suddenly? In that case, lots of values
    need to be stored so that lots of cosine waves can be added together to make the
    sudden change in colour, or else the edge of the image become fuzzy. You can think
    of it as the cosine waves overshooting on the sudden changes, producing artifacts
    like the ones in the following image where the edges are messy.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad55ee7624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The original had sharp edges, but this zoomed in view of the JPEG version of
    it show that not only are the edges gradual, but some darker pixels occur further
    into the white space, looking a bit like shadows or echoes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad55e4055f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For this reason, JPEG is used for photos and natural images, but other techniques
    (such as GIF and PNG, which we will look at in another section) work better for
    artificial images like this one.
  prefs: []
  type: TYPE_NORMAL
- en: '7.4\. IMAGE COMPRESSION: GIF AND PNG'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[appearing soon!]'
  prefs: []
  type: TYPE_NORMAL
- en: 7.5\. GENERAL PURPOSE COMPRESSION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: General purpose compression methods need to be lossless because you can’t assume
    that the user won’t mind if the data is changed. The most widely used general
    purpose compression algorithms (such as ZIP, gzip, and rar) are based on a method
    called “Ziv-Lempel coding”, invented by Jacob Ziv and Abraham Lempel in the 1970s.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at this with a text file as an example. The main idea of Ziv-Lempel
    coding is that sequences of characters are often repeated in files (for example,
    the sequence of characters “image ” appears often in this chapter), and so instead
    of storing the repeated occurrence, you just replace it with a reference to where
    it last occurred. As long as the reference is smaller than the phrase being replaced,
    you’ll save space. Typically this systems based on this approach can be used to
    reduce text files to as little as a quarter of their original size, which is almost
    as good as any method known for compressing text.
  prefs: []
  type: TYPE_NORMAL
- en: The following interactive allows you to explore this idea. The empty boxes have
    been replaced with a reference to the text occurring earlier. You can click on
    a box to see where the reference is, and you can type the referenced characters
    in to decode the text. What happens if a reference is pointing to another reference?
    As long as you decode them from first to last, the information will be available
    before you need it.
  prefs: []
  type: TYPE_NORMAL
- en: You can also enter your own text by clicking on the “Text” tab. You could paste
    in some text of your own to see how many characters can be replaced with references.
  prefs: []
  type: TYPE_NORMAL
- en: 'The references are actually two numbers: the first says how many characters
    to count back to where the previous phrase starts, and the second says how long
    the referenced phrase is. Each reference typically takes about the space of one
    or two characters, so the system makes a saving as long as two characters are
    replaced. The options in the interactive above allow you to require the replaced
    length to be at least two, to avoid replacing a single character with a reference.
    Of course, all characters count, not just letters of the alphabet, so the system
    can also refer back to the white spaces between words. In fact, some of the most
    common sequences are things like a full stop followed by a space.'
  prefs: []
  type: TYPE_NORMAL
- en: This approach also works very well for black and white images, since sequences
    like “10 white pixels” are likely to have occurred before. Here are some of the
    bits from the example earlier in this chapter; you can paste them into the interactive
    above to see how many pointers are needed to represent it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In fact, this is essentially what happens with GIF and PNG images; the pixel
    values are compressed using the Ziv-Lempel algorithm, which works well if you
    have lots of consecutive pixels the same colour. But it works very poorly with
    photographs, where pixel patterns are very unlikely to be repeated.
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  prefs: []
  type: TYPE_NORMAL
- en: The method we have described here is named “Ziv-Lempel” compression after Jacob
    Ziv and Abraham Lempel, the two computer scientists who invented it in the 1970s.
    Unfortunately someone mixed up the order of their names when they wrote an article
    about it, and called it “LZ” compression instead of “ZL” compression. So many
    people copied the mistake that Ziv and Lempel’s method is now usually called “LZ
    compression”!
  prefs: []
  type: TYPE_NORMAL
- en: 7.6\. AUDIO COMPRESSION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most widely used methods for compressing music is MP3, which is actually
    from a video compression standard. The Motion Picture Expert Group (MPEG) was
    a consortium of companies and researchers that got together to agree on a standard
    so that people could easily play the same videos on different brands of equipment
    (especially from DVD). The very first version of their standard (called MPEG 1)
    had three methods of storing the sound track (layer 1, 2 and 3). One of those
    methods (MPEG 1 layer 3) became very popular for compressing music, and was abbreviated
    to MP3.
  prefs: []
  type: TYPE_NORMAL
- en: Most other audio compression methods use a similar approach to the MP3 method,
    although some offer better quality for the same amount of storage (or less storage
    for the same quality). It’s not essential to know how this works, but the general
    idea is to break the sound down into bands of different frequencies, and then
    represent each of those bands by adding together the values of a simple formula
    (the sum of cosine waves, to be precise).
  prefs: []
  type: TYPE_NORMAL
- en: There is some [more detail about how MP3 coding works on the cs4fn site](http://www.cs4fn.org/mathemagic/sonic.html),
    and also in [an article on the I Programmer site](http://www.i-programmer.info/babbages-bag/1222-mp3.html).
  prefs: []
  type: TYPE_NORMAL
- en: Other audio compression systems that you might come across include AAC, ALAC,
    Ogg Vorbis, and WMA. Each of these has various advantages over others, and some
    are more compatible or open than others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main questions with compressed audio are how small the file can be made,
    and how good the quality is of the human ear. (There is also the question of how
    long it takes to encode the file, which might affect how useful the system is.)
    The tradeoff between quality and size of audio files can depend on the situation
    you’re in: if you are jogging and listening to music then the quality may not
    matter so much, but it’s good to reduce the space available to store it. On the
    other hand, someone listening to a recording at home on a good sound system might
    not mind about having a large device to store the music, as long as the quality
    is high.'
  prefs: []
  type: TYPE_NORMAL
- en: To evaluate an audio compression you should choose a variety of recordings that
    you have high quality originals for, typically on CD (or using uncompressed WAV
    or AIFF files). Choose different styles of music, and other kinds of audio such
    as speech, and perhaps even create a recording that is totally silent. Now convert
    these recordings to different audio format. One system for doing this that is
    free to download is Apple’s iTunes, which can be used to rip CDs to a variety
    of formats, and gives a choice of settings for the quality and size. A lot of
    other audio systems are able to convert files, or have plugins that can do the
    conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Compress each of your recordings using a variety of methods, making sure that
    each compressed file is created from a high quality original. Make a table showing
    how long it took to process each recording, the size of the compressed file, and
    some evaluation of the quality of the sound compared with the original. Discuss
    the tradeoffs involved — do you need much bigger files to store good quality sound?
    Is there a limit to how small you can make a file and still have it sounding ok?
    Do some methods work better for speech than others? Does a 2 minute recording
    of silence take more space than a 1 minute recording of silence? Does a 1 minute
    recording of music use more space than a minute of silence?
  prefs: []
  type: TYPE_NORMAL
- en: 7.7\. THE WHOLE STORY!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The details of how compression systems work have been glossed over in this chapter,
    as we have been more concerned about the file sizes and speed of the methods than
    how they work. Most compression systems are variations of the ideas that have
    been covered here, although one fundamental method that we haven’t mentioned is
    Huffman coding, which turns out to be useful as the final stage of all of the
    above methods, and is often one of the first topics mentioned in textbooks discussing
    compression (there’s a brief [explanation of it here](http://www.cimt.plymouth.ac.uk/resources/codes/codes_u17_text.pdf).
    A closely related system is Arithmetic coding (there’s an [explanation of it here](http://www.cimt.plymouth.ac.uk/resources/codes/codes_u18_text.pdf)).
    Also, motion picture compression has been omitted, even though compressing videos
    saves more space than most kinds of compression. Most video compression is based
    on the “MPEG” standard (Motion Picture Experts Group). There is some information
    about how this works in the [CS4FN article on “Movie Magic”](http://www.cs4fn.org/films/mpegit.php).
  prefs: []
  type: TYPE_NORMAL
- en: The Ziv-Lempel method shown is a variation of the so-called “LZ77” method. Many
    of the more popular compression methods are based on this, although there are
    many variations, and one called “LZW” has also been used a lot. Another high-compression
    general-purpose compression method is bzip, based on a very clever method called
    the Burrows-Wheeler Transform.
  prefs: []
  type: TYPE_NORMAL
- en: Questions like “what is the most compression that can be achieved” are addressed
    by the field of [information theory](http://en.wikipedia.org/wiki/Information_theory).
    There is an [activity on information theory on the CS Unplugged site](http://csunplugged.org/information-theory),
    and there is a [fun activity that illustrates information theory](http://www.math.ucsd.edu/~crypto/java/ENTROPY/).
    Based on this theory, it seems that English text can’t be compressed to less than
    about 12% of its original size at the very best. Images, sound and video can get
    much better compression because they can use lossy compression, and don’t have
    to reproduce the original data exactly.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8\. FURTHER READING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: “The Data Compression Book” by Mark Nelson and Jean-Loup Gailly is a good overview
    of this topic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of books on this topic (and lots of other information about compression)
    is available from [The Data Compression Site](http://www.data-compression.info/Books/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gleick’s book “The Information” has some background to compression, and coding
    in general.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.8.1\. USEFUL LINKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Images, run-length-coding [http://csunplugged.org/image-representation](http://csunplugged.org/image-representation) This
    is also relevant to binary representations in general, although is probably best
    used in the compression section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a detailed section on [JPEG encoding on Wikipedia](http://en.wikipedia.org/wiki/Jpeg).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text compression [http://csunplugged.org/text-compression](http://csunplugged.org/text-compression)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8\. ENCRYPTION CODING
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 8.1\. WHAT’S THE BIG PICTURE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Encryption is used to keep data secret. In its simplest form, a file or data
    transmission is garbled so that only authorised people with a secret key can unlock
    the original text. If you’re using digital devices then you’ll be using systems
    based on encryption all the time: when you use online banking, when you access
    data through through wifi, when your web browser remembers your password, when
    you pay for something with a credit card (either by swiping, inserting or tapping),
    in fact, nearly every activity will involve layers of encryption. Without encryption,
    your information would be wide open to the world — anyone could pull up outside
    a house and read all the data going over your wifi, and stolen laptops, hard disks
    and SIM cards would yield all sorts of information about you — so encryption is
    critical to having computer systems work at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we wouldn’t need encryption if we lived in a world where everyone
    was honest and could be trusted, and it was ok for anyone to have access to all
    your personal information such as health records, online discussions, bank accounts
    and so on, and if you knew that no-one would interfere with things like aircraft
    control systems and computer controlled weapons. However, information is worth
    money, people value their privacy, and safety is important, so encryption has
    become fundamental to the design of computer systems. Even breaking the security
    on a traffic light system could be used to personal advantage!
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  prefs: []
  type: TYPE_NORMAL
- en: An interesting example of the value of using encryption outside of secret messages
    is the two engineers who were convicted of changing traffic light patterns to
    cause chaos during a strike [http://latimesblogs.latimes.com/lanow/2009/12/engineers-who-hacked-in-la-traffic-signal-computers-jamming-traffic-sentenced.html](http://latimesblogs.latimes.com/lanow/2009/12/engineers-who-hacked-in-la-traffic-signal-computers-jamming-traffic-sentenced.html).
    A related problem in the US was traffic signals that could respond to codes from
    emergency vehicles to change to green; originally these didn’t use encryption,
    and people could figure out how to trigger them to their own advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Like all technologies, encryption can be used for good and bad purposes. A human
    rights organisation might use encryption to secretly send photographs of human
    rights abuse to the media, while drug traffickers might use it to avoid having
    their plans read by investigators. Understanding how encryption works and what
    is possible can help to make informed decisions around things like freedom of
    speech, human rights, tracking criminal activity, personal privacy, identity theft,
    online banking and payments, and the safety of systems that might be taken over
    if they were “hacked into”.
  prefs: []
  type: TYPE_NORMAL
- en: 'An encryption system is really two programs: one to *encrypt* some data (referred
    to as *plaintext*) into a form that looks like nonsense (the *ciphertext*), and
    a second program that can *decrypt* the ciphertext back into the plaintext form.'
  prefs: []
  type: TYPE_NORMAL
- en: A big issue with encryption systems is people who want to break into them and
    decrypt messages without the key. Some systems that were used many years ago were
    discovered to be insecure because of attacks, so could no longer be used. It is
    possible that somebody will find an effective way of breaking into the widespread
    systems we use these days, which would result in a lot of chaos!
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: There are various words that can be used to refer to trying to get the plaintext
    from a ciphertext, including decipher, decrypt, crack, and cryptanalysis. Often
    the process of trying to break cryptography is referred to as an “attack”. The
    term “hack” is also sometimes used, but it has other connotations, and is only
    used informally.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, encryption doesn’t fix all our security problems, and because we
    have such good encryption systems available, information thieves must turn to
    other approaches, especially social engineering. The easiest way to get a user’s
    password is to ask them! A [phishing attack](http://en.wikipedia.org/wiki/Phishing) does
    just that, and there are estimates that as many as 1 in 20 computer users have
    given out secret information this way at some stage.
  prefs: []
  type: TYPE_NORMAL
- en: Other social engineering approaches that can be used include bribing or blackmailing
    people who have access to a system, or simply looking for a password written on
    a sticky note on someone’s monitor! Gaining access to someone’s email account
    is a particularly easy way to get lots of passwords, because many “lost password”
    systems will send a new password to their email account.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: When describing an encryption scenario, cryptographers often use the fictitious
    characters “Alice” and “Bob”, with a message being sent from Alice to Bob (A to
    B). We always assume that someone is eavesdropping on the conversation (in fact,
    if you’re using a wireless connection, it’s trivial to pick up the transmissions
    between Alice and Bob as long as you’re in reach of the wireless network that
    one of them is using). The fictitious name for the eavesdropper is usually Eve.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad5ef16f7f.png)](http://xkcd.com/1323/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'People who try to decrypt messages are called cryptanalysts; more informal
    terms like hackers and crackers are sometimes used, generally with the implication
    that they have bad intentions. Being a cryptanalyst is generally a good thing
    to do though: people who use encryption systems actually want to know if they
    have weaknesses, and don’t want to wait until the bad guys find out for them.
    It’s like a security guard checking doors on a building; the guard hopes that
    they can’t get in, but if a door is found unlocked, they can do something about
    it to make sure the bad guys can’t get in. Of course, if a security guard finds
    an open door, and takes advantage of that to steal something for themselves, they’re
    no longer doing their job properly!'
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several other characters used to describe activities around encryption
    protocols: for example Mallory (a malicious attacker) and Trudy (an intruder).
    Wikipedia has a [list of Alice and Bob’s friends](http://en.wikipedia.org/wiki/Alice_and_Bob).'
  prefs: []
  type: TYPE_NORMAL
- en: 8.2\. SUBSTITUTION CIPHERS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For these activities, you will need to have pen and paper in front of you to
    figure out the answers in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Working in a group with 1 or 2 of your classmates (or by yourself if nobody
    else is around), can you figure out what the following message, encrypted with
    a simple cipher, says?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: What techniques did your group use to decrypt the message?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you haven’t already, write out each letter in the alphabet, and then the
    letter that it corresponds to in the cipher (for the ones that are known, i.e.
    actually were in the cipher). Can you see a pattern?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you were going to make a secret message of your own using this same cipher,
    how would you go about it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What would be wrong with using this cipher method for a secret you’d never want
    anybody else finding out?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may have realised that there was a pattern in how letters from the original
    message corresponded to letters in the decoded one: a letter in the original message
    is decoded to the letter that is 10 places before it in the alphabet. The conversion
    table you drew should have highlighted this. Here’s the table for the letter correspondences,
    where the letter “K” translates to an “A”'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad5edb794d.png)'
  prefs: []
  type: TYPE_IMG
- en: The same idea can generate other codes, such as the following one where each
    letter is replaced with the one that is 8 places earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad5ed0b4f5.png)'
  prefs: []
  type: TYPE_IMG
- en: We sometimes say that the alphabet has been *rotated* by 8\. This system of
    rotating each letter in a piece of text by a certain amount in order to encrypt
    it is called Caesar Cipher, named after Julius Caesar, who used it with a rotation
    of 3 to disguise messages.
  prefs: []
  type: TYPE_NORMAL
- en: You can experiment with this cipher using this interactive.
  prefs: []
  type: TYPE_NORMAL
- en: PLAINTEXT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: ENCRYPT
  prefs: []
  type: TYPE_NORMAL
- en: ROTATION AMOUNT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: CIPHERTEXT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: DECRYPT
  prefs: []
  type: TYPE_NORMAL
- en: In this system, the amount of rotation is referred to as a *key*, since you
    can unlock the message if you know the key. Normally the sender and receiver would
    agree on a key in advance (and in person), so that the receiver can easily unlock
    the message.
  prefs: []
  type: TYPE_NORMAL
- en: However, this encryption method isn’t very secure, and you’ve probably already
    figured out how to crack a coded message. You actually only need to work out what
    one of the corresponding letters is, and then use that to calculate what the rotation
    is, which immediately gives you the key.
  prefs: []
  type: TYPE_NORMAL
- en: If for example you identify that the letter “Y” in the encrypted message is
    in place of the letter “R”, you can calculate the rotation by working out how
    many places R is before Y in the alphabet (it might help to write the alphabet
    out on a piece of paper so that you can count the places, as saying the alphabet
    backwards is quite challenging for most people!) As R is 7 places before Y, this
    means that the rotation for this cipher must be 7, and you should be able to convert
    all letters in the encrypted message to an understandable message by subtracting
    7 from them. The quickest way of going about this though would be to write out
    a conversion table like the ones above.
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  prefs: []
  type: TYPE_NORMAL
- en: The Caesar cipher with a key of 13 is the same as an approach called [ROT13
    (rotate 13 characters)](http://en.wikipedia.org/wiki/Rot_13), which is sometimes
    used to obscure things like the punchline of a joke, a spoiler for a story, the
    answer to a question, or text that might be offensive. It is easy to decode (and
    there are plenty of automatic systems for doing so), but the user has to deliberately
    ask to see the deciphered version. A key of 13 for a Caesar cipher has the interesting
    property that the encryption method is identical to the decryption method i.e.
    the same program can be used for both. Actually, many strong encryption methods
    try to make the encryption and decryption processes as similar as possible so
    that the same software and/or hardware can be used for both parts of the task,
    perhaps with only minor adaptions.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of the idea that you only need to figure out 1 letter to decide,
    can you figure out what the following message says? Which letter is the best one
    to try and guess? Why? What was the rotation? You may make a few incorrect guesses
    before figuring it out, so be prepared for that! Once you think you know what
    one of the letters in the ciphertext might correspond to in the plaintext, work
    out what the rotation is, and then write out the conversions for that rotation
    and decode the start of the message using that conversion table to see whether
    or not it makes sense. If the first few words seem to be meaningless, then that
    rotation is probably not the correct one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know how to decipher a message that is using Caesar Cipher without
    actually knowing the key, you should be able to see that it would be very easy
    to decipher a message if you know the key. The following message was encrypted
    using a rotation of 6\. Generate the conversion table for a rotation of 6\. This
    should allow you to easily decipher the following message. What does the message
    say? (Use only the conversion table to figure it out!)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It shouldn’t be too difficult to see how a message can be *encrypted* using
    Caesar Cipher. Previously, you were generating conversion tables that converted
    from the ciphertext to the plaintext. In a very similar way, you can generate
    conversion tables that convert from the plaintext to the ciphertext. The only
    difference is that instead of subtracting the rotation, you are adding it. i.e.
    if the rotation was 5, then the letter “H” in the plaintext would go to the letter
    that is 5 places forward in the alphabet, which is “M”.
  prefs: []
  type: TYPE_NORMAL
- en: Using a rotation of 3, generate a conversion table, and then the ciphertext,
    for the following message.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now that all that is out of the way, you can encrypt your own messages (assuming
    it doesn’t matter too much if somebody deciphers them — as you saw above, this
    is not a very secure cipher!). Decide on a message to encrypt, and a rotation
    key. Generate a conversion table, and then encrypt your message.
  prefs: []
  type: TYPE_NORMAL
- en: If a friend is also doing this activity, once you have your encrypted message
    you could give them the ciphertext and the rotation key (and get them to give
    you theirs), and see if you can decrypt one another’s messages (remember to generate
    a conversion table).
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Caesar is an example of a *substitution cipher*, where each letter is substituted
    for another one. Other substitution ciphers improve on the Caesar cipher by not
    having all the letters in order, and some older written ciphers use different
    symbols for each symbol. However, substitution ciphers are easy to attack because
    a statistical attack is so easy: you just look for a few common letters and sequences
    of letters, and match that to common patterns in the language.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.3\. PROBLEMS WITH SUBSTITUTION CIPHERS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have looked at one way of cracking Caesar cipher: using patterns in the
    text. By looking for patterns such as one letter words, other short words, double
    letter patterns, apostrophe positions, and knowing rules such as all words (excluding
    some acronyms and words written in txt language of course) must contain at least
    one of a, e, i, o, u, or y, you were probably able to decipher the messages in
    the book with little difficulty.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many other ways of cracking Caeser cipher which we will look at in
    this section. Understanding various common attacks on ciphers is important when
    looking at the security of more sophisticated ciphers.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.1\. FREQUENCY ANALYSIS ATTACKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Frequency analysis means looking at how many times each letter appears in the
    encrypted message, and using this information to crack the message. A letter that
    appears many times in a message is far more likely to be “T” than “Z”!
  prefs: []
  type: TYPE_NORMAL
- en: For example, try copying and pasting the following text into the statistical
    analyser at [http://www.richkni.co.uk/php/crypta/freq.php](http://www.richkni.co.uk/php/crypta/freq.php).
    What is the most common letter in the code? Which English letter is that likely
    to be?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The most common letter in most English text is the letter E, so it makes sense
    to try to decrypt the message guessing that the most common letter in the ciphertext
    corresponds to E.
  prefs: []
  type: TYPE_NORMAL
- en: If that doesn’t work, you could see if the second most common letter in the
    ciphertext is E, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  prefs: []
  type: TYPE_NORMAL
- en: Although in almost all English texts the letter E is the most common letter,
    it isn’t always. For example, the [1939 novel *Gadsby* by Ernest Vincent Wright](http://en.wikipedia.org/wiki/Gadsby_(novel))doesn’t
    contain a single letter E (this is called a lipogram). Furthermore, the text you’re
    attacking may not be English. During World War 1 and 2, the US military had many
    Native American [Code talkers](http://en.wikipedia.org/wiki/Code_talker) translate
    messages into their own language, which provided a strong layer of security at
    the time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  prefs: []
  type: TYPE_NORMAL
- en: A slightly stronger cipher than the Caesar cipher is the [Vigenere cipher](http://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher),
    which is created by using multiple Caesar ciphers, where there is a key phrase
    (e.g. “acb”), and each letter in the key gives the offset (in the example this
    would be 1, 3, 2). These offsets are repeated to give the offset for encoding
    each character in the plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: By having multiple caesar ciphers, common letters such as E will no longer stand
    out as much, making frequency analysis a lot more challenging. The following website
    shows the effect on the distribution. [http://www.simonsingh.net/The_Black_Chamber/vigenere_strength.html](http://www.simonsingh.net/The_Black_Chamber/vigenere_strength.html)
  prefs: []
  type: TYPE_NORMAL
- en: However, while this makes the Vigenere cipher more challenging to crack than
    the Caeser cipher, ways have been found to crack it. In fact, once you know the
    key length, it just breaks down to cracking several Caesar ciphers (which you
    have seen is straightforward!). Several statistical methods have been devised
    for working out the key length.
  prefs: []
  type: TYPE_NORMAL
- en: A brute force attack is harder for the Vigenere cipher because there are a lot
    more possible keys. In principle there isn’t a limit to the number of key phrases
    possible, although if the phrase is too long then keeping track of the key would
    be difficult.
  prefs: []
  type: TYPE_NORMAL
- en: The Vigenere cipher is known as a *polyalphabetic substitution cipher*, since
    it is uses multiple substitution rules.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.2\. PLAIN TEXT ATTACKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another kind of attack is the *known plaintext* attack, where you know part
    or all of the solution. For example, if you know that I start all my messages
    with “HI THERE”, what is the key for the following message?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Even if you did not know the key was a rotation, you have learnt that A->H,
    B->I, M->T, X->E, and K->R. This goes a long way towards deciphering the message!
  prefs: []
  type: TYPE_NORMAL
- en: A known plaintext attack is trivial for a Caesar cipher, but a good code shouldn’t
    have this vulnerability because there it can be surprisingly easy for someone
    to know that a particular message is being sent. For example, a common message
    might be “Nothing to report”, or in online banking there are likely to be common
    messages like headings in a bank account or parts of the web page that always
    appear.
  prefs: []
  type: TYPE_NORMAL
- en: Even worse is a *chosen plaintext attack*, where you trick someone into sending
    your chosen message through their system.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it is essential for any good cryptosystem to not be breakable,
    even if the attacker has pieces of plaintext along with their corresponding ciphertext
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the cryptosystem should not give different ciphertext each time the same
    plaintext message is encrypted. It may initially sound impossible to achieve this,
    although there are several clever techniques used by real cryptosystems.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3.3\. BRUTE FORCE ATTACKS TO GUESS THE KEY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another approach to cracking a ciphertext is a *brute force attack*, which involves
    trying out all possible keys, and seeing if any of them produce intelligible text.
    This is easy for a Caesar cipher because there are only 25 possible keys. For
    example, the following ciphertext is a single word, but is too short for a statistical
    attack. Try putting it into the decoder above, and trying keys until you decipher
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: These days encryption keys are normally numbers that are 128 bits or longer.
    You could calculate how long it would take to try out every possible 128 bit number
    if a computer could test a million every second (including testing if each decoded
    text contains English words). It will eventually crack the message, but would
    it be any use after that amount of time?
  prefs: []
  type: TYPE_NORMAL
- en: '**Key size in general substition ciphers**'
  prefs: []
  type: TYPE_NORMAL
- en: While Caesar cipher has a key specifying a rotation, a more general substitution
    cipher could randomly scramble the entire alphabet. This requires a key consisting
    of a sequence of 26 letters or numbers, specifying which letter maps onto each
    other one. For example, the first part of the key could be “D, Z, E”, which would
    mean D -> A, Z -> B, E ->C. The key would have to have another 23 letters in order
    to specify the rest of the mapping.
  prefs: []
  type: TYPE_NORMAL
- en: This increases the number of possible keys, and thus reduces the risk of a brute
    force attack. A can be substituted for any of the 26 letters in the alphabet,
    B can then be substituted for any of the 25 remaining letters (26 minus the letter
    already substituted for A), C can then be substituted for any of the 24 remaining
    letters…
  prefs: []
  type: TYPE_NORMAL
- en: This gives us 26 possibilities for A times 25 possibilities for B times 24 possibilities
    for C.. all the way down to 2 possibilities for Y and 1 possibility for Z. 26*25*24*23*22*21*20*19*18*17*16*15*14*13*12*11*10*9*8*7*6*5*4*3*2*1
    = 26! Representing each of these possibilites requires around 88 bits, making
    the cipher’s key size around 88 bits!
  prefs: []
  type: TYPE_NORMAL
- en: However, this only solves one of the problems. The other techniques for breaking
    caeser cipher we have looked at are still highly effective on all substitution
    ciphers. For this reason, we need better ciphers in practice, which we will look
    at shortly!
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: The main terminology you should be familiar with now is that a *plaintext* is *encrypted* by
    to create a *ciphertext* using an *encryption key*. Someone without the encryption
    key who wants to *attack* the cipher could try various approaches, including a *brute
    force attack* (trying out all possible keys), a *frequency analysis attack* (looking
    for statistical patterns), and a *known plaintext attack* (matching some known
    text with the cipher to work out the key).
  prefs: []
  type: TYPE_NORMAL
- en: '**Steganography**'
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography is about hiding the content of a message, but sometimes it’s important
    to hide the *existence* of the message. Otherwise an enemy might figure out that
    something is being planned just because a lot more messages are being sent, even
    though they can’t read them. One way to achieve this is via *steganography*, where
    a secret message is hidden inside another message that seems innocuous. A classic
    scenario would be to publish a message in the public notices of a newspaper or
    send a letter from prison where the number of letters in each word represent a
    code. To a casual reader, the message might seem unimportant (and even say the
    opposite of the hidden one), but someone who knows the code could work it out.
    Messages can be hidden in digital images by making unnoticable changes to pixels
    so that they store some information. You can find out [more about steganography
    on Wikipedia](http://en.wikipedia.org/wiki/Steganography) or in this [lecture
    on steganography](http://www.youtube.com/watch?v=Py-qu9KWXhk#t=29).
  prefs: []
  type: TYPE_NORMAL
- en: Two fun uses of steganography that you can try to decode yourself are a [film
    about ciphers that contains hidden ciphers (called “The Thomas Beale Cipher”)](http://www.thomasbealecipher.com/),
    and an activity that has [five-bit text codes hidden in music](http://csunplugged.org/modem).
  prefs: []
  type: TYPE_NORMAL
- en: 8.4\. PUBLIC KEY SYSTEMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 8.4.1\. THE KEY DISTRIBUTION PROBLEM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alice sending an encrypted message to Bob raises an interesting problem in encryption.
    The ciphertext itself can safely be sent across an “unsafe” network (one that
    Eve is listening on), but the key cannot. How can Alice get the key to Bob? Remember
    the key is the thing that tells Bob how to convert the ciphertext back to plaintext.
    So Alice can’t include it in the encrypted message, because then Bob would be
    unable to access it! Alice can’t just include it as plaintext either, because
    then Eve will be able to get ahold of it and use it to decrypt any messages that
    come through using it! You might ask why Alice doesn’t just encrypt the key using
    a different encryption scheme, but then how will Bob know the new key? Alice would
    need to tell Bob the key that was used to encrypt it... and so on... this idea
    is definitely out!
  prefs: []
  type: TYPE_NORMAL
- en: Remember that Alice and Bob might be in different countries, and can only communicate
    through the internet. This also rules out Alice simply passing Bob the key in
    person.
  prefs: []
  type: TYPE_NORMAL
- en: Distributing keys physically is very expensive, and up to the 1970s large sums
    of money were spent physically sending keys internationally. Systems like this
    are call*symmetric* encryption, because Alice and Bob both need an identical copy
    of the key. The breakthrough was the realisation that you could make a system
    that used different keys for encoding and decoding!
  prefs: []
  type: TYPE_NORMAL
- en: 8.4.2\. SOLVING THE PROBLEM WITH PUBLIC KEY SYSTEMS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the remarkable discoveries in computer science in the 1970s was a method
    called *public key encryption*, where it’s fine to tell everyone what the key
    is to encrypt any messages, but you need a special private key to decrypt it.
    Because Alice and Bob use different keys, this is called an *asymmetric* encryption
    system.
  prefs: []
  type: TYPE_NORMAL
- en: It’s like giving out padlocks to all your friends, so anyone can lock a box
    and send it to you, but if you have the only (private) key, then you are the only
    person who can open the boxes. Once your friend locks a box, even they can’t unlock
    it. It’s really easy to distribute the padlocks. Public keys are the same — you
    can make them completely public — often people put them on their website or attach
    them to all emails they send. That’s quite different to having to hire a security
    firm to deliver them to your colleague.
  prefs: []
  type: TYPE_NORMAL
- en: Public key encryption is very heavily used for online commerce (such as internet
    banking and credit card payment) because your computer can set up a connection
    with the business or bank automatically using a public key system without you
    having to get together in advance to set up a key. Public key systems are generally
    slower than symmetric systems, so the public key system is often used to then
    send a new key for a symmetric system just once per session, and the symmetric
    key can be used from then on with a faster symmetric encryption system.
  prefs: []
  type: TYPE_NORMAL
- en: A very popular public key system is RSA. The following interactives use RSA
    so that you can try using a public key system for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, you will need to generate a pair of keys using the key generator interactive.
    Note that each key consists of two numbers and the interactive separates them
    with a “+” (this does not mean addition). You should keep the private key secret,
    and publicly announce the public key so that your friends can send you messages
    (e.g. put it on the whiteboard, or email it to some friends). Make sure you save
    your keys somewhere so you don’t forget them — a text file would be best.
  prefs: []
  type: TYPE_NORMAL
- en: RSA Key Generator
  prefs: []
  type: TYPE_NORMAL
- en: Public Key
  prefs: []
  type: TYPE_NORMAL
- en: Private Key
  prefs: []
  type: TYPE_NORMAL
- en: The second interactive is the encrypter, and it is used to encrypt or decrypt
    messages with the keys. In order to encrypt messages for you, your friends should
    use your public key (and select the “encrypt” button on the interactive). In order
    to decrypt the messages your friends have sent you, you should use your private
    key (and select the “decrypt” button on the interactive).
  prefs: []
  type: TYPE_NORMAL
- en: RSA Encrypter & Decrypter
  prefs: []
  type: TYPE_NORMAL
- en: Mode
  prefs: []
  type: TYPE_NORMAL
- en: Encrypt Decrypt
  prefs: []
  type: TYPE_NORMAL
- en: Key
  prefs: []
  type: TYPE_NORMAL
- en: Text
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs: []
  type: TYPE_NORMAL
- en: Despite even your enemies knowing your public key (as you publically announced
    it), they cannot use it to decrypt your messages which were encrypted using the
    public key.
  prefs: []
  type: TYPE_NORMAL
- en: '**Digital Signatures** In order to encrypt a message, the public key is used.
    In order to decrypt it, the corresponding private key must be used. But what would
    happen if the message was encrypted using the *private* key? Could you then decrypt
    it with the public key? Initially this might sound like a silly thing to do, as
    why would you encrypt a message which can be decrypted using a key that everybody
    in the world can access!?! It turns out that indeed, encrypting a message with
    the private key and then decrypting it with the public key works, and it has a
    very useful application! The only person who is able to *encrypt* the message
    using the *private* key is the person who owns the private key. The public key
    will only decrypt the message if the private key that was used to encrypt it actually
    is the public key’s corresponding private key! If the message can’t be decrypted,
    then it could not have been encrypted with that private key. This allows the sender
    to prove that the message actually is from them, and is known as a digital signature.'
  prefs: []
  type: TYPE_NORMAL
- en: You could check that someone is the authentic private key holder by giving them
    a phrase to encrypt with their private key. You then decrypt it with the public
    key to check that they encrypted the phrase you gave them.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this interactive’s implementation of RSA only uses around 50 bits
    of encryption and has other weaknesses. It is just for demonstrating the concepts
    here and is not quite the same as the implementations used in live encryption
    systems. In the RSA chapter, we will look at a more realistic implementation.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a [video illustrating how public key systems work using a padlock analogy
    which might help to understand how asymmetric keys could work.](http://www.youtube.com/watch?v=a72fHRr6MRU)
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Public key systems rely on *one way functions*, which are mathematical functions
    where it’s easy to calculate the output for a particular input, but very hard
    to work out the input given the output. In the physical world a telephone book
    is a one-way function: if you’re given a name, it’s easy to work out the number,
    but given someone’s phone number, it’s difficult to work out their name from the
    phone book. In cryptography a widely used one-way function is multiplying numbers.
    Given two large numbers, you can multiply them very quickly, but given the result
    of the multiplication, it is very difficult to find out what its factors are.
    For example, see if you can work out which numbers multiply to give 806,849,546,124,373,268,247,678,601\.
    You could try writing a program to try every combination of factors, but you’ll
    probably find it takes too long. Although this particular number can be factorised
    by modern software, larger numbers can’t be, and this is a problem that mathematicians
    and computer scientists can’t find an efficient solution to.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: The methods that we considered at the start of this chapter are *symmetric key* systems,
    which just means that you use the same key to encode and decode the text. Public
    key systems are often called *asymmetric key* systems, where the sender and receiver
    have different keys. An asymmetric system can make it a lot easier to distribute
    the encryption key, because if the eavesdropper gets hold of it, all they can
    do is encrypt messages, not decrypt them, so they are no use for attacking messages.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5\. THE RSA CRYPTOSYSTEM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The RSA cryptosystem is a widely used algorithm for public key systems. Many
    real world cryptosystems are based on RSA. Because it is a public key system,
    this means that keys are in pairs; a private key and a public key. A message that
    was encrypted using the public key can only be decrypted using the private key.
    This means that the key owner is able to keep their private key secret, and distribute
    their public key to the world.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, the RSA cryptosystem uses some clever math based on the unsolved
    mathematical problem of efficiently *factoring* a number which is the product
    of two prime numbers. If you need a reminder of what prime numbers and factoring
    a number are, read the Jargon Buster just below.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that the factors of a number are all the numbers which divide into
    it without giving a remainder. For example: The factors of 12 are 1, 2, 3, 4,
    6, and 12\. Numbers such as 5 and 7 are NOT factors of 12, because 12 divided
    by 7 gives 1 remainder 5.'
  prefs: []
  type: TYPE_NORMAL
- en: If a number only has 1 and itself as factors (i.e. all other numbers would give
    a remainder if divided into it), it is a prime number (For example, the factors
    of 37 are only 1 and 37, making it a prime number).
  prefs: []
  type: TYPE_NORMAL
- en: Factoring means to find all the factors of a number.
  prefs: []
  type: TYPE_NORMAL
- en: Currently the only known algorithm to find what the two primes that were multiplied
    are is a brute force one that has to try most of the possibilities that are less
    the the number itself. If the number is massive, then that is a huge number of
    possibilities that need to be checked, and it cannot be done before the sun is
    expected to burn out, even with huge amounts of computing power! This problem
    is known as the *factoring problem*. A public and private key pair has a mathematical
    relationship to the primes that were used.
  prefs: []
  type: TYPE_NORMAL
- en: If somebody was to find a good solution to this problem that could work on massive
    numbers, then RSA would no longer be secure, unlocking many important computer
    systems around the world including banks! Mathematicians are quite confident no
    such solution exists though. We aren’t going to go any further into the mathematical
    details here.
  prefs: []
  type: TYPE_NORMAL
- en: The following interactive provides a key generator and encrypter/decrypter for
    RSA. [http://travistidwell.com/jsencrypt/demo/](http://travistidwell.com/jsencrypt/demo/)
  prefs: []
  type: TYPE_NORMAL
- en: Keys of various sizes can be generated, and then used to encrypt a message.
    Encryption is carried out using the *public key*. Decryption is carried out using
    the *private key*
  prefs: []
  type: TYPE_NORMAL
- en: '**Easy vs Difficult problems in Computer Science**'
  prefs: []
  type: TYPE_NORMAL
- en: If you were asked to multiply the following two big prime numbers, you might
    find it a bit tiring to do by hand (although it is definitely doable!), but could
    get an answer in milliseconds by putting it in the big numbers calculator! (included
    just below this box).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If on the other hand you were asked what two prime numbers were multiplied to
    get the following big number, you’d have a lot more trouble! (If you do find the
    answer, let us know! We’d be very interested to hear about it!)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So why is it that despite these two problems being similar, one of them is “easy”
    and the other one is “hard”? Well, it comes down to the algorithms we have to
    solve each of the problems. You have probably done long multiplication in school
    by making one line for each digit in the second number and then adding all the
    rows together. We can analyse the speed of this algorithm, much like we did in
    the algorithms chapter for sorting and searching. Assuming that each number has
    the same number of digits, which we will call n (“Number of digits”), we need
    to write n rows. For each of those n rows, we will need to do around n multiplications.
    That gives us n*n little multiplications. We need to add the n rows together at
    the end as well, but that doesn’t take long so lets ignore that part. We have
    determined that the number of small multiplications needed to multiply two big
    numbers is approximately the square of the number of digits. So for two numbers
    with 1000 digits, that’s 1,000,000 little multiplication operations. A computer
    can do that in less than a second! If you know about Big-O notation, this is a
    O(n^2) algorithm, where n is the number of digits! Note that some slightly better
    algorithms have been designed, but this estimate is good enough for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: For the second problem, we’d need an algorithm that could find the two numbers
    that were multiplied together. You might initially say, why can’t we just reverse
    the multiplication? The reverse of multiplication is division, so can’t we just
    divide to get the two numbers? It’s a good idea, but it won’t work. For division
    we need to know the big number, and one of the small numbers we want to divide
    into it, and that will give us the other small number. But in this case, we *only* know
    the big number. So it isn’t a straightforward long division problem at all! It
    turns out that there is no known good algorithm to solve the problem. One way
    is to just try every number that is less than the number (well, we only need to
    go up to the square root, but that doesn’t help much!) There is still billions
    of billions of billions of numbers we need to check. Even a computer that could
    check 1 billion possibilities a second isn’t going to help us much with this!
    If you know about Big-O notation, this is an O(10^n) algorithm, where n is the
    number of digits – even small numbers of digits are just too much to deal with!
    There are slightly better solutions, but none of them shave off enough time to
    actually be useful for problems of the size of the one above!
  prefs: []
  type: TYPE_NORMAL
- en: The chapter on Complexity and Tractability looks at more computer science problems
    which are surprisingly challenging to solve. If you found this stuff interesting,
    do read about Complexity and Tractability when you are finished here!
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad5ec6def9.png)Click to load'
  prefs: []
  type: TYPE_NORMAL
- en: big number calculator](http://csfieldguide.org.nz/_static/widgets/big-calculator.html?plain=true%20frameborder=)
  prefs: []
  type: TYPE_NORMAL
- en: What isn’t known though, is whether or not the general problem of breaking RSA
    is actually as difficult as the factoring problem. In other words, is there a
    completely different way of breaking it that does not involve factoring numbers?
  prefs: []
  type: TYPE_NORMAL
- en: What happens when we try the tricks that we could use to break Caesar cipher?
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.1\. DOES RSA REVEAL ANY PATTERNS IN THE CIPHERTEXT?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need to scroll up to the Caesar cipher interactive for this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a Caesar cipher key of your choice, encrypt a short sentence, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, encrypt a very similar sentence using the same key, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Put the ciphertext for each side by side. As you might expect, they look very
    similar. This is problematic given that if Eve has the first message, she could
    probably use it to guess the second one! This means Caesar cipher is not *semantically
    secure*. It is essential that ciphers used in practice are!
  prefs: []
  type: TYPE_NORMAL
- en: But what about RSA? Do similar plaintext messages lead to similar ciphertext
    messages when RSA is used?
  prefs: []
  type: TYPE_NORMAL
- en: In order to find out, generate an RSA key and use it to encrypt each of the
    two above messages. What do you observe?
  prefs: []
  type: TYPE_NORMAL
- en: Because of how RSA encrypts messages, the way each character is jumbled is dependent
    on all the other characters in the message. This makes many of the analysis techniques
    we used to break Caeser cipher useless for breaking RSA! Well, nearly...
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster: Semantically Secure**'
  prefs: []
  type: TYPE_NORMAL
- en: Semantically secure means that there is no known efficient algorithm that can
    use the ciphertext to get any information about the plaintext, other than the
    length of the message. It is very important that cryptosystems used in practice
    are semantically secure.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.2\. ADDING PADDING TO THE PLAINTEXT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The plain RSA algorithm actually fails one important requirement of a good cryptosystem
    though! If Eve thinks she knows what message Alice is sending to Bob using public
    key encryption, she can attempt to encrypt that message using the public key and
    then see if the ciphertext she gets is the same as what Alice sent. If it is,
    she now knows what Alice sent Bob!
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, a simple solution to this problem has been found. Alice can add random *padding* to
    the plaintext message, which then gets mixed into her message in the ciphertext.
    As long as Bob’s computer knows how much padding is on the message so that once
    it decrypts the message, it can throw away the padding, this will work.
  prefs: []
  type: TYPE_NORMAL
- en: For example, assume 5 characters of padding have been added onto the end of
    Alice’s message. Hi Bob, want to meet for lunch?1si98 Even if Eve knew it was
    likely Alice was asking Bob to go to lunch with her, she would have no way of
    knowing what random padding has been used. She might try Hi Bob, want to meet
    for lunch?72kld
  prefs: []
  type: TYPE_NORMAL
- en: Try encrypting both of these messages using the same public key. Is there any
    way to know from the ciphertext that they are even the same message?
  prefs: []
  type: TYPE_NORMAL
- en: Cryptosystems which implement RSA use padding in order to counteract this weakness
    of RSA in practice. This makes them *semantically secure*
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.3\. CAN WE JUST GUESS THE RSA KEY?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might remember from the Algorithms chapter that problems can have good and
    bad algorithms to solve them, and that a good algorithm is fast even when the
    size of the problem is massive. While we have no good algorithms for breaking
    a message that is encrypted with RSA without the key, we have good algorithms
    for encrypting or decrypting the message, given the appropriate key. This means
    that large keys can be used, that will take a long time to guess with brute force.
  prefs: []
  type: TYPE_NORMAL
- en: If we were using a key size of 1024 bits (which is pretty standard), this would
    mean that there are 2^1024 different possible keys. Even if every computer in
    the world was working to guess the key and was able to check a million combinations
    a second, the universe will still end well before the key is guessed!
  prefs: []
  type: TYPE_NORMAL
- en: You might like to calculate how long it would take for various levels of encryption
    to be broken. e.g. 256, 1024, 2048, and 4096 using a big numbers calculator.
  prefs: []
  type: TYPE_NORMAL
- en: RSA normally uses keys in the size range of 1024 bits to 4096 bits. This makes
    it incredibly unlikely for somebody to guess the key!
  prefs: []
  type: TYPE_NORMAL
- en: 8.5.4\. A PITFALL OF RSA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far RSA has held up really well against the potential attacks we have looked
    at. However, one big problem exists. How can Alice be certain that the public
    key she is about to use actually is Bob’s? This problem isn’t trivial, as Eve
    could easily publish that a public key belongs to Bob, when infact it is Eve that
    has the private key for it! All she has to do is get Alice to encrypt a message
    with that public key, mistakenly believing it is Bob’s, and she can now intercept
    and read the message with the private key she holds!
  prefs: []
  type: TYPE_NORMAL
- en: No mathematical solution exists, although there is a practical solution. Public
    Key Certificates are distributed by Public Key Certificate Authorities (CA’s)
    in order to prove the ownership of a public key. This now assumes that the CA’s
    are trustworthy and that they won’t be fooled or compromised. For the most part
    it works, although there have been some [worrying exceptions…](http://en.wikipedia.org/wiki/Certificate_authority#CA_compromise)
  prefs: []
  type: TYPE_NORMAL
- en: 8.6\. THE WHOLE STORY!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of the examples in this chapter use very weak encryption methods that were
    chosen to illustrate concepts, but would never be used for commercial or military
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: There are many aspects to computer security beyond encryption. For example,
    access control (such as password systems and security on smart cards) is crucial
    to keeping a system secure. Another major problem is writing secure software which
    doesn’t leave ways for a user to get access to information that they shouldn’t
    (such as typing a database command into a website query and have the system accidentally
    run it, or overflowing the buffer with a long input, which could accidentally
    replace parts of the program). Also, systems need to be protected from “denial
    of service” (DOS) attacks, where they get so overloaded with requests (e.g. to
    view a web site) that the server can’t cope, and legitimate users get very slow
    response from the system, or it might even fail completely.
  prefs: []
  type: TYPE_NORMAL
- en: For other kinds of attacks relating to computer security, see the [Wikipedia
    entry on Hackers](http://en.wikipedia.org/wiki/Hacker_(computer_security)).
  prefs: []
  type: TYPE_NORMAL
- en: There’s a dark cloud hanging over the security of all current encryption methods: [Quantum
    computing](http://en.wikipedia.org/wiki/Quantum_computer). Quantum computing is
    in its infancy, but if this approach to computing is successful, it has the potential
    to run very fast algorithms for attacking our most secure encryption systems (for
    example, it could be used to factorise numbers very quickly). In fact, the quantum
    algorithms have already been invented, but we don’t know if quantum computers
    can be built to run them. Such computers aren’t likely to appear overnight, and
    if they do become possible, they will also open the possibility for new encryption
    algorithms. This is yet another mystery in computer science where we don’t know
    what the future holds, and where there could be major changes in the future. But
    we’ll need very capable computer scientists around at the time to deal with these
    sorts of changes!
  prefs: []
  type: TYPE_NORMAL
- en: On the positive side, [quantum information transfer protocols](http://en.wikipedia.org/wiki/Quantum_cryptography_protocol) exist
    and are used in practice (using specialised equipment to generate quantum bits);
    these provide what is in theory a perfect encryption system, and don’t depend
    on an attacker being unable to solve a particular computational problem. Because
    of the need for specialised equipment, they are only used in high security environments
    such as banking.
  prefs: []
  type: TYPE_NORMAL
- en: 8.7\. FURTHER READING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Wikipedia entry on cryptography](http://en.wikipedia.org/wiki/Cryptography) has
    a fairly approachable entry going over the main terminology used in this chapter
    (and a lot more)
  prefs: []
  type: TYPE_NORMAL
- en: The encryption methods used these days rely on fairly advanced maths; for this
    reason books about encryption tend to either be beyond high school level, or else
    are about codes that aren’t actually used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of intriguing stories around encryption, including its use in
    wartime and for spying e.g.
  prefs: []
  type: TYPE_NORMAL
- en: How I Discovered World War II’s Greatest Spy and Other Stories of Intelligence
    and Code (David Kahn)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Decrypted Secrets: Methods and Maxims of Cryptology (Friedrich L. Bauer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Secret History: The Story of Cryptology (Craig Bauer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Codebreakers: The Comprehensive History of Secret Communication from Ancient
    Times to the Internet (David Kahn) — this book is an older version of his new
    book, and may be hard to get'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following activities explore cryptographic protocols using an Unplugged
    approach; these methods aren’t strong enough to use in practice, but provide some
    insight into what is possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://csunplugged.org/information-hiding](http://csunplugged.org/information-hiding)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://csunplugged.org/cryptographic-protocols](http://csunplugged.org/cryptographic-protocols)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://csunplugged.org/public-key-encryption](http://csunplugged.org/public-key-encryption)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[War in the fifth domain](http://www.economist.com/node/16478792) looks at
    how encryption and security are key to our defence against a new kind of war.'
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of [articles in cs4fn on cryptography](http://www.cs4fn.org/security/crypto/),
    including [a statistical attack that lead to a beheading](http://www.cs4fn.org/security/beheading/secrets1.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The book “Hacking Secret Ciphers with Python: A beginner’s guide to cryptography
    and computer programming with Python” (by Al Sweigart) goes over some simple ciphers
    including ones mentioned in this chapter, and how they can be programmed (and
    attacked) using Python programs.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.7.1\. USEFUL LINKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[How Stuff Works entry on Encryption](http://www.howstuffworks.com/encryption.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cryptool](http://www.cryptool.org/) is a free system for trying out classical
    and modern encryption methods. Some are beyond the scope of this chapter, but
    many will be useful for running demonstrations and experiments in cryptography.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia entry on Cryptographic keys](http://en.wikipedia.org/wiki/Key_%28cryptography%29)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia entry on the Caesar cipher](http://en.wikipedia.org/wiki/Caesar_cypher)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Videos about modern encryption methods](http://simonsingh.net/media/online-videos/cryptography/the-science-of-secrecy-going-public/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Online interactives for simple ciphers](http://www.braingle.com/brainteasers/codes/index.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9\. ERROR CONTROL CODING
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 9.1\. WHAT’S THE BIG PICTURE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The parity magic trick (in the video above) enables the magician to detect which
    card out of dozens has been flipped over while they weren’t looking. The magic
    in the trick is actually computer science, using the same kind of technique that
    computers use to detect and correct errors in data. We will talk about how it
    works in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The same thing is happening to data stored on computers — while you (or the
    computer) is looking away, some of it might accidentally change because of a minor
    fault. When the computer reads the data, you don’t want it to just use the incorrect
    values. At the least you want it to detect that something has gone wrong, and
    ideally it should do what the magician did, and put it right.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is about guarding against errors in data in its many different
    forms — data stored on a harddrive, on a CD, on a floppy disk, on a solid state
    drive (such as that inside a cellphone, camera, or mp3 player), data currently
    in RAM (particularly on servers where the data correctness is critical), data
    going between the RAM and hard drive or between an external hard drive and the
    internal hard drive, data currently being processed in the processor or data going
    over a wired or wireless network such as from your computer to a server on the
    other side of the world. It even includes data such as the barcodes printed on
    products or the number on your credit card.
  prefs: []
  type: TYPE_NORMAL
- en: If we don’t detect that data has been changed by some physical problem (such
    as small scratch on a CD, or a failing circuit in a flash drive), the information
    will just be used with incorrect values. A very poorly written banking system
    could potentially result in your bank balance being changed if just one of the
    bits in a number was changed by a cosmic ray affecting a value in the computer’s
    memory! If the barcode on the packet of chips you buy from the shop is scanned
    incorrectly, you might be charged for shampoo instead. If you transfer a music
    file from your laptop to your mp3 player and a few of the bits were transferred
    incorrectly, the mp3 player might play annoying glitches in the music. Error control
    codes guard against all these things, so that (most of the time) things just work
    without you having to worry about such errors.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways that data can be changed accidentally. Networks that
    have a lot of “noise” on them (caused by poor quality wiring, electrical interference,
    or interference from other networks in the case of wireless). The bits on disks
    are very very small, and imperfections in the surface can eventually cause some
    of the storage to fail. The surfaces on compact disks and DVDs are exposed, and
    can easily be damaged by storage (e.g. in heat or humidity) and handling (e.g.
    scratches or dust). Errors can also occur when numbers are typed in, such as entering
    a bank account number to make a payment into, or the number of a container that
    is being loaded onto a ship. A barcode on a product might be slightly scratched
    or have a black mark on it, or perhaps the package is bent or is unable to be
    read properly due to the scanner being waved too fast over it. Bits getting changed
    on permanent storage (such as hard drives, optical disks, and solid state drives)
    is sometimes referred to as bit rot, and the [wikipedia page on bit rot](http://en.wikipedia.org/wiki/Bit_rot) has
    a list of more ways that these errors can occur.
  prefs: []
  type: TYPE_NORMAL
- en: Nobody wants a computer that is unreliable and won’t do what it’s supposed to
    do because of bits being changed! So, how can we deal with these problems?
  prefs: []
  type: TYPE_NORMAL
- en: Error control coding is concerned with detecting when these errors occur, and
    if practical and possible, correcting the data to what it is supposed to be.
  prefs: []
  type: TYPE_NORMAL
- en: Some error control schemes have error correction built into them, such as the
    parity method that was briefly introduced at the beginning of this section. You
    might not understand yet how the parity trick worked, but after the card was flipped,
    the magician *detected* which card was flipped, and was able to *correct* it.
  prefs: []
  type: TYPE_NORMAL
- en: Other error control schemes, such as those that deal with sending data from
    a server overseas to your computer, send the data in very small pieces called
    packets (the network protocols chapter talks about this) and each packet has error
    detection information added to it.
  prefs: []
  type: TYPE_NORMAL
- en: Error detection is also used on barcode numbers on products you buy, as well
    as the unique ISBN (International Standard Book Number) that all books have, and
    even the 16 digit number on a credit card. If any of these numbers are typed or
    scanned incorrectly, there’s a good chance that the error will be detected, and
    the user can be asked to re-enter the data.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should understand the basic idea of error control
    coding, the reasons that we require it, the differences between algorithms that
    can detect errors and those that can both detect and correct errors, and some
    of the ways that error control coding is used, in particular parity (focussing
    on the parity magic trick) and the check digits used to ensure book numbers, barcode
    numbers, and credit card numbers are entered correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2\. THE PARITY MAGIC TRICK
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have never seen the parity magic trick before, check out the video in
    the “What’s the Bigger Picture?” section above. This section assumes that you
    know what is meant by the parity magic trick, but now we’ll explain how it actually
    works!
  prefs: []
  type: TYPE_NORMAL
- en: A magician asks an observer to lay out a square grid of two-sided cards, and
    the magician then says they are going to make it a bit harder, and add an extra
    row and column to the square. The magician then faces the other way while the
    observer flips over one card. The magician turns back around again, and tells
    the observer which card was flipped!
  prefs: []
  type: TYPE_NORMAL
- en: The question now is, how did the magician know which card had been flipped without
    seeing the card being flipped, or memorising the layout?! The short answer is
    error control coding. Let’s look more closely at that…
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.1\. CARRYING OUT THE PARITY TRICK
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are now going to take the role of the magician and carry out the trick yourself.
    The interactive below will allow you to practice it.
  prefs: []
  type: TYPE_NORMAL
- en: In the interactive, the computer has a 7x7 grid of black and white cards. You
    must choose the colour of an extra card for each row (at the right) and column
    (at the bottom), making an 8x8 grid of cards. Each extra card should be chosen
    so that each row and column has an even number of black cards (since there are
    8 cards, there will also be an even number of white cards). The bottom right-hand
    card can be chosen from either its row or column; they should both give the same
    colour. Once you think you have this correct, you should tell the computer to
    flip a card. An animation will appear for a few seconds, and then the cards will
    reappear with one card flipped (all the rest will be the same as before). Your
    task is to identify the flipped card. You should be able to do this *without* having
    memorised the layout. Remember the pattern you made with the extra cards you added?
    That’s the key to figuring it out. Once you think you have identified the card,
    click it to see whether or not you were right! The interactive will guide you
    through these instructions. If you are completely stuck identifying the flipped
    card, a hint follows the interactive, although you should try and figure it out
    for yourself first! Make sure you add the extra cards correctly; the computer
    won’t tell you if you get them wrong, and you probably won’t be able to identify
    the flipped card if the extra cards aren’t chosen correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad79c608bd.png)Click to load the parity widget](http://csfieldguide.org.nz/_static/widgets/DR/DR-Parity/public_html/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Remember how you made it so that each column had an even number of black cards?
    When a card is flipped, this results in the row and column that the card was in
    having an odd number of black cards. So all you need to do is to identify the
    row and column that have an odd number of black and white cards, and the card
    that is at the intersection of them must be the one that was flipped!
  prefs: []
  type: TYPE_NORMAL
- en: What we saw above is a simple error control coding algorithm, known as *2-dimensional
    parity*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cards represent bits, with their two states being black and white (in the
    “data representation” chapter we looked at how a bit can be stored by anything
    that can be in one of two states: shiny/not shiny, magnetised/not magnetised,
    high voltage/low voltage, black/white, etc). The original 7x7 cards that the computer
    laid out for you could be some kind of data, for example some text represented
    using bits, or an image, or some numbers. Although they are laid out in a grid,
    on a computer the rows of bits would be stored or transmitted one after the other
    (as 8 lots of 8 bits).'
  prefs: []
  type: TYPE_NORMAL
- en: The extra cards you added are called *parity bits*. Parity simply means whether
    a number is even or odd (the word comes from the same root as “pair”). By adding
    the extra cards in a way that ensured an even number of black cards in each row
    and column, you made it so that the rows and columns had what is called *even
    parity*.
  prefs: []
  type: TYPE_NORMAL
- en: When a card was flipped, this simulated an error being made in your data (such
    as a piece of dust landing on a bit stored on a CD, or a cosmic ray changing a
    bit stored on a hard disk, or electrical interference changing a bit being sent
    over a network cable). Because you knew that each row and column was supposed
    to have an even number of black and white cards in it, you could tell that there
    was an error from the fact that there was a column and row that had an odd number
    of black cards in it. This means that the algorithm is able to detect errors,
    i.e. it has **error detection**. The specific card that had been flipped was at
    the intersection of the row and column that had an odd number of black cards and
    white cards in them, and because you were able to identify exactly which card
    was flipped, you were able to correct the error, i.e the algorithm has **error
    correction**.
  prefs: []
  type: TYPE_NORMAL
- en: If you had not added the parity bits, you would have had no way of even knowing
    an error had occurred, unless you had memorised the entire layout of cards! And
    what if more than one bit had been flipped? We’ll consider this later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Being a magician**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learnt how the parity trick works, you might like to try it
    with a physical set of cards like the busker in the video, or you could use any
    objects with two distinct sides, such as coins or cups. You could use playing
    cards, but the markings can be distracting, and cards with two colours are easiest
    (you can make them by cutting up sheets of card with the two colours on, or single
    coloured card with a scribble or sticker on one side).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find details and lots of ideas relating to the trick [here](http://csunplugged.org/error-detection),
    or follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Ask a friend to lay out 25 cards in a 5 by 5 grid, trying to have a reasonably
    random mix of blacks and whites (this is smaller than the one in the interactive,
    but it is easier to have fewer cards to avoid errors in the next step!)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take all the remaining cards, and then say that actually, 5 by 5 is too easy
    so you are going to make it 6 by 6\. Instead of adding the new row and column
    randomly though, you are adding them in the way you did in the interactive (even
    parity). Do this as fast as you can without making errors (it can look very casual
    if you practise this, even though the cards are being carefully selected).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tell your friend that you are going to face the other way, and you want them
    to flip over one card while you are not looking.Check that they’ve flipped exactly
    one card.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn around again once they have flipped a card, look through the rows and columns,
    identifying a row and then a column that has an odd number of black cards in it.
    The flipped card will be the one at the intersection of that row and column. Flip
    that card back over.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It would take some practice to be able to add the extra cards, and identify
    the flipped card without the observer noticing that you are thinking hard about
    it. With practice you should be able to do it while having a casual conversation.
    Once you master it, you’ve got a great trick for parties, or even for busking.
  prefs: []
  type: TYPE_NORMAL
- en: To make it more showy, you can pretend that you are mind reading the person,
    waving your hands over the cards. A particular impressive variation is to have
    an assistant come in to the room after the card has been flipped; even though
    they haven’t seen any of the setup, they will still be able to detect the error.
  prefs: []
  type: TYPE_NORMAL
- en: 9.2.2\. INVESTIGATING THE PARITY TRICK A LITTLE FURTHER
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, you should be able to carry out the parity trick well enough
    that you can demonstrate that you understand how to do it. The remainder of this
    section is focussed on exploring further ideas in error control coding related
    to the parity trick. You can either continue to read through the rest of this
    section and explore the interesting questions raised, or you can skip forward
    to one of the other sections.
  prefs: []
  type: TYPE_NORMAL
- en: It would be ideal to have some physical parity cards at this point that you
    can layout in front of you and play around with to explore the questions raised.
  prefs: []
  type: TYPE_NORMAL
- en: An error control coding algorithm can often detect errors more easily than it
    can correct them. Errors involving multiple bits can sometimes even go undetected.
    What if the computer (or your friend if you were being a magician with actual
    parity cards) had been sneaky and turned over two cards instead of one? You could
    start by getting a friend or classmate to actually do this. Repeat it a few times.
    Are you always able to correct the errors, or do you get it wrong?
  prefs: []
  type: TYPE_NORMAL
- en: Remember that to *detect* errors using this algorithm, you know that if one
    or more rows and/or columns has an odd number of blacks and whites in it, that
    there must be at least one error. In order to *correct* errors you have to be
    able to pinpoint the specific card(s) that were flipped.
  prefs: []
  type: TYPE_NORMAL
- en: Are you always able to detect when an error has occurred if 2 cards have been
    flipped? Why? Are you ever able to correct the error? What about with 3 cards?
  prefs: []
  type: TYPE_NORMAL
- en: There is actually a way to flip 4 cards where the error is then *undetected* meaning
    that the algorithm will be unable to detect the error. Can you find a way of doing
    this?
  prefs: []
  type: TYPE_NORMAL
- en: With more parity cards, we can detect and possibly correct more errors. Lets
    explore a very simple system with minimal parity cards. We can have a 7x7 grid
    of data with just one parity card. That parity card makes it so that there is
    an even number of black cards in the entire layout (including the parity card).
    How can you use this to detect errors? Are you ever able to correct errors in
    this system? In what situations do errors go undetected (think when you have multiple
    errors, i.e. more than one card flipped).
  prefs: []
  type: TYPE_NORMAL
- en: So going back to the actual parity trick that has the 7 by 7 grid, and 15 parity
    cards to make it 8 by 8, it is interesting to note that only 1 extra card was
    needed to detect that an error had occurred, but an extra 15 cards were needed
    to be able to correct the error. In terms of the cost of an algorithm, it costs
    a lot more space to be able to correct errors than it does to be able to simply
    detect them!
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you use grids of different sizes? The grid doesn’t have to
    have an even number of black cards *and* an even number of white cards, it just
    happens that whenever you have an even number sized grid with the parity bits
    added (e.g. the 8x8 we have mostly used in this section) and you have an even
    number of black cards, you will also have to have an even number of whites, which
    makes it a bit easier to keep track of.
  prefs: []
  type: TYPE_NORMAL
- en: Try a 6x6 grid with parity cards to make it 7x7\. The parity cards simply need
    to make each row and column have an even number of black cards (in this case there
    will always be an odd number of white cards in each row and column). The error
    detection is then looking for rows and columns that have an odd number of black
    cards in them (but an even number of white cards). Interestingly, the grid doesn’t
    even have to be a square! You could use 4x7 and it would work!
  prefs: []
  type: TYPE_NORMAL
- en: There’s also no limit on the size. You could create a 10x10 grid (100 cards),
    and still be able to detect which card has been flipped over. Larger grids make
    for an even more impressive magic trick.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3\. CHECK DIGITS ON BARCODES AND OTHER NUMBERS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You probably wouldn’t be very happy if you bought a book online by entering
    the ISBN (International Standard Book Number), and the wrong book was sent to
    you, or if a few days after you ordered it, you got an email saying that the credit
    card number you entered was not yours, but was instead one that was one digit
    different and another credit card holder had complained about a false charge.
    Or if you went to the shop to buy a can of drink and the scanner read it as being
    a more expensive product. Sometimes, the scanner won’t even read the barcode at
    all, and the checkout operator has to manually enter the number into the computer
    — but if they don’t enter it exactly as it is on the barcode you could end up
    being charged for the wrong product. These are all examples of situations that
    error control coding can help prevent.
  prefs: []
  type: TYPE_NORMAL
- en: Barcode numbers, credit card numbers, ISBNs, the NHI (National Health Index,
    the unique identifier given to all users of the NZ health system), IRD numbers
    (Inland Revenue Department number for all NZ taxpayers) all have error control
    coding in them to help reduce the chance of errors. The last digit in each of
    these numbers is a check digit, which is obtained doing a special calculation
    on all the other digits in the number. If for example you enter your credit card
    number into a web form to buy something, it will calculate what the 16th digit
    should be, using the first 15 digits and the special calculation (there are 16
    digits in a credit card number). If the 16th digit that it expected is not the
    one you entered, it can tell that there was an error made when the number was
    entered and will notify you that the credit card number is not valid.
  prefs: []
  type: TYPE_NORMAL
- en: In this section we will be initially looking at one of the most commonly used
    barcode number formats used on most products you buy from supermarkets and other
    shops. We will then be having a look at credit card numbers. You don’t have to
    understand *why* the calculations work so well (this is advanced math, and isn’t
    important for understanding the overall ideas), and while it is good for you to
    know what the calculation is, it is not essential. So if math is challenging and
    worrying for you, don’t panic too much because what we are looking at in this
    section isn’t near as difficult as it might initially appear!
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.1\. CHECK DIGITS ON PRODUCT BARCODES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most products you can buy at the shop have a barcode on them with a 13 digit
    global trade item number (referred to as GTIN-13). The first 12 digits are the
    actual identification number for the product, the 13th is the check digit calculated
    from the other 12\. Not all barcodes are GTIN-13, there are several others around.
    If the barcode has 13 numbers in it, it is almost certainly GTIN-13.
  prefs: []
  type: TYPE_NORMAL
- en: The following spreadsheet checks GTIN-13 barcodes. Enter a barcode number into
    the interactive, and it will tell you whether or not you typed it correctly! Start
    by using the barcode number of a box of 30 cans of coke; “9 300675 036009”. What
    happens if you then change one digit to something else?
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here to download the spreadsheet.](http://csfieldguide.org.nz/_static/interactives/ec/isbncreditcardcheckerv2.xlsx)'
  prefs: []
  type: TYPE_NORMAL
- en: Have a look for another product that has a barcode on it, such as a food item
    from your lunch, or a stationery item. Your teacher might also bring various packaging
    that has barcodes on it for you to try. Note that some barcodes are a little different.
    Make sure the barcodes that you are using have 13 digits (although you might like
    to go and find out how the check digit works on some of the other ones). Hopefully
    you will find that the interactive is always able to determine whether or not
    you typed the barcode correctly!
  prefs: []
  type: TYPE_NORMAL
- en: One of the following product numbers has one incorrect digit. Can you tell which
    of the products is wrong?
  prefs: []
  type: TYPE_NORMAL
- en: 9 400550 619775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9 400559 001014
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9 300617 013199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you were scanning the above barcodes in a supermarket, the incorrect one
    will need to be rescanned, and the system can tell that it’s a wrong number without
    even having to look it up.
  prefs: []
  type: TYPE_NORMAL
- en: You could try swapping barcode numbers with a classmate, but before giving them
    the number toss a coin, and if it’s heads, change one digit of the barcode before
    you give it to them. Can they determine that they’ve been given an erroneous barcode?
  prefs: []
  type: TYPE_NORMAL
- en: If one of the digits is incorrect, this calculation will produce a different
    value to the checksum, and signals an error. So single digit errors will always
    be detected, but what if two digits change — will that always detect the error?
  prefs: []
  type: TYPE_NORMAL
- en: What if the error is in the checksum itself but not in the other digits - will
    that be detected?
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.2\. HOW DO CHECK DIGITS PROTECT AGAINST COMMON HUMAN ERRORS?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: People can make mistakes when they enter numbers into computers, and even barcode
    scanners can get a digit wrong. Check digits attempt to detect when an error has
    occurred and notify the computer and/or person of it. Suppose you give your cellphone
    number to a friend so that they can contact you later. To ensure that you told
    them the number correctly, you may get them to text you immediately to confirm
    (and so that you have their number too). If you don’t get the text you will probably
    double check the number and will find that your friend made an error, for example
    they got a digit wrong or they reversed 2 digits next to one another. Mistakes
    happen, and good systems prevent those mistakes from having annoying or even serious
    consequences. If a check digit is being used, there is a good chance that the
    error will be detected when the check digit is not what the computer expects it
    to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the really common errors are:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting one digit wrong (substitution)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swapping two digits that are adjacent (transposition)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing a digit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a digit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two will be picked up from the expected length of the number; for example,a
    GTIN-13 has 13 numbers, so if 12 or 14 were entered, the computer immediately
    knows this is not right. The first two depend on the check digit in order to be
    detected. Interestingly, all one digit errors will be detected by common checksum
    systems, and *most* transpositions will be detected (can you find examples of
    transpositions that aren’t detected, using the interactive above?)
  prefs: []
  type: TYPE_NORMAL
- en: There are also some less common errors that people make - Getting a digit wrong
    in two or more different places - Doubling the wrong digit, e.g. putting 3481120
    instead of 3481220 - Muddling 3 digits, e.g. 14829 instead of 12489 - Phonetic
    errors are possible when the number was read and typed by somebody listening (or
    reading the number to themselves as they type it). For example, “three-forty”
    (340) might be heard as “three-fourteen” (314), and numbers like 5 and 9 can sound
    similar on a bad phone line.
  prefs: []
  type: TYPE_NORMAL
- en: Experiment further with the interactives for the product barcodes and/or credit
    card numbers. What errors are picked up? What errors can you find that are not?
    Are the really common errors nearly always picked up? Can you find any situations
    that they are not? Try to find examples of errors that are detected and errors
    that are not for as many of the different types of errors as you can.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a program to calculate checksums is a good programming exercise. It
    can be made simple by having each digit entered separately, or part of the exercise
    could be to separate the digits. It’s also not hard to create a spreadsheet to
    do these calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.3\. HOW IS THE CHECK DIGIT ON PRODUCT BARCODES CALCULATED?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first 12 numbers of the barcode represent information such as the country
    origin, manufacturer, and an identifier for the product. The 13th digit is a check
    digit, it is calculated from the first 12 digits.
  prefs: []
  type: TYPE_NORMAL
- en: So, given the first 12 digits of a barcode number, how is the 13th digit calculated?
    The following algorithm is used (also, see the example below).
  prefs: []
  type: TYPE_NORMAL
- en: Multiply every second digit (starting with the second digit) by 3, and every
    other digit by 1 (so they stay the same).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add up all the multiplied numbers to obtain the *sum*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The check digit is whatever number would have to be added to the sum in order
    to bring it up to a multiple of 10 (i.e. the last digit of the sum should be 0).
    Or more formally, take the last digit of the sum and if it is 0, the check digit
    is 0\. Otherwise, subtract the last digit from 10 to obtain the check digit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lets look at an example to illustrate this algorithm. We want to confirm that
    the check digit that was put on the barcode of a bottle of coke was the correct
    one. Its barcode number is 9300675032247\. The last digit, 7, is the check digit.
    So we take the first 12 digits and multiply them by 1 or 3, depending on their
    positions (9x1+3x3+0x1+0x3+6x1+7x3+5x1+0x3+3x1+2x3+2x1+4x3). We then add up all
    the multiplied numbers, obtaining a sum of 73\. We want to add the check digit
    that will bring the sum up to the nearest multiple of 10, which is 80\. This number
    is 7, which is indeed the check digit on the coke bottle’s barcode.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm to check whether or not a barcode number was correctly entered
    is very similar. This time, we are using all 13 digits.
  prefs: []
  type: TYPE_NORMAL
- en: Multiply every second digit (starting with the second digit) by 3, and every
    other digit by 1\. This includes the 13th digit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add up all the multiplied numbers to obtain the *sum*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the last digit of the sum is a 0, the number was entered correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**'
  prefs: []
  type: TYPE_NORMAL
- en: A quick way to add up a checksum that can be done in your head with some practice
    is to separate the numbers to be multiplied by 3, add them up, and then multiply
    by 3\. For the example above (9300675032247) the two groups are 9+0+6+5+3+2+7
    = 32 and 3+0+7+0+2+4= 16\. So we add 32 + 16x3, which gives the total of 80 including
    the check digit.
  prefs: []
  type: TYPE_NORMAL
- en: '**For Experts: Why does this algorithm work so well?**'
  prefs: []
  type: TYPE_NORMAL
- en: In order to be effective, the algorithm needs to ensure the multiplied digits
    will not add up to a multiple of 10 any more if the digits are changed slightly.
    The choice of multipliers affects how likely it is to detect small changes in
    the input. It’s possible to analyse these mathematically to work out what sorts
    of errors can be detected.
  prefs: []
  type: TYPE_NORMAL
- en: The check digit on barcodes is described in the >. Basically every second digit
    is multiplied by 3, and the sum of these multiples are added to the remaining
    digits.
  prefs: []
  type: TYPE_NORMAL
- en: Lets look at some smaller examples with 5 digits (4 normal digits and a check
    digit), as the same ideas will apply to the 13 digit numbers.
  prefs: []
  type: TYPE_NORMAL
- en: If we need a check digit for 8954, we would calculate (8x1)+(9x3)+(5x1)+(4x3)=52,
    and in order to bring this up to 60, we need to add 8\. This makes the full number
    89548.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we should observe is that only the ones column (last digit)
    of each number added have any impact on the check digit. 8+27+5+12=52, and 8+7+5+2=22
    (only looking at the last digit of each number we are adding). Both these end
    in a 2, and therefore need 8 to bring them up to the nearest multiple of 10\.
    You might be able to see why this is if you consider that the “2” and “1” were
    cut from the tens column, they are equal to 10+20=30, a multiple of 10\. Subtracting
    them only affects the tens column and beyond. This is always the case, and therefore
    we can simplify the problem by only adding the ones column of each number to the
    sum. (This can also be used as a shortcut to calculate the checksum in your head).
  prefs: []
  type: TYPE_NORMAL
- en: '*Protection against single digit errors*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, lets look at why changing *one* digit in the number to another digit will *always* be
    detected with this algorithm. Each digit will contribute a number between 0 and
    9 to the sum (remember we only care about the ones column now). As long as changing
    the digit will result in it contributing a different amount to the sum, it becomes
    impossible for it to still sum to a multiple of 10\. Remember that each digit
    is either multiplied by 1 or 3 before its ones column is added to the sum.
  prefs: []
  type: TYPE_NORMAL
- en: A number being multiplied by 1 will always contribute itself to the sum. If
    for example the digit was supposed to be 9, no other single digit can contribute
    9 to the sum. So those multiplied by 1 are fine.
  prefs: []
  type: TYPE_NORMAL
- en: But what about those multiplied by 3? To answer that, we need to look at what
    each different digit contributes to the sum when multiplied by 3.
  prefs: []
  type: TYPE_NORMAL
- en: 1 -> 3
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 -> 6
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 3 -> 9
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 -> 2 (from 1*2*)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 5 -> 5 (from 1*5*)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 6 -> 8 (from 1*8*)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 7 -> 1 (from 2*1*)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 -> 4 (from 2*4*)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 9 -> 7 (from 2*7*)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 -> 0
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: If you look at the right hand column, you should see that no number is repeated
    twice. This means that no digit contributes the same amount to the sum when it
    is multiplied by 3!
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we know that all single digit errors will be detected.
  prefs: []
  type: TYPE_NORMAL
- en: '*Protection against swapping adjacent digit errors*'
  prefs: []
  type: TYPE_NORMAL
- en: Seeing why the algorithm is able to protect against most swap errors is much
    more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: If two digits are next to one another, one of them must be multiplied by 1,
    and the other by 3\. If they are swapped, then this is reversed. For example,
    if the number 89548 from earlier is changed to 8*59*48, then (5x3)+(9x1)=24 is
    being added to the total instead of (9x3)+(5x1)=32\. Because 24 and 32 have different
    values in their ones columns, the amount contributed to the total is different,
    and therefore the error will be detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'But are there any cases where the totals will have the same values in their
    ones columns? Another way of looking at the problem is to take a pair of rows
    from the table above, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: 8 -> 4
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 -> 6
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that the first column is how much will be contributed to the total
    for digits being multiplied by 1, and the second column is for those being multiplied
    by 3\. Because adjacent digits are each multiplied by a different amount (one
    by 3 and the other by 1), the numbers diagonal to each other in the chosen pair
    will be added.
  prefs: []
  type: TYPE_NORMAL
- en: If for example the first 2 digits in a number are “28”, then we will add 2+4=6
    to the sum. If they are then reversed, we will add 8+6=14, which is equivalent
    to 4 as again, the “10” part does not affect the sum. 8+6 and 2+4 are the diagonals
    of the pair!
  prefs: []
  type: TYPE_NORMAL
- en: '*8* -> **4**'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2** -> *6*'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: So the question now is, can you see any pairs where the diagonals would add
    up to the same value? There is one!
  prefs: []
  type: TYPE_NORMAL
- en: '*Protection against twin errors*'
  prefs: []
  type: TYPE_NORMAL
- en: A twin error is where a digit that is repeated twice in a number is changed
    to a different digit that is repeated twice. For example, if we have “22” in the
    number, somebody might somehow change it to “88”.
  prefs: []
  type: TYPE_NORMAL
- en: When two numbers are side by side, one is multiplied by 3 and the other by 1\.
    So the amount contributed to the total is the sum of the number’s row in the above
    table. For example, 2 has the row “2->6”. This means that 2+6=8 will be contributed
    to the sum as a result of these two digits.
  prefs: []
  type: TYPE_NORMAL
- en: If any rows add up to the same number, this could be a problem. Where the sum
    was over 10, the tens column has been removed.
  prefs: []
  type: TYPE_NORMAL
- en: 1 -> 3 adds to “4”
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 -> 6 adds to “8”
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 3 -> 9 adds to “2”
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 -> 2 adds to “6”
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 5 -> 5 adds to “0”
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 6 -> 8 adds to “4”
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 7 -> 1 adds to “8”
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 -> 4 adds to “2”
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 9 -> 7 adds to “6”
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 -> 0 adds to “0”
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the rows add up to the same number! Because both 4 and 9 add up to 6,
    the error will not be detected if “44” changes to “99” in a number!
  prefs: []
  type: TYPE_NORMAL
- en: Rows that do not add will be detected. From the example above, if 22 changes
    to 88, this will be detected because 22’s total is 8, and 88’s total is 2.
  prefs: []
  type: TYPE_NORMAL
- en: '*An error which is never detected*'
  prefs: []
  type: TYPE_NORMAL
- en: Another error that people sometimes make is the jump transposition error. This
    is where two digits that have one digit in between them are swapped, for example,
    812 to 218.
  prefs: []
  type: TYPE_NORMAL
- en: A pair of numbers that are two apart like this will always be multiplied by
    the same amount as each other, either 1 or 3\. This means that the change in position
    of the numbers does not affect what they are multiplied by, and therefore what
    they contribute to the sum. So this kind of error will never be detected.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.4\. CHECK DIGITS ON CREDIT CARD NUMBERS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Credit card numbers also have check digits. These can be used by online purchasing
    systems to ensure that the credit card number entered was entered correctly way
    before having to check with the bank to see if the number is legitimate. This
    isn’t a good protection against fraud, but it does check that a legitimate user
    hasn’t made a simple mistake that makes it look like they are trying to commit
    a fraud, or that a completely random number has been typed in. A credit card number
    has 16 digits in it: 15 digits that make up the number, and then the last digit
    is a check digit.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we go any further investigating credit card numbers, there are a few
    ethical and privacy issues we must consider. While credit card numbers are not
    secret, just like your home address you would not give your credit card number
    to just anybody. There are fraudsters around who collect credit card numbers and
    attempt to use other peoples credit cards. (One of the main reasons Paypal exists
    is that it hides the credit card number from the seller, and only Paypal needs
    to be trusted with this sensitive information, rather than every person you make
    a payment to on the internet.)
  prefs: []
  type: TYPE_NORMAL
- en: It is not really a good idea to include experiments in an assessed report that
    contain your credit card number or your parents’ credit card number. You also
    need to be careful about making credit card numbers up, as the number you make
    up could potentially be somebody’s valid credit card number. There is a range
    of credit card numbers that are only used as test numbers, which start with 5413
    30\. If you are giving examples using credit cards, we recommend that you use
    numbers in this range in your report. You can use the following generator to generate
    test credit card numbers in this range.
  prefs: []
  type: TYPE_NORMAL
- en: JACK PUT THE CREDIT CARD NUMBER GENERATOR HERE
  prefs: []
  type: TYPE_NORMAL
- en: The interactive below allows you to experiment with numbers from the above generator,
    and see what kinds of errors are detected and which are not (use the information
    from the previous sections to guide your experimentation). Note that it only accepts
    numbers from the above generator, as we don’t want you checking real credit card
    numbers with this interactive!
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.5\. THE ALGORITHM FOR CALCULATING CREDIT CARD NUMBER CHECK DIGITS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 9.4\. THE WHOLE STORY!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The codes discussed in this chapter are all widely used, but the most widely
    used codes for data storage are more sophisticated because they need to deal with
    more complex errors than a single bit changing. For example, if a CD is scratched
    of a hard disk has a small fault, it’s likely to affect many adjacent bits. These
    systems use codes based on more advanced mathematical concepts. The most widely
    used codes for storage and data transfer are [the Reed-Solomon codes](http://en.wikipedia.org/wiki/Reed_Solomon) and [Cyclic
    Redundancy Check (CRC)](http://en.wikipedia.org/wiki/CRC32). For human readable
    numbers such as bar codes, bank numbers, tax numbers, social security numbers
    and so on, [checksums](http://en.wikipedia.org/wiki/Checksum) are very common,
    and the [Luhn algorithm](http://en.wikipedia.org/wiki/Luhn_algorithm) is one of
    the more widely used. Larger checksums are also used to check that downloaded
    files are correct. The parity method is a form of [Hamming code](http://en.wikipedia.org/wiki/Hamming_code).
  prefs: []
  type: TYPE_NORMAL
- en: 9.5\. FURTHER READING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 9.5.1\. USEFUL LINKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[CS Unplugged Parity Trick](http://csunplugged.org/error-detection)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CS4FN](http://csfieldguide.org.nz/cs4fn.org) has a [free book](http://www.cs4fn.org/magic/) that
    contains the Parity Trick and a number of other tricks related to computer science.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techradar has more [information about error detection and correction](http://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[An explanation of error correcting codes](http://www.multiwingspan.co.uk/as1.php?page=error)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A check digit calculator for common bar codes](http://www.gs1.org/barcodes/support/check_digit_calculator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10\. ARTIFICIAL INTELLIGENCE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 10.1\. WHAT’S THE BIG PICTURE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Artificial Intelligence conjures up all sorts of images — perhaps you think
    of friendly systems that can talk to you and solve tough problems; or maniac robots
    that are bent on world domination? There’s the promise of driverless cars that
    are safer than human drivers, and the worry of medical advice systems that hold
    peoples lives in their virtual hands. The field of Artificial Intelligence is
    a part of computer science that has a lot of promise and also raises a lot of
    concerns. It can be used to make decisions in systems as large as an aeroplane
    or an [autonomous dump truck](http://www.komatsu.com/ce/currenttopics/v09212/index.html) ,
    or as small as a mobile phone that accurately predicts text being typed into it.
    What they have in common is that they try to mimic aspects of human intelligence.
    And importantly, such systems can be of significant help in people’s everyday
    lives.
  prefs: []
  type: TYPE_NORMAL
- en: AI (also known as intelligent systems) is primarily a branch of computer science
    but it has borrowed a lot of concepts and ideas from other fields, especially[mathematics](http://en.wikipedia.org/wiki/Mathematics) (particularly
    logic, combinatorics, statistics, probability and optimisation theory), [biology](http://en.wikipedia.org/wiki/Biology) , [psychology](http://en.wikipedia.org/wiki/Psychology) , [linguistics](http://en.wikipedia.org/wiki/Linguistics) , [neuroscience](http://en.wikipedia.org/wiki/Neuroscience) and [philosophy](http://en.wikipedia.org/wiki/Philosophy).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll explore a range of these intelligent systems. Inevitably
    this will mean dealing with ethical and philosophical issues too — do we really
    want machines to take over some of our jobs? Can we trust them? Might it all go
    too far one day? What do we really mean by a computer being intelligent? While
    we won’t address these questions directly in this chapter, gaining some technical
    knowledge about AI will enable you to make more informed decisions about the deeper
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2\. CHATTERBOTS AND THE TURING TEST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](563ad8f58e4e0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Many humans take for granted the fact that they can easily have a conversation
    with another person, and choose appropriate things to say based on the conversation.
    The ability to do this is a form of intelligence, and for computers it isn’t so
    easy! Many attempts have been made to design computer programs that can have a
    conversation with a human and sound intelligent. These computer programs are called *chatterbots*,
    or just *chatbots*. This book uses the former term, although you may see both
    being used in other books or websites.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.1\. A THERAPY SESSION WITH ELIZA THE CHATTERBOT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One such chatterbot is **Eliza**. Eliza attempts to sound like a Rogerian Psychotherapist,
    and sounds most intelligent in the kind of conversation that would be had in such
    a therapy session. ([Rogerian Psychotherapy](http://en.wikipedia.org/w/index.php?title=Rogerian_psychotherapy) is
    a technique that revolves around trying to understand the client by asking questions
    and reflecting their statements back to clarify that they’ve been understood).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Eliza is a system that was intended to get people thinking about AI, and you
    should *not* use it for your own therapeutic usage. You should never enter personal
    information into a computer that you wouldn’t want anybody else reading, as you
    can never be certain that the web site isn’t going to store the information or
    pass it on to someone. So you don’t want to be telling Eliza the kinds of things
    a person would say in a therapy session — just make stuff up when talking to Eliza!
    For the same reason, do *not* tell any chatterbot other personal information such
    as your full name, date of birth, or address.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the link just below and have a conversation with Eliza (keeping in mind
    that she is supposed to be a Rogerian Psychotherapist, so will respond like one).
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here for the Eliza chatterbot at nlp-addiction](http://nlp-addiction.com/eliza/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad8f4d5b30.png)'
  prefs: []
  type: TYPE_IMG
- en: Do you think Eliza is as smart as a human? Would you believe she was a human
    if somebody told you she was?
  prefs: []
  type: TYPE_NORMAL
- en: 'You will probably agree that while Eliza sounds somewhat intelligent at times,
    she gives very vague and general replies, forgets earlier parts of the conversation,
    and says some things that sound very strange! As an example, here is a conversation
    with Eliza:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eliza**: Hello, I am Eliza. **Human**: Hello I am a human **Eliza**: Do you
    believe it is normal to be a human? **Human**: Yes **Eliza**: Are you Sure? **Human**:
    Yes **Eliza**: Why did you repeat yourself?'
  prefs: []
  type: TYPE_NORMAL
- en: Eliza often gives very general replies by looking for suitable rules based only
    on the line you’ve just typed, and that often leads to some very weird conversations,
    such as the one above! In this case Eliza used pattern matching to determine that
    it might be appropriate to ask me “Do you believe it is normal to be a human?”,
    as I had said I was a human; if I had said “I am a banana” then the same rule
    would have responded with “Do you believe it is normal to be a banana?”. When
    I answered “Yes”, Eliza didn’t actually understand the *meaning* of me saying
    “Yes”, so simply asked me if I was sure, as it has a general response that says
    a good way of responding to somebody saying “Yes” is to ask them if they were
    sure. Eliza also has rules that are triggered if somebody repeats themselves that
    say she should ask them why. Because Eliza doesn’t actually understand meanings
    but instead just follows rules that say what might be appropriate responses, she
    had no way of knowing that it actually *was* meaningful for me to respond with
    “Yes” twice! This is a big giveaway that Eliza really isn’t that intelligent,
    and doesn’t actually understand meanings in conversation, or even whether or not
    a response to her own question is actually reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: Now go back and have another conversation with Eliza. There are many other examples
    of Eliza saying stuff that makes no sense such as the above dialogue. How many
    can you find? In addition, how does Eliza respond when you do the following things?
  prefs: []
  type: TYPE_NORMAL
- en: Try being a “parrot” that just copies everything Eliza says.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when you don’t give meaningful answers to her questions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you say the same thing you said earlier in the conversation, does Eliza always
    respond in the same way? (When you say it immediately after, she probably won’t,
    as she’ll comment on the fact that you repeated yourself the second time!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when you talk about things that are unrelated to what would be
    said in a therapy session, i.e. you try to have a general conversation with Eliza
    (remember that Eliza works in a restricted domain, i.e. she assumes she is a therapist).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.2.2\. ALICE THE CHATTERBOT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We saw above that Eliza is a chatterbot who works with a restricted domain (trying
    to take the role of a therapist), and tried to sound intelligent by giving very
    general responses. As you probably found out though, this quickly reveals that
    Eliza really isn’t intelligent at all, and will just repeat the same things over
    and over again. In addition, you probably also noticed that Eliza frequently doesn’t
    make a lot of sense, and comes up with sentences that make no sense to a human.
  prefs: []
  type: TYPE_NORMAL
- en: Try having a conversation with another chatterbot — Alice. Note that she knows
    you as “judge”. You might work out why she calls you this once you have read the
    sections on the Turing Test below!
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here for the Alice chatterbot at pandorabots.com](http://www.pandorabots.com/pandora/talk?botid=f5d922d97e345aa1)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ad8f4665e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Does Alice sound more intelligent than Eliza? Does she sound as intelligent
    as a human, or can you trick her into saying things that make no sense? Try using
    the same tricks you used to fool Eliza and see if they fool Alice as well. (Look
    back at the list of bullet points in the Eliza section just above).
  prefs: []
  type: TYPE_NORMAL
- en: Like Eliza, Alice also uses hard coded rules to know what to say, although she
    has a lot more of these rules and a more sophisticated algorithm for choosing
    which rules should be used to determine what to say. If you want to know more,
    just ask Alice how she works, and she’ll tell you!
  prefs: []
  type: TYPE_NORMAL
- en: Some possible rules that Alice might have are,
  prefs: []
  type: TYPE_NORMAL
- en: If “favourite colours” are mentioned, say your favourite colour is “green”,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if family members are mentioned (e.g. “mum”, “dad”, or “brother”) say something
    that is about family.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use the rules, the chatterbot analyses your last sentence (and possibly earlier
    sentences also) by matching the sentence against the patterns in its rules. If
    the sentence matches the rule pattern, it “activates” the rule. The rule will
    specify a reply. Sometimes the reply is just a template for a sentence, and the
    chatterbot analyses the text you typed to extract words that can be inserted into
    the template. That’s why the replies sometimes use part of what you typed.
  prefs: []
  type: TYPE_NORMAL
- en: The quality of these rules determines how intelligent the chatterbot will sound.
  prefs: []
  type: TYPE_NORMAL
- en: While Alice is undoubtedly more intelligent than Eliza, Alice still has her
    limitations. Sometimes she even admits to those limitations!
  prefs: []
  type: TYPE_NORMAL
- en: '**Judge**: What will happen in the year 2000 **ALICE**: I cannot predict the
    future. **Judge**: That is the past **ALICE**: Yes it is one of the past. **Judge**:
    Then why did you say you can’t predict the future? **ALICE**: It was a preprogrammed
    response completely determined by your statements.'
  prefs: []
  type: TYPE_NORMAL
- en: I suppose I was a bit mean for tricking her and saying “what will”. Her rules
    assume a human wouldn’t mislead her like that.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.3\. CHATTERBOTS THAT LEARN FROM HUMANS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We saw in the previous sections examples of two chatterbots that have rules
    that help them determine suitable things to say. One of those chatterbots only
    works in a restricted domain, taking the role of a therapist, and is unable to
    have very general conversations, and the other is able to have more general conversations.
    Both these chatterbots had their *rules* of what to say determined by programmers *at
    the time of programming*, and these rules will never be changed unless a programmer
    decides to change them.
  prefs: []
  type: TYPE_NORMAL
- en: There are other chatterbots that are able to *learn* their rules from the humans
    they have conversations with. By looking at how a human responds to various dialogues,
    the chatterbot attempts to learn how it should respond in various situations.
    The idea is that if it responds in similar ways to what a human does, then perhaps
    it will sound like a human. Most of these chatterbots aim to have very general
    conversations, i.e. they aren’t restrained to one domain such as Eliza the therapist
    is.
  prefs: []
  type: TYPE_NORMAL
- en: If it is human intelligence you are trying to simulate, then perhaps learning
    from humans is the way to go?
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the following exercise involves interacting with one of these
    chatterbots. Because the chatterbot has learnt from humans, it will quite possibly
    have been taught to say things that you may find highly offensive. While we have
    tried to choose chatterbots that mostly say things that aren’t going to offend,
    it is impossible to guarantee this, so use your discretion with them; you can
    skip this section and still cover the main concepts of this chapter. Because Eliza
    and Alice don’t learn from humans, they won’t say offensive things unless you
    do first!
  prefs: []
  type: TYPE_NORMAL
- en: And again, don’t tell the chatterbots your personal details (such as your full
    name, date of birth, address, or any other information you wouldn’t be happy sharing
    with everybody). Make stuff up where necessary. A chatterbot that learns from
    people quite possibly *will* pass on what you say to other people in an attempt
    to sound intelligent to *them*!
  prefs: []
  type: TYPE_NORMAL
- en: These warnings will make more sense once you’ve learnt how these chatterbots
    work.
  prefs: []
  type: TYPE_NORMAL
- en: An example of a chatterbot that learns from humans is Cleverbot.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click on this link to have a conversation with Cleverbot](http://www.cleverbot.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad8f3c0670.png)](http://www.cleverbot.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Eliza and Alice, whose rules of what to say were determined by programmers,
    Cleverbot learns rules based on what people say. For example, when Cleverbot says
    “hi” to a person, it keeps track of all the different responses that people make
    to that, such as “hi”, “hello!”, “hey ya”, “sup!”. A rule is made that says that
    if somebody says hi to you, then the things that people have commonly said in
    response to Cleverbot saying hi are appropriate things to say in response to “hi”.
    In turn, when Cleverbot says something like “sup!” or “hello!”, it will look at
    how humans respond to that in order to learn appropriate response for those. And
    then it will learn responses for those responses. This allows Cleverbot to built
    up an increasingly large database.
  prefs: []
  type: TYPE_NORMAL
- en: An implication of learning from humans is that Cleverbot makes the assumption
    that the humans actually *are* intelligent, and will teach it to say intelligent
    things. If for example people told Cleverbot something like “School is boring”
    in response to Cleverbot saying “hi”, Cleverbot might learn that when a person
    says “hi” to it, it should say “School is boring”!
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity: A short film written by Cleverbot**'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the short film [“Do You Love Me”](http://www.youtube.com/watch?v=QkNA7sy5M5s) (~3
    mins), that Chris R Wilson collaborated with Cleverbot to write a movie script.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.4\. EVEN MORE CHATTERBOTS!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are even more chatterbots you can talk to. Try looking at the [list on
    wikipedia](http://en.wikipedia.org/wiki/List_of_chatterbots), or doing a google
    search for chatterbots. Each chatterbot on this list has its own wikipedia page.
    You should be able to find the chatterbots by either an internet search, or looking
    at the references of the wikipedia pages. Some of these will have rules that were
    determined by programmers, and others will have rules that were learnt from humans.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a device that runs Apple iOS (for example an iPhone), have a look
    at the [Siri](http://en.wikipedia.org/wiki/Siri_%28software%29) chatterbot in
    the device’s help system. Siri is an example of a chatterbot that has the job
    of *helping* a human, unlike most chatterbots which simply have the purpose of
    web entertainment. It also has voice recognition, so you can talk to it rather
    than just typing to it.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2.5\. THE TURING TEST
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the above sections you met some chatterbots, and (hopefully!) have drawn
    the conclusion that they aren’t entirely convincing in terms of sounding like
    a human (although some are better than others!). But maybe soon, there will be
    new chatterbots that don’t have the same limitations. Should we consider them
    to be intelligent? How could we tell? Is there a formal way we can determine whether
    or not a chatterbot is of the level of human intelligence?
  prefs: []
  type: TYPE_NORMAL
- en: A very famous computer scientist, Alan Turing, answered this question back in
    1950, before the first chatterbots even existed! Alan Turing had an extraordinary
    vision of the future, and knew that coming up with computers that were intelligent
    would become a big thing, and that we would need a way to know when we have succeeded
    in creating a truly intelligent computer.
  prefs: []
  type: TYPE_NORMAL
- en: He thought about how intelligence could be defined (defining intelligence is
    surprisingly difficult!), and decided that one way would be to say that a human
    was intelligent, and that if a computer was able to communicate convincingly like
    a human, then it must be intelligent also. This definition doesn’t cover all of
    intelligence, as it only considers what a person or a computer says and ignores
    other components of intelligence such as determining the best way to walk through
    a building (or maze) or deciding how to act in a specific situation (such as at
    a social event, when deciding what to do next at work, or when lost). However,
    communication is still a very significant component of human intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: In order to test whether or not a computer program can communicate like a human,
    Turing proposed a test. In addition to the computer program, two humans are required
    to carry out the test. One of the humans act as an interrogator, and the other
    as a “human” to compare the computer program to. The interrogator is put in a
    separate room from the computer running the computer program and the “human”.
    The interrogator has conversations with both the human and the computer program,
    but isn’t told which one they are having the conversation with at each time. The
    conversations are both carried out over something like an instant messaging program
    so that actual speech isn’t required from the computer program. During the conversations,
    the human has to convince the interrogator that they are indeed the human, and
    the computer program has to convince the interrogator that IT is actually the
    human. At the end of the conversations, the interrogator has to say which was
    the computer and which was the human. If they can’t reliably tell, then the computer
    is said to have passed the test.
  prefs: []
  type: TYPE_NORMAL
- en: This test proposed by Turing eventually became very famous and got the name
    “The Turing Test”. One of the motivations for writing chatterbots is to try and
    make one that passes the Turing Test. Unfortunately, making a chatterbot that
    successfully passes the Turing Test hasn’t yet been achieved, and whether or not
    it is even possible is still an open question in computer science, along with
    many other questions in artificial intelligence that you will encounter later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Other forms of the Turing Test exist as well. Action games sometimes have computer
    controlled characters that fight your own character, in place of a second human
    controlled character. A variation of the Turing Test can be used to determine
    whether or not the computer controlled player seems to have human intelligence
    by getting an interrogator to play against both the computer character and the
    human character, and to see whether or not they can tell them apart.
  prefs: []
  type: TYPE_NORMAL
- en: Infact, many parts of human intelligence could be tested using a variation of
    the Turing Test. If you wanted a computer chess player that seemed like a human
    as opposed to a computer (as some people might prefer to be playing against a
    human rather than a computer), you could use a Turing Test for this as well! What
    other possible Turing Tests can you think of?
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will actually carry out the Turing Test on a chatterbot.
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity: The real Turing test**'
  prefs: []
  type: TYPE_NORMAL
- en: Alan Turing actually started by suggesting a simple party game requiring three
    players, where the first player was female, the second player was male, and the
    third player could be either male or female, and took the role of the “interrogator”.
    The interrogator would be in a separate room to the other two players, and could
    only communicate with them by passing written notes (for example, by passing the
    notes under a door). The male had to try and convince the interrogator that he
    was actually female, and the female had to try and convince the interrogator that
    she *was* the female. At the end the interrogator had to say which was the male
    and which was the female, and if the interrogator guessed incorrectly, then the
    male “won”.
  prefs: []
  type: TYPE_NORMAL
- en: '10.2.6\. ACTIVITY: RUN YOUR OWN TURING TEST'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section will involve you actually carrying out the Turing Test. Read this
    entire section carefully (and the previous section if you haven’t done so already)
    before you start, and make sure you understand it all before starting.
  prefs: []
  type: TYPE_NORMAL
- en: In science classes, such as biology, physics, and chemistry, carrying out experiments
    is commonly done. If you have taken classes like these, you will probably know
    that if an experiment isn’t carried out properly (e.g. in chemistry some students
    are tempted to put in more of a chemical than the instructions say to, or when
    timing is important this is easy to get wrong), then the results will not necessarily
    be the ones you are after and your experiment is essentially meaningless and pointless.
    You also have to be careful that other factors don’t affect the results. e.g.
    controlling temperature and moisture in biology experiments that involve growing
    micro-organisms.
  prefs: []
  type: TYPE_NORMAL
- en: Carrying out the Turing Test is carrying out an experiment, just like carrying
    out experiments in chemistry classes. And just like the chemistry experiments,
    carrying out the Turing Test requires being careful to follow instructions correctly,
    and controlling factors that could potentially affect the results but aren’t part
    of what is being tested. You should keep this in mind while you are carrying out
    this project.
  prefs: []
  type: TYPE_NORMAL
- en: For example, most chatterbots communicate in a text form rather than verbal.
    Communicating in a verbal form involves not only choosing intelligent sounding
    things to say, but also involves having a convincing voice and pronouncing words
    correctly. Tone of voice or accent could potentially make it very obvious to the
    interrogator which conversation was with the human and which was the computer,
    without them even having to consider what was actually said in the conversation.
    This is not what the Turing Test is supposed to be testing! Therefore, the Turing
    Test will have both the computer and the human communicating in a written form.
  prefs: []
  type: TYPE_NORMAL
- en: As another example, speed of response could have an impact. The computer is
    likely to be able to reply instantly, whereas the human will need time to think
    and then write their reply. To prevent the interrogator from making their decision
    based on the speed instead of the content, the speed of response needs to be controlled
    as well. The way of carrying out the Turing Test described below tries to control
    these additional factors.
  prefs: []
  type: TYPE_NORMAL
- en: Choose a chatterbot from the list on Wikipedia (see the above chatterbots section),
    or possibly use Alice or Cleverbot (Eliza isn’t recommended for this). You will
    be taking the role of the interrogator, but will need another person to act as
    the “human”. For this it is recommended you choose a person in your class who
    you don’t know very well. Do *not* choose your best friend in the class, because
    you will know their responses to questions too well, so will be able to identify
    them from the chatterbot based on their personality rather than the quality of
    the chatterbot.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the chatterbot and your classmate to act as the human, you will
    need access to a room with a computer with internet (this could just be the computer
    classroom), another room outside it (a hallway would be fine), pieces of paper,
    2 pens, and a coin or a dice.
  prefs: []
  type: TYPE_NORMAL
- en: The chatterbot should be loaded on the computer to be used, and your classmate
    should be in the same room with the computer. You should be outside that room.
    As the interrogator, you will first have a conversation with either your classmate
    or the computer, and then a conversation with the other one. You should not know
    which order you will speak to them; to determine which you speak to first your
    classmate should use the dice or the coin to randomly decide (and shouldn’t tell
    you).
  prefs: []
  type: TYPE_NORMAL
- en: In order to carry out the conversations, start by writing something at the top
    of the piece of paper such as “hello” or “hi” or “how are you?”. Put a mark next
    to the line to make it clear that line was written by YOU. Pass the piece of paper
    into the room where your classmate and the computer are (if you can, slide it
    under the door) where your classmate will write a reply on it and pass it back
    to you. You should then write a reply to that and repeat the process. Each conversation
    should be on a separate piece of paper, and be around 20 to 40 lines long (this
    means that each person/ computer should say around 10 - 20 lines in each conversation).
    Put a mark next to each of the lines you write, so that it is clear who wrote
    which lines.
  prefs: []
  type: TYPE_NORMAL
- en: If your classmate is currently supposed to be having the conversation (rather
    than the chatterbot), they will write the reply based on what they would say.
  prefs: []
  type: TYPE_NORMAL
- en: If the chatterbot is currently supposed to be having the conversation, your
    classmate should type what you said into the chatterbot and then write its reply
    on the piece of paper. Before submitting the line to the chatterbot, they should
    double check it was entered correctly.
  prefs: []
  type: TYPE_NORMAL
- en: A problem is that it will take longer for the conversation between you and the
    chatterbot than between you and the classmate, because of the need for your classmate
    to type what you say to the chatterbot. You wouldn’t want to make it obvious which
    was the computer and which was the human due to that factor! To deal with this,
    you could intentionally delay for a while before each reply to that they all take
    exactly one minute.
  prefs: []
  type: TYPE_NORMAL
- en: You can ask whatever you like, although keep in mind that you should be assuming
    you don’t know your classmate already, so don’t refer to common knowledge about
    previous things that happened such as in class or in the weekend in what you ask
    your classmate or the chatterbot. This would be unfair to the chatterbot since
    it can’t possibly know about those things. Remember you’re evaluating the chatterbot
    on its ability to display human intelligence, not on what it doesn’t know about.
  prefs: []
  type: TYPE_NORMAL
- en: Good conversation topics would be favourite colours, games, foods, the weather,
    and the kinds of conversation topics you’d have with a person you don’t know but
    are having a friendly conversation with at work, the supermarket, or a party.
    Coming up with good things to ask is challenging but just ask yourself whether
    something would require knowledge of an event that not everybody could be expected
    to have.
  prefs: []
  type: TYPE_NORMAL
- en: Once both conversations are complete, you as the interrogator has to say which
    was your classmate, and which was the chatterbot. Your classmate should tell you
    whether or not you were correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some questions you can consider after you have finished carrying
    out the Turing Test:'
  prefs: []
  type: TYPE_NORMAL
- en: How were you able to tell which was the chatterbot and which was your classmate?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Were there any questions you asked that were “unfair” — that depended on knowledge
    your classmate might have but no-one (computer or person) from another place could
    possibly have?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Which gave it away more: the content of the answers, or the way in which the
    content was expressed?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](563ad8f32f57b.png)'
  prefs: []
  type: TYPE_IMG
- en: '10.2.7\. PROJECT: INVESTIGATING CHATTERBOTS AND THE TURING TEST'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this project, you will write a report about your investigations of Chatterbots
    and the Turing Test.
  prefs: []
  type: TYPE_NORMAL
- en: The report consists of 2 parts. The first involves demonstrating that you understand
    the Turing Test by carrying out your own Turing Test and then answering some questions
    about the Turing Test. The second part involves having conversations with several
    chatterbots and investigating some common techniques they used in order to sound
    as though they have human intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t already, carry out the Turing Test in the project in the above
    section. Once you have carried out the Turing Test and have your two conversations,
    answer the following questions in your report, to show you understand the Turing
    Test. *Make sure you include the two conversations in your report!*
  prefs: []
  type: TYPE_NORMAL
- en: Explain what the Turing Test is for, using your experience with chatterbots
    as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Describe what you did to run a Turing Test, including a copy of the two conversations.
  prefs: []
  type: TYPE_NORMAL
- en: When you were carrying out the Turing Test, you had to be careful to avoid external
    factors that gave away which was the computer and which was the human. Explain
    some of these factors and why it is important to avoid them. (Some of them were
    mentioned in the text above!)
  prefs: []
  type: TYPE_NORMAL
- en: Explain how the Turing Test could be used to evaluate a new chatbot. Discuss
    other possible applications of the Turing Test or similar tests for other programs
    that are supposed to be intelligent.
  prefs: []
  type: TYPE_NORMAL
- en: Discuss whether or not the Turing test is a good test of intelligence, giving
    reasons for your answer and using examples from your chatterbot experiments. What
    parts of *human* intelligence would the Turing test not capture?
  prefs: []
  type: TYPE_NORMAL
- en: Before completing this second part of your report, you should ensure you have
    talked to at least three chatterbots (either the ones talked about in this book
    or other ones you find).
  prefs: []
  type: TYPE_NORMAL
- en: What is it that chatterbots are trying to accomplish?
  prefs: []
  type: TYPE_NORMAL
- en: Describe the chatterbots that you have investigated. Show a brief conversation
    with each of them to illustrate what they do (no more than 10 lines for each conversation).
  prefs: []
  type: TYPE_NORMAL
- en: Choose at least two techniques used by chatterbots in an attempt to sound like
    they have human intelligence. The techniques you choose could be the identification
    of key words, canned responses, learning from humans, giving very general replies,
    or anything else you notice about how a chatterbot tends to speak or react that
    is an attempt to make it sound human (including techniques that make sense in
    some cases that the chatterbot uses them, but not in others!)
  prefs: []
  type: TYPE_NORMAL
- en: For each of the techniques you choose, do the following.
  prefs: []
  type: TYPE_NORMAL
- en: Explain how the technique works, using specific examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give examples of specific chatterbots that use this technique, and examples
    of conversations with these chatterbots where it is obvious that they are using
    these techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain your examples in terms of the technique(s) they are illustrating.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss how well the techniques work and when they break.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which techniques seemed to be the most effective, if any? How could you tell
    that these chatterbots weren’t actually human? What were the main limitations
    of the chatterbots? Which chatterbot out of the ones you talked to do you think
    was the most intelligent? Which was the least intelligent? Why?
  prefs: []
  type: TYPE_NORMAL
- en: Most of the chatterbots you have looked at here exist solely for the purpose
    of web entertainment, or as attempts to pass the Turing Test. These however aren’t
    the only applications of chatterbots. Discuss how chatterbots be useful in other
    applications, for example, help systems and games? Can you think of any other
    possible applications for chatterbots?
  prefs: []
  type: TYPE_NORMAL
- en: 10.3\. THE WHOLE STORY!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter so far, we have only talked about one application of AI. AI
    contains many more exciting applications, such as computers that are able to play
    board games against humans, computers that are able to learn, and computers that
    are able to control robots that are autonomously exploring an environment too
    dangerous for humans to enter.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually further sections on other topics in AI will be added to this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4\. FURTHER READING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Artificial Intelligence Strong and Weak - I Programmer](http://www.i-programmer.info/babbages-bag/297-artificial-intelligence.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Paradox of Artificial Intelligence - I Programmer](http://www.i-programmer.info/programming/artificial-intelligence/2437-the-paradox-of-artificial-intelligence.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.4.1\. USEFUL LINKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[CS Unplugged - Programming Languages - Harold the Robot](http://csunplugged.org/programming-languages-0) -
    related to why AI is so tricky'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CS Unplugged - Artificial Intelligence - The Intelligent Piece of Paper](http://csunplugged.org/intelligent-paper)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CS Unplugged - The Turing Test - Conversations with Computers](http://csunplugged.org/turing-test)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia- Outline of Artificial Intelligence](http://en.wikipedia.org/wiki/Outline_of_artificial_intelligence)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Turing Test](http://en.wikipedia.org/wiki/Turing_test)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Machine Learning](http://en.wikipedia.org/wiki/Machine_learning)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CS 4 FUN - Meet the Chatterbots](http://www.cs4fn.org/ai/meetthechatterbots.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CS 4 FUN - The Illusion of Intelligence](http://www.cs4fn.org/ai/illusionintelligence.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Alice Bot](http://www.alicebot.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[IEEE Spectrum](http://spectrum.ieee.org/robotics/artificial-intelligence)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[TED Conversations matching Artificial Intelligence](http://www.ted.com/conversations/topics/artificial+intelligence)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11\. COMPLEXITY AND TRACTABILITY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 11.1\. WHAT’S THE BIG PICTURE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Are there problems that are too hard even for computers? Yes. In the chapter
    on Artificial Intelligence we’ll see that just having a conversation — chatting
    — is something computers can’t do well, not because they can’t speak but rather
    because they can’t understand or think of sensible things to say. However, that’s
    not the kind of hard problem we’re talking about here — it’s not that computers
    couldn’t have conversations, more that we don’t know just how we do it ourselves
    and so we can’t tell the computer what to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we’re going to look at problems where it’s easy to tell the
    computer what to do — by writing a program — but the computer *can’t* do what
    we want because it takes far too long: millions of centuries, perhaps. Not much
    good buying a faster computer: if it were a hundred times faster it would still
    take millions of years; even one a million times faster would take hundreds of
    years. That’s what you call a *hard* problem—one where it takes far longer than
    the lifetime of the fastest computer imaginable to come up with a solution! The
    area of *tractability* explores problems and algorithms that can take an impossible
    amount of computation to solve except perhaps for very small examples of the problem.
    We’ll define what we mean by *tractable* later on, but put very crudely, a tractable
    problem is one which we can write programs for that finish in a reasonable amount
    of time, and an intractable problem is one that will generally end up taking way
    too long.'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing when a problem you are trying to solve is one of these hard problems
    is very important. Otherwise it is easy to waste huge amounts of time trying to
    invent a clever program to solve it, and never getting anywhere. A computer scientist
    needs to be able to recognise a problem as an intractable problem, so that they
    can use other approaches. A very common approach is to give up on getting a perfect
    answer, and instead just aim for an approximately correct answer. There are a
    variety of techniques for getting good approximate answers to hard problems; a
    way of getting an answer that isn’t guaranteed to give the exact correct answer
    is sometimes referred to as a *heuristic*.
  prefs: []
  type: TYPE_NORMAL
- en: One important example of an intractable problem that this chapter looks at is
    the travelling salesman problem (TSP for short). It’s a simple problem; if you’ve
    got a collection of places that you need to visit, and you know the distance to
    travel between each pair of places, what’s the shortest route that visits all
    of the places exactly once? This is a very practical problem that comes up with
    courier vehicles choosing routes to deliver parcels, rock bands planning tours,
    and even a designated driver dropping friends off after an event. In fact, the
    measurement between cities doesn’t have to be distance. It could actually be the
    dollar cost to travel between each pair of cities. For example, if you needed
    to visit Queenstown, Christchurch, Auckland, and Wellington one after the other
    while minimising airfares and you knew the cost of an airfare between each pair
    of those 4 cities, you could work out what the cheapest way of flying to each
    of them is. This is still an example of TSP.
  prefs: []
  type: TYPE_NORMAL
- en: The following interactive has a program that solves the problem for however
    many cities you want to select by trying out all possible routes, and recording
    the best so far. You can get a feel for what an intractable problem looks like
    by seeing how long the interactive takes to solve the problem for different size
    maps. Try generating a map with about 5 cities, and press “Start” to solve the
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Now try it for 10 cities (twice as many). Does it take twice as long? How about
    twice as many again (20 cities)? What about 50 cities? Can you guess how long
    it would take? You’re starting to get a feel for what it means for a problem to
    be *intractable*.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, for some situations, intractable problems are a good thing. In particular,
    most security and cryptography algorithms are based on intractable problems; the
    codes could be broken, but it would take billions of years and so would be futile.
    In fact, if anyone ever finds a fast algorithm for solving such problems, a lot
    of computer security systems would stop being secure overnight! So one of the
    jobs of computer scientists is to be confident that such solutions *don’t* exist!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will look at the TSP and other problems for which *no* tractable
    solutions are known, problems that would take computers millions of centuries
    to solve. And we will encounter what is surely the greatest mystery in computer
    science today: that *no-one knows* whether there’s a more efficient way of solving
    these problems! It may be just that no-one has come up with a good way yet, or
    it may be that there is no good way. We don’t know which.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad96f09743.png)](http://xkcd.com/287/)'
  prefs: []
  type: TYPE_NORMAL
- en: But let’s start with a familiar problem that we can actually solve.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2\. ALGORITHMS, PROBLEMS, AND SPEED LIMITS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*Complexity*](http://csfieldguide.org.nz/appendices/Glossary.html#term-complexity) is
    an important concept with problems and algorithms that solve them. Usually complexity
    is just the amount of time it takes to solve a problem, but there are several
    ways that we can measure the “time”. Using the actual time on a particular computer
    can be useful, but to get a rough idea of the inherent behaviour of an algorithm,
    computer scientists often start by estimating the number of steps the algorithm
    will take for *n* items. For example, a linear search can end up checking each
    of *n* items being searched, so the algorithm will take *n* steps. An algorithm
    that compares every pair of values in a list of *n* items will have to make n2comparisons,
    so we can characterise it as taking about n2 steps. This gives us a lot of information
    about how good an algorithm is without going into details of which computer it
    was running on, which language, and how well written the program was. The term *complexity* is
    generally used to refer to these rough measures.'
  prefs: []
  type: TYPE_NORMAL
- en: Having a rough idea of the complexity of a problem helps you to estimate how
    long it’s likely to take. For example, if you write a program and run it with
    a simple input, but it doesn’t finish after 10 minutes, should you quit, or is
    it about to finish? It’s better if you can estimate the number of steps it needs
    to make, and then extrapolate from the time it takes other programs to find related
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster: Asymptotic complexity**'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re reading about complexity, you may come across some terminology like
    “Big Oh” notation and “asymptotic complexity”, where an algorithm that takes about
    n2 steps is referred to as O(n2). We won’t get into these in this chapter, but
    here’s a little information in case you come across the terms in other reading.
    “Big Oh” notation is a precise way to talk about complexity, and is used with
    “asymptotic complexity”, which simply means how an algorithm performs for large
    values of *n*. The “asymptotic” part means as *n* gets really large — when this
    happens, you are less worried about small details of the running time. If an algorithm
    is going to take seven days to complete, it’s not that interesting to find out
    that it’s actually 7 days, 1 hour, 3 minutes and 4.33 seconds, and it’s not worth
    wasting time to work it out precisely.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t use precise notation for asymptotic complexity (which says which parts
    of speed calculations you can safely ignore), but we will make rough estimates
    of the number of operations that an algorithm will go through. There’s no need
    to get too hung up on precision since computer scientists are comfortable with
    a simple characterisation that gives a ballpark indication of speed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider using selection sort to put a list of *n* values into
    increasing order. (This is explained in the chapter on algorithms). Suppose someone
    tells you that it takes 30 seconds to sort a thousand items. Does that sounds
    like a good algorithm? For a start, you’d probably want to know what sort of computer
    it was running on - if it’s a supercomputer then that’s not so good; if it’s a
    tiny low-power device like a smartphone then maybe it’s ok.
  prefs: []
  type: TYPE_NORMAL
- en: Also, a single data point doesn’t tell you how well the system will work with
    larger problems. If the selection sort algorithm above was given 10 thousand items
    to sort, it would probably take about 50 minutes (3000 seconds) — that’s 100 times
    as long to process 10 times as much input.
  prefs: []
  type: TYPE_NORMAL
- en: 'These data points for a particular computer are useful for getting an idea
    of the performance (that is, complexity) of the algorithm, but they don’t give
    a clear picture. It turns out that we can work out exactly how many steps the
    selection sort algorithm will take for *n* items: it will require about n(n-1)/2
    operations, or in expanded form,n2/2 - n/2 operations. This formula applies regardless
    of the kind of computer its running on, and while it doesn’t tell us the time
    that will be taken, it can help us to work out if it’s going to be reasonable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the above formula we can see why it gets bad for large values of *n* :
    the number of steps taken increases with the square of the size of the input.
    Putting in a value of 1 thousand for *n* tells us that it will use 1,000,000/2
    - 1,000/2 steps, which is 499,500 steps.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the second part (1000/2) makes little difference to the calculation.
    If we just use the n2/2 part of the formula, the estimate will be out by 0.1%,
    and quite frankly, the user won’t notice if it takes 20 seconds or 19.98 seconds.
    That’s the point of asymptotic complexity — we only need to focus on the most
    significant part of the formula, which contains n2.
  prefs: []
  type: TYPE_NORMAL
- en: Also, since measuring the number of steps is independent of the computer it
    will run on, it doesn’t really matter if it’s described as n2/2 or n2\. The amount
    of time it takes will be proportional to both of these formulas, so we might as
    well simplify it to n2\. This is only a rough characterisation of the selection
    sort algorithm, but it tells us a lot about it, and this level of accuracy is
    widely used to quickly but fairly accurately characterise the complexity of an
    algorithm. In this chapter we’ll be using similar crude characterisations because
    they are usually enough to know if an algorithm is likely to finish in a reasonable
    time or not.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve studied algorithms, you will have learnt that some sorting algorithms,
    such as mergesort and quicksort, are inherently faster than other algorithms,
    such as insertion sort, selection sort, or bubble sort. It’s obviously better
    to use the faster ones. The first two have a complexity of n log(n) time (that
    is, the number of steps that they take is roughly proportional to n log(n)), whereas
    the last three have complexity of n2\. Generally the consequence of using the
    wrong sorting algorithm will be that a user has to wait many minutes (or perhaps
    hours) rather than a few seconds or minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Here we’re going to consider another possible sorting algorithm, called *permutation
    sort*. Permutation sort says “Let’s list all the possible orderings (“permutations”)
    of the values to be sorted, and check each one to see if it is sorted, until the
    sorted order is found”. This algorithm is straightforward to describe, but is
    it any good?
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you are sorting the numbers 45, 21 and 84, then every possible
    order they can be put in (that is, all permutations) would be listed as:'
  prefs: []
  type: TYPE_NORMAL
- en: 45, 21, 84
  prefs: []
  type: TYPE_NORMAL
- en: 45, 84, 21
  prefs: []
  type: TYPE_NORMAL
- en: 21, 45, 84
  prefs: []
  type: TYPE_NORMAL
- en: 21, 84, 45
  prefs: []
  type: TYPE_NORMAL
- en: 84, 21, 45
  prefs: []
  type: TYPE_NORMAL
- en: 84, 45, 21
  prefs: []
  type: TYPE_NORMAL
- en: Going through the above list, the only line that is in order is 21, 45, 84,
    so that’s the solution. It’s a very inefficient approach, but it will help to
    illustrate what we mean by tractability.
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand how this works, and the implications, choose four different
    words (in the example below we have used colours) and list all the possible orderings
    of the four words. Each word should appear exactly once in each ordering. You
    can either do this yourself, or use an online permutation generator such as[JavaScriptPermutations](http://users.telenet.be/vdmoortel/dirk/Maths/permutations.html) or [Text
    Mechanic](http://textmechanic.com/Permutation-Generator.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example if you’d picked red, blue, green, and yellow, the first few orderings
    could be:'
  prefs: []
  type: TYPE_NORMAL
- en: red, blue, green, yellow
  prefs: []
  type: TYPE_NORMAL
- en: red, blue, yellow, green
  prefs: []
  type: TYPE_NORMAL
- en: red, yellow, blue, green
  prefs: []
  type: TYPE_NORMAL
- en: red, yellow, green, blue
  prefs: []
  type: TYPE_NORMAL
- en: They do not need to be in any particular order, although a systematic approach
    is recommended to ensure you don’t forget any!
  prefs: []
  type: TYPE_NORMAL
- en: Once your list of permutations is complete, search down the list for the one
    that has the words sorted in alphabetical order. The process you have just completed
    is using permutation sort to sort the words.
  prefs: []
  type: TYPE_NORMAL
- en: Now add another word. How many possible orderings will there be with 5 words?
    What about with only 2 and 3 words — how many orderings are there for those? If
    you gave up on writing out all the orderings with 5 words, can you now figure
    out how many there might be? Can you find a pattern? How many do you think there
    might be for 10 words? (You don’t have to write them all out!).
  prefs: []
  type: TYPE_NORMAL
- en: If you didn’t find the pattern for the number of orderings, think about using
    factorials. For 3 words, there are 3! (“3 factorial”) orderings. For 5 words,
    there are 5! orderings. Check the jargon buster below if you don’t know what a
    “factorial” is, or if you have forgotten!
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Factorials are very easy to calculate; just multiply together all the integers
    from the number down to 1\. For example, to calculate 5! you would simply multiply:
    5 x 4 x 3 x 2 x 1 = 120\. For 8! you would simply multiply 8 x 7 x 6 x 5 x 4 x
    3 x 2 x 1 = 40,320.'
  prefs: []
  type: TYPE_NORMAL
- en: As stated above, the factorial of a number tells you how many permutations (orderings)
    there would be for that number of words (assuming they are all different). This
    means that if you are arranging 8 words, there will be 40,320 ways of arranging
    them (which is why you weren’t asked to try this in the first exercise!!)
  prefs: []
  type: TYPE_NORMAL
- en: Your calculator may have a ”!” button for calculating factorials and spreadsheets
    usually have a “FACT” function, although for the factorials under 10 in this section,
    we recommend that you calculate them the long way, and then use the calculator
    as a double check. Ensuring you understand how a factorial is calculated is essential
    for understanding the rest of this section!
  prefs: []
  type: TYPE_NORMAL
- en: For factorials of larger numbers, most desktop calculators won’t work so well;
    for example, 100! has 158 digits. You can use the calculator below to work with
    huge numbers (especially when using factorials and exponents).
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad96e90e82.png)Click to load'
  prefs: []
  type: TYPE_NORMAL
- en: big number calculator](http://csfieldguide.org.nz/_static/widgets/big-calculator.html?plain=true%20frameborder=)
  prefs: []
  type: TYPE_NORMAL
- en: Try calculating 100! using this calculator — that’s the number of different
    routes that a travelling salesman might take to visit 100 places (not counting
    the starting place). With this calculator you can copy and paste the result back
    into the input if you want to do further calculations on the number. If you are
    doing these calculations for a report, you should also copy each step of the calculation
    into your report to show how you got the result.
  prefs: []
  type: TYPE_NORMAL
- en: There are other big number calculators available online; for example, the [Big
    Integer Calculator](http://www.javascripter.net/math/calculators/100digitbigintcalculator.htm).
    Other big calculators are available online, or you could look for one to download
    for a desktop machine or smartphone.
  prefs: []
  type: TYPE_NORMAL
- en: As a final exercise on permutation sort, calculate how long a computer would
    take to use permutation sort to sort 100 numbers. Remember that you can use the
    calculator that was linked to above. Assume that you don’t have to worry about
    how long it will take to generate the permutations, only how long it will take
    to check them. Assume that you have a computer that creates and checks an ordering
    every nanosecond.
  prefs: []
  type: TYPE_NORMAL
- en: How many orderings need to be checked for sorting 100 numbers?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many orderings can be checked in a second?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many orderings can be checked in a year?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many years will checking all the orderings take?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And as an interesting thing to think about, do some calculations based on the
    assumptions listed below. How long would it take to use permutation sort on 100
    numbers? What would happen first: the algorithm would finish, or the universe
    would end?'
  prefs: []
  type: TYPE_NORMAL
- en: There are 1082 atoms in the universe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The universe has another 14 billion years before it ends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose every atom in the universe is a computer that can check an ordering
    every nanosecond
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By now, you should be very aware of the point that is being made. Permutation
    sort is so inefficient that sorting 100 numbers with it takes so long that it
    is essentially impossible. Trying to use permutation sort with a non trivial number
    of values simply won’t work. While selection sort is a lot slower than quick sort
    or merge sort, it wouldn’t be impossible for Facebook to use selection sort to
    sort their list of 1 billion users. It would take a lot longer than quick sort
    would, but it would be doable. Permutation sort on the other hand would be impossible
    to use!
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we need to now distinguish between algorithms that are essentially
    usable, and algorithms that will take billions of year to finish running, even
    with a small input such as 100 values.
  prefs: []
  type: TYPE_NORMAL
- en: Computer Scientists call an algorithm “intractable” if it would take a completely
    unreasonable amount of time to run on reasonably sized inputs. Permutation sort
    is a good example of an intractable algorithm. The term “intractable” is used
    a bit more formally in computer science; it’s explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the *problem* of sorting items into order is not intractable - even though
    the Permutation sort algorithm is intractable, there are lots of other efficient
    and not-so-efficient algorithms that you could use to solve a sorting problem
    in a reasonable amount of time: quick sort, merge sort, selection sort, even bubble
    sort! However, there are some problems in which the ONLY known algorithm is one
    of these intractable ones. Problems in this category are known as *intractable
    problems*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity : Towers of Hanoi**'
  prefs: []
  type: TYPE_NORMAL
- en: The Towers of Hanoi problem is a challenge where you have a stack of disks of
    increasing size on one peg, and two empty pegs. The challenge is to move all the
    disks from one peg to another, but you may not put a larger disk on top of a smaller
    one. There’s a description of it at [Wikipedia](http://en.wikipedia.org/wiki/Tower_of_Hanoi).
  prefs: []
  type: TYPE_NORMAL
- en: This problem cannot be solved in fewer than 2n-1 moves, so it’s an intractable
    problem (a computer program that lists all the moves to make would use at least
    2n - 1 steps). For 6 disks it only needs 63 moves, but for 50 disks this would
    be 1,125,899,906,842,623 moves.
  prefs: []
  type: TYPE_NORMAL
- en: We usually characterise a problem like this as having a complexity of 2n, as
    subtracting one to get a precise value makes almost no difference, and the shorter
    expression is simpler to communicate to others.
  prefs: []
  type: TYPE_NORMAL
- en: The Towers of Hanoi is one problem where we know for sure that it will take
    exponential time. There are many intractable problems where this isn’t the case
    — we don’t have tractable solutions for them, but we don’t know for sure if they
    don’t exist. Plus this isn’t a real problem — it’s just a game (although there
    is a backup system based on it). But it is a nice example of an exponential time
    algorithm, where adding one disk will double the number of steps required to produce
    a solution.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3\. TRACTABILITY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s a very simple rule that computer scientists use to decide if an algorithm
    is tractable or not, based on the complexity (estimated number of steps) of the
    algorithm. Essentially, if the algorithm takes an exponential amount of time or
    worse for an input of size *n*, it is labelled as intractable. This simple rule
    is a bit crude, but it’s widely used and provides useful guidance. (Note that
    a factorial amount of time, *n!*, is intractable because it’s bigger than an exponential
    function.)
  prefs: []
  type: TYPE_NORMAL
- en: To see what this means, let’s consider how long various algorithms might take
    to run. The following interactive will do the calculations for you to estimate
    how long an algorithm might take to run. You can choose if the running time is
    exponential (that is, 2n, which is the time required for the Towers of Hanoi problem
    with *n*disks), or factorial (that is, n!, which is the time required for checking
    all possible routes a travelling salesman would make to visit *n* places other
    than the starting point). You can use the interactive below to calculate the time.
  prefs: []
  type: TYPE_NORMAL
- en: For example, try choosing the factorial time for the TSP, and put in 20 for
    the value of *n* (i.e. this is to check all possible travelling salesman visits
    to 20 places). Press the return or tab key to update the calculation. The calculator
    will show a large number of seconds that the program will take to run; you can
    change the units to years to see how long this would be.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad96e245ff.png)Click to load'
  prefs: []
  type: TYPE_NORMAL
- en: big number calculator](http://csfieldguide.org.nz/_static/widgets/tract-scaling-v2.html)
  prefs: []
  type: TYPE_NORMAL
- en: So far the calculation assumes that the computer would only do 1 operation per
    second; try changing to a million (1,000,000) operations per second, which is
    more realistic, and see how long that would take.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to solve problems faster is to have multiple processors work on
    different solutions at the same time. If you were to buy 1,000 processors (e.g.
    1,000 computers, or 250 4-core computers) and have each one test out different
    routes, then the solution could be found 1,000 times faster. Try changing the
    number of processors to 1,000, and see how long that would take (you may need
    to change the units back — is it seconds? hours? days?)
  prefs: []
  type: TYPE_NORMAL
- en: The interactive above estimates the amount of time taken for various algorithms
    to run given *n* values to be processed. Let’s assume that we have a *very* fast
    computer, faster than any that exist. Try putting in the assumption that the computer
    can do a million million (1,000,000,000,000) steps per second. Is that achievable?
    But what if you add just two more locations to the problem (i.e. n=22 instead
    of n=20)?
  prefs: []
  type: TYPE_NORMAL
- en: Now, consider an algorithm that has a complexity of n2 (there are lots that
    take roughly this number of steps, including selection sort which was mentioned
    earlier). Type in a value of 1,000,000 for *n* to see how long it might take to
    sort a million items on a single processor (keep the number of steps per second
    at 1,000,000,000,000, but set the number of processors to just 1) — it should
    show that it will only take about 1 second on our hypothetical very fast machine.
    Now put in 10 million for *n* — although it’s sorting a list 10 times as big,
    it takes more than 10 times as long, and will now take a matter of minutes rather
    than seconds. At what value of *n* does the amount of time become out of the question
    — that is, how large would the problem need to be for it to take years to finish?
    Is anyone ever likely to be sorting this many values — for example, what if for
    some reason you were sorting the name of every person in the world, or every base
    in the human genome?
  prefs: []
  type: TYPE_NORMAL
- en: What about an algorithm with complexity of n3? What’s the largest size input
    that it can process in a reasonable amount of time?
  prefs: []
  type: TYPE_NORMAL
- en: Now try the same when the number of steps is 2n, but start with a value of 10
    for *n* , then try 30, 40 , 50 and so on. You’ll probably find that for an input
    of about 70 items it will take an unreasonable amount of time. Is it much worse
    for 80 items?
  prefs: []
  type: TYPE_NORMAL
- en: Now try increasing the number of operations per second to 10 times as many.
    Does this help to solve bigger problems?
  prefs: []
  type: TYPE_NORMAL
- en: Trying out these figures you will likely have encountered the barrier between
    “tractable” and “intractable” problems. Algorithms that take n2, n3 or even n4 time
    to solve a problem (such as sorting a list) aren’t amazing, but at least with
    a fast enough computer and for the size of inputs we might reasonably encounter,
    we have a chance of running them within a human lifetime, and these are regarded
    as *tractable* . However, for algorithms that take 2n, 3n or more steps, the amount
    of time taken can end up as billions of years even for fairly small problems,
    and using computers that are thousand times faster still doesn’t help to solve
    much bigger problems. Such problems are regarded as *intractable* . Mathematically,
    the boundary between tractable and intractable is between a polynomial number
    of steps (polynomials are formulas made up of n2, n3, n4 and so on), and an exponential
    number of steps (2n, 3n, 4n, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The two formulas n2 and 2n look very similar, but they are really massively
    different, and can mean a difference between a few seconds and many millennia
    for the program to finish. The whole point of this chapter is to develop an awareness
    that there are many problems that we have tractable algorithms for, but there
    are also many that we haven’t found any tractable algorithms for. It’s very important
    to know about these, since it will be futile to try to write programs that are
    intractable, unless you are only going to be processing very small problems.
  prefs: []
  type: TYPE_NORMAL
- en: Note that algorithms that take a factorial amount of time (n!, or 1 \times 2
    \times 3 \times \ldots n) are in the intractable category (in fact, they take
    times that are a lot worse than 2n).
  prefs: []
  type: TYPE_NORMAL
- en: Essentially any algorithm that tries out all combinations of the input will
    inevitably be intractable because the number of combinations is likely to be exponential
    or factorial. Thus an important point is that it’s usually not going to work to
    design a system that just tries out all possible solutions to see which is the
    best.
  prefs: []
  type: TYPE_NORMAL
- en: Although we’ve provided n6 as an example of a tractable time, nearly all algorithms
    you’re likely to encounter will be n3 and better, or 2n and worse — only very
    specialised ones fall in the gap between those. So there’s a big gulf between
    tractable and intractable problems, and trying to grapple with it is one of the
    biggest problems in computer science!
  prefs: []
  type: TYPE_NORMAL
- en: What about Moore’s law, which says that computing power is increasing exponentially?
    Perhaps that means that if we wait a while, computers will be able to solve problems
    that are currently intractable? Unfortunately this argument is wrong; intractable
    problems are also exponential, and so the rate of improvement due to Moore’s law
    means that it will only allow for slightly larger intractable problems to be solved.
    For example, if computing speed is doubling every 18 months (an optimistic view
    of Moore’s law), and we have an intractable problem that takes 2n operations to
    solve (many take longer than this), then in 18 months we will be able to solve
    a problem that’s just one item bigger. For example, if you can solve an exponential
    time problem for 50 items (50 countries on a map to colour, 50 cities for a salesman
    to tour, or 50 rings on a Towers of Hanoi problem) in 24 hours, then in 18 months
    you can expect to buy a computer that could solve it for 51 items at best! And
    in 20 years you’re likely to be able to get a computer that could solve for 55
    items in one day. You’re going to have to be more than patient if you want Moore’s
    law to help out here — you have to be prepared to wait for decades for a small
    improvement!
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that if you need to do calculations of huge numbers, there’s a calculator
    here that you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ad96d9b972.png)Click to load'
  prefs: []
  type: TYPE_NORMAL
- en: big number calculator](http://csfieldguide.org.nz/_static/widgets/big-calculator.html?plain=true%20frameborder=)
  prefs: []
  type: TYPE_NORMAL
- en: 11.4\. THE TRAVELLING SALESMAN PROBLEM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An example of an intractable problem is the Travelling Salesman Problem (TSP).
    The TSP involves a bunch of locations (cities, houses, airports,....) where you
    can travel between any possible pair of locations. The goal is to find the shortest
    route that will go through all the locations once — this is what the interactive
    at the start of this chapter does.
  prefs: []
  type: TYPE_NORMAL
- en: Researchers have spent a lot of time trying to find efficient solutions to the
    Travelling Salesman Problem, yet have been unable to find a *tractable* algorithm
    for solving it. As you learnt in the previous section, *intractable* algorithms
    are very slow, to the point of being impossible to use. As the only solutions
    to TSP are intractable, TSP is known as an *intractable problem*.
  prefs: []
  type: TYPE_NORMAL
- en: It hasn’t actually been *proven* that there is no tractable solution to TSP,
    although many of the world’s top computer scientists have worked on this problem
    for the last 40 years, trying to find a solution but without success. What they
    have managed to do is find thousands of other problems that are also intractable,
    and more importantly, if a solution is found for any one of these problems, we
    know how to convert it to a solution for any of the others (these are called NP-complete
    problems). They all stand and fall together, including the TSP problem. So it’s
    not just being lazy if you give up on finding an optimal TSP algorithm — people
    have tried for decades and not found a tractable algorithm. Of course, this is
    also a strong motivator to try to find one — if you do, you will have solved thousands
    of other problems at the same time! This is a great thing for a researcher to
    do, but if you have a program to get finished by the end of the month, it’s not
    a good bet to work on it.
  prefs: []
  type: TYPE_NORMAL
- en: Current algorithms for finding the optimal TSP solution aren’t a lot better
    than simply trying out all possible paths through the map (as in the interactive
    at the start of this chapter). The number of possible paths gets out of hand;
    it’s an intractable approach. In the project below you’ll be estimating how long
    it would take.
  prefs: []
  type: TYPE_NORMAL
- en: While TSP was originally identified as being the problem that sales people face
    when driving to several different locations and wanting to visit them in the order
    that leads to the shortest route (less petrol usage), the same problem applies
    to many other situations as well. Courier and delivery companies have variants
    of this problem — often with extra constraints such as limits on how long a driver
    can work for, or allowing for left hand turns being faster than right-hand ones
    (in NZ at least!)
  prefs: []
  type: TYPE_NORMAL
- en: Since these problems are important for real companies, it is not reasonable
    to simply give up and say there is no solution. Instead, when confronted with
    an intractable problem, computer scientists look for algorithms that produce approximate
    solutions — solutions that are not perfectly correct or optimal, but are hopefully
    close enough to be useful. By relaxing the requirement that the solution has to
    be perfectly correct, it is often possible to come up with tractable algorithms
    that will find good enough solutions in a reasonable time. This kind of algorithm
    is called a *heuristic* - it uses rules of thumb to suggest good choices and build
    up a solution made of pretty good choices.
  prefs: []
  type: TYPE_NORMAL
- en: A simple heuristic that often works OK is a *greedy* heuristic algorithm — an
    algorithm that just takes what looks like the best choice at each step. For example,
    for the TSP, a greedy heuristic algorithm might repeatedly take the route to the
    next closest city. This won’t always be the best choice, but it is very fast,
    and experience shows that it is typically no more than 25% worse than the optimal.
    There are more sophisticated ways of designing approximate algorithms that can
    do better than this (some can get within 3% of optimal for the TSP), but they
    take longer to run.
  prefs: []
  type: TYPE_NORMAL
- en: There are software companies that work on trying to make better and better approximate
    algorithms for guiding vehicles by GPS for delivery routes. Companies that write
    better algorithms can charge a lot of money if their routes are faster, because
    of all the fuel and time savings that can be made.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting thing with intractability is that you can have two very similar
    problems, with one being intractable and the other being tractable. For example,
    finding the shortest route between two points (like a GPS device usually does)
    is a tractable problem, yet finding the shortest route around multiple points
    (the TSP) isn’t. By the way, finding the *longest* path between two points (without
    going along any route twice) is also intractable, even though finding the *shortest* path
    is tractable!
  prefs: []
  type: TYPE_NORMAL
- en: '11.4.1\. PROJECT: THE CRAYPOTS PROBLEM'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should present your findings for this project in a written report where
    you include your answers to the exercises, the maps you make, and written explanations
    to explain what you have found out and learnt.
  prefs: []
  type: TYPE_NORMAL
- en: This project is based around a scenario where there is a cray fisher who has
    around 18 craypots that have been laid out in open water. Each day the fisher
    uses a boat to go between the craypots and check each one for crayfish.
  prefs: []
  type: TYPE_NORMAL
- en: The cray fisher has started wondering what the shortest route to take to check
    all the craypots would be, and has asked you for your help. Because every few
    weeks the craypots need to be moved around, the fisher would prefer a general
    way of solving the problem, rather than a solution to a single layout of craypots.
    Therefore, your investigations must consider more than one possible layout of
    craypots, and the layouts investigated should have the craypots placed *randomly* i.e.
    not in lines, patterns, or geometric shapes.
  prefs: []
  type: TYPE_NORMAL
- en: When asked to generate a random map of craypots, get a pile of coins (or counters)
    with however many craypots you need, and scatter them onto an A4 piece of paper.
    If any land on top of each other, place them beside one another so that they are
    touching but not overlapping. One by one, remove the coins, making a dot on the
    paper in the centre of where each coin was. Number each of the dots. Each dot
    represents one craypot that the cray fisher has to check. You should label the
    top left corner or the paper as being the boat dock, where the cray fisher stores
    the boat.
  prefs: []
  type: TYPE_NORMAL
- en: Generate a map with 7 or 8 craypots using the random map generation method described
    above. *Make an extra copy of this map, as you will need it again later.*
  prefs: []
  type: TYPE_NORMAL
- en: Using your intuition, find the shortest path between the craypots.
  prefs: []
  type: TYPE_NORMAL
- en: Now generate a map (same method as above) with somewhere between 15 and 25 craypots. *Make
    more than one copy of this map, as you will need it again later*
  prefs: []
  type: TYPE_NORMAL
- en: Now on this new map, try to use your intuition to find the shortest path between
    the craypots. Don’t spend more than 5 minutes on this task; you don’t need to
    include the solution in your report. Why was this task very challenging? Can you
    be sure you have an optimal solution?
  prefs: []
  type: TYPE_NORMAL
- en: Unless your locations were laid out in a circle or oval, you probably found
    it very challenging to find the shortest route. A computer would find it even
    harder, as you could at least take advantage of your visual search and intuition
    to make the task easier. A computer could only consider two locations at a time,
    whereas you can look at more than two. But even for you, the problem would have
    been challenging! Even if you measured the distance between each location and
    put lines between them and drew it on the map so that you didn’t have to judge
    distances between locations in your head, it’d still be very challenging for you
    to figure out!
  prefs: []
  type: TYPE_NORMAL
- en: A straightforward algorithm to guarantee that you find the shortest route is
    to check *all* possible routes. This involves working out what all the possible
    routes are, and then checking each one. A possible route can be written as a list
    of the locations (i.e. the numbers on the craypots), in the order to go between
    them. This should be starting to sound familiar to you assuming you did the permutation
    sort discussed above. Just like in that activity you listed all the possible ordering
    for the values in the list to be sorted, this algorithm would require listing
    all the possible orderings of the craypots, which is equivalent (although you
    don’t need to list all the orderings for this project!).
  prefs: []
  type: TYPE_NORMAL
- en: How many possible routes are there for the larger example you have generated?
    How is this related to permutation sort, and factorials? How long would it take
    to calculate the shortest route in your map, assuming the computer can check 1
    billion (1,000,000,000) possible routes per second? (i.e. it can check one route
    per nanosecond) What can you conclude about the cost of this algorithm? Would
    this be a good way for the cray fisher to decide which path to take?
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you show *all* your mathematical working in your answers to the above
    questions!
  prefs: []
  type: TYPE_NORMAL
- en: So this algorithm is intractable, but maybe there is a more clever algorithm
    that is tractable? The answer is No.
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to tell that this problem is equivalent to the TSP, and therefore
    it is intractable. How can you tell? What is the equivalent to a town in this
    scenario? What is the equivalent to a road?
  prefs: []
  type: TYPE_NORMAL
- en: Since we know that this craypot problem is an example of the TSP, and that there
    is no known tractable algorithm for the TSP, we know there is no tractable algorithm
    for the craypot problem either. Although there are slightly better algorithms
    than the one we used above, they are still intractable and with enough craypots,
    it would be impossible to work out a new route before the cray fisher has to move
    the pots again!
  prefs: []
  type: TYPE_NORMAL
- en: Instead of wasting time on trying to invent a clever algorithm that no-one has
    been able to find, we need to rely on a algorithm that will generate an approximate
    solution. The cray fisher would be happy with an approximate solution that is
    say, 10% longer more than the best possible route, but which the computer can
    find quickly.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways of approaching this. Some are better than others in general,
    and some are better than others with certain layouts. One of the more obvious
    approximate algorithms, is to start from the boat dock in the top left corner
    of your map and to go to the nearest craypot. From there, you should go to the
    nearest craypot from that craypot, and repeatedly go to the nearest craypot that
    hasn’t yet been checked. This approach is known as a *greedy heuristic algorithm* as
    it always makes the decision that looks the best at the current time, rather than
    making a not so good decision now to try and get a bigger pay off later. You will
    understand why this doesn’t necessarily lead to the optimal solution after completing
    the following exercises.
  prefs: []
  type: TYPE_NORMAL
- en: On a copy of each of your 2 maps you generated, draw lines between the craypots
    to show the route you would find following the greedy algorithm (you should have
    made more than one copy of each of the maps!)
  prefs: []
  type: TYPE_NORMAL
- en: For your map with the smaller number of craypots (7 or 8), compare your optimal
    solution and your approximate solution. Are they the same? Or different? If they
    are the same, would they be the same in all cases? Show a map where they would
    be different (you can choose where to place the craypots yourself, just use as
    many craypots as you need to illustrate the point).
  prefs: []
  type: TYPE_NORMAL
- en: For your larger map, show why you don’t have an optimal solution. The best way
    of doing this is to show a route that is similar to, but shorter than the approximate
    solution. The shorter solution you find doesn’t have to be the optimal solution,
    it just has to be shorter than the one identified by the approximate algorithm
    (Talk to your teacher if you can’t find a shorter route and they will advise on
    whether or not you should generate a new map). You will need to show a map that
    has a greedy route and a shorter route marked on it. Explain the technique you
    used to show there was a shorter solution. Remember that it doesn’t matter how
    much shorter the new solution you identify is, just as long as it is at least
    slightly shorter than the approximate solution — you are just showing that the
    approximate solution couldn’t possibly be the optimal solution by showing that
    there is a shorter solution than the approximate solution.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the greedy algorithm only generates an approximate solution, as
    opposed to the optimal solution, explain why is it more suitable for the cray
    fisher than generating an optimal solution would be?
  prefs: []
  type: TYPE_NORMAL
- en: Why would it be important to the cray fisher to find a short route between the
    craypots, as opposed to just visiting them in a random order? Discuss other problems
    that are equivalent to TSP that real world companies encounter every day. Why
    is it important to these companies to find good solutions to TSP? Estimate how
    much money might a courier company be wasting over a year if their delivery routes
    were 10% worse than the optimal. How many different locations/towns/etc might
    their TSP solutions have to be able to handle?
  prefs: []
  type: TYPE_NORMAL
- en: Find a craypot layout that will result in the greedy algorithm finding the shortest
    route. How do you know it is the shortest route? What is a general pattern that
    seem to work well for this greedy algorithm?
  prefs: []
  type: TYPE_NORMAL
- en: Find a craypot layout that results in the greedy algorithm finding what seem
    to be a really inefficient route. Why is it inefficient? Don’t worry about trying
    to find an actual worst case, just find a case that seems to be quite bad. What
    is a general pattern that seems to make this greedy algorithm inefficient?
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to include an introductory paragraph in your report that outlines
    the key ideas. It should include a brief description of what an intractable problem
    is, and how a computer scientist goes about dealing with such a problem. The report
    should also describe the Travelling Salesman Problem and the craypot problem in
    your own words. Explain why the craypot problem is a realistic problem that might
    matter to someone.
  prefs: []
  type: TYPE_NORMAL
- en: 11.5\. OTHER INTRACTABLE PROBLEMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are thousands of problems like the TSP for which no tractable solution
    is known. Extra sections will eventually be added here to introduce some of them,
    but in the meantime, if you are keen you might like to explore some of these problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[map and graph colouring](http://csunplugged.org/graph-colouring) (these can
    be reduced to a timetabling problem and vice versa, showing how NP-complete problems
    can relate to each other)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[the knapsack problem](http://en.wikipedia.org/wiki/Knapsack_problem)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[the bin packing problem](http://en.wikipedia.org/wiki/Bin_packing_problem)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hamiltonian paths](http://en.wikipedia.org/wiki/Hamiltonian_path) (no tractable
    solution for this is known, yet the very similar Eulerian path, which is often
    presented as the seven bridges problem, has an easy tractable solution)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Steiner trees](http://www.csunplugged.org/steiner-trees)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dominating sets](http://www.csunplugged.org/dominating-sets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Longest path](http://en.wikipedia.org/wiki/Longest_path) (this is interesting
    because finding the longest path is intractable, yet finding the shortest path
    is tractable - the shortest path is calculated when a GPS device works out the
    shortest route to a destination. Also, a Hamiltonian problem can be reduced easily
    to longest path, showing the concept of reduction when one NP-complete problem
    is used to solve another). And here’s a song about it! [https://www.youtube.com/watch?feature=player_embedded&v=a3ww0gwEszo](https://www.youtube.com/watch?feature=player_embedded&v=a3ww0gwEszo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[the Battleship problem](http://en.wikipedia.org/wiki/Battleship_(puzzle))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.6\. THE WHOLE STORY!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The question of tractability is a big one in computer science — in fact, what
    is widely regarded as the biggest unsolved problem in computer science revolves
    around it. You may recall that we mentioned that there are thousands of problems
    that are we don’t have a tractable solution for, yet a tractable solution to one
    can be adapted to all the others. This groups of problems is called “NP-complete”
    (NP stands for non-deterministic polynomial if you really want to know; complete
    just means that they can all be converted to each other!) The big question is
    whether or not there is a polynomial time algorithm for any one of them, in which
    case all NP problems will have a P (polynomial time) solution. The question is
    often referred to as whether or not P equals NP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, things get worse. So far we’ve talked about intractable problems
    — ones that can be solved, but might need billions of years on a computer. If
    you think it’s bad that some problems take that long to solve, that’s nothing!
    There are some well known problems that we know can *never* be solved on a computer.
    For example, writing a program that reliably tells you if another program will
    finish or not is impossible! There are other examples of such problems here: -[http://www.cs4fn.org/algorithms/tiles.php](http://www.cs4fn.org/algorithms/tiles.php) - [http://www.cs4fn.org/algorithms/uncomputable.php](http://www.cs4fn.org/algorithms/uncomputable.php) - [http://www.cs4fn.org/algorithms/haltingproblem.php](http://www.cs4fn.org/algorithms/haltingproblem.php)'
  prefs: []
  type: TYPE_NORMAL
- en: It’s good to know about these issues, to avoid getting stuck writing impossible
    programs. It’s also a fascinating area of research with opportunities to make
    a discovery that could change the world of computing, as well as contribute to
    our understanding on what can and can’t be computed.
  prefs: []
  type: TYPE_NORMAL
- en: 11.7\. FURTHER READING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This topic is covered very thoroughly in a way that is accessible to non-specialists
    in a popular book by David Harel called “Computers Ltd.: What They Really Can’t
    Do”.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1\. USEFUL LINKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Computational_complexity_theory](http://en.wikipedia.org/wiki/Computational_complexity_theory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.tsp.gatech.edu/games/index.html](http://www.tsp.gatech.edu/games/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://csunplugged.org/graph-colouring](http://csunplugged.org/graph-colouring)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Travelling_salesman_problem](http://en.wikipedia.org/wiki/Travelling_salesman_problem)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Knapsack_problem](http://en.wikipedia.org/wiki/Knapsack_problem)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Bin_packing_problem](http://en.wikipedia.org/wiki/Bin_packing_problem)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Hamiltonian_path](http://en.wikipedia.org/wiki/Hamiltonian_path)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Brute-force_search](http://en.wikipedia.org/wiki/Brute-force_search)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12\. FORMAL LANGUAGES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 12.1\. WHAT’S THE BIG PICTURE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve ever written a text-based program, chances are that at some stage
    the system has told you there’s an error in your program even before it runs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada52be381.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These “syntax errors” are annoying messages that programmers become excruciatingly
    familiar with ... it means that they didn’t follow the rules somehow, even if
    it’s just a tiny mistake. For example, suppose you intended to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'but you accidentally left out one of the brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When you try to compile or run the program, the computer will tell you that
    there’s an error. If it’s really helpful, it might even suggest where the error
    is, but it won’t run the program until you fix it.
  prefs: []
  type: TYPE_NORMAL
- en: This might seem annoying, but in fact by enforcing precision and attention to
    detail it helps pinpoint mistakes before they become bugs in the program that
    go undetected until someone using it complains that it’s not working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you get errors like this, you’re dealing with a *formal language*.
    Formal languages specify strict rules such as “all parentheses must be balanced”,
    “all commands in the program must be keywords selected from a small set”, or “the
    date must contain three numbers separated by dashes”.
  prefs: []
  type: TYPE_NORMAL
- en: Formal languages aren’t just used for programming languages — they’re used anywhere
    the format of some input is tightly specified, such as typing an email address
    into a web form.
  prefs: []
  type: TYPE_NORMAL
- en: In all these cases, the commands that you have typed (whether in Python, Scratch,
    Snap!, C, Pascal, Basic, C#, HTML, or XML) are being read by a computer program.
    (That’s right... Python is a program that reads in Python programs.) In fact,
    the compiler for a programming language is often written in its own language.
    Most C compilers are written in C — which begs the question, who wrote the first
    C compiler (and what if it had bugs)?! Computer Scientists have discovered good
    ways to write programs that process other programs, and a key ingredient is that
    you have to specify what is allowed in a program very precisely. That’s where
    formal languages come in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the concepts we’ll look at in this chapter are used in a variety of
    other situations: checking input to a web page; analysing user interfaces; searching
    text, particularly with “wild cards” strings that can match any sequence of characters;
    creating logic circuits; specifying communication protocols; and designing embedded
    systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re familiar with the idea of formal languages, you’ll possess a powerful
    tool for cutting complex systems down to size using an easily specified format.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ada5242e0a.png)](http://xkcd.com/1144/)'
  prefs: []
  type: TYPE_NORMAL
- en: 12.2\. GETTING STARTED
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To give you a taste of what can be done, let’s try searching for words that
    fit particular patterns. Suppose you’re looking for words that contain the name
    “tim”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the [Regex Dictionary](http://www.visca.com/regexdict/) and type into
    the “String:” box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: then press the “Search” button to find all words containing “tim”.
  prefs: []
  type: TYPE_NORMAL
- en: That’s a pretty simple search (though the results may have surprised you!).
    But now we introduce the *wildcard* code, which in this case is ”.” — a widely
    used convention. This matches any character at all. So now you can do a search
    like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'and you will get any words that have both “tim” and “b” with a single character
    — any character — in between. Are there any words that match “tim..b”? “tim...b”?
    You can specify any number of occurrences of a symbol by putting a “*” after it
    (again a widely used convention), so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: will match any words where “tim” is followed by “b”, separated by any number
    of characters — including zero.
  prefs: []
  type: TYPE_NORMAL
- en: Try the following search. What kind of words does it find?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Can you find words that contain your name, or your initials?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What about words containing the letters from your name in the correct order?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there any words that contain all the vowels in order (a, e, i, o, u)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code you’ve used above is a part of a formal language called a “regular
    expression”. Computer programs that accept typed input use regular expressions
    for checking items like dates, credit card numbers and product codes. They’re
    used extensively by programming language compilers and interpreters to make sense
    of the text that a programmer types in. We’ll look at them in more detail in the
    section on [*Regular expressions*](http://csfieldguide.org.nz/FormalLanguages.html#fl-regex).
  prefs: []
  type: TYPE_NORMAL
- en: Next we examine a simple system for reading input called a [*finite state automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton),
    which — as we’ll find out later — is closely related to regular expressions. Later
    we’ll explore the idea of *grammars*, another kind of formal language that can
    deal with more complicated forms of input.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3\. FINITE STATE AUTOMATA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s a map of a commuter train system for the town of Trainsylvania. The trouble
    is, it doesn’t show where the the trains go — all you know is that there are two
    trains from each station, the A-train and the B-train. The inhabitants of Trainsylvania
    don’t seem to mind this — it’s quite fun choosing trains at each station, and
    after a while you usually find yourself arriving where you intended.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada51cba6a.png)'
  prefs: []
  type: TYPE_IMG
- en: You can travel around Trainsylvania yourself using the following interactive.
    You’re starting at the City Mall station, and you need to find your way to Suburbopolis.
    At each station you can choose either the A-train or the B-train — press the button
    to find out where it will take you. But, like the residents of Trainsylvania,
    you’ll probably want to start drawing a map of the railway, because later you
    might be asked to find your way somewhere else. If you want a template to draw
    on, you can[print one out from here](http://csfieldguide.org.nz/_static/formal_languages/FL-trainsylvania-blank.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Did you find a sequence of trains to get from City Mall to Suburbopolis? You
    can test it by typing the sequence of trains in the following interactive. For
    example, if you took the A-train, then the B-train, then an A-train, type in ABA.
  prefs: []
  type: TYPE_NORMAL
- en: Can you find a sequence that takes you from City Mall to Suburbopolis? Can you
    find another sequence, perhaps a longer one? Suppose you wanted to take a really
    long route ... can you find a sequence of 12 hops that would get you there? 20
    hops?
  prefs: []
  type: TYPE_NORMAL
- en: Here’s another map. It’s for a different city, and the stations only have numbers,
    not names (but you can name them if you want).
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada512cb66.png)'
  prefs: []
  type: TYPE_IMG
- en: Suppose you’re starting at station 1, and need to get to station 3 (it has a
    double circle to show that’s where you’re headed.)
  prefs: []
  type: TYPE_NORMAL
- en: What’s the shortest way to get from station 1 to station 3?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where do you end up if you start at station 1 and take the trains ABAA?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where do you end up if your start at station 1 and take 20 train hops, always
    alternating A, B, A, B, A, B?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you give an easy-to-describe sequence of 100 or more hops that will get
    you to station 3?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The map that we use here, with circles and arrows, is actually a powerful idea
    from computer science called a [*Finite State Automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton),
    or FSA for short. Being comfortable with such structures is a useful skill for
    computer scientists.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: The name [*Finite State Automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton) (FSA)
    might seem strange, but each word is quite simple. “Finite” just means that there
    is a limited number of states (such as train stations) in the map. The “state”
    is just as another name for the train stations we were using. “Automaton” is an
    old word meaning a machine that acts on its own, following simple rules (such
    as the cuckoo in a cuckoo clock). Sometimes an FSA is called a **Finite State
    Machine** (FSM), or even just a “state machine”. By the way, the plural of “Automaton”
    can be either “Automata” or “Automatons”. People working with formal languages
    usually use Finite State *Automata*, but “FSAs” for short.
  prefs: []
  type: TYPE_NORMAL
- en: An FSA isn’t all that useful for train maps, but the notation is used for many
    other purposes, from checking input to computer programs to controlling the behaviour
    of an interface. You may have come across it when you dial a telephone number
    and get a message saying “Press 1 for this … Press 2 for that … Press 3 to talk
    to a human operator.” Your key presses are inputs to a [*finite state automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton) at
    the other end of the phone line. The dialogue can be quite simple, or very complex.
    Sometimes you are taken round in circles because there is a peculiar loop in the
    finite-state automaton. If this occurs, it is an error in the design of the system
    — and it can be extremely frustrating for the caller!
  prefs: []
  type: TYPE_NORMAL
- en: Another example is the remote control for an air conditioning unit. It might
    have half a dozen main buttons, and pressing them changes the mode of operation
    (e.g. heating, cooling, automatic). To get to the mode you want you have to press
    just the right sequence, and if you press one too many buttons, it’s like getting
    to the train station you wanted but accidentally hopping on one more train. It
    might be a long journey back, and you may end up exploring all sorts of modes
    to get there! If there’s a manual for the controller, it may well contain a diagram
    that looks like a [*Finite State Automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton).
    If there isn’t a manual, you may find yourself wanting to draw a map, just as
    for the trains above, so that you can understand it better.
  prefs: []
  type: TYPE_NORMAL
- en: 'The map that we used above uses a standard notation. Here’s a smaller one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada50151bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that this map has routes that go straight back to where they started!
    For example, if you start at 1 and take route “b”, you immediately end up back
    at 1\. This might seem pointless, but it can be quite useful. Each of the “train
    stations” is called a state, which is a general term that just represents where
    you are after some sequence of inputs or decisions. What it actually means depends
    on what the FSA is being used for. States could represent a mode of operation
    (like fast, medium, or slow when selecting a washing machine spin cycle), or the
    state of a lock or alarm (on, off, exit mode), or many other things. We’ll see
    more examples soon.
  prefs: []
  type: TYPE_NORMAL
- en: One of the states has a double circle. By convention, this marks a “final” or
    “accepting” state, and if we end up there we’ve achieved some goal. There’s also
    a “start” state — that’s the one with an arrow coming from nowhere. Usually the
    idea is to find a sequence of inputs that gets you from the start state to a final
    state. In the example above, the shortest input to get to state 2 is “a”, but
    you can also get there with “aa”, or “aba”, or “baaaaa”. People say that these
    inputs are “accepted” because they get you from the start state to the final state
    — it doesn’t have to be the shortest route.
  prefs: []
  type: TYPE_NORMAL
- en: What state would you end up in if the input was the letter “a” repeated 100
    times?
  prefs: []
  type: TYPE_NORMAL
- en: Of course, not all inputs get you to state 2\. For example, “aab” or even just
    “b” aren’t accepted by this simple system. Can you characterise which inputs are
    accepted?
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an interactive which follows the rules of the FSA above. You can use
    it to test different inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s another [*FSA*](http://csfieldguide.org.nz/appendices/Glossary.html#term-fsa),
    which looks similar to the last one but behaves quite differently. You can test
    it in the interactive below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4eedfc8.png)'
  prefs: []
  type: TYPE_IMG
- en: Work out which of the following inputs it accepts. Remember to start in state
    1 each time!
  prefs: []
  type: TYPE_NORMAL
- en: “aaa”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “abb”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “aaaa”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “bababab”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “babababa”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the letter “a” repeated 100 times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the letter “a” repeated 1001 times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the letter “b” a million times, then an “a”, then another million of the letter
    “b”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you state a general rule for the input to be accepted?
  prefs: []
  type: TYPE_NORMAL
- en: To keep things precise, we’ll define two further technical terms. One is the [*alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet),
    which is just a list of all possible inputs that might happen. In the last couple
    of examples the [*alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet) has
    consisted of the two letters “a” and “b”, but for an FSA that is processing text
    typed into a computer, the [*alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet) will
    have to include every letter on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: The connections between states are called *transitions*, since they are about
    changing state. The sequence of characters that we input into the FSA is often
    called a[*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) (it’s
    just a [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) of
    letters), and the set of all [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    can be accepted by a particular FSA is called its *language*. For the FSA in the
    last example, its language includes the [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) “a”,
    “aaa”, “bab”, “ababab”, and lots more, because these are accepted by it. However,
    it does not include the [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) “bb”
    or “aa”.
  prefs: []
  type: TYPE_NORMAL
- en: The language of many FSAs is big. In fact, the ones we’ve just looked at are
    infinite. You could go on all day listing patterns that they accept. There is
    no limit to the length of the [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) they
    can accept.
  prefs: []
  type: TYPE_NORMAL
- en: That’s good, because many real-life FSA’s have to deal with “infinite” input.
    The diagram below shows the FSA for the spin speed on a washing machine, where
    each press of the spin button changes the setting.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4e02ce8.png)'
  prefs: []
  type: TYPE_IMG
- en: It would be frustrating if you could only change the spin setting 50 times,
    and then it stopped accepting input ever again. If you want, you could switch
    from fast to slow spin by pressing the spin button 3002 times. Or 2 times would
    do. Or 2 million times (try it if you don’t believe me).
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram summarizes the terminology we have introduced. Notice
    that this FSA has two accepting states. You can have as many as you want, but
    only one start state.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4d13da0.png)'
  prefs: []
  type: TYPE_IMG
- en: For this FSA, the [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) “aa”
    and “aabba” would be accepted, and “aaa” and “ar” wouldn’t. By the way, notice
    that we often put inverted commas around [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) to
    make it clear where they start and stop. Of course, the inverted commas aren’t
    part of the strings.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you’ll see an FSA referred to as a Finite State Machine, or FSM, and
    there are other closely related systems with similar names. We’ll mention some
    later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now there’s something we have to get out of the way before going further. If
    we’re talking about which [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) of
    inputs will get you into a particular state, and the system starts in that state,
    then the *empty string* — that is, a string without any letters at all — is one
    of the solutions! For example, here’s a simple [*finite state automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton) with
    just one input (button a) that represents a strange kind of light switch. The
    reset button isn’t part of the FSA; it’s just a way of letting you return to the
    starting state. See if you can figure out which patterns of input will turn the
    light on:'
  prefs: []
  type: TYPE_NORMAL
- en: Have you worked out which sequences of button presses turn on the light? Now
    think about the *shortest* sequence from a reset that can turn it on.
  prefs: []
  type: TYPE_NORMAL
- en: Since it’s already on when it has been reset, the shortest sequence is *zero* button
    presses. It’s hard to write that down (although you could use “”), so we have
    a symbol especially for it, which is the Greek letter epsilon: ϵ. You’ll come
    across ϵ quite often with formal languages.
  prefs: []
  type: TYPE_NORMAL
- en: It can be a bit confusing. For example, the language (that is, the list of all
    accepted inputs) of the FSA above includes “aaa”, “aaaaaa”, and ϵ. If you try
    telling someone that “nothing” will make the light come on that could be confusing
    — it might mean that you could never turn the light on — so it’s handy being able
    to say that the*empty string* (or ϵ) will turn the light on. There are different
    kinds of “nothing”, and we need to be precise about which one we mean!
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the FSA for the strange light switch. You can tell that ϵ is part of
    the language because the start state is also a final state (in fact, it’s the
    only final state). Actually, the switch isn’t all that strange — data projectors
    often require two presses of the power button, to avoid accidentally turning them
    off.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4c8ebaf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An important part of the culture of computer science is always to consider
    extreme cases. One kind of extreme case is where there is no input at all: what
    if a program is given an empty file, or your database has zero entries in it?
    It’s always important to make sure that these situations have been thought through.
    So it’s not surprising that we have a symbol for the empty string. Just for variety,
    you’ll occasionally find some people using the Greek letter lambda (λ) instead
    of ϵ to represent the empty string.'
  prefs: []
  type: TYPE_NORMAL
- en: And by the way, the language of the three-state FSA above is infinitely large
    because it is the set of all [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    contain the letter “a” in multiples of 3, which is {ϵ, aaa, aaaaaa, aaaaaaaaa,
    ...}. That’s pretty impressive for such a small machine.
  prefs: []
  type: TYPE_NORMAL
- en: While we’re looking at extremes, here’s another FSA to consider. It uses “a”
    and “b” as its [*alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet).
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4be9118.png)'
  prefs: []
  type: TYPE_IMG
- en: Will it accept the [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) “aaa”?
    Or “aba”? Or anything of 3 characters or more?
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you get the third character you end up in state 4, which is called
    a *trap state* because you can’t get out. If this was the map for the commuter
    train system we had at the start of this section it would cause problems, because
    eventually everyone would end up in the trap state, and you’d have serious overcrowding.
    But it can be useful in other situations — especially if there’s an error in the
    input, so no matter what else comes up, you don’t want to go ahead.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the example above, the language of the FSA is any mixture of “a”s and “b”s,
    but only two characters at most. Don’t forget that the empty [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) is
    also accepted. It’s a very small language; the only [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) in
    it are: {ϵ, a, b, aa, ab, ba, bb}.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another FSA to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4b23fb5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It’s fairly clear what it will accept: [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) like
    “ab”, “abab”, “abababababab”, and, of course ϵ. But there are some missing transitions:
    if you are in state 1 and get a “b” there’s nowhere to go. If an input cannot
    be accepted, it will be rejected, as in this case. We could have put in a trap
    state to make this clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4a999f6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But things can get out of hand. What if there are more letters in the [*alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet)?
    We’d need something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4a11618.png)'
  prefs: []
  type: TYPE_IMG
- en: So, instead, we just say that any unspecified transition causes the input to
    be rejected (that is, it behaves as though it goes into a trap state). In other
    words, it’s fine to use the simple version above, with just two transitions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve got the terminology sorted out, let’s explore some applications
    of this simple but powerful “machine” called the [*Finite State Automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton).
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.1\. WHO USES FINITE STATE AUTOMATA?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finite state automata are used a lot in the design of digital circuits (like
    the electronics in a hard drive) and embedded systems (such as burglar alarms
    or microwave ovens). Anything that has a few buttons on it and gets into different
    states when you press those buttons (such as alarm on/off, high/med/low power)
    is effectively a kind of FSA.
  prefs: []
  type: TYPE_NORMAL
- en: With such gadgets, FSAs can be used by designers to plan what will happen for
    every input in every situation, but they can also be used to analyse the interface
    of a device. If the FSA that describes a device is really complicated, it’s a
    warning that the interface is likely to be hard to understand. For example, here’s
    an FSA for a microwave oven. It reveals that, for example, you can’t get from
    power2 to power1 without going through timer1\. Restrictions like this will be
    very frustrating for a user. For example, if they try to set power1 it won’t work
    until they’ve set timer1 first. Once you know this sequence it’s easy, but the
    designer should think about whether it’s necessary to force the user into that
    sort of sequence. These sorts of issues become clear when you look at the FSA.
    But we’re straying into the area of Human-Computer Interaction! This isn’t surprising
    because most areas of computer science end up relating to each other — but let’s
    get back to other applications of FSAs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada490a53e.png)'
  prefs: []
  type: TYPE_IMG
- en: As we shall see in the next section, one of the most valuable uses of the FSA
    in computer science is for checking input to computers, whether it’s a value typed
    into a dialogue box, a program given to a compiler, or some search text to be
    found in a large document. There are also data compression methods that use FSAs
    to capture patterns in the data being compressed, and variants of FSA are used
    to simulate large computer systems to see how best to configure it before spending
    money on actually building it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  prefs: []
  type: TYPE_NORMAL
- en: What’s the biggest FSA in the world, one that lots of people use every day?
    It’s the World-Wide Web. Each web page is like a state, and the links on that
    page are the transitions between them. Back in the year 2000 the web had a billion
    pages. In 2008 Google Inc. declared they had found a trillion different web page
    addresses. That’s a lot. A book with a billion pages would be 50 km thick. With
    a trillion pages, its thickness would exceed the circumference of the earth.
  prefs: []
  type: TYPE_NORMAL
- en: But the web is just a finite-state automaton. And in order to produce an index
    for you to use, search engine companies like Google have to examine all the pages
    to see what words they contain. They explore the web by following all the links,
    just as you did in the train travelling exercise. Only, because it’s called the
    “web,” exploring is called “crawling” — like spiders do.
  prefs: []
  type: TYPE_NORMAL
- en: '12.3.2\. ACTIVITY: PRACTICE CREATING FSAS'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This activity involves constructing and testing your own FSA, using free software
    that you can download yourself. Before doing that, we’ll look at some general
    ways to create an FSA from a description. If you want to try out the examples
    here on a live FSA, read the next two sections about using Exorciser and JFLAP
    respectively, which allow you to enter FSAs and test them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good starting point is to think of the shortest string that is needed for
    a particular description. For example, suppose you need an FSA that accepts all
    strings that contain an even number of the letter “b”. The shortest such string
    is ϵ, which means that the starting state must also be a final state, so you can
    start by drawing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada48671b5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If instead you had to design an FSA where the shortest accepted string is “aba”,
    you would need a sequence of 4 states like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada47a5a7c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then you need to think what happens next. For example, if we are accepting
    strings with an even number of “b”s, a single “b” would have to take you from
    the start state to a non-accepting state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada471e68e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But another “b” would make an even number, so that’s acceptable. And for any
    more input the result would be the same even if all the text to that point hadn’t
    happened, so you can return to the start state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada464b4be.png)'
  prefs: []
  type: TYPE_IMG
- en: Usually you can find a “meaning” for a state. In this example, being in state
    1 means that so far you’ve seen an even number of “b”s, and state 2 means that
    the number so far has been odd.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to think about missing transitions from each state. So far there’s
    nothing for an “a” out of state 1\. Thinking about state 1, an “a” doesn’t affect
    the number of “b”s seen, and so we should remain in state 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada45ab99d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The same applies to state 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4518aa4.png)'
  prefs: []
  type: TYPE_IMG
- en: Now every state has a transition for every input symbol, so the FSA is finished.
    You should now try some examples to check that an even number of “b”s always brings
    it to state 1.
  prefs: []
  type: TYPE_NORMAL
- en: Get some practice doing this yourself! Here are instructions for two different
    programs that allow you to enter and test FSAs.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.2.1\. EXORCISER
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section shows how to use some educational software called “Exorciser”.
    (The next section introduces an alternative called JFLAP which is a bit harder
    to use.) Exorciser has facilities for doing advanced exercises in formal languages;
    but we use just the simplest ones.
  prefs: []
  type: TYPE_NORMAL
- en: Exorciser can be downloaded [here](http://www.swisseduc.ch/compscience/exorciser/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: When you run it, select “Constructing Finite Automata” (the first menu item);
    click the “Beginners” link when you want a new exercise. The challenge in each
    FSA exercise is the part after the | in the braces (i.e., curly brackets). For
    example, in the diagram below you are being asked to draw an FSA that accepts
    an input [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) w
    if “w has length at least 3”. You should draw and test your answer, although initially
    you may find it helpful to just click on “Solve exercise” to get a solution, and
    then follow strings around the solution to see how it works. That’s what we did
    to make the diagram below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada44407e1.png)'
  prefs: []
  type: TYPE_IMG
- en: To draw an FSA in the Exorciser system, right-click anywhere on the empty space
    and you’ll get a menu of options for adding and deleting states, choosing the[*alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet),
    and so on. To make a transition, drag from the outside circle of one state to
    another (or out and back to the state for a loop). You can right-click on states
    and transitions to change them. The notation “a|b” means that a transition will
    be taken on “a” or “b” (it’s equivalent to two parallel transitions).
  prefs: []
  type: TYPE_NORMAL
- en: 'If your FSA doesn’t solve their challenge, you’ll get a hint in the form of
    a [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) that
    your FSA deals with incorrectly, so you can gradually fix it until it works. If
    you’re stuck, click “Solve exercise”. You can also track input as you type it:
    right-click to choose that option. See the [SwissEduc website](http://www.swisseduc.ch/compscience/) for
    more instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3e01265.png)'
  prefs: []
  type: TYPE_IMG
- en: The section after next gives some examples to try. If you’re doing this for
    a report, keep copies of the automata and tests that you do. Right-click on the
    image for a “Save As” option, or else take screenshots of the images.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.2.2\. JFLAP
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another widely used system for experimenting with FSAs is a program called JFLAP
    (download it from [http://jflap.org](http://jflap.org/)). You can use it as an
    alternative for Exorciser if necesary. You’ll need to follow instructions carefully
    as it has many more features than you’ll need, and it can be hard to get back
    to where you started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to build an FSA using JFLAP. As an example, we’ll use the following
    FSA:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3d72c6f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To build this, run JFLAP and:'
  prefs: []
  type: TYPE_NORMAL
- en: click on the “Finite Automaton” button in the control panel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Editor window, click on the picture of a state (with a little q in it),
    and then click in the window to create states.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To move the states around, click on the arrow tool in the toolbar (leftmost
    icon). It doesn’t matter where the states are, but you want them to be easy to
    view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To put a transition between two states, click on the transition tool (third
    icon), drag a line between two states, type the label for the transition (“a”
    or “b” for this exercise), and press return. (The system will offer the empty
    string (λ) as a label, but please don’t go there!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make a transition loop back to a state, just click on the state with the
    transition tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can choose the start state by selecting the arrow tool (leftmost icon),
    right-clicking on the state, and selecting “Initial”. Only one state can be the
    start state, but you can set more than one “Final” (accepting) state in the same
    way, by right-clicking on them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to change something, you can delete things with the delete tool
    (the skull icon). Alternatively, select the arrow tool and double-click on a transition
    label to edit it, or right-click on a state. You can drag states around using
    the arrow tool.
  prefs: []
  type: TYPE_NORMAL
- en: To watch your FSA process some input, use the “Input” menu (at the top), choose
    “Step with closure”, type in a short string such as “abaa”, and click “OK”. Then
    at the bottom of the window you can trace the [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) one
    character at a time by pressing “Step”, which highlights the current state as
    it steps through the string. If you step right through the [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) and
    end up in a final (accepting) state, the panel will come up green. To return to
    the Editor window, go to the “File” menu and select “Dismiss Tab”.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3cb18bf.png)'
  prefs: []
  type: TYPE_IMG
- en: You can run multiple tests in one go. From the “Input” menu choose “Multiple
    Run”, and type your tests into the table, or load them from a text file.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3bcf9cf.png)'
  prefs: []
  type: TYPE_IMG
- en: You can even do tests with the empty [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) by
    leaving a blank line in the table, which you can do by pressing the “Enter Lambda”
    button.
  prefs: []
  type: TYPE_NORMAL
- en: There are some FSA examples in the next section. If you’re doing this for a
    report, keep copies of the automata and tests that you do (JFLAP’s “File” menu
    has a “Save Image As...” option for taking snapshots of your work; alternatively
    you can save an FSA that you’ve created in a file to open later).
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.2.3\. EXAMPLES TO TRY
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using Exorciser or JFLAP, construct an FSA that takes inputs made of the letters
    “a” and “b”, and accepts the input if it meets one of the following requirements.
    You should build a separate FSA for each of these challenges.
  prefs: []
  type: TYPE_NORMAL
- en: '[*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    start with the letter “a” (e.g. “aa”, “abaaa”, and “abbbb”).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    end with the letter “a” (e.g. “aa”, “abaaa”, and “bbbba”).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    have an even number of the letter “a” (e.g. “aa”, “abaaa”, “bbbb”; and don’t forget
    the empty string ϵ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    have an odd number of the letter “a” (e.g. “a”, “baaa”, “bbbab”, but not ϵ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) where
    the number of “a”s in the input is a multiple of three (e.g. “aabaaaa”, “bababab”).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) where
    every time an a appears in the input, it is followed by a b (e.g. “abb”, “bbababbbabab”,
    “bbb”).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    end with “ab”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    start with “ab” and end with “ba”, and only have “b” in the middle (e.g. “abba”,
    “abbbbba”)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the FSA(s) that you construct, check that they accept valid input, but also
    make sure they reject invalid input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some more sequences of characters that you can construct FSAs to detect.
    The input [*alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet) is
    more than just “a” and “b”, but you don’t need to put in a transition for every
    possible character in every state, because an FSA can automatically reject an
    input if it uses a character that you haven’t given a transition for. Try doing
    two or three of these:'
  prefs: []
  type: TYPE_NORMAL
- en: the names for international standard paper sizes (A1 to A10, B1 to B10, and
    so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a valid three-letter month name (Jan, Feb, Mar, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a valid month number (1, 2, ... 12)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a valid weekday name (Monday, Tuesday, ...)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A classic example of an FSA is an old-school vending machine that only takes
    a few kinds of coins. Suppose you have a machine that only takes 5 and 10 cent
    pieces, and you need to insert 30 cents to get it to work. The [*alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet) of
    the machine is the 5 and 10 cent coin, which we call F and T for short. For example,
    TTT would be putting in 3 ten cent coins, which would be accepted. TFFT would
    also be accepted, but TFFF wouldn’t. Can you design an FSA that accepts the input
    when 30 cents or more is put into the machine? You can make up your own version
    for different denominations of coins and required total.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve worked with binary numbers, see if you can figure out what this FSA
    does. Try each binary number as input: 0, 1, 10, 11, 100, 101, 110, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3b3c22b.png)'
  prefs: []
  type: TYPE_IMG
- en: Can you work out what it means if the FSA finishes in state q1? State q2?
  prefs: []
  type: TYPE_NORMAL
- en: '12.3.3\. ACTIVITY: FIND FINITE STATE AUTOMATA IN EVERYDAY USE'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are lots of systems around that use FSAs. You could choose a system,
    explain how it can be represented with an FSA, and show examples of sequences
    of input that it deals with. Examples are:'
  prefs: []
  type: TYPE_NORMAL
- en: Board games. Simple board games are often just an FSA, where the next move is
    determined by some input (e.g. a number given by rolling dice), and the final
    state means that you have completed the game — so the first person to the final
    state wins. Most games are too complex to draw a full FSA for, but a simple game
    like snakes and ladders could be used as an example. What are some sequences of
    dice throws that will get you to the end of the game? What are some sequences
    that don’t?!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple devices with a few buttons often have states that you can identify. For
    example, a remote control for a car alarm might have two buttons, and what happens
    to the car depends on the order in which you press them and the current state
    of the car (whether it is alarmed or not). For devices that automatically turn
    on or off after a period of time, you may have to include an input such as “waited
    for 30 seconds”. Other devices to consider are digital watches (with states like
    “showing time”, “showing date”, “showing stopwatch”, “stopwatch is running”),
    the power and eject buttons on a CD player, channel selection on a TV remote (just
    the numbers), setting a clock, storing presets on a car radio, and burglar alarm
    control panels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.3.4\. ACTIVITY: KARA, THE LADYBUG'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[SwissEduc](http://www.swisseduc.ch/compscience/) has a programming environment
    called [Kara](http://www.swisseduc.ch/compscience/karatojava/kara/) (requires
    Java to be installed), which is a programmable ladybug that (in its simplest version)
    walks around an imaginary world controlled by actions output by a [*finite state
    automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton).
    The ladybug has (simulated) detectors that sense its immediate surroundings; these
    serve as input to the FSA.'
  prefs: []
  type: TYPE_NORMAL
- en: 12.4\. REGULAR EXPRESSIONS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For teachers
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions (regex for short) are closely related to FSAs, as we shall
    see. Much of the terminology that is needed was already covered in the previous
    section: we’ll be using languages, [*alphabets*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabets),
    strings, ϵ / λ, and eventually finite state automata. So the previous section
    on FSAs needs to be covered before embarking on regular expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: It may be that students have used regular expressions already, because they
    are built into many programming languages and are often used when writing script
    programs. We’ll be looking briefly at such applications — and they’re very relevant
    — but in formal languages we’re also interested in the limits of what can be represented,
    and how to convert a regex to an FSA. So there should be something here to get
    students thinking, even if they’re expert at programming with regexes.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already had a taste of regular expressions in the [*Getting started*](http://csfieldguide.org.nz/FormalLanguages.html#fl-gettingstarted) section.
    They are just a simple way to search for things in the input, or to specify what
    kind of input will be accepted as legitimate. For example, many web scripting
    programs use them to check input for patterns like dates, email addresses and
    URLs. They’ve become so popular that they’re now built into most programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: You might already have a suspicion that regular expressions are related to finite
    state automata. And you’d be right, because it turns out that every [*regular
    expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) has
    a [*finite state automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton) that
    can check for matches, and every [*finite state automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton) can
    be converted to a [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) that
    shows exactly what it does (and doesn’t) match. Regular expressions are usually
    easier for humans to read. For machines, a computer program can convert any regular
    expression to an FSA, and then the computer can follow very simple rules to check
    the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest kind of matching is just entering some text to match. Open a new
    window to the “Rubular” system (a screenshot is shown below) by clicking on the
    following challenge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Open Rubular using this link and type the text "cat" into the box labeled
    "Your regular expression"](http://rubular.com/r/vCD1OSfjAc)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3a487fd.png)'
  prefs: []
  type: TYPE_IMG
- en: If you’ve only typed the 3 characters “cat”, then it should find 6 matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try typing a dot (full stop or period) as the fourth character: “cat.”.
    In a regular expression, ”.” can match any single character. Try adding more dots
    before and after “cat”. How about “cat.s” or “cat..n”?'
  prefs: []
  type: TYPE_NORMAL
- en: What do you get if you search for ” ... ” (three dots with a space before and
    after)?
  prefs: []
  type: TYPE_NORMAL
- en: Now try searching for “ic.”. The ”.” matches any letter, but if you really wanted
    a full stop, you need to write it like this “ic.” — use this search to find “ic”
    at the end of a sentence.
  prefs: []
  type: TYPE_NORMAL
- en: Another special symbol is “\d”, which matches any digit. Try matching 2, 3 or
    4 digits in a row (for example, two digits in a row is “\d\d”).
  prefs: []
  type: TYPE_NORMAL
- en: To choose from a small set of characters, try “[ua]ff”. Either of the characters
    in the square brackets will match. Try writing a [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) that
    will match “fat”, “sat” and “mat”, but not “cat”.
  prefs: []
  type: TYPE_NORMAL
- en: A shortcut for “[mnopqrs]” is “[m-s]”; try “[m-s]at” and “[4-6]”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful shortcut is being able to match repeated letters. There are
    four common rules:'
  prefs: []
  type: TYPE_NORMAL
- en: a* matches 0 or more repetitions of a
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a+ matches 1 or more repetitions of a
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a? matches 0 or 1 occurrences of a (that is, a is optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a{5} matches “aaaaa” (that is, a repeated 5 times)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try experimenting with these. Here are some examples to try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to choose between options, the vertical bar is useful. Try the
    following, and work out what they match. You can type extra text into the test [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) area
    if you want to experiment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Notice the use of brackets to group parts of the regular expression. It’s useful
    if you want the “+” or “*” to apply to more than one character.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: The name [*Regular Expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) is
    sometimes abbreviated to “regex”, “regexp”, or “RE”. It’s “regular” because it
    can be used to define sets of strings from a very simple class of languages called
    “regular languages”, and it’s an “expression” because it is a combination of symbols
    that follow some rules.
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here for another challenge: you should try to write a short regular
    expression to match the first two words, but not the last three](http://rubular.com/r/AdmyZ5aPtD).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, regular expressions are mainly used for more serious purposes. Click
    on the following challenge to get some new text to search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Open this challenge in Rubular and try the following expressions](http://rubular.com/r/kun5ZaJqlL).'
  prefs: []
  type: TYPE_NORMAL
- en: The following [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) will
    find comon NZ number plates in the sample text, but can you find a shorter version
    using the {n} notation?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'How about an expression to find the dates in the text? Here’s one option, but
    it’s not perfect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Can you improve on it?
  prefs: []
  type: TYPE_NORMAL
- en: What about phone numbers? You’ll need to think about what variations of phone
    numbers are common! How about finding email addresses?
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ada38e70dc.png)](http://xkcd.com/208/)'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions are useful!
  prefs: []
  type: TYPE_NORMAL
- en: The particular form of [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) that
    we’ve been using is for the Ruby programming language (a popular language for
    web site development), although it’s very similar to regular expressions used
    in other languages including Java, JavaScript, PHP, Python, and Microsoft’s .NET
    Framework. Even some spreadsheets have [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) matching
    facilities.
  prefs: []
  type: TYPE_NORMAL
- en: But regular expressions have their limits — for example, you won’t be able to
    create one that can match palindromes (words and phrases that are the same backwards
    as forwards, such as “kayak”, “rotator” and “hannah”), and you can’t use one to
    detect [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    consist of *n* repeats of the letter “a” followed by *n* repeats of the letter
    “b”. We’ll look at other systems for doing that in the section on *grammars*.
    But nevertheless, regular expressions are very useful for a lot of common [*pattern
    matching*](http://csfieldguide.org.nz/appendices/Glossary.html#term-pattern-matching) requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.1\. REGULAR EXPRESSIONS AND FSAS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s a direct relationship between regular expressions and FSAs. For example,
    consider the following regex, which matches [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    begin with an even number of the letter “a” and end with an even number of the
    letter “b”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now look at how the following FSA works on these [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) —
    you could try “aabb”, “aaaabb”, “aaaaaabbbb”, and also see what happens for [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) like
    “aaabb”, “aa”, “aabbb”, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3841dfd.png)'
  prefs: []
  type: TYPE_IMG
- en: You may have noticed that q2 is a “trap state”. We can achieve the same effect
    with the following FSA, where all the transitions to the trap state have been
    removed — the FSA can reject the input as soon as a non-existent transition is
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada37a5880.png)'
  prefs: []
  type: TYPE_IMG
- en: Like an FSA, each [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) represents
    a [*language*](http://csfieldguide.org.nz/appendices/Glossary.html#term-language),
    which is just the set of all [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    match the regular expression. In the example above, the shortest[*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) in
    the language is “aabb”, then there’s “aaaabb” and “aabbbb”, and of course an infinite
    number more. There’s also an infinite number of [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that *aren’t* in
    this language, like “a”, “aaa”, “aaaaaa” and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the above example, the FSA is a really easy way to check for the [*regular
    expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) —
    you can write a very fast and small program to implement it (in fact, it’s a good
    exercise: you typically have an array or list with an entry for each state, and
    each entry tells you which state to go to next on each character, plus whether
    or not it’s a final state. At each step the program just looks up which state
    to go to next.)'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, *every* [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) can
    be converted to an FSA. We won’t look at the process here, but both Exorciser
    and JFLAP can do it for you anyway (see the activities below).
  prefs: []
  type: TYPE_NORMAL
- en: This is also built into most programming languages. Programmers usually use
    regular expressions by calling functions or methods that are passed the regex
    and the[*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) to
    be searched. But behind the scenes, the [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) is
    converted to a finite state automaton, and then the job of checking your [*regular
    expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) is
    very easy.
  prefs: []
  type: TYPE_NORMAL
- en: '12.4.2\. ACTIVITY: DESIGNING REGULAR EXPRESSIONS'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are some ideas for regular expressions for you to try to create. You can
    check them using [Rubular](http://rubular.com/) as we did earlier, but you’ll
    need to make up your own text to check. When testing your expressions, make sure
    that they not only accept correct strings, but reject ones that don’t match, even
    if there’s just one character missing.
  prefs: []
  type: TYPE_NORMAL
- en: You may find it easier to have one test match [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) per
    line in “Your test string”. You can force your [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) to
    match a whole line by putting “^” (start of line) before the regular expression,
    and “$” (end of line) after it. For example, “^a+$” only matches lines that have
    nothing but “a”s on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some challenges to try to create regular expressions for:'
  prefs: []
  type: TYPE_NORMAL
- en: local forms of non-personalised number plates (e.g. AB1234 or ABC123 in New
    Zealand)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: any extended form of the word “hello”, e.g. “helloooooooooooo”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: variants of “aaaarrrrrgggggghhhh”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a 24-hour clock time (e.g. 23:00) or a 12-hour time (e.g. 11:55 pm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a bank account or credit card number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a credit card expiry date (must have 4 digits e.g 01/15)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a password that must contain at least 2 digits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a phone number (choose your format e.g. mobile only, national numbers, or international)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a dollar amount typed into a banking website, which should accept various formats
    like “$21.43”, “$21”, “21.43”, and “$5,000”, but not “21$”, “21.5”, “5,0000.00”,
    and “300$”.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: acceptable identifiers in your programming language (usually something like
    a letter followed by a combination of letters, digits and some punctuation symbols)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an integer in your programming language (allow for + and - at the front, and
    some languages allow suffixes like L, or prefixes like 0x)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an IP address (e.g. 172.16.5.2 or 172.168.10.10:8080)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a MAC address for a device (e.g. e1:ce:8f:2a:0a:ba)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'postal codes for several countries e.g. NZ: 8041, Canada: T2N 1N4, US: 90210'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a (limited) http URL, such as “[http://abc.xyz](http://abc.xyz/)”, “[http://abc.xyz#conclusion](http://abc.xyz/#conclusion)”,
    “[http://abc.xyz?search=fgh](http://abc.xyz/?search=fgh)”.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.4.3\. PROJECT: CONVERTING REGULAR EXPRESSIONS TO FSAS'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this project you will make up a regular expression, convert it to an FSA,
    and demonstrate how some [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) are
    processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one trick you’ll need to know: the software we’re using doesn’t have
    all the notations we’ve been using above, which are common in programming languages,
    but not used so much in pure formal language theory. In fact, the only ones available
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: a* matches 0 or more repetitions of a
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a|b matches a or b
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (aa|bb)* Parentheses group commands together; in this case it gives a mixture
    of pairs of “a”s and pairs of “b”s.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having only these three notations isn’t too much of a problem, as you can get
    all the other notations using them. For example, “a+” is the same as “aa*”, and
    “\d” is “0|1|2|3|4|5|67|8|9”. It’s a bit more tedious, but we’ll mainly use exercises
    that only use a few characters.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.3.1\. CONVERTING WITH EXORCISER
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use this section if you’re using Exorciser; if you’re using JFLAP then skip
    to [`](http://csfieldguide.org.nz/FormalLanguages.html#id8)Converting with JFLAP`~.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exorciser is very simple. In fact, unless you change the default settings,
    it can only convert regular expressions using two characters: “a” and “b”. But
    even that’s enough (in fact, in theory any input can be represented with two characters
    — that’s what binary numbers are about!)'
  prefs: []
  type: TYPE_NORMAL
- en: On the plus side, Exorciser has the empty [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) symbol
    available — if you type “e” it will be converted to ϵ. So, for example, “(a| ϵ)”
    means an optional “a” in the input.
  prefs: []
  type: TYPE_NORMAL
- en: To do this project using Exorciser, go to the start (“home”) window, and select
    the second link, “Regular Expression to Finite Automata Conversion”. Now type
    your[*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) into
    the text entry box that starts with “R =”.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a warmup, try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: then click on “solve exercise” (this is a shortcut — the software is intended
    for students to create their own FSA, but that’s beyond what we’re doing in this
    chapter).
  prefs: []
  type: TYPE_NORMAL
- en: You should get a very simple FSA!
  prefs: []
  type: TYPE_NORMAL
- en: To test your FSA, right-click on the background and choose “Track input”.
  prefs: []
  type: TYPE_NORMAL
- en: Now try some more complex regular expressions, such as the following. For each
    one, type it in, click on “solve exercise”, and then track some sample inputs
    to see how it accepts and rejects different strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Your project report should show the regular expressions, explain what kind of [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) they
    match, show the corresponding FSAs, show the sequence of states that some sample
    test [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) would
    go through, and you should explain how the components of the FSA correspond the
    parts of the [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) using
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.3.2\. CONVERTING WITH JFLAP
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re using [JFLAP](http://www.jflap.org/) for your project, you can have
    almost any character as input. The main exceptions are “*”, “+” (confusingly,
    the “+” is used instead of “|” for alternatives), and ”!” (which is the empty [*string*]([http://csfieldguide.org.nz/appendices/Glossary.html#term-string](http://csfieldguide.org.nz/appendices/Glossary.html#term-string)) —
    in the preferences you can choose if it is shown as λ or ϵ).
  prefs: []
  type: TYPE_NORMAL
- en: 'So the main operators available in JFLAP are:'
  prefs: []
  type: TYPE_NORMAL
- en: a* matches 0 or more repetitions of a
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a+b matches a or b
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (aa+bb)* Parentheses group commands together; in this case it gives a mixture
    of pairs of “a”s and pairs of “b”s.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JFLAP software can work with all sorts of formal languages, so you’ll need
    to ignore a lot of the options that it offers! This section will guide you through
    exactly what to do.
  prefs: []
  type: TYPE_NORMAL
- en: There are some details about the format that JFLAP uses for regular expressions
    in the following tutorial — just read the “Definition” and “Creating a regular
    expression” sections.
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.jflap.org/tutorial/regular/index.html](http://www.jflap.org/tutorial/regular/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a warmup, we’ll convert this regex to an FSA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'On the main control window of JFLAP click on “Regular Expression”, and type
    your [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) into
    JFLAP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3713b5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the “Convert” menu choose “Convert to NFA”. This will only start the conversion;
    press the “Do all” button to complete it (the system is designed to show all the
    steps of the conversion, but we just want the final result). For the example,
    we get the following non-deterministic finite automaton (NFA), which isn’t quite
    what we want and probably looks rather messy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada364e398.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need a DFA (deterministic FA), not an NFA. To convert the NFA to a DFA,
    press the “Export” button, then from the “Convert” menu, choose “Convert to DFA”,
    press the “Complete” button to complete the conversion, and then the “Done?” button,
    which will put it in a new window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada35ade1e.png)'
  prefs: []
  type: TYPE_IMG
- en: We’re nearly there. If it’s hard to read the FSA, you can move states around
    by choosing the arrow tool (on the left of the tool bar — if the states won’t
    move when you grab them, so make sure you click on the arrow icon before trying
    to move them). The states may have some extraneous labels underneath them; you
    can hide those by selecting the arrow tool, right-click on the white part of the
    window and un-check “Display State Labels”.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3538e8b.png)'
  prefs: []
  type: TYPE_IMG
- en: If the FSA is simple enough, it may be just as easy if you now copy the diagram
    by hand and try to set it out tidily yourself, otherwise you can save it as an
    image to put into your project.
  prefs: []
  type: TYPE_NORMAL
- en: Now try some sample inputs. The starting state is labeled q0 and will have a
    large arrow pointing at it. You can get JFLAP to run through some input for you
    by using the “Input” menu. “Step by state” will follow your input state by state,
    “Fast run” will show the sequence of states visited for your input, and “Multiple
    run” allows you to load a list of [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) to
    test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple runs are good for showing lots of tests on your regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3483649.png)'
  prefs: []
  type: TYPE_IMG
- en: For example, “ab” is rejected because it would only get to state 2.
  prefs: []
  type: TYPE_NORMAL
- en: Now you should come up with your own regular expressions that test out interesting
    patterns, and generate FSA’s for them. In JFLAP you can create FSAs for some of
    regular expressions we used earlier, such as (simple) dates, email addresses or
    URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Your project report should show the regular expressions, explain what kind of [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) they
    match, show the corresponding FSAs, show the sequence of states that some sample
    test [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) would
    go through, and you should explain how the components of the FSA correspond to
    the parts of the [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) using
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.4\. OTHER IDEAS FOR PROJECTS AND ACTIVITIES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some more ideas that you could use to investigate regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the [regexdict site](http://www.visca.com/regexdict/), read the instructions
    on the kinds of [*pattern matching*](http://csfieldguide.org.nz/appendices/Glossary.html#term-pattern-matching) it
    can do, and write regular expressions for finding words such as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: words that contain “aa”
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: all words with 3 letters
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: all words with 8 letters
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: all words with more than 8 letters
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: words that include the letters of your name
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: words that are made up *only* of the letters in your name
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: words that contain all the vowels in reverse order
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: words that you can make using only the notes on a piano (i.e the letters A to
    G and a to g)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: words that are exceptions to the rule “i before e except after c” — make sure
    you find words like “forfeit” as well as “science”.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Word’s *Find* command uses regular expressions if you select the “Use
    wildcards” option. For more details see [Graham Mayor](http://word.mvps.org/AboutMVPs/graham_mayor.htm)‘s [Finding
    and Replacing Characters using Wildcards](http://word.mvps.org/FAQs/General/UsingWildcards.htm).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore regular expressions in spreadsheets. The Google docs spreadsheet has
    a function called RegExMatch, RegExExtract and RegExReplace. In Excel they are
    available via Visual Basic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knitting patterns are a form of regular expression. If you’re interested in
    knitting, you could look into how they are related through the [article about
    knitting and regular expressions at CS4FN site](http://www.cs4fn.org/regularexpressions/knitters.php).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chesapeake NetCraftsmen site provides [a system for practising writing regular
    expressions](http://www.netcraftsmen.net/presos/Regex_Practice/player.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “grep” command is available in many command line systems, and matches a [*regular
    expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) in
    the command with lines in an input file. (the name comes from “Global Regular
    Expression Parser”). Demonstrate the grep command for various regular expressions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions for matching against regular expressions appear in most programming
    languages. If your favourite language has this feature, you could demonstrate
    how it works using sample regular expressions and strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advanced: The free tools *lex* and *flex* are able to take specifications for
    regular expressions and create programs that parse input according to the rules.
    They are commonly used as a front end to a compiler, and the input is a program
    that is being compiled. You could investigate these tools and demonstrate a simple
    implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.5\. GRAMMARS AND PARSING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: this section hasn’t been written yet; the material below is just an introduction
  prefs: []
  type: TYPE_NORMAL
- en: With unusual [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) Yoda
    from Star Wars speaks. Yet still understand him, people can. The flexibility of
    the rules of English [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) mean
    that you can usually be understood if you don’t get it quite right, but it also
    means that the rules get very complicated and difficult to apply.
  prefs: []
  type: TYPE_NORMAL
- en: Grammars in formal languages are much more predictable than grammars in human
    languages — that’s why they’re called formal languages! When you’re doing English, [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) can
    be a tricky topic because not only are there are so many rules, but there are
    also so many exceptions — for example, you need an apostrophe if you write “the
    computer’s USB port”, but you have to leave it out if you say “its USB port”.
    Grammars in computer science are mainly used to specify programming languages
    and file formats, and compilers make a fuss even if you leave out just one bracket
    or comma! But at least they’re predictable.
  prefs: []
  type: TYPE_NORMAL
- en: In this section we’ll look at the kind of grammars that are widely used in computer
    science. They are very powerful because they allow a complicated system (like
    a compiler or a format like HTML) to be specified in a very concise way, and there
    are programs that will automatically take the [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) and
    build the system for you. The grammars for conventional programming languages
    are a bit too unwieldy to use as initial examples (they usually take a few pages
    to write out), so we’re going to work with some small examples here, including
    parts of the grammars for programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: the remainder of this section will be developed during 2013.'
  prefs: []
  type: TYPE_NORMAL
- en: 12.5.1\. PROJECT IDEAS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (Note that these will make more sense when the previous introduction to grammars
    has been completed!)
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrate how compilers, interpreters, parsers or validators find errors in
    formal languages e.g. introduce an error to a compiled program, XML document file
    or web page, and show the effect of the error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) for
    a programming language, and show how a sample program would be parsed using the
    grammar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use examples to show the [*parse tree*](http://csfieldguide.org.nz/appendices/Glossary.html#term-parse-tree) (or [*syntax*](http://csfieldguide.org.nz/appendices/Glossary.html#term-syntax) tree)
    for a correct and incorrect program fragment, or to show a sequence of [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) productions
    to construct a correct program fragment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore the [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) for
    balanced parentheses S -> SS, S -> (S), S -> ( )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) for
    a simple arithmetic expression in a programming language, and show the [*parse
    tree*](http://csfieldguide.org.nz/appendices/Glossary.html#term-parse-tree) for
    sample expressions (such as (a+b)*(c-d) ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.5.2\. PROJECTS: GRAMMARS IN ART AND MUSIC'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](563ada33db744.png)'
  prefs: []
  type: TYPE_IMG
- en: The *context free art* program ( [http://www.contextfreeart.org/](http://www.contextfreeart.org/) )
    enables you to specify images using a context-free grammar. For example, the following
    pictures of trees are defined by just a few rules that are based around a forest
    being made of trees, a tree being made of branches, and the branches in turn being
    made of branches themselves! These simple definitions can create images with huge
    amounts of detail because the drawing process can break down the [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) into
    as many levels as required. You can define your own grammars to generate images,
    and even make a movie of them being created, like the one below. Of course, if
    you do this as a project make sure you understand how the system works and can
    explain the formal language behind your creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JFLAP program that we have been using also has a feature for rendering
    “L-systems” ([http://en.wikipedia.org/wiki/L-system](http://en.wikipedia.org/wiki/L-system)),
    which are another way to use grammars to create structured images. You’ll need
    to read about how they work in the JFLAP tutorial (www.jflap.org/tutorial/index.html),
    and there’s a more detailed tutorial at [http://www.cs.duke.edu/csed/pltl/exercises/lessons/20/L-system.zip](http://www.cs.duke.edu/csed/pltl/exercises/lessons/20/L-system.zip).
    There are some sample files here to get you inspired: (the ones starting “ex10...”
    www.cs.duke.edu/csed/jflap/jflapbook/files/ ) and here’s an example of the kind
    of image that can be produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada31b0e86.png)'
  prefs: []
  type: TYPE_IMG
- en: A tree drawn using L-systems in JFLAP
  prefs: []
  type: TYPE_NORMAL
- en: There’s also an online system for generating images with L-systems: [http://www.kevs3d.co.uk/dev/lsystems/](http://www.kevs3d.co.uk/dev/lsystems/)
  prefs: []
  type: TYPE_NORMAL
- en: 'Grammars have been used for music notation:'
  prefs: []
  type: TYPE_NORMAL
- en: The following is the BNF [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) for
    the ABC music format: [http://www.norbeck.nu/abc/bnf/abc20bnf.htm](http://www.norbeck.nu/abc/bnf/abc20bnf.htm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://abc.sourceforge.net/](http://abc.sourceforge.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://meta.wikimedia.org/wiki/Music_markup](https://meta.wikimedia.org/wiki/Music_markup)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.emergentmusics.org/theory/15-implementation](http://www.emergentmusics.org/theory/15-implementation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: analyse a simple piece of music in terms of a formal grammar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.6\. THE WHOLE STORY!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you found the material in this chapter interesting, here are some topics
    that you might want to look into further, as we’ve only just scratched the surface
    of what can be done with formal languages.
  prefs: []
  type: TYPE_NORMAL
- en: Formal languages come up in various areas of computer science, and provide invaluable
    tools for the computer scientist to reduce incredibly complex systems to a small
    description, and conversely to create very complex systems from a few simple rules.
    They are essential for writing compilers, and so are activated every time someone
    writes a program! They are also associated with automata theory and questions
    relating to computability, and are used to some extent in natural language processing,
    where computers try to make sense of human languages.
  prefs: []
  type: TYPE_NORMAL
- en: Technically the kind of finite state automata (FSA) that we used in [Finite
    state automata](http://csfieldguide.org.nz/FormalLanguages.html#finite-state-automata) section
    is a kind known as a *Deterministic Finite Automata* (DFA), because the decision
    about which transition to take is unambiguous at each step. Sometimes it’s referred
    to as a *Finite State Acceptor* because it accepts and rejects input depending
    on whether it gets to the final state. There are all sorts of variants that we
    didn’t mention, including the Mealy and Moore machines (which produce an output
    for each each transition taken or state reached), the nested state machine (where
    each state can be an FSA itself), the non-deterministic finite automata (which
    can have the same label on more than one transition out of a state), and the lambda-NFA
    (which can include transitions on the empty string, λ). Believe it or not, all
    these variations are essentially equivalent, and you can convert from one to the
    other. They are used in a wide range of practical situations to design systems
    for processing input.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are also more complex models of computation such as the push-down
    automaton (PDA) which is able to follow the rules of context-free grammars, and
    the most general model of computation which is called a Turing machine. These
    models are increasingly complicated and abstract, and structures like the Turing
    machine aren’t used as physical devices (except for fun), but as a tool for reasoning
    about the limits on what can be computed.
  prefs: []
  type: TYPE_NORMAL
- en: The Turing machine is named after Alan Turing, who worked on these concepts
    in the early 20th century (that’s the same person from whom we got the Turing
    test in AI, which is something quite different — Turing’s work comes up in many
    areas of computer science!) If you want to investigate the idea of a Turing machine
    and you like chocolate, there’s [an activity on the cs4fn site](http://www.cs4fn.org/turing/turingmachines.php) that
    gives examples of how it works. The Kara programming environment also has a [demonstration
    of Turing machines](http://www.swisseduc.ch/compscience/karatojava/turingkara/)
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter looked at two main kinds of formal language: the [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) (RE)
    and the context-free [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) (CFG).
    These typify the kinds of languages that are widely used in compilers and file
    processing systems. Regular expressions are good for finding simple patterns in
    a file, like identifiers, keywords and numbers in a program, or tags in an HTML
    file, or dates and URLs in a web form. Context-free grammars are good when you
    have nested structures, for example, when an expression is made up of other expressions,
    or when an “if” statement includes a block of statements, which in turn could
    be “if” statements, ad infinitum. There are more powerful forms of grammars that
    exist, the most common being context-sensitive grammars and unrestricted grammars,
    which allow you to have more than one non-terminal on the left hand side of a
    production; for example, you could have xAy → aBb, which is more flexible but
    a lot harder to work with. The relationships between the main kinds of grammars
    was described by the linguist Noam Chomsky, and is often called the [*Chomsky
    Hierarchy*](http://csfieldguide.org.nz/appendices/Glossary.html#term-chomsky-hierarchy) after
    him.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a direct correspondence between the “machines” (such as the FSA) and
    languages (such as the Regular Expression), as each increasingly complex language
    needs the correspondingly complex machine to process it. For example, an FSA can
    be used to determine if the input matches a given Regular Expression, but a PDA
    is needed to match a [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) to
    a CFG. The study of formal languages looks at these relationships, and comes up
    with ways to create the appropriate machines for a given language and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: There are many tools available that will read in the specification for a language
    and produce another program to parse the language; some common ones are called
    “Lex” and “Flex” (both perform lexical anaylsis of regular expressions), “Yacc”
    (“yet another compiler compiler”) and “Bison” (an improved version of Yacc). These
    systems make it relatively easy to make up your own programming language and construct
    a compiler for it, although they do demand quite a range of skills to get the
    whole thing working!
  prefs: []
  type: TYPE_NORMAL
- en: So we’ve barely got started on what can be done with formal languages, but the
    intention of this chapter is to give you a taste of the kind of structures that
    computer scientists work with, and the powerful tools that have been created to
    make it possible to work with infinitely complex systems using small descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 12.7\. GLOSSARY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s a list of the main terms and concepts that come up in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet)'
  prefs: []
  type: TYPE_NORMAL
- en: '[*String*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string)'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Finite state automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton)'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression)'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Pattern matching*](http://csfieldguide.org.nz/appendices/Glossary.html#term-pattern-matching)'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Lexical analysis*](http://csfieldguide.org.nz/appendices/Glossary.html#term-lexical-analysis)'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar)'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Parsing*](http://csfieldguide.org.nz/appendices/Glossary.html#term-parsing)'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Parse tree*](http://csfieldguide.org.nz/appendices/Glossary.html#term-parse-tree)'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Syntax*](http://csfieldguide.org.nz/appendices/Glossary.html#term-syntax)'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Syntax diagram*](http://csfieldguide.org.nz/appendices/Glossary.html#term-syntax-diagram)'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Syntactically correct*](http://csfieldguide.org.nz/appendices/Glossary.html#term-syntactically-correct)'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chomsky hierarchy*](http://csfieldguide.org.nz/appendices/Glossary.html#term-chomsky-hierarchy)'
  prefs: []
  type: TYPE_NORMAL
- en: 12.8\. FURTHER READING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the material in this chapter was inspired by [http://www.ccs3.lanl.gov/mega-math/workbk/machine/malearn.html](http://www.ccs3.lanl.gov/mega-math/workbk/machine/malearn.html)
  prefs: []
  type: TYPE_NORMAL
- en: There’s a good article on finite state machines at [http://www.i-programmer.info/babbages-bag/223-finite-state-machines.html](http://www.i-programmer.info/babbages-bag/223-finite-state-machines.html)
  prefs: []
  type: TYPE_NORMAL
- en: Textbooks on formal languages will have considerably more advanced material
    and more mathematical rigour than could be expected at High School level, but
    for students who really want to read more, a popular book is “Introduction to
    the Theory of Computation” by Michael Sipser.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions and their relationship with FSAs is explained well in the
    book “Algorithms” by Robert Sedgewick.
  prefs: []
  type: TYPE_NORMAL
- en: 12.8.1\. USEFUL LINKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Formal_language](http://en.wikipedia.org/wiki/Formal_language)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Context-free_grammar#Examples](http://en.wikipedia.org/wiki/Context-free_grammar#Examples)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Abstract_syntax_tree](http://en.wikipedia.org/wiki/Abstract_syntax_tree)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Regular_expression](http://en.wikipedia.org/wiki/Regular_expression)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://csunplugged.org/finite-state-automata](http://csunplugged.org/finite-state-automata)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.i-programmer.info/babbages-bag/223-finite-state-machines.html](http://www.i-programmer.info/babbages-bag/223-finite-state-machines.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.jflap.org/](http://www.jflap.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Deterministic_finite_automaton](http://en.wikipedia.org/wiki/Deterministic_finite_automaton)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Finite-state_machine](http://en.wikipedia.org/wiki/Finite-state_machine)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13\. COMPUTER GRAPHICS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 13.1\. WHAT’S THE BIG PICTURE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computer graphics will be familiar from games, films and images, and there is
    amazing software available to create images, but how does the software work? The
    role of a computer scientist is not just to *use* graphics systems, but to *create* them,
    and especially invent new techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The entertainment industry is always trying to develop new graphics software
    so that they can push the boundaries and create new experiences. We’ve seen this
    in the evolution of animated films, from simple 2D films to realistic computer
    generated movies with detailed 3D images.
  prefs: []
  type: TYPE_NORMAL
- en: Movie and gaming companies can’t always just use existing software to make the
    next great thing — they need computer scientists to come up with better graphics
    techniques to make something that’s never been seen before. The creative possibilities
    are endless!
  prefs: []
  type: TYPE_NORMAL
- en: 'Computer graphics are used in a wide variety of situations: games and animated
    movies are common examples, but graphics techniques are also used to visualise
    large amounts of data (such as all cellphone calls being made in one day), to
    display and animate graphical user interfaces, to create virtual reality and augmented
    reality worlds, and much more.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll look at some of the basic techniques that are used to
    create computer graphics. These will give you an idea of the techniques that are
    used in graphics programming, although it’s just the beginning of what’s possible.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter we are using a system called WebGL which can render 3D graphics
    in your browser. If your browser is set up correctly then you should see a teapot
    on the right, and you can click the “animate” button to make it rotate. If this
    doesn’t work, or if the performance is poor, there is [information here about
    how to get it going](http://csfieldguide.org.nz/appendices/Interactives.html) .
  prefs: []
  type: TYPE_NORMAL
- en: 13.2\. GRAPHICS TRANSFORMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A computer graphics image is just the result of a whole lot of mathematical
    calculations. In fact, every pixel you see in an image has typically had many
    calculations made to work out what colour it should be, and there are often millions
    of pixels in a typical image.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with some simple but common calculations that are needed for in
    graphics programming. The following image shows a cube with writing on each face.
    You can move it around using what’s called a *transform*, which simply adjusts
    where it is placed in space.
  prefs: []
  type: TYPE_NORMAL
- en: In this example the only transforms we've supplied are to *translate* it in
    three dimensions. The dimensions are *x* (left and right), *y* (up and down) and *z* (in
    and out of the screen). Your goal is to type in how far it should be transformed
    in each of these directions so that you can see the symbol on each face, and put
    those symbols on the spinner wheels shown. (The order of the symbols doesn't matter).
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb44b57c0.png)Click to load the widget](http://csfieldguide.org.nz/ComputerGraphics.html)'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve just applied 3D *translation transforms* to the cube. Translation just
    means moving it in the three dimensions up and down, forward and back, and sideways.
  prefs: []
  type: TYPE_NORMAL
- en: Another common transform is *rotation*, which you can use in the following image
    to find the symbols (the rotation is measured in degrees).
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb432ff18.png)Click to load the widget](http://csfieldguide.org.nz/ComputerGraphics.html)'
  prefs: []
  type: TYPE_NORMAL
- en: There are several transformations that are used in computer graphics, but the
    most common ones are translation (moving the object), rotation (spinning it) and
    scaling (changing its size). They come up often in graphics because they are applied
    not only to objects, but to things like the positions of the camera and lighting
    sources.
  prefs: []
  type: TYPE_NORMAL
- en: In this section you can apply transformations to various images. We’ll start
    by making the changes manually, one point at a time, but we’ll move up to a quick
    shortcut method that uses a *matrix* to do the work for you. We’ll start by looking
    at how these work in two dimensions - it’s a bit easier to think about than three
    dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: The following interactive shows an arrow, and on the right you can see a list
    of the points that correspond to its 7 corners. The arrow is on a grid (usually
    referred to as *cartesian coordinates* ), where the centre point is the “zero”
    point. Points are specified using two numbers, *x* and *y*, usually written as
    (*x*,*y*). The *x* value is how far the point is to the right of the centre and
    the *y* value is how far above the centre it is. For example, the first point
    in the list is the tip at (0,2), which means it’s 0 units to the right of the
    centre (i.e. at the centre), and 2 units above it. Which point does the last pair
    (2,0) correspond to? What does it mean if a coordinate has a negative*x* value?
  prefs: []
  type: TYPE_NORMAL
- en: The first list of coordinates is for the original arrow position, and in the
    second list, you can type in the transformed points to move the arrow — the original
    is shown in green and the moved one is in blue.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb42a8311.png)Click to load the widget](http://csfieldguide.org.nz/ComputerGraphics.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Your first challenge is to add 2 to all the *x* points, and 3 to all the *y* points
    (you can either type the new number or put the calculation in the box e.g. "0.5+2".
    What effect does this have on the original arrow? (Be careful to add the negative
    numbers correctly; for example, adding 2 to -0.5 gives 1.5.) What happens if you
    subtract 3 from each of the original coordinate values?
  prefs: []
  type: TYPE_NORMAL
- en: The above transform is called a *translation* — it translates the arrow around
    the grid. This kind of transform is used in graphics to specify where an object
    should be placed in a scene, but it has many other uses, such as making an animated
    object move along a path, or specifying the position of the imaginary camera (viewpoint).
  prefs: []
  type: TYPE_NORMAL
- en: In this next interactive, try replacing the coordinates in the second list with
    all the original values multiplied by 2\. What is the effect of this transform?
    What would happen if you multiply each value by 10? How about 0.5? What if you
    only multiply the *x* values?
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb421efcc.png)Click to load the widget](http://csfieldguide.org.nz/ComputerGraphics.html)'
  prefs: []
  type: TYPE_NORMAL
- en: This transformation is called *scaling*, and although it can obviously be used
    to control the size of an object, this can in turn be used to create a visual
    effect such as making the object appear closer or further away.
  prefs: []
  type: TYPE_NORMAL
- en: Try to get the blue arrow to match up with the red one. It will require a mixture
    of scaling and translation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb419514b.png)Click to load the widget](http://csfieldguide.org.nz/ComputerGraphics.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, see what happens if you swap the *x* and *y* value for each coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb4128f87.png)Click to load the widget](http://csfieldguide.org.nz/ComputerGraphics.html)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple *rotation* transformation, also useful for positioning objects
    in a scene, but also for specifying things like camera angles.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.1\. MATRIX TRANSFORMS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s a much easier way to specify transformations than having to change
    each coordinate separately. Transformations are usually done in graphics using *matrix*arithmetic,
    which is a shorthand notation for doing lots of simple arithmetic operations in
    one go. The matrix for the two-dimensional transformations we’ve been doing above
    has four values in it. For the 2 dimensional scaling transform where we made each *x* and *y* value
    twice as large, the matrix is written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[2002]'
  prefs: []
  type: TYPE_NORMAL
- en: You can type this matrix into the following interactive to see what it does
    (replace the ones with twos). The top left-hand value just means multiply all
    the *x* values by 2, and the bottom right one means multiply all the *y* values
    by 2\. For the meantime, leave the other two values as 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb40998c1.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  prefs: []
  type: TYPE_NORMAL
- en: (At this stage you may want to have the widget open in a separate window so
    that you can read the text below and interact with the widget at the same time.)
  prefs: []
  type: TYPE_NORMAL
- en: Now try changing the matrix to
  prefs: []
  type: TYPE_NORMAL
- en: '[3003]'
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[0.2000.2]'
  prefs: []
  type: TYPE_NORMAL
- en: The “add translate” values in the interactive are added to each *x* and *y* coordinate;
    experiment with them to see what they do. Now try to find suitable values for
    these and the matrix to match the arrow up with the red one.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if you use the following matrix?
  prefs: []
  type: TYPE_NORMAL
- en: '[2004]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try the following matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[0110]'
  prefs: []
  type: TYPE_NORMAL
- en: This matrix should have rotated the arrow to the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple way of looking at the matrix is that the top row determines the transformed *x* value,
    simply by saying how much of the original *x* value and *y* value contribute to
    the new *x* value. So in the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[2004]'
  prefs: []
  type: TYPE_NORMAL
- en: 'the top row just means that the new *x* value is 2 lots of the original *x*,
    and none of the original y, which is why all the *x* values double. The second
    row determines the *y*value: in the above example, it means that the new *y* value
    uses none of the original x, but 4 times the original *y* value. If you try this
    matrix, you should find that the location of all the *x* points is doubled, and
    the location of all the y points is multiplied by 4.'
  prefs: []
  type: TYPE_NORMAL
- en: That now explains the [0110] matrix. The new *x* value has none of the original *x*,
    but exactly the original *y* value, and vice versa. This swaps all the *x* and *y*coordinates,
    which is the same as rotating the object to the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where it gets interesting is when you use a little of each value; try the following
    matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[0.7−0.70.70.7]'
  prefs: []
  type: TYPE_NORMAL
- en: Now the *x* value of each coordinate is a mixture of 0.7 of the original *x*,
    and 0.7 of the original *y*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, to rotate an image by a given angle you need to use the sine (abbreviated
    sin) and cosine (abbreviated cos) functions from trigonometry. To rotate the image
    by Θ degrees, you’ll need the following values in the matrix, which rely on trig
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[cos(θ)sin(θ)−sin(θ)cos(θ)]'
  prefs: []
  type: TYPE_NORMAL
- en: You can type these calculations directly into the interactive - if you type
    cos(60) it will work out the cosine of 60 degrees for you, which happens to be
    exactly 0.5\. Or you can just type in the sin and cosine values; the 0.7 numbers
    in the matrix above are just the values for sin(45) and so on (or at least, they
    approximately the value; it's actually 0.70710678..., which happens to be the
    square root of 0.5, but 0.7 is close enough for our example).
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb4007956.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  prefs: []
  type: TYPE_NORMAL
- en: What is the matrix for rotation by 360 degrees?
  prefs: []
  type: TYPE_NORMAL
- en: 'The general matrix for *scaling* is a bit simpler; if you want to scale by
    a factor of *s*, then you just use the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[s00s]'
  prefs: []
  type: TYPE_NORMAL
- en: A translation can’t be specified by this kind of matrix, but in the interactives
    we’ve provided an extra place to specify an *x* and *y* value to translate the
    input.
  prefs: []
  type: TYPE_NORMAL
- en: Try translating the original arrow so that it matches up with the red arrow.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3f4b0d7.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  prefs: []
  type: TYPE_NORMAL
- en: Now try to scale the original arrow in the following, and translate it to match
    the red arrow.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3e7a0c1.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  prefs: []
  type: TYPE_NORMAL
- en: The following interactive has the translation and scaling the other way around.
    Use this one to transform the blue arrow to the red arrow. The order in which
    the operations happen makes a difference!
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3dc5719.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  prefs: []
  type: TYPE_NORMAL
- en: In the above, you’ll have noticed that scaling is affected by how far the object
    is from the centre. If you want to scale around a fixed point in the object (so
    it expands where it is), then an easy way is to translate it back to the centre
    (also called the *origin*), scale it, and then translate it back to where it was.
    The following interactive allows you to move the arrow, then scale it, and move
    it back.
  prefs: []
  type: TYPE_NORMAL
- en: The tip is at (-8,7), so you should translate it to (0,0), scale by 2, and translate
    back to (-8, 7).
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3d00240.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  prefs: []
  type: TYPE_NORMAL
- en: The same problem comes up with rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Try rotating this image by 45 degrees.You'll need to translate the tip to the
    origin, apply the rotation, and translate it back.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3c67015.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  prefs: []
  type: TYPE_NORMAL
- en: The following two examples combine rotation, scaling and translation. You can
    use multiple matrices (that’s the plural of matrix) to match up the target object
    — the product of each matrix becomes the input to the next one. Oh, and the arrow
    is twice as fat, but still the same hight (from base to tip).
  prefs: []
  type: TYPE_NORMAL
- en: Try matching the blue arrow to the red one using two matrices (one to scale
    and one to rotate), and adding a vector.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3bd2e49.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  prefs: []
  type: TYPE_NORMAL
- en: You will need to use all three operations to do this next one.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3b4780a.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  prefs: []
  type: TYPE_NORMAL
- en: These combined transformations are common, and they might seem like a lot of
    work because each matrix has to be applied to every point in an object. Our arrows
    only had 7 points, but complex images can have thousands or even millions of points
    in them. Fortunately we can combine all the matrix operations in advance to give
    just one operation to apply to each point.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.2\. COMBINING TRANSFORMATIONS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Several transforms being applied to the same image can be made more efficient
    by creating one matrix that has the effect of all the transforms combined.The
    combination is done by “multiplying” all the matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplying two matrices can’t be done by just multiplying the corresponding
    elements; if you are multiplying two matrices with the *a* and *b* values shown
    below, the resulting values from the multiplication are calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[a11a12a21a22]'
  prefs: []
  type: TYPE_NORMAL
- en: \times
  prefs: []
  type: TYPE_NORMAL
- en: '[b11b12b21b22]'
  prefs: []
  type: TYPE_NORMAL
- en: '='
  prefs: []
  type: TYPE_NORMAL
- en: '[a11b11+a21b12a12b11+a22b12a11b21+a21b22a12b21+a22b22]'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a bit complicated, but this calculation is only done once to work out the
    combined transformation, and it gives you a single matrix that will provide to
    transforms in one operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a simple example, consider what happens when you scale by 2 and then rotate
    by 45 degrees. The two matrices to multiply work out like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[2002]'
  prefs: []
  type: TYPE_NORMAL
- en: \times
  prefs: []
  type: TYPE_NORMAL
- en: '[0.7−0.70.70.7]'
  prefs: []
  type: TYPE_NORMAL
- en: '='
  prefs: []
  type: TYPE_NORMAL
- en: '[2×0.7+0×−0.70×0.7+2×−0.72×0.7+0×0.70×0.7+2×0.7]'
  prefs: []
  type: TYPE_NORMAL
- en: '='
  prefs: []
  type: TYPE_NORMAL
- en: '[1.4−1.41.41.4]'
  prefs: []
  type: TYPE_NORMAL
- en: Try putting in the final matrix here and see if it does scale by 2 and rotate
    by 45 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3ab20ff.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  prefs: []
  type: TYPE_NORMAL
- en: Now try multiplying two other transform matrices that you make up yourself,
    and see if they produce the expected result.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3a39d3a.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  prefs: []
  type: TYPE_NORMAL
- en: In computer graphics systems there can be many transformations combined, and
    this is done by multiplying them all together (two at a time) to produce one matrix
    that does all the transforms in one go. That transform might then be applied to
    millions of points, so the time taken to do the matrix multiplication at the start
    will pay off well.
  prefs: []
  type: TYPE_NORMAL
- en: The project below gives the chance to explore combining matrices, and has an
    interactive that will calculate the multiplied matrices for you.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.3\. 3D TRANSFORMS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far we’ve just done the transforms in two dimensions. To do this in 3D, we
    need a *z* coordinate as well, which is the depth of the object into the screen.
    A matrix for operating on 3D points is 3 by 3\. For example, the 3D matrix for
    doubling the size of an object is as follows; it multiplies each of the *x*, *y* and *z* values
    of a point by 2.
  prefs: []
  type: TYPE_NORMAL
- en: ⎡⎣⎢200020002⎤⎦⎥
  prefs: []
  type: TYPE_NORMAL
- en: In this interactive, try changing the scaling on the image (it starts with a
    scaling factor of 10 in all three dimensions).
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3866882.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  prefs: []
  type: TYPE_NORMAL
- en: The above image mesh has 3644 points in it, and your matrix was applied to each
    one of them to work out the new image.
  prefs: []
  type: TYPE_NORMAL
- en: Translation requires 3 values, which are added to the *x*, *y* and *z* coordinates
    of each point in an object.
  prefs: []
  type: TYPE_NORMAL
- en: In the following interactive, try moving the teapot left and right ( *x* ),
    up and down ( *y* ), and in and out of the screen ( *z* ) by adding a “vector”
    to the operations. Then try combining all three.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb369b536.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  prefs: []
  type: TYPE_NORMAL
- en: Rotation is trickier because you can now rotate in different directions. In
    2D rotations were around the centre (origin) of the grid, but in 3D rotations
    are around a line (either the horizontal x-axis, the vertical y-axis, or the z-axis,
    which goes into the screen!)
  prefs: []
  type: TYPE_NORMAL
- en: 'The rotation we used earlier can be applied to 3 dimensions using this matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: ⎡⎣⎢cos(θ)sin(θ)0−sin(θ)cos(θ)0001⎤⎦⎥
  prefs: []
  type: TYPE_NORMAL
- en: Try applying that to the image above. This is rotating around the z-axis (a
    line going into the screen); that is, it’s just moving the image around in the
    2D plane. It’s really the same as the rotation we used previously, as the last
    line (0, 0, 1) just keeps the z point the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following matrix, which rotates around the x-axis (notice that the
    x value always stays the same because of the 1,0,0 in the first line):'
  prefs: []
  type: TYPE_NORMAL
- en: ⎡⎣⎢1000cos(θ)sin(θ)0−sin(θ)cos(θ)⎤⎦⎥
  prefs: []
  type: TYPE_NORMAL
- en: 'And this one for the y-axis:'
  prefs: []
  type: TYPE_NORMAL
- en: ⎡⎣⎢cos(θ)0−sin(θ)010sin(θ)0cos(θ)⎤⎦⎥
  prefs: []
  type: TYPE_NORMAL
- en: The following interactive allows you to combine 3D matrices.
  prefs: []
  type: TYPE_NORMAL
- en: You can experiment with moving the teapot around in space, changing its size,
    and angle.
  prefs: []
  type: TYPE_NORMAL
- en: Think about the order in which you need to combine the transforms to get a particular
    image that you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you translate an image and then scale it, you’ll get a different
    effect to scaling it then translating it. If you want to rotate or scale around
    a particular point, you can do this in three steps (as with the 2D case above):
    (1) translate the object so that the point you want to scale or rotate around
    is the origin (where the x, y and z axes meet), (2) do the scaling/rotation, (3)
    translate the object back to where it was. If you just scale an object where it
    is, its distance from the origin will also be scaled up.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb34825ff.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Click here for the interactive to combine multiple transforms into one](http://csfieldguide.org.nz/ComputerGraphics.html)
  prefs: []
  type: TYPE_NORMAL
- en: In the above examples, when you have several matrices being applied to every
    point in the image, a lot of time can be saved by converting the series of matrices
    and transforms to just one formula that does all of the transforms in one go.
    The following interactive can do those calculations for you.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the following interactive, type in the matrix for doubling the
    size of an object (put the number 2 instead of 1 on the main diagonal values),
    then add another matrix that triples the size of the image (3 on the main diagonal).
    The interactive shows a matrix on the right that combines the two — does it look
    right?
  prefs: []
  type: TYPE_NORMAL
- en: Multiple transforms
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb33ec59d.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  prefs: []
  type: TYPE_NORMAL
- en: The interactive also allows you to combine in translations (just three numbers,
    for x, y and z). Try combining a scaling followed by a translation. What if you
    add a rotation — does the order matter?
  prefs: []
  type: TYPE_NORMAL
- en: In case you’re wondering, the interactive is using the following formula to
    combine two matrices (you don’t have to understand this to use it). It is called
    matrix multiplication, and while it might be a bit tricky, it’s very useful in
    computer graphics because it reduces all the transformations you need to just
    one matrix, which is then applied to every point being transformed. This is way
    better than having to run all the matrices of every point.
  prefs: []
  type: TYPE_NORMAL
- en: '13.2.4\. PROJECT: 3D TRANSFORMS'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this project, you will demonstrate what you’ve learned in the section above
    by explaining a 3D transformation of a few objects. You should take screenshots
    of each step to illustrate the process for your report.
  prefs: []
  type: TYPE_NORMAL
- en: The following scene-creation interactive allows you to choose objects (and their
    colours etc.), and apply one transformation to them. To position them more interestingly,
    you will need to come up with multiple transformations (e.g. scale, then rotate,
    then translate), and use the “simplifier” interactive to combine all the matrices
    into one operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scene-creation interactive can be run from here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb31a48f0.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate combined transformations, you can use the following transform simplifier
    interactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb2c15684.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  prefs: []
  type: TYPE_NORMAL
- en: Because you can’t save your work in the interactives, keep notes and screen
    shots as you go along. These will be useful for your report, and also can be used
    if you need to start over again.
  prefs: []
  type: TYPE_NORMAL
- en: Introduce your project with a examples of 3D images, and how they are used (perhaps
    from movies or scenes that other people have created). Describe any innovations
    in the particular image (e.g. computer generated movies usually push the boundaries
    of what was previously possible, so discuss what boundaries were moved by a particular
    movie, and who wrote the programs to achieve the new effects).
  prefs: []
  type: TYPE_NORMAL
- en: For your project, try putting a few objects in a particular arrangement (e.g.
    with the teapot sitting beside some cups), and explain the transforms needed to
    achieve this, showing the matrices needed.
  prefs: []
  type: TYPE_NORMAL
- en: Give simple examples of translation, scaling *and* rotation using your scene.
  prefs: []
  type: TYPE_NORMAL
- en: You should include multiple transforms applied to one object, and show how they
    can be used to position an object.
  prefs: []
  type: TYPE_NORMAL
- en: Show how the matrices for a series of transforms can be multiplied together
    to get one matrix that applies all the transforms at once.
  prefs: []
  type: TYPE_NORMAL
- en: Discuss how the single matrix derived from all the others is more efficient,
    using your scene as an example to explain this.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3\. DRAWING LINES AND CIRCLES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A fundamental operation is computer graphics is to draw lines and circles. For
    example, these are used as the components of scalable fonts and vector graphics;
    the letter “i” is specified as a series of lines and curves, so that when you
    zoom in on it the computer can redraw it at whatever resolution is needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563adb2b64b99.png)'
  prefs: []
  type: TYPE_IMG
- en: In 3D graphics shapes are often stored using lines and curves that mark out
    the edges of flat surfaces, each of which is so small that you can’t see them
    unless you zoom right in.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563adb2aeb693.gif)'
  prefs: []
  type: TYPE_IMG
- en: The lines and circles that specify an object are usually given using numbers
    (for example, a line between a given starting and finishing position or a circle
    with a given centre and radius). From this a graphics program must calculate which
    pixels on the screen should be coloured in to represent the line or circle.
  prefs: []
  type: TYPE_NORMAL
- en: For example, here’s a grid of pixels with 5 lines shown magnified. The vertical
    line would have been specified as going from pixel (2,9) to (2,16) — that is,
    starting 2 across and 9 up, and finishing 2 across and 16 up. Of course, this
    is only a small part of a screen, as normally they are more like 1000 by 1000
    pixels or more; even a smartphone can be hundreds of pixels high and wide.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb2a6c251.png)](http://csfieldguide.org.nz/_images/20grid_example.png)'
  prefs: []
  type: TYPE_NORMAL
- en: These are things that are easy to do with pencil and paper using a ruler and
    compass, but on a computer the calculations need to be done for every pixel, and
    if you use the wrong method then it will take too long and the image will be displayed
    slowly or a live animation will appear jerky. In this section we will look into
    some very simple but clever algorithms that enable a computer to do these calculations
    very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.1\. LINE DRAWING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To draw a line, a computer must work out which pixels need to be filled so that
    the line looks straight. You can try this by colouring in squares on a grid, such
    as the one below (they are many times bigger than the pixels on a normal printer
    or screen). We’ll identify the pixels on the grid using two values, (*x*,*y*),
    where *x* is the distance across from the left, and *y* is the distance up from
    the bottom. The bottom left pixel below is (0,0), and the top right one is (19,19).
  prefs: []
  type: TYPE_NORMAL
- en: 'On the following grid, try to draw these straight lines by filling in pixels
    in the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: from (2, 17) to (10, 17)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: from (18, 2) to (18, 14)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: from (1, 5) to (8, 12)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![](563adb29f2de5.png)](http://csfieldguide.org.nz/_images/20grid.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a horizontal, vertical or diagonal line like the ones above is easy;
    it’s the ones at different angles that require some calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Without using a ruler, can you draw a straight line from A to B on the following
    grid by colouring in pixels?
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb2967ed3.png)](http://csfieldguide.org.nz/_images/20grid_ab.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have finished drawing your line, try checking it with a ruler. Place
    the ruler so that it goes from the centre of A to the centre of B. Does it cross
    all of the pixels that you have coloured?
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.2\. USING A FORMULA TO DRAW A LINE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mathematical formula for a line is y=mx+c. This gives you the *y* value
    for each *x* value across the screen, where m is the slope of the line and c is
    where it crosses the y axis. In other words, for *x* pixels across, the pixel
    to colour in would be (*x*, mx+c).
  prefs: []
  type: TYPE_NORMAL
- en: For example, choosing m=2 and c=3 means that the line would go through the points
    (0,3), (1,5), (2,7), (3,9) and so on. This line goes up 2 pixels for every one
    across (m=2), and crosses the y axis 3 pixels up (c=3).
  prefs: []
  type: TYPE_NORMAL
- en: You should experiment with drawing graphs for various values of m and c (for
    example, start with c=0, and try these three lines: m=1, m=0.5 and m=0) by putting
    in the values. What angle are these lines at?
  prefs: []
  type: TYPE_NORMAL
- en: The mx+c formula can be used to work out which pixels should be coloured in
    for a line that goes between (x1,y1) and (x2,y2). What are (x1,y1) and (x2,y2) for
    the points A and B on the grid below?
  prefs: []
  type: TYPE_NORMAL
- en: 'See if you can work out the m and b values for a line from A to B, or you can
    calculate them using the following formulas:'
  prefs: []
  type: TYPE_NORMAL
- en: m=(y2−y1)(x2−x1)
  prefs: []
  type: TYPE_NORMAL
- en: b=(y1x2−y2x1)(x2−x1)
  prefs: []
  type: TYPE_NORMAL
- en: Now draw the same line as in the previous section (between A and B) using the
    formula y=mx+c to calculate *y* for each value of *x* from x1 to x2 (you will
    need to round *y* to the nearest integer to work out which pixel to colour in).
    If the formulas have been applied correctly, the *y* value should range from y1 to y2.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb28db89c.png)](http://csfieldguide.org.nz/_images/20grid_ab.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have completed the line, check it with a ruler. How does it compare
    to your first attempt?
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the number of calculations that are needed to work out each point.
    It won’t seem like many, but remember that a computer might be calculating hundreds
    of points on thousands of lines in a complicated image. In the next section we
    will explore a method that greatly speeds this up.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.3\. BRESENHAM’S LINE ALGORITHM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A faster way for a computer to calculate which pixels to colour in is to use
    Brensenham’s Line Algorithm. It follows these simple rules. First, calculate these
    three values:'
  prefs: []
  type: TYPE_NORMAL
- en: A=2×(y2−y1)
  prefs: []
  type: TYPE_NORMAL
- en: B=A−2×(x2−x1)
  prefs: []
  type: TYPE_NORMAL
- en: P=A−(x2−x1)
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw the line, fill the starting pixel, and then for every position along
    the *x* axis:'
  prefs: []
  type: TYPE_NORMAL
- en: if P is less than 0, draw the new pixel on the same line as the last pixel,
    and add A to P.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if P was 0 or greater, draw the new pixel one line higher than the last pixel,
    and add B to P.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: repeat this decision until we reach the end of the line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Without using a ruler, use Bresenham’s Line Algorithm to draw a straight line
    from A to B:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb2356e1c.png)](http://csfieldguide.org.nz/_images/20grid_ab.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have completed the line, check it with a ruler. How does it compare
    to the previous attempts?
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.4\. LINES AT OTHER ANGLES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far the version of Bresenham’s line drawing algorithm that you have used
    only works for lines that have a gradient (slope) between 0 and 1 (that is, from
    horizontal to 45 degrees). To make this algorithm more general, so that it can
    be used to draw any line, some additional rules are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: If a line is sloping downward instead of sloping upward, then when P is 0 or
    greater, draw the next column’s pixel one row *below* the previous pixel, instead
    of above it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the change in Y value is greater than the change in X value, then the calculations
    for A, B, and the initial value for P will need to be changed. When calculating
    A, B, and the initial P, use X where you previously would have used Y, and vice
    versa. When drawing pixels, instead of going across every column in the X axis,
    go through every row in the Y axis, drawing one pixel per row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![](563adb22d7087.png)](http://csfieldguide.org.nz/_images/20grid.png)'
  prefs: []
  type: TYPE_NORMAL
- en: In the grid above, choose two points of your own that are unique to you. Don’t
    choose points that will give horizontal, vertical or diagonal lines!
  prefs: []
  type: TYPE_NORMAL
- en: Now use Bresenham’s algorithm to draw the line. Check that it gives the same
    points as you would have chosen using a ruler, or using the formula y=mx+b. How
    many arithmetic calculations (multiplications and additions) were needed for Bresenhams
    algorithm? How many would have been needed if you used the y=mx+b formula? Which
    is faster (bear in mind that adding is a lot faster than multiplying for most
    computers).
  prefs: []
  type: TYPE_NORMAL
- en: You could write a program or design a spreadsheet to do these calculations for
    you — that’s what graphics programmers have to do.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.5\. CIRCLES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As well as straight lines, another common shape that computers often need to
    draw are circles. An algorithm similar to Bresenham’s line drawing algorithm,
    called the Midpoint Circle Algorithm, has been developed for drawing a circle
    efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: A circle is defined by a centre point, and a radius. Points on a circle are
    all the radius distance from the centre of the circle.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb2219f04.png)](http://csfieldguide.org.nz/_images/20grid_cr.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Try to draw a circle by hand by filling in pixels (without using a ruler or
    compass). Note how difficult it is to make the circle look round.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to draw the circle using a formula based on Pythagoras’ theorem,
    but it requires calculating a square root for each pixel, which is very slow.
    The following algorithm is much faster, and only involves simple arithmetic so
    it runs quickly on a computer.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.6\. BRESENHAM’S MIDPOINT CIRCLE ALGORITHM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the rules for the Midpoint Circle Algorithm for a circle around (cx, cy)
    with a radius of R:'
  prefs: []
  type: TYPE_NORMAL
- en: E=−R
  prefs: []
  type: TYPE_NORMAL
- en: X=R
  prefs: []
  type: TYPE_NORMAL
- en: Y=0
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat the following rules in order until *Y* becomes greater than *X*:'
  prefs: []
  type: TYPE_NORMAL
- en: Fill the pixel at coordinate (cx+X, cy+Y)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase *E* by 2×Y+1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase *Y* by 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *E* is greater than or equal to 0, subtract (2X−1) from *E*, and then subtract
    1 from *X*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow the rules to draw a circle on the grid, using (cx, cy) as the centre
    of the circle, and R the radius. Notice that it will only draw the start of the
    circle and then it stops because *Y* is greater than *X*!
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb2190ffc.png)](http://csfieldguide.org.nz/_images/20grid_cr.png)'
  prefs: []
  type: TYPE_NORMAL
- en: When *y* becomes greater than *x*, one eighth (an octant) of the circle is drawn.
    The remainder of the circle can be drawn by reflecting the octant that you already
    have (you can think of this as repeating the pattern of steps you just did in
    reverse). Reflect pixels along the X and Y axis, such that the line of reflection
    crosses the middle of the centre pixel of the circle. Half of the circle is now
    drawn, the left and the right half. To add the remainder of the circle, another
    line of reflection must be used. Can you work out which line of reflection is
    needed to complete the circle?
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster** : Octant'
  prefs: []
  type: TYPE_NORMAL
- en: A quadrant is a quarter of an area; the four quadrants that cover the whole
    area are marked off by a vertical and horizontal line that cross. An *octant* is
    one eighth of an area, and the 8 octants are marked off by 4 lines that intersect
    at one point (vertical, horizontal, and two diagonal lines).
  prefs: []
  type: TYPE_NORMAL
- en: To complete the circle, you need to reflect along the diagonal. The line of
    reflection should have a gradient of 1 or -1, and should cross through the middle
    of the centre pixel of the circle.
  prefs: []
  type: TYPE_NORMAL
- en: While using a line of reflection on the octant is easier for a human to understand,
    a computer can draw all of the reflected points at the same time it draws a point
    in the first octant because when it is drawing pixel with an offset of (x,y) from
    the centre of the circle, it can also draw the pixels with offsets (x,-y), (-x,y),
    (-x,-y), (y,x), (y,-x), (-y,x) and (-y,-x), which give all eight reflections of
    the original point!
  prefs: []
  type: TYPE_NORMAL
- en: By the way, this kind of algorithm can be adapted to draw ellipses, but it has
    to draw a whole quadrant because you don’t have octant symmetry in an ellipse.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.7\. PRACTICAL APPLICATIONS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Computers need to draw lines, circles and ellipses for a wide variety of tasks,
    from game graphics to lines in an architect’s drawing, and even a tiny circle
    for the dot on the top of the letter ‘i’ in a word processor. By combining line
    and circle drawing with techniques like ‘filling’ and ‘antialiasing’, computers
    can draw smooth, clear images that are resolution independent. When an image on
    a computer is described as an outline with fill colours it is called vector graphics
    — these can be re-drawn at any resolution. This means that with a vector image,
    zooming in to the image will not cause the pixelation seen when zooming in to
    bitmap graphics, which only store the pixels and therefore make the pixels larger
    when you zoom in. However, with vector graphics the pixels are recalculated every
    time the image is redrawn, and that’s why it’s important to use a fast algorithm
    like the one above to draw the images.
  prefs: []
  type: TYPE_NORMAL
- en: Outline fonts are one of the most common uses for vector graphics as they allow
    the text size to be increased to very large sizes, with no loss of quality to
    the letter shapes.
  prefs: []
  type: TYPE_NORMAL
- en: Computer scientists have found fast algorithms for drawing other shapes too,
    which means that the image appears quickly and it can be done on relatively slow
    hardware - for example, a smartphone needs to do these calculations all the time
    to display images, and reducing the amount of calculations can extend its battery
    life, as well as make it appear faster.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, things aren’t quite as simple as shown here. For example, consider
    a horizontal line that goes from (0,0) to (10,0), which has 11 pixels. Now compare
    it with a 45 degree line that goes from (0,0) to (10,10). It still has 11 pixels,
    but the line is longer (about 41% longer to be precise). This means that the line
    would appear thinner or fainter on a screen, and extra work needs to be done (mainly
    anti-aliasing) to make the line look ok. We’ve only just begun to explore how
    techniques in graphics are needed to quickly render high quality images.
  prefs: []
  type: TYPE_NORMAL
- en: '13.3.8\. PROJECT: LINE AND CIRCLE DRAWING'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To compare Bresenham’s method with using the equation of a line (y=mx+b), choose
    your own start and end point of a line (of course, make sure it’s at an interesting
    angle), and show the calculations that would be made by each method. Count up
    the number of additions, subtractions, multiplications and divisions that are
    made in each case to make the comparison. Note that addition and subtraction is
    usually a lot faster than multiplication and division.
  prefs: []
  type: TYPE_NORMAL
- en: You can estimate how long each operation takes on your computer by running a
    program that does thousands of each operation, and timing how long it takes for
    each. From this you can estimate the total time taken by each of the two methods.
    A good measurement for these is how many lines (of your chosen length) your computer
    could calculate per second.
  prefs: []
  type: TYPE_NORMAL
- en: 13.4\. THE WHOLE STORY!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 13.5\. FURTHER READING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Todo
  prefs: []
  type: TYPE_NORMAL
- en: this section is yet to be written
  prefs: []
  type: TYPE_NORMAL
- en: 13.5.1\. USEFUL LINKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Computer_graphics](http://en.wikipedia.org/wiki/Computer_graphics)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Transformation_matrix](http://en.wikipedia.org/wiki/Transformation_matrix)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Bresenham](http://en.wikipedia.org/wiki/Bresenham)’s_line_algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Ray_trace](http://en.wikipedia.org/wiki/Ray_trace)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.cosc.canterbury.ac.nz/mukundan/cogr/applcogr.html](http://www.cosc.canterbury.ac.nz/mukundan/cogr/applcogr.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.cosc.canterbury.ac.nz/mukundan/covn/applcovn.html](http://www.cosc.canterbury.ac.nz/mukundan/covn/applcovn.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.povray.org/resources/links/3D_Tutorials/POV-Ray_Tutorials/](http://www.povray.org/resources/links/3D_Tutorials/POV-Ray_Tutorials/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computer Graphics, Computer Vision, Bresenham’s Line Algorithm, Ray Tracing,
    Magnetic Resonance Imaging (MRI), Rendering, 3D Modeling, Animation, WebGL (Web
    Graphics Library), OpenGL (Open Graphics Library)
  prefs: []
  type: TYPE_NORMAL
- en: 13.5.2\. KEY CONCEPTS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Algorithms: Bresenham’s algorithm (line and circle drawing), colour space conversion,
    line anti-aliasing, Bézier and B-spline curves, painter’s algorithm, Z-buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Techniques: Techniques: ray tracing, texture mapping, shading, anti-aliasing,
    volume rendering, polygonisation, constructive solid geometry, 3D modeling, hidden
    object removal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Applications: drawing software, animation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14\. COMPUTER VISION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 14.1\. WHAT’S THE BIG PICTURE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When computers were first developed, the only way they could interact with the
    outside world was through the input that people wired or typed into them. Digital
    devices today often have cameras, microphones and other sensors through which
    programs can perceive the world we live in automatically. Processing images from
    a camera, and looking for interesting information in them, is what we call *computer
    vision*.
  prefs: []
  type: TYPE_NORMAL
- en: With increases in computer power, the decrease in the size of computers and
    progressively more advanced algorithms, computer vision has a growing range of
    applications. While it is commonly used in fields like healthcare, security and
    manufacturing, we are finding more and more uses for them in our everyday life,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a sign written in Chinese:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563addbd743c9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you can’t read the Chinese characters, there are apps available for smartphones
    that can help:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563addbb7496d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Having a small portable device that can “see” and translate characters makes
    a big difference for travellers. Note that the translation given is only for the
    second part of the phrase (the last two characters). The first part says “please
    don’t”, so it could be misleading if you think it’s translating the whole phrase!
  prefs: []
  type: TYPE_NORMAL
- en: 'Recognising of Chinese characters may not work every time perfectly, though.
    Here is a warning sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563addb95808d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: My phone has been able to translate the “careful” and “steep” characters, but
    it hasn’t recognised the last character in the line. Why do you think that might
    be?
  prefs: []
  type: TYPE_NORMAL
- en: Giving users more information through computer vision is only one part of the
    story. Capturing information from the real world allows computers to assist us
    in other ways too. In some places, computer vision is already being used to help
    car drivers to avoid collisions on the road, warning them when other cars are
    too close or there are other hazards on the road ahead. Combining computer vision
    with map software, people have now built cars that can drive to a destination
    without needing a human driver to steer them. A wheelchair guidance system can
    take advantage of vision to avoid bumping into doors, making it much easier to
    operate for someone with limited mobility.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2\. LIGHTS, CAMERA, ACTION!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Digital cameras and human eyes fulfill largely the same function: images come
    in through a lens and are focused onto a light sensitive surface, which converts
    them into electrical impulses that can be processed by the brain or a computer
    respectively. There are some differences, however.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Human eyes** have a very sensitive area in the centre of their field of vision
    called the fovea. Objects that we are looking at directly are in sharp detail,
    while our peripheral vision is quite poor. We have separate sets of cone cells
    in the retina for sensing red, green and blue (RGB) light, but we also have special
    rod cells that are sensitive to light levels, allowing us to perceive a wide dynamic
    range of bright and dark colours. The retina has a blind spot (a place where all
    the nerves bundle together to send signals to the brain through the optic nerve),
    but most of the time we don’t notice it because we have two eyes with overlapping
    fields of view, and we can move them around very quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Digital cameras** have uniform sensitivity to light across their whole field
    of vision. Light intensity and colour are picked up by RGB sensor elements on
    a silicon chip, but they aren’t as good at capturing a wide range of light levels
    as our eyes are. Typically, a modern digital camera can automatically tune its
    exposure to either bright or dark scenes, but it might lose some detail (e.g.
    when it is tuned for dark exposure, any bright objects might just look like white
    blobs).'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that neither a human eye nor a digital camera
    — even a very expensive one — can perfectly capture all of the information in
    the scene in front of it. Electronic engineers and computer scientists are constantly
    doing research to improve the quality of the images they capture, and the speed
    at which they can record and process them.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3\. NOISE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One challenge when using digital cameras is something called *noise*. That’s
    when individual pixels in the image appear brighter or darker than they should
    be, due to interference in the electronic circuits inside the camera. It’s more
    of a problem when light levels are dark, and the camera tries to boost the exposure
    of the image so that you can see more. You can see this if you take a digital
    photo in low light, and the camera uses a high ASA/ISO setting to capture as much
    light as possible. Because the sensor has been made very sensitive to light, it
    is also more sensitive to random interference, and gives photos a “grainy” effect.
  prefs: []
  type: TYPE_NORMAL
- en: Noise mainly appears as random changes to pixels. For example, the following
    image has “salt and pepper” noise.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563addb730d9f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Having noise in an image can make it harder to recognise what’s in the image,
    so an important step in computer vision is reducing the effect of noise in an
    image. There are well-understood techniques for this, but they have to be careful
    that they don’t discard useful information in the process. In each case, the technique
    has to make an educated guess about the image to predict which of the pixels that
    it sees are supposed to be there, and which aren’t.
  prefs: []
  type: TYPE_NORMAL
- en: Since a camera image captures the levels of red, green and blue light separately
    for each pixel, a computer vision system can save a lot of processing time in
    some operations by combining all three channels into a single “grayscale” image,
    which just represents light intensities for each pixel.
  prefs: []
  type: TYPE_NORMAL
- en: This helps to reduce the level of noise in the image. Can you tell why, and
    about how much less noise there might be? (As an experiment, you could take a
    photo in low light — can you see small patches on it caused by noise? Now use
    photo editing software to change it to black and white — does that reduce the
    effect of the noise?)
  prefs: []
  type: TYPE_NORMAL
- en: Rather than just considering the red, green and blue values of each pixel individually,
    most noise-reduction techniques look at other pixels in a region, to predict what
    the value in the middle of that neighbourhood ought to be.
  prefs: []
  type: TYPE_NORMAL
- en: A *mean filter* assumes that pixels nearby will be similar to each other, and
    takes the average (i.e. the *mean*) of all pixels within a square around the centre
    pixel. The wider the square, the more pixels there are to choose from, so a very
    wide mean filter tends to cause a lot of blurring, especially around areas of
    fine detail and edges where bright and dark pixels are next to each other.
  prefs: []
  type: TYPE_NORMAL
- en: A *median filter* takes a different approach. It collects all the same values
    that the mean filter does, but then sorts them and takes the middle (i.e. the *median*)
    value. This helps with the edges that the mean filter had problems with, as it
    will choose either a bright or a dark value (whichever is most common), but won’t
    give you a value between the two. In a region where pixels are mostly the same
    value, a single bright or dark pixel will be ignored. However, numerically sorting
    all of the neighbouring pixels can be quite time-consuming!
  prefs: []
  type: TYPE_NORMAL
- en: A *Gaussian* blur is another common technique, which assumes that the closest
    pixels are going to be the most similar, and pixels that are farther away will
    be less similar. It works a lot like the mean filter above, but is statistically
    weighted according to a *normal distribution*.
  prefs: []
  type: TYPE_NORMAL
- en: '14.3.1\. ACTIVITY: NOISE REDUCTION FILTERS'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Open the noise reduction filtering interactive using this link and experiment
    with settings as below. You will need a webcam, and the widget will ask you to
    allow access to it.](http://www.cosc.canterbury.ac.nz/csfieldguide/dev/dev/_static/widgets/cv-noise-filters.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Mathematically, this process is applying a special kind of matrix called a *convolution
    kernel* to the value of each pixel in the source image, averaging it with the
    values of other pixels nearby and copying that average to each pixel in the new
    image. The average is weighted, so that the values of nearby pixels are given
    more importance than ones that are far away. The stronger the blur, the wider
    the convolution kernel has to be and the more calculations take place.
  prefs: []
  type: TYPE_NORMAL
- en: 'For your project, investigate the different kinds of noise reduction filter
    and their settings (mask size, number of iterations) and determine:'
  prefs: []
  type: TYPE_NORMAL
- en: how well they cope with different kinds and levels of noise (you can set this
    in the interactive).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how much time it takes to do the necessary processing (the interactive shows
    the number of frames per second that it can process)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how they affect the quality of the underlying image (a variety of images + camera)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can take screenshots of the image to show the effects in your writeup. You
    can discuss the tradeoffs that need to be made to reduce noise.
  prefs: []
  type: TYPE_NORMAL
- en: 14.4\. FACE RECOGNITION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recognising faces has become a widely used computer vision application. These
    days photo album systems like Picasa and Facebook can try to recognise who is
    in a photo using face recognition — for example, the following photos were recognised
    in Picasa as being the same person, so to label the photos with people’s names
    you only need to click one button rather than type each one in.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563addb624a24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are lots of other applications. Security systems such as customs at country
    borders use face recognition to identify people and match them with their passport.
    It can also be useful for privacy — Google Maps streetview identifies faces and
    blurs them. Digital cameras can find faces in a scene and use them to adjust the
    focus and lighting.
  prefs: []
  type: TYPE_NORMAL
- en: There is some information about [How facial recognition works](http://electronics.howstuffworks.com/gadgets/high-tech-gadgets/facial-recognition.htm) that
    you can read up as background, and some more information at [i-programmer.info](http://www.i-programmer.info/babbages-bag/1091-face-recognition.html) .
  prefs: []
  type: TYPE_NORMAL
- en: There are some relevant [articles on the cs4fn website](http://www.cs4fn.org/vision/) that
    also provide some general material on computer vision.
  prefs: []
  type: TYPE_NORMAL
- en: '14.4.1\. PROJECT: RECOGNISING FACES'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First let’s manually try some methods for recognising whether two photographs
    show the same person.
  prefs: []
  type: TYPE_NORMAL
- en: Get about 3 photos each of 3 people
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measure features on the faces such as distance between eyes, width of mouth,
    height of head etc. Calculate the ratios of some of these.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do photos of the same person show the same ratios? Do photos of different people
    show different ratios? Would these features be a reliable way to recognise two
    images as being the same person?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there other features you could measure that might improve the accuracy?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can evaluate the effectiveness of facial recognition in free software such
    as Google’s Picasa or the Facebook photo tagging system, but uploading photos
    of a variety of people and seeing if it recognises photos of the same person.
    Are there any false negatives or positives? How much can you change your face
    when the photo is being taken to not have it match your face in the system? Does
    it recognise a person as being the same in photos taken several years apart? Does
    a baby photo match of a person get matched with them when they are five years
    old? When they are an adult? Why or why not does this work?
  prefs: []
  type: TYPE_NORMAL
- en: Use the following face recognition interactive to see how well the Haar face
    recognition system can track a face in the image. What prevents it from tracking
    a face? Is it affected if you cover one eye or wear a hat? How much can the image
    change before it isn’t recognised as a face? Is it possible to get it to incorrectly
    recognise something that isn’t a face?
  prefs: []
  type: TYPE_NORMAL
- en: '[Open the face recognition interactive using this link and experiment with
    the settings. You will need a webcam, and the widget will ask you to allow access
    to it.](http://inspirit.github.com/jsfeat/sample_haar_face.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 14.5\. EDGE DETECTION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A useful technique in computer vision is *edge detection*, where the boundaries
    between objects are automatically identified. Having these boundaries makes it
    easy to*segment* the image (break it up into separate objects or areas), which
    can then be recognised separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s a photo where you might want to recognise individual objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563addb4e8659.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And here’s a version that has been processed by an edge detection algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563addaf0bce5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the grain on the table above has affected the quality; some pre-processing
    to filter that would have helped!
  prefs: []
  type: TYPE_NORMAL
- en: You can experiment with edge-detection yourself. Open the following interactive,
    which provides a *Canny edge detector* (see the information about [Canny edge
    detection on Wikipedia](http://en.wikipedia.org/wiki/Canny_edge_detector) ). This
    is a widely used algorithm in computer vision, developed in 1986 by John F. Canny.
  prefs: []
  type: TYPE_NORMAL
- en: '[Open the edge detection interactive using this link and experiment with settings
    as below. You will need a webcam, and the widget will ask you to allow access
    to it.](http://inspirit.github.com/jsfeat/sample_canny_edge.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '14.5.1\. ACTIVITY: EDGE DETECTION EVALUATION'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the canny edge detection interactive above, try putting different images
    in front of the camera and determine how good the algorithm is at detecting boundaries
    in the image. Capture images to put in your report as examples to illustrate your
    experiments with the detector.
  prefs: []
  type: TYPE_NORMAL
- en: Can the Canny detector find all edges in the image? If there are some missing,
    why might this be?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there any false edge detections? Why did they system think that they were
    edges?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the lighting on the scene affect the quality of edge detection?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the system find the boundary between two colours? How similar can the colours
    be and still have the edge detected?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How fast can the system process the input? Does the nature of the image affect
    this?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How well does the system deal with a page with text on it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.6\. THE WHOLE STORY!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The field of computer vision is changing rapidly at the moment because camera
    technology has been improving quickly over the last couple of decades. Not only
    is the resolution of cameras increasing, but they are more sensitive for low light
    conditions, have less noise, can operate in infra-red (useful for detecting distances),
    and are getting very cheap so that it’s reasonable to use multiple cameras, perhaps
    to give different angles or to get stereo vision.
  prefs: []
  type: TYPE_NORMAL
- en: Despite these recent changes, many of the fundamental ideas in computer vision
    have been around for a while; for example, the “k-means” segmentation algorithm
    was first described in 1967, and the first digital camera wasn’t built until 1975
    (it was a 100 by 100 pixel Kodak prototype).
  prefs: []
  type: TYPE_NORMAL
- en: (More material will be added to this chapter in the near future)
  prefs: []
  type: TYPE_NORMAL
- en: 14.7\. FURTHER READING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Computer_vision](http://en.wikipedia.org/wiki/Computer_vision)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Mri](http://en.wikipedia.org/wiki/Mri)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.cosc.canterbury.ac.nz/mukundan/cogr/applcogr.html](http://www.cosc.canterbury.ac.nz/mukundan/cogr/applcogr.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.cosc.canterbury.ac.nz/mukundan/covn/applcovn.html](http://www.cosc.canterbury.ac.nz/mukundan/covn/applcovn.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15\. NETWORK COMMUNICATION PROTOCOLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 15.1\. WHAT’S THE BIG PICTURE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Think about the last time someone sent you mail via the post. They probably
    wrote some content on some paper, put it in an envelope, wrote an address and
    put it in a postbox. From there, the letter probably went into a sorting center,
    got sorted, and was put in a bag. The bag then went into a vehicle like a truck,
    plane or boat. The vehicle either travelled through water, the air, or on the
    road. The postal system is a complicated one, designed to let individuals communicate
    easily, yet being efficient enough to group many letters into one postal delivery.
    The same ideas apply to how messages move around the internet. Whether it be a
    ‘like’ on Facebook, a video stream or an email - the internet and its various
    protocols looks after it for you so it is delivered on time and intact to the
    other person.
  prefs: []
  type: TYPE_NORMAL
- en: Below we introduce some concepts, algorithms, techniques, applications and problems
    that relate to network protocols; it isn’t a complete list of all the ideas in
    the area, but should be enough to give you a good idea of what this area of computer
    science is about.
  prefs: []
  type: TYPE_NORMAL
- en: 15.2\. GETTING STARTED
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take part in a game of Tablets of Stone in your classroom. Your teacher will
    show you how it is played. Try to think about a few things while you’re playing
    the game. What happens if one of my messages is delayed? What happens if one of
    my messages gets lost completely? Will the other governor be able to put them
    back together?
  prefs: []
  type: TYPE_NORMAL
- en: 15.3\. WHAT IS A PROTOCOL?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '‘Protocol’ is a fancy word for simply saying “an agreed way to do something”.
    You might have heard it in a cheesy cop show – “argh Jim, that’s against protocol!!!”
    – or heard it used in a procedural sense, such as how to file a tax return or
    sit a driving test. We all use protocols, every day. Think of when you’re in class.
    The *protocol*for asking a question may be as follows: raise your hand, wait for
    a nod from the teacher then begin asking your question.'
  prefs: []
  type: TYPE_NORMAL
- en: Simple tasks require simple protocols like the one above; however more complicated
    processes may require more complicated protocols. Pilots and aviation crew have
    their own language (almost) for their tasks. A subset of normal language used
    to convey information such as altitude, heading, people on board, status and more.
  prefs: []
  type: TYPE_NORMAL
- en: Activities on the internet vary a lot too (email, skype, video streaming, music,
    gaming, browsing, chatting), and so do the protocols used to achieve these. These
    collections of protocols form the topic of Networking Communication Protocols
    and this chapter will introduce you to some of them, what problems they solve,
    and what you can do to experience these protocols first hand. Let’s start by talking
    about the one you’re using if you’re viewing this page on the web.
  prefs: []
  type: TYPE_NORMAL
- en: 15.4\. APPLICATION LEVEL PROTOCOLS - HTTP, IRC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The URL for the home site of this book is [http://csfieldguide.org](http://csfieldguide.org/).
    Ask a few friends what the “http” stands for - they have probably seen it thousands
    of times...do they know what it is? This section covers high level protocols such
    as HTTP and IRC, what they can do and how you can use them (hint: you’re already
    using HTTP right now).'
  prefs: []
  type: TYPE_NORMAL
- en: 15.4.1\. HYPERTEXT TRANSFER PROTOCOL (HTTP)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The HyperText Transfer Protocol (HTTP) is the most common protocol in use on
    the internet. The protocol’s job is to transfer *HyperText* (such as HTML) from
    a server to your computer. It’s doing that right now. You just loaded the Field
    Guide from the servers where it is hosted. Hit refresh and you’ll see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP functions as a simple conversation between client and server. Think of
    when you’re at a shop:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You: “Can I have a can of soda please?”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shop Keeper: “Sure, here’s a can of soda”'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ade320686c.png)'
  prefs: []
  type: TYPE_IMG
- en: HTTP uses a request/response pattern for solving the problem of reliable communication
    between client and server. The “ask for” is known as a *request* and the reply
    is known as a *response*. Both requests and responses can also have other data
    or *resources* sent along with it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  prefs: []
  type: TYPE_NORMAL
- en: A *resource* is any item of data on a server. For example, a blog post, a customer,
    an item of stock or a news story. As a business or a website, you would create,
    read, update and delete these as part of your daily business. HTTP is well suited
    to that. For example, if you’re a news site, every day your authors would add
    stories, you could update them, delete them if they’re old or become out of date,
    all sorts. These sorts of methods are required to manage content on a server,
    and HTTP is the way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: This is happening all the time when you’re browsing the web; every web page
    you look at is delivered using the HyperText Transfer Protocol. Going back to
    the shop analogy, consider the same example, this time with more resources shown
    in asterisk (*) characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You: “Can I have a can of soda please?” *You hand the shop keeper $2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shop Keeper: “Sure, here’s a can of soda” *Also hands you a receipt and your
    change*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ade3151585.png)'
  prefs: []
  type: TYPE_IMG
- en: There are nine *types* of requests that HTTP supports, and these are outlined
    below.
  prefs: []
  type: TYPE_NORMAL
- en: A GET request returns some text that describes the thing you’re asking for.
    Like above, you ask for a can of soda, you get a can of soda.
  prefs: []
  type: TYPE_NORMAL
- en: 'A HEAD request returns what you’d get if you did a GET request. It’s like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You: “Can I have a can of soda please?”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shop Keeper: “Sure, here’s the can of soda you’d get” *Holds up a can of soda*'
  prefs: []
  type: TYPE_NORMAL
- en: What’s neat about HTTP is that it allows you to also modify the contents of
    the server. Say you’re now also a representative for the soda company, and you’d
    like to re-stock some shelves.
  prefs: []
  type: TYPE_NORMAL
- en: 'A POST request allows you to send information in the other direction. This
    request allows you to replace a resource on the server with one you supply. These
    use what is called a Uniform Resource Identifier or URI. A URI is a unique code
    or number for a resource. Confused? Let’s go back to the shop:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sales Rep: “I’d like to replace this dented can of soda with barcode number
    123-111-221 with this one, that isn’t dented”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shop Keeper: “Sure, that has now been replaced”'
  prefs: []
  type: TYPE_NORMAL
- en: A PUT request adds a new resource to a server, however, if the resource already
    exists with that URI, it is modified with the new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sales Rep: “Here, have 10 more cans of lemonade for this shelf”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shop Keeper: “Thanks, I’ve now put them on the shelf”'
  prefs: []
  type: TYPE_NORMAL
- en: A DELETE request does what you’d think, it deletes a resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sales Rep: “We are no longer selling ‘Lemonade with Extra Vegetables’, no one
    likes it! Please remove them!”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shop Keeper: “Okay, they are gone”.'
  prefs: []
  type: TYPE_NORMAL
- en: Some other request types (*HTTP methods*) exist too, but they are less used;
    these are TRACE, OPTIONS, CONNECT and PATCH. You can [find out more about these](http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)on
    your own if you’re interested.
  prefs: []
  type: TYPE_NORMAL
- en: 'In HTTP, the first line of the response is called the *status* line and has
    a numeric status code such as **404** and a text-based *reason phrase* such as
    “Not Found”. The most common is 200 and this means successful or “OK”. HTTP status
    codes are primarily divided into five groups for better explanation of requests
    and responses between client and server and are named by purpose and a number:
    Informational 1XX, Successful 2XX, Redirection 3XX, Client Error 4XX and Server
    Error 5XX. There are many [status codes](http://en.wikipedia.org/wiki/List_of_HTTP_status_codes) for
    representing different cases for error or success. There’s even a nice 418: Teapot
    error on Google: [http://www.google.com/teapot](http://www.google.com/teapot)'
  prefs: []
  type: TYPE_NORMAL
- en: So what’s actually happening? Well, let’s find out. If you’re in a Chrome or
    Safari browser, press Ctrl + Shift + I in windows or Command + Option + I on a
    mac to bring up the web inspector. Select the Network tab. Refresh the page. What
    you’re seeing now is a list of of HTTP requests your browser is making to the
    server to load the page you’re currently viewing. Near the top you’ll see a request
    to NetworkCommunicationProtocols.html. Click that and you’ll see details of the
    Headers, Preview, Response, Cookies and Timing. Ignore those last two for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the first few lines of the headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The *Remote Address* is the address of the server of the page is hosted on.
    The *Request URL* is the original URL that you requested. The request method should
    be familiar from above. It is a GET type request, saying “can I have the web page
    please?” and the response is the HTML. Don’t believe me? Click the *Response* tab.
    Finally, the *Status Code* is a code that the page can respond with.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the *Request Headers* now, click ‘view source’ to see the original
    request.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, a request message consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A request line in the form of *method* *URI* *protocol*/*version*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request Headers (Accept, User-Agent, Accept-Language etc)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional message body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at the *Response Headers*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, a request message consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Status Line, 200 OK means everything went well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Response Headers (Content-Length, Content-Type etc)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional message body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go ahead and try this same process on a few other pages too. For example, try
    these sites:'
  prefs: []
  type: TYPE_NORMAL
- en: A very busy website in terms of content, such as *Facebook.com*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A chapter that [doesn’t exist in the Field Guide](http://csfieldguide.org.nz/Nope.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your favourite website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Curiosity**'
  prefs: []
  type: TYPE_NORMAL
- en: Tim Berners-Lee was credited for creating HTTP in 1989\. You can read more about
    him [here](http://en.wikipedia.org/wiki/Tim_Berners-Lee).
  prefs: []
  type: TYPE_NORMAL
- en: 15.4.2\. INTERNET RELAY CHAT (IRC)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Internet Relay Chat (IRC) is a system that lets you transfer messages in the
    form of text. It’s essentially a chat protocol. The system uses a client-server
    model. Clients are chat programs installed on a user’s computer that connect to
    a central server. The clients communicate the message to the central server which
    in turn relays that to other clients. The protocol was originally designed for
    group communication in a discussion forum, called *channels*. IRC also supports
    one-to-one communication via *private messages*. It is also capable of file and
    data transfer too.
  prefs: []
  type: TYPE_NORMAL
- en: The neat thing about IRC is that users can use commands to interact with the
    server, client or other users. For example /DIE will tell the server to shutdown
    (although it will only work if you are the administrator!) /ADMIN will tell you
    who the administrator is.
  prefs: []
  type: TYPE_NORMAL
- en: Whilst IRC may be new to you, the concept of a group conversation online or
    a *chat room* may not be. There really isn’t any difference. Groups exist in the
    forms of*channels*. A server hosts many channels, and you can choose which one
    to join.
  prefs: []
  type: TYPE_NORMAL
- en: 'Channels usually form around a particular topic, such as Python, Music, TV
    show fans, Gaming or Hacking. Convention dictates that channel names start with
    one or two # symbols, such as #python or ##TheBigBangTheory. *Conventions* are
    different to protocols in that they aren’t actually enforced by the protocol,
    but people choose to use it that way.'
  prefs: []
  type: TYPE_NORMAL
- en: To get started with IRC, first you should get a client. A client is a program
    that let’s you connect Ask your teacher about which one to use. For this chapter,
    we’ll use the [freenode web client.](http://webchat.freenode.net/). Check with
    your teacher about which channel to join, as they may have set one up for you.
  prefs: []
  type: TYPE_NORMAL
- en: Try a few things while you’re in there. Look at this [list of commands](http://en.wikipedia.org/wiki/List_of_Internet_Relay_Chat_commands) and
    try to use some of them. What response do you get? Does this make sense?
  prefs: []
  type: TYPE_NORMAL
- en: Try a one on one conversation with a friend. If they use commands, do you see
    them? How about the other way around?
  prefs: []
  type: TYPE_NORMAL
- en: 15.5\. PROJECTS - HTTP AND IRC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**HTTP** is the most common protocol yet. We use it every day and you’re using
    it right now if you’re viewing this on the web. Open up the web inspector (you
    might have to do this at home if your school doesn’t have it available) and have
    a look at the traffic. You might need to refresh, depending on your browser. We
    recommend Chrome, which is free to download at [https://www.google.com/chrome/browser/](https://www.google.com/chrome/browser/).'
  prefs: []
  type: TYPE_NORMAL
- en: Bring up the Developer Tools. Find the *Network* tab. Reload the page. You should
    now see a slew of request form. Go through and click each one. Have a look at
    the details you can see under headers.
  prefs: []
  type: TYPE_NORMAL
- en: What is the remote address?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What type of method is it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the status code mean?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the path?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the response?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is *actually happening* here? What part of the page is loading?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IRC** is a very primitive chat program which is fun to use with your friends.'
  prefs: []
  type: TYPE_NORMAL
- en: Go be a hacker, grab a friend and [visit freenode and create a channel for you.](http://webchat.freenode.net/) Now,
    look at the [list of commands you can use](http://en.wikipedia.org/wiki/List_of_Internet_Relay_Chat_commands) and
    try to use some of them. What response do you get? Does this make sense?
  prefs: []
  type: TYPE_NORMAL
- en: Try a one on one conversation with a friend. If they use commands, do you see
    them? How about the other way around?
  prefs: []
  type: TYPE_NORMAL
- en: 15.6\. TRANSPORT LAYER PROTOCOLS - TCP AND UDP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we have talked about HTTP and IRC. These protocols are at a level that
    make sure you do not need to worry about how your data is being transported. Now
    we’ll cover how your data is transferred reliably and efficiently, regardless
    of what the data is. Below this level is an unreliable medium for transfer (such
    as wifi or cable, which are subject to interference errors) which causes a concern
    for data transportation. These protocols take different approaches to ensure data
    is delivered in an effective and/or efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: 15.6.1\. TCP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TCP (The Transmission Control Protocol) is one of the most important protocol
    on the internet. It breaks large messages up into *packets*. What is a packet?
    A packet is a segment of data that when combined with other packets, make up a
    total message (something like a HTTP request, an email, an IRC message or a file
    like a picture or song being downloaded). For the rest of the section, we’ll look
    at how these are used to load an image from a website.
  prefs: []
  type: TYPE_NORMAL
- en: So computer A looks the file and takes it, breaks it into packets. It then sends
    the packets over the internet and computer B reassembles them and gives them back
    to you as the image, [which is demonstrated in this video.](https://www.youtube.com/watch?v=WwyJGzZmBe8)
  prefs: []
  type: TYPE_NORMAL
- en: By now you’re probably wondering why we bother splitting up packets… wouldn’t
    it be easier to send the file as a whole? Well, it solves congestion. Imagine
    you’re in a bus, in rush hour and you have to be home by 5\. The road is jammed
    and there’s no way you and your friends are getting home on time. So you decide
    to get out of the bus and go your own separate ways. Web pages are like this too.
    They are too big to travel together so they are split up and sent in tiny pieces
    and then reassembled at the other end.
  prefs: []
  type: TYPE_NORMAL
- en: 'So why don’t the packets all just go from computer A to computer B just fine?
    Ha! That’d be nice. Unfortunately it’s not that simple. Through various means,
    there are some problems that can affect packets. These problems are:'
  prefs: []
  type: TYPE_NORMAL
- en: Packet loss
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packet delay (packets arrive out of order)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packet corruption (the packet gets changed on the way)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, if we didn’t try fix these, the image wouldn’t load, bits would be missing,
    corrupted or computer B might not even recognise what it is!
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ade2e6c678.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, TCP is a protocol that solves these issues. To introduce you to TCP, please
    play the game below. In the game, *you* are the problems (loss, delay, corruption)
    and as you move through the levels, pay attention to how the computer tries to
    combat them. Good luck trying to stop the messages getting through correctly!
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ade2d60b06.png)Click to play'
  prefs: []
  type: TYPE_NORMAL
- en: Packet Attack](http://csfieldguide.org.nz/_static/widgets/PacketAttack/)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s talk about what you saw in that game. What did the levels do to solve
    the issues of packet loss, delay (reordering) and corruption? TCP has several
    mechanisms for dealing with packet troubles.
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  prefs: []
  type: TYPE_NORMAL
- en: Why do packets experience delays, loss and corruption? This is because as packets
    are sent over a network, they go through various *nodes*. These nodes are effectively
    different routers or computers. One route might experience more interference than
    another (causing packet loss), one might be faster or shorter than another (causing
    order to be lost). Corruption can happen at any time through electronic interference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, TCP starts by doing what is known as a handshake. This basically means
    the two computers say to each other: “Hey, we’re going to use TCP for this image.
    Reconstruct it as you would”.'
  prefs: []
  type: TYPE_NORMAL
- en: Next is **Ordering**. Since a computer can’t look at data and order it like
    we can (like when we do a jigsaw puzzle or play Scrabble™) they need a way to
    “stitch” the packets back together. As we saw in *Packet Attack*, if you delayed
    a message that didn’t have ordering, the message may look like “HELOLWOLRD”. So,
    TCP puts a number on each packet (called a sequence number) which signifies its
    order. With this, it can put them back together again. It’s a bit like when you
    print out a few pages from a printer and you see “*Page 2 of 11*” on the bottom.
    Now, if packets do become out of order, TCP will wait for all of the packets to
    arrive and then put the message together.
  prefs: []
  type: TYPE_NORMAL
- en: Another concept is **checksums**. This concept of storing information about
    the data may be familiar from the [error control coding chapter](http://www.cosc.canterbury.ac.nz/csfieldguide/ErrorControlCoding.html).
    Basically, a checksum can detect errors and sometimes with coding schemes, can
    correct them. In the case of a correctable packet, it is corrected. If not, the
    packet is useless and needs to be resent. In the game, shields represent checksums.
    Corrupt a checksum once, and it can recover from the error using error correction.
    Corrupt it again and it can’t.
  prefs: []
  type: TYPE_NORMAL
- en: So how do packets get re-sent? TCP has a concept of *acknowledgement* and *negative
    acknowledgement* messages (ACK and NACK for short). You would have seen these
    in the higher levels of the game as the green (ACK) and red (NACK) creatures going
    back. Acks are sent to let the sender know when a packet arrives and it is usable.
    Nacks are sent back when a packet arrives and is damaged and needs resending.
    ACKs and and NACKs are useful because they provide a channel *in the opposite
    direction* for communication. If computer A receives a NACK, they can resend the
    message. If it receives an Ack, the computer can stop worrying about a resend.
  prefs: []
  type: TYPE_NORMAL
- en: But does a computer send it again if it doesn’t hear back? Yes. It’s called
    a timeout and it’s the final line of defense in TCP. If a computer doesn’t get
    an ACK or a NACK back, after a certain time it will just resend the packet. It’s
    a bit like when you’re tuning out in class, and the teacher keeps repeating your
    name until you answer. Maybe that’s been you… woops. Sometimes, an ACK might get
    lost, so the packet is resent after a timeout, but that’s OK, as TCP can recognise
    duplicates and ignore them.
  prefs: []
  type: TYPE_NORMAL
- en: So that’s TCP. A protocol that puts accurate data transmission before efficiency
    and speed in a network. It uses timeouts, checksums, acks and nacks and many packets
    to deliver a message reliably. However, what if we don’t need all the packets?
    Can we get the overall picture faster? Read on…
  prefs: []
  type: TYPE_NORMAL
- en: 15.6.2\. UDP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UDP (User Datagram Protocol) is a protocol for sending packets that does not
    guarantee delivery. UDP doesn’t guarantee against lost packets, duplicate packets
    or out of order packets. It just gets the bulk of the data there when it can.
    Checksums are used for data integrity though, so they have some protection. It’s
    still a protocol because it has a formal packet structure. The packets still include
    destination and origin as well as the size of the packet.
  prefs: []
  type: TYPE_NORMAL
- en: So do we even use such an unreliable protocol? Yes, but not for anything too
    important. Files, messages, emails, web pages and other text based items use TCP,
    but things like streaming music, video, VOIP and so on use UDP. Maybe you’ve had
    a call on Skype that has been poor quality. Maybe the video flickers or the sound
    drops for a split second. That’s packets being lost. However, you of course get
    the overall picture and the conversation you’re having is successful.
  prefs: []
  type: TYPE_NORMAL
- en: 15.7\. PROJECTS - TCP AND UDP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before writing about Network Communication Protocols, think about the following
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tablets of Stone:**'
  prefs: []
  type: TYPE_NORMAL
- en: How did your messaging go when you first started?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you need numbers on your tablets?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Was it a pain to use up tablet space on numbers and other information?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you ever get to reliable communication?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packet Attack:**'
  prefs: []
  type: TYPE_NORMAL
- en: What happens if you add too many kills, corrupts and delays? Is there a relationship
    between this and time taken to transmit the message? Try graphing it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if you turn off all the defenses?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if you have no kills, corrupts and delays?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if you only have delays?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if you kill a packet creature when it tries to get sent the second
    time?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What other situations can you get the protocol in?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PACKET ATTACK LEVEL CREATOR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check any defenses you want, enter some values for the attacks and click Create
    Level
  prefs: []
  type: TYPE_NORMAL
- en: Shields
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs: []
  type: TYPE_NORMAL
- en: Timeouts
  prefs: []
  type: TYPE_NORMAL
- en: Return Packet Creatures
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of Delays:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of Corrupts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of Kills:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a project, using the knowledge you have gained on TCP and UDP, create some
    custom levels in Packet Attack using the controls just above to create some unique
    situations that illustrate different aspects of Network Protocols. The following
    questions will help you to reflect on the issues that you could talk about:'
  prefs: []
  type: TYPE_NORMAL
- en: What problems did you encounter when transmitting data across networks? Talk
    about problems that you encountered at the start of Tablets of Stone (photos of
    examples from various stages of the activity are a great way to illustrate it!)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the use of TCP and UDP in networks today, with example situations. Which
    systems use TCP? Which use UDP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain at least two techniques used by TCP and UDP to address the problems
    above. Show some examples from Packet Attack (and/or Tablets of Stone) that illustrate
    the concepts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For systems that require TCP, what might happen to them if TCP did not exist
    and they had to use UDP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Discuss the differences between TCP and UDP, why each exists, and why you would
    choose a particular protocol for several scenarios.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the performance of protocols like TCP change as the reliability of
    the connection varies? You could look at how the speed of getting data through
    changes if lots of packets need to be re-sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 15.8\. THE WHOLE STORY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say I want to write an online music player. Okay, so I write the code
    for someone to press play on a website and the song plays. Do I now need to code
    up the protocol that streams the music? Fine, I write some UDP code. Now, do I
    need to go install the cables in your house? Sure, I jump in my van and spend
    a few weeks running cable to your house and make sure the packets can get over
    too.
  prefs: []
  type: TYPE_NORMAL
- en: No. This sounds absurd. As a web developer, I don’t want to worry about anything
    other than making my music player easy to use and fast. I *don’t* want to worry
    about UDP and I *don’t* want to worry about ethernet or cables. It’s already done,
    I can assume it’s take care of. And it is.
  prefs: []
  type: TYPE_NORMAL
- en: Internet protocols exist in layers. We have four such layers in the computer
    science internet model. The top two levels are discussed above in detail, the
    bottom two we won’t focus on.The first layer is the Application Layer, followed
    by the Transport, Internet and Link layers.
  prefs: []
  type: TYPE_NORMAL
- en: At each layer, data is made up of the previous layers’ whole unit of data, and
    then *headers* are added and passed down. At the bottom layer, the Link layer,
    a *footer* is added also. Below is an example of what a UDP packet looks like
    when it’s packaged up for transport.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: Footers and Headers are basically packet *meta-data*. Information about the
    information. Like a letterhead or a footnote, they’re not part of the content,
    but they are on the page. Headers and Footers exist on packets to store data.
    Headers come before the data and footers afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ade27d0061.png)'
  prefs: []
  type: TYPE_IMG
- en: You can think of these protocols as a game of pass the parcel. When a message
    is sent in HTTP, it is wrapped in a TCP header, which is then wrapped in an IPv6
    header, which is then wrapped in a Ethernet header and footer and sent over ethernet.
    At the other end, it’s unwrapped again from an ethernet *frame*, back to a IP*packet*,
    a TCP *datagram*, to a HTTP *request*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  prefs: []
  type: TYPE_NORMAL
- en: The name packet is a generic term for a unit of data. In the application layer
    units of data are called *data* or *requests*, in the transport layer, *datagram* or*segments*,
    in the Network/IP layer, *packet* and in the physical layer, a *frame*. Each level
    has its own name for a unit of data (segment, packet, frame, request etc), however
    the more generic “packet” is often used instead, regardless of layer.
  prefs: []
  type: TYPE_NORMAL
- en: This system is neat because each layer can assume that the layer above and below
    have guaranteed something about the information, and each layer (and protocol
    in use at that layer) has a stand-alone role. So if you’re making a website you
    just have to program website code, and not worry about code to make the site work
    over wifi as well as ethernet. A similar system is in the postal system… You don’t
    put the courier’s truck number on the front of the envelope! That’s take care
    of by the post company, which then uses a system to sort the mail and assign it
    to drivers, and then drivers to trucks, and then drivers to routes… none of which
    you need to worry about when you send or receive a letter or use a courier.
  prefs: []
  type: TYPE_NORMAL
- en: So what does a TCP segment look like?
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ade247f257.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, a packet is divided into four main parts, addresses (source,
    destination), numbers (sequence number, ANCK number if it’s an acknowledgement),
    flags (urgent, checksum) in the header, then the actual data. At each level, a
    segment becomes the data for the next data unit, and that again gets its own header.
  prefs: []
  type: TYPE_NORMAL
- en: TCP and UDP packets have a number with how big they are. This number means that
    the packet can actually be as big as you like. Can you think of any advantages
    of having small packets? How about big ones? Think about the ratio of data to
    information (such as those in the header and footer).
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example of a packet trace on our network…(using [tcpdump on the mac)](http://support.apple.com/kb/HT3994)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 15.9\. FURTHER READING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [`two generals problem`__](http://csfieldguide.org.nz/NetworkCommunicationProtocols.html#id6) is
    a famous problem in protocols to talk about what happens when you can’t be sure
    about communication success
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if you were to send packets tied to birds? [IP over Avian Cariers](http://en.wikipedia.org/wiki/IP_over_Avian_Carriers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocols are found in the strangest of places…. [Engine Order Telegraph](http://en.wikipedia.org/wiki/Engine_order_telegraph)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coursera course on [Internet History, Technology, and Security](https://www.coursera.org/learn/insidetheinternet)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.9.1\. EXTRA ACTIVITIES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CS Unplugged Routing - Why do packets get delayed? [http://csunplugged.org/routing-and-deadlock](http://csunplugged.org/routing-and-deadlock)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snail Mail - [http://www.cs4fn.org/internet/realsnailmail.php](http://www.cs4fn.org/internet/realsnailmail.php)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code.org - The Internet [https://learn.code.org/s/1/level/102](https://learn.code.org/s/1/level/102)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.9.2\. USEFUL LINKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[http://simple.wikipedia.org/wiki/TCP/IP](http://simple.wikipedia.org/wiki/TCP/IP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Internet_protocol_suite](http://en.wikipedia.org/wiki/Internet_protocol_suite)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol](http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Internet_Relay_Chat](http://en.wikipedia.org/wiki/Internet_Relay_Chat)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Transmission_Control_Protocol](http://en.wikipedia.org/wiki/Transmission_Control_Protocol)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/User_Datagram_Protocol](http://en.wikipedia.org/wiki/User_Datagram_Protocol)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://csunplugged.org/routing-and-deadlock](http://csunplugged.org/routing-and-deadlock)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16\. SOFTWARE ENGINEERING
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 16.1\. WHAT’S THE BIG PICTURE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software failures happen all the time. Sometimes it’s a little bug that makes
    a program difficult to use; other times an error might crash your entire computer.
    Some software failures are more spectacular than others.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1996, The ARIANE 5 rocket of the European Space Agency was launched for
    its first test flight: Countdown, ignition, flame and smoke, soaring rocket...
    then BANG! Lots of little pieces scattered through the South American rainforest.
    Investigators had to piece together what happened and finally tracked down this
    tiny, irrelevant bug. A piece of software on board the rocket which was not even
    needed had reported an error and started a self-destruct sequence. Thankfully,
    no one was on board but the failure still caused about US$370m damage.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae351997df.png)'
  prefs: []
  type: TYPE_IMG
- en: In extreme cases, software bugs can endanger lives. This happened in the 1980s,
    for example, when a [radiation therapy machine](http://en.wikipedia.org/wiki/Therac) caused
    the deaths of 3 patients by giving 100 times the intended dose of radiation. And
    in 1979, a US army computer almost started a nuclear war, when it misinterpreted
    a simulation of the Soviet Union launching a missile as the real thing! (If you
    are interested in other software failures, [CS4FN](http://www.cs4fn.org/softwareengineering/backtodrawingboard.php) lists
    the most spectacular ones!)
  prefs: []
  type: TYPE_NORMAL
- en: 'Our society today is so reliant on software that we can’t even imagine life
    without it anymore. In many ways, software has made our lives easier: we write
    emails, chat with friends on Facebook, play computer games and search for information
    on Google. Heaps of software is hidden behind the scenes too so we don’t even
    know we’re using it, for example in cars, traffic lights, TVs, washing machines,
    Japanese toilets, and hearing aids. We’ve become so used to having software, we
    expect it to work at all times!'
  prefs: []
  type: TYPE_NORMAL
- en: So why doesn’t it? Why do we get bugs in the first place? As it turns out, writing
    software is incredibly difficult. Software isn’t a physical product, so we can’t
    just look at it to see if it’s correct. On top of that, most of the software you
    use every day is huge and extremely complex. Windows Vista is rumoured to have
    around 50 million lines of code; MacOSX even has 86 million. If we printed Vista
    out on paper, we would get a 88m high stack! That’s as high as a 22 storey building
    or the Statue of Liberty in New York! If you wanted to read through Vista and
    try to understand how it works, you can expect to get through about 120 lines
    per hour, so it would take you 417,000 hours or 47 ½ years! (And that’s just to
    read through it, not write it.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae350d2c61.png)'
  prefs: []
  type: TYPE_IMG
- en: Software engineering is all about how we can create software despite this enormous
    size and complexity and hopefully get a working product in the end. It was first
    introduced as a topic of computer science in the 1960s during the so-called “software
    crisis”, when people realised that the capability of hardware was increasing at
    incredible speeds while our ability to develop software is staying pretty much
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: As the name software engineering suggests, we are taking ideas and processes
    from other engineering disciplines (such as building bridges or computer hardware)
    and applying them to software. Having a structured process in place for developing
    software turns out to be hugely important because it allows us to manage the size
    and complexity of software. As a result of advances in software engineering, there
    are many success stories of large and complex software products which work well
    and contain few bugs. Think, for example, of Google who have huge projects (Google
    search, Gmail, …) and thousands of engineers working on them but somehow still
    manage to create software that does what it should.
  prefs: []
  type: TYPE_NORMAL
- en: Since the 1960s, software engineering has become a very important part of computer
    science, so much so that today programmers are rarely called programmers, but
    software engineers. That’s because making software is much more than just programming.
    There are a huge number of jobs for software engineers and demand for skilled
    workers continues to grow. The great thing about being a software engineer is
    that you get to work in large teams to produce products that will impact the lives
    of millions of people! Although you might think that software engineers would
    have to be very smart and a bit geeky, communication and teamwork skills are actually
    more important; software engineers have to be able to work in teams and communicate
    with their teammates. The ability to work well with humans is at least as important
    as the ability to work with computers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity: Moore’s Law**'
  prefs: []
  type: TYPE_NORMAL
- en: In 1965, Gordon Moore noticed that the number of transistors on integrated circuits
    was doubling about every 2 years. This means that computers’ processing power
    was doubling roughly every 2 years (sometimes this is quoted as 18 months due
    to the combination of the numbers *and* speed increasing). Moore said that he
    expected this trend to continue for at least 10 years.
  prefs: []
  type: TYPE_NORMAL
- en: Believe it or not, Moore’s law didn’t just last for 10 years but is still true
    nearly 50 years later (although a slowdown is predicted in the next couple of
    years). This means that computers today are over 100 million times faster than
    in 1965! (It’s been 47 years since 1965, which means that processing power has
    doubled about 24 times; 2^{24} is 16,777,216 so if computers could run one instruction
    per second in 1965, they can now run 16,777,216!) It also means that if you buy
    a computer today, you might regret it in two years time when new computers will
    be twice as fast. Moore’s law also holds for other things, such as processing
    power in cellphones and the number of pixels in digital cameras.
  prefs: []
  type: TYPE_NORMAL
- en: The exact numbers above will depend on exactly what you’re describing, but the
    main point is that the processing power is increasing *exponentially* — exponential
    growth doesn’t mean just getting a lot faster, but getting unbelievably faster;
    nothing in human history has ever grown this quickly! To illustrate this in reverse,
    the time taken to open an app on a smartphone might be half a second today, but
    a 1965 smartphone would have taken over a year to open the same app (and the phone
    would probably have been the size of a football field). It’s no wonder that smartphones
    weren’t popular in the 1960s.
  prefs: []
  type: TYPE_NORMAL
- en: Although software engineering has come a long way in the last decades, writing
    software is still difficult today. As a user, you only see the programs that were
    completed, not those that failed. In 2009, just under a third of all software
    projects succeeded, while almost a quarter failed outright or were cancelled before
    the software could be delivered. The remaining projects were either delivered
    late, were over budget or lacked functionality. A famous recent project failure
    was the software for the baggage handling system at the new airport in Denver.
    The system turned out to be more complex than engineers had expected; in the end,
    the entire airport was ready but had to wait for 16 months before it could be
    opened because the software for the baggage system was not working. Apparently,
    the airport lost $1 million every day during these 16 months!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we look at some of the basics of software engineering. We’ll
    give you an introduction about *analysing* the problem so you know what kind of
    software to build in the first place; we’ll talk briefly about how to structure
    and *design* software and tell you a bit about *testing*, one of the most important
    steps for avoiding software bugs. As you’ll see below, analysis, design and testing
    are all important steps when making software. The actual programming part usually
    takes up only 20% of time on a project (and in this chapter we barely even mention
    it)! Finally, we’ll look at software processes which organise activities including
    analysis, design and testing so that we always know what we should be doing next.
  prefs: []
  type: TYPE_NORMAL
- en: '16.2\. ANALYSIS: WHAT DO WE BUILD?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to start making software, we first have to decide what we actually
    want to make. We call this part of the software project *analysis* because we
    analyse exactly what our software needs to be able to do. Although this sounds
    trivial, getting the details right is pretty tricky. If someone asked you to design
    a physical object like a chair or a toaster, you’d probably have a pretty good
    idea of what the finished product would be like. No matter how many legs you decide
    to put on your chair, they will still have to do the job of holding up a person
    against the force of gravity. When designing software, we often don’t have the
    benefit of creating familiar objects, or even known constraints like the laws
    of physics. If your software was, say, a program to help authors invent imaginary
    worlds, where would you start? What could you take for granted?
  prefs: []
  type: TYPE_NORMAL
- en: Analysis is extremely important. Obviously, if we make a mistake at this stage
    of the project, the software we end up building may not be what we wanted; all
    the other work to design, build and test the software could be for nothing.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine your friend Anna asks you to write a program to help her
    get to school in the morning. You write a great GPS navigation system and show
    it to Anna, but it turns out that she takes to bus to school so what she really
    needed was just software showing the current bus timetable. All your hard work
    was in vain, because you didn’t get the details right in the start!
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we are making software for ourselves; in that case, we can just decide
    what the software should do. (But be careful: even if you think you know what
    you want the software to do when you start developing it, you will probably find
    that by the end of the project you will have a very different view of what it
    should do. The problem is that before you have the software, you can’t really
    predict how you will use it when it’s finished. For example, the people making
    smart phones and software for smart phones probably didn’t anticipate how many
    people would want to use their smart phones as torches!)'
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, we build software for other people. You might make a website
    for your aunt’s clothing shop or write software to help your friends with their
    maths homework. A software company might create software for a local council or
    a GP’s practice. Google and Microsoft make software used by millions of people
    around the world. Either way, whether you’re writing a program for your friends
    or for millions of people, you first have to find out from your customers what
    they actually need the software to do.
  prefs: []
  type: TYPE_NORMAL
- en: We call anyone who has an interest in the software a *stakeholder*. These are
    the people that you need to talk to during the analysis part of your project to
    find out what they need the software to do.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you are making a phone app that allows students to preorder food
    from the school cafeteria. They can use the app to request the food in the morning
    and then just go a pick up the food at lunch time. The idea is that this should
    help streamline the serving of food and reduce queues in the cafeteria. Obvious
    stakeholders for your project are the students (who will be using the phone app)
    and cafeteria staff (who will be receiving requests through the app). Less obvious
    (and indirect) stakeholders include parents (“I have to buy Johnny an iPhone so
    he can use this app?”), school admin (“No phones should be used during school
    time!”) and school IT support who will have to deal with all the students who
    can’t figure out how to work the app. Different stakeholders might have very different
    ideas about what the app should do.
  prefs: []
  type: TYPE_NORMAL
- en: To find out what our stakeholders want the software to do, we usually interview
    them. We ask them questions to find *functional* and *non-functional* requirements
    for the software. Functional requirements are things the software needs to do.
    For example, your phone app needs to allow students to choose the food they want
    to order. It should then send the order to the cafeteria, along with the student’s
    name so that they can be easily identified when picking up the food.
  prefs: []
  type: TYPE_NORMAL
- en: Non-functional requirements, on the other hand, don’t tell us *what* the software
    needs to do but *how* it needs to do it. How efficient does it need to be? How
    reliable? What sort of computer (or phone) does it need to run on? How easy to
    use should it be?
  prefs: []
  type: TYPE_NORMAL
- en: So we first figure out who our stakeholders are and then we go to interview
    them to find the requirements for the software. That doesn’t sound too hard, right?
    Unfortunately, it’s the communication with the customer that often turns out to
    be most difficult.
  prefs: []
  type: TYPE_NORMAL
- en: The first problem is that customers and software engineers often don’t speak
    the same language. Of course, we don’t mean to say that they don’t both speak
    English, but software engineers tend to use technical language, while customers
    use language specific to their work. For example, doctors might use a lot of scary
    medical terms that you don’t understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that a customer asks you to develop a scoring system for the (fictional)
    sport of Whacky-Flob. The customer tells you “It’s really simple. You just need
    to record the foo-whacks, but not the bar-whacks, unless the Flob is circulating”.
    After this description, you’re probably pretty confused because you don’t know
    anything about the sport of Whacky-Flob and don’t know the specific terms used.
    (What on earth are foo-whacks???) To get started, you should attend a few games
    of Whacky-Flob and observe how the game and the scoring works. This way, you’ll
    be able to have a much better conversation with the customer since you have some
    knowledge about the problem domain. (Incidentally, this is one of the cool things
    about being a software engineer: you get exposure to all kinds of different, exciting
    problem domains. One project might be tracking grizzly bears, the next one might
    be identifying cyber terrorists or making a car drive itself.)'
  prefs: []
  type: TYPE_NORMAL
- en: You should also never assume that a customer is familiar with technical terms
    that you might think everyone should know, such as JPEG, database or maybe even
    operating system. Something like “The metaclass subclass hierarchy was constrained
    to be parallel to the subclass hierarchy of the classes which are their instances”
    might make some sense to a software engineer but a customer will just look at
    you very confused! One of the authors once took part in a customer interview where
    the stakeholder was asked if they want to use the system through a browser. Unfortunately,
    the customer had no idea what a browser was. Sometimes, customers may not want
    to admit that they have no idea what you’re talking about and just say “Yes” to
    whatever you suggest. Remember, it’s up to you to make sure you and your customer
    understand each other and that you get useful responses from your customer during
    the interview!
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae30e196ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Even if you manage to communicate with a customer, you might find that they
    don’t really know what they want the software to do or can’t express it. They
    might say they want “software to improve their business” or to “make their work
    more efficient” but that’s not very specific. (There’s a great cartoon of [Dilbert](http://dilbert.com/strips/comic/2006-01-29/) which
    illustrates this point!) When you show them the software you have built, they
    can usually tell you if that’s what they wanted or what they like and don’t like
    about it. For that reason, it’s a good idea to build little prototypes while you’re
    developing your system and keep showing them to customers to get feedback from
    them.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll often find that customers have a specific process that they follow already
    and want the software to fit in with that. We were once involved in a project
    being done by university students for a library. Their staff used to write down
    information about borrowed items three times on a paper form, cut up the form
    and send the pieces to different places as records. When the students interviewed
    them, they asked for a screen in the program where they could enter the information
    three times as well (even though in a computer system there really isn’t much
    point in that)!
  prefs: []
  type: TYPE_NORMAL
- en: Customers are usually experts in their field and are therefore likely to leave
    out information that they think is obvious, but may not be obvious to you. Other
    times, they do not really understand what can and cannot be done with computers
    and may not mention something because they do not realise that it is possible
    to do with a computer. Again, it’s up to you to get this information from them
    and make sure that they tell you what you need to know.
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple stakeholders, you can get conflicting viewpoints. For example,
    when you talk to the cafeteria people about your food-ordering app, they may suggest
    that every student should only be able to order food up to a value of $10\. In
    this way, they want to avoid prank orders. When you talk to a teacher, they agree
    with this suggestions because they are worried about bullying. They don’t want
    one student to get pressured into ordering food for lots of other students. But
    the students tell you that they want to be able to order food for their friends.
    In their view, $10 isn’t even enough for one student.
  prefs: []
  type: TYPE_NORMAL
- en: What do you do about these conflicting points of view? Situations like this
    can be difficult to handle, depending on the situation, the stakeholders and the
    software you are making. In this case, you need the support from the cafeteria
    and the teachers for your software to work, but maybe you could negotiate a slightly
    higher order limit of $20 to try to keep all your stakeholders happy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, even if you get everything right during the analysis stage of your
    project, talk to all the stakeholders and find all the requirements for the software,
    requirements can change while you’re making the software. Big software projects
    can take years to complete. Imagine how much changes in the technology world in
    a year! While you’re working on the project, new hardware (phones, computers,
    tablets, …) could come out or a competitor might release software very similar
    to what you’re making. Your software itself might change the situation: once the
    software is delivered, the customer will try working with it and may realise it
    isn’t what they really wanted. So you should never take the requirements for your
    software to be set in stone. Ideally, you should keep talking to customers regularly
    throughout the project and always be ready for changes in requirements!'
  prefs: []
  type: TYPE_NORMAL
- en: '16.2.1\. PROJECT: FINDING THE REQUIREMENTS'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this project, you need to find someone for whom you could develop software.
    This could be someone from your family or a friend. They might, for example, need
    software to manage information about their business’ customers or their squash
    club might want software to schedule squash tournaments or help with the timetabling
    of practices. (For this project, you won’t actually be making the software, just
    looking at the requirements; if the project is small enough for you to program
    on your own, it’s probably not big enough to be a good example for software engineering!)
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve found a project, start by identifying and describing the stakeholders
    for your project. (This project will work best if you have at least two different
    stakeholders.) Try to find all the stakeholders, remembering that some of them
    might only have an indirect interest in your software. For example, if you are
    making a database to store customer information, the customers whose information
    is being stored have some interest in your software even though they never use
    it directly; for example, they will want the software to be secure so that their
    data cannot be stolen. Write up a description about each stakeholder, giving as
    much background detail as possible. Who are they? What interest do they have in
    the software? How much technical knowledge do they have? …
  prefs: []
  type: TYPE_NORMAL
- en: Interview *one* of the stakeholders to find out what they want the software
    to do. Write up the requirements for your software, giving some detail about each
    requirement. Try to distinguish between functional and non-functional requirements.
    Make sure you find out from your stakeholder which things are most important to
    them. This way you can give each requirement a priority (for example high, medium,
    low), so that if you would actually build the software you could start with the
    most important features.
  prefs: []
  type: TYPE_NORMAL
- en: For the other stakeholders, try to imagine what their requirements would be.
    In particular, try to figure out how the requirements would differ from the other
    stakeholders. It’s possible that two stakeholders have the same requirements but
    in that case maybe they have different priorities? See if you can list any potential
    disagreements or conflicts between your stakeholders? If so, how would you go
    about resolving them?
  prefs: []
  type: TYPE_NORMAL
- en: '16.3\. DESIGN: HOW DO WE BUILD IT?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have decided what your software needs to be able to do, you can actually
    build it. But just blindly starting to program is likely to get you into trouble;
    remember that most software is huge and very complex. You need to somehow minimise
    the amount of complexity in software, otherwise it will become impossible to understand
    and maintain for other developers in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Software design is all about managing this complexity and making sure that the
    software we create has a good structure. Before we start writing any code, we
    design the structure of our software in the *design* phase of the project. When
    you talk about software design, many people will think that you’re talking about
    designing what the software will look like. Here, we’re actually going to look
    at designing the *internal* structure of software.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how can we design software in a way that it doesn’t end up hugely complex
    and impossible to understand? Here, we give you an introduction to two important
    approaches: subdivision and abstraction. Those are pretty scary words, but as
    you’ll see soon, the concepts behind them are surprisingly simple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can probably already guess what *subdivision* means: We break the software
    into many smaller parts that can be built independently. Each smaller part may
    again be broken into even smaller parts and so on. As we saw in the introduction,
    a lot of software is so large and complex that a single person cannot understand
    it all; we can deal much more easily with smaller parts. Large software is developed
    by large teams so different people can work on different parts and develop them
    in parallel, independently of each other. For example, for your cafeteria project,
    you might work on developing the database that records what food the cafeteria
    sells and how much each item costs, while your friend works on the actual phone
    app that students will use to order food.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have developed all the different parts, all we need to do is make them
    communicate with each other. If the different parts have been designed well, this
    is relatively easy. Each part has a so-called *interface* which other parts can
    use to communicate with it. For example, your part of the cafeteria project should
    provide a way for another part to find out what food is offered and how much each
    item costs. This way, your friend who is working on the phone app for students
    can simply send a request to your part and get this information. Your friend shouldn’t
    need to know exactly how your part of the system works; they should just be able
    to send off a request and trust that the answer they get from your part is correct.
    This way, each person working on the project only needs to understand how their
    own part of the software works.
  prefs: []
  type: TYPE_NORMAL
- en: Ok, so let’s talk about the second concept, *abstraction*. Have you ever thought
    about why you can drive a car without knowing how its engine works? Or how you
    can use a computer without knowing much about hardware? Maybe you know what a
    processor and a hard drive is but could you build your own computer? Could your
    parents? We don’t need to know exactly how computers or cars work internally to
    be able to use them thanks to abstraction!
  prefs: []
  type: TYPE_NORMAL
- en: If we look more closely at a computer, we can see that it actually has a number
    of *layers* of abstraction. Right at the bottom, we have the hardware, including
    the processor, RAM, hard disk and various complicated looking circuit boards,
    cables and plugs.
  prefs: []
  type: TYPE_NORMAL
- en: When you boot your computer, you start running the operating system. The operating
    system is in charge of communicating with the hardware, usually through special
    driver software. Once you’ve started your computer, you can run programs, for
    example your browser. The browser actually doesn’t communicate with the hardware
    directly but always goes through the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’re the top layer of the system. You use the program but you will
    (hopefully) never have to interact with the more complicated parts of the operating
    system such as driver software, let alone the hardware. In this way, you can use
    the computer without ever having to worry about these things.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae30d55358.png)'
  prefs: []
  type: TYPE_IMG
- en: We call a system like this a *layered system*. You can have any number of layers
    you want but each layer can only communicate with the one directly below it. The
    operating system can directly access the hardware but a program running on the
    computer can’t. You can use programs but hopefully will never have to access the
    hardware or the more complex parts of the operating system such as drivers. This
    again reduces the complexity of the system because each layer only needs to know
    about the layer directly below it, not any others.
  prefs: []
  type: TYPE_NORMAL
- en: Each layer in the system needs to provide an interface so that the layer above
    it can communicate with it. For example, a processor provides a set of instructions
    to the operating system; the operating system provides commands to programs to
    create or delete files on the hard drive; a program provides buttons and commands
    so that you can interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: One layer knows nothing about the internal workings of the layer below; it only
    needs to know how to use the layer’s interface. In this way, the complexity of
    lower layers is completely hidden, or *abstracted*. Each layer represents a higher
    level of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: So each layer hides some complexity, so that as we go up the layers things remain
    manageable. Another advantage of having layers is that we can change one layer
    without affecting the others, as long as we keep the layer’s interface the same
    of course. For example, your browser’s code might change but you might never notice
    as long as the browser still looks and works the same as before. Of course, if
    the browser stops working or new buttons appear suddenly you know that something
    has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have the same “layered” approach inside a single program. For example,
    websites are often designed as so-called *three-tier* systems with three layers:
    a database layer, a logic layer and a presentation layer. The database layer usually
    consists of a database with the data that the website needs. For example, Facebook
    has a huge database where it keeps information about its users. For each user,
    it stores information about who their friends are, what they have posted on their
    wall, what photos they have added, and so on. The logic layer processes the data
    that it gets from the database. Facebook’s logic layer, for example, will decide
    which posts to show on your “Home” feed, which people to suggest as new friends,
    etc. Finally, the presentation layer gets information from the logic layer which
    it displays. Usually, the presentation layer doesn’t do much processing on the
    information it gets but simply creates the HTML pages that you see.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae30c9341c.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Curiosity: Reuse - Kangaroos and Helicopters**'
  prefs: []
  type: TYPE_NORMAL
- en: Since building software is so difficult and time-consuming, a popular idea has
    been to reuse existing software. Not surprisingly, we call this *software reuse*.
    It’s a great idea in theory (why recreate something that already exists?) but
    turns out to be difficult to put into practice partly because existing software
    is also huge and complicated. Usually when you reuse software, you want only a
    small part of the existing software’s functionality, rather than everything.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting story that illustrates the problems with software reuse (although
    it is unfortunately not completely accurate, see[http://www.snopes.com/humor/nonsense/kangaroo.asp](http://www.snopes.com/humor/nonsense/kangaroo.asp))
    is that of helicopters and kangaroos. The Australian Air Force was developing
    a new helicopter simulator to train pilots. They wanted the simulator to be as
    realistic as possible and therefore decided to include herds of kangaroos in the
    simulation. To save time, they reused code from another simulator which included
    foot soldiers and simply changed the icons of the soldiers to kangaroos.
  prefs: []
  type: TYPE_NORMAL
- en: Once the program was finished, they demonstrated it to some pilots. One of the
    pilots decided to fly the helicopter close to a herd of kangaroos to see what
    would happen. The kangaroos scattered to take cover when the helicopter approached
    (so far so good) but then, to the pilot’s extreme surprise, pulled out their guns
    and missile launchers and fired at the helicopter. It seemed the programmer had
    forgotten to remove *that* part of the code from the original simulator.
  prefs: []
  type: TYPE_NORMAL
- en: '16.3.1\. PROJECT: DESIGNING YOUR SOFTWARE'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Think back to the requirements you found in the analysis project described above.
    In this project, we will look at how to design the software.
  prefs: []
  type: TYPE_NORMAL
- en: Start by thinking about how the software you are trying to build can be broken
    up into smaller parts. Maybe there is a database or a user interface or a website?
    For example, imagine you are writing software to control a robot. The robot needs
    to use its sensors to follow a black line on the ground until it reach a target.
    The software for your robot should have a part that interacts with the sensors
    to get information about what they “see”. It should then pass this information
    to another part, which analyses the data and decides where to move next. Finally,
    you should have a part of the software which interacts with the robot’s wheels
    to make it move in a given direction.
  prefs: []
  type: TYPE_NORMAL
- en: Try to break down your software into as many parts as possible (remember, small
    components are much easier to build!) but don’t go too far - each part should
    perform a sensible task and be relatively independent from the rest of the system.
  prefs: []
  type: TYPE_NORMAL
- en: For each part that you have identified, write a brief description about what
    it does. Then think about how the parts would interact. For each part, ask yourself
    which other parts it needs to communicate with directly. Maybe a diagram could
    help visualise this?
  prefs: []
  type: TYPE_NORMAL
- en: '16.4\. TESTING: DID WE BUILD THE RIGHT THING / DOES IT WORK?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve decided what our software should do (analysis) and designed its internal
    structure (design), and the system has been programmed according to the design.
    Now, of course, we have to test it to make sure it works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is an incredibly important part of developing software. We cannot really
    release software that still has lots of bugs to our customers. (Well, we could
    but our customers wouldn’t be very happy about it.) Remember that software bugs
    can have both very small and very large effects. On the less serious end of the
    scale, they might make a program difficult to use or crash your computer. On the
    other hand, they can cost millions of dollars and even endanger human life. More
    testing might have prevented the Ariane 5 failure or might have discovered the
    Therac bug which ended up killing 3 patients.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, testing is again really difficult because of the size and complexity
    of software. If a piece of software would take years to read and understand, imagine
    how long it would take to fully test it!
  prefs: []
  type: TYPE_NORMAL
- en: When we test software, we try lots of different inputs and see what outputs
    or behaviour the software produces. If the output is incorrect, we have found
    a bug.
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity: Bugs and Moths**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae306e1fde.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In 1947, engineers working on a computer called the *Mark II* were investigating
    a computer error and found that it was caused by a moth which had become trapped
    inside the computer! Since then, we use the word *bug* to refer to computer errors.
    Of course, today we use the word to refer to errors in programs, rather than actual
    insects trapped in the computer.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with testing is that it can only show the presence of errors, not
    their absence! If you get an incorrect output from the program, you know that
    you have found a bug. But if you get a correct output, can you really conclude
    that the program is correct? Not really. The software might work in this particular
    case but you cannot assume that it will work in other cases. No matter how thoroughly
    you test a program, you can never really be 100% sure that it’s correct. In theory,
    you would have to test every possible input to your system, but that’s not usually
    possible. Imagine testing Google for everything that people could search for!
    But even if we can’t test everything, we can try as many different test cases
    as possible and hopefully at least decrease the probability of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: As with design, we can’t possibly deal with the entire software at once, so
    we again just look at smaller pieces, testing one of them at a time. We call this
    approach *unit testing*. A unit test is usually done by a separate program which
    runs the tests on the program that you’re writing. That way you can run the tests
    as often as you like — perhaps once a day, or even every time there is a change
    to the program. It’s not unusual to write a unit test program before you write
    the actual program. It might seem like wasted work to have to write two programs
    instead of one, but being able to have your system tested carefully any time you
    make a change greatly improves the reliability of your final product, and can
    save a lot of time trying to find bugs in the overall system, since you have some
    assurance that each unit is working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the separate pieces have been tested thoroughly, we can test the whole
    system to check if all the different parts work together correctly. This is called*integration
    testing*. Some testing can be automated while other testing needs to be done manually
    by the software engineer.
  prefs: []
  type: TYPE_NORMAL
- en: If I give you a part of the software to test, how would you start? Which test
    inputs would you use? How many different test cases would you need? When would
    you feel reasonably sure that it all works correctly?
  prefs: []
  type: TYPE_NORMAL
- en: There are two basic approaches you can take, which we call *black-box testing* and *white-box
    testing*. With black-box testing, you simply treat the program as a black box
    and pretend you don’t know how it’s structured and how it works internally. You
    give it test inputs, get outputs and see if the program acts as you expected.
  prefs: []
  type: TYPE_NORMAL
- en: But how do you select useful test inputs? There are usually so many different
    ones to choose from. For example, imagine you are asked to test a program that
    takes a whole number and outputs its successor, the next larger number (e.g. give
    it 3 and you get 4, give it -10 and you get -9, etc). You can’t try the program
    for *all* numbers so which ones do you try?
  prefs: []
  type: TYPE_NORMAL
- en: You observe that many numbers are similar and if the program works for one of
    them it’s probably safe to assume it works for other similar numbers. For example,
    if the program works as you expect when you give it the number 3, it’s probably
    a waste of time to also try 4, 5, 6 and so on; they are just so similar to 3.
  prefs: []
  type: TYPE_NORMAL
- en: This is the concept of *equivalence classes*. Some inputs are so similar, you
    should only pick one or two and if the software works correctly for them you assume
    that it works for all other similar inputs. In the case of our successor program
    above, there are two big equivalence classes, positive numbers and negative numbers.
    You might also argue that zero is its own equivalence class, since it is neither
    positive nor negative.
  prefs: []
  type: TYPE_NORMAL
- en: For testing, we pick a couple of inputs from each equivalence class. The inputs
    at the boundary of equivalence classes are usually particularly interesting. Here,
    we should definitely test -1 (this should output 0), 0 (this should output 1)
    and 1 (this should output 2). We should also try another negative and positive
    number not from the boundary, such as -48 and 57\. Finally, it can be interesting
    to try some very large numbers, so maybe we’ll take -2,338,678 and 10,462,873\.
    We have only tested 7 different inputs, but these inputs will probably cover most
    of the interesting behaviour of our software and should reveal most bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you might also want to try some invalid inputs, for example “hello”
    (a word) or “1,234” (a number with a comma in it) or “1.234” (a number with a
    decimal point). Often, test cases like these can get programs to behave in a very
    strange way or maybe even crash because the programmer hasn’t considered that
    the program might be given invalid inputs. Remember that especially human users
    can give you all sorts of weird inputs, for example if they misunderstand how
    the program should be used. In case of an invalid input, you probably want the
    program to tell the user that the input is invalid; you definitely don’t want
    it to crash!
  prefs: []
  type: TYPE_NORMAL
- en: Black-box testing is easy to do but not always enough because sometimes finding
    the different equivalence classes can be difficult if you don’t know the internal
    structure of the program. When we do white-box testing, we look at the code we
    are testing and come up with test cases that will execute as many different lines
    of code as possible. If we execute each line at least once, we should be able
    to discover a lot of bugs. We call this approach *code coverage* and aim for 100%
    coverage, so that each line of code is run at least once. In reality, even 100%
    code coverage won’t necessarily find all bugs though, because one line of code
    might work differently depending on inputs and values of variables in a program.
    Still, it’s a pretty good start.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is very useful for finding bugs. It helps us find out if the program
    works as *we* intended. Another important question during testing is if the software
    does what the *customer* wanted (Did we build the right thing?). *Acceptance testing* means
    showing your program to your stakeholders and getting feedback about what they
    like or don’t like. Any mistakes that we made in the analysis stage of the project
    will probably show up during acceptance testing. If we misunderstood the customer
    during the interview, our *unit tests* might pass (i.e. the software does what
    we thought it should) but we may still have an unhappy customer.
  prefs: []
  type: TYPE_NORMAL
- en: Different stakeholders can be very different, for example in terms of technical
    skills, or even could have given us conflicting requirements for the software.
    It’s therefore of course possible to get positive feedback from one stakeholder
    and negative feedback from another.
  prefs: []
  type: TYPE_NORMAL
- en: '16.4.1\. PROJECT: ACCEPTANCE TESTING'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this project, choose a small program such as a Windows desktop gadget or
    an Apple dashboard widget. (For example, you can find a good selection of Windows
    gadgets at [http://www.thoosje.com/desktop-gadgets-gallery.html](http://www.thoosje.com/desktop-gadgets-gallery.html))
    Pick something that you find particularly interesting or useful! Start by reading
    the description of the program to find out what it does *before* you try it out.
  prefs: []
  type: TYPE_NORMAL
- en: Next, think about a stakeholder for this software. Who would use it and why?
    Briefly write down some background information about the stakeholder (as in the
    analysis project) and their main requirements. Note which requirements would be
    most important to them and why.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can go ahead and install the program and play around with it. Try
    to imagine that you are the stakeholder that you described above. Put yourself
    in this person’s shoes. How would they feel about this program? Does it meet your
    requirements? What important features are missing? Try to see if you can find
    any particular problems or bugs in the program. (Tip: sometimes giving programs
    unexpected input, for example a word when they were expecting a number, can cause
    some interesting behaviour.)'
  prefs: []
  type: TYPE_NORMAL
- en: Write up a brief acceptance test report about what you found. Try to link back
    to the requirements that you wrote down earlier, noting which have been met (or
    maybe partially met) and which haven’t. Do you think that overall the stakeholder
    would be happy with the software? Do you think that they would be likely to use
    it? Which features would you tell the software developers to implement next?
  prefs: []
  type: TYPE_NORMAL
- en: 16.5\. SOFTWARE PROCESSES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far in this chapter, you’ve learned about different phases of software development:
    analysis, design and testing. But how do these phases fit together? At what time
    during the project do we do what activity? That’s the topic of *software processes*.'
  prefs: []
  type: TYPE_NORMAL
- en: The obvious answer would be to start with analysis to figure out what we want
    to build, then design the structure of the software, implement everything and
    finally test the software. This is the simplest software process called the *waterfall
    process*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae306154cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The waterfall process is borrowed from other kinds of engineering. If we want
    to build a bridge, we go through the same phases of analysis, design, implementation
    and testing: we decide what sort of bridge we need (How long should it be? How
    wide? How much load should it be able to support?), design the bridge, build it
    and finally test it before we open it to the public. It’s been done that way for
    many decades and works very well, for bridges at least.'
  prefs: []
  type: TYPE_NORMAL
- en: We call this process the waterfall process because once you “jump” from one
    phase of the project to the next, you can’t go back up to the previous one. In
    reality, a little bit of backtracking is allowed to fix problems from previous
    project phases but such backtracking is usually the exception. If during the testing
    phase of the project you suddenly find a problem with the requirements you certainly
    won’t be allowed to go back and rewrite the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae30540347.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An advantage of the waterfall process is that it’s very simple and easy to
    follow. At any point in the project, it’s very clear what stage of the project
    you are at. This also helps with planning: if you’re in the testing stage you
    know you’re quite far into the project and should finish soon. For these reasons,
    the waterfall process is very popular with managers who like to feel in control
    of where the project is and where it’s heading.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity: Hofstadter’s law**'
  prefs: []
  type: TYPE_NORMAL
- en: Your manager and customer will probably frequently ask you how much longer the
    project is going to take and when you will finally have the finished program.
    Unfortunately, it’s really difficult to know how much longer a project is going
    to take. According to Hofstadter’s law, “It always takes longer than you expect,
    even when you take into account Hofstadter’s Law.”
  prefs: []
  type: TYPE_NORMAL
- en: Because it’s just so nice and simple, the waterfall process is still in many
    software engineering textbooks and is widely used in industry. The only problem
    with this is that the waterfall process just does not work for most software projects.
  prefs: []
  type: TYPE_NORMAL
- en: So why does the waterfall process not work for software when it clearly works
    very well for other engineering products like bridges (after all, most bridges
    seem to hold up pretty well...)? First of all, we need to remember that software
    is very different from bridges. It is far more complex. Understanding the plans
    for a single bridge and how it works might be possible for one person but the
    same is not true for software. We cannot easily look at software as a whole (other
    than the code) to see its structure. It is not physical and thus does not follow
    the laws of physics. Since software is so different from other engineering products,
    there really is no reason why the same process should necessarily work for both.
  prefs: []
  type: TYPE_NORMAL
- en: To understand why the waterfall process doesn’t work, think back to our section
    about analysis and remember how hard it is to find the right requirements for
    software. Even if you manage to communicate with the customers and resolve conflicts
    between the stakeholders, the requirements could still change while you’re developing
    the software. Therefore, it is very unlikely that you will get the complete and
    correct requirements for the software at the start of your project.
  prefs: []
  type: TYPE_NORMAL
- en: If you make mistakes during the analysis phase, most of them are usually found
    in the testing stage of the project, particularly when you show the customer your
    software during acceptance testing. At this point, the waterfall process doesn’t
    allow you to go back and fix the problems you find. Similarly, you can’t change
    the requirements halfway through the process. Once the analysis phase of the project
    is finished, the waterfall process “freezes” the requirements. In the end of your
    project, you will end up with software that hopefully fulfills *those* requirements,
    but it is unlikely that those will be the *correct* requirements. You end up having
    to tell the customer that they got what they asked for, not what they needed.
    If they’ve hired you, they’ll be annoyed; it it’s software that you’re selling
    (such as a smartphone app), people just won’t bother buying it.
  prefs: []
  type: TYPE_NORMAL
- en: You can also get things wrong at other points in the project. For example, you
    might realise while you’re writing the code that the design you came up with doesn’t
    really work. But the waterfall process tells you that you have to stick with it
    anyway and make it work somehow.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae2e58b4b2.png)'
  prefs: []
  type: TYPE_IMG
- en: Design by [Paragon Innovations](http://www.paragoninnovations.com/guide.shtml) and
    drawn by [Project Cartoon](http://www.projectcartoon.com/about/)
  prefs: []
  type: TYPE_NORMAL
- en: So if the waterfall process doesn’t work, what can we do instead? Most modern
    software development processes are based on the concept of iteration. We do a
    bit of analysis, followed by some design, some programming and some testing. (We
    call this one iteration.) This gives us a rather rough prototype of what the system
    will look like. We can play around with the prototype, show it to customers and
    see what works and what doesn’t. Then, we do the whole thing again. We refine
    our requirements and do some more design, programming and testing to make our
    prototype better (another iteration). Over time, the prototype grows into the
    final system, getting closer and closer to what we want.
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae2e45b08e.png)'
  prefs: []
  type: TYPE_IMG
- en: The advantage with this approach is that if you make a mistake, you will find
    it soon (probably when you show the prototype to the customer the next time) and
    have the opportunity to fix it. The same is true if requirements change suddenly;
    you are flexible and can respond to changes quickly. You also get a lot of feedback
    from the customers as they slowly figures out what they need.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of different software processes that use iteration (we call
    them *iterative processes*); a famous one is the *spiral model*. Although the
    details of the different processes vary, they all use the same iteration structure
    and tend to work very well for software.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the question of what we do at what point of the project, another
    interesting question addressed by software processes is how much time we should
    spend on the different project phases. You might think that the biggest part of
    a software project is programming, but in a typical project, programming usually
    takes up only about 20% of the total time! 40% is spent on analysis and design
    and another 40% on testing. This shows that software engineering is so much more
    than programming.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve finished developing your program and given it to the customer, the
    main part of the software project is over. Still, it’s important that you don’t
    just stop working on it. The next part of the project, which can often go on for
    years, is called *maintenance*. During this phase you fix bugs, provide customer
    support and maybe add new features that customers need.
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity: Brooks’s law**'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that your project is running late and your customer is getting impatient.
    Your first instinct might be to ask some of your friends if they can help out
    so that you have more people working on the project. Brooks’s law, however, suggests
    that that is exactly the wrong thing to do!
  prefs: []
  type: TYPE_NORMAL
- en: Brooks’s law states that “adding manpower to a late software project makes it
    later.” This might seem counterintuitive at first because you would assume that
    more people would get more work done. However, the overhead of getting new people
    started on the project (getting them to understand what you are trying to build,
    your design, the existing code, and so on) and of managing and coordinating the
    larger development team actually makes things slower rather than faster in the
    short term.
  prefs: []
  type: TYPE_NORMAL
- en: '16.5.1\. ACTIVITY: FUN WITH THE WATERFALL PROCESS'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The waterfall process is simple and commonly used but doesn’t really work in
    practice. In this activity, you’ll get to see why. First, you will create a design
    which you then pass on to another group. They have to implement your design exactly
    and are not allowed to make any changes, even if it doesn’t work!
  prefs: []
  type: TYPE_NORMAL
- en: You need a deck of cards and at least 6 people. Start by dividing up into groups
    of about 3-4 people. You need to have at least 2 groups. Each group should grab
    two chairs and put them about 30cm apart. The challenge is to build a bridge between
    the two chairs using only the deck of cards!
  prefs: []
  type: TYPE_NORMAL
- en: Before you get to build an actual bridge, you need to think about how you are
    going to make a bridge out of cards. Discuss with you team members how you think
    this could work and write up a short description of your idea. Include a diagram
    to make your description understandable for others.
  prefs: []
  type: TYPE_NORMAL
- en: Now exchange your design with another group. Use the deck of cards to try to
    build your bridge to the exact specification of the other group. You may not alter
    their design in any way (you are following the waterfall process here!). As frustrating
    as this can be (especially if you know how to fix the design), if it doesn’t work,
    it doesn’t work!
  prefs: []
  type: TYPE_NORMAL
- en: If you managed to build the bridge, congratulations to you and the group that
    managed to write up such a good specification! If you didn’t, you now have a chance
    to talk to the other group and give them feedback about the design. Tell them
    about what problems you had and what worked or didn’t work. The other group will
    tell you about the problems they had with your design!
  prefs: []
  type: TYPE_NORMAL
- en: Now, take your design back and improve it, using what you just learnt about
    building bridges out of cards and what the other group told you. You can experiment
    with cards as you go, and keep changing the design as you learn about what works
    and what doesn’t (this is an agile approach). Keep iterating (developing ideas)
    until you get something that works.
  prefs: []
  type: TYPE_NORMAL
- en: Which of these two approaches worked best — designing everything first, or doing
    it in the agile way?
  prefs: []
  type: TYPE_NORMAL
- en: '16.5.2\. ACTIVITY: A NAVIGATION LANGUAGE'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this activity, you will develop a language for navigating around your school.
    Imagine that you need to describe to your friend how to get to a particular classroom.
    This language will help you give a precise description that your friend can easily
    follow.
  prefs: []
  type: TYPE_NORMAL
- en: First, figure out what your language has to do (i.e. find the *requirements*).
    Will your language be for the entire school or only a small part? How exact will
    the descriptions be? How long will the descriptions be? How easy will they be
    to follow for someone who does / doesn’t know your language? How easy will it
    be to learn? …
  prefs: []
  type: TYPE_NORMAL
- en: Now, go ahead and *design* the language. Come up with different commands (e.g.
    turn left, go forward 10, …). Make sure you have all the commands you need to
    describe how to get from one place in your school to any other!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, *test* the language using another student. Don’t tell them where they’re
    going, just give them instructions and see if they follow them correctly. Try
    out different cases until you are sure that your language works and that you have
    all the commands that you need. If you find any problems, go back and fix them
    and try again!
  prefs: []
  type: TYPE_NORMAL
- en: Note down how much time each of the different phases of the project take you.
    When you have finished, discuss how much time you spent on each phase and compare
    with other students. Which phase was the hardest? Which took the longest? Do you
    think you had more time for some of the phases? What problems did you encounter?
    What would you do differently next time around?
  prefs: []
  type: TYPE_NORMAL
- en: '16.5.3\. ACTIVITY: BLOCK BUILDING (PRECISE COMMUNICATION)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Communicating clearly with other software engineers and customers is essential
    for software engineers. In this activity, you get to practice communicating as
    precisely as possible!
  prefs: []
  type: TYPE_NORMAL
- en: Divide up into pairs, with one *creator* and one *builder* in each pair. Each
    person needs a set of at least 10 coloured building blocks (e.g. lego blocks).
    Make sure that each pair has a matching set of blocks or this activity won’t work!
  prefs: []
  type: TYPE_NORMAL
- en: The two people in each pair should not be able to see each other but need to
    be able to hear each other to communicate. Put up a screen between the people
    in each pair or make them face in opposite directions. Now, the creator builds
    something with their blocks. The more creative you are the more interesting this
    activity will be!
  prefs: []
  type: TYPE_NORMAL
- en: When the creator has finished building, it’s the builders turn. His or her aim
    is to build an exact replica of the creator’s structure (but obviously without
    knowing what it looks like). The creator should describe exactly what they need
    to do with the blocks. For example, the creator could say “Put the small red block
    on the big blue block” or “Stand two long blue blocks up vertically with a one
    block spacing between them, and then balance a red block on top of them”. But
    the creator should not describe the building as a whole (“Make a doorframe.”).
  prefs: []
  type: TYPE_NORMAL
- en: When the builder thinks they are done, compare what you built! How precise was
    your communication? Which parts were difficult to describe for the creator / unclear
    for the builder? Switch roles so that you get to experience both sides!
  prefs: []
  type: TYPE_NORMAL
- en: 16.6\. AGILE SOFTWARE DEVELOPMENT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Agile* software development has become popular over the last 10 years; the
    two most famous agile processes are called [XP](http://en.wikipedia.org/wiki/Extreme_programming) and [Scrum](http://en.wikipedia.org/wiki/Scrum_(development)).
    Agile software development is all about being extremely flexible and adaptive
    to change. Most other software processes try to manage and control changes to
    requirements during the process; agile processes accept and expect change.'
  prefs: []
  type: TYPE_NORMAL
- en: Agile processes work similarly to iterative processes in that they do a number
    of iterations of analysis, design, implementation and testing. However, these
    iterations are extremely short, each usually lasting only about 2 weeks.
  prefs: []
  type: TYPE_NORMAL
- en: In many other processes, documentation is important. We document the requirements
    so that we can look back at them; we document our design so that we can refer
    back to it when we program the system. Agile software processes expect things
    to change all the time. Therefore, they do very little planning and documentation
    because documenting things that will change anyway is a bit of a waste of time.
  prefs: []
  type: TYPE_NORMAL
- en: Agile processes include lots of interesting principles that are quite different
    from standard software development. We look at the most interesting ones here.
    If you want to find out more, have a look at [Agile Academy on Youtube](http://www.youtube.com/user/AgileAcademyAus) which
    has lots of videos about interesting agile practices! There’s also [another video
    here](http://www.youtube.com/watch?v=kqz_jDS0RWY) which explains the differences
    between agile software development and the waterfall process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some general principles used for agile programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pair-programming**'
  prefs: []
  type: TYPE_NORMAL
- en: Programming is done in pairs with one person coding while the other person watches
    and looks for bugs and special cases that the other might have missed. It’s simply
    about catching small errors before they become bugs. After all, 4 eyes see more
    than 2.
  prefs: []
  type: TYPE_NORMAL
- en: You might think that pair-programming is not very efficient and that it would
    be more productive to have programmers working separately; that way, they can
    write more code more quickly, right? Pair-programming is about reducing errors.
    Testing, finding and fixing bugs is hard; trying not to create them in the first
    place is easier. As a result, pair-programming has actually been shown to be more
    efficient than everyone programming by themselves!
  prefs: []
  type: TYPE_NORMAL
- en: '**YAGNI**'
  prefs: []
  type: TYPE_NORMAL
- en: YAGNI stands for “You ain’t gonna need it” and tells developers to keep things
    simple and only design and implement the things that you know you are really going
    to need. It can be tempting to think that in the future you might need feature
    x and so you may as well already create it now. But remember that requirements
    are likely to change so chances are that you won’t need it after all.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ae2e3d146f.png)](http://xkcd.com/974/)'
  prefs: []
  type: TYPE_NORMAL
- en: You ain’t gonna need it!
  prefs: []
  type: TYPE_NORMAL
- en: '**Constant testing**'
  prefs: []
  type: TYPE_NORMAL
- en: Agile processes take testing very seriously. They usually rely on having lots
    of automated unit tests that are run at least once a day. That way, if a change
    is made (and this happens often), we can easily check if this change has introduced
    an unexpected bug.
  prefs: []
  type: TYPE_NORMAL
- en: '**Refactoring**'
  prefs: []
  type: TYPE_NORMAL
- en: There are many different ways to design and program a system. YAGNI tells you
    to start by doing the simplest thing that’s possible. As the project develops,
    you might have to change the original, simple design. This is called *refactoring*.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring means to change your design or implementation without changing the
    program’s behaviour. After a refactoring, the program will work exactly the same,
    but will be better structured in some way. Unit tests really come in handy here
    because you can use them to check that the code works the same way before and
    after the refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring only works on software because it is “soft” and flexible. The same
    concept does not really work for physical engineering products. Imagine that when
    building a bridge, for example, you started off by doing the simplest possible
    thing (putting a plank over the river) and then continually refactored the bridge
    to get the final product.
  prefs: []
  type: TYPE_NORMAL
- en: '**Courage**'
  prefs: []
  type: TYPE_NORMAL
- en: '“Courage” might seem like an odd concept in the context of software development.
    In agile processes, things change all the time and therefore programmers need
    to have the courage to make changes to the code as needed, fix the problems that
    need to be fixed, correct the design where needed, throw away code that doesn’t
    work etc. This might not seem like a big deal, but it can actually be quite scary
    to change code, particularly if the code is complicated or has been written by
    a different person. Unit tests really help by giving you courage: you’ll feel
    more confident to change the code if you have tests that you can run to check
    your work later.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test-driven development**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In standard software development, we first write some code and then test it.
    This makes sense: we need the code before we can test it, right? Test-driven development
    tells you to do the exact opposite!'
  prefs: []
  type: TYPE_NORMAL
- en: Before you write a piece of code, you should write a test for the code that
    you are about to write. This forces you to think about exactly what you’re trying
    to do and what special cases there are. Of course, if you try to run the test,
    it will fail (since the functionality it is testing does not yet exist). When
    you have a failing test, you can then write code to make the test pass.
  prefs: []
  type: TYPE_NORMAL
- en: '**Programmer welfare**'
  prefs: []
  type: TYPE_NORMAL
- en: Software developers should not work more than 40 hours per week. If they do
    overtime one week they should not do more overtime the following week. This helps
    keep software developers happy and makes sure they don’t get overworked.
  prefs: []
  type: TYPE_NORMAL
- en: '**Customer involvement**'
  prefs: []
  type: TYPE_NORMAL
- en: A customer representative should be part of the developing team (ideally spending
    full-time with the team), on hand to answer questions or give feedback at all
    times. This is important to be able to quickly change the requirements or direction
    of the project. If you have to wait 2 weeks until you can get feedback from your
    customer, you will not be able to adapt to change very quickly!
  prefs: []
  type: TYPE_NORMAL
- en: Although having a customer on the development team is a great idea in theory,
    it is quite hard to achieve in practice. Most customers simply want to tell you
    their requirements, pay you and then get the software delivered 5 months later.
    It’s rare to find a customer who is willing and has the time to be more involved
    in the project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity: Christopher Alexander**'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve mainly compared software development to engineering and building
    bridges, but you might have noticed that it’s also pretty similar to architecture.
    In fact, software development (in particular agile software development) has borrowed
    a lot of concepts from architecture. An architect called Christopher Alexander,
    for example, suggested involving customers in the design process. Sound familiar?
    Several other suggestions from Christopher Alexander were also picked up by the
    agile development community and as a result his thinking about architecture has
    shaped how we think about software development. This is despite the fact that
    Christopher Alexander knew nothing about software. He was apparently very surprised
    when he found out how well known he is among software developers!
  prefs: []
  type: TYPE_NORMAL
- en: '16.6.1\. PROJECT: SOFTWARE PROCESSES'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This project will provide insight into a real software engineering process,
    but you’ll need to find a software engineer who is prepared to be interviewed
    about their work. It will be ideal if the person works in a medium to large size
    company, and they need to be part of a software engineering team (i.e. not a lone
    programmer).
  prefs: []
  type: TYPE_NORMAL
- en: The project revolves around interviewing the person about the process they went
    through for some software development they did recently. They may be reluctant
    to talk about company processes, in which case it may help to assure them that
    you will keep their information confidential (your project should only be viewed
    by you and those involved in supervising and marking it; you should state its
    confidential nature clearly at the start so that it doesn’t later get used as
    an exemplar).
  prefs: []
  type: TYPE_NORMAL
- en: You need to do substantial preparation for the interview. Find out about the
    kind of software that the company makes. Read up about software engineering (in
    this chapter) so that you know the main terminology and techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Now prepare a list of questions for the interviewee. These should find out what
    kind of software development processes they use, what aspects your interviewee
    works on, and what the good and bad points are of the process, asking for examples
    to illustrate this.
  prefs: []
  type: TYPE_NORMAL
- en: You should take extensive notes during the interview (and record it if the person
    doesn’t mind).
  prefs: []
  type: TYPE_NORMAL
- en: You then need to write up what you have learned, describing the process, discussing
    the techniques used, illustrating it with examples, and evaluating how well the
    process works.
  prefs: []
  type: TYPE_NORMAL
- en: 16.7\. THE WHOLE STORY!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ve tried to give you an introduction to the challenges of
    creating software and some techniques that software engineers use to overcome
    them. We’ve really only scratched the surface of software analysis, design, testing
    and software processes; there are entire books about each of these areas!
  prefs: []
  type: TYPE_NORMAL
- en: It can be difficult to understand the importance of some of the problems and
    techniques we have described here if you have never worked on a larger software
    project yourself. Some may seem blindingly obvious to you, others may seem irrelevant.
    When you work on your first large project, come back to this chapter and hopefully
    you’ll recognise some of the problems we have described here!
  prefs: []
  type: TYPE_NORMAL
- en: 16.8\. FURTHER READING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 16.8.1\. USEFUL LINKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Wikipedia - Software engineering](http://en.wikipedia.org/wiki/Software_engineering)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CS4FN - Software engineering](http://www.cs4fn.org/fundamentals/softwareeng.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Teach ICT - Systems Life Cycle](http://www.teach-ict.com/as_a2_ict_new/ocr/A2_G063/331_systems_cycle/slc_stages/home_slc.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Software crisis](http://en.wikipedia.org/wiki/Software_crisis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[IEEE - Why software fails](http://spectrum.ieee.org/computing/software/why-software-fails)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Software design](http://en.wikipedia.org/wiki/Software_design)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Abstraction](http://en.wikipedia.org/wiki/Abstraction_(computer_science))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Software testing](http://en.wikipedia.org/wiki/Software_testing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Software development process](http://en.wikipedia.org/wiki/Software_development_process)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Waterfall model](http://en.wikipedia.org/wiki/Waterfall_model)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Iterative and incremental development](http://en.wikipedia.org/wiki/Iterative_and_incremental_development)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Agile software development](http://en.wikipedia.org/wiki/Agile_software_development)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Test driven development](http://en.wikipedia.org/wiki/Test-driven_development)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17\. APPENDICES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[17.1\. GLOSSARY](17.1.%20GLOSSARY.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.2\. CONTRIBUTORS](17.2.%20CONTRIBUTORS.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.3\. INTERACTIVES](17.3.%20INTERACTIVES.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.4\. 1.44 ASSESSMENT GUIDE](17.4.%201.44%20ASSESSMENT%20GUIDE.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.5\. ALGORITHMS (1.44) - SEARCHING ALGORITHMS](17.5.%20ALGORITHMS%20%281.44%29%20-%20SEARCHING%20ALGORITHMS.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.6\. ALGORITHMS (1.44) - SORTING ALGORITHMS](17.6.%20ALGORITHMS%20%281.44%29%20-%20SORTING%20ALGORITHMS.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.7\. HUMAN COMPUTER INTERACTION (1.44)](17.7.%20HUMAN%20COMPUTER%20INTERACTION%20%281.44%29.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.8\. PROGRAMMING LANGUAGES (1.44)](17.8.%20PROGRAMMING%20LANGUAGES%20%281.44%29.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.9\. 2.44 ASSESSMENT GUIDE](17.9.%202.44%20ASSESSMENT%20GUIDE.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.10\. REPRESENTING DATA USING BITS (BINARY NUMBERS) (2.44)](17.10.%20REPRESENTING%20DATA%20USING%20BITS%20%28BINARY%20NUMBERS%29%20%282.44%29.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.11\. REPRESENTING DATA USING BITS (CHARACTERS/TEXT) (2.44)](17.11.%20REPRESENTING%20DATA%20USING%20BITS%20%28CHARACTERS-TEXT%29%20%282.44%29.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.12\. REPRESENTING DATA USING BITS (IMAGES/COLOUR) (2.44)](17.12.%20REPRESENTING%20DATA%20USING%20BITS%20%28IMAGES-COLOUR%29%20%282.44%29.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.13\. COMPRESSION (2.44) - RUN LENGTH ENCODING](17.13.%20COMPRESSION%20%282.44%29%20-%20RUN%20LENGTH%20ENCODING.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.14\. ENCRYPTION (2.44) - RSA CRYPTOSYSTEM](17.14.%20ENCRYPTION%20%282.44%29%20-%20RSA%20CRYPTOSYSTEM.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.15\. ERROR CONTROL CODING (2.44) - CHECK SUMS](17.15.%20ERROR%20CONTROL%20CODING%20%282.44%29%20-%20CHECK%20SUMS.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.16\. ARTIFICIAL INTELLIGENCE (3.44) - TURING TEST](17.16.%20ARTIFICIAL%20INTELLIGENCE%20%283.44%29%20-%20TURING%20TEST.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.17\. FUTURE PLANS FOR THE FIELD GUIDE](17.17.%20FUTURE%20PLANS%20FOR%20THE%20FIELD%20GUIDE.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.18\. GUIDE TO SYSTEM FOR OPEN SOURCE DEVELOPERS](17.18.%20GUIDE%20TO%20SYSTEM%20FOR%20OPEN%20SOURCE%20DEVELOPERS.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 17.1\. GLOSSARY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ALC
  prefs: []
  type: TYPE_NORMAL
- en: Apple Lossless Coding, a lossless compression method for audio.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm a process for achieving an outcome, normally for a general problem
    such as searching, sorting, finding an optimal path through a map and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm analysis
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm analysis working out the complexity of an algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm complexity
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm complexity how long the algorithm takes to run (or how much memory
    it uses). These are almost always specified in terms of the size of input.
  prefs: []
  type: TYPE_NORMAL
- en: Alphabet
  prefs: []
  type: TYPE_NORMAL
- en: Alphabets
  prefs: []
  type: TYPE_NORMAL
- en: In formal languages, this is the set of characters that might be processed.
    For many compilers and text processing systems the alphabet is the set of all
    ASCII characters, but for example, for a finite state automaton controlled by
    an “up” and “down” button, the alphabet is just the two symbols “up” and “down”.
    For systems processing binary numbers, the alphabet would usually be “0” and “1”.
    Many of the small examples just use a small alphabet of a few characters (typically
    “a”, “b”, “c” etc.) to keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: ASCII
  prefs: []
  type: TYPE_NORMAL
- en: ASCII the commonly used code for representing characters as 8-bit numbers (although
    only 7 of the 8 bits are usually used).
  prefs: []
  type: TYPE_NORMAL
- en: Attack
  prefs: []
  type: TYPE_NORMAL
- en: Gaining access to or decrypting a file that is using encryption, without having
    the key. There are several types of attacks, some of which are also defined in
    this list.
  prefs: []
  type: TYPE_NORMAL
- en: Binary Number System
  prefs: []
  type: TYPE_NORMAL
- en: The base 2 number system, i.e. numbers only made up of the digits “0” and “1”.
    All numbers that can be represented in the decimal number system can be uniquely
    represented in the binary number system.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search
  prefs: []
  type: TYPE_NORMAL
- en: Binary search searching a sorted list by looking at the middle item, and then
    searching the appropriate half recursively (used for phone books, dictionaries
    and computer algorithms).
  prefs: []
  type: TYPE_NORMAL
- en: Bit
  prefs: []
  type: TYPE_NORMAL
- en: Bit short for “binary digit” - a digit that is either 0 or 1.
  prefs: []
  type: TYPE_NORMAL
- en: Brute force attack
  prefs: []
  type: TYPE_NORMAL
- en: A type of attack that is carried out by trying every possible key.
  prefs: []
  type: TYPE_NORMAL
- en: Bubble sort
  prefs: []
  type: TYPE_NORMAL
- en: Bubble sort a sorting algorithm based on swapping adjacent items that are out
    of order. It is not a good method, but serves as an example of a slow method in
    contrast to others like quicksort.
  prefs: []
  type: TYPE_NORMAL
- en: Byte
  prefs: []
  type: TYPE_NORMAL
- en: Byte a group of 8 bits, able to represent numbers from 0 to 255, can store one
    ASCII character (also known as an octet).
  prefs: []
  type: TYPE_NORMAL
- en: Caesar Cipher
  prefs: []
  type: TYPE_NORMAL
- en: A very simple cipher that offsets each letter in the alphabet by a certain amount,
    specified by the key. It is no longer used in practice due to being very easy
    to attack.
  prefs: []
  type: TYPE_NORMAL
- en: Chatterbot
  prefs: []
  type: TYPE_NORMAL
- en: An AI system that has text conversations with the user, typically based on simple
    pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: Check digit
  prefs: []
  type: TYPE_NORMAL
- en: An extra digit that is added onto the end of a number such as an ISBN, credit
    card number, or barcode number. This digit is calculated using a formula based
    on the other digits in the number. Error detection works by using the check equation
    to determine whether or not the check digit is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Check equation
  prefs: []
  type: TYPE_NORMAL
- en: An equation that is used to check whether or not the check digit for a number
    is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Chomsky hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: A hierarchy of types of languages ranging from the simple “regular expression”
    through to unrestricted grammars. Each level of the hierarchy can describe more
    complex rules, but is also harder to implement. It is named after the linguist
    Noam Chomsky.
  prefs: []
  type: TYPE_NORMAL
- en: Cipher
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm used to encrypt a piece of plain text.
  prefs: []
  type: TYPE_NORMAL
- en: Cipher text
  prefs: []
  type: TYPE_NORMAL
- en: Text which has been encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler
  prefs: []
  type: TYPE_NORMAL
- en: Compiler translates an entire program written in a high level language to machine
    language in advance before running it.
  prefs: []
  type: TYPE_NORMAL
- en: Complexity
  prefs: []
  type: TYPE_NORMAL
- en: Complexity how long it takes to solve a problem. A problem has an inherent complexity
    (minimum time needed to solve it); any algorithm to solve the problem will have
    a higher complexity (take at least that long). See also algorithm complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Compression
  prefs: []
  type: TYPE_NORMAL
- en: Compression making a file smaller by removing redundant information (typically
    using standards like zip, jpeg, mpeg, mp3).
  prefs: []
  type: TYPE_NORMAL
- en: Decimal Number System
  prefs: []
  type: TYPE_NORMAL
- en: The standard base 10 number system that is used in everyday math, using the
    digits “0”, “1”, “2”, “3”, “4”, “5”, “6”, “7”, “8”, and “9”.
  prefs: []
  type: TYPE_NORMAL
- en: Decrypt
  prefs: []
  type: TYPE_NORMAL
- en: Decryption
  prefs: []
  type: TYPE_NORMAL
- en: Decipher
  prefs: []
  type: TYPE_NORMAL
- en: Getting the plain text for a piece of cipher text by either using the key or
    an attack.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption
  prefs: []
  type: TYPE_NORMAL
- en: Encryption changing the representation of data so it can’t be read by an eavesdropper
    who doesn’t have the encryption key.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption key
  prefs: []
  type: TYPE_NORMAL
- en: Encryption key the password or secret code that will unlock an encrypted file.
  prefs: []
  type: TYPE_NORMAL
- en: Error correction
  prefs: []
  type: TYPE_NORMAL
- en: Correcting an error that has been detected in some data. This can be demonstrated
    in the Parity trick, where a person is able to flip the changed bit back over
    so it is correct again (after they have “detected” which bit was incorrect). Not
    all error control schemes are able to correct errors; some are only able to detect
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Error detection
  prefs: []
  type: TYPE_NORMAL
- en: Detecting when an error has occurred in some data, such as a number getting
    typed incorrectly or a bit getting flipped. Some simple examples of this are parity
    bits or a check digit.
  prefs: []
  type: TYPE_NORMAL
- en: Feature
  prefs: []
  type: TYPE_NORMAL
- en: A function available on a digital device or software, such as copy/paste, autofocus,
    voice dialling or undo. Features are often used to sell a device, but having features
    (functionality) should not be confused with people being able to use the device
    effectively (usability).
  prefs: []
  type: TYPE_NORMAL
- en: Feedback
  prefs: []
  type: TYPE_NORMAL
- en: Responding to or acknowledging a user action. Users find the devices hard to
    use if the feedback is slow, confusing, or non-existent.
  prefs: []
  type: TYPE_NORMAL
- en: Finite state automaton
  prefs: []
  type: TYPE_NORMAL
- en: FSA
  prefs: []
  type: TYPE_NORMAL
- en: A simple notation for processing input symbols to determine if they obey some
    specified. An FSA has a starting state, transitions between states based on the
    next input symbol, and “accepting” states, which indicate that the input is accepted
    if the processing ends up in one.
  prefs: []
  type: TYPE_NORMAL
- en: Frequency Analysis Attack
  prefs: []
  type: TYPE_NORMAL
- en: An attack on substitution ciphers that takes advantage of the fact that some
    letters are generally more common than others in a piece of text (e.g. in English,
    the letter “e” is usually the most common letter) by looking at which letters
    appear the most in the cipher text and guessing that they must be the substitutions
    for the most common letters.
  prefs: []
  type: TYPE_NORMAL
- en: GIF
  prefs: []
  type: TYPE_NORMAL
- en: A lossless image compression system typically used for small images with few
    colours in them (in practice it can be lossy because it has only 256 colours,
    and if the original has more colours then some will be lost).
  prefs: []
  type: TYPE_NORMAL
- en: Gigabyte
  prefs: []
  type: TYPE_NORMAL
- en: About 1000 megabytes (1,000,000 kilobytes and 1,000,000,000 bytes). This is
    8,000 million individual bits (i.e. 0’s and 1’s). [Like a kilobyte, there are
    other definitions, such as 1024x1024x1024 bytes, but usually this level of accuracy
    isn’t important]. Commonly referred to as a “GB”.
  prefs: []
  type: TYPE_NORMAL
- en: Grammar
  prefs: []
  type: TYPE_NORMAL
- en: Rules that specify a language, typically used for defining programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  prefs: []
  type: TYPE_NORMAL
- en: Graphics in computer science, designing algorithms that can produce images on
    a computer.
  prefs: []
  type: TYPE_NORMAL
- en: HCI
  prefs: []
  type: TYPE_NORMAL
- en: HCI human computer interaction; an area of computer science looking at how people
    interact with a digital device, with an emphasis on the quality of the experience
    to complete tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Heuristic
  prefs: []
  type: TYPE_NORMAL
- en: A heuristic is rule or guideline, usually devised from experience. The term
    is used in both HCI and algorithms. In **HCI**, heuristics are often used as a
    benchmark to evaluate interfaces — they aren’t strict rules, but usually highlight
    issues with designs. A very common set is given at www.useit.com . In **algorithms**,
    and heuristic is an approximate solution to a problem; it doesn’t guarantee to
    give the best possible answer (such as the shortest route on a map), but by using
    simple rules the calculation can be done quickly, and the solution is hopefully
    good enough for practical use.
  prefs: []
  type: TYPE_NORMAL
- en: Hexadecimal
  prefs: []
  type: TYPE_NORMAL
- en: The base 16 number system. Uses the digits “0”, “1”, “2”, “3”, “4”, “5”, “6”,
    “7”, “8”, “9”, “A”, “B”, “C”, “D”, “E”, and “F”. All numbers that can be represented
    in decimal can be uniquely represented in hexadecimal (just like binary). It is
    most often used as a shorthand notation for binary, by assigning 1 hexadecimal
    digit to each 4 bit pattern (the assigning is done in numeric order).
  prefs: []
  type: TYPE_NORMAL
- en: Hexadecimal colour codes
  prefs: []
  type: TYPE_NORMAL
- en: A representation for colours that tells the computer how much red, blue, and
    green light to display in a pixel (to make the desired colour). Uses 1 byte for
    each of these 3 primary colours, which is 3 bytes (24 bits) in total. These 24
    bits are often written as 6 hexadecimal digits to make them easier for humans
    to read, which is why they are called “Hexadecimal colour codes”. They are commonly
    encountered when specificying colours in HTML for web pages.
  prefs: []
  type: TYPE_NORMAL
- en: High level language
  prefs: []
  type: TYPE_NORMAL
- en: High level language a programming language that is designed for humans to read
    and write (e.g. Java, Python, C, C#, Basic, Scratch…) as opposed to machine languages.
  prefs: []
  type: TYPE_NORMAL
- en: Insertion sort
  prefs: []
  type: TYPE_NORMAL
- en: Start with an empty list, and insert each item in the correct place; this is
    a relatively slow method, usually between selection sort and quick sort in speed.
  prefs: []
  type: TYPE_NORMAL
- en: Intelligent Systems
  prefs: []
  type: TYPE_NORMAL
- en: Intelligent systems an area of computer science that investigates ways to simulate
    or approximate human intelligence on computers; often referred to as artificial
    intelligence (AI).
  prefs: []
  type: TYPE_NORMAL
- en: Interface
  prefs: []
  type: TYPE_NORMAL
- en: The part of a computer, software, or electronic device that a human interacts
    with, whether this is by sight, hearing, or touch.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter runs a programming language by translating each line of code as
    it is execute.
  prefs: []
  type: TYPE_NORMAL
- en: ISBN
  prefs: []
  type: TYPE_NORMAL
- en: Stands for International Standard Book Number. Every published book has one
    of these numbers on the back of it. ISBN is significant to error control coding
    because it uses a check digit for error detection.
  prefs: []
  type: TYPE_NORMAL
- en: JPEG
  prefs: []
  type: TYPE_NORMAL
- en: A lossy image compression system typically used for photographs.
  prefs: []
  type: TYPE_NORMAL
- en: Key (in algorithms)
  prefs: []
  type: TYPE_NORMAL
- en: It is an item of data that is being searched for or sorted, and therefore will
    be compared with other data.
  prefs: []
  type: TYPE_NORMAL
- en: Key (in cryptography)
  prefs: []
  type: TYPE_NORMAL
- en: The password or secret value that is used to encrypt and decrypt an encrypted
    file (without having to use an “attack”). Some widely used methods have different
    keys for encryption and decryption.
  prefs: []
  type: TYPE_NORMAL
- en: Kilobyte
  prefs: []
  type: TYPE_NORMAL
- en: About 1000 bytes. This is 8,000 individual bits (i.e. 0’s and 1’s). [We say
    “about” 1000 bytes because the term is ambiguous and it is often taken as 1024
    bytes; however, rounding it to 1000 is close enough for most calculations]. Commonly
    referred to as a “KB”.
  prefs: []
  type: TYPE_NORMAL
- en: Known plain-text Attack
  prefs: []
  type: TYPE_NORMAL
- en: Working out the key or method of encryption (cipher) based on having access
    to both the original plain-text and its encrypted form.
  prefs: []
  type: TYPE_NORMAL
- en: Language
  prefs: []
  type: TYPE_NORMAL
- en: A set of strings, typically obeying some rules defined by a regular expression
    or grammar e.g. all strings containing the letter “a” exactly twice, or all strings
    that are legal Java programs.
  prefs: []
  type: TYPE_NORMAL
- en: Lexical analysis
  prefs: []
  type: TYPE_NORMAL
- en: When compiling a computer program, working out what the components of the program
    are e.g. identifiers, keywords, integers.
  prefs: []
  type: TYPE_NORMAL
- en: Linear Complexity
  prefs: []
  type: TYPE_NORMAL
- en: Linear complexity grows in proportion to the size of the problem - if the problem
    is twice as big, it will take roughly twice as long to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Logarithm
  prefs: []
  type: TYPE_NORMAL
- en: Logarithm is a very slow growing mathematical function written as \log n. In
    computer science logarithms are usually in base 2, that is, \log_2 n, which is
    the inverse of the incredibly fast growing exponent function 2^n. Logarithms are
    not needed to understand the material in this book, but they are used a lot in
    computer science and are a useful concept to understand. Logarithms happen to
    come up a lot with algorithms, and the two words are often confused. The value
    \log_2 n is just the number of times you can halve n until you get down to 1;
    for example, \log_2 32`is 5, and :math:log_2 1024` is 10\. Binary search takes
    \log_2 n steps to search *n*items; storing the number *n* in binary takes \log_2
    n bits.
  prefs: []
  type: TYPE_NORMAL
- en: Lossless
  prefs: []
  type: TYPE_NORMAL
- en: A compression method that does not cause any loss of data. This means that the
    uncompressed file will be identical to the original file that was compressed (which
    is important for text). In the case of images and sound, it means they will be
    of the same quality before and after compression. For example, ZIP and ALC use
    lossless compression.
  prefs: []
  type: TYPE_NORMAL
- en: Lossy
  prefs: []
  type: TYPE_NORMAL
- en: A compression method that trades off quality for file size. Lossy compression
    methods can make files smaller than lossless compression methods can, but the
    quality of the resulting file will be lower. For example, MP3 and JPEG use lossy
    compression.
  prefs: []
  type: TYPE_NORMAL
- en: Machine language
  prefs: []
  type: TYPE_NORMAL
- en: The native language for instructions for a computer, not very easy for humans
    to read and write.
  prefs: []
  type: TYPE_NORMAL
- en: Megabyte
  prefs: []
  type: TYPE_NORMAL
- en: About 1000 kilobytes (1,000,000 bytes). This is 8 million individual bits (i.e.
    0’s and 1’s). [Like a kilobyte, there are other definitions, such as 1024x1024
    bytes, but usually this level of accuracy isn’t important]. Commonly referred
    to as a “MB”.
  prefs: []
  type: TYPE_NORMAL
- en: MP3
  prefs: []
  type: TYPE_NORMAL
- en: A lossy audio compression system.
  prefs: []
  type: TYPE_NORMAL
- en: Nibble
  prefs: []
  type: TYPE_NORMAL
- en: 4 bits (half a byte), sometimes called a nybble.
  prefs: []
  type: TYPE_NORMAL
- en: Nielson’s Heuristics
  prefs: []
  type: TYPE_NORMAL
- en: A widely used set of heuristics for evaluating computer interfaces that was
    devised by Jakob Nielson (available from [http://useit.com](http://useit.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Octal
  prefs: []
  type: TYPE_NORMAL
- en: 'The base 8 number system. Like hexadecimal, it is significant to computer scientists
    as it allows a shorthand notation for writing binary numbers. Octal assigns a
    digit to each possible 3 bit pattern. Note: You probably don’t need to know this
    for the achievement standard, although it is included here in case you come across
    the term.'
  prefs: []
  type: TYPE_NORMAL
- en: Parity
  prefs: []
  type: TYPE_NORMAL
- en: Adding an extra bit to a set of bits to make it so that there is an even number
    of 1’s. Storing the parity makes it possible to detect and correct errors later.
    [This is known as an even parity bit; an odd parity bit is also possible where
    the extra bit ensures there is an odd number of 1’s]
  prefs: []
  type: TYPE_NORMAL
- en: Parse tree
  prefs: []
  type: TYPE_NORMAL
- en: The structure derived by parsing some input.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing
  prefs: []
  type: TYPE_NORMAL
- en: Reading some input (typically a computer program) and making sense of it by
    breaking it into parts according to their function.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs: []
  type: TYPE_NORMAL
- en: Finding strings of characters that match simple rules, typically based on a
    regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: Plain Text
  prefs: []
  type: TYPE_NORMAL
- en: Text before it has been encrypted or after it has been decrypted (so essentially
    text in plain language, without any encryption).
  prefs: []
  type: TYPE_NORMAL
- en: PNG
  prefs: []
  type: TYPE_NORMAL
- en: A lossless image compression system typically used for small images with few
    colours in them.
  prefs: []
  type: TYPE_NORMAL
- en: Quadratic complexity
  prefs: []
  type: TYPE_NORMAL
- en: Quadratic complexity grows with the square of the size of the problem - if the
    problem is twice as big, it will take roughly 4 times as long to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Quick sort
  prefs: []
  type: TYPE_NORMAL
- en: Quick sort pick an item at random, put all the smaller items in a group on its
    left and the larger items in a group on its right. Now do quick sort on the two
    groups. This is one of the better sorting algorithms, and is good for comparing
    with others. Students don’t need to understand how it works, but some may be curious.
  prefs: []
  type: TYPE_NORMAL
- en: Redundant Bits
  prefs: []
  type: TYPE_NORMAL
- en: Extra bits that are not part of the actual data but instead have been added
    for error detection and possibly error correction.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression
  prefs: []
  type: TYPE_NORMAL
- en: A simple expression used for pattern matching, typically using characters combined
    with “*” (repetition), “|” (selecting one or the other) and parenthesis (to group
    operations). Some systems allow more complex patterns such as ”.” (matches any
    character), “{n}” (repeated n times), and “\d” (digit).
  prefs: []
  type: TYPE_NORMAL
- en: Search
  prefs: []
  type: TYPE_NORMAL
- en: Find a key in a large amount of data.
  prefs: []
  type: TYPE_NORMAL
- en: Selection sort
  prefs: []
  type: TYPE_NORMAL
- en: Selection sort select the smallest item, then the second smallest, and so on.
    This is not a very fast algorithm, but it’s not as bad as bubble sort, and provides
    a good contrast with quick sort.
  prefs: []
  type: TYPE_NORMAL
- en: Sort
  prefs: []
  type: TYPE_NORMAL
- en: Sort puts keys (numbers, names or other values) in order from smallest to largest
    (outside computer science this is usually called ordering).
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs: []
  type: TYPE_NORMAL
- en: A sequence of characters or symbols from an alphabet. For example, the two-character
    strings that can be made from the alphabet {“a”,”b”} are “aa”, “ab”, “ba” and
    “bb”.
  prefs: []
  type: TYPE_NORMAL
- en: Substitution Cipher
  prefs: []
  type: TYPE_NORMAL
- en: A type of cipher that works simply by replacing each letter or combination of
    letters in a plain text with a certain other letter or combination of letters
    to make up the cipher text. The result of this is that each unique letter combination
    of letters in the plain text (e.g. “t”) is represented by the same unique letter
    combination of letters in the cipher text (e.g. “y”) Caesar Cipher is a simple
    example of a substitution cipher. Substitution ciphers are vulnerable to Frequency
    Analysis Attacks, so are not used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Syntactically correct
  prefs: []
  type: TYPE_NORMAL
- en: A string is syntactically correct if it matches the specifications for a formal
    language. For example, the string “()(())” is correct for a grammar that gives
    the rules for balanced parentheses. In a computer program, a syntax error is when
    a character occurs in the input which isn’t allowed, and the program is therefore
    not syntactically correct.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs: []
  type: TYPE_NORMAL
- en: Syntax rules about what text can appear in a programming language, used by a
    compiler or interpreter and therefore need to be followed by a programmer to avoid
    syntax errors.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax diagram
  prefs: []
  type: TYPE_NORMAL
- en: Also known as railway (or railroad) diagrams, these are a graphical representation
    of a grammar using arrows (the “train tracks”) to show the options for each component
    of a language.
  prefs: []
  type: TYPE_NORMAL
- en: Task
  prefs: []
  type: TYPE_NORMAL
- en: Something a user might do with a piece of software or electronic device to achieve
    a goal. In the case of a cellphone this might be “send a text message” or in the
    case of a microwave it might be “heat up yesterday’s leftovers”. Interfaces are
    best evaluated when considering how they help a user to perform a task.
  prefs: []
  type: TYPE_NORMAL
- en: Time complexity
  prefs: []
  type: TYPE_NORMAL
- en: Time complexity the usual meaning of the complexity of an algorithm; this makes
    it clear that we’re talking about the time taken. Normally it’s expressed in terms
    of steps, not real time on a particular computer, as different computers are different
    speeds.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode
  prefs: []
  type: TYPE_NORMAL
- en: Unicode an extension of ASCII; it supports characters from multiple languages,
    using 16 bits per character.
  prefs: []
  type: TYPE_NORMAL
- en: Usability heuristic
  prefs: []
  type: TYPE_NORMAL
- en: See [*Heuristic*](http://csfieldguide.org.nz/appendices/Glossary.html#term-heuristic).
  prefs: []
  type: TYPE_NORMAL
- en: User
  prefs: []
  type: TYPE_NORMAL
- en: The human using the computer system or electronic device.
  prefs: []
  type: TYPE_NORMAL
- en: Visual computing
  prefs: []
  type: TYPE_NORMAL
- en: Visual computing designing systems that can perceive, process, understand and
    generate images; images typically come from scanners and cameras, and may be displayed
    on monitors, head mounted displays, or as movies.
  prefs: []
  type: TYPE_NORMAL
- en: 17.2\. CONTRIBUTORS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If there is an error in the list, please contact [Jack Morgan](mailto:jack.morgan%40canterbury.ac.nz)
  prefs: []
  type: TYPE_NORMAL
- en: Tim Bell - International Field Guide, co-organiser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peter Denning - International Field Guide, co-organiser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jack Morgan - Editor and Technical Lead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heidi Newton - Writer for Artificial Intelligence, Complexity and Tractability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Janina Voigt - Writer for Software Engineering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ian Witten, writer and advisor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jon Rutherford - Writer for Software Engineering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wal Irwin - Advisor for Software Engineering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peter Andreae - Advisor for Artificial Intelligence, Complexity and Tractability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walter Guttmann - Advisor for Formal Languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: David Thompson - Interactive games and Writer for Computer Vision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rhem Munro- Interactive games and Writer for Computer Graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sumant Murugesh - Research
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ben Gibson - Interactive games and related material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linda Pettigrew - Formal languages material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Joshua Scott - Computer Graphics material: Bresenham’s methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Michael Bell (Orange Studio) - Video production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patrick Baker, Jenny Baker, Neil Leslie - NZ teachers providing advisory role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dr Mukundan - Advisor for Computer Graphics & Vision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Richard Green - Advisor for Computer Vision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DongSeong Kim - Advisor for networking/security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mike Fellows, co-authored CS unplugged (source material)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Andrea Arpaci-Dusseau, co-author of a Chinese version of “Unplugged” (source
    material)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renate Thies and Jan Vahrenhold (Münster University, Germany), advisors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anthony Robins - advisor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shadi Ibrahim - advisor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paul Curzon - CS4FN material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quintin Cutts - “Computing Science Inside” material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paul Matthews (IITP) - advisor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calvin Lin, Bradley Beth - The University of Texas at Austin “Thriving in our
    Digital World” project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brad Miller and David Ranum - advisors for authoring tools - our web system
    is based on their books at [Runestone Interactive](http://runestoneinteractive.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.2.1\. ACKNOWLEDGEMENTS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project has grown out of a partnership for an international field guide
    to computing. In the CSSE department, it grew from the CS Unplugged project (csunplugged.org)
    and the CS resource guides (nzacditt.org.nz/resources). At the at Naval Postgraduate
    School in Monterey, California, it grew from a project called “Field Guide to
    the Science of Computing” (csfieldguide.org) and the Great Principles of Computing
    project (greatprinciples.org), both led by Peter Denning.
  prefs: []
  type: TYPE_NORMAL
- en: Funding for this online textbook has been provided by Google Inc. In addition,
    countless hours of volunteer time have been contributed by those listed above.
    Tim Bell prepared an initial draft of this material while visiting Huazhong University
    of Science and Technology, Wuhan, China, whom we thank for providing an excellent
    environment for writing. The project is based at the University of Canterbury,
    Christchurch, New Zealand; other authors are at Victoria University of Wellington,
    New Zealand, and Cambridge University, UK.
  prefs: []
  type: TYPE_NORMAL
- en: Partial funding for the US field guide project was provided by the US National
    Science Foundation under Grant No. 0938809.
  prefs: []
  type: TYPE_NORMAL
- en: 17.3\. INTERACTIVES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is for help on getting the interactives (previously referred to
    as widgets) working. The current interactives are prototypes and have not been
    heavily tested across different browsers and operating systems. Most of the interactives
    will work in the latest version of Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: The interactives are currently not designed for mobile or touch devices, but
    are a focus when we redesign them over the coming months.
  prefs: []
  type: TYPE_NORMAL
- en: 17.3.1\. WEBGL ON WINDOWS, LINUX AND MAC OS X
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The graphics chapter makes a lot of use of the WebGL system, which can render
    3D images in a web browser. It is relatively new, so older browsers and operating
    systems may not have it setup correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 17.3.1.1\. QUICK FIXES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using an up-to-date version of Chrome or Firefox and the drivers
    for your operating system are up-to-date and the computer has a suitable GPU,
    then it should work. It won’t be possible to use it in Internet Explorer. For
    Safari you will need to adjust some settings. The details for getting WebGL set
    up are below.
  prefs: []
  type: TYPE_NORMAL
- en: '**Updating your operating system**'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re on **Windows**, make sure you have [the Microsoft DirectX runtime](http://www.microsoft.com/en-us/download/details.aspx?id=35) installed
    — this is a free download from Microsoft. Once you’ve done that, make sure that
    you’ve got the very latest versions of the drivers for your graphics card. We
    recommend doing this manually, there are good tutorials on the internet. There
    is a good[video](http://www.pctecmech.com/tutorials/Video-Card-Drivers.php) here
    that explains how to do this. The easiest way is to install an free driver update
    program like [SlimDriver](http://download.cnet.com/SlimDrivers-Free/3000-18513_4-75279940.html) which
    will find missing and out-of-date drivers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For **MacOS**: 1\. Click the Apple logo. 2\. On the “Apple” menu, click “Software
    Update.” 3\. If there is a Mac OS X update available, you can install it. If there
    is a graphics driver update, it will be included in the Mac OS X update.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Updating your browser**'
  prefs: []
  type: TYPE_NORMAL
- en: This depends on which browser you are using. If you can use Chrome it can be
    a little easier to get working.
  prefs: []
  type: TYPE_NORMAL
- en: '[Firefox](http://www.mozilla.org/en-US/firefox/new/): just make sure you have
    version 4 or higher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chrome: all you need to do is [install it](https://www.google.com/intl/en/chrome/browser/),
    or if you’re already using it, just check whether it’s updated itself to version
    10 or later — this will almost certainly have happened automatically (it was released
    in March 2011), but you can check from the “About Google Chrome” option on the
    tools menu to confirm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Safari: on Macs, OS X 10.7 has WebGL support, but it’s switched off by default.
    To switch it on, enable the developer menu and check the “[Enable WebGL](http://www.google.com/url?q=http%3A%2F%2Fwww.ikriz.nl%2F2011%2F08%2F23%2Fenable-webgl-in-safari&sa=D&sntz=1&usg=AFQjCNFn42c02vQLy95tRoAoDxdprFGPJA)”
    option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All older version of these browsers require manual enabling of WebGL. For more
    information on getting a WebGL implementation follow this [link](http://www.google.com/url?q=http%3A%2F%2Fwww.khronos.org%2Fwebgl%2Fwiki%2FGetting_a_WebGL_Implementation&sa=D&sntz=1&usg=AFQjCNEnTnBdVMIaarDTponyCLS5rHphOA).
  prefs: []
  type: TYPE_NORMAL
- en: 17.3.1.2\. TROUBLE IN LINUX, WINDOWS OR MAC OS X
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the above doesn’t work then you may unfortunately have a blacklisted GPU
    / graphics card, or your graphics drivers may be out of date because the company
    has discontinued their support. In most cases we can get around this (see below).
  prefs: []
  type: TYPE_NORMAL
- en: You can find an explanation of [blacklisted](http://www.google.com/url?q=http%3A%2F%2Fwww.khronos.org%2Fwebgl%2Fwiki%2FBlacklistsAndWhitelists&sa=D&sntz=1&usg=AFQjCNFATCzIoQU6-Fo8xMSQZPPKtYktjQ) cards/GPU’s
    for Chrome. As of January 2013 the “blacklisted” Chrome GPU’s are as follows;
    some may be removed from the list later.
  prefs: []
  type: TYPE_NORMAL
- en: '**All operating systems**'
  prefs: []
  type: TYPE_NORMAL
- en: NVIDIA GeForce FX Go5200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows**'
  prefs: []
  type: TYPE_NORMAL
- en: Intel GMA 945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ATI FireMV 2400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mac**'
  prefs: []
  type: TYPE_NORMAL
- en: ATI Radeon HD2400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ATI Radeon 2600 series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ATI Radeon X1900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ATI Radeon HD 6490M on OS X 10.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeForce 7300 GT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux**'
  prefs: []
  type: TYPE_NORMAL
- en: AMD/ATI cards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nvidia QuadroFX 1500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nvidia cards with Nouveau drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nvidia cards with Nvidia drivers older than 295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimus dual-GPU configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intel for Mesa drivers earlier than 7.9 (just update drivers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.3.1.3\. THE WORK-AROUND
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To work around this it is easiest done in Chrome by typing “[about:flags](about:flags)”
    in the address bar, it will open a page. On this page find “Override software
    rendering list” in the list and click ‘enable’. Then look for and click the “relaunch
    google chrome” button or close all chrome browser windows and restart/reload Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: In Firefox type “[about:flags](about:flags)” in the address bar. (On this page
    there is a search input available) Search in this for “force-enabled”. Double
    click on both*layers.acceleration.force-enabled* and *webgl.force-enabled* which
    will set their value **true**. Then close all firefox browser windows and restart/reload
    firefox.
  prefs: []
  type: TYPE_NORMAL
- en: 17.3.1.4\. EXTRA TROUBLE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Graphics drivers must be working, some graphics cards are not fully compatible
    with some operating systems. In the case of Linux OS make sure is fully updated
    ie. Intel Mesa drivers should be higher than 7.9 otherwise it will default to
    software rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 17.3.1.5\. DIAGNOSE YOUR GPU IN CHROME
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can diagnose what’s happening by typing ‘chrome://gpu’ in the location bar.
    You can also see your driver version in here and other details.
  prefs: []
  type: TYPE_NORMAL
- en: 'If webgl is enabled then you should get a graphics feature status, ie. - Canvas:
    Hardware accelerated - WebGL: Hardware accelerated - WebGL multisampling: Hardware
    accelerated - Flash 3D: Hardware accelerated - Flash Stage3D: Hardware accelerated'
  prefs: []
  type: TYPE_NORMAL
- en: The GL_RENDERER also should have the name of your GPU, otherwise if its not
    working correctly it may have something like “Software Rasterizer” and will be
    really slow. In this case again check your drivers are up to date.
  prefs: []
  type: TYPE_NORMAL
- en: 17.4\. 1.44 ASSESSMENT GUIDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This document provides a brief introduction to teachers on the Computer Science
    Field Guide assessment guides for NCEA Achievement standard AS91074 (1.44).
  prefs: []
  type: TYPE_NORMAL
- en: 17.4.1\. TOPICS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1.44 has bullet points for the following three topics in computer science.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming Languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Human Computer Interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these topics has a chapter in the Computer Science Field Guide, which
    this assessment guide is based on.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we provide two different assessment guides for algorithms (sorting
    and searching), and one for each of human computer interaction and programming
    languages. Note that students only need to follow one assessment guide for each
    of the three topics (i.e. they do not need to do both searching and sorting for
    the topic of algorithms).
  prefs: []
  type: TYPE_NORMAL
- en: 17.4.2\. SORTING VS SEARCHING FOR ALGORITHMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the topic of algorithms, students can demonstrate their understanding of
    algorithms and their costs by using either sorting algorithms or searching algorithms
    as their example.
  prefs: []
  type: TYPE_NORMAL
- en: For students who are weak at math, searching algorithms is probably the better
    choice. Sorting algorithms requires either being good at understanding trends
    from data in a table or understanding how to read trends from a graph in order
    to achieve merit or excellence, whereas the cost of Searching algorithms can easily
    be seen by students carrying out the algorithms themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting algorithms provide a slightly richer range of possibilities, including
    more ways to demonstrate how they work in a student’s report, and intriguing new
    approaches to a common and easily described task that may not have been obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 17.4.3\. ORDER OF TOPICS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The three topics can be completed in any order, although the first bullet point
    in each level (comparing algorithms, programs, and informal instructions) is probably
    best left until both algorithms and programming languages have been completed,
    since they can provide examples to illustrate the points in the first bullet points.
  prefs: []
  type: TYPE_NORMAL
- en: Covering Human Computer Interaction first may make the Algorithms topic more
    relevant to students. In many cases, a not so good algorithm will take a second
    to run, whereas a better algorithm will take less than a tenth of a second. This
    is very significant in terms of a good user interface, so covering HCI first will
    make students more aware of issues like this.
  prefs: []
  type: TYPE_NORMAL
- en: 17.4.4\. PERSONALISATION AND STUDENT VOICE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important that students use personalised examples to base their explanations
    around, and that the explanations are in their own words, and based on their example
    (rather than being a paraphrase from wikipedia, for example).
  prefs: []
  type: TYPE_NORMAL
- en: Personalised means that the student’s example is different to their classmates.
    For example, they may have a program that prints their name or favourite saying,
    they may use a different number of items to sort or search through, their choice
    of the values being sorted or searched in examples is unique, and they may carry
    out their own usability exploration of a device they chose, and report on it in
    their own words.
  prefs: []
  type: TYPE_NORMAL
- en: If the teacher provides too many headings or leading questions for students
    to structure their work, this can reduce the opportunity for the report to reflect
    a personal understanding.
  prefs: []
  type: TYPE_NORMAL
- en: 17.4.5\. REPORT LENGTH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note that the page limit given by NZQA is not a target. The
    markers prefer reports that are short and to the point, and the requirements of
    the standard can easily be met within the limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The page limit for 1.44 is now 10 pages to cover the three topics. A possible
    breakdown that leaves one additional page is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithms: 4 pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Programming Languages: 2 pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Human Computer Interaction: 3 pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The assessment guides provide further guidance on how to stay within these limits.
    Students should be mindful of the recommended limits while they are working on
    their reports, in order to avoid having to delete work they put a lot of effort
    into.
  prefs: []
  type: TYPE_NORMAL
- en: Some hints to reduce total length
  prefs: []
  type: TYPE_NORMAL
- en: Only include what is relevant to the standard. While covering additional material
    in class is valuable for learning, additional content that doesn’t demonstrate
    understanding of the topics and bullet points in the standard is only a distraction
    in the report.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resize screenshots and photos so that they are still readable, although don’t
    take up unnecessary space. Use cropping to show the relevant parts of the image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t leave unnecessary space in the report. It both looks untidy and makes
    it more difficult for the marker to find what they are looking for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.4.6\. PRESENTING THE REPORT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Always check your report trying to think of it from the marker’s point of view.
    A common mistake is to put in graphs without labels on the axes, so the marker
    doesn’t know what the graph is showing. Also make sure you give units for measurements
    (e.g. 5 seconds, 5 minutes?). If you refer to colour in an image don’t print the
    report in black and white!
  prefs: []
  type: TYPE_NORMAL
- en: If you are using examples, don’t use ones taken from the Field Guide or other
    sources - make up your own. For sorting and searching, makes up a set of numbers
    or words (perhaps about 8, but not 2 or 3) to demonstrate the algorithms. For
    HCI, use your own device. For algorithms, don’t use the “glass of water” example
    in the Field Guide - think of your own example to show that you’ve understood
    the point!
  prefs: []
  type: TYPE_NORMAL
- en: 17.4.7\. GENERAL ADVICE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 2012 we did a study that looked over 151 student submissions for 1.44 in
    2011\. This was the first year 1.44 was offered, although the lessons learnt are
    still relevant, particularly for teachers teaching the standard for the first
    time. A WIPSCE paper was written presenting our findings of how well students
    approached the standard and our recommendations for avoiding pitfalls. Our key
    findings are reflected in the teacher guides, although reading the entire paper
    would be worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: The paper was Bell, T., Newton, H., Andreae, P., & Robins, A. (2012). The introduction
    of Computer Science to NZ High Schools — an analysis of student work. In M. Knobelsdorf
    & R. Romeike (Eds.), The 7th Workshop in Primary and Secondary Computing Education
    (WiPSCE 2012). Hamburg, Germany. Available from:[http://nzacditt.org.nz/system/files/Student-work-WiPCSE2012-final-submission-dl.pdf](http://nzacditt.org.nz/system/files/Student-work-WiPCSE2012-final-submission-dl.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: 17.5\. ALGORITHMS (1.44) - SEARCHING ALGORITHMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting the *Algorithms* topic of digital technologies
    achievement standard 1.44 (AS91074).
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done projects
    covering the topics of *Programming Languages* and *Human Computer Interaction* in
    the standard, and included these in your report.
  prefs: []
  type: TYPE_NORMAL
- en: 17.5.1\. OVERVIEW
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The topic of *Algorithms* has the following bullet points in achievement standard
    1.44, which this guide covers. This guide separates them into two categories.
  prefs: []
  type: TYPE_NORMAL
- en: 17.5.1.1\. COMPARING ALGORITHMS, PROGRAMS, AND INFORMAL INSTRUCTIONS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved** (A1): “describing the key characteristics, and roles of algorithms,
    programs and informal instructions”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit** (M1): “explaining how algorithms are distinct from related concepts
    such as programs and informal instructions”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence** (E1): “comparing and contrasting the concepts of algorithms,
    programs, and informal instructions”'
  prefs: []
  type: TYPE_NORMAL
- en: 17.5.1.2\. DETERMINING THE COST OF ALGORITHMS AND UNDERSTANDING VARIOUS KINDS
    OF STEPS IN ALGORITHMS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved** (A2): “describing an algorithm for a task, showing understanding
    of the kinds of steps that can be in an algorithm, and determining the cost of
    an algorithm for a problem of a particular size”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit** (M2): “showing understanding of the way steps in an algorithm for
    a task can be combined in sequential, conditional, and iterative structures and
    determining the cost of an iterative algorithm for a problem of size *n*”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence** (E2): “determining and comparing the costs of two different
    iterative algorithms for the same problem of size *n*”'
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed Digital Technology reports, you should base
    your explanations around personalised examples.
  prefs: []
  type: TYPE_NORMAL
- en: 17.5.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 - What’s the bigger picture?
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 - Searching Algorithms
  prefs: []
  type: TYPE_NORMAL
- en: 17.5.3\. PROJECT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project involves understanding linear search and binary search.
  prefs: []
  type: TYPE_NORMAL
- en: 17.5.3.1\. WRITING YOUR REPORT FOR THE MAIN BULLET POINTS THAT COVER ALGORITHMS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved**'
  prefs: []
  type: TYPE_NORMAL
- en: Try both the box searching interactives linked to in the field guide. For one
    of them you have to use linear search, and for the other you have to use binary
    search.
  prefs: []
  type: TYPE_NORMAL
- en: Pick one of these algorithms to focus on for achieved. Carry out the interactive
    and then take a screenshot. Show on your screenshot which boxes you opened, and
    put how many boxes you opened. The number of boxes you opened is the *cost* of
    the algorithm in this particular case.
  prefs: []
  type: TYPE_NORMAL
- en: If you did the search with this same number of boxes lots of times (but with
    different numbers in the boxes), on average how many boxes would you need to check?
    This is the *cost* for a problem of this particular size (the problem size is
    the number of boxes).
  prefs: []
  type: TYPE_NORMAL
- en: Describe (in your own words with a few sentences) the overall process you carried
    out to search through the boxes. Try and make your explanation general, e.g. if
    you gave the instructions to somebody who needs to know how to search 100 boxes,
    or 500 boxes, the instructions would be meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit/ Excellence**'
  prefs: []
  type: TYPE_NORMAL
- en: For merit, you need to make it clear that you understand that algorithms can
    contain iterative, conditional, and sequential steps. If you don’t know what these
    terms mean, go have another look at the field guide. Get a Scratch program (or
    another language if you are fairly confident with understanding the language)
    that implements your sorting algorithm. Take a screenshot of it, or a large part
    of it (you want to ensure that the screenshot takes up no more than half a page
    in the report, but is still readable) and open it in a drawing program such as
    paint. Add arrows and notes showing a part of the algorithm that is sequential,
    part that is conditional, and part that is iterative.
  prefs: []
  type: TYPE_NORMAL
- en: It should be obvious by now that binary search is far better than linear search!
    Although you still might say, why not just use a faster computer? To explore this
    possibility, you are now going to analyse what happens with a **huge** amount
    of data. Pick a really large number (e.g. in the billions, or even bigger - this
    is the amount of data that large online companies have to search). Imagine you
    have this number of boxes that you have to search. Rather than actually carrying
    out the searching, you are going to determine how long it would take if you use
    linear search, and how long it would take if you used binary search. Computer
    scientists call this*analysing* an algorithm, and often it is better to work out
    how long an algorithm can be expected to take before waiting years for it to run
    and wondering if it will ever complete.
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that you can use the big number calculator and the time calculator
    in the field guide.*'
  prefs: []
  type: TYPE_NORMAL
- en: How many boxes on average will you have to search if you use a linear search?
  prefs: []
  type: TYPE_NORMAL
- en: What about with binary search? If you are unsure on how to calculate this, remember
    that each box you check cuts the number of boxes you still need to consider in
    half. Therefore, you can determine approximately how many boxes you will need
    to check by continually halving the total number of boxes until it gets down to
    1\. You should include all the working (i.e. the result of each division by 2)
    in your report.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if your answer isn’t perfect; it’s okay to be within 5 or so of
    the correct answer. This means that if while halving your number it never gets
    down to exactly 1 (e.g. it gets down to 1.43 and then 0.715), your answer will
    be near enough. As long as you have halved your number repeatedly until it gets
    down to a number that is less than 1, your answer will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: Calculate how long it would take for each algorithm, assuming you have a computer
    that can look in a million boxes per second. Don’t worry about being too accurate
    (e.g. just round to the nearest second, minute, hour, day, month, or year).
  prefs: []
  type: TYPE_NORMAL
- en: You should see a very big difference between the two numbers. What will happen
    if you have twice as many boxes? What about four times as many? How long will
    it take for each algorithm? You should easily be able to calculate these numbers
    based on your previous calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Include a table in your report that shows the time it would take for your 15
    digit number of boxes using each algorithm, and then for two times, four times,
    and eight times the number of boxes. If you are keen you could look at 128 times
    as well (that is doubling the problem size 7 times).
  prefs: []
  type: TYPE_NORMAL
- en: Write about what you observe in the time increase when you have doubled the
    number of boxes.
  prefs: []
  type: TYPE_NORMAL
- en: With such a large number of boxes, how important is it to use binary search
    if you can? Imagine if you were a computer scientist with the task of searching
    these boxes, and in order to do your work you need to search for many pieces of
    data each day. What would happen if you were trying to use linear search?
  prefs: []
  type: TYPE_NORMAL
- en: 17.5.3.2\. WRITING THE PART OF YOUR REPORT THAT ADDRESSES “COMPARING ALGORITHMS/
    PROGRAMS/ INFORMAL INSTRUCTIONS”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved/ Merit/ Excellence**'
  prefs: []
  type: TYPE_NORMAL
- en: We recommend doing this part after you have done programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: All three levels (A/M/E) are subsumed by the E requirement, so you should try
    to do that i.e. “comparing and contrasting the concepts of algorithms, programs,
    and informal instructions”. You should refer to examples you used in your report
    or include additional examples (e.g. a program used as an example in the programming
    languages topic, or an algorithm describing the searching process, etc). If you
    are confused, have another look at the field guide. You should only need to write
    a few sentences to address this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 17.5.4\. HINTS FOR SUCCESS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don’t confuse “algorithm cost” with the “algorithm length”. The number of lines
    in the algorithm or program normally unrelated to the cost. Cost is the time the
    algorithm actually takes to run, or the number of comparisons that have to be
    made. You can find more information in the Field Guide if you are not sure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resize screenshots/ photos so that they are large enough to see what is on them,
    but not taking up unnecessary space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.5.5\. RECOMMENDED NUMBER OF PAGES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within the 4 pages recommended for algorithms, a possible breakdown is:'
  prefs: []
  type: TYPE_NORMAL
- en: '1 ½ pages: Screenshots and explanations of you carrying out a chosen algorithm **(Achieved)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '¼ page: General instructions for carrying out your chosen algorithm **(Achieved)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '½ page: Example of the iterative, conditional, and sequential steps that can
    be in an algorithm **(Merit)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1 ½ pages: Your investigation and data collected for merit/ excellence. Including
    results and discussion **(Merit/ Excellence)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '¼ page: Explanation of the difference between algorithms, programs, and informal
    instructions **(Achieved/ Merit/ Excellence)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are *maximums*, not targets!
  prefs: []
  type: TYPE_NORMAL
- en: For the topic of searching algorithms you probably won’t need this much space
    (sorting algorithms tends to require more space). In particular, you should only
    need 1 page to introduce your chosen algorithm for achieved, and 1 page or less
    for your investigation for merit/ excellence. This might allow you to allocate
    more pages to one of the other two topics.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you go over 4 pages for Algorithms, then you may have to use fewer
    pages for one of the other two topics, which could be problematic. No other material
    should be included for Algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 17.6\. ALGORITHMS (1.44) - SORTING ALGORITHMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting the *Algorithms* topic of digital technologies
    achievement standard 1.44 (AS91074).
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done projects
    covering the topics of *Programming Languages* and *Human Computer Interaction* in
    the standard, and included these in your report.
  prefs: []
  type: TYPE_NORMAL
- en: 17.6.1\. OVERVIEW
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The topic of *Algorithms* has the following bullet points in achievement standard
    1.44, which this guide covers. This guide separates them into two categories.
  prefs: []
  type: TYPE_NORMAL
- en: 17.6.1.1\. COMPARING ALGORITHMS, PROGRAMS, AND INFORMAL INSTRUCTIONS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved** (A1): “describing the key characteristics, and roles of algorithms,
    programs and informal instructions”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit** (M1): “explaining how algorithms are distinct from related concepts
    such as programs and informal instructions”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence** (E1): “comparing and contrasting the concepts of algorithms,
    programs, and informal instructions”'
  prefs: []
  type: TYPE_NORMAL
- en: 17.6.1.2\. DETERMINING THE COST OF ALGORITHMS AND UNDERSTANDING VARIOUS KINDS
    OF STEPS IN ALGORITHMS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved** (A2): “describing an algorithm for a task, showing understanding
    of the kinds of steps that can be in an algorithm, and determining the cost of
    an algorithm for a problem of a particular size”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit** (M2): “showing understanding of the way steps in an algorithm for
    a task can be combined in sequential, conditional, and iterative structures and
    determining the cost of an iterative algorithm for a problem of size *n*”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence** (E2): “determining and comparing the costs of two different
    iterative algorithms for the same problem of size *n*”'
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed Digital Technology reports, you should base
    your explanations around personalised examples.
  prefs: []
  type: TYPE_NORMAL
- en: 17.6.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 - What’s the bigger picture?
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 - Sorting Algorithms
  prefs: []
  type: TYPE_NORMAL
- en: Note that 2.2 is not necessary for this project, as 2.2 focuses on *searching* algorithms,
    whereas this project focuses on *sorting* algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 17.6.3\. PROJECT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project involves understanding how selection sort works and the types of
    steps that can be in it and other algorithms, and then comparing the cost of selection
    sort and quicksort.
  prefs: []
  type: TYPE_NORMAL
- en: 17.6.3.1\. WRITING YOUR REPORT FOR THE MAIN BULLET POINTS THAT COVER ALGORITHMS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved**'
  prefs: []
  type: TYPE_NORMAL
- en: Carry out selection sort on a small amount of data. You can do this either using
    the balance scale interactive in the field guide (recommended), a physical set
    of balance scales if your school has them (normal scales that show the exact weights
    are unsuitable), or as a trace you did using pencil and paper (not recommended).
    Count how many comparisons you made to sort the items.
  prefs: []
  type: TYPE_NORMAL
- en: Take screenshots/ photos of you using the interactive or balance scales to do
    the sorting. Three or four pictures would be ideal (i.e. one showing the initial
    state of the scales and weights, one or two in the middle where you are comparing
    weights, and one at the end where all the weights are sorted). Use a drawing program
    to draw on each of the pictures and show which weights have been sorted so far,
    and which have not. Put on the screenshots how many comparisons have been made
    so far in the sorting process. Write a short explanation of what is happening
    in the images. Make sure you include the total number of comparisons that was
    needed to sort the items in your report.
  prefs: []
  type: TYPE_NORMAL
- en: Describe (in your own words with a few sentences) the overall process you carried
    out to sort the weights or numbers. Try and make your explanation general, e.g.
    if you gave the instructions to somebody who needs to know how to sort 100 numbers,
    or 500 numbers, the instructions would be meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**'
  prefs: []
  type: TYPE_NORMAL
- en: For merit, you need to make it clear that you understand that algorithms can
    contain iterative, conditional, and sequential steps. If you don’t know what these
    terms mean, go have another look at the field guide. Get a Scratch program (or
    another language if you are fairly confident with understanding the language)
    that implements selection sort. Take a screenshot of it, or a large part of it
    (you want to ensure that the screenshot takes up no more than half a page in the
    report, but is still readable) and open it in a drawing program such as paint.
    Add arrows and notes showing a part of the algorithm that is sequential, part
    that is conditional, and part that is iterative.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that some algorithms are a lot faster than others, especially as the
    size of the problem gets bigger. It isn’t necessarily the case that if you try
    to sort twice as many items then it will take twice as long. As a quick warm up
    investigation to give you some idea of this, try the following.
  prefs: []
  type: TYPE_NORMAL
- en: Get an implementation of selection sort (there are some linked to at the end
    of the chapter in the field guide). Start by choosing a number between 10 and
    20\. How many comparisons does it take to sort that many randomly generated numbers
    with your chosen algorithm? Now, try sorting twice as many numbers. How many comparisons
    did it take now? Does it take twice as many? Now, try sorting 10 times as many
    numbers. Does it take 10 times as many comparisons? How many more times the original
    problem size’s number of comparisons does it actually take? Hopefully you are
    starting to see a trend here.
  prefs: []
  type: TYPE_NORMAL
- en: '*If you aren’t attempting excellence,* include the numbers you got from the
    warm up investigation, along with an explanation of the trend you found. *If you
    are attempting excellence, you should do the warm up investigation as it will
    help you (and will only take a few minutes), but you don’t need to write about
    it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**'
  prefs: []
  type: TYPE_NORMAL
- en: You probably found in the activity for merit that selection sort isn’t a very
    good algorithm. So how much better is quicksort? Does the difference become more
    noticeable as you try to sort more numbers? For your report, you are going to
    compare selection sort with quicksort. Your objective is to show how much the
    difference in comparisons between selection sort and quicksort changes as the
    number of items to be sorted is increased.
  prefs: []
  type: TYPE_NORMAL
- en: Choose 10 numbers in the range of 1 to 1000 (you will need a good variety of
    numbers, some high and some low. Do not pick the same numbers as your classmates!)
    For each of your 10 numbers, try sorting that many values with each of the sorting
    algorithms. Record your results in a table that has a column for the problem size,
    a column for how many comparisons selection sort used, and a column for how many
    comparisons quicksort used.
  prefs: []
  type: TYPE_NORMAL
- en: The best way of visualising the data you have just collected is to make a graph
    (e.g. using Excel). Your graph should have 2 lines; one for quicksort and one
    for selection sort, showing how the number of comparisons increases as the size
    of the problem goes up. Make sure you label the graph well. A simple way of making
    the graph is to use a scatter plot and put in lines connecting the dots (make
    sure the data for the graph is increasing order with the smallest problem sizes
    first and largest last so that the line gets drawn properly). Ask your teacher
    for guidance if you are having difficulty with excel.
  prefs: []
  type: TYPE_NORMAL
- en: Look at your graph. Does the rate of increase for the two algorithms seem to
    be quite different? Discuss what your graph shows. If you aren’t sure what to
    include in the discussion of your findings, you could consider the following questions
    (optional).
  prefs: []
  type: TYPE_NORMAL
- en: What happens to the number of comparisons when you double how many numbers you
    are sorting with quicksort? What about when you sort 10 times as many numbers?
    How is this different to when you used selection sort at the start?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the largest problem you can solve within a few seconds using selection
    sort? What about with quicksort?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you had a database with 1 million people in it and you needed to sort them
    by age, which of the two algorithms would you choose? Why? What would happen if
    you chose the other algorithm?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.6.3.2\. WRITING THE PART OF YOUR REPORT THAT ADDRESSES “COMPARING ALGORITHMS/
    PROGRAMS/ INFORMAL INSTRUCTIONS”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved/ Merit/ Excellence**'
  prefs: []
  type: TYPE_NORMAL
- en: We recommend doing this part after you have done programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: All three levels (A/M/E) are subsumed by the E requirement, so you should try
    to do that i.e. “comparing and contrasting the concepts of algorithms, programs,
    and informal instructions”. You should refer to examples you used in your report
    or include additional examples (e.g. a program used as an example in the programming
    languages topic, or an algorithm describing the sorting process, etc). If you
    are confused, have another look at the field guide. You should only need to write
    a few sentences to address this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 17.6.4\. HINTS FOR SUCCESS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don’t confuse “algorithm cost” with the “algorithm length”. The number of lines
    in the algorithm or program normally unrelated to the cost. Cost is the time the
    algorithm actually takes to run, or the number of comparisons that have to be
    made. You can find more information in the Field Guide if you are not sure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we recommend using the balance scales interactive, if you do include a
    pen and paper trace, don’t give yourself more than 5 or 6 values to sort, and
    use an efficient layout that ensures the entire trace takes no more than about
    half a page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resize screenshots/ photos so that they are large enough to see what is on them,
    but not taking up unnecessary space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be sure to label the axis of your graph clearly so that the marker knows what
    your graph shows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.6.5\. RECOMMENDED NUMBER OF PAGES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within the 4 pages we recommend for algorithms, a possible breakdown is:'
  prefs: []
  type: TYPE_NORMAL
- en: '1 ½ pages: Screenshots and explanations of you carrying out a chosen algorithm
    and determining the cost of it for your example problem (**Achieved**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '¼ page: General instructions for carrying out your chosen algorithm (**Achieved**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '½ page: Example of the iterative, conditional, and sequential steps that can
    be in an algorithm (**Merit**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1 ½ pages: Your investigation and data collected for merit/ excellence. Including
    results and discussion (**Merit/ Excellence**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '¼ page: Explanation of the difference between algorithms, programs, and informal
    instructions (**Achieved/ Merit/ Excellence**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are *maximums*, not targets!
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you go over 4 pages for Algorithms, then you may have to use fewer
    pages for one of the other two topics, which could be problematic. No other material
    should be included for Algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 17.7\. HUMAN COMPUTER INTERACTION (1.44)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting Human Computer Interaction in digital
    technologies achievement standard 1.44 (AS91074).
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done projects
    covering the topics of Algorithms and Programming Languages, and included these
    in your report.
  prefs: []
  type: TYPE_NORMAL
- en: 17.7.1\. OVERVIEW
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Human Computer Interaction has the following bullet points in achievement standard
    1.44, which this guide covers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: “describing the role of a user interface and factors that contribute
    to its usability”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “explaining how different factors of a user interface contribute
    to its usability”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**: “discussing how different factors of a user interface contribute
    to its usability by comparing and contrasting related interfaces”'
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed reports, you should base your explanations around
    personalised examples.
  prefs: []
  type: TYPE_NORMAL
- en: 17.7.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  prefs: []
  type: TYPE_NORMAL
- en: Read all of these sections, as they give the necessary introduction of the topic
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 - What’s the Big Picture?
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 - Users and Tasks
  prefs: []
  type: TYPE_NORMAL
- en: Read one (or both if you are keen) of these sections as they will give you some
    ideas for evaluating an interface in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 - Interface Usability
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 - Usability Heuristics
  prefs: []
  type: TYPE_NORMAL
- en: 17.7.3\. PROJECT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, you will carry out a usability evaluation carrying out a specific
    task with a chosen interface. Unless you are good at seeing things from other
    people’s perspectives, it is best to find a helper who will carry out the task
    with the interface with you observing them
  prefs: []
  type: TYPE_NORMAL
- en: 17.7.3.1\. CHOOSING AN INTERFACE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The interface you choose should be one your helper is not familiar with,
  prefs: []
  type: TYPE_NORMAL
- en: Because you will need to compare related interfaces for excellence, make sure
    you choose an interface for which you will also be able to find a second related
    interface to compare with (e.g. two different alarm clocks). The second interface
    should also be one you are not familiar with (otherwise you will be biased).
  prefs: []
  type: TYPE_NORMAL
- en: Your interface should also be specific. By this we mean it should just have
    one obvious function. e.g. texting capabilities of a cellphone, file chooser on
    a computer, etc. iPhone vs Samsung Phone, or Windows vs Macintosh are too general
    as there are thousands of aspects to these interfaces! You would need to pick
    specific apps or programs within them that typically only need a few steps to
    complete a task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some possible pairs of interfaces you could use are:'
  prefs: []
  type: TYPE_NORMAL
- en: Online booking systems for two different airlines (e.g. Air NZ vs Jetstar)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two different friend’s cell phones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two different email clients you have never used before (don’t forget about the
    many webmail clients. Even signing up for webmail addresses could prove to be
    challenging in some cases!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try heating something in 2 different microwaves. Cheap microwaves are notorious
    for being inconsistent and illogical to use. [Note that running a microwave with
    nothing in it will damage it! You would be best to put something inside it while
    you are experimenting with its interface. Water in a microwave safe glass is fine]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a couple of apps/ programs/ for setting an alarm (many exist). You could
    choose ones that go on a phone or on your computer, or one of each. A physical
    alarm clock would be good.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two different drawing programs you have never used before
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that an interface you designed yourself is unsuitable because you will
    know how it works in great detail.
  prefs: []
  type: TYPE_NORMAL
- en: 17.7.3.2\. CHOOSING A TASK WITH THE INTERFACE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have chosen an interface, you need to think of one or two common tasks
    that are carried out with your chosen interface. The tasks should be specific.
    Some tasks (depending on the interfaces you chose) could be:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting an alarm that will ring at 4:25am tomorrow to catch an early flight
    (or for a more sophisticated interface, at 7:25am on Monday, Tuesday, Wednesday,
    and Friday i.e. all weekdays except Thursday)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a text to a friend that says “What are you doing at 3pm today? :-)”
    [Symbols are good to include in the message]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a phone background to a photo you found online
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heating some food or water in a microwave for 1 minute, 20 seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Booking the cheapest flight that will arrive before 11 AM in Auckland from Christchurch,
    on the next Saturday (stop once you get to the part that asks for payment details!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw a smiley face with a drawing program. Put your name below the smiley face.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.7.3.3\. WRITING YOUR REPORT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to satisfy the requirements of the standard, you should do the following
    and include all your answers in your report. A photos and screenshots of your
    interface and various aspects of it are useful to include.
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of the interface(s) you have chosen? How will they help
    the user achieve their task?
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved/ Merit (Note that this is needed for achieved, but should also cover
    merit)**'
  prefs: []
  type: TYPE_NORMAL
- en: Try carrying out your chosen task with one of the interfaces, or observe a helper
    carrying out the task. Take notes of every time you or your helper are confused,
    select an incorrect option (or menu), something happens you didn’t expect (no
    matter how minor it is), something happens that wastes time, etc. (there is some
    more detail on doing this here: [http://www.cs4fn.org/usability/cogwalkthrough.php](http://www.cs4fn.org/usability/cogwalkthrough.php))
  prefs: []
  type: TYPE_NORMAL
- en: Think back to sections 3.3 and/or 3.4 of the book. Explain the characteristics
    of the interface that caused the problems you identified. Which characteristics
    of the interface made it easy for the user to figure out how to carry out the
    task?
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to briefly describe the context of each characteristic (e.g. what was
    the user trying to accomplish at the time? What were they expecting to see happen)?
    You should explain 2 or 3 characteristics (2 is fine if you are attempting excellence,
    as you will have 4 characteristics between the 2 interfaces which is enough!).
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**'
  prefs: []
  type: TYPE_NORMAL
- en: Carry out the chosen task with the second interface, and do the same as you
    did for Achieved/Merit with it (consider similar characteristics to before, and
    focus on seeing if the second interface has similar issues to the first interface).
    What was different between the two interfaces? Which interface did you (or your
    helper) prefer using? Why? If you were designing an interface that could be used
    for the same task, which ideas would you take from each interface?
  prefs: []
  type: TYPE_NORMAL
- en: 17.7.4\. HINTS FOR SUCCESS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be careful to talk about interface usability rather than just features. For
    example, a cell phone might have a fancy camera able to take very high resolution
    photos (a feature), but what we’re interested in is how easy it actually is for
    somebody to take a photo with the camera (a usability factor), especially how
    easy it is to go from having the phone in your pocket to getting the photo, or
    from taking the photo to sharing or printing it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your helper struggles to complete the task with the interface, it is likely
    to be because the interface was not designed well for them. This gives you great
    material for your project - look for the reasons they had trouble and don’t blame
    them, as it isn’t their fault.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose an interface that you or your helper rarely/ never use, otherwise you
    may be blind to usability issues because you’ve got used to working with them!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t evaluate an interface you designed yourself. As we said in the book, the
    designer knows the interface really well, and is the worst person to evaluate
    it!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The page limit given by NZQA for the length of your report includes your work
    on algorithms and programming languages. The limit provides enough space to write
    an excellent report, but to avoid blowing out the page length:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to keep photos/ screenshots large enough to see, but not so large they take
    up needless amounts of space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you write concisely and clearly, you may be able to cover all the requirements
    with a page or less of writing (excluding pictures). This is fine, and in fact
    desirable for the marker as long as you have covered all the requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.7.5\. RECOMMENDED NUMBER OF PAGES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within the 3 pages we recommend for Human Computer Interaction, you should
    include a few images of your interface, and some explanations of the usability
    factors. For the project outlined above, a possible breakdown is:'
  prefs: []
  type: TYPE_NORMAL
- en: ½ page of text introducing the topic, your chosen interface, and chosen tasks.
    (**Achieved**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ½ page of text explaining the usability factors identified in the first observation.
    (**Achieved/Merit**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ½ page of text explaining usability factors identified in the second observation
    (**Excellence**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ½ page of text discussing comparing the two interfaces (**Excellence**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up to 1 page worth of images (mixed with the above); ensure they are shrunk
    down enough that they are legible but not wasting space. You may decided instead
    to do a little more writing and include a fewer images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are *maximums*, not targets!
  prefs: []
  type: TYPE_NORMAL
- en: The key to this topic is writing succinctly. Be careful to not ramble. You might
    not be able to include everything you wanted to; this is okay. Just prioritise
    and focus on the most interesting 2 or 3 issues for each interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you go over 3 or 4 pages for Human Computer Interaction, then you
    may have to use fewer pages for one of the other two topics, which could be problematic.
  prefs: []
  type: TYPE_NORMAL
- en: No other material should be included for Human Computer Interaction. For example,
    don’t include a list of heuristics explaining each one, or a list of general usability
    factors. You should only describe factors that directly relate to your chosen
    user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 17.8\. PROGRAMMING LANGUAGES (1.44)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students writing about the topic of Programming Languages
    in Digital Technologies achievement standard 1.44 (AS91074).
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done projects
    covering the topics of *Algorithms* and *Human Computer Interaction*, and included
    these in your report.
  prefs: []
  type: TYPE_NORMAL
- en: 17.8.1\. OVERVIEW
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programming Languages has the following bullet points in achievement standard
    1.44, which this guide covers. Note that merit is split into two bullet points.
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: “describing the role and characteristics of programming languages,
    including the different roles and characteristics of high level languages and
    low level (or machine) languages, and the function of a compiler”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “explaining how the characteristics of programming languages, including
    the different characteristics of high level and low level (or machine) languages,
    are important for their roles”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “explaining the need for programs to translate between high and
    low level languages”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**: “comparing and contrasting high level and low level (or machine)
    languages, and explaining different ways in which programs in a high level programming
    language are translated into a machine language'
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed reports, you should base your explanations around
    personalised examples.
  prefs: []
  type: TYPE_NORMAL
- en: 17.8.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives and activities in the following
    sections of the CS Field Guide in order to prepare yourself for the assessed project.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 - What’s the Big Picture? (and an introduction to what programming is, intended
    for those of you with limited programming experience)
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 - Machine Code (Low Level Languages)
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 - A Babel of Programming Languages (High Level Languages)
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 - How does the Computer Process your Program? (Compilers and Interpreters)
  prefs: []
  type: TYPE_NORMAL
- en: Note that you don’t need to read about all the programming languages in 4.3\.
    It is important that you actually do the activities in 4.2 (and 4.1 if you don’t
    know much about programming).
  prefs: []
  type: TYPE_NORMAL
- en: 17.8.3\. PROJECT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project consists of two main components. The first involves making a couple
    of examples
  prefs: []
  type: TYPE_NORMAL
- en: 17.8.3.1\. MAKING EXAMPLES FOR YOUR REPORT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need two examples of programs to include in your report; one that is
    in a high level language and one that is in a low level language. For the high
    level language example, you should use a program you wrote yourself, or make a
    small modification of a high level language program from the field guide
  prefs: []
  type: TYPE_NORMAL
- en: Include your program examples in your report as either screenshots or plain
    text. Note that the Hints for Success section has some advice on displaying code
    in a report.
  prefs: []
  type: TYPE_NORMAL
- en: Briefly explain what each of the programs does (ideally you should have run
    them). e.g. does it add numbers, or does it print some output?. You do not need
    to explain how it does it (i.e. no need to explain what each statement in the
    program does). What output do your programs give? The purpose of this is to show
    the marker that you do know what your example does.
  prefs: []
  type: TYPE_NORMAL
- en: 17.8.3.2\. HIGH AND LOW LEVEL LANGUAGES (ACHIEVED/MERIT/ EXCELLENCE)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What is the main difference(s) you see between the high level language and the
    low level language? Why would a human not want to program in the language shown
    in your low level programming language example? What made modifying the low level
    programs in section 4.2 of the field guide challenging? Given that a human probably
    doesn’t want to program in a low level language, why do we need low level programming
    languages at all? What is their purpose?
  prefs: []
  type: TYPE_NORMAL
- en: When you wrote your high level program (or modified an existing program), what
    features of the language made this easier compared to when you attempted to modify
    a low level program? Why are there many different high level programming languages?
  prefs: []
  type: TYPE_NORMAL
- en: In order to make your answers really clear, you might like to quote a few lines
    of your code examples which illustrate the points you make (e.g. some code that
    is cryptic and some code that you can tell easily what it does).
  prefs: []
  type: TYPE_NORMAL
- en: 17.8.3.3\. COMPILERS AND INTERPRETERS (ACHIEVED/MERIT/ EXCELLENCE)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a compiler for the language your high level program example is written
    in, how would you use it to allow the computer to run your program? (Even if your
    language is an interpreted one, such as Python, just explain what would happen
    if you had a compiler for it, as technically a compiler could be written for any
    language).
  prefs: []
  type: TYPE_NORMAL
- en: If you have access to a compiler, you could explain how you have to use it,
    and show an example of its output (the compiled program)
  prefs: []
  type: TYPE_NORMAL
- en: What about an interpreter? How does the interpreter’s function differ from a
    compiler in the way interpreted programs and compiled programs are run? Which
    is mostly used?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some more ideas for comparing compilers and interpreters: One way
    to consider the difference is to explain what happens if a program is transferred
    from one computer to another. Does it still run on the other computer? Does someone
    else need the same compiler or interpreter to run your software? Can you type
    in each line of a program and have it executed as you type it, or does the whole
    program have to be available before it can be run?'
  prefs: []
  type: TYPE_NORMAL
- en: 17.8.4\. HINTS FOR SUCCESS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should easily be able to explain the concepts in half to one page of writing
    (in addition to the program examples). Any more than this is probably unnecessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t use large programs in the examples. Keep it to 5 to 10 lines (slightly
    fewer is okay!) for the high level program, and a bit more for the low level program.
    A good trick for displaying the low level program without wasting space is to
    use 2 columns, because the low level language statements are so short ( you could
    remove the comments in the code). If using a screenshot, get 2 screenshots with
    roughly half the program each and put them side by side, and if using text directly
    in report, just format it to 2 columns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If displaying the program examples as plain text in your report, then make the
    font size smaller for the code to try and prevent lines splitting (8pt or 9pt
    should be fine, as long as your explanations in the rest of your report are using
    the font size that NZQA requires!) Preferably use a fixed width font for program
    code as a variable width font can mess up the layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If displaying the program examples as screenshots and the editor background
    is darker than the text colour, invert the colours using an image editor so as
    to make it easier to read on paper, and not waste black ink/toner!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paraphrasing definitions of high level languages, low level languages, compilers,
    and interpreters from Wikipedia or another site is not satisfactory for the standard.
    The marker needs to see what you understand, not what Wikipedia understands! You
    can show your understanding by explaining the ideas using your own examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.8.5\. RECOMMENDED NUMBER OF PAGES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within the 2 pages we recommend using for programming languages, a possible
    breakdown is:'
  prefs: []
  type: TYPE_NORMAL
- en: '½ page: Example of low level program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '½ page: Example of high level program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '½ page: High Level and Low Level languages discussion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '½ page: Compilers and Interpreters discussion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are *maximums*, not targets!
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you go over 2 pages for Programming Languages, then you may have
    to use fewer pages for one of the other two topics, which could be problematic.
    No other material should be included for Programming Languages
  prefs: []
  type: TYPE_NORMAL
- en: 17.9\. 2.44 ASSESSMENT GUIDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This document provides a brief introduction to teachers on the Computer Science
    Field Guide assessment guides for NCEA Achievement standard AS91371 (2.44).
  prefs: []
  type: TYPE_NORMAL
- en: 17.9.1\. TOPICS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 2.44 has bullet points for the following topics in computer science.
  prefs: []
  type: TYPE_NORMAL
- en: Representing Data using Bits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding (split into 3 sub topics) - Compression - Error Control Coding - Encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Human Computer Interaction (different to 1.44)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these topics has a chapter in the Computer Science Field Guide, which
    this assessment guide is based on.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple assessment guides for representing data and the encoding
    topics, of which students need to do a subset. The following explanations outline
    what students should cover.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the topics can be covered independently, although using a common context
    for all or most of them (such as considering an mp3 player or photo display that
    represents data using bits, uses encoding and has an interface that can be evaluated)
    can make personalisation easier.
  prefs: []
  type: TYPE_NORMAL
- en: 17.9.1.1\. REPRESENTING DATA USING BITS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Students should choose at least **two** data types and cover the “ways in which
    different types of data can be represented using bits” in order to get achieved,
    and they should choose at least two different representations for **each** of
    their chosen data types for the merit level. (While two representations of two
    types is sufficient to meet the exact requirements of the standard, it needn’t
    take a lot of space to go a little beyond this, and this can be more convincing
    for showing student understanding compared with doing the bare minimum.) The following
    table shows common types of data that students could choose (they should choose
    two rows from the table to meet the achieved requirement). For merit they should
    should choose an alternative representation with a different number of bits; examples
    are shown in the “Merit” column.
  prefs: []
  type: TYPE_NORMAL
- en: Data Type | Achieved | Merit |
  prefs: []
  type: TYPE_NORMAL
- en: '| sliderBinary Numbers (Whole numbers)slider | sliderPositive numbersslider
    | sliderNegative numbers (simple sign bit) or Floating pointslider or Twos complement
    |'
  prefs: []
  type: TYPE_TB
- en: '| sliderCharacters/ Textslider | sliderASCIIslider | sliderUnicodeslider |'
  prefs: []
  type: TYPE_TB
- en: '| sliderImages/ Coloursslider | slider24 bit colourslider | sliderColour with
    fewer bitsslider |'
  prefs: []
  type: TYPE_TB
- en: '| sliderSoundslider | WAV file representation (16 bit, 44KHz) | Higher or lower
    quality sound (24 bit, 8 bit) and/or different sample rates |'
  prefs: []
  type: TYPE_TB
- en: Note that data types and representations currently covered in the field guide
    are in italics. Binary numbers is a prerequisite for colours, and are recommended
    for all students. Students who struggle with binary numbers should just aim to
    represent a few numbers in binary (e.g. their age, birthday, etc) and then move
    onto representing text.
  prefs: []
  type: TYPE_NORMAL
- en: In general, we recommend choosing binary numbers for all projects.
  prefs: []
  type: TYPE_NORMAL
- en: If students are using a common device as an example, chances are they won’t
    be able to find out how it represents data, but they could say how they would
    represent the data if they had to write the program that is running on the device
    e.g. how they might store the name of a song, a date, the length of a file, the
    number of tracks etc. These will typically have minimum and maximum values that
    will dictate the number of bits needed to store them.
  prefs: []
  type: TYPE_NORMAL
- en: This topic does not have excellence requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 17.9.1.2\. ENCODING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the standard, students need to describe each of the three encoding topics
    in order to get achieved, and do a more in-depth project on one in order to get
    merit or excellence.
  prefs: []
  type: TYPE_NORMAL
- en: Students should choose do projects that cover **one** of the following selections
    (i.e. just the shaded entries).
  prefs: []
  type: TYPE_NORMAL
- en: '| **Compression** | **Error Control Coding** | **Encryption** |'
  prefs: []
  type: TYPE_TB
- en: '| Achieved | Achieved | Achieved |'
  prefs: []
  type: TYPE_TB
- en: '| Merit | Merit | Merit |'
  prefs: []
  type: TYPE_TB
- en: '| Excellence | Excellence | Excellence |'
  prefs: []
  type: TYPE_TB
- en: OR
  prefs: []
  type: TYPE_NORMAL
- en: '| **Compression** | **Error Control Coding** | **Encryption** |'
  prefs: []
  type: TYPE_TB
- en: '| Achieved | Achieved | Achieved |'
  prefs: []
  type: TYPE_TB
- en: '| Merit | Merit | Merit |'
  prefs: []
  type: TYPE_TB
- en: '| Excellence | Excellence | Excellence |'
  prefs: []
  type: TYPE_TB
- en: OR
  prefs: []
  type: TYPE_NORMAL
- en: '| **Compression** | **Error Control Coding** | **Encryption** |'
  prefs: []
  type: TYPE_TB
- en: '| Achieved | Achieved | Achieved |'
  prefs: []
  type: TYPE_TB
- en: '| Merit | Merit | Merit |'
  prefs: []
  type: TYPE_TB
- en: '| Excellence | Excellence | Excellence |'
  prefs: []
  type: TYPE_TB
- en: Note that some assessment guides provide projects that cover only achieved,
    and others go to excellence. For topics that students are only covering to achieved,
    they can either follow an achieved guide, or the achieved component of an excellence
    guide.
  prefs: []
  type: TYPE_NORMAL
- en: At the excellence level students are required to evaluate “a widely used system
    for compression coding, error control coding, or encryption”. The guides discuss
    some widely used systems, but the thing to note is that only *one* system need
    be considered (e.g. JPEG is a widely used compression system, so evaluating JPEG
    would be sufficient; an alternative would be checksums used in bar codes). The
    evaluation would need to involve a comparison with *not* using the system, so
    for JPEG it might be with a RAW or BMP file; for bar codes, it would be to consider
    what would be different if a check digit isn’t used.
  prefs: []
  type: TYPE_NORMAL
- en: One issue to be aware of is that the data representation section includes reducing
    the number of bits (the “bit depth”) for images and sound to reduce the space
    that they take. This overlaps with the idea of compression, but is should *not* be
    used for the compression part of the standards, as it’s a very crude way to reduce
    file size, but not generally regarded as a compression method that takes advantage
    of the content of a file to make it smaller. For example, students could use examples
    of images with 16-bit and 24 colour to illustrate two representations of a type
    of data for data representation, but they should use an image compression method
    like JPEG, GIF and PNG to illustrate compressing image files.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is that hexadecimal is not a good example for students to use
    as a different representation of data, as it is simply a shorthand for binary.
    Writing a number as 01111010 (binary) or 7A (hexadecimal) represents exactly the
    same bits stored on a computer with exactly the same meaning; the latter is easier
    for humans to read and write, but both are 8-bit representations that have the
    same range of values. It is a useful shorthand, but shouldn’t be used as a second
    representation for a type of data, or as a different type of data.
  prefs: []
  type: TYPE_NORMAL
- en: 17.9.1.3\. HUMAN COMPUTER INTERACTION
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Human Computer Interaction is straightforward, and we provide one 2.44 guide
    for it. Note that the requirements for 2.44 HCI are different to 1.44 HCI.
  prefs: []
  type: TYPE_NORMAL
- en: 17.9.2\. ORDER OF TOPICS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The three topics can be completed in any order, although encoding is best covered
    after representing data.
  prefs: []
  type: TYPE_NORMAL
- en: It may be a good idea to cover Human Computer Interaction (HCI) first, as students
    should already have some familiarity with it if they did 1.44, and it can help
    if they are able to start work on it early, then work on the other topics, and
    come back to HCI once they’ve had a while to reflect on the issues.
  prefs: []
  type: TYPE_NORMAL
- en: 17.9.3\. PERSONALISATION AND STUDENT VOICE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important that students use personalised examples to base their explanations
    around, and that the explanations are in their own words, and based on their example
    (rather than being a paraphrase from wikipedia, for example).
  prefs: []
  type: TYPE_NORMAL
- en: Personalised means that the student’s example is different to their classmates.
    For example, they may represent their age or name using bits, carry out the parity
    trick (error control coding) with a friend choosing random combinations and take
    photos, and they may carry out their own usability exploration of a device they
    chose, and report on it in their own words.
  prefs: []
  type: TYPE_NORMAL
- en: 17.9.4\. REPORT LENGTH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note that the page limit given by NZQA is not a target. The
    markers prefer reports that are short and to the point.
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible breakdown is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Representing Data using Bits: 2 pages (1 per data type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Encoding: 5 pages (1 for each achieved project and 3 for the achieved/ merit/
    excellence project)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Human Computer Interaction: 3 pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The assessment guides provide further guidance on how to stay within these limits.
    With 2.44, it is particularly important to try and keep each individual project
    in the report within the recommended limit, as space is tighter than for 1.44
    and 3.44.
  prefs: []
  type: TYPE_NORMAL
- en: Some hints to reduce total length
  prefs: []
  type: TYPE_NORMAL
- en: Only include what is relevant to the standard. While covering additional material
    in class is valuable for learning, additional content that doesn’t demonstrate
    understanding of the topics in the standard is only a distraction in the report.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resize screenshots and photos so that they are still readable, although don’t
    take up unnecessary space. Use cropping to show the relevant parts of the image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t leave unnecessary spaces in the report. It both looks untidy and makes
    it more difficult for the marker to find what they are looking for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.10\. REPRESENTING DATA USING BITS (BINARY NUMBERS) (2.44)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting Representing Data using Bits in digital
    technologies achievement standard 1.44 (AS91074). You will need to cover **two**different
    types of data to meet the requirements of the standard (each assessment guide
    only covers one).
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done one more
    project for representing data using bits and projects covering the topics of *Encoding*and *Human
    Computer Interaction*, and included these in your report.
  prefs: []
  type: TYPE_NORMAL
- en: 17.10.1\. OVERVIEW
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The topic of representing data using bits has the following bullet points in
    achievement standard 1.44, which this guide covers. Note that there is no excellence
    criteria for this topic. This assessment guide only covers one of the two types
    of data required for achieved.
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: “describing ways in which different types of data can be represented
    using bits”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “comparing and contrasting different ways in which different types
    of data can be represented using bits and discussing the implications”'
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed reports, you should base your explanations around
    personalised examples.
  prefs: []
  type: TYPE_NORMAL
- en: 17.10.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  prefs: []
  type: TYPE_NORMAL
- en: Read all of these sections, as they give the necessary introduction of the topic
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 - What’s the Big Picture? (General information about bits)
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 - Representing numbers with bits (Relevant to the achieved criteria)
  prefs: []
  type: TYPE_NORMAL
- en: 5.8 - Computers representing numbers in practice (Relevant to the merit criteria)
  prefs: []
  type: TYPE_NORMAL
- en: 17.10.3\. PROJECT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 17.10.3.1\. WRITING YOUR REPORT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Achieved, you need to demonstrate that you know how to convert decimal
    numbers (convention notation with 10 digits) into binary numbers. You can use
    a tool to help you do this, although you need to be able to describe how the answer
    was derived. You should show the binary representation for at least three numbers.
    Some ideas of numbers you could use are:'
  prefs: []
  type: TYPE_NORMAL
- en: Your street number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The day and month of your date of birth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your age
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The age(s) of your sibling(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some more challenging ones if you are keen:'
  prefs: []
  type: TYPE_NORMAL
- en: Your year of birth (e.g. 2002)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The population of a city or country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distance between some cities (e.g. airline flight distances)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Briefly describe how a number is converted to binary.
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**'
  prefs: []
  type: TYPE_NORMAL
- en: The material about representing numbers in practice may be challenging, so don’t
    worry if you need to read over it a couple of times!
  prefs: []
  type: TYPE_NORMAL
- en: Think of a few different examples for different sized integers (both signed
    and unsigned ones) of a piece of data that you could store in that sized integer.
    For example, the age of a person could be stored in an 8 bit unsigned integer
    (people can’t be a negative age!), and the number of students in your school could
    be stored in an 8 bit or 16 bit integer, depending on how big your school is.
    Try to include examples of signed and unsigned integers, and of at least two different
    integer sizes. This means you will need at least three examples.
  prefs: []
  type: TYPE_NORMAL
- en: The field guide gives some other examples (e.g. programming languages and IP
    addresses) that are affected by the number of bits used to represent a number.
  prefs: []
  type: TYPE_NORMAL
- en: What are the consequences of making a wrong decision about how many bits to
    use to represent a number? In practice, how much of an issue is each of the consequences?
    Relate your answer to your examples above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optional extra: Give an example of a situation where a 32 bit integer would
    not be suitable. What do we do in practice to address this problem?'
  prefs: []
  type: TYPE_NORMAL
- en: 17.10.4\. HINTS FOR SUCCESS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that this part of the standard only goes up to the merit level. While
    you need to do some evaluation for merit, you should be mindful that the other
    topics go up to the excellence level, so they should make up the bulk of your
    in-depth discussions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember to do a second project on a different type of data for the merit level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful to use personalised examples (i.e. represent different numbers to
    your classmates). It may be a good idea to pick a larger number (e.g. in the millions)
    to minimise the chance of it being the same as others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.10.5\. RECOMMENDED NUMBER OF PAGES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We recommend that this project does not take up more than 1 page. Examples should
    be small, and discussions should be short and to the point, keeping in mind that
    there is no excellence criteria for this topic.
  prefs: []
  type: TYPE_NORMAL
- en: 17.11\. REPRESENTING DATA USING BITS (CHARACTERS/TEXT) (2.44)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting Representing Data using Bits in digital
    technologies achievement standard 1.44 (AS91074). You will need to cover **two**different
    types of data to meet the requirements of the standard (each assessment guide
    only covers one). See the introduction for the 2.44 guides for more details on
    choosing topics; this guide covers the “characters/text” type of data.
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done one more
    project for representing data using bits and projects covering the topics of *Encoding*and *Human
    Computer Interaction*, and included these in your report.
  prefs: []
  type: TYPE_NORMAL
- en: 17.11.1\. OVERVIEW
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The topic of representing data using bits has the following bullet points in
    achievement standard 1.44, which this guide covers. Note that there is no excellence
    criteria for this topic. This assessment guide only covers one of the two types
    of data required for achieved.
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: “describing ways in which different types of data can be represented
    using bits”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “comparing and contrasting different ways in which different types
    of data can be represented using bits and discussing the implications”'
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed reports, you should base your explanations around
    personalised examples.
  prefs: []
  type: TYPE_NORMAL
- en: 17.11.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  prefs: []
  type: TYPE_NORMAL
- en: Read all of these sections, as they give the necessary introduction of the topic
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 - What’s the Big Picture? (General information about bits)
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 - Getting Started
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 - Representing text with bits
  prefs: []
  type: TYPE_NORMAL
- en: 5.7 - General representations of text (Required for Merit)
  prefs: []
  type: TYPE_NORMAL
- en: 17.11.3\. PROJECT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 17.11.3.1\. WRITING YOUR REPORT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved**'
  prefs: []
  type: TYPE_NORMAL
- en: For Achieved, you need to demonstrate that you know how to convert characters
    into binary numbers. ASCII, which uses 8-bit codes, is a simple system to explore
    for this. You should show the binary representation for a few characters; the
    easiest way to do this is to show the ASCII code for your name.
  prefs: []
  type: TYPE_NORMAL
- en: Briefly describe the relationship between characters and their ASCII code. A
    few sentences is fine.
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**'
  prefs: []
  type: TYPE_NORMAL
- en: The most common longer code for characters is Unicode, which actually covers
    multiple lengths of representations. You could show a conversion to Unicode for
    the characters in your name, but to contrast the power of Unicode, it’s ideal
    to show the representation of some characters that wouldn’t be possible in ASCII
    e.g. choose a Chinese (Simplified Chinese) or Japanese (Kanji) name for a city
    and explain how the characters would be represented. Discuss why more bits are
    needed for these character sets.
  prefs: []
  type: TYPE_NORMAL
- en: Use your example to discuss the tradeoffs that are made by using a 16-bit character
    representation, and to explain the limitations of the ASCII code.
  prefs: []
  type: TYPE_NORMAL
- en: You could also use the 5-bit Baudot code to contrast different representations
    of text, and again explain the tradeoffs between this and either ASCII or Unicode.
  prefs: []
  type: TYPE_NORMAL
- en: 17.11.4\. HINTS FOR SUCCESS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that this part of the standard only goes up to the merit level. While
    you need to do some evaluation for merit, you should be mindful that the other
    topics go up to the excellence level, so they should make up the bulk of your
    in-depth discussions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember to do a second project on a different type of data for the merit level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful to use personalised examples (i.e. represent words that are personal
    to you such as your name or street name).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.11.5\. RECOMMENDED NUMBER OF PAGES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We recommend that this project does not take up more than 1 page. Examples should
    be small, and discussions should be short and to the point, keeping in mind that
    there is no excellence criteria for this topic.
  prefs: []
  type: TYPE_NORMAL
- en: 17.12\. REPRESENTING DATA USING BITS (IMAGES/COLOUR) (2.44)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting Representing Data using Bits in digital
    technologies achievement standard 1.44 (AS91074). You will need to cover **two**different
    types of data to meet the requirements of the standard (each assessment guide
    only covers one). See the introduction for the 2.44 guides for more details on
    choosing topics; this guide covers the “images/colour” type of data.
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done one more
    project for representing data using bits and projects covering the topics of *Encoding*and *Human
    Computer Interaction*, and included these in your report.
  prefs: []
  type: TYPE_NORMAL
- en: 17.12.1\. OVERVIEW
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The topic of representing data using bits has the following bullet points in
    achievement standard 1.44, which this guide covers. Note that there is no excellence
    criteria for this topic. This assessment guide only covers one of the two types
    of data required for achieved.
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: “describing ways in which different types of data'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “comparing and contrasting different ways in which different types
    of data can be represented using bits and discussing the implications”'
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed reports, you should base your explanations around
    personalised examples.
  prefs: []
  type: TYPE_NORMAL
- en: 17.12.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  prefs: []
  type: TYPE_NORMAL
- en: Read all of these sections, as they give the necessary introduction of the topic
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 - What’s the Big Picture? (General information about bits)
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 - Representing Numbers With Bits (Relevant to the achieved criteria)
  prefs: []
  type: TYPE_NORMAL
- en: 5.6 - Representing Images With Bits (Relevant to the achieved criteria)
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.1 - Representing High Quality Images Using Bits (Relevant to the achieved
    criteria)
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.3 - Representing colours using fewer bits (Relevant to the merit criteria)
  prefs: []
  type: TYPE_NORMAL
- en: 17.12.3\. PROJECT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 17.12.3.1\. WRITING YOUR REPORT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved**'
  prefs: []
  type: TYPE_NORMAL
- en: Using the colour matcher (note that it is at the start of section 5.6.3), choose
    a colour you like by clicking on the image. Try and match up the 24 bit colour
    hexagon to be the same colour as your selected colour. Don’t worry about the 8
    bit hexagon yet. If you have trouble, the interactive will help you.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have matched up the colour, make a screenshot of the colour matcher
    which you can include in your report.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have 3 numbers; one for each of red, green, and blue. Convert
    each of these numbers into 8 bit binary numbers. These 3 numbers put together
    make up the 24 bit number that represents your colour. Show your working in your
    report, and explain how you arrived at your answer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**'
  prefs: []
  type: TYPE_NORMAL
- en: For merit, you need to show what happens when fewer bits are used to represent
    each colour in an image. There are several ways you can go about this; we recommend
    exploring the various interactives on colour representation and experimenting
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: Include at least one screenshot of an interactive and your personalised example
    which shows what happens when fewer bits are used to represent the colours in
    the image.
  prefs: []
  type: TYPE_NORMAL
- en: What is the benefit of using fewer bits? What happens to the images when fewer
    bits are used? Are there certain kinds of images where it matters a lot? Are there
    other cases where the benefits of fewer bits outweigh the downsides?
  prefs: []
  type: TYPE_NORMAL
- en: 17.12.4\. HINTS FOR SUCCESS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that this part of the standard only goes up to the merit level. While
    you need to do some evaluation for merit, you should be mindful that the other
    topics go up to the excellence level, so they should make up the bulk of your
    in depth evaluations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember to do a second project on a different type of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may need to reread the section on representing numbers using bits if you
    cannot remember how to convert the numbers into binary. Additionally you could
    also look at the worked example for the large block of purple in the previous
    section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose a colour that has at least two of the three colour components somewhere
    in the middle of the slider. Examples such as 0, 255, and 1 are not helpful for
    showing your knowledge of binary representation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure the screenshots are large enough to be seen, but no larger!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.12.5\. RECOMMENDED NUMBER OF PAGES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We recommend that this project does not take up more than 1 page. Examples should
    be small, and discussions should be short and to the point, keeping in mind that
    there is no excellence criteria for this topic.
  prefs: []
  type: TYPE_NORMAL
- en: 17.13\. COMPRESSION (2.44) - RUN LENGTH ENCODING
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting compression (one of the three encoding
    subtopics) in digital technologies achievement standard 2.44 (AS91371).
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you only need to do one of the three encoding topics (Compression,
    Encryption, and Error Control Coding) to the excellence level. The other two only
    need to be done to the achieved level. This guide is suitable for both doing compression
    to the excellence level, but can also be used for the achieved level for compression.
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done projects
    covering the topics of encryption and error control coding to at least the achieved
    level, and projects covering the topics of representing data using bits and human
    computer interaction, and include these in your report.
  prefs: []
  type: TYPE_NORMAL
- en: 17.13.1\. OVERVIEW
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encoding has the following bullet points in achievement standard 2.44 which
    this guide covers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: “describing the concept of encoding information using compression
    coding, error control coding, and encryption; and typical uses of encoded information”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “discussing how a widely used technology is enabled by one or more
    of compression coding, error control coding, and encryption”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**: “evaluating a widely used system for compression coding, error
    control coding, or encryption”'
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed reports, you should base your explanations around
    personalised examples.
  prefs: []
  type: TYPE_NORMAL
- en: 17.13.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  prefs: []
  type: TYPE_NORMAL
- en: Read all of these sections, as they give the necessary introduction of the topics
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 - What’s the Big Picture?
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 - Run Length Encoding
  prefs: []
  type: TYPE_NORMAL
- en: 17.13.3\. PROJECT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the achieved criteria you will show how run length encoding works to compress
    a simple image. For the merit and excellence criteria you will investigate how
    and why run length encoding is used by fax machines, and then evaluate how effective
    it is for this purpose. *If you have chosen to focus on error control coding or
    encryption for merit and excellence, then you only need to meet the achieved criteria
    for this project.*
  prefs: []
  type: TYPE_NORMAL
- en: 17.13.3.1\. WRITING YOUR REPORT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved**'
  prefs: []
  type: TYPE_NORMAL
- en: Make a grid of squares (any size is fine, but it should be at least 6x6) and
    draw a picture by filling some of the squares with black and leave others white.
    Underneath (or alongside each row), show how a computer could represent your image
    using run length encoding. You should not worry about how it is represented at
    the bit level. It is fine to just use normal numbers which are comma separated
  prefs: []
  type: TYPE_NORMAL
- en: Count how many characters are needed to represent your image in its original
    form (i.e. how many squares does it contain?). Count how many characters were
    used in your run length encoding representation. Don’t forget to include the commas!
    How well did run length encoding compress your image?
  prefs: []
  type: TYPE_NORMAL
- en: Explain why you would want to use run length encoding on an image. Think about
    a more typical image, such as a scan of a page of writing - what sort of runs
    of black and white pixels will that have? What is the purpose of compression?
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit/ Excellence**'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the field guide, fax machines use run length encoding. What
    advantages does this provide to fax machines sending and receiving faxes?
  prefs: []
  type: TYPE_NORMAL
- en: Is run length encoding guaranteed to always make the amount of data needed to
    represent the image smaller? Try and come up with an example (to include in your
    report) where the amount of space required to store your image with run length
    encoding is more than the original representation. What about an example where
    it is a very small amount of data? You can use the following interactive (written
    by Hannah Taylor, a digital technologies teacher) to help you experiment and to
    quickly generate examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[http://taylormade.io/run-length-encoding.html](http://taylormade.io/run-length-encoding.html)'
  prefs: []
  type: TYPE_NORMAL
- en: You should have found that in some cases the compression is really good, and
    in others it makes things worse! You might remember from the book that it is impossible
    to design a lossless text compression method that makes every possible input smaller.
    What matters though is how good the compression is for its intended application.
    What would you expect a typical fax message to look like? (You might like to include
    an example, although shrink the image down so that it is less than ¼ of the page
    tall.)
  prefs: []
  type: TYPE_NORMAL
- en: 17.13.4\. HINTS FOR SUCCESS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you make your image for the achieved level, make it a real image rather
    than a grid containing random black and white squares.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put compression in its own section (your report should have suitable headings
    and subheadings for each topic to make it clear for the marker) and ensure that
    you briefly introduce the topic. It is important that your report clearly demonstrates
    that you know the difference between encryption, error control coding, and compression,
    and what their different purposes are.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you did compression only to the achieved level, half to one page should be
    enough. If you did merit and excellence, a couple of pages should be enough (shrink
    down the examples as much as is reasonable, particularly if you included a lot
    of them)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While you could potentially go into the details of how the computer represents
    the compressed image at the bit level, this is not necessary. The purpose of the
    encoding topic in 2.44 is for you to investigate the general ideas of how encoding
    works rather than the precise details of the representation with bits (simpler
    representations with bits are already covered in the first bullet point of the
    standard).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.14\. ENCRYPTION (2.44) - RSA CRYPTOSYSTEM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting encryption (one of the three encoding
    subtopics) in digital technologies achievement standard 2.44 (AS91371).
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you only need to do one of the three encoding topics (Compression,
    Encryption, or Error Control Coding) to the excellence level. The other two only
    need to be done to the achieved level. This guide is suitable for both doing encryption
    to the excellence level, but can also be used for the achieved level for encryption.
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done projects
    covering the topics of *error control coding* and *compression* to at least the
    achieved level, and projects covering the topics of *representing data using bits* and *human
    computer interaction*, and included these in your report.
  prefs: []
  type: TYPE_NORMAL
- en: 17.14.1\. OVERVIEW
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encoding has the following bullet points in achievement standard 2.44 which
    this guide covers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: “describing the concept of encoding information using compression
    coding, error control coding, and encryption; and typical uses of encoded information”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “discussing how a widely used technology is enabled by one or more
    of compression coding, error control coding, and encryption”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**: “evaluating a widely used system for compression coding, error
    control coding, or encryption”'
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed reports, you should base your explanations around
    personalised examples.
  prefs: []
  type: TYPE_NORMAL
- en: 17.14.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the activities in the following sections of
    the CS Field Guide in order to prepare yourself for the assessed project.
  prefs: []
  type: TYPE_NORMAL
- en: Read all of these sections, as they give the necessary introduction of the topics
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 - What’s the Big Picture?
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 - Substitution Ciphers
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 - Problems with Substitution Ciphers (Needed only for Merit/ Excellence)
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 - Public Key Cryptosystems (Needed only for Merit/ Excellence)
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 - The RSA Cryptosystem
  prefs: []
  type: TYPE_NORMAL
- en: Note that for this project, reading the field guide material thoroughly and
    doing all the activities is particularly important in order to understand and
    do a good project at the merit/ excellence level.
  prefs: []
  type: TYPE_NORMAL
- en: 17.14.3\. PROJECT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the achieved criteria you will show an example of the Caeser cipher and
    describe how by using a *key*, *plaintext* can be converted to *ciphertext*, and
    then the*ciphertext* can be converted back to *plaintext* by anybody who has the
    key.
  prefs: []
  type: TYPE_NORMAL
- en: For the merit and excellence criteria, you will show an example of the RSA cryptosystem,
    describing how its differences to Caesar cipher allow it to be used in practice,
    and then you will show the kinds of attacks and limitations that make the Caesar
    cipher unsuitable in practice, and discuss whether or not similar limitations
    exist in RSA.
  prefs: []
  type: TYPE_NORMAL
- en: 17.14.3.1\. WRITING YOUR REPORT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved**'
  prefs: []
  type: TYPE_NORMAL
- en: Do the following to make an example to include in your report.
  prefs: []
  type: TYPE_NORMAL
- en: Write a short sentence that you could send to a classmate (must be appropriate
    to include in your report). This message is your *plain text*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a number between 1 and 25 that will be your encryption key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a conversion table that shows how each letter in your *plain text* should
    be changed using your key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Encrypt* your *plain text* message using your chosen *key* in order to obtain
    your *ciphertext*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include your plain text, key, conversion table, and ciphertext in your report.
    Be sure to clearly label each of these four parts of your example using the correct
    terminology. What will your classmate need to decrypt the message?
  prefs: []
  type: TYPE_NORMAL
- en: Why is encryption so important in computer science? (assuming the cipher is
    one that is a lot more difficult to break than Caesar cipher!)
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit/ Excellence**'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a pair of RSA keys using the field guide interactive, and encrypt a
    message with the public key using the other field guide interactive. Then, show
    how it can be decrypted with the private key. Include the keys, plaintext, ciphertext,
    and a brief explanation of how public key cryptosystems such as RSA are used,
    and why they are so useful.
  prefs: []
  type: TYPE_NORMAL
- en: What kinds of systems in the world depend on RSA being able to resist attacks?
    What kinds of things would happen if somebody came up with a good way of breaking
    RSA?
  prefs: []
  type: TYPE_NORMAL
- en: In order to do a good evaluation of RSA cryptosystems, you will need to show
    why particular attacks will not work, and how some potential issues are addressed.
    Some of this will involve comparing to Caesar cipher. Show personalised examples
    of the following (come up with your own messages, don’t just copy the field guide
    ones!) Remember that the interactives in the field guide will help you to generate
    personalised examples.
  prefs: []
  type: TYPE_NORMAL
- en: Caesar cipher vs RSA on messages that are very similar (show an example for
    both algorithms so you can compare them)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of random padding in order to ensure that even if the same plaintext
    is encrypted more than once with the same public key, the ciphertext for each
    occurrence is different.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How long a typical sized RSA key might take to break (make sensible assumptions
    about the number of bits in the key, the number of computers able to work on breaking
    it, computer speed, etc). Make sure you discuss the implications, and how much
    (or little) slightly modifying your assumptions would change the overall conclusion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each of your examples, explain why the issue is very important to address
    (what kinds of attacks could be carried out if the issue had been overlooked?)
  prefs: []
  type: TYPE_NORMAL
- en: RSA isn’t perfect, and there are a few ways to potentially break it which you
    should have read about in the field guide. What is at least one of these problems?
    How is it addressed? Is this solution guaranteed to always work?
  prefs: []
  type: TYPE_NORMAL
- en: 'Discuss what you have found from this evaluation: is RSA a good cryptosystem?'
  prefs: []
  type: TYPE_NORMAL
- en: 17.14.4\. HINTS FOR SUCCESS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Display your examples using the standard font size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put encryption in its own section (your report should have suitable headings
    and subheadings for each topic to make it clear for the marker) and ensure that
    you briefly introduce the topic. It is important that your report clearly demonstrates
    that you know the difference between encryption, error control coding, and compression,
    and what their different purposes are.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should be able to discuss this material, with examples, in about 2 or 3
    pages of your report.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.15\. ERROR CONTROL CODING (2.44) - CHECK SUMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting error control coding (one of the three
    encoding subtopics) in digital technologies achievement standard 2.44 (AS91371).
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you only need to do one of the three encoding topics (Compression,
    Encryption, or Error Control Coding) to the excellence level. The other two only
    need to be done to the achieved level. This guide is suitable for both doing error
    control coding to the excellence level, but can also be used for the achieved
    level for error control coding.
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done projects
    covering the topics of *encryption* and *compression* to at least the achieved
    level, and projects covering the topics of *representing data using bits* and *human
    computer interaction*, and included these in your report.
  prefs: []
  type: TYPE_NORMAL
- en: 17.15.1\. OVERVIEW
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encoding has the following bullet points in achievement standard 2.44 which
    this guide covers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: “describing the concept of encoding information using compression
    coding, error control coding, and encryption; and typical uses of encoded information”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “discussing how a widely used technology is enabled by one or more
    of compression coding, error control coding, and encryption”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**: “evaluating a widely used system for compression coding, error
    control coding, or encryption”'
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed reports, you should base your explanations around
    personalised examples.
  prefs: []
  type: TYPE_NORMAL
- en: 17.15.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  prefs: []
  type: TYPE_NORMAL
- en: Read all of these sections, as they give the necessary introduction of the topics
  prefs: []
  type: TYPE_NORMAL
- en: 9.1 - What’s the Big Picture?
  prefs: []
  type: TYPE_NORMAL
- en: 9.3 - Check digits on barcodes and other numbers
  prefs: []
  type: TYPE_NORMAL
- en: 17.15.3\. PROJECT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the achieved criteria you will show how the barcode on a product you chose
    has a check digit which helps to ensure that when a shop assistant scans or enters
    the number into a computer, that the computer is able to notify them if it was
    entered incorrectly. For the merit and excellence criteria, you will explain why
    this is so important, and evaluate how effective it is.
  prefs: []
  type: TYPE_NORMAL
- en: 17.15.3.1\. WRITING YOUR REPORT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved**'
  prefs: []
  type: TYPE_NORMAL
- en: Find some products with barcodes on them, and the checker will tell you whether
    or not it is a correct barcode. Try a few others. Does it ever seem to say a number
    was wrong? Now try change one digit in a barcode. Does it ever still say the barcode
    is correct? Choose one product to take a photo of the barcode, and describe how
    the last digit is a check digit that ensures the number was entered correctly
    (it’s a good idea to include the calculation that was used to calculate the check
    digit’s value). Show that when you enter the number into the barcode and change
    one of the digits, the last digit is no longer correct.
  prefs: []
  type: TYPE_NORMAL
- en: Explain why you would want to use a check digit on a barcode. What is the purpose
    of error control coding?
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit/ Excellence**'
  prefs: []
  type: TYPE_NORMAL
- en: What could be some of the implications of a number being entered incorrectly,
    and this not being detected? What kinds of things could happen to the shop?
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of what some of the common errors could be if somebody was manually entering
    the number into a computer. What mistakes are easy to make? (clue: missing a digit
    or swapping 2 adjacent digits are common mistakes, however there are others as
    well). Also think about what could cause errors if a scanner was being used to
    read the barcode.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the barcodes you found earlier, replicate some of the common errors that
    would occur when a person manually enters the number into the computer by entering
    the mistakes into the checker. Try lots of variations of the errors, and see if
    the errors are always detected. Which errors always seem to be detected? Which
    do not? Discuss whether or not the check digits decrease the chances of errors,
    particularly common ones. Do you think that sometimes mistakes do go undetected?
    Remember that really obscure errors (such as getting 3 digits in a row incorrect)
    will probably never occur in practice, and the intention of the check digit is
    to pick up small mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Your discussion should include a few examples of common errors you tried replicating
    (use screenshots), and whether or not the check digit was able to detect them.
  prefs: []
  type: TYPE_NORMAL
- en: 17.15.4\. HINTS FOR SUCCESS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Put error control coding in its own section (your report should have suitable
    headings and subheadings for each topic to make it clear for the marker) and ensure
    that you briefly introduce the topic. It is important that your report clearly
    demonstrates that you know the difference between encryption, error control coding,
    and compression, and what their different purposes are.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be sure to shrink down examples so they do not take up too much space. A barcode
    only needs to be big enough for the numbers to be readable; it does not need to
    take up half a page!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For merit, you should not just paraphrase information. You need to use your
    own thinking to generate some of the answers, as your own experiences should enable
    you to come up with a lot of the answers. As an example, you should already know
    that if you bought something from the shop, and the scanner read the barcode wrong,
    and you were charged twice as much, you would not be happy about it! The implications
    of not having the technology are an important part of the discussion — what would
    happen if these systems weren’t used?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For excellence, don’t simply discuss whether or not the algorithm is good without
    examples. You *must* have examples so that your work is personalised. Show some
    of the errors and whether or not they generate the correct check digit. If you
    find examples with simple common errors where the error did give the correct check
    digit, this is really good to show.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should be able to discuss this material, with examples, in about 2 or 3
    pages of your report.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.16\. ARTIFICIAL INTELLIGENCE (3.44) - TURING TEST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting Artificial Intelligence in digital technologies
    achievement standard 3.44\. This guide is not official, although we intend for
    it to be helpful, and welcome any feedback.
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done a project
    in one other 3.44 topic. The other project should be in either Software Engineering,
    Complexity and Tractability, Formal Languages, Network Protocols, or Graphics
    and Visual Computing.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the project in this guide focuses on using the Turing Test to evaluate
    Chatbots. Another guide exists which has a project that instead focusses on the
    actual algorithms and techniques used by Chatbots in an attempt to sound intelligent.
    Either of these are sufficient to cover a “key algorithm or technique” from the
    field of Artificial Intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: 17.16.1\. OVERVIEW
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to complete a 3.44 project in two different areas of computer
    science. Each project needs to satisfy all bullet points in the standard.
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: [A1]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: [A2] “describing examples of practical applications of selected
    areas to demonstrate the use of key algorithms and/or techniques from these areas“'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: [M1] “explaining how key algorithms or techniques are applied in
    selected areas”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: [M2] “explaining examples of practical applications of selected
    areas to demonstrate the use of key algorithms and/or techniques from these areas”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**: [E1] “discussing examples of practical applications of selected
    areas to demonstrate the use of key algorithms and/or techniques from these areas”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**: [E2] “evaluating the effectiveness of algorithms, techniques,
    or applications from selected areas”'
  prefs: []
  type: TYPE_NORMAL
- en: The terminology in the 3.44 standard can be challenging to understand because
    it applies to six different areas. The following list describes how the terminology
    of the standard maps onto this project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Selected Area**: Intelligent Systems (Artificial Intelligence)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Problem**: Determining whether or not a computer program is able to have
    a conversation with a human and seem like another human.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithms/ Techniques**: Turing Test'
  prefs: []
  type: TYPE_NORMAL
- en: '**Practical Application**: Using the Turing Test to evaluate if a chatbot is
    able to have a human-like conversation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, to satisfy the standard you might do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe the key problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain how the Turing Test can be used to evaluate a chatbot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain (Describe) how you evaluated a chatbot with the Turing Test, in order
    to demonstrate the use of the Turing Test in Artificial Intelligence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss other related applications of the Turing Test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate how effective the Turing Test is at addressing the key problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.16.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1 - What’s the Big Picture?
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 - Chatterbots and the Turing Test
  prefs: []
  type: TYPE_NORMAL
- en: You will be doing the activity in 10.2.6 (Run your own turing test) as the main
    part of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 17.16.3\. PROJECT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Turing Test is used to evaluate computer programs that are attempting to
    have a conversation like a human. In this project, you will carry out your own
    Turing test with an online chatbot, and report on the process and your findings.
  prefs: []
  type: TYPE_NORMAL
- en: 17.16.3.1\. CARRYING OUT THE TURING TEST
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Choose a chatbot and carry out the Turing test with the help of a classmate,
    as described in activity 10.2.6\. Include both the conversations that were generated
    as a result of carrying out the Turing test in your report.
  prefs: []
  type: TYPE_NORMAL
- en: 17.16.3.2\. WRITING YOUR REPORT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved/ Merit**'
  prefs: []
  type: TYPE_NORMAL
- en: Briefly describe what the purpose of the Turing Test is. What problem in computer
    science does it address? Note that this should be at the start of your report,
    and written clearly (considering starting the sentence with “A key problem in
    Artificial Intelligence is…”), so that it is clear to the marker what problem
    the remainder of your report addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Explain what you did to carry out your Turing Test. Which external factors did
    you have to be careful of in order to ensure that the test was “fair”? Include
    a copy of the two conversations. Is there anything you did in your turing test
    that did not work very well? Were any of the questions you asked “unfair” to the
    chatbot?
  prefs: []
  type: TYPE_NORMAL
- en: Which conversation do you think was the chatbot and which do you think was your
    classmate? How could you tell? Refer to some lines in your conversations (some
    which you think were definitely not a human). Were you correct?
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**'
  prefs: []
  type: TYPE_NORMAL
- en: Discuss other possible applications of the Turing Test or similar tests for
    other programs that are supposed to be intelligent. How would you go about carrying
    out such a test? For example, what if you wanted to evaluate whether or not a
    computer played a game in a “human like” way? (As people may prefer to play against
    something that seems human).
  prefs: []
  type: TYPE_NORMAL
- en: Discuss whether or not the Turing test is a good test of intelligence, giving
    reasons for your answer and using examples from your chatterbot experiments. What
    parts of human intelligence would the Turing test not capture? Are there are other
    ways of testing whether or not a computer is able to have a conversation like
    a human?
  prefs: []
  type: TYPE_NORMAL
- en: You might like to do some additional reading for ideas for your discussion.
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Turing_test#Strengths_of_the_test](http://en.wikipedia.org/wiki/Turing_test#Strengths_of_the_test)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Turing_test#Weaknesses_of_the_test](http://en.wikipedia.org/wiki/Turing_test#Weaknesses_of_the_test)'
  prefs: []
  type: TYPE_NORMAL
- en: 17.16.4\. HINTS FOR SUCCESS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some students have used quiz show-like questions instead of trying to have conversations.
    It is important to try and have a conversation rather than just ask lots of unrelated
    questions. A conversation does best at revealing a Chatbot’s limitations. For
    example, this conversation isn’t very good. And infact, many of the lines could
    have been human responses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What is your favourite colour?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: My favorite color is green. What is yours?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What do you do?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: judge, I talk to people on the web. What do you do?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What is your name?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: My name is ALICE.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: How long have you been alive?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: 16 years.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What is your favourite movie?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: My favorite movie is Casablanca. Have you seen it?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What is your favourite song?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: My favorite song is Imagine. Do you know it?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What is your favourite food?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: I require only electricity.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What is 10 + 20 ?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: 10 times 10 = 100.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What is 79 - 7'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: I would look into the web for that knowledge.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Whereas this next conversation reveals the Chatbot’s limited ability to hold
    a conversation, as we were attempting to make it do.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'judge: What is your favourite colour?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: My favorite color is green. What is yours?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: Mine is Purple'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: purple is a very nice color.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: Why isn’t it your favourite colour?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: My mind does not contain an explanation for it.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What does your mind contain?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: What do you think it does?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: I would have no idea'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: How much would you pay for it?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: Nothing, sorry'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: Really nothing?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: Yeah, you’re a worthless chatbot...'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: Aha.. Yes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You will need to base your responses on the last response you received rather
    than attempting to use a list of predefined questions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You don’t need to say the same things to the chatbot and the human. Just try
    and hold a conversation with both, and mostly go with whatever direction the conversation
    is going (although do try one or two subject changes as well to see what happens!).
    Just pretend you are having a casual conversation with somebody you don’t know
    very well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offensive words or topics could land you in a ton of trouble if included in
    your submitted report. If a chatbot says something inappropriate, censor it. Choose
    a classmate to work with who is likely to be sensible if you want to do well (if
    they do say anything offensive, don’t include it in your report).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have nobody to work with, consider doing the related project which focuses
    mostly on the chatbots and the techniques they use to try and sound intelligent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should be able to write up the project in about 4 pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.17\. FUTURE PLANS FOR THE FIELD GUIDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The initial version of the guide being developed in 2012/2013 is intended to
    cover the new NZ achievement standards in CS. However, there are other topics
    that aren’t covered that would be good to mention, and they are recorded here
    as possible future chapters to add.
  prefs: []
  type: TYPE_NORMAL
- en: 17.17.1\. COMPUTABILITY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[http://www.lel.ed.ac.uk/~gpullum/loopsnoop.html](http://www.lel.ed.ac.uk/~gpullum/loopsnoop.html) Ed
    Dalley’s story about the halting problem cs4fn'
  prefs: []
  type: TYPE_NORMAL
- en: 17.17.2\. LOGIC CIRCUITS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gates (see unplugged Peruvian activity) [http://www.cs4fn.org/binary/nim/nim.php](http://www.cs4fn.org/binary/nim/nim.php) uses
    xor Online logic simulator? Binary additions (see also marble and wood logic devices,
    and other non-electronic ones) Logic: [http://courses.cs.vt.edu/csonline/MachineArchitecture/Lessons/index.html](http://courses.cs.vt.edu/csonline/MachineArchitecture/Lessons/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: 17.17.3\. BIG DATA/CLOUD COMPUTING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Big_data](http://en.wikipedia.org/wiki/Big_data) [http://www.nsf.gov/cise/csbytes/newsletter/vol1/vol1i11.html](http://www.nsf.gov/cise/csbytes/newsletter/vol1/vol1i11.html)'
  prefs: []
  type: TYPE_NORMAL
- en: There is some background at: [http://www.techamericafoundation.org/bigdata](http://www.techamericafoundation.org/bigdata)
  prefs: []
  type: TYPE_NORMAL
- en: The Google data center gallery has cool pictures: [http://www.google.com/about/datacenters/gallery/#/](http://www.google.com/about/datacenters/gallery/#/) or
    could tie in with Computational Science (from ACM curriculum)
  prefs: []
  type: TYPE_NORMAL
- en: Shadi to help Mark at Monterey interested
  prefs: []
  type: TYPE_NORMAL
- en: main concepts?
  prefs: []
  type: TYPE_NORMAL
- en: CAP theorem, mapreduce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: using an API e.g. google maps, twitter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: low level - uploading data (mashup?); higher level - APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.17.4\. PARALLEL/CONCURRENT COMPUTING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some people advocate teaching this first because all computers have multiprocessors
    and data centres. It might be the same chapter as “Big data”, but there are other
    approaches. For beginners, StarLogo and Scratch can be used to teach concurrent
    processes and the issues that arise. There’s bound to be an unplugged activity
    that could show issues like race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.cs4fn.org/parallelcomputing/parallelrats.php](http://www.cs4fn.org/parallelcomputing/parallelrats.php)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://dl.acm.org/citation.cfm?id=2414446&picked=prox&CFID=269871400&CFTOKEN=70782049](http://dl.acm.org/citation.cfm?id=2414446&picked=prox&CFID=269871400&CFTOKEN=70782049)'
  prefs: []
  type: TYPE_NORMAL
- en: ACM curriculum has a lot of material on this
  prefs: []
  type: TYPE_NORMAL
- en: Teaching map-reduce: [http://dl.acm.org/citation.cfm?id=2414448](http://dl.acm.org/citation.cfm?id=2414448)
  prefs: []
  type: TYPE_NORMAL
- en: 17.17.5\. DATABASES (OR INFORMATION MANAGEMENT?)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: and other stuff from the Information branch of the DT standards?
  prefs: []
  type: TYPE_NORMAL
- en: 17.17.6\. OPERATING SYSTEMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Or related topics? [http://www.cl.cam.ac.uk/freshers/raspberrypi/tutorials/os/](http://www.cl.cam.ac.uk/freshers/raspberrypi/tutorials/os/) From
    nand to Tetris project Architecture, memory management, security, VMs, devices,
    file systems, fault tolerance, performance evaluation Operating systems on-a-stick
    e.g. schools.pconme.com Operating systems:[http://courses.cs.vt.edu/csonline/OS/Lessons/index.html](http://courses.cs.vt.edu/csonline/OS/Lessons/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: 17.17.7\. INFORMATION ASSURANCE AND SECURITY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the new ACM curriculum; could include forensics? [http://www.nsf.gov/cise/csbytes/newsletter/vol1/vol1i12.html](http://www.nsf.gov/cise/csbytes/newsletter/vol1/vol1i12.html)[http://www.nsf.gov/cise/csbytes/newsletter/vol2/vol2i3.html](http://www.nsf.gov/cise/csbytes/newsletter/vol2/vol2i3.html)
  prefs: []
  type: TYPE_NORMAL
- en: might use some stuff from cryptography?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doxd game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark at Monterey may contribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.nsf.gov/cise/csbytes/newsletter/vol2/vol2i13.html](http://www.nsf.gov/cise/csbytes/newsletter/vol2/vol2i13.html) -
    information privacy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.17.8\. MOBILE COMPUTING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not sure if it’s a general area, but probably a few things that could be covered
  prefs: []
  type: TYPE_NORMAL
- en: 17.17.9\. SOCIAL AND PROFESSIONAL ISSUES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ethics? Communication? Digital divide, social implications, professional communities,
    codes of conduct, intellectual property, open source movement, privacy, sustainability
    (green computing), computer crime, how companies make money (e.g. Skype p2p, Google
    and Facebook with private information)
  prefs: []
  type: TYPE_NORMAL
- en: 17.17.10\. QUANTUM COMPUTING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Quantum_computer](http://en.wikipedia.org/wiki/Quantum_computer) [http://www.howstuffworks.com/quantum-computer.htm](http://www.howstuffworks.com/quantum-computer.htm) [http://plato.stanford.edu/entries/qt-quantcomp/](http://plato.stanford.edu/entries/qt-quantcomp/)www.youtube.com/watch?v=sICXOwOwS4E'
  prefs: []
  type: TYPE_NORMAL
- en: 17.18\. GUIDE TO SYSTEM FOR OPEN SOURCE DEVELOPERS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following guide has been written to help those wishing to adapt this system.
    Modifying the system can be quite a large task, especially in setup. We are not
    releasing the full package of files for automated generation process, as this
    includes personal login data to networks, etc. However, we do want to share this
    project as much as possible, therefore this guide has been written for those wish
    to take the time to adapt the system.
  prefs: []
  type: TYPE_NORMAL
- en: If you are wanting a local copy of the files to host on your local network,
    or wish to clarify or add something to the guide below, please contact [Jack Morgan](mailto:jack.morgan%40canterbury.ac.nz).
    The guide is definitely not complete in it’s current state, but is being expanded
    frequently.
  prefs: []
  type: TYPE_NORMAL
- en: The textbook is licensed under a Creative Commons Attribution Non-Commerical
    Share Alike license. Full details on this license, including a human readable
    summary, [can be found here](http://creativecommons.org/licenses/by-nc-sa/3.0/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Code experience recommended
  prefs: []
  type: TYPE_NORMAL
- en: The following guide to setup your own Sphinx system is quite code heavy, so
    moderate experience with programming is recommended. For those who get stuck with
    Sphinx creation, the Sphinx community is very active, you can [find them here](https://groups.google.com/forum/?fromgroups=#!forum/sphinx-users).
  prefs: []
  type: TYPE_NORMAL
- en: 17.18.1\. PROCESS OF TEXTBOOK CREATION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The textbook uses a documentation generator by the name of [Sphinx](http://sphinx-doc.org/),
    orginally created to generate Python documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563b17495362e.png)](http://csfieldguide.org.nz/_images/A-system-process.png)'
  prefs: []
  type: TYPE_NORMAL
- en: The textbook is written in a notation called ReStructured Text (or ReST), which
    acts much like a relaxed version of LaTeX. Details on how to use the ReStructured
    Text markup (plus how it fits into Sphinx) can be [found here](http://sphinx-doc.org/rest.html).
    The advantages of using the ReST format, is that if we ever want to switch away
    from the Sphinx system, we can plug the source material straight into the new
    system with minimal configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most pages on the textbook website (except for a couple of special cases: homepage
    etc) are written in the ReST format, and you can view the source code by clicking
    the ‘Show Source’ link in the sidebar. For example, the source for this page can
    be found in the sidebar.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Sphinx system then processes these files, and generates the relevant HTML
    requires for the website. From this stage onwards, many tweaks have been made
    to the system, the source and the generation process to produce the material we
    wanted. These details are too numerous to go into detail about, however some good
    links to read for running your own Sphinx setup include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[First Steps with Sphinx](http://sphinx-doc.org/tutorial.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sphinx Markup Constructs](http://sphinx-doc.org/markup/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sphinx Configuration File](http://sphinx-doc.org/config.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[HTML Theming](http://sphinx-doc.org/theming.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Build Options](http://sphinx-doc.org/invocation.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Available Sphinx Builders](http://sphinx-doc.org/builders.html) (What is produced
    on the generation: HTML, PDF etc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Math support in Sphinx](http://sphinx-doc.org/ext/math.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.18.2\. VERSIONING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this textbook, several versions were created for different purposes. To
    designate content to different versions, we decided the student version would
    be the base version, as other versions *build* on top of this. Adding and designating
    content to another version (for example: a teacher’s note) is done with the [only
    command](http://sphinx-doc.org/markup/misc.html#directive-only) in the text files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The versions we created are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Student’s version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teacher’s version (include comments for teachers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development version (includes raw development material)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And each version are created in the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: Website (HTML output)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paper (LaTeX/PDF output)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Portable (ePub/MOBI output) using an experimental builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You would generally create all the versions from the same source files (ie student
    version would just not include teachers notes), however we wanted to customise
    the website even further. Our textbook is generated by *one* system, from *one* main
    source and *three* minor sources (one for each version) into *multiple* outputs.
    The minor sources include files that needed to be different for each version.
    Some of these files include the Sphinx Configuration file ([conf.py file](http://sphinx-doc.org/config.html))
    which dictated the appearance for the seperate versions (teacher version is green
    while student version is blue), and what was included in the sidebar (hiding the
    source files from students to prevent them from easily being able to access answers).
    This proved to be quite a complicated system to setup, however the system now
    has an extreme amount of power in customisation ability.
  prefs: []
  type: TYPE_NORMAL
- en: 17.18.3\. PDF GENERATION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Guide on PDF generation to be released at a later date (when it’s ready).
  prefs: []
  type: TYPE_NORMAL
- en: 17.18.4\. EPUB/MOBI GENERATION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Guide on ePub/MOBIgeneration to be released at a later date (when it’s ready).
  prefs: []
  type: TYPE_NORMAL
- en: 17.18.5\. HOW TO ADD CONTENT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Guide on how to add content to be released at a later date (when it’s ready).
  prefs: []
  type: TYPE_NORMAL
- en: 17.18.6\. UPDATE SCRIPT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Guide on the update script to be released at a later date (when it’s ready).
  prefs: []
  type: TYPE_NORMAL
- en: 17.18.7\. VISUAL APPEARANCE/CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Guide on editing the appearance of the site to be released at a later date (when
    it’s ready).
  prefs: []
  type: TYPE_NORMAL
- en: JUST BROWSING
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The "Computer Science Field Guide" is a online resource for teaching Computer
    Science to students. This guide is being developed as an online interactive textbook
    to support the new achievement standards in Computer Science that are being rolled
    out in New Zealand from 2011 to 2013\. Eventually it will expand to support other
    curricula, but the initial focus is to meet the urgent need of resources in NZ.
  prefs: []
  type: TYPE_NORMAL
- en: The [Introduction](http://csfieldguide.org.nz/Introduction.html) chapter is
    good place to start to find out the goals of the site. The chapters are in various
    stages of development, but the chapter on graphics is a good example of a fairly
    complete version, and the formal languages chapter is a good example of how we're
    taken advanced concepts and packaged them for high school students.
  prefs: []
  type: TYPE_NORMAL
- en: INTERACTIVES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following interactives are used in our online resource to teach concepts
    or particular ideas to students.
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ae3fa81d80.png)Click to load the'
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm Sorting interactive](http://csfieldguide.org.nz/_static/widgets/ALGO/ALGO-PhysicsSort_v2/public_html/index.html)
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ae3f9f397e.png)Click to load the'
  prefs: []
  type: TYPE_NORMAL
- en: binary number interactive](http://csfieldguide.org.nz/_static/widgets/DR/DR-base-conversion/public_html/index.html?base=2&columns=8&lines=A,B,C&offset=0)
  prefs: []
  type: TYPE_NORMAL
