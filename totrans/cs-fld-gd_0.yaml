- en: perface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序言
- en: 原文出处：[http://csfieldguide.org.nz/](http://csfieldguide.org.nz/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文出处：[http://csfieldguide.org.nz/](http://csfieldguide.org.nz/)
- en: The "Computer Science Field Guide" is an online interactive resource for high
    school students learning about computer science, developed at the University of
    Canterbury in New Zealand.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “计算机科学领域指南”是新西兰坎特伯雷大学开发的面向高中学生学习计算机科学的在线互动资源。
- en: 1\. INTRODUCTION
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 介绍
- en: 1.1\. WHAT’S THE BIG PICTURE?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1\. 大局观是什么？
- en: Why is it that people have a love-hate relationship with computers? Why are
    some people so fanatical about particular types of computers, while others have
    been so angry at digital devices that they have been physically violent with them?
    And what does this have to do with computer science? And what is computer science
    anyway?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么人们对计算机有爱恨交加的情感？为什么有些人对特定类型的计算机如此狂热，而另一些人对数字设备如此愤怒以至于对它们进行了暴力行为？这与计算机科学有什么关系？计算机科学到底是什么？
- en: I’m glad you asked! Put simply, computer science is about tools and techniques
    for designing and building applications that are very fast, have great interfaces,
    are reliable, secure, helpful — even fun.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 很高兴你问！简而言之，计算机科学是关于设计和构建非常快速、拥有出色界面、可靠、安全、有帮助甚至有趣的应用程序的工具和技术。
- en: A lot of people confuse computer science with programming. It has been said
    that “computer science is no more about programming than astronomy is about telescopes”
    ([Mike Fellows](http://en.wikiquote.org/wiki/Computer_science)). Programming is
    the tool that computer scientists use to bring great ideas to life, but just knowing
    how to give programmed instructions to a computer isn’t enough to create software
    that delights and empowers people.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人将计算机科学与编程混淆。有人说“计算机科学与编程的关系就像天文学与望远镜的关系一样”（[迈克·费洛斯](http://en.wikiquote.org/wiki/Computer_science)）。编程是计算机科学家用来实现伟大想法的工具，但仅仅知道如何向计算机发出编程指令并不足以创建令人愉悦和赋予人力量的软件。
- en: For example, computers can perform billions of operations every second, and
    yet people often complain that they are too slow. Humans can perceive delays of
    about one tenth of a second, and if your program takes longer than that to respond
    it will be regarded as sluggish, jerky or frustrating. You’ve got well under a
    second to delight the user! If you are searching millions of items of data, or
    displaying millions of pixels (megapixels), you can’t afford to do things the
    wrong way, and you can’t just tell your users that they should buy a faster computer
    ... they’ll probably just go out and buy someone’s faster software instead!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，计算机每秒可以执行数十亿次操作，然而人们经常抱怨它们太慢。人类可以感知大约一秒钟的延迟，如果你的程序响应时间超过这个时间，它将被视为迟缓、卡顿或令人沮丧。你只有不到一秒钟的时间来让用户感到愉悦！如果你正在搜索数百万条数据，或者显示数百万像素（百万像素），你不能承担以错误的方式处理事情的代价，你也不能告诉用户他们应该购买一台更快的计算机...
    他们可能只会去购买别人更快的软件！
- en: 'Here’s some advice from Fred Wilson, who has invested in many high profile
    tech companies:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些建议来自弗雷德·威尔逊，他投资了许多知名科技公司：
- en: First and foremost, we believe that speed is more than a feature. Speed is the
    most important feature. If your application is slow, people won’t use it. I see
    this more with mainstream users than I do with power users. I think that power
    users sometimes have a bit of sympathetic eye to the challenges of building really
    fast web apps, and maybe they’re willing to live with it, but when I look at my
    wife and kids, they’re my mainstream view of the world. If something is slow,
    they’re just gone. ... speed is more than a feature. It’s a requirement.
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先，我们相信速度不仅仅是一个特性。速度是最重要的特性。如果你的应用程序很慢，人们就不会使用它。我觉得这种情况在普通用户中更为常见，而不是在高级用户中。我认为高级用户有时对构建真正快速的网络应用程序的挑战有些同情，也许他们愿意忍受，但当我看着我的妻子和孩子时，他们是我对世界的主流看法。如果某样东西很慢，他们就会离开。...
    速度不仅仅是一个特性。这是一个要求。
- en: ''
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —[Fred Wilson](http://en.wikipedia.org/wiki/Fred_Wilson_(financier)) ([Source](http://triple-networks.com/2011/12/06/10-golden-principles-of-successful-web-apps/))
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —[弗雷德·威尔逊](http://en.wikipedia.org/wiki/Fred_Wilson_(financier)) ([来源](http://triple-networks.com/2011/12/06/10-golden-principles-of-successful-web-apps/))
- en: A key theme in computer science is working out how to make things run fast,
    especially if you want to be able to sell your software to the large market of
    people using old-generation smartphones, or run it in a data centre where you
    pay by the minute for computing time. You can’t just tell your customers to buy
    a faster device — you need to deliver efficient software.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中的一个关键主题是如何让事物运行更快，尤其是如果你希望能够将软件销售给使用旧一代智能手机的大量市场，或者在一个按分钟计费的数据中心中运行它。你不能只是告诉你的客户购买一个更快的设备
    — 你需要提供高效的软件。
- en: Try using the following two calculators to make a simple calculation. They both
    have the same functionality (they can do the same calculations), but which is
    nicer to use? Why?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用以下两个计算器进行简单计算。它们都具有相同的功能（可以进行相同的计算），但哪一个更好用？为什么？
- en: (This book has many interactives like this. If the first calculator doesn’t
    work properly, you may need to use a more recent browser. The interactive material
    in this book works in most recent browsers; Google Chrome is a particularly safe
    bet.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: （本书中有很多类似的交互式内容。如果第一个计算器无法正常工作，可能需要使用更新的浏览器。本书中的交互式材料在大多数最新的浏览器中都可以使用；谷歌浏览器是一个特别靠谱的选择。）
- en: The second calculator above is slower, and that can be frustrating. But it has
    a fancier interface — buttons expand when you point to them to highlight what
    you’re doing. Does this make it easier to use? Did you have problems because the
    “C” and “=” keys are so close?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的第二个计算器速度较慢，这可能令人沮丧。但它有一个更复杂的界面 — 按钮在你指向它们时会展开，以突出显示你正在做的事情。这会使使用更加容易吗？你是否因为“C”和“=”键靠得太近而遇到问题？
- en: How interfaces work is a core part of computer science. The aesthetics — images
    and layout — are important, but what’s much more crucial is the psychology of
    how people interact. For example, suppose the “OK” and “Cancel” buttons in dialogue
    boxes were occasionally reversed. You would always need to check carefully before
    clicking on one of them, instead of using the instinctive moves you’ve made countless
    times before. There are some very simple principles based on how people think
    and behave that you can take advantage of to design systems that people love.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 界面如何工作是计算机科学的核心部分。美学 — 图像和布局 — 是重要的，但更关键的是人们如何交互的心理学。例如，假设对话框中的“确定”和“取消”按钮偶尔被颠倒。你总是需要在点击其中一个之前仔细检查，而不是像以前那样凭直觉进行操作。基于人们思考和行为方式的一些非常简单的原则可以被利用来设计人们喜爱的系统。
- en: Making software that can scale up is another important theme. Imagine you’ve
    built a web interface and have attracted thousands of customers. Everything goes
    well until your site goes viral overnight, and you suddenly have millions of customers.
    If the system becomes bogged down, people will become frustrated waiting for a
    response, and tomorrow you will have no customers — they’ll all have moved on
    to someone else’s system. But if your programs are designed so they can scale
    up to work with such large amounts of data your main problem will be dealing with
    offers to buy your company!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 制作能够扩展的软件是另一个重要主题。想象一下，你建立了一个网络界面，并吸引了成千上万的客户。一切都很顺利，直到你的网站一夜之间爆红，突然间有了数百万的客户。如果系统变得繁忙不堪，人们等待响应时会感到沮丧，明天你就没有客户了
    — 他们都会转向别人的系统。但是，如果你的程序设计得足够扩展，可以处理如此大量的数据，那么你的主要问题将是如何处理收购你公司的要约！
- en: Some of these problems can be solved by buying more equipment, but that can
    be an expensive and wasteful option (not just for cost, but because of the impact
    on the environment, including the wasted power used to do the processing inefficiently).
    With mobile computing it’s even more important to keep things lean and efficient
    — heavy duty programs chew up valuable battery life, and processing and memory
    must be used sparingly as these affect the size, weight and even heat dissipation
    of devices.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题中的一些可以通过购买更多的设备来解决，但这可能是一种昂贵且浪费的选择（不仅仅是成本，还包括对环境的影响，包括用于不高效处理的浪费电力）。对于移动计算，保持事物的精简和高效更加重要
    — 重型程序会消耗宝贵的电池寿命，处理和内存必须节俭使用，因为这些会影响设备的大小、重量甚至散热。
- en: And if your system continues be successful, pretty soon people will be trying
    to hack into it to steal valuable customer data or passwords. How can you design
    systems so that you know they are secure from such attacks and your customers
    can trust you with their personal information or business transactions?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统继续取得成功，很快就会有人试图黑入系统，窃取有价值的客户数据或密码。你如何设计系统，以确保它们免受此类攻击，并让您的客户相信您能够保护他们的个人信息或业务交易？
- en: All these questions and more are addressed by the field of computer science.
    The purpose of this guide is to introduce you to those ideas so that you have
    a better idea of whether this field is for you. It is aimed at high-school level,
    and is intended to bring you to the point where you have a good overview of the
    field, and are well prepared for further in-depth study to become an expert.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题以及更多问题都由计算机科学领域解决。本指南的目的是向你介绍这些想法，以便你更好地了解这个领域是否适合你。它面向高中水平，并旨在使你对该领域有一个良好的概述，并为进一步深入学习以成为专家做好准备。
- en: We’ve broken computer science up into a whole lot of topics that you’ll often
    find in curricula around the world, such as algorithms, human-computer interaction,
    compression, cryptography, computer graphics, and artificial intelligence. The
    reality is that all these topics interact, so be on the lookout for the connections.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将计算机科学分解成了许多你经常在全球课程中找到的主题，比如算法、人机交互、压缩、密码学、计算机图形学和人工智能。事实上，所有这些主题都相互作用，所以要留意它们之间的联系。
- en: This guide isn’t a list of facts for you to memorise, or to copy and paste into
    projects! It is mainly a guide to things you can do — experiences that will engage
    you with the topics. In fact, we won’t go through all the topics in great detail,
    but will give you references to websites and books that explain things thoroughly.
    The idea of this guide is to give you enough background to understand the topics,
    and to do something meaningful with them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南不是一份供你记忆的事实清单，也不是一份可供复制粘贴到项目中的内容！它主要是一份指导你可以做的事情的指南——这些经历将使你与主题产生联系。事实上，我们不会详细介绍所有的主题，但会为你提供网站和书籍的参考资料，这些资料会对事情有很好的解释。这个指南的想法是为你提供足够的背景知识来理解这些主题，并且能够用它们做一些有意义的事情。
- en: 'And what about programming? You can get through this whole guide without doing
    any programming, although we’ll suggest exercises. Ultimately, however, all the
    concepts here are reflected in programs that people write. If you want to learn
    programming there are many excellent courses available. It takes time and practice,
    and is well worth doing in parallel with working through the topics in this guide.
    There are a number of free online systems and books that you can use to teach
    yourself programming. A database of options for learning to program is being compiled
    by [code.org](http://www.code.org/), where there is also a popular video of some
    well-known high-fliers in computing which is good to show classes. Here are some
    other sources that might suit you:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编程方面又如何呢？在阅读整个指南的过程中，你可以不进行任何编程，尽管我们会建议一些练习。然而，所有这里的概念最终都反映在人们编写的程序中。如果你想学习编程，有许多优秀的课程可供选择。学习编程需要时间和练习，但与阅读本指南中的主题并行进行是非常值得的。有许多免费在线系统和书籍可供您自学编程。一个关于学习编程选项的数据库正在由[code.org](http://www.code.org/)编制，那里还有一些知名的计算机高手的受欢迎视频，很适合用来展示课堂。以下是一些可能适合您的其他来源：
- en: '[The NCEA year 12 workbook](http://www.cs.otago.ac.nz/year12dt/) is a book
    (two actually) on programming in Java and Python, written for the NZ achievement
    standards. The authors are developing a second book for the year 13 programming
    standard.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NCEA年12级工作手册](http://www.cs.otago.ac.nz/year12dt/) 是一本关于Java和Python编程的书籍（实际上有两本），适用于新西兰的成就标准。作者正在开发第二本适用于13年级编程标准的书籍。'
- en: '[CodeAvengers](http://www.codeavengers.com/) is an online system where you
    can work through challenges that will introduce you to programming in Javascript.
    This system matches the NZ programming achievement standards from level 1 to 3.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CodeAvengers](http://www.codeavengers.com/) 是一个在线系统，您可以通过挑战来学习Javascript编程。该系统与新西兰的编程成就标准相匹配，从1级到3级。'
- en: '[Interactive Python](http://interactivepython.org/) has a free online “book”
    called “How to Think Like a Computer Scientist: Interactive Edition” (also referred
    to as “Think Python”) which teaches the Python language, and enables students
    to edit and run Python examples within the web browser. The original book is open
    source and is also available in various non-interactive versions.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Interactive Python](http://interactivepython.org/) 有一本免费的在线“书”叫做“如何像计算机科学家一样思考：互动版”（也被称为“思考
    Python”），教授 Python 语言，并使学生能够在网络浏览器中编辑和运行 Python 示例。原始书籍是开源的，也有各种非交互式版本可用。'
- en: '[Codecademy](http://www.codecademy.com/) is an online system where you can
    learn languages including Python and Javascript'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Codecademy](http://www.codecademy.com/) 是一个在线系统，你可以学习包括 Python 和 Javascript
    在内的语言。'
- en: '[Coder Dojo](http://coderdojo.com/) is a “movement orientated around running
    free not-for-profit coding clubs and regular sessions for young people”.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Coder Dojo](http://coderdojo.com/) 是一个“围绕免费非营利性编程俱乐部和定期为年轻人举办会议的运动”。'
- en: '[TryPython](http://trypython.org/) is an instant Python tutorial that runs
    in your web browser.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[TryPython](http://trypython.org/) 是一个可以在你的网络浏览器中运行的即时 Python 教程。'
- en: '[CodingBat](http://codingbat.com/) has hundreds of programming challenges that
    you can try to check on how you are progressing with learning to program.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CodingBat](http://codingbat.com/) 有数百个编程挑战，你可以尝试检查你学习编程的进度。'
- en: '[Greenfoot](http://greenfoot.org/) is a visual, interactive system that teaches
    object orientation with Java. You create ‘actors’ that live in ‘worlds’ to build
    games, simulations, and other graphical programs.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Greenfoot](http://greenfoot.org/) 是一个可视化、交互式系统，用 Java 教授对象导向。你可以创建‘演员’在‘世界’中建立游戏、模拟和其他图形程序。'
- en: '[Khan Academy](http://www.khanacademy.org/cs/) has a “Computer Science” section;
    most of the material here is about programming rather than computer science in
    general.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Khan Academy](http://www.khanacademy.org/cs/) 有一个“计算机科学”部分；这里的大部分材料都是关于编程而不是一般的计算机科学。'
- en: '[Grok learning](https://groklearning.com/) is a new site for learning to code'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Grok learning](https://groklearning.com/) 是一个学习编程的新网站。'
- en: 'The following programming teaching systems are aimed more at younger students,
    or are based around a “drag and drop” language which is only intended as a teaching
    tool:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下编程教学系统更适合年轻学生，或者基于“拖放”语言，仅用作教学工具：
- en: '[ScratchEd](http://scratched.media.mit.edu/) provides extensive educational
    material for Scratch, which is a drag-and-drop programming language centred around
    creating 2D animations. Scratch has many of the features of more conventional
    languages. The [Snap (BYOB)](http://byob.berkeley.edu/) system is based on Scratch,
    and has some more advanced features.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ScratchEd](http://scratched.media.mit.edu/) 为 Scratch 提供大量教育资料，这是一个以创建 2D
    动画为中心的拖放式编程语言。Scratch 具有许多更传统语言的功能。[Snap (BYOB)](http://byob.berkeley.edu/) 系统基于
    Scratch，并具有一些更高级的功能。'
- en: '[Computer Science Concepts in Scratch](http://stwww.weizmann.ac.il/g-cs/scratch/scratch_en.html) is
    a book on programming in Scratch.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Scratch 中的计算机科学概念](http://stwww.weizmann.ac.il/g-cs/scratch/scratch_en.html)
    是一本关于 Scratch 编程的书籍。'
- en: '[Alice](http://alice.org/) is an educational programming language based around
    creating 3D animations.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Alice](http://alice.org/) 是一个围绕创建 3D 动画的教育性编程语言。'
- en: '[Kodu](http://www.kodugamelab.com/) is a visual programming tool that is also
    available of Xbox.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kodu](http://www.kodugamelab.com/) 是一个可在 Xbox 上使用的可视化编程工具。'
- en: '[Snake wrangling for kids](http://briggs.net.nz/snake-wrangling-for-kids.html) is
    a free downloadable book that introduces younger students to Python programming.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[儿童的蛇编程](http://briggs.net.nz/snake-wrangling-for-kids.html) 是一本免费下载的书，向年轻学生介绍
    Python 编程。'
- en: Programming is just one of the skills you’ll need to be a computer scientist.
    In this book you’ll be exercising many other skills — maths, psychology, and communication
    are important ones.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编程只是成为计算机科学家所需技能之一。在本书中，你将锻炼许多其他技能 —— 数学、心理学和沟通都是重要的技能之一。
- en: 1.2\. HOW TO USE THIS GUIDE
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2\. 如何使用本指南
- en: This guide is intended to support a variety of curricula, and teacher guides
    will become available for using it in different contexts. For students, we’ve
    designed most chapters so that they can stand alone; the few that build on previous
    chapters explain at the outset what preparation you need (the most useful general
    preparation is the chapter on data representation, because everything on a computer
    is stored using binary numbers and so they have an important role in many areas
    of computer science.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 该指南旨在支持各种课程设置，并将提供用于在不同环境中使用它的教师指南。对于学生，我们大多数章节都设计为可以单独使用；一些依赖于前一章节的章节在开始时解释了您需要做的准备工作（最有用的一般准备工作是关于数据表示的章节，因为计算机上的所有内容都是使用二进制数存储的，因此它们在计算机科学的许多领域中起着重要作用。）
- en: Each chapter begins with a section about the “big picture” — why the topic is
    useful for understanding and designing computer systems, and what can be achieved
    using the main ideas in the chapter. You’ll then be introduced to key ideas and
    applications of the topic through examples, and wherever possible we’ll have interactive
    activities that enable you to work with the ideas first hand. Sometimes these
    will be simplified versions of the full sized problems that computer scientists
    need to deal with – our intention is for you to actually interact with the ideas,
    not just read about them. Make sure you give them a go!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章都以关于“大局观”的部分开头 —— 为什么该主题对于理解和设计计算机系统是有用的，以及通过该章节的主要思想可以实现什么。然后，您将通过示例介绍该主题的关键思想和应用，并在可能的情况下，我们将有一些交互式活动，使您可以亲身体验这些思想。有时，这些活动将是计算机科学家需要处理的完整问题的简化版本
    - 我们的意图是让您实际与这些思想互动，而不仅仅是阅读它们。确保您尝试一下！
- en: We finish each chapter by talking about the “whole story,” giving hints about
    parts of the topic that we omitted because we didn’t want to make the chapter
    too overwhelming. There will be pointers for further reading, but be warned that
    some of it might be quite deep, and require advanced math or programming skills.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每一章结束时都会谈论“整体故事”，提供有关我们因不想使章节过于压倒而省略的主题部分的提示。将会有进一步阅读的指引，但请注意，其中一些可能相当深入，并且需要高级数学或编程技能。
- en: If you are doing this for formal study, you’ll end up having to do some sort
    of assessment. The chapters provide ideas for projects and activities that could
    be used for this, and the appendix has more detailed projects (currently designed
    for the New Zealand NCEA requirements).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是为正式学习而进行此项工作，最终将不得不进行某种形式的评估。各章提供了可用于此目的的项目和活动的想法，附录中还有更详细的项目（目前设计用于新西兰
    NCEA 要求）。
- en: 1.3\. ABOUT THIS GUIDE
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3\. 关于这个指南
- en: This guide is free for you to copy, share and even modify. We plan to make it
    available online, as a downloadable PDF file, and for ePub (e.g. for iBooks) and
    MOBI (e.g. for Kindle), although it’s much better viewed in the other formats
    because you can watch the videos and use the interactive activities.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指南免费供您复制、分享甚至修改。我们计划将其在线提供，作为可下载的 PDF 文件，并提供 ePub 格式（例如 iBooks）和 MOBI 格式（例如
    Kindle），尽管在其他格式中查看效果更好，因为您可以观看视频并使用交互式活动。
- en: This guide is licenced under a [Creative Commons Attribution-NonCommercial-ShareAlike
    licence](http://creativecommons.org/licenses/by-nc-sa/3.0/), which means that
    you are welcome to take copies and modify them. If you do make improvements, we
    ask that you share those, and acknowledge this guide by linking back to our web
    site. You can give away the guide (or any derivatives), but you’re not allowed
    to sell it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该指南采用 [知识共享署名-非商业性使用-相同方式共享许可协议](http://creativecommons.org/licenses/by-nc-sa/3.0/)，这意味着您可以复制并修改它们。如果您进行了改进，请分享这些改进，并通过链接回我们的网站来承认此指南。您可以免费提供该指南（或任何衍生作品），但不允许销售。
- en: Production of the guide was partially funded by a generous grant from Google
    Inc., and supported by the University of Canterbury. Of course, we welcome donations
    to support further work on the guide.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该指南的制作部分资金来自 Google 公司的慷慨资助，并得到了坎特伯雷大学的支持。当然，我们欢迎捐赠以支持进一步完善指南的工作。
- en: 1.4\. FURTHER READING
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4\. 进一步阅读
- en: Each chapter gives suggestions for further reading for that particular. There
    are also plenty of general books and websites about computer science that you
    might want to read to keep your view of the topic broad.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章都为特定主题提供了进一步阅读的建议。此外，还有许多关于计算机科学的一般书籍和网站，您可能希望阅读以扩展您对该主题的视野。
- en: 'The [“Nested” Youtube channel](https://www.youtube.com/channel/UCp-hlYynzR5VW18ITtrcMtQ) is
    a video series that introduces different computer science topics (for example:
    binary search) and closely matches the topics in the Field Guide.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[“嵌套”Youtube频道](https://www.youtube.com/channel/UCp-hlYynzR5VW18ITtrcMtQ)是一个介绍不同计算机科学主题（例如：二分查找）的视频系列，与Field
    Guide中的主题非常匹配。'
- en: 'Books that we particularly recommend include:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别推荐的书籍包括：
- en: 'Algorithmic adventures: from knowledge to magic, by Jurag Hromkovic'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《算法冒险：从知识到魔法》，作者为Jurag Hromkovic
- en: The Turing Omnibus, by A.K. Dewdney
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图灵百科全书，作者为A.K. Dewdney
- en: Algorithmics, by David Harel
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法学，作者为David Harel
- en: '[Computational fairy tales](http://computationaltales.blogspot.co.nz/), by
    Jeremy Kubica'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机科学童话，作者为Jeremy Kubica
- en: Wikipedia has a fairly extensive [entry on computer science](http://en.wikipedia.org/wiki/Computer_science).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科有一个相当广泛的[关于计算机科学的条目](http://en.wikipedia.org/wiki/Computer_science)。
- en: The AQA Computing A2 book(s), by Sylvia Langfield and Kevin Bond, give a more
    detailed account of many of these topics.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: AQA计算机A2书籍，作者为Sylvia Langfield和Kevin Bond，对这些主题进行了更详细的说明。
- en: 'There are also some excellent general web sites about Computer Science, many
    of which we’ve referenced:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些关于计算机科学的优秀的通用网站，其中许多我们已经引用过：
- en: '[Computer Science For Fun](http://www.cs4fn.org/) — a very readable collection
    of short articles about practical applications of topics in computer science'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[计算机科学娱乐](http://www.cs4fn.org/) —— 一个关于计算机科学主题实际应用的非常易读的短文集'
- en: '[Babbage’s bag](http://www.i-programmer.info/babbages-bag/) is an excellent
    collection of technical articles on many topics in computing.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[巴贝奇的包袱](http://www.i-programmer.info/babbages-bag/)是一个涵盖了计算领域许多主题的技术文章的优秀集合。'
- en: '[CS Bytes](http://www.nsf.gov/cise/csbytes/) has up-to-date articles about
    applications of computer science.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CS字节](http://www.nsf.gov/cise/csbytes/)提供了有关计算机科学应用的最新文章。'
- en: '[Thriving in our digital world](http://www.cs.utexas.edu/~engage/) has some
    excellent information and interactive material on topics from computer science.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在我们的数字世界中蓬勃发展](http://www.cs.utexas.edu/~engage/) 提供了一些关于计算机科学主题的优秀信息和交互材料。'
- en: '[The Virginia tech online interactive modules for teaching computer science](http://courses.cs.vt.edu/csonline/) cover
    a range of relevant topics.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[弗吉尼亚理工大学在线互动教学计算机科学模块](http://courses.cs.vt.edu/csonline/)涵盖了一系列相关主题。'
- en: '[CS animated](http://www.csanimated.com/) has interactive activities on computer
    science.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CS动画](http://www.csanimated.com/)具有关于计算机科学的交互式活动。'
- en: '[CS for All](http://www.cs.hmc.edu/csforall/)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CS for All](http://www.cs.hmc.edu/csforall/)'
- en: 2\. ALGORITHMS
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 算法
- en: 2.1\. WHAT’S THE BIG PICTURE?
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1\. 这是什么大背景？
- en: Every computer device you have ever used, from your school computers to your
    calculator, has been using algorithms to tell it how to do whatever it was doing.
    Algorithms are a very important topic in Computer Science because they help software
    developers create efficient and error free programs. The most important thing
    to remember about algorithms is that there can be many different algorithms for
    the same problem, but some are much better than others!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你曾经使用过的每台计算机设备，从学校的电脑到计算器，都在使用算法告诉它如何完成它所做的任何事情。 算法是计算机科学中非常重要的话题，因为它们帮助软件开发人员创建高效且无误的程序。
    关于算法最重要的一点是要记住，对于同一个问题可能会有许多不同的算法，但其中一些比其他的好得多！
- en: Click an image to play sorting animations
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 单击图像以播放排序动画
- en: '![](563ad17424b90.gif)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad17424b90.gif)'
- en: '**Selection sort**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择排序**'
- en: '![](563ad172e4630.gif)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad172e4630.gif)'
- en: '**Quick sort**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速排序**'
- en: '*Animations provided by David Martin from [www.sorting-algorithms.com](http://www.sorting-algorithms.com/)*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*动画由David Martin提供，来源于 [www.sorting-algorithms.com](http://www.sorting-algorithms.com/)*'
- en: Computers are incredibly fast at manipulating, moving and looking through data.
    However the amount of data computers use is often so large that it doesn’t matter
    how fast the computer is, it will take it far too long to examine every single
    piece of data (companies like Google, Facebook and Twitter process about 1 billion
    things per day). This is where algorithms come in. If a computer is given a better
    algorithm to process the data then it doesn’t matter how much information it has
    to look through, it will still be able to do it in a reasonable amount of time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机在操作、移动和查看数据方面速度非常快。 但是，计算机使用的数据量通常非常大，以至于计算机速度多快都无关紧要，它将花费太长时间来检查每一条数据（像Google、Facebook和Twitter这样的公司每天处理约10亿个事务）。
    这就是算法的作用。 如果计算机被给予更好的算法来处理数据，那么无论它要查看多少信息，它仍然能够在合理的时间内完成。
- en: If you have read through the Introduction chapter you may remember that the
    speed of an application on a computer makes a big difference to a human using
    it. If an application you create is too slow, people will get frustrated with
    it and won’t use it. It doesn’t matter if your program can solve all their life
    problems, if it takes too long they will simply get bored and close it!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了介绍章节，你可能会记得应用程序在计算机上的速度对于使用它的人来说非常重要。如果你创建的应用程序太慢，人们会对它感到沮丧，不会使用它。如果你的程序可以解决所有他们的生活问题，但是花费的时间太长，他们简单地会感到厌倦，然后关闭它！
- en: 2.1.1\. ALGORITHMS, PROGRAMS AND INFORMAL INSTRUCTIONS
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1\. 算法、程序和非正式指令
- en: 'At this stage you might be thinking that algorithms and computer programs kind
    of sound like the same thing, but they are actually two very distinct concepts.
    Descriptions of these and another important concept, Informal Instructions, are
    below. They are each different ways of describing how to do something:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能会认为算法和计算机程序听起来有点像，但它们实际上是两个非常不同的概念。对于这些和另一个重要概念的描述，非正式指令，如下。它们是描述如何做某事的不同方式：
- en: '**Informal Instruction**: An instruction using natural language. They are un-precise
    so computers cannot understand them, but humans are able to use their own intelligence
    to interpret them. This is the least precise of our three descriptions for doing
    things, and is typically used to give a very simple description of the general
    idea of an algorithm.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非正式指令**：使用自然语言的指令。它们不精确，因此计算机无法理解，但人类能够利用自己的智慧来解释它们。这是我们对做事情的三种描述中最不精确的，通常用于对算法的一般概念进行非常简单的描述。'
- en: '**Algorithm**: step by step process that describes how to solve a problem and/or
    complete a task, which will always give a result. They are more precise than Informal
    Instructions and do not require any knowledge or intelligence to follow, however
    they are still not precise enough for a computer to follow. These are often expressed
    using [pseudo-code](http://en.wikipedia.org/wiki/Pseudocode), which matches a
    programming language fairly closely, but leaves out details that could easily
    be added later by a programmer, and doesn’t specify the kinds of commands that
    can be used.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法**：一种逐步描述如何解决问题和/或完成任务的过程，总是会产生一个结果。它们比非正式指令更精确，不需要任何知识或智能来遵循，但仍然不够精确，无法被计算机遵循。这些通常使用[伪代码](http://en.wikipedia.org/wiki/Pseudocode)来表达，它与编程语言相当接近，但省略了稍后可以由程序员轻松添加的细节，并且不指定可以使用的命令类型。'
- en: '**Program**: a specific implementation of an algorithm, which is written in
    a specific programming language and will give a certain result. This is the most
    precise of these three descriptions and computers are able to follow and understand
    these.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序**：算法的具体实现，以特定的编程语言编写，并将给出特定的结果。这是这三种描述中最精确的，计算机能够遵循和理解这些描述。'
- en: For example…
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如…
- en: '**Informal Instruction**: “Get me a glass of water”. A human can understand
    what this means and can figure out how to accomplish this task by thinking, but
    a computer would have no idea how to do this!'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非正式指令**：“给我一杯水”。人类可以理解这意味着什么，并且可以通过思考来解决这个任务，但计算机不知道如何做到这一点！'
- en: '**Algorithm**: 1) Go to the kitchen. 2) Pick up a glass. 3) Turn on the tap.
    4) Put the glass under the running water and remove it once it is almost full.
    5) Turn off the tap. 6) Take the glass back to the person who gave the instruction.
    A human could follow these instructions easily, but a computer could not figure
    out exactly what to do.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法**：1）去厨房。2）拿起一个玻璃杯。3）打开水龙头。4）将玻璃杯放在流水下，待水几乎满了时取出。5）关闭水龙头。6）将玻璃杯带回给出指示的人。人类可以轻松地遵循这些说明，但计算机无法准确地弄清楚该做什么。'
- en: '**Program**: A computer program, written in a programming language, which would
    tell a robot exactly how to retrieve a glass of water and bring it back to the
    person who asked for the water.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序**：用编程语言编写的计算机程序，会告诉机器人如何取得一杯水并把它带回向要水的人。'
- en: 2.1.2\. ALGORITHM COST
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2\. 算法成本
- en: When Computer Scientists are comparing algorithms they often talk about the
    ‘cost’ of an algorithm. The cost of an algorithm can be interpreted in several
    different ways, but it is always related to how well an algorithm performs based
    on the size of its input, *n*. In this chapter we will talk about the cost of
    an algorithm as either the time it takes a program (which performs the algorithm)
    to complete, and the number of comparisons the algorithm makes before it finishes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机科学家比较算法时，他们经常谈论算法的“成本”。算法的成本可以有多种不同的解释，但它总是与算法根据其输入大小 *n* 的表现有关。在本章中，我们将讨论算法的成本，无论是作为程序（执行算法的程序）完成所需的时间，还是算法完成之前进行的比较次数。
- en: The amount of time a program which performs the algorithm takes to complete
    may seem like the simplest cost we could look at, but this can actually be affected
    by a lot of different things, like the speed of the computer being used, or the
    programming language the program has been written in. This means that if the time
    the program takes to complete is used to measure the cost of an algorithm it is
    important to use the same program and the same computer (or another computer with
    the same speed) for testing the algorithm with different numbers of inputs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 执行算法的程序完成所需的时间可能看起来是我们可以考虑的最简单的成本，但实际上，这可能受到许多不同因素的影响，例如使用的计算机的速度或编程语言编写的程序。这意味着，如果使用程序完成所需的时间来衡量算法的成本，则在测试具有不同输入数量的算法时，使用相同的程序和相同的计算机（或具有相同速度的另一台计算机）非常重要。
- en: The number of comparisons an algorithm makes however will not change depending
    on the speed of a computer, or the programming language the program using the
    algorithm is written in. Some algorithms will always make the same number of comparisons
    for a certain input size, while others might vary.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 算法进行的比较次数不会因计算机的速度或使用算法的程序的编程语言而改变。某些算法对于特定的输入大小将始终进行相同数量的比较，而其他算法可能会有所不同。
- en: If you want to find out more about how the cost of an algorithm is described
    in industry, with ‘Big-O Notation’, then check out “The Whole Story!” section
    at the end of this chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关如何在工业中描述算法成本的“大O符号”的更多信息，请查看本章末尾的“整个故事！”部分。
- en: 2.1.3\. SEARCHING AND SORTING
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3\. 搜索和排序
- en: In this chapter we will look at two of the most common and important types of
    algorithms, Searching and Sorting. You probably come across these kinds of algorithms
    every time you use a computer without even realising!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍两种最常见和重要的算法类型，搜索和排序。您可能在使用计算机时每次都会遇到这些类型的算法，甚至都没有意识到！
- en: 2.2\. SEARCHING
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2\. 搜索
- en: Searching through collections of data is something computers have to do all
    the time. It happens every time you type in a search on Google, or when you type
    in a file name to search for on your computer. Computers deal with such huge amounts
    of data that we need fast algorithms to help us find information quickly. Lets
    investigate searching with a game…
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据集合中进行搜索是计算机经常要做的事情。每当您在Google上输入搜索或在计算机上输入文件名进行搜索时，它都会发生。计算机处理如此大量的数据，以至于我们需要快速的算法来帮助我们快速找到信息。让我们通过一个游戏来研究搜索...
- en: '[![](563ad171a0ed8.jpg)Click to load'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad171a0ed8.jpg)点击加载'
- en: Searching Game - Part 1](http://csfieldguide.org.nz/_static/interactives/alg/searching/index.html?max=2)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索游戏 - 第1部分](http://csfieldguide.org.nz/_static/interactives/alg/searching/index.html?max=2)
- en: You may have noticed that the numbers on the monsters and pets in the game were
    in a random order, which meant that finding the pet was basically luck! You might
    have found it on your first try, or if you were less lucky you might have had
    to look inside almost all the presents before you found it. This might not seem
    like such a bad thing since you had enough lives to look under all the boxes,
    but imagine if there had been 1,000 boxes, or worse 1,000,000! It would have taken
    far too long to look through all the boxes and the pet might have never been found.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到游戏中的怪物和宠物上的数字是随机排序的，这意味着找到宠物基本上是运气！您可能在第一次尝试时找到了它，或者如果您运气不佳，您可能不得不查看几乎所有礼物才能找到它。这可能看起来并不那么糟糕，因为您有足够的生命来查看所有的盒子，但是想象一下如果有1,000个盒子，或者更糟糕的是1,000,000个盒子！查看所有盒子将花费太长时间，宠物可能永远都找不到。
- en: Now this next game is slightly different. You have less lives, which makes things
    a bit more challenging, but this time the numbers inside the boxes will be in
    order. The monsters, or maybe the pet, with the smallest number is in the present
    on the far left, and the one with the largest number is in the present on the
    far right. Let’s see if you can collect all the pets without running out of lives…
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接下来的游戏略有不同。你有更少的生命，这让事情变得有些挑战，但这次箱子里的数字将是有序的。最小数字的怪物，或者说是宠物，位于最左边的礼物中，而具有最大数字的怪物位于最右边的礼物中。让我们看看你能否在不耗尽生命的情况下收集所有的宠物...
- en: '[![](563ad11248654.jpg)Click to load'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad11248654.jpg)点击加载'
- en: Searching Game - Part 2](http://csfieldguide.org.nz/_static/interactives/alg/searching/index.html?level=3)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索游戏 - 第 2 部分](http://csfieldguide.org.nz/_static/interactives/alg/searching/index.html?level=3)
- en: Now that you have played through the whole game (and hopefully found all of
    the lost pets!) you may have noticed that even though you had less lives in the
    second part of the game, and lots of presents to search through, you were still
    able to find the pet. Why was this possible?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经玩过了整个游戏（希望你找到了所有迷失的宠物！），你可能已经注意到，即使在游戏的第二部分你的生命比较少，而且要搜索的礼物很多，你仍然能够找到宠物。这是为什么呢？
- en: 2.2.1\. TWO CONTRASTING SEARCH ALGORITHMS
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1\. 两种对比的搜索算法
- en: 'Since the boxes in the first game were in a random order there really wasn’t
    any strategy you could have used to find the pet, except simply keep opening presents
    one by one until you found the pet. This is very similar to the Linear Search
    Algorithm (sometimes called a sequential search). In plain english, this algorithm
    is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一个游戏中的箱子是随机排列的，所以你真的没有任何策略可以用来找到宠物，除了简单地一个接一个地打开礼物，直到你找到宠物为止。这与线性搜索算法（有时称为顺序搜索）非常相似。用简单的英语来说，这个算法如下：
- en: Check if the first item in a list is the item you are searching for, if it is
    the one you are looking for, you are done.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查列表中的第一个项目是否是你正在搜索的项目，如果是你正在寻找的项目，则完成。
- en: If it isn’t the item you are searching for move on and check the next item.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它不是你正在寻找的物品，请继续并检查下一个物品。
- en: Continue checking items until you find the one you are searching for.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续检查项目，直到找到你正在寻找的那个。
- en: If you used this algorithm you might get lucky and find what you are looking
    for on your first go, but if you were really unlucky you might have to look through
    everything in your list before you found the right object! For a list of 10 items
    this means on average you would only have to look at 5 items to find what you
    were looking for, but for a list of 10000 you would have to look through on average
    5000.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这个算法，你可能会幸运地在第一次尝试时找到你要找的东西，但如果你真的很不幸，你可能必须在找到正确的对象之前查看列表中的所有内容！对于一个包含
    10 个项目的列表，这意味着你平均只需要查看 5 个项目才能找到你要找的东西，但对于一个包含 10000 个项目的列表，你平均需要查看 5000 个项目。
- en: '**Curiosity: Bozo Search**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**好奇心：Bozo 搜索**'
- en: If you watched the video at the beginning of the chapter you might be thinking
    that what you did in the present searching game sounds more like Bozo Search than
    Linear Search, but actually Bozo Search is even sillier than this! If you were
    doing a Bozo Search then after unwrapping a present and finding a monster inside,
    you would wrap the present back up before you moved on to the next one! This means
    you might end up checking the same present again and again and again and you might
    never find the pet, even with a small number of presents!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在章节开始时观看了视频，你可能会认为你在搜索礼物的游戏中所做的事情更像是 Bozo Search 而不是线性搜索，但实际上 Bozo Search
    比这还要愚蠢！如果你在打开一个礼物并发现里面有怪物后，你会重新包装这个礼物，然后再继续下一个！这意味着你可能会一遍又一遍地检查同一个礼物，你可能永远找不到宠物，即使只有很少的礼物！
- en: A much better algorithm to use is called Binary Search. In the second part of
    the present searching game the boxes were in order, which meant you were able
    to be more clever when you were searching for the pet, and you might have been
    using a Binary Search without realising...
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的算法是二分搜索。在当前搜索游戏的第二部分，箱子是有序的，这意味着当你搜索宠物时，你可以更聪明一些，你可能在不知不觉中使用了二分搜索...
- en: If you used a Binary Search on each of the levels then you would have always
    had enough lives to find the pet! Informally, the Binary Search algorithm is as
    follows.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在每个级别上都使用了二分搜索，那么你总是有足够的生命来找到宠物！非正式地，二分搜索算法如下。
- en: Look at the item in the centre of the list and compare it to what you are searching
    for
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看列表中心的项目，并将其与你正在搜索的内容进行比较。
- en: If it is what you are looking for then you are done.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是你正在寻找的东西，那么你就完成了。
- en: If it is larger than the item you are looking for then you can ignore all the
    items in the list which are larger than that item (if the list is from smallest
    to largest this means you can ignore all the items to the right of the centre
    item).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它比你要找的项大，那么你可以忽略列表中所有大于该项的项（如果列表是从最小到最大排列的，这意味着你可以忽略中心项右侧的所有项）。
- en: If it is smaller then you can ignore all the items in the list which are smaller
    than that centre item.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它更小，那么你可以忽略列表中所有小于该中心项的项。
- en: Now repeat the algorithm on the remaining half of the list, checking the middle
    of the list and choosing one of the halves, until you find the item you are searching
    for.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在在列表的剩余一半上重复该算法，检查列表的中间并选择其中的一半，直到找到你要搜索的项。
- en: Binary Search is a very powerful algorithm. If you had 1000 presents to Search
    through it would take you at most 10 checks for Binary search to find something
    and Linear search would take at most 1000 checks, but if you doubled the number
    of presents to search through how would this change the number of checks made
    by Binary Search and Linear search?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制搜索是一个非常强大的算法。如果你要搜索1000份礼物，那么用二进制搜索最多只需要10次检查就能找到东西，而用线性搜索最多需要1000次检查，但如果你要搜索的礼物数量翻倍，这会如何改变二进制搜索和线性搜索的检查次数？
- en: Hopefully you’ve noticed that the answer for each of these algorithms would
    be different.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经注意到，这些算法的答案都是不同的。
- en: It is important to remember that you can only perform a Binary Search if the
    items you are searching through are sorted into order. This makes the sorting
    algorithms we will look at next even more important because without sorting algorithms
    we wouldn’t be able to use Binary Search to quickly look through data!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，只有在搜索的项被排序为顺序时才能执行二进制搜索。这使得我们接下来将要看的排序算法变得更加重要，因为没有排序算法，我们将无法使用二进制搜索来快速查找数据！
- en: 'The following files will run linear and binary search in various languages:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文件将在各种语言中运行线性和二进制搜索：
- en: '[Scratch](http://csfieldguide.org.nz/_static/algorithms/files/linear-binary-search-scratch.zip)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Scratch](http://csfieldguide.org.nz/_static/algorithms/files/linear-binary-search-scratch.zip)'
- en: '[Python (Version 2)](http://csfieldguide.org.nz/_static/algorithms/files/linear-binary-search-python2.py)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python (Version 2)](http://csfieldguide.org.nz/_static/algorithms/files/linear-binary-search-python2.py)'
- en: '[Python (Version 3)](http://csfieldguide.org.nz/_static/algorithms/files/linear-binary-search-python3.py)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python (Version 3)](http://csfieldguide.org.nz/_static/algorithms/files/linear-binary-search-python3.py)'
- en: 2.3\. SORTING ALGORITHMS
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3\. 排序算法
- en: Sorting is another very important area of algorithms. Computers often have to
    sort large amounts of data into order based on some attribute of that data, such
    as sorting a list of files by their name or size, or emails by the date they were
    received, or a customer list according to people’s names. Most of the time this
    is done to make searching easier. For example you might have a large amount of
    data and each piece of data could be someone’s name and their phone number. If
    you want to search for someone by name it would help to first have the data sorted
    alphabetically according to everyones names, but if you then wanted to search
    for a phone number it would be more useful to have the data sorted according to
    people’s phone numbers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 排序是算法的另一个非常重要的领域。计算机通常需要根据数据的某些属性对大量数据进行排序，例如根据文件名或大小对文件列表进行排序，或根据收件日期对电子邮件进行排序，或根据人名对客户列表进行排序。大多数情况下，这样做是为了使搜索更容易。例如，你可能有大量数据，每条数据都可能是某人的姓名和电话号码。如果你想通过姓名搜索某人，首先将数据按照每个人的姓名按字母顺序排序将会很有帮助，但如果你想搜索电话号码，将数据按照人们的电话号码排序将更有用。
- en: Like searching there are many different sorting algorithms, but some take much
    longer than others. In this section you will be introduced to two slower algorithms
    and one much better one.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 像搜索一样，有许多不同的排序算法，但有些比其他的要慢得多。在本节中，你将介绍两种较慢的算法和一种更好的算法。
- en: 2.3.1\. SCALES INTERACTIVE
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1\. SCALES 交互式
- en: Throughout this section you can use the sorting interactive to test out the
    algorithms we talk about. When you’re using it make sure you take note of the
    comparisons at the bottom of the screen, each time you compare two boxes the algorithm
    is making ‘one comparison’ so the total number of comparisons you have to make
    with each algorithm is the cost of that algorithm for the 8 boxes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您可以使用排序交互功能来测试我们讨论的算法。在使用时，请务必注意屏幕底部的比较情况，每次比较两个框时，算法都会进行一次“比较”，因此每个算法的总比较次数是对8个框进行该算法的成本。
- en: Use the scales to compare the boxes (you can only compare two boxes at a time)
    and then arrange them along the bottom of the screen. Arrange them so that the
    lightest box is on the far left and the heaviest is on the far right. Once you
    think they are in order click ‘Test order’.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用天平比较框（一次只能比较两个框），然后将它们沿屏幕底部排列。将它们排列，以便最轻的框在最左边，最重的框在最右边。一旦您认为它们按顺序排列，请单击“测试顺序”。
- en: If the interactive does not run properly on your computer you can use a set
    of physical balance scales instead — just make sure you can only tell if one box
    is heavier than the other, not their exact weight (so not digital scales that
    show the exact weight).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果交互式在您的计算机上运行不正常，则可以使用一组物理天平来代替 - 只需确保您只能确定一个框比另一个框重，而不能确定它们的确切重量（因此不能使用显示确切重量的数字天平）。
- en: '[![](563ad10acf5c3.png)Click to load the'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad10acf5c3.png)点击加载'
- en: Algorithm Sorting interactive](http://csfieldguide.org.nz/_static/interactives/alg/sorting/index.html)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 算法排序交互式](http://csfieldguide.org.nz/_static/interactives/alg/sorting/index.html)
- en: 2.3.2\. SELECTION SORT
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2\. 选择排序
- en: One of the most intuitive ways to sort a group of boxes into order, from lightest
    to heaviest, is to start by first finding the lightest (or the heaviest) box and
    placing that to the side. Try this with the scales interactive.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将一组框按从最轻到最重的顺序排序的最直观方法之一是首先找到最轻（或最重）的框，并将其放在一边。尝试使用天平交互式进行此操作。
- en: After finding the lightest box simply repeat the process again with the remaining
    boxes until you find the second lightest, now place that to the side alongside
    the lightest box. If you keep repeating this process you will eventually find
    you have placed each box into order. Try sorting the whole group of boxes in the
    scales interactive into order using this method and count how many comparisons
    you have to make.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 找到最轻的框后，只需重复此过程，直到找到次轻的框，然后将其放在最轻的框旁边。如果您不断重复此过程，最终会发现已将每个框都按顺序放置。尝试使用此方法将天平交互式中的整组框排序，并计算您必须进行多少比较。
- en: 'Tip: Start by moving all the boxes to the right of the screen and then once
    you have found the lightest box place it to the far right (if you want to find
    the heaviest first instead then move them all to the left).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：首先将所有框移动到屏幕右侧，然后一旦找到最轻的框，请将其放在最右侧（如果您想首先找到最重的框，则将它们全部移动到左侧）。
- en: 'If you record how many comparisons you had to make each time to find the next
    lightest box you might notice a pattern (hint: finding the lightest should take
    7 comparisons, and then finding the second lightest should take 6 comparisons…).
    If you can see the pattern then how many comparisons do you think it would take
    to then sort 9 boxes into order? What about 20? If you knew how many comparisons
    it would take to sort 1000 boxes, then how many more comparisons would it take
    to sort 1001 instead?'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记录了每次找到下一个最轻的框时必须进行的比较次数，您可能会注意到一个模式（提示：找到最轻的应该需要7次比较，然后找到次轻的应该需要6次比较……）。如果您能看到这种模式，那么您认为要对9个框进行排序需要多少次比较？20个呢？如果您知道要对1000个框进行排序需要多少次比较，那么要对1001个框进行排序需要多少次比较？
- en: This algorithm is called Selection sort, because each time you look through
    the list you are ‘selecting’ the next lightest box and putting it into the correct
    position. If you go back to the algorithms racing interactive at the top of the
    page you might now be able to watch the selection sort list and understand what
    it is doing at each step.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法称为选择排序，因为每次查看列表时，您都在“选择”下一个最轻的框并将其放入正确的位置。如果您返回页面顶部的算法竞速交互式部分，现在您可能能够观察选择排序列表并理解它在每一步中所做的事情。
- en: The selection sort algorithm can be described as follows.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 选择排序算法可以描述如下。
- en: Find the smallest item in the list and place it to one side. This will be your
    sorted list.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到列表中最小的项目并将其放在一侧。这将是您的已排序列表。
- en: Next find the smallest item in the remaining list, remove it and place it into
    your sorted list beside the item you previously put to the side.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来在剩余列表中找到最小的项，将其移除并将其放在你之前放到一边的项旁边。
- en: Repeat this process until all items have been selected and moved into their
    correct position in the sorted list.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复这个过程，直到所有的项都被选择并移动到排序列表中的正确位置。
- en: You can swap the word ‘smallest’ for ‘largest’ and the algorithm will still
    work, as long as you are consistent it doesn’t matter if you are looking for the
    smallest or the largest item each time.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将“最小的”一词替换为“最大的”，算法仍然有效，只要你保持一致，每次寻找最小项或最大项都没有关系。
- en: 2.3.3\. INSERTION SORT
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3\. 插入排序
- en: This algorithm works by removing each box from the original group of boxes and
    inserting it into its correct position in a new sorted list. Like Selection Sort,
    it is very intuitive and people often perform it when they are sorting objects
    themselves, like cards in their hands.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法通过将原始箱组中的每个箱子移出并将其插入到一个新的排序列表的正确位置来工作。与选择排序类似，它非常直观，人们在自己排序物体时经常执行它，比如手中的卡片。
- en: Try this with the scales interactive. Start by moving all the boxes to one side
    of the screen, this is your original, and unsorted, group. Now choose a box at
    random and place that on the other side of the screen, this is the start of your
    sorted group.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 试试用这个称 Interactive 进行尝试。首先将所有箱子移到屏幕的一侧，这是您的原始和未排序的组。现在随机选择一个箱子，并将其放在屏幕的另一侧，这是您已排序组的开始。
- en: To insert another box into the sorted group, compare it to the box that is already
    in the sorted group and then arrange these two boxes in the correct order. Then
    to add the next box compare it to these boxes (depending on the weight of the
    box you might only have to compare it to one!) and then arrange these three boxes
    in the correct order. Continue inserting boxes until the sorted list is complete.
    Don’t forget to count how many comparisons you had to make!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要将另一个箱子插入已排序的组中，请将其与已排序组中的箱子进行比较，然后将这两个箱子按正确顺序排列。然后添加下一个箱子时，将其与这些箱子进行比较（根据箱子的重量，您可能只需要与一个进行比较！），然后将这三个箱子按正确顺序排列。继续插入箱子，直到排序列表完成。不要忘记计算你做了多少次比较！
- en: This algorithm is called Insertion Sort. If you’re not quite sure if you’ve
    got the idea of the algorithm yet then have a look at [this animation](http://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif) from [Wikipedia](http://en.wikipedia.org/wiki/Insertion_sort).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法叫做插入排序。如果你还不太确定自己是否已经理解了这个算法的思想，那就看看[Wikipedia](http://en.wikipedia.org/wiki/Insertion_sort)上的[这个动画](http://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif)。
- en: 'Insertion sort can be described with informal instructions as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序可以用非正式的指令描述如下：
- en: Take an item from your unsorted list and place it to the side, this will be
    your sorted list.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从未排序的列表中取出一个项目并将其放到一边，这将成为您的已排序列表。
- en: One by one, take each item from the unsorted list and insert it into the correct
    position in the sorted list.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐个从未排序的列表中取出每个项目，并将其插入已排序列表的正确位置。
- en: Do this until all items have been sorted.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复此操作，直到所有项目都已排序。
- en: People often perform this when they physically sort items. It can also be a
    very useful algorithm to use if you already have a sorted set of data and want
    to add a new piece of data into the set. For example if you owned a library and
    purchased a new book you wouldn’t do a Selection Sort on the entire library just
    to place this new book, you would simply insert the new book in its correct place.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常在他们物理排序物品时执行此操作。如果您已经有一个排序好的数据集，并且想要将一个新的数据添加到数据集中，那么使用这个算法会非常有用。例如，如果你拥有一个图书馆，并购买了一本新书，你不会对整个图书馆进行选择排序，只是为了放置这本新书，你只需将新书插入到它的正确位置即可。
- en: 2.3.4\. QUICKSORT
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4\. 快速排序
- en: Insertion and Selection Sort may seem like logical ways to sort things into
    order, but they both take far too many comparisons when they are used for large
    amounts of data. Remember computers often have to search through HUGE amounts
    of data, so even if they use a good searching algorithm like Binary Search to
    look through their data, if they use a bad sorting algorithm to first sort that
    data into order then finding anything will take far too long!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当插入排序和选择排序用于大量数据时，它们可能看起来像是将事物排序的逻辑方法，但是当它们用于大量数据时，它们都需要太多的比较。请记住，计算机经常需要搜索大量的数据，所以即使它们使用了像二分搜索这样的良好搜索算法来搜索它们的数据，如果它们首先使用了一个糟糕的排序算法来对数据进行排序，那么找到任何东西都会花费太长时间！
- en: A much better sorting algorithm is Quicksort! (the name is a bit of a giveaway)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的排序算法是快速排序！（这个名字有点暴露）
- en: '[![](563ad108d8a22.png)Click to load the'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad108d8a22.png)点击加载'
- en: Quick Sort interactive](http://csfieldguide.org.nz/_static/interactives/alg/sorting/index.html?method=quick)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[快速排序交互式](http://csfieldguide.org.nz/_static/interactives/alg/sorting/index.html?method=quick)'
- en: This algorithm is a little more complicated, but is very powerful. To do this
    algorithm with the sorting interactive, start by randomly choosing a box and placing
    it on the scales. Now compare every other box to the one you selected; heavier
    boxes should be put on the right of the second row and lighter boxes are put on
    the left. When you are done, place the box you were comparing everything else
    to between these two groups, but to help you keep track of things, put it in the
    row below. The following example shows how it might look after this step. Note
    that the selected block is in the right place for the final sorted order, and
    everything on either side will remain on the side that it is on.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法略微复杂，但非常强大。要使用此排序交互执行此算法，请先随机选择一个箱子并将其放在天平上。现在将所有其他箱子与您选择的箱子进行比较；较重的箱子应放在第二行的右侧，较轻的箱子应放在左侧。完成后，将您用于比较其他所有内容的箱子放在这两个组之间，但为了帮助您跟踪事物，将其放在下面的行中。以下示例显示了此步骤完成后的外观。请注意，所选块位于最终排序顺序的正确位置，左右两侧的所有内容将保持在其所在的一侧。
- en: '![](563ad106c6175.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad106c6175.png)'
- en: Now apply this process to each of the two groups of boxes (the lighter ones,
    then the heavier ones). Keep on doing this until they are all sorted. The boxes
    should then be in sorted order!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将此过程应用于两组箱子中的每一组（较轻的箱子，然后是较重的箱子）。一直这样做，直到它们全部排序完毕。然后箱子应按排序顺序排列！
- en: It might be worth trying this algorithm out a few times and counting the number
    of comparisons you perform each time. This is because sometimes you might be unlucky
    and happen to pick the heaviest, or the lightest box first. On the other hand
    you might be very lucky and choose the middle box to compare everything to first.
    Depending on this the number of comparisons you perform will change.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 也许值得尝试此算法几次并计算每次执行的比较次数。这是因为有时您可能不走运，碰巧首先选择到最重或最轻的箱子。另一方面，您可能会非常幸运，首先选择要比较其他所有内容的中间箱子。根据这一点，您执行的比较次数将发生变化。
- en: 'Quicksort can be described in the following way:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序可以描述如下：
- en: Choose an item from the list and compare every other item in the list to this
    (this item is often called the pivot).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表中选择一个项目，并将列表中的每个其他项目与此进行比较（此项目通常称为枢轴）。
- en: Place all the items that are greater than it into one subgroup and all the items
    that are smaller into another subgroup. Place the pivot item in between these
    two subgroups.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有大于它的项目放入一个子组，将所有小于它的项目放入另一个子组。将枢纽项目放置在这两个子组之间。
- en: Choose a subgroup and repeat this process. Eventually each subgroup will contain
    only one item and at this stage the items will be in sorted order.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个子组并重复此过程。最终，每个子组将只包含一个项目，在此阶段项目将按排序顺序排列。
- en: 'The following files will run quicksort in various languages:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文件将在各种语言中运行快速排序：
- en: '[Scratch](http://csfieldguide.org.nz/_static/algorithms/files/selection-quicksort-scratch.zip)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Scratch](http://csfieldguide.org.nz/_static/algorithms/files/selection-quicksort-scratch.zip)'
- en: '[Python (Version 2)](http://csfieldguide.org.nz/_static/algorithms/files/selection-quicksort-python2.py)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python（版本2）](http://csfieldguide.org.nz/_static/algorithms/files/selection-quicksort-python2.py)'
- en: '[Python (Version 3)](http://csfieldguide.org.nz/_static/algorithms/files/selection-quicksort-python3.py)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python（版本3）](http://csfieldguide.org.nz/_static/algorithms/files/selection-quicksort-python3.py)'
- en: 2.4\. OTHER TOPICS IN ALGORITHMS
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4\. 算法中的其他主题
- en: There is another searching algorithm which performs even better than Binary
    Search. It is called Hashing and can be investigated with the CS Unplugged[Battleships
    Game](http://csunplugged.org/searching-algorithms).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有另一种搜索算法，其性能甚至比二分搜索更好。它被称为哈希，可以通过 CS Unplugged 的[战舰游戏](http://csunplugged.org/searching-algorithms)进行研究。
- en: There are some problems for which no good algorithms have been found (and many
    people believe they will never be found). For more on these kinds of algorithms
    see the Complexity and Tractability chapter in the Field Guide.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些问题没有找到好的算法（许多人认为永远不会找到）。有关这些类型的算法的更多信息，请参阅 Field Guide 中的复杂性和可解性章节。
- en: 2.5\. THE WHOLE STORY!
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5\. 整个故事！
- en: We’ve only really scraped the surface of algorithms in this chapter, as there
    are millions of different algorithms for millions of different problems! Algorithms
    are used in maths, route planning, network planning and operation, problem solving,
    artificial intelligence, genetic programming, computer vision, the list goes on
    and on! But by going through this chapter you should have gained an understanding
    of the key concepts of algorithms and will be well prepared to tackle more complicated
    ones in the future.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只是简单地介绍了算法的表面，因为有数百万种不同的算法用于解决数百万种不同的问题！算法被用于数学、路径规划、网络规划和运营、问题解决、人工智能、遗传编程、计算机视觉，等等！但是通过阅读本章，您应该已经了解了算法的关键概念，并且将为将来处理更复杂的算法做好了充分准备。
- en: In this chapter we have only talked about the number of comparisons an algorithm
    makes, and the amount of time a program takes to complete as ‘costs’ of algorithms.
    There are actually many other ways of measuring the cost of an algorithm. These
    include the amount of memory the algorithm uses and its computational complexity.
    Computer Scientists use ‘Big O notation’ to more accurately describe the performance
    or complexity of an algorithm, and you are likely to come across this notation
    very quickly when investigating the performance of algorithms. It characterises
    the resources needed by an algorithm and is usually applied to the execution time
    required, or sometimes the space used by the algorithm.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只谈到了算法所进行的比较次数以及程序完成所需的时间作为算法的“成本”。实际上，有许多其他方法来衡量算法的成本。这些方法包括算法使用的内存量以及其计算复杂性。计算机科学家使用“大
    O 符号”来更准确地描述算法的性能或复杂性，在研究算法性能时，您很快就会遇到这种符号。它描述了算法所需的资源，并且通常应用于所需的执行时间，有时也适用于算法使用的空间。
- en: 'Here are some Big O examples:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些大 O 的示例：
- en: O(1) - An algorithm with O(1) complexity will always execute in the same amount
    of time regardless of how much data you give it to process
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O(1) - 具有 O(1) 复杂度的算法将始终在相同的时间内执行，无论您提供多少数据来处理
- en: O(n) - The amount of time an algorithm with O(n) complexity will take to execute
    will increase linearly and in direct proportion to the amount of data you give
    it to process. Remember that Big O describes the worst case scenario so the algorithm
    might sometimes take less time, but the greatest amount of time it can take will
    increase in direct proportion to the amount of data it is given.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O(n) - 具有 O(n) 复杂度的算法执行所需的时间将线性增加，与您提供的数据量成正比。请记住，大 O 描述的是最坏情况，因此算法有时可能花费较少的时间，但它所需的最长时间将与所提供的数据量成正比增加。
- en: O(n2) - The performance of an algorithm with this complexity is directly proportional
    to the square of the size of the input data set.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O(n2) - 具有这种复杂度的算法的性能与输入数据集大小的平方成正比。
- en: O(2n) - The amount of time an algorithm with this complexity will take to complete
    will double with each additional element added to the data set! Does this remind
    you of any of the algorithms you have looked at in this chapter?
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O(2n) - 具有这种复杂度的算法将随着每增加一个元素到数据集中而将完成时间加倍！这是否让你想起了本章中看过的某些算法？
- en: Big O Notation however requires some advanced mathematics to explore thoroughly
    so has been intentionally left out of this main chapter, but if you want to learn
    more check out the Useful Links section. These topics are looked at in more depth
    in the Complexity and Tractability chapter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，大 O 符号需要一些高级数学知识来深入探讨，因此它被有意地省略在了这个主要章节中，但如果您想了解更多，请查看有用链接部分。这些主题在复杂性和可解性章节中更深入地研究。
- en: To make things even more complicated, in practice algorithms are running on
    computers that have cached memory and virtual memory, where the time to access
    a particular value can be particularly short, or particularly long. There is a
    whole range of algorithms that are used for this situation to make sure that the
    algorithm still runs efficiently in such environments. Such algorithms are still
    based on the ideas we’ve looked at in this chapter, but require some clever adjustments
    to ensure that they work well.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更加复杂，实际上算法是在具有缓存内存和虚拟内存的计算机上运行的，其中访问特定值的时间可能特别短或特别长。有一整套用于此类情况的算法，以确保算法在这种环境中仍然有效运行。这些算法仍然基于本章所介绍的思想，但需要一些巧妙的调整来确保它们运行良好。
- en: 2.6\. FURTHER READING
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6\. 深入阅读
- en: 2.6.1\. USEFUL LINKS
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.1\. 有用的链接
- en: CS Unplugged [Searching algorithms](http://csunplugged.org/searching-algorithms)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CS Unplugged [搜索算法](http://csunplugged.org/searching-algorithms)
- en: CS Unplugged [Sorting algorithms](http://csunplugged.org/sorting-algorithms)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CS Unplugged [排序算法](http://csunplugged.org/sorting-algorithms)
- en: '[Searching algorithm game, may not be suitable](http://csunplugged.org/divideAndConquer)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[搜索算法游戏，可能不太适合](http://csunplugged.org/divideAndConquer)'
- en: Wikipedia has more details on [Linear Search](http://en.wikipedia.org/wiki/Linear_search), [Binary
    Search](http://en.wikipedia.org/wiki/Binary_search), [Selection sort](http://en.wikipedia.org/wiki/Selection_sort), [Insertion
    sort](http://en.wikipedia.org/wiki/Insertion_sort) and [Quicksort](http://en.wikipedia.org/wiki/Quicksort).
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia 上有更多关于 [线性搜索](http://en.wikipedia.org/wiki/Linear_search)、[二分搜索](http://en.wikipedia.org/wiki/Binary_search)、[选择排序](http://en.wikipedia.org/wiki/Selection_sort)、[插入排序](http://en.wikipedia.org/wiki/Insertion_sort)
    和 [快速排序](http://en.wikipedia.org/wiki/Quicksort) 的详细信息。
- en: The [Sorting Bricks game](http://mathsite.math.berkeley.edu/sorting/brick.html) is
    a great way to learn about several sorting algorithms (requires Java).
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[排序砖块游戏](http://mathsite.math.berkeley.edu/sorting/brick.html) 是学习多种排序算法的好方法（需要
    Java）。'
- en: '[Sorting Algorithms Visualisations](http://www.sorting-algorithms.com/) shows
    several different sorting algorithms racing and contains information and pseudocode
    for each.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[排序算法可视化](http://www.sorting-algorithms.com/) 展示了几种不同的排序算法竞赛，并包含了每种算法的信息和伪代码。'
- en: '[Beginners Guide to Big O Notation](http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[大 O 表示法初学者指南](http://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/)'
- en: 3\. HUMAN COMPUTER INTERACTION
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 人机交互
- en: 3.1\. WHAT’S THE BIG PICTURE?
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1\. 总体情况
- en: People often become frustrated with computers. At some point when using these
    devices, you will be annoyed that the computer did something you didn’t want it
    to do and you can’t figure out how to get the computer to do what you want, but
    why is that? Humans made computers, so why are computers often so frustrating
    to use by humans?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常对计算机感到沮丧。在使用这些设备的某个时刻，你会因为计算机做了你不想要的事情而感到恼火，而且你无法弄清楚如何让计算机做你想要的事情，但为什么呢？计算机是人类制造的，为什么计算机经常让人类感到沮丧呢？
- en: 'Computers are becoming hundreds of times more powerful every decade, yet there
    is one important component of the computer system that hasn’t changed significantly
    in performance since the first computers were developed in the 1940s: the human.
    For a computer system to work really well it needs to be designed by people who
    understand the human part of the system well.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机每十年变得强大数百倍，然而计算机系统中一个重要的组成部分在性能上自 1940 年代的第一台计算机开发以来没有显著改变：人类。要使计算机系统真正运行良好，需要由了解系统人类部分的人设计。
- en: In this chapter we’ll look at what typically makes good and bad interfaces.
    The idea is to make you sensitive to the main issues so that you can critique
    existing interfaces, and begin to think about how you might design good interfaces.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将看一下通常构成好与坏界面的因素。其目的是让你对主要问题变得敏感，这样你就可以批评现有的界面，并开始思考如何设计好的界面。
- en: Often software developers create a computer program or system for a device that
    requires the user to spend some time to learn how to use the program. These interfaces
    might be easy to use for the developer since they know the system really well,
    but a user just wants to get the job done without spending too much time learning
    the software (they might switch to another program if it’s too hard to use). A
    developer might treat the program and the user separately, however the user is
    part of the system, and a developer needs to create the software with the user
    in mind, designing a program that they will find easy to use and intuitive.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，软件开发人员为一个需要用户花费一些时间学习如何使用程序的设备创建计算机程序或系统。这些界面可能对于开发者来说很容易使用，因为他们非常了解系统，但用户只想快速完成任务，而不想花费太多时间学习软件（如果使用起来太困难，他们可能会切换到另一个程序）。开发者可能会把程序和用户分开对待，但用户是系统的一部分，开发者需要以用户为考虑对象，设计一个他们会觉得易于使用和直观的程序。
- en: Human-computer interaction (HCI) is about trying to make programs useful, usable,
    and accessible to humans. It goes way beyond choosing layouts, colours, and fonts
    that aren’t Comics Sans for an interface. It’s strongly influenced by the psychology
    of how people interact with digital devices, which means understanding many issues
    about how people behave, how they perceive things, and how they understand things
    so that they feel that a system is working to help them and not hinder them. HCI
    “involves the study, planning, and design of the interaction between people (the
    users) and computers. It is often regarded as the intersection of computer science,
    behavioral sciences, design and several other fields of study.” By understanding
    HCI, developers are more likely to create software that is effective and popular.
    If you ask people if they have ever been frustrated using a computer system, you’ll
    probably get a clear message that HCI isn’t always done well.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 人机交互（HCI）致力于使程序对人类有用、可用和易于访问。它远不止于选择界面中的布局、颜色和字体（不使用卡通字体）。它受到人们如何与数字设备互动的心理学的强烈影响，这意味着要了解人们如何行为，他们如何感知事物，以及他们如何理解事物，以便他们感到系统正在帮助他们而不是妨碍他们。HCI
    “涉及人（用户）与计算机之间互动的研究、规划和设计。它通常被认为是计算机科学、行为科学、设计和其他几个学科交叉的地方。” 通过了解HCI，开发人员更有可能创建有效和受欢迎的软件。如果你问人们是否曾经在使用计算机系统时感到沮丧，你可能会清楚地得到一个信息，即HCI并不总是做得很好。
- en: 'Try out the following interactive task, and get some friends to try it:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下交互式任务，并让一些朋友也试一试：
- en: Answer as many questions as you can
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能回答多的问题
- en: START
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 开始
- en: 15 seconds left
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 还剩15秒
- en: Did anyone get a wrong answer to the question even though you thought you got
    it right? You may have noticed that the “Yes” and “No” button sometimes swap.
    Inconsistency is normally a really bad thing in an interface, as it can easily
    fool the user into making an error.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你认为自己回答正确了，有人也会答错问题吗？你可能已经注意到，“是”和“否”按钮有时会交换位置。在界面中，不一致通常是一件非常糟糕的事情，因为它很容易让用户犯错。
- en: 'The study of Human Computer Interaction involves a lot of psychology (how people
    behave) because this affects how they will use a system. As a simple example,
    the human short term memory only lasts for a matter of seconds (even in young
    people!) If a device delays a response for more than about 10 seconds, the user
    has to make a conscious effort to remember what they were doing, and that’s extra
    work for the user (which from their point of view, makes the system more tiring
    to use). Another example is that people get “captured” into sequences: if you
    start biking on a route that you take each day, you’ll soon find yourself arriving
    without thinking about every turn along the way, which is fine unless you were
    supposed to go somewhere else on the way. A similar effect occurs with confirmation
    dialogues; perhaps you often accidentally close a file without saving it, and
    the system says “Do you want to save it?”, so you press “Yes”. After you’ve done
    this a few times you’ll be captured into that sequence, so on the one occasion
    that you don’t want to overwrite your old file, you may accidentally click “Yes”
    anyway. A lot of people might blame themselves for such errors, but basic psychology
    says that this is a natural error to make, and a good system should protect users
    from such errors (for example, by allowing them to be undone).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 人机交互的研究涉及大量的心理学（人们的行为），因为这影响着他们如何使用系统。举一个简单的例子，人类的短期记忆只能持续几秒钟（即使在年轻人身上也是如此！）如果一个设备延迟了超过大约10秒的响应，用户就必须有意识地记住他们正在做什么，这对用户来说是额外的工作（从他们的角度来看，这使得系统更加费力）。另一个例子是人们会被“困住”在序列中：如果你每天骑车去一个固定的地方，你很快就会发现自己到达目的地而不用想着沿途的每一个转弯，这是好事，除非你应该在途中去其他地方。类似的效果也会出现在确认对话框中；也许你经常无意中关闭一个未保存的文件，然后系统会说“你要保存吗？”，于是你点击“是”。当你这样做几次后，你就会被困在这个序列中，所以在你不想覆盖旧文件的一次事件中，你可能还是会不小心点击“是”。很多人可能会责怪自己犯了这样的错误，但基本的心理学告诉我们这是一个自然的错误，一个好的系统应该保护用户免受这样的错误（例如，通过允许他们撤消操作）。
- en: Designing good interfaces is *very* difficult. Just when you think you’ve got
    a clever idea, you’ll find that a whole group of people struggle to figure out
    how to use it, or it backfires in some situation. Even worse, some computer developers
    think that their users are dummies and that any interface problems are the user’s
    fault and not the developer’s. But the real problem is that the developer knows
    the system really well, whereas the user just wants to get their job done without
    having to spend a lot of time learning the software – if the software is too hard
    to use, they’ll just find something else that’s easier. Good interfaces are worth
    a lot in the market.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的界面是非常困难的。就在你认为自己有一个聪明的主意时，你会发现一整群人在尝试弄清楚如何使用它，或者在某些情况下它事与愿违。更糟糕的是，一些计算机开发人员认为他们的用户是笨蛋，任何界面问题都是用户的错而不是开发人员的错。但真正的问题是，开发人员非常了解系统，而用户只是想要在不必花费大量时间学习软件的情况下完成工作
    - 如果软件太难使用，他们将只是找到其他更容易的东西。好的界面在市场上价值不菲。
- en: There are many ways to evaluate and fine tune interfaces, and in this chapter
    we’ll look at some of these. One important principle is that one of the worst
    people to evaluate an interface is the person who designed and programmed it.
    They know all the details of how it works, they’ve probably been thinking about
    it for weeks, they know the bits that you’re not supposed to touch and the options
    that shouldn’t be selected, and of course they have a vested interest in finding
    out what is *right*with it rather than what is *wrong*. It’s also important that
    the interface should be evaluated by someone who is going to be a typical user;
    if you get a 12-year-old to evaluate a retirement planning system they may not
    know what the user will be interested in; and if you get a teacher to try out
    a system that students will use, they will know what the answers are and what
    the correct process is.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多评估和微调界面的方法，在本章中我们将介绍其中一些。一个重要的原则是，评估界面的最糟糕的人之一是设计和编程的人。他们知道它的所有细节，他们可能已经思考了几个星期，他们知道你不应该触摸的部分和不应该选择的选项，当然，他们对发现它有什么*正确*之处比发现有什么*错误*之处更感兴趣。由一个典型用户评估界面也很重要；如果你让一个12岁的孩子评估一个退休规划系统，他们可能不知道用户会对什么感兴趣；如果你让一名教师尝试一下学生将使用的系统，他们将知道答案是什么，以及正确的流程是什么。
- en: Often interfaces are evaluated by getting typical users to try them out, and
    carefully noting any problems they have. There are companies that do nothing but
    these kinds of user tests — they will be given a prototype product, and pay groups
    of people to try it out. A report on the product is then produced and given to
    the people who are working on it. This is an expensive process, but it makes the
    product a lot better, and may well give it a huge advantage over its competitors.
    Having it evaluated by a separate company means that you avoid any bias from people
    in your own company who want to prove (even subconsciously) that they’ve done
    a good job designing it, rather than uncover any niggling problems in the software
    that will annoy users.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通常通过让典型用户尝试它们，并仔细记录他们遇到的任何问题来评估界面。有一些公司专门做这类用户测试 - 他们会得到一个原型产品，并支付一群人来尝试它。然后会制作关于产品的报告，并交给正在开发它的人。这是一个昂贵的过程，但它会使产品变得更好，并且很可能使其比竞争对手具有巨大优势。通过一个独立的公司评估它意味着你避免了自己公司中那些想要证明（甚至是下意识地）他们在设计上做得很好的人的任何偏见，而不是发现软件中可能会让用户感到烦恼的任何微小问题。
- en: Before we look at different ways to evaluate interfaces, we need to consider
    what is happening with an interface.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论不同评估界面的方法之前，我们需要考虑界面发生了什么。
- en: 3.2\. USERS AND TASKS
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2\. 用户和任务
- en: 'A very important consideration when designing or evaluating an interface is
    who the users are likely to be. For example, the typical age of a user can be
    significant: very young children may have difficulty reading some words and prefer
    images and animations, while a business person who uses an interface frequently
    will want it to be very fast to use, perhaps using keyboard shortcuts only.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 设计或评估界面时一个非常重要的考虑因素是用户可能是谁。例如，用户的典型年龄可能很重要：非常年幼的孩子可能会有困难阅读一些单词，更喜欢图像和动画，而经常使用界面的商务人士会希望它使用起来非常快，可能只使用键盘快捷键。
- en: What are some of the considerations you would make for the following user groups?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下用户群体，你会考虑哪些因素？
- en: Senior citizens
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 老年人
- en: Gamers
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏玩家
- en: Casual users
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时用户
- en: Foreign visitors
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外国游客
- en: The interface is the only part of a program that the user sees (that’s the definition
    of an interface!), so if the interface doesn’t work for them, the program doesn’t
    work.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 界面是程序中用户看到的唯一部分（这就是界面的定义！），所以如果界面对他们不起作用，程序就不起作用。
- en: Another important thing to do when designing and evaluating an interface is
    to think about what tasks it is being used for. Advertisements for digital devices
    often hide the complexity of a task, and simply point out the features available
    for doing the task. For example, suppose a smartphone is advertised as having
    a high resolution camera. The real task that someone might want to do is to take
    a photo of something they’ve just spotted, and send it to a friend. If you look
    at what happens in reality, the smartphone might be in their pocket or bag, and
    if they see something cool going past, they need to get it out, perhaps unlock
    it, open the camera app, adjust the lighting and other settings, press a button
    (is it easy to find when you’re holding the camera up?), select the photo, choose
    an email option, type in the friend’s address (does the system help with that?),
    send it (what happens if you’re out of reception range?), and then put the phone
    away. If any one of these steps is slow or hard to remember, the whole experience
    can be frustrating, and it’s possible the photo opportunity will be missed, or
    for some other reason the friend won’t receive the photo.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和评估界面时，另一件重要的事情是考虑它正在用于什么任务。 数字设备的广告经常隐藏任务的复杂性，仅指出用于执行任务的可用功能。 例如，假设智能手机被宣传为具有高分辨率相机。
    某人可能想做的真正任务是拍摄他们刚刚发现的东西，并将其发送给朋友。 如果你看看现实中发生了什么，智能手机可能在他们的口袋或包里，如果他们看到一些酷的东西经过，他们需要拿出来，也许解锁它，打开相机应用程序，调整照明和其他设置，按下按钮（拿着相机时是否容易找到？），选择照片，选择电子邮件选项，输入朋友的地址（系统是否有帮助？），发送它（如果你在接收范围之外会发生什么？），然后把手机放回。
    如果任何一个步骤缓慢或难以记住，整个体验可能会令人沮丧，而且可能会错过拍照机会，或者因为某种原因朋友收不到照片。
- en: 'It’s very important to think about the whole context when describing a task.
    As an exercise, can you provide an example of a real task, including context,
    for a real person for each of the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 描述任务时，考虑整个上下文非常重要。 作为一项练习，你能为以下每个实例提供一个真实的任务示例吗，包括上下文，为真实人士：
- en: set an alarm clock
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置闹钟
- en: show a slide (Powerpoint) presentation
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示幻灯片（Powerpoint）演示
- en: It’s important to think through all the parts of a task when discussing an interface,
    as it’s the small steps in a task that make all the difference between using the
    interface in a real situation, compared with a demonstration of some features
    of the device.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论界面时，思考任务的所有部分非常重要，因为任务中的小步骤在实际情况下对比设备的一些功能演示会产生重大差异。
- en: '3.2.1\. ACTIVITY: SENDING AN EMAIL FROM MULTIPLE DEVICES'
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1\. 活动：从多个设备发送电子邮件
- en: For this activity, try sending an email from both a computer and a mobile phone.
    Take note of all the steps required from when you start using the device until
    the email is sent.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个活动，请尝试从计算机和手机发送电子邮件。 注意从你开始使用设备直到发送电子邮件所需的所有步骤。
- en: You will probably notice quite a few differences between the two interfaces.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到两个界面之间有很多差异。
- en: '3.2.2\. ACTIVITY: DESIGNING STOVETOPS/REMOTE'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2\. 活动：设计炉灶顶部/遥控器
- en: For this activity, you will designing the top of a cooking stove. This isn’t
    a computer system, but will help demonstrate some of the issues that come up.
    Your task is to sketch three different configurations for the stovetop which includes
    the arrangement of the 4 elements and the 4 control knobs.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个活动，你将设计一个烹饪灶的顶部。 这不是一个计算机系统，但将帮助演示一些问题。 你的任务是为炉灶顶部草绘三种不同的配置，其中包括4个元素和4个控制旋钮的排列。
- en: The task is [described in detail in the HCI CS Unplugged activity](http://csunplugged.org/human-interface-design).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 任务在[人机界面设计 HCI CS Unplugged 活动中详细描述](http://csunplugged.org/human-interface-design)。
- en: 3.3\. INTERFACE USABILITY
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3\. 界面可用性
- en: 'Devices are often sold using catch phrases like “user friendly” and “intuitive”,
    but these are vague terms that are hard to pin down. In this section we will use
    the more technical term, [Usability](http://en.wikipedia.org/wiki/Usability),
    which is well understood by HCI experts, and gives us some ways to evaluate how
    suitable an interface is for a particular task. Usability isn’t just about an
    interface being nice to use: poor usability can lead to serious problems, and
    has been the cause of major disasters, such as airplane crashes, financial disasters,
    and medical mishaps. It is also important because an interface that requires a
    lot of dexterity, quick reactions or a good memory makes it less accessible to
    much of the population, when accessibility can be both a moral and legal expectation.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 设备通常使用“用户友好”和“直观”等口号销售，但这些是难以明确的模糊术语。在本节中，我们将使用更技术性的术语[可用性](http://en.wikipedia.org/wiki/Usability)，这个术语被人机交互专家广泛理解，并为我们提供了一些评估界面对特定任务的适用性的方法。可用性不仅仅是关于界面是否易于使用：糟糕的可用性可能导致严重问题，并且已经导致了重大灾难，比如飞机失事、金融灾难和医疗事故。这也很重要，因为一个需要很多灵巧、快速反应或良好记忆的界面会使大部分人难以接触，而可接近性既可以是道德期望，也可以是法律期望。
- en: There are many elements that can be considered in usability, and we will mention
    a few that you are likely to come across when evaluating everyday interfaces.
    Bear in mind that the interfaces might not just be a computer — any digital device
    such as an alarm clock, air conditioning remote control, microwave oven, or burglar
    alarms can suffer from usability problems.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在可用性中有许多因素可以考虑，我们将提及一些在评估日常界面时可能会遇到的因素。请记住，界面可能不仅仅是一个计算机 —— 任何数字设备，如闹钟、空调遥控器、微波炉或防盗警报器都可能存在可用性问题。
- en: 'One “golden rule” of usability is *consistency*. If a system keeps changing
    on you, it’s going to be frustrating to use. Earlier we had the example of a yes/no
    button pair that occasionally swapped places. A positive example is the consistent
    use of “control-C” and “control-V” in many different programs to copy and paste
    text or images. This also helps *learnability*: once you have learned copy and
    paste in one program, you know how to use it in many others. Imagine if every
    program used different menu commands and keystrokes for this!'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性的一个“黄金法则”是*一致性*。如果一个系统不断变化，使用起来会很令人沮丧。之前我们提到过一个是/否按钮对有时会交换位置的例子。一个积极的例子是在许多不同程序中一贯使用“控制-C”和“控制-V”来复制和粘贴文本或图像。这也有助于*可学习性*：一旦你学会了在一个程序中复制和粘贴，你就知道如何在许多其他程序中使用它。想象一下，如果每个程序都使用不同的菜单命令和按键组合来实现这个功能！
- en: 'A related issue is the [*Mode error*](http://en.wikipedia.org/wiki/Mode_error#Mode_errors),
    where the behaviour of an action depends on what mode you are in. A simple example
    is having the caps lock key down (particularly for entering a password, where
    you can’t see the effect of the mode). A classic example is in Excel spreadsheets,
    where the effect of clicking on a cell depends on the mode: sometimes it selects
    the cell, and other times it puts the name of the cell you clicked on into another
    cell. Modes are considered bad practice in interface design because they can easily
    cause the user to make the wrong action, and should be avoided if possible.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关问题是[*模式错误*](http://en.wikipedia.org/wiki/Mode_error#Mode_errors)，其中一个动作的行为取决于你所处的模式。一个简单的例子是按下大写锁定键（特别是在输入密码时，你看不到模式的效果）。一个经典的例子是在Excel电子表格中，点击单元格的效果取决于模式：有时它选择单元格，有时它将你点击的单元格名称放入另一个单元格中。模式在界面设计中被认为是不良实践，因为它们很容易导致用户执行错误操作，如果可能的话应该避免使用。
- en: The speed at which an interface responds (its *reaction time*) has a significant
    effect on usability. This is closely related to human perception of time. If something
    happens fast enough, we will perceive it as being instant.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 界面响应速度（其*反应时间*）对可用性有显著影响。这与人类对时间的感知密切相关。如果某事发生得足够快，我们会感觉它是瞬间发生的。
- en: The following interactive lets you find out how fast “instant” is for you. As
    you click on each cell, there will sometimes be a random delay before it comes
    up; other cells won’t have a delay. Click on each cell, and if it seems to respond
    instantly, leave it as it is. However, if you perceive that there is a small delay
    before the image comes up, click it again (which makes the cell a little lighter).
    You can’t go back and change a cell, so just make a quick, gut-level decision
    the first time you click each one. The delay may be very short, but only make
    the cell gray if you are fairly sure you noticed a delay.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下互动让你找出“即时”对你来说有多快。当你点击每个单元格时，有时会出现随机延迟才会出现；其他单元格不会有延迟。点击每个单元格，如果它似乎立即响应，请将其保持原样。但是，如果你感觉在图像出现之前有一点延迟，请再次点击（这会使单元格变得稍微浅一些）。你无法返回并更改单元格，所以第一次点击每个单元格时请做出快速的、直观的决定。延迟可能非常短暂，但只有当你相当确定你注意到了延迟时才将单元格变成灰色。
- en: '[![](563ad235e0a1c.png)Click to load the'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad235e0a1c.png)点击加载'
- en: delay interactive](http://csfieldguide.org.nz/_static/widgets/HCI/HCI-Delay/index.html)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[延迟互动](http://csfieldguide.org.nz/_static/widgets/HCI/HCI-Delay/index.html)'
- en: Once you have clicked on all the cells, click on the “Probability of perceiving
    delays” bar to see a graph of how often you thought there was a delay compared
    with how long the delay actually was. 100 ms is one tenth of a second; for most
    people this is where they are likely to start perceiving a delay; anything short
    (particularly around 50 ms) is very hard to notice. Longer delays (for example,
    350 ms, which is over a third of a second) are very easy to notice.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 点击所有单元格后，点击“感知延迟的概率”栏，以查看你认为有延迟的频率与实际延迟有多长的图表。100毫秒是一秒钟的十分之一；对于大多数人来说，这是他们可能开始察觉到延迟的地方；任何较短的延迟（特别是约50毫秒左右）都很难注意到。较长的延迟（例如，超过三分之一秒的350毫秒）非常容易注意到。
- en: The point of this is that any interface element (such as a button or checkbox)
    that takes more than 100 ms to respond is likely to be perceived by the user as
    not working, and they may even click it again. In the case of a checkbox, this
    may lead to it staying off (from the two clicks), leading the user to think that
    it’s not working.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的目的是，任何需要超过100毫秒才能响应的界面元素（例如按钮或复选框）都可能被用户认为是不工作的，甚至他们可能会再次点击它。对于复选框来说，这可能会导致它保持关闭状态（两次点击），使用户认为它不工作。
- en: Click the checkbox
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 点击复选框
- en: Clicked 0 times
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 已点击0次
- en: So, as you evaluate interfaces, bear in mind that even very small delays can
    make a system hard to use.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在评估界面时，请记住，即使是非常小的延迟也会使系统难以使用。
- en: Another important length of time to bear in mind is our *short term memory* time,
    which is usually a matter of seconds. To remember something for longer, the user
    needs to rehearse it (repeat it over) or make a note of the information, such
    as writing it down. If a system takes some time to respond (say, 10 seconds) then
    chances are the user may have forgotten some detail of what they were going to
    do with the system. For example, if you have a phone number to type in that someone
    has just told you, and it takes 12 seconds before you can type it, you may forget
    the number, whereas if you can access the interface within a couple of seconds,
    you can probably enter the number without much effort. For this reason, any part
    of a system that takes more than about 10 seconds to respond forces the user to
    rehearse or write down key information, which is more tiring.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要牢记的重要时间是我们的*短期记忆*时间，通常是几秒钟的事情。要想记住更长时间的东西，用户需要复述它（重复一遍）或记录下信息，比如写下来。如果系统花费了一些时间来响应（比如，10秒），那么用户可能已经忘记了他们打算如何使用系统的某些细节。例如，如果你有一个刚刚被告知的电话号码要输入，而在你能输入之前需要花费12秒，你可能会忘记这个号码，而如果你可以在几秒钟内访问界面，你可能可以毫不费力地输入这个号码。因此，系统中任何需要超过大约10秒来响应的部分都会迫使用户复述或写下关键信息，这会更加疲惫。
- en: Another important usability consideration is *spatial memory* — our ability
    to remember where things are located (such as where a button or icon is). Human
    spatial memory has a high capacity (you can probably remember the location of
    many places and objects), it is long lasting (people visiting a town they grew
    up in can often remember the layout), and we can remember things very quickly.
    A very simple aspect of usability that comes from this is that the layout of an
    interface shouldn’t keep changing. The interactive task at the start of this chapter
    was deliberately set up to be frustrating by swapping the two buttons occasionally;
    the reason people often make a mistake in that situation is that their spatial
    memory takes over, so the location of the button is more important than what is
    written on it. Systems that aren’t consistent in their spatial placement of the
    “OK” and “Cancel” buttons can be frustrating.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的可用性考虑因素是*空间记忆*——我们记住事物位置的能力（比如按钮或图标的位置）。人类的空间记忆容量很高（你可能能记住许多地方和物体的位置），它持久耐久（去一个长大的小镇的人通常能记得那里的布局），而且我们可以很快记住事物。从这里产生的可用性的一个非常简单的方面是，界面的布局不应该经常变化。本章开始时的交互任务是故意设置成令人沮丧的，因为偶尔交换两个按钮；人们在那种情况下经常犯错误的原因是他们的空间记忆接管了，所以按钮的位置比上面写的内容更重要。不一致地安置“确定”和“取消”按钮的系统会让人沮丧。
- en: Another place that the layout of an interface changes quickly is when a tablet
    or smartphone is rotated. Some devices rearrange the icons for the new orientation,
    which loses the spatial layout, while others keep them the same (except they may
    not look right in the new rotation). Try a few different devices and see which
    ones change the layout when rotated.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 界面布局迅速改变的另一个地方是当平板电脑或智能手机旋转时。一些设备重新排列新方向的图标，这样就失去了空间布局，而另一些则保持不变（除了在新旋转中可能看起来不正确）。尝试一些不同的设备，看看哪些在旋转时改变了布局。
- en: What else can cause the layout of an interface to change suddenly?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 还有什么因素会突然改变界面的布局呢？
- en: Associated with spatial memory is our *muscle memory*, which helps us to locate
    items without having to look carefully. With some practice, you can probably select
    a common button with a mouse just by moving your hand the same distance that you
    always have, rather than having to look carefully. For example, working with a
    new keyboard can mean having to re-learn the muscle memory that you have developed,
    and so may slow you down a bit.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 与空间记忆相关的是我们的*肌肉记忆*，它帮助我们在不必仔细查看的情况下找到物品的位置。通过一些练习，你可能只需移动手的距离就能用鼠标选择一个常见的按钮，而不必仔细查看。例如，使用新键盘可能意味着必须重新学习你已经形成的肌肉记忆，所以可能会使你的速度慢下来。
- en: One common human error that an interface needs to take account of is the *off
    by one error*, where the user accidentally clicks or types on an item next to
    the one they intended. For example, if the “save” menu item is next to a “delete”
    menu item, that is risky because one small slip could cause the user to erase
    a file instead of saving it. A similar issue occurs on keyboards; for example,
    control-W might close just one window in a web browser, and control-Q might close
    the entire web-browser, so choosing these two adjacent keys is a problem. Of course,
    this can be fixed by either checking if the user quits, or by having all the windows
    saved so that the user just needs to open the browser again to get their work
    back. This can also occur in web forms, where there is a reset button next to
    the submit button, and the off-by-one error causes the user to lose all the data
    they just entered.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 界面需要考虑的一个常见人为错误是*偏移一个错误*，即用户意外点击或键入他们打算点击的项目旁边的项目。例如，如果“保存”菜单项旁边是“删除”菜单项，那是有风险的，因为一个小失误可能导致用户删除文件而不是保存文件。键盘上也会出现类似的问题；例如，Ctrl-W可能只会关闭浏览器中的一个窗口，而Ctrl-Q可能会关闭整个浏览器，因此选择这两个相邻的键是一个问题。当然，这可以通过检查用户是否退出来修复，或者通过保存所有窗口使用户只需要再次打开浏览器即可恢复工作。这也可能发生在网络表单中，其中重置按钮在提交按钮旁边，偏移一个错误导致用户丢失了刚刚输入的所有数据。
- en: Another idea used by HCI designers is the *principle of commensurate effort*,
    which says that frequently done simple tasks should be easy to do, but it’s ok
    to require a complex procedure for a complex task. For example, in a word processor,
    printing a page as it is displayed should be easy, but it’s ok if some effort
    is required to make it double sided, two to a page, with a staple in the top left
    corner. In fact, sometimes more effort should be *required* if the command has
    a serious consequence, such as deleting a file, wiping a device, or closing an
    account. In such cases artificial tasks may be added, such as asking “Are you
    sure?”, or to get an extreme setting on a device (like setting a voltage for a
    power supply) might require pressing an “up” button many times, rather than letting
    the user type in an extra couple of zeroes.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: HCI设计师使用的另一个概念是*等效努力原则*，它指出频繁进行的简单任务应该易于完成，但对于复杂任务需要复杂的步骤也是可以接受的。例如，在文字处理器中，打印显示的页面应该很容易，但如果需要将其双面打印，每页两张，并在左上角装订，那么需要一些努力也是可以接受的。事实上，有时候如果命令有严重后果，比如删除文件、擦除设备或关闭账户，可能需要更多的*确认*。在这种情况下，可能会添加人为任务，比如询问“您确定吗？”，或者在设备上设置一个极端值（比如为电源供应设置电压）可能需要多次按“上”按钮，而不是让用户输入额外的几个零。
- en: These are just a few ideas from HCI that will help you to be aware of the kinds
    of issues that interfaces can have. In the following project you can observe these
    kinds of problems firsthand by watching *someone else* use an interface, noting
    any problems they have. It’s much easier to observe someone else than do this
    yourself, partly because it’s hard to concentrate on the interface and taking
    notes at the same time, and partly because you might already know the interface
    and have learned to overcome some of the less usable features.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是HCI中的一些想法，将帮助您意识到界面可能存在的问题。在接下来的项目中，您可以通过观察*其他人*使用界面来直接观察这些问题，注意他们遇到的任何问题。观察别人使用界面比自己做这件事要容易得多，部分原因是很难同时集中精力在界面上并做笔记，部分原因是您可能已经熟悉了界面并学会了克服一些不太易用的功能。
- en: '3.3.1\. PROJECT: COGNITIVE WALKTHROUGH'
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1\. **项目：认知漫步**
- en: The *cognitive walkthrough* is a technique that HCI experts use to do a quick
    evaluation of an interface. [Details of how to do one are on the cs4fn site](http://www.cs4fn.org/usability/cogwalkthrough.php).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*认知漫步*是HCI专家用来快速评估界面的技术。[如何进行认知漫步的详细信息请参考cs4fn网站](http://www.cs4fn.org/usability/cogwalkthrough.php)。'
- en: There is more information in the [Wikipedia entry for Cognitive Walkthrough](http://en.wikipedia.org/wiki/Cognitive_walkthrough).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Wikipedia的认知漫步条目](http://en.wikipedia.org/wiki/Cognitive_walkthrough)中有更多信息。
- en: 3.4\. USABILITY HEURISTICS
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4\. **可用性启发式**
- en: Evaluating an interface is best done by getting feedback from having lots of
    potential users try it out. However, this can be expensive and time-consuming,
    so HCI experts have come up with some quick rules of thumb that help us spot obvious
    problems quickly. The formal word for a rule of thumb is a *heuristic*, and in
    this section we will look at some common heuristics that can be used to critique
    an interface.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 评估界面最好的方法是让许多潜在用户尝试使用并提供反馈。然而，这可能会很昂贵且耗时，因此HCI专家提出了一些快速的经验法则，帮助我们快速发现明显的问题。经验法则的正式名称是*启发式*，在本节中我们将介绍一些常见的启发式，用于批评界面。
- en: There are various sets of heuristics that people have proposed for evaluating
    interfaces, but a Danish researcher called Jakob Nielsen has come up with a set
    of 10 heuristics that have become very widely used, and we will describe them
    in this section. If you encounter a usability problem in an interface, it is almost
    certainly breaking one of these heuristics, and possibly a few of them. It’s not
    easy to design a system that doesn’t break any of the heuristics, and sometimes
    you wouldn’t want to follow them strictly — that’s why they are called heuristics,
    and not rules.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 人们提出了各种用于评估界面的启发式集，但一位名为Jakob Nielsen的丹麦研究人员提出了一套广泛使用的10个启发式，我们将在本节中描述它们。如果在界面中遇到可用性问题，几乎肯定是违反了这些启发式中的一个，甚至几个。设计一个不违反任何启发式的系统并不容易，有时您可能不想严格遵循它们
    — 这就是它们被称为启发式而不是规则的原因。
- en: You can find the [heuristics online on Jakob Nielsen’s website](http://www.nngroup.com/articles/ten-usability-heuristics/);
    below is an explanation of each one.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Jakob Nielsen的网站上找到[启发式原则](http://www.nngroup.com/articles/ten-usability-heuristics/)的在线版本；以下是每个原则的解释。
- en: 3.4.1\. VISIBILITY OF SYSTEM STATUS
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1\. **系统状态的可见性**
- en: '*The system should always keep users informed about what is going on, through
    appropriate feedback within reasonable time.*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统应始终通过合理的时间内适当的反馈向用户提供信息。*'
- en: This heuristic states that a user should be able to see what the device is doing
    (the system’s status), at all times. This varies from the user being able to tell
    if the device is turned on or off, to a range of actions. A classic example is
    the “caps lock” key, which may not clearly show if it is on, and when typing a
    password the user might not know why it is being rejected; a positive example
    of this is when a password entry box warns you that the caps lock key is on.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个启发式规定用户应该随时能够看到设备在做什么（系统的状态）。 这与用户能否判断设备是开启还是关闭有关，以及一系列动作。 一个经典的例子是“大写锁定”键，它可能不清楚地显示是否打开，并且在输入密码时用户可能不知道为什么会被拒绝；
    这种情况的一个积极例子是密码输入框警告您大写锁定键已打开。
- en: One of the simplest statuses for a device is on or off, which is usually a coloured
    light on the outside of the computer. However, some devices take a while to show
    the status (for example, some DVD players take a while to respond when switched
    on), and the user might press the power button again or otherwise get confused
    about the status.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 设备的最简单状态之一是开启或关闭，通常是计算机外部的彩色灯。 但是，一些设备需要一段时间才能显示状态（例如，一些DVD播放器在开启时需要一段时间才能响应），用户可能会再次按下电源按钮或以其他方式对状态感到困惑。
- en: There are many tasks that users ask computers to do that require some time including
    copying documents, downloading files, and loading video games. In this situation,
    one of the most common ways to keep a user informed of the task is the progress
    bar.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 用户要求计算机执行的许多任务都需要一些时间，包括复制文件、下载文件和加载视频游戏。 在这种情况下，向用户通报任务进度的最常见方式之一是进度条。
- en: 85% Complete
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 85% 完成
- en: '![](563ad23528d53.gif)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad23528d53.gif)'
- en: '![](563ad234920a4.gif)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad234920a4.gif)'
- en: '[![](563ad233de2f6.png)](http://xkcd.com/612/)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad233de2f6.png)](http://xkcd.com/612/)'
- en: However, progress indicators aren’t always helpful; the spinning wheels above
    don’t indicate if you are going to have to wait a few seconds or a few minutes
    (or even hours) for the task to complete, which can be frustrating.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，进度指示器并不总是有帮助的； 上面的旋转图标无法指示您是否需要等待几秒钟、几分钟（甚至几小时）才能完成任务，这可能会让人感到沮丧。
- en: Giving feedback in a “reasonable time” is really important, and the “reasonable
    time” is often shorter than what you might think. In the section above there was
    an experiment to find out at what point people perceive a delayed reaction; you
    probably found that it was around a tenth of a second. If a computer takes longer
    than that to respond then it can be confusing to use. There’s more about this
    in the previous section.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在“合理的时间”内提供反馈非常重要，“合理的时间”通常比您想象的要短。 在上面的部分中进行了一个实验，以找出人们感知延迟反应的临界点； 您可能发现它大约是十分之一秒。
    如果计算机的响应时间超过这个时间，那么使用起来可能会令人困惑。 在前一节中还有更多相关内容。
- en: 'There are some other important delay periods in interface evaluation: a delay
    of around 1 second is where natural dialogues start to get awkward, and around
    10 seconds puts a lot of load on the user to remember what they were doing. Nielsen
    has an [article about the importance of these time periods](http://www.nngroup.com/articles/response-times-3-important-limits/).
    If you want to test these ideas, try having a conversation with someone where
    you wait 3 seconds before each response; or put random 10 second delays in when
    you’re working on a task!'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在界面评估中存在一些其他重要的延迟时期：大约1秒的延迟是自然对话开始变得尴尬的时候，而约10秒的延迟会让用户难以记住他们正在做什么。 Nielsen撰写了一篇关于这些时间段重要性的[文章](http://www.nngroup.com/articles/response-times-3-important-limits/)。
    如果您想测试这些想法，请尝试与某人进行对话，在每次回复之前等待3秒钟； 或者在完成任务时随机延迟10秒钟！
- en: Getting computers to respond quickly often depends on the algorithms used (covered
    in the chapter on algorithms), and can also depend on the design of a program
    (such as whether it stores data on disk or waits for a network response before
    continuing). It is particularly noticeable on small devices like smartphones,
    which have limited computing power, and might take a second or two to open an
    app or respond to some input. It’s not too hard to find these sorts of delays
    in systems when you’re evaluating them.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让计算机快速响应通常取决于所使用的算法（在算法章节中有介绍），也可能取决于程序的设计（例如它是将数据存储在磁盘上，还是在继续之前等待网络响应）。这在像智能手机这样的小型设备上特别明显，这些设备的计算能力有限，可能需要一两秒钟来打开应用程序或响应某些输入。在评估系统时，很容易发现这种延迟。
- en: 3.4.2\. MATCH BETWEEN SYSTEM AND THE REAL WORLD
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2\. 系统与现实世界的匹配
- en: '*The system should speak the users’ language, with words, phrases and concepts
    familiar to the user, rather than system-oriented terms. Follow real-world conventions,
    making information appear in a natural and logical order.*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统应该使用用户熟悉的词语、短语和概念，而不是系统导向的术语。遵循现实世界的惯例，使信息以自然和逻辑的顺序出现。*'
- en: The language, colours and notation in an interface should match the user’s world,
    and while this seems obvious and sensible, it’s often something that is overlooked.
    Take for example the following two buttons — can you see what is confusing about
    them?
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 界面中的语言、颜色和符号应该与用户的世界相匹配，虽然这似乎是显而易见和合理的，但往往会被忽视。比如下面的两个按钮——你能看出有什么令人困惑的地方吗？
- en: CONFIRM
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 确认
- en: CANCEL
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 取消
- en: The following interface is from a bank system for paying another person. Suppose
    you get an email asking someone to pay you $1699.50 dollars for a used car; try
    entering “$1699.50” into the box.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的界面来自一个用于向他人支付款项的银行系统。假设您收到一封电子邮件，要求某人支付给您$1699.50美元购买一辆二手车；尝试将“$1699.50”输入到框中。
- en: 'Payment Amount:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 付款金额：
- en: The notation “$1699.50” is a common way to express a dollar amount, but this
    system forces you to follow its own conventions (probably to make things easier
    for the programmer who wrote the system).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 符号“$1699.50”是表达美元金额的常用方式，但是这个系统强制你遵循它自己的惯例（可能是为了让编写系统的程序员更容易些）。
- en: Are there other ways of expressing dollar amounts that are valid, but this system
    rejects? This system should be flexible with the inputted text to prevent errors
    (we will talk more about this later on).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有其他有效的表达美元金额的方式，但是这个系统会拒绝？这个系统应该对输入的文本灵活处理，以防止错误（我们稍后会详细讨论这个问题）。
- en: 3.4.3\. USER CONTROL AND FREEDOM
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.3\. 用户控制和自由
- en: '*Users often choose system functions by mistake and will need a clearly marked
    “emergency exit” to leave the unwanted state without having to go through an extended
    dialogue. Support undo and redo.*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户经常误选系统功能，并需要一个明确定义的“紧急退出”以离开不需要的状态，而不必经过长时间的对话。支持撤销和重做。*'
- en: It is very frustrating to make a mistake and not be able to get out of it. It
    is particularly bad if one small action can wipe a lot of work that can’t be recovered
    (the reset button on some web forms is infamous for this — it is often next to
    the submit button, and you can wipe all your data with an off-by-one error.) A
    common way to provide user freedom is an “undo” feature, which means that not
    only can mistakes be fixed easily, but the user is encouraged to experiment, trying
    out features of the interface secure in the knowledge that they can just “undo”
    to get back to how things were, instead of worrying that they’ll end up in a state
    that they can’t fix. If “redo” is also available, they can flick back and forth,
    deciding which is best. (In fact, redo is really an undo for undo!)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 犯一个错误而无法摆脱它非常令人沮丧。如果一个小操作可以清除无法恢复的大量工作，那就特别糟糕了（一些网络表单上的重置按钮以此而臭名昭著——它经常位于提交按钮旁边，你可能会因为一个错位而清除所有数据）。提供用户自由的一种常见方式是“撤销”功能，这意味着不仅可以轻松纠正错误，而且鼓励用户进行实验，尝试界面的功能，因为他们知道他们可以轻松地“撤销”回到以前的状态，而不是担心会陷入无法解决的状态。如果“重做”也可用，他们可以来回切换，决定哪种方式更好。事实上，重做实际上是撤销的撤销！
- en: Here’s an example of a button that doesn’t provide user control; if you press
    it, you’ll lose this whole page and have to find your way back (we warned you!)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不提供用户控制的按钮示例；如果您按下它，您将丢失整个页面，并且不得不找回去（我们警告过您！）
- en: Do you wish to close this window?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否希望关闭此窗口？
- en: 'YES'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: 'NO'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: Sometimes the interface can force the user into doing something the user does
    not want to do. For example, it is quite common for operating systems or programs
    to perform updates automatically that require a restart. Sometimes the interface
    may not give them the opportunity to cancel or delay this, and restart nevertheless.
    This is bad if it happens when the user is just about to give a presentation.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候界面可能会强迫用户做一些用户不想做的事情。例如，操作系统或程序可能会自动执行需要重新启动的更新。有时候界面可能不会给他们取消或延迟此操作的机会，而是仍然重新启动。如果这种情况发生在用户正要进行演示时，那就糟糕了。
- en: Another common form of this problem is not being able to quit a system. A positive
    example is the “home” button on smartphones, which almost always stops the current
    app that is in use.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的问题形式是无法退出系统。一个积极的例子是智能手机上的“主页”按钮，几乎总是停止当前正在使用的应用程序。
- en: 3.4.4\. CONSISTENCY AND STANDARDS
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.4\. 一致性和标准
- en: '*Users should not have to wonder whether different words, situations, or actions
    mean the same thing. Follow platform conventions.*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户不应该想知道不同的词语、情境或行动是否意味着相同的事情。遵循平台约定。*'
- en: Consistency (something being the same every time) is extremely useful for people
    using interfaces, and is sometimes called the “golden rule of HCI”. If an interface
    is consistent with other interfaces then learning in one interface transfers directly
    to another. One of the biggest examples of consistency in computer programs is
    copy and paste, which works the same way in most software, so users only have
    to learn the concept once. The shortcut keys for copy and paste are also fairly
    consistent between programs. But in some software, copy/paste behaves differently,
    and this can be confusing for users.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性（每次都是相同的东西）对于使用接口的人非常有用，有时被称为“HCI的黄金法则”。如果一个接口与其他接口一致，那么在一个接口中学习的内容直接转移到另一个接口。在计算机程序中一致性的最大例子之一是复制和粘贴，在大多数软件中都以相同的方式工作，因此用户只需要学习一次这个概念。复制和粘贴的快捷键在程序之间也是相当一致的。但在一些软件中，复制/粘贴的行为不同，这可能会让用户感到困惑。
- en: An example of inconsistency is generally found within spreadsheet programs,
    where the result of pushing “control-A” (select all) depends on whether you are
    editing a cell or just have the cell selected (this particular problem is a ‘mode’
    problem). While this may make sense to a user experienced with spreadsheets, a
    new user can be very confused when the same action causes a different response.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一种不一致性的例子通常在电子表格程序中找到，在那里按下“control-A”（选择全部）的结果取决于您是正在编辑单元格还是只是选择了单元格（这个特定的问题是一种‘模式’问题）。虽然这对于熟悉电子表格的用户可能有意义，但新用户在相同的操作导致不同的响应时可能会感到非常困惑。
- en: A lack of consistency is often the reason behind people not liking a new system.
    It is particularly noticeable between Mac and Windows user; someone who has only
    used one system can find the other very frustrating to use because so many things
    are different (consider the window controls for a start, which are in a different
    place and have different icons). An experienced user of one interface will think
    that it is “obvious”, and can’t understand why the other person finds it frustrating,
    which can lead to discussions of religious fervour on which interface is best.
    Similar problems can occur when a radically different version of an operating
    system comes out (such as Windows 8); a lot of the learning that has been done
    on the previous system needs to be undone, and the lack of consistency (i.e. losing
    prior learning) is frustrating.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 不一致性常常是人们不喜欢新系统的原因。在Mac和Windows用户之间尤其明显；只用过一个系统的人可能会发现另一个系统非常令人沮丧，因为有许多事情都不同（首先考虑窗口控件，它们位于不同的位置并具有不同的图标）。一个接口的经验丰富的用户会认为它是“显而易见的”，而不理解为什么另一个人会感到沮丧，这可能导致关于哪种界面更好的宗教狂热的讨论。当操作系统的一个完全不同的版本出现时（比如Windows
    8），类似的问题可能会发生；之前系统上的大部分学习都需要被废弃，而且不一致性（即失去之前的学习）是令人沮丧的。
- en: 3.4.5\. ERROR PREVENTION
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.5\. 错误预防
- en: '*Even better than good error messages is a careful design which prevents a
    problem from occurring in the first place. Either eliminate error-prone conditions
    or check for them and present users with a confirmation option before they commit
    to the action.*'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*比良好的错误消息更好的是仔细设计，防止问题在第一次发生。要么消除容易出错的条件，要么在用户承诺执行操作之前检查它们并向用户提供确认选项。*'
- en: A computer program shouldn’t make it easy for people to make serious errors.
    An example of error prevention found in many programs is a menu item on a toolbar
    or dropdown being ‘greyed out’ or deactivated. It stops the user from using a
    function that shouldn’t be used in that situation, like trying to copy when nothing
    is selected. A good program would also inform the user why an item is not available
    (for example in a tooltip).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序不应该让人们轻易犯严重错误。许多程序中找到的错误预防的例子是工具栏或下拉菜单中的菜单项被“灰化”或停用。它阻止用户在该情况下使用不应该使用的功能，比如在没有选定任何内容的情况下尝试复制。一个好的程序还会告诉用户为什么某个项目不可用（例如在工具提示中）。
- en: Below is a date picker; can you see what errors can be produced with it?
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个日期选择器；你能看出它可能产生哪些错误吗？
- en: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31   January February March April May June July August September October November December   20152014201320122011201020092008200720062005200420032002200120001999199819971996199519941993199219911990198919881987198619851984198319821981198019791978197719761975197419731972197119701969196819671966196519641963196219611960195919581957195619551954195319521951195019491948194719461945194419431942194119401939193819371936
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31   一月 二月 三月 四月 五月 六月 七月 八月 九月 十月 十一月 十二月   20152014201320122011201020092008200720062005200420032002200120001999199819971996199519941993199219911990198919881987198619851984198319821981198019791978197719761975197419731972197119701969196819671966196519641963196219611960195919581957195619551954195319521951195019491948194719461945194419431942194119401939193819371936
- en: A related problem with dates is when a user needs to pick a start and end date
    (for example, booking flights or a hotel room); the system should prevent a date
    prior to the first date being selected for the second date.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 与日期相关的一个问题是当用户需要选择开始和结束日期时（例如，订票航班或酒店房间）；系统应该防止在第一个日期之前选择第二个日期。
- en: Any time a dialogue box comes up that says you weren’t allowed to do a certain
    action, the system has failed to prevent an error. Of course, it may be difficult
    to do that because the error can depend on so many user choices, but it is ideal
    that the system doesn’t offer something that it can’t do.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 每当出现一个对话框，告诉你不能执行某个动作时，系统未能防止错误。当然，这可能很难做到，因为错误可能取决于用户的很多选择，但理想情况下，系统不会提供它无法执行的内容。
- en: MENU
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单
- en: 3.4.6\. RECOGNITION RATHER THAN RECALL
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.6\. 识别而不是回忆
- en: '*Minimize the user’s memory load by making objects, actions, and options visible.
    The user should not have to remember information from one part of the dialogue
    to another. Instructions for use of the system should be visible or easily retrievable
    whenever appropriate.*'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过使对象、动作和选项可见来减少用户的记忆负担。用户不应该记住对话框的一部分信息到另一部分。系统使用说明应在适当时可见或容易检索。*'
- en: Humans are generally very good at recognising items, but computers are good
    at remembering them accurately. A good example of this is a menu system; if you
    click on the “Edit” menu in a piece of software, it will remind you of all the
    editing tasks available, and you can choose the appropriate one easily. If instead
    you had to type in a command from memory, that would put more load on the user.
    In general it’s good for the computer to “remember” details, and the user to be
    presented with options rather than having to remember them.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 人类通常很擅长识别物品，但计算机擅长准确地记住它们。一个很好的例子是菜单系统；如果你在软件中点击“编辑”菜单，它会提醒你所有可用的编辑任务，并且你可以轻松选择适当的任务。如果相反地，你必须凭记忆输入命令，那将给用户增加更多负担。一般来说，让计算机“记住”细节是好的，而让用户呈现选项而不是必须记住它们是好的。
- en: 3.4.7\. FLEXIBILITY AND EFFICIENCY OF USE
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.7\. 灵活性和使用效率
- en: '*Accelerators – unseen by the novice user – may often speed up the interaction
    for the expert user such that the system can cater to both inexperienced and experienced
    users. Allow users to tailor frequent actions.*'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*加速器 - 对初学者用户不可见 - 可以加快经验丰富的用户的互动，使系统可以满足无经验和有经验的用户。允许用户定制频繁的操作。*'
- en: When someone is using software every day, they soon have common sequences of
    operations they do (such as “Open the file, find the next blank space, put in
    a record of what just happened”). It’s good to offer ways to make this quick to
    do, such as “macros” which do a sequence of actions from a single keystroke.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人每天使用软件时，他们很快就会有常见的操作序列（比如“打开文件，找到下一个空白处，记录刚刚发生的事情”）。提供快速执行这些操作的方法是很好的，比如“宏”可以通过单个按键来执行一系列操作。
- en: Similarly, it’s good to be able to customise software by allocating keystrokes
    for frequent actions (such as “file this email in the ‘pending’ folder”). Common
    tasks like copy and paste usually have keystrokes added to them, and these allow
    experienced users to perform the task without having to reach for a mouse.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，能够通过为频繁操作分配按键（例如“将此电子邮件归档到‘待处理’文件夹”）来自定义软件是很好的。常见任务如复制和粘贴通常会添加快捷键，这使得经验丰富的用户可以在无需鼠标的情况下执行任务。
- en: 3.4.8\. AESTHETIC AND MINIMALIST DESIGN
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.8\. 美学和极简主义设计
- en: '*Dialogues should not contain information which is irrelevant or rarely needed.
    Every extra unit of information in a dialogue competes with the relevant units
    of information and diminishes their relative visibility.*'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*对话框不应包含无关或很少需要的信息。对话框中的每个额外信息单元都会与相关信息单元竞争，并降低它们的相对可见性。*'
- en: Software can contain many features, and if they are all visible at the same
    time (for example, on a toolbar) this can be overwhelming for a new user.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 软件可能包含许多功能，如果它们同时都可见（例如在工具栏上），这对于新用户来说可能会很压倒。
- en: 3.4.9\. HELP USERS RECOGNIZE, DIAGNOSE, AND RECOVER FROM ERRORS
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.9\. 帮助用户识别、诊断和从错误中恢复
- en: '*Error messages should be expressed in plain language (no codes), precisely
    indicate the problem, and constructively suggest a solution.*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*错误消息应该用简单的语言（没有代码）表达，准确指出问题，并建议解决方案。*'
- en: It’s not hard to find error messages that don’t really tell you what’s wrong!
    The most common examples are messages like “Misc error”, “Error number -2431”,
    or “Error in one of the input values”. These force the user to go on a debugging
    mission to find out what went wrong, which could be anything from a disconnected
    cable or unfixable compatibility issue, to a missing digit in a number.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易找到并不真正告诉你出了什么问题的错误消息！最常见的例子是“杂项错误”，“错误编号-2431”或“输入值中的错误”。这些强迫用户进行调试任务，以找出出了什么问题，可能是从断开的电缆或无法修复的兼容性问题，到数字中缺失的数字等任何问题。
- en: A variant of this is a message that gives two alternatives, such as “File may
    not exist, or it may already be in use”. A better message would save the user
    having to figure out which of these is the problem.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种是提供两个选择的消息，例如“文件可能不存在，或者可能已在使用中”。更好的消息会避免用户不得不弄清楚这两者哪个是问题。
- en: 3.4.10\. HELP AND DOCUMENTATION
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.10\. 帮助和文档
- en: '*Even though it is better if the system can be used without documentation,
    it may be necessary to provide help and documentation. Any such information should
    be easy to search, focused on the user’s task, list concrete steps to be carried
    out, and not be too large.*'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '*即使最好的情况是系统可以在没有文档的情况下使用，但可能需要提供帮助和文档。任何此类信息都应易于搜索，专注于用户的任务，列出要执行的具体步骤，并且不应过于庞大。*'
- en: CLICK ME FOR HELP
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 点我获取帮助
- en: Often help is an afterthought, and tends to be feature-centred (e.g. a catalogue
    of menu items), rather than task-centred (the series of actions needed to complete
    typical tasks, which is more useful for the user). When a user needs help, they
    typically have a task to complete (such as upload photos from a camera), and good
    documentation should explain how to do common tasks, rather than explain each
    feature (such as “Setting the camera to USB mode”).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助通常是事后想法，并且往往以功能为中心（例如菜单项目目录），而不是以任务为中心（完成典型任务所需的一系列操作，对用户更有用）。当用户需要帮助时，他们通常有一个要完成的任务（例如从相机上传照片），良好的文档应该解释如何完成常见任务，而不是解释每个功能（例如“将相机设置为USB模式”）。
- en: 3.5\. THE WHOLE STORY!
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5\. 整个故事！
- en: In this chapter we’ve mainly looked at how to critique interfaces, but we haven’t
    said much about how to design good interfaces. That’s a whole new problem, although
    being able to see what’s wrong with an interface is a key idea. Many commercial
    systems are tested using the ideas above to check that people will find them easy
    to use; in fact, before releasing a new application, often they are tested many
    times with many users. Improvements are made, and then more tests need to be run
    to check that the improvements didn’t make some other aspect of the interface
    worse! It’s no wonder that good software can be expensive — there are many people
    and a lot of time involved in making sure that it’s easy to use before it’s released.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们主要讨论了如何批评界面，但我们并没有谈论如何设计良好的界面。这是一个全新的问题，尽管能够看出界面有何问题是一个关键的想法。许多商业系统都是使用上述思想进行测试，以确保人们会发现它们易于使用；事实上，在发布新应用程序之前，它们通常会被多次测试，使用多个用户进行测试。进行改进，然后需要运行更多的测试来检查改进是否会使界面的其他方面变得更糟！难怪好的软件可能会很昂贵——在发布之前需要投入许多人力和时间来确保它易于使用。
- en: 'We also haven’t talked much about accessibility: making a system usable for
    someone with a disability such as impaired vision or impaired use of their limbs
    provides extra challenges, but is also very worthwhile because the device itself
    may improve accessibility (such as software to browse the web using an audio interface,
    or a computer-controlled wheelchair that can avoid colliding with obstacles).'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有谈论太多关于可访问性的内容：使系统对残障人士，如视力受损或肢体受损的人士可用，会带来额外的挑战，但也非常值得，因为设备本身可能会提高可访问性（例如，使用音频接口浏览网页的软件，或者可以避免与障碍物碰撞的计算机控制轮椅）。
- en: There are many other ideas from psychology, physiology, sociology and even anthropology
    that HCI experts must draw on. Things that come into play include[Mental models](http://en.wikipedia.org/wiki/Mental_model),
    about how someone believes a system works compared with how it actually works
    (these are almost never the same e.g. double clicking on an icon that only needs
    to be single clicked), [Fitts’s law](http://en.wikipedia.org/wiki/Fitts's_law),
    about how long it takes to point to objects on a screen (such as clicking on a
    small button), the [Hick-Hyman law](http://en.wikipedia.org/wiki/Hick's_law),
    about how long it takes to make a decision between multiple choices (such as from
    a menu), [Miller’s law](http://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two) about
    the number of items a person can think about at once,[affordances](http://en.wikipedia.org/wiki/Affordance),
    about how properties of an object help us to perform actions on them, [interaction
    design (IxD)](http://en.wikipedia.org/wiki/Interaction_design), about creating
    digital devices that work for the people who will use the product, [the NASA TLX
    (Task Load Index)](http://en.wikipedia.org/wiki/NASA-TLX) for rating the perceived
    workload that a task puts on a user, and many more laws, observations and guidelines
    about designing interfaces that take account of human behaviour and how the human
    body functions.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 人机交互专家必须利用心理学、生理学、社会学甚至人类学等许多其他思想。涉及的内容包括[心理模型](http://en.wikipedia.org/wiki/Mental_model)，即某人认为系统如何运作与实际运作方式的差异（这些几乎从不相同，例如双击只需要单击的图标），[费茨定律](http://en.wikipedia.org/wiki/Fitts's_law)，即在屏幕上指向对象所需的时间（例如点击一个小按钮），[希克-海曼定律](http://en.wikipedia.org/wiki/Hick's_law)，即在多个选择之间做出决策所需的时间（例如从菜单中选择），[米勒定律](http://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two)，即一个人可以同时思考的项目数量，[可供性](http://en.wikipedia.org/wiki/Affordance)，即对象的属性如何帮助我们对其执行操作，[交互设计（IxD）](http://en.wikipedia.org/wiki/Interaction_design)，即创建为将使用该产品的人而设计的数字设备，[NASA
    TLX（任务负荷指数）](http://en.wikipedia.org/wiki/NASA-TLX)用于评估任务对用户的感知负荷，以及许多其他法律、观察和指南，涉及设计考虑人类行为以及人体功能的界面。
- en: 3.6\. FURTHER READING
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6\. 进一步阅读
- en: The book “Designing with the mind in mind” by Jeff Johnson provides excellent
    background reading for many of the issues discussed in this chapter
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《**设计中的心灵**》是 Jeff Johnson 撰写的一本书，为本章讨论的许多问题提供了优秀的背景阅读。
- en: The [cs4fn website has a lot of articles and activities on Human Computer Interaction](http://www.cs4fn.org/fundamentals/hci.php),
    such as [problems around reporting interface problems](http://www.cs4fn.org/chi-med/reportingincidents.php), [cultural
    issues in interface design](http://www.cs4fn.org/usability/tzeltal.php), and [The
    importance of Sushi](http://www.cs4fn.org/usability/importanceofsushi.php).
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[cs4fn网站上有大量有关人机交互的文章和活动](http://www.cs4fn.org/fundamentals/hci.php)，如[报告界面问题的问题](http://www.cs4fn.org/chi-med/reportingincidents.php)、[界面设计中的文化问题](http://www.cs4fn.org/usability/tzeltal.php)和[寿司的重要性](http://www.cs4fn.org/usability/importanceofsushi.php)。'
- en: A classic book relating to usability is “The psychology of everyday things”
    (later changed to “The design of everyday things”) by Don Norman. It’s about everyday
    objects like doors and phones, and it was written a while ago, but it contains
    lots of thought provoking and often humorous examples.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与可用性相关的经典书籍是唐·诺曼（Don Norman）的《日常物品的心理学》（后来改名为《日常物品的设计》）。它涉及日常物品如门和电话，虽然写于一段时间之前，但包含许多发人深省且常常幽默的例子。
- en: 3.6.1\. USEFUL LINKS
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.1\. 有用的链接
- en: '[The ten usability heuristics on Nielsen’s website](http://www.nngroup.com/articles/ten-usability-heuristics/),
    and a [collection of articles about usability heuristics](http://www.nngroup.com/topic/heuristic-evaluation/)'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Nielsen网站上有十大可用性启发式法则](http://www.nngroup.com/articles/ten-usability-heuristics/)，以及[有关可用性启发式法则的文章集合](http://www.nngroup.com/topic/heuristic-evaluation/)。'
- en: There is a [CS Unplugged activity on HCI](http://csunplugged.org/sites/default/files/activity_pdfs_full/unplugged-19-human_interface_design_0.pdf) which
    includes background information
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个[关于人机交互的CS取消活动](http://csunplugged.org/sites/default/files/activity_pdfs_full/unplugged-19-human_interface_design_0.pdf)，其中包括背景信息。
- en: There is [extensive material on HCI on the cs4fn website](http://www.cs4fn.org/fundamentals/hci.php)
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[cs4fn网站上有大量关于人机交互的资料](http://www.cs4fn.org/fundamentals/hci.php)。
- en: A [glossary of usability terms](http://www.usabilityfirst.com/glossary/)
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个[可用性术语表](http://www.usabilityfirst.com/glossary/)。
- en: 4\. PROGRAMMING LANGUAGES
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 编程语言
- en: 4.1\. WHAT’S THE BIG PICTURE?
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1\. 整体概览
- en: Programming, sometimes referred to as coding, is a nuts and bolts activity for
    computer science. While this book won’t teach you how to program (we’ve given
    some links to sites that can do this in the introduction), we are going to look
    at what a programming language is, and how computer scientists breath life into
    a language. From a programmer’s point of view, they type some instructions, and
    the computer follows them. But how does the computer know what to do? Bear in
    mind that you might be using one of the many languages such as Python, Java, Scratch,
    Basic or C#, yet computers only have the hardware to follow instructions in one
    particular language, which is usually a very simple “machine code” that is hard
    for humans to read and write. And if you invent a new programming language, how
    do you tell the computer how to use it?
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 编程，有时称为编码，是计算机科学的一项基础活动。虽然本书不会教您如何编程（在引言中我们提供了一些可以做到这一点的网站链接），但我们将探讨编程语言是什么，以及计算机科学家如何使语言活跃起来。从程序员的角度来看，他们键入一些指令，计算机就会执行它们。但是计算机如何知道该做什么？请记住，您可能正在使用诸如Python、Java、Scratch、Basic或C#之类的许多语言，但是计算机只有硬件来遵循一种特定的语言，通常是一种非常简单的“机器码”，这对人类来说很难读写。如果您发明了一种新的编程语言，该如何告诉计算机如何使用它？
- en: In this chapter we’ll look at what happens when you write and run a program,
    and how this affects the way that you distribute the program for others to use.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看当您编写和运行程序时会发生什么，以及这如何影响您将程序分发给他人使用的方式。
- en: We start with an optional subsection on what programming is, for those who have
    never programmed before and want an idea about what a program is. Examples of
    very simple programs in Python are provided, and these can be run and modified
    slightly. Working through this section should give you sufficient knowledge for
    the rest of this chapter to make sense; we won’t teach you how to program, but
    you will get to go through the process that programmers use to get a program to
    run. Feel free to skip this section if you are already know a bit about programming.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先有一个关于编程是什么的可选小节，针对那些以前从未编程过但想了解程序是什么的人。提供了Python中非常简单的程序示例，这些示例可以运行并稍作修改。通过完成本节，您应该能够理解本章的其余部分；我们不会教您如何编程，但您将了解程序员用来使程序运行的过程。如果您已经对编程有所了解，请随时跳过本节。
- en: A subsection on what this chapter focuses on then follows. Everybody should
    read that section.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着是本章重点的一个小节。每个人都应该阅读那一部分。
- en: 4.1.1\. WHAT IS PROGRAMMING?
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1\. 什么是编程？
- en: 'Note: This section is intended for those who are unfamiliar with programming.
    If you already know a little about programming, feel free to skip over this section.
    Otherwise, it will give you a quick overview so that the remainder of the chapter
    makes sense.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本节面向那些对编程不熟悉的人。如果你已经了解一些编程知识，可以跳过本节。否则，它将为你提供一个快速概述，以便后面的章节更容易理解。
- en: An example of the simplest kind of program is as follows — it has five instructions
    (one on each line) that are followed one after the other.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单类型的程序示例如下 — 它有五条指令（每行一条），按顺序执行。
- en: '[PRE0]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This program is written in a language called Python, and when the program runs,
    it will print the following text to the screen
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序是用一种叫做Python的语言编写的，当程序运行时，它将把以下文本打印到屏幕上
- en: '[PRE1]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In order to run a Python program, we need something called a Python interpreter.
    A Python interpreter is able to read your program, and process it. Below is a
    Python interpreter that you can use to run your own programs. If you have a Python
    interpreter installed on your computer (ask your teacher if you are following
    this book for a class and are confused) and know how to start it and run programs
    in it, you can use that.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行一个Python程序，我们需要一个叫做Python解释器的东西。Python解释器能够读取你的程序并处理它。下面是一个Python解释器，你可以用它来运行你自己的程序。如果你的电脑上已经安装了Python解释器（如果你在课堂上使用这本书并感到困惑，请向你的老师询问），并且知道如何启动它和运行程序，你可以使用它。
- en: Run
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 运行
- en: 'Output:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: Try changing the program so that it says your name instead of *Student*. When
    you think you have it right, try running the program again to see. Make sure you
    don’t remove the double quotes or the parentheses (round brackets) in the program
    by mistake. What happens if you spelt “programming” wrong? Does the computer correct
    it? If you are completely stuck, ask your teacher for help before going any further.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改程序，使其显示你的名字而不是*学生*。当你认为修改正确时，尝试再次运行程序查看结果。确保你不要误删程序中的双引号或括号（圆括号）。如果你拼错了“编程”会发生什么？计算机会自动纠正吗？如果你完全卡住了，在继续之前向你的老师寻求帮助。
- en: Hopefully you figured out how to make the program print your name. You can also
    change the asterisks (*) to other symbols. What happens if you do remove one of
    the double quotes or one of the parentheses? Try it!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经弄清楚如何让程序打印你的名字。你也可以将星号（*）改成其他符号。如果你删除一个双引号或一个括号会发生什么？试试看！
- en: 'If you change a critical symbol in the program you will probably find that
    the Python interpreter gives an error message. In the online Python interpreter
    linked to above, it says “ParseError: bad input on line 1”, although different
    interpreters will express the error in different ways. If you have trouble fixing
    the error again, just copy the program back into Python from above.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你改变了程序中的一个关键符号，你可能会发现Python解释器会给出一个错误消息。在上面链接的在线Python解释器中，它会显示“ParseError:
    bad input on line 1”，尽管不同的解释器会以不同的方式表达错误。如果你在修复错误时遇到困难，只需将程序从上面复制回Python中。'
- en: Programming languages can do much more than print out text though. The following
    program is able to print out multiples of a number. Try running the program.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言不仅可以打印文本。以下程序能够打印一个数字的倍数。尝试运行这个程序。
- en: '[PRE2]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first line is a print statement, like those you saw earlier, which just
    tells the system to put the message on the screen. The second line is a *loop*,
    which says to repeat the lines after it 5 times. Each time it loops, the value
    of i changes. i.e. the first time i is 0, then 1, then 2, then 3, and finally
    4\. It may seem weird that it goes from 0 to 4 rather than 1 to 5, but programmers
    tend to like counting from 0 as it makes some things work out a bit simpler. The
    third line says to print the current value of i multiplied by 3 (because we want
    multiples of 3). Note that there is *not* double quotes around the last print
    statement, as they are only used when we want to print out a something literally
    as text. If we did put them in, this program would print the text “i*3” out 5
    times instead of the value we want!
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是一个print语句，就像你之前看到的那样，它只是告诉系统将消息放在屏幕上。第二行是一个*循环*，它说要重复之后的行5次。每次循环，i 的值都会改变。即第一次
    i 是 0，然后是 1，然后是 2，然后是 3，最后是 4。它可能看起来很奇怪，它从 0 到 4 而不是从 1 到 5，但程序员倾向于从 0 开始计数，因为这样做使某些事情变得更简单一些。第三行表示要打印
    i 的当前值乘以 3（因为我们想要 3 的倍数）。请注意，最后一个打印语句周围*没有*双引号，因为它们仅在我们想要将某些内容文本文字打印出来时使用。如果我们把它们放进去，这个程序会打印出文本“i*3”而不是我们想要的值！
- en: Try make the following changes to the program.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试对程序进行以下更改。
- en: 'Make it print multiples of 5 instead of 3\. Hint: You need to change more than
    just the first line — you will need to make a change on the third line as well.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使其打印5的倍数而不是3的倍数。提示：你需要更改不止第一行 —— 你还需要在第三行进行更改。
- en: Make it print the first 10 multiples instead of the first 5\. Make sure it printed
    10 multiples, and not 9 or 11!
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使其打印前 10 个倍数而不是前 5 个。确保它打印了 10 个倍数，而不是 9 个或 11 个！
- en: You can also loop over a list of data. Try running the program below. It will
    generate a series of “spam” messages, one addressed to each person in the recipients
    list!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以循环遍历数据列表。尝试运行下面的程序。它将生成一系列“垃圾邮件”消息，每个消息都寄给收件人列表中的一个人！
- en: 'Note that the # symbol tells the computer that it should ignore the line, as
    it is a comment for the programmer.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，# 符号告诉计算机它应该忽略这一行，因为它是程序员的注释。
- en: '[PRE3]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Try changing the recipients or the letter. Look carefully at all the symbols
    that were used to include the recipient’s name in the letter.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改收件人或信件内容。仔细查看用于包含收件人姓名的所有符号。
- en: '**Jargon Buster**'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**行话解析**'
- en: The detailed requirements of a programming language about exactly which characters
    need to be used and where, is called its *syntax*. In the example above, the syntax
    for the list of names requires square brackets around the list, inverted commas
    around the names, and a comma between each one. If you make a mistake, such as
    leaving out one of the square brackets, the system will have a *syntax error*,
    and won’t be able to run the program. Every symbol counts, and one small error
    in a program can stop it running, or make it do the wrong thing.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言的详细要求，关于需要使用哪些字符以及在何处使用，称为其*语法*。在上面的示例中，名称列表的语法需要在列表周围使用方括号，在名称周围使用引号，并在每个名称之间使用逗号。如果出现错误，例如漏掉了一个方括号，系统将出现*语法错误*，并且无法运行程序。每个符号都很重要，在程序中的一个小错误可能会导致程序停止运行，或者使其执行错误的操作。
- en: Programs can also use *variables* to store the results of calculations in, receive
    user input, and make decisions (called *conditionals*, such as *if* statements).
    Try running this program. Enter a number of miles to convert when asked. Don’t
    put units on the number you enter; for example just put “12”.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 程序也可以使用*变量*来存储计算结果，接收用户输入，并做出决策（称为*条件语句*，如*if*语句）。尝试运行此程序。当被询问时输入要转换的英里数。不要在输入的数字上加单位；例如只输入“12”。
- en: '[PRE4]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first line is a *print* statement (which you should be very familiar with
    by now!) The second line asks the user for a number of miles which is converted
    from input text (called a string) to an integer, the third line uses an *if* statement
    to check if the number entered was less than 0, so that it can print an error
    if it is. Otherwise if the number was ok, the program jumps into the *else* section
    (the error is not printed because the *if* was not true), calculates the number
    of kilometers (there are 0.6214 kilometers in a mile), stores it into a *variable* called
    number_of_kilometers for later reference, and then the last line prints it out.
    Again, we don’t have quotes around number_of_kilometers in the last line as we
    want to print the value out that is stored in the number_of_kilometers variable.
    If this doesn’t make sense, don’t worry. You aren’t expected to know how to program
    for this chapter, this introduction is only intended for you to have some idea
    of what a program is and the things it can do.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是一个*print*语句（现在你应该对这个很熟悉！）第二行要求用户输入一个英里数，该数从输入文本（称为字符串）转换为整数，第三行使用一个*if*语句来检查输入的数字是否小于
    0，以便在小于 0 时打印错误。否则，如果数字没问题，程序就跳到*else*部分（因为*if*不为真，所以错误不会打印出来），计算出千米数（一英里等于 0.6214
    千米），将其存储在一个叫做 number_of_kilometers 的*变量*中以便以后使用，然后最后一行将其打印出来。同样，我们在最后一行没有引号围绕
    number_of_kilometers，因为我们想要打印出存储在 number_of_kilometers 变量中的值。如果这听起来不合理，别担心。在这一章中，你不需要知道如何编程，这个介绍只是为了让你对程序是什么以及它能做什么有一些想法。
- en: If you are keen, you could modify this program to calculate something else,
    such as pounds to kilograms or farenheit to celcius. It may be best to use an
    installed Python interpreter on your computer rather than the web version, as
    the web version can give very unhelpful error messages when your program has a
    mistake in it (although all interpreters give terrible error messages at least
    sometimes!)
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，你可以修改这个程序来计算其他东西，比如将磅转换为千克或将华氏度转换为摄氏度。最好使用安装在你电脑上的 Python 解释器，而不是网络版本，因为网络版本在程序出错时可能会给出非常不友好的错误消息（尽管所有的解释器至少有时都会给出糟糕的错误消息！）
- en: Programs can do many more things, such as having a graphical user interface
    (like most computer programs you will be familiar with), being able to print graphics
    onto a screen, or being able to write to and from files on the computer in order
    to save information between each time you run the program.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 程序还可以做许多其他事情，比如拥有图形用户界面（就像你熟悉的大多数计算机程序一样），能够将图形打印到屏幕上，或者能够在计算机上读写文件，以便在每次运行程序时保存信息。
- en: 4.1.2\. WHERE ARE WE GOING?
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2\. 我们要去哪里？
- en: When you ran the programs, it might have seemed quite magical that the computer
    was able to instantly give you the output. Behind the scenes however, the computer
    was running your example programs through another program in order to convert
    them into a form that it could make sense of and then run.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，可能会觉得电脑能够立即给你输出是非常神奇的。然而，在幕后，电脑正在通过另一个程序运行你的示例程序，以将它们转换为它能够理解并运行的形式。
- en: Firstly, you might be wondering why we need languages such as Python, and why
    we can’t give computers instructions in English. If we typed into the computer
    “Okay computer, print me the first 5 multiples of 3”, there’s no reason that it
    would be able to understand. For starters, it would not know what a “multiple”
    is. And it would not even know how to go about this task. Computers cannot be
    told what every word means, and they cannot know how to accomplish every possible
    task. Understanding human language is a very difficult task for a computer, as
    you will find out in the Artificial Intelligence chapter. Unlike humans who have
    an understanding of the world, and see meaning, computers are only able to follow
    the precise instructions you give them. Therefore, we need languages that are
    constrained and unambiguous that the computer “understands” instructions in. These
    can be used to give the computer instructions, like those in the previous section.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可能想知道为什么我们需要像Python这样的语言，以及为什么我们不能用英语给计算机发指令。如果我们在计算机上键入“好的计算机，打印给我前5个3的倍数”，它没有理由能够理解。首先，它不会知道“倍数”是什么意思。它甚至不知道如何执行这个任务。计算机不能被告知每个词的含义，它们也不能知道如何完成每个可能的任务。理解人类语言对计算机来说是一项非常困难的任务，你将在人工智能章节中发现这一点。与人类不同，人类对世界有一定的了解，并能够理解含义，计算机只能遵循您给出的精确指令。因此，我们需要的是一种受限且不含歧义的语言，使计算机“理解”指令。这些指令可以用来给计算机发出指令，就像前一节中的那些指令一样。
- en: It isn’t this simple though, a computer cannot run instructions given directly
    in these languages. At the lowest level, a computer has to use physical hardware
    to run the instructions. Arithmetic such as addition, subtraction, multiplication,
    and division, or simple comparisons such as less than, greater than, or equal
    to are done on numbers represented in binary by putting electricity through physical
    computer chips containing transistors. The output is also a number represented
    in binary. Building a fast and cheap circuit to do simple arithmetic such as this
    isn’t that hard, but the kind of instructions that people want to give computers
    (like “print the following sentence”, or “repeat the following 100 times”) are
    much harder to build circuitry for.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 但事情并不是这么简单的，计算机不能直接运行以这些语言直接给出的指令。在最低层次上，计算机必须使用物理硬件来运行指令。诸如加法、减法、乘法和除法之类的算术运算，或者简单的比较，如小于、大于或等于，是通过将电流通过包含晶体管的物理计算机芯片上的数字来完成的。输出也是用二进制表示的数字。构建一个快速且廉价的电路来执行这样的简单算术并不难，但是人们想要给计算机的那种指令（比如“打印以下句子”或“重复以下操作100次”）要难得多，为此构建电路。
- en: '**Jargon Buster**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**术语解释**'
- en: The electronics in computers uses circuitry that mainly just works with two
    values (represented as high and low voltages) to make it reliable and fast. This
    system is called *binary*, and is often written on paper using zeroes and ones.
    There’s a lot more about binary in the [*Data representation*](http://csfieldguide.org.nz/DataRepresentation.html#data-representation) chapter,
    and it’s worth having a quick look at the first section of that now if you haven’t
    come across binary before.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机中的电子学使用电路，主要只使用两个值（表示为高电压和低电压）来使其可靠且快速。这种系统称为*二进制*，通常使用零和一在纸上书写。有关二进制的更多信息，请参阅[*数据表示*](http://csfieldguide.org.nz/DataRepresentation.html#data-representation)章节，并且如果你之前没有接触过二进制，现在最好快速查看一下该章节的第一部分。
- en: So instead of building computers that can understand these high level instructions
    that you find in languages like Python (or Java, Basic, JavaScript, C and so on),
    we build computers that can follow a very limited set of instructions, and then
    we write programs that convert the instructions in the standard languages people
    write programs in into the simple instructions that the circuitry can directly
    carry out. The language of these simple instructions is a low level programming
    language often referred to as machine code.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不是构建能够理解像Python（或Java、Basic、JavaScript、C等）这样的高级指令的计算机，而是构建能够执行一组非常有限的指令的计算机，然后编写程序，将人们编写程序时使用的标准语言中的指令转换为电路可以直接执行的简单指令。这些简单指令的语言通常称为机器语言，是一种低级编程语言。
- en: The conversion from a high level to a low level language can involve *compiling*,
    which replaces the high level instructions with machine code instructions that
    can then be run, or it can be done by *interpreting*, where each instruction is
    converted and followed one by one, as the program is run. In reality, a lot of
    languages use a mixture of these, sometimes compiling a program to an intermediate
    language, then interpreting it (Java does this). The language we looked at earlier,
    Python, is an interpreted language. Other languages such as C++ are compiled.
    We will talk more about compiling and interpreting later.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 从高级语言到低级语言的转换可能涉及到*编译*，它将高级指令替换为可以运行的机器码指令，或者可以通过*解释*来完成，其中每个指令被转换并按顺序执行，因为程序正在运行。实际上，很多语言都是这两种方式的混合，有时将程序编译成中间语言，然后解释它（Java就是这样做的）。我们之前看过的语言Python是一种解释性语言。其他语言如C++是编译的。我们稍后会更多地讨论编译和解释。
- en: We will start with looking at some other programming languages that programmers
    use to give instructions to computers, then we will look at low level languages
    and how computers actually carry out the instructions in them, and then finally
    we will talk about how we convert programs that were written by humans in a high
    level language into a low level language that the computer can carry out.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看一些程序员用来向计算机发出指令的其他编程语言，然后我们将看一看低级语言以及计算机如何实际执行其中的指令，最后我们将讨论如何将由人类用高级语言编写的程序转换为计算机可以执行的低级语言。
- en: 4.2\. MACHINE CODE (LOW LEVEL LANGUAGES)
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2\. 机器码（低级语言）
- en: A computer has to carry out instructions on physical circuits. These circuits
    contain transistors laid out in a special way that will give a correct output
    based on the inputs.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机必须在物理电路上执行指令。这些电路包含以特殊方式布置的晶体管，根据输入给出正确的输出。
- en: Data such as numbers (represented using binary) have to be put into storage
    places called registers while the circuit is processing them. Registers can be
    set to values, or data from memory can be put into registers. Once in registers,
    they can be added, subtracted, multiplied, divided, or be checked for equality,
    greater than, or less than. The output is put into a register, where it can either
    be retrieved or used in further arithmetic.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 数据，如数字（使用二进制表示），必须被放入称为寄存器的存储位置中，而电路正在处理它们。可以将寄存器设置为值，或者将来自内存的数据放入寄存器中。一旦在寄存器中，它们可以被相加、相减、相乘、相除，或者被检查是否相等、大于或小于。输出被放入一个寄存器中，可以从中检索或在进一步的算术中使用。
- en: All computers have a machine code language (commonly referred to as an instruction
    set) that is used to tell the computer to put values into registers, to carry
    out arithmetic with the values in certain registers and put the result into another
    specified register like what we talked about above. Machine code also contains
    instructions for loading and saving values from memory (into or out of registers),
    jumping to a certain line in the program (that is either before or after the current
    line), or to jump to the line only if a certain condition is met (by doing a specified
    comparisons on values in registers). There are also instructions for handling
    simple input/ output, and interacting with other hardware on the computer.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的计算机都有一种机器码语言（通常称为指令集），用于告诉计算机将值放入寄存器中，在某些寄存器中的值进行算术运算并将结果放入另一个指定的寄存器中，就像我们上面讨论的那样。机器码还包含从内存中加载和保存值的指令（进入或退出寄存器），跳转到程序中的某一行（在当前行之前或之后），或者仅在满足某些条件时跳转到该行（通过对寄存器中的值进行指定的比较）。还有一些用于处理简单输入/输出以及与计算机上的其他硬件交互的指令。
- en: The instructions are quite different to the ones you will have seen before in
    high level languages. For example, the following program is written in a machine
    language called MIPS; which is used on some embedded computer systems. We will
    use MIPS in examples throughout this chapter.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 指令与你之前在高级语言中见过的指令非常不同。例如，下面的程序是用一种叫做MIPS的机器语言编写的；在一些嵌入式计算机系统上使用。我们将在本章的示例中使用MIPS。
- en: It starts by adding 2 numbers (that have been put in registers $t0 and $t1)
    and printing out the result. It then prints “Hello World!” Don’t worry, we aren’t
    about to make you learn how to actually program in this language! And if you don’t
    really understand the program, that’s also fine because many software engineers
    wouldn’t either! (We are showing it to you to help you to appreciate high level
    languages!)
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先将两个数字相加（这些数字已经放在寄存器$t0和$t1中），然后打印出结果。然后它打印“Hello World！”别担心，我们不打算让你真正学习如何使用这种语言编程！如果你不太理解这个程序，也没关系，因为很多软件工程师也不会理解！（我们向你展示这个程序是为了帮助你欣赏高级语言！）
- en: '[PRE5]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can run this program using an online MIPS emulator. This needs to be done
    in 2 steps:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用在线MIPS模拟器来运行此程序。这需要分两步进行：
- en: '[Copy paste the code into the black box on the page from this link](http://alanhogan.com/asu/assembler.php) (remove
    ALL existing text in the box), and then click the Assemble button.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将代码复制粘贴到此链接页面上的黑色框中](http://alanhogan.com/asu/assembler.php)（删除框中所有现有文本），然后点击“Assemble”按钮。'
- en: '[Copy paste the output in the “Assembler Output” box into the box on the page
    from this link](http://alanhogan.com/asu/simulator.php) (remove ALL existing text
    in the box), and click the Simulate Execution button, and the output should appear
    in a box near the top of the page'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将“Assembler Output”框中的输出复制粘贴到此链接页面上的框中](http://alanhogan.com/asu/simulator.php)（删除框中所有现有文本），然后点击“Simulate
    Execution”按钮，输出应该会出现在页面顶部附近的一个框中。'
- en: 'Once you have got the program working, try changing the values that are added.
    The comments tell you where these numbers that can be changed are. You should
    also be able to change the string (text) that is printed without too much trouble
    also. As a challenge, can you make it so that it subtracts rather than adds the
    numbers? Clue: instruction names are always very short. Unfortunately you won’t
    be able to make it multiply or divide using this emulator as this seems to not
    currently be supported. Remember that to rerun the program after changing it,
    you will have to follow both steps 1 and 2 again.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序运行起来后，尝试改变被添加的数值。注释告诉你可以改变这些数字的位置。你也应该可以轻松地改变所打印的字符串（文本）。作为挑战，你能使它减去而不是加上这些数字吗？提示：指令名称通常非常简短。不幸的是，你不能使用这个模拟器来进行乘法或除法运算，因为目前似乎不支持这些操作。记住，在修改程序后重新运行程序，你需要重新执行步骤1和2。
- en: You may be wondering why you have to carry out both these steps. Because computers
    work in 1’s and 0’s, the instructions need to simply be converted into hexadecimal.
    Hexadecimal is a shorthand notation for binary numbers. *Don’t muddle this process
    with compiling or interpreting!* Unlike these, it is much simpler as in general
    each instruction from the source code ends up being one line in the hexadecimal.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么必须执行这两个步骤。因为计算机以1和0的形式工作，指令需要简单地转换为十六进制。十六进制是二进制数的简写。*不要将此过程与编译或解释混淆！*与这些过程不同，它要简单得多，因为通常源代码中的每个指令最终都成为十六进制中的一行。
- en: One thing you might have noticed while reading over the possible instructions
    is that there is no loop instruction in MIPS. Using several instructions though,
    it actually is possible to write a loop using this simple language. Have another
    read of the paragraph that describes the various instructions in MIPS. Do you
    have any ideas on how to solve this problem? It requires being quite creative!
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读可能的指令时，你可能注意到MIPS中没有循环指令。然而，使用几个指令，实际上可以使用这种简单的语言编写循环。再次阅读描述MIPS各种指令的段落。你有没有想法来解决这个问题？这需要相当有创造力！
- en: The jumping to a line, and jumping to a line if a condition is met can be used
    to make loops! A very simple program we could write that requires a loop is one
    that counts down from five and then says “Go!!!!” once it gets down to one. In
    Python we can easily write this program in three lines.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转到一行，以及如果满足条件就跳转到一行，可以用来创建循环！我们可以编写一个非常简单的程序，需要一个循环，该程序从五倒数到一，然后在倒数到一时说“Go!!!!”。在Python中，我们可以用三行代码轻松编写这个程序。
- en: '[PRE6]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But in MIPS, it isn’t that straight forward. We need to put values into registers,
    and we need to build the loop out of jump statements. Firstly, how can we design
    the loop?
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在MIPS中，情况并不那么简单。我们需要将值放入寄存器，并且需要使用跳转语句构建循环。首先，我们如何设计循环？
- en: And the full MIPS program for this is as follows. You can go away and change
    it.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这个完整的MIPS程序如下所示。你可以离开并进行修改。
- en: '[PRE7]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Can you change the Python program so that it counts down from 10? What about
    so it stops at 5? (You might have to try a couple of times, as it is somewhat
    counter intuitive. Remember that when i is the stopping number, it stops there
    and does not run the loop for that value!). And what about decrementing by 2 instead
    of 1? And changing the string (text) that is printed at the end?
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 你能修改 Python 程序让它从 10 倒数吗？然后在 5 停下来呢？（你可能需要尝试几次，因为这有点违反直觉。请记住，当 i 是停止数时，它会停在那里并且不运行该值的循环！）那么减少
    2 而不是 1 呢？还有改变末尾打印的字符串（文本）呢？
- en: You probably found the Python program not too difficult to modify. See if you
    can make these same changes to the MIPS program.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能觉得修改 Python 程序并不太困难。看看你能否对 MIPS 程序进行相同的更改。
- en: If that was too easy for you, can you make both programs print out “GO!!!!”
    twice instead of once? (you don’t have to use a loop for that). And if THAT was
    too easy, what about making each program print out “GO!!!!” 10 times? Because
    repeating a line in a program 10 times without a loop would be terrible programming
    practice, you’d need to use a loop for this task.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对你来说太容易了，你能让这两个程序都打印出“GO!!!!”两次而不是一次吗？（你不必使用循环来做到这一点）。如果那也太容易了，那么让每个程序都打印出“GO!!!!”10次呢？因为在程序中重复一行10次而不使用循环会是糟糕的编程实践，你需要使用循环来完成这个任务。
- en: More than likely, you’re rather confused at this point and unable to modify
    the MIPS program with all these suggested changes. And if you do have an additional
    loop in your MIPS program correctly printing “GO!!!” 10 times, then you are well
    on your way to being a good programmer!
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，你现在感到非常困惑，无法使用所有这些建议修改 MIPS 程序。如果你的 MIPS 程序中有一个额外的循环正确地打印出“GO!!!”10次，那么你就是一名优秀的程序员了！
- en: So, what was the point of all this? These low level instructions may seem tedious
    and a bit silly, but the computer is able to directly run them on hardware due
    to their simplicity. A programmer can write a program in this language if they
    know the language, and the computer would be able to run it directly without doing
    any further processing. As you have probably realised though, it is extremely
    time consuming to have to program in this way. Moving stuff in and out of registers,
    implementing loops using jump and branch statements, and printing strings and
    integers using a three line pattern that you’d probably never have guessed was
    for printing had we not told you leaves even more opportunities for bugs in the
    program. Not to mention, the resulting programs are extremely difficult to read
    and understand.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这一切的目的是什么呢？这些低级指令可能看起来很乏味，有点傻，但由于它们的简单性，计算机能够直接在硬件上运行它们。如果程序员知道这种语言，他们就可以用这种语言编写程序，计算机将能够直接运行它而不需要进行任何进一步的处理。但正如你可能意识到的，以这种方式编程是非常耗时的。在寄存器中移动数据，使用跳转和分支语句实现循环，并使用一个你可能从未想过用于打印的三行模式打印字符串和整数，即使我们没有告诉你，也会为程序中的错误留下更多的机会。更不用说，由此产生的程序极其难以阅读和理解。
- en: Because computers cannot directly run the instructions in the languages that
    programmers like, high level programming languages by themselves are not enough.
    The solution to this problem of different needs is to use a compiler or interpreter
    that is able to convert a program in the high level programming language that
    the programmer used into the machine code that the computer is able to understand.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 因为计算机不能直接运行程序员喜欢的语言中的指令，仅靠高级编程语言是不够的。解决这个不同需求的问题的方法是使用一个编译器或解释器，它能够将程序员使用的高级编程语言编写的程序转换为计算机能够理解的机器码。
- en: These days, few programmers program directly in these languages. In the early
    days of computers, programs written directly in machine language tended to be
    faster than those compiled from high level languages. This was because compilers
    weren’t very good at minimising the number of machine language instructions, referred
    to as *optimizing*, and people trained to write in machine code were better at
    it. These days however, compilers have been made a lot smarter, and can optimize
    code far better than most people can. Writing a program directly in machine code
    may result in a program that is *less* optimized than one that was compiled from
    a high level language. Don’t put in your report that low level languages are faster!
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，很少有程序员直接使用这些语言进行编程。在计算机早期，直接用机器语言编写的程序往往比从高级语言编译的程序运行得更快。这是因为编译器在最小化机器语言指令数量方面表现不佳，被称为*优化*，而且熟悉机器码编写的人更擅长。然而，如今编译器变得更加智能，可以比大多数人更好地优化代码。直接用机器码编写程序可能导致比从高级语言编译的程序*更*不优化。不要在你的报告中写低级语言更快！
- en: This isn’t the full story; the MIPS machine code described here is something
    called a Reduced Instruction Set Architecture (RISC). Many computers these days
    use a Complex Instruction Set Architecture (CISC). This means that the computer
    chips can be a little more clever and can do more in a single step. This is well
    beyond the scope of this book though, and understanding the kinds of things RISC
    machine code can do, and the differences between MIPS and high level languages
    is fine at this level, and fine for most computer scientists and software engineers.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是全部；这里描述的MIPS机器码是一种称为精简指令集体系结构（RISC）的东西。如今许多计算机使用的是复杂指令集体系结构（CISC）。这意味着计算机芯片可以更聪明一些，可以在一步中完成更多工作。然而，这远远超出了本书的范围，了解RISC机器码可以做的事情以及MIPS与高级语言之间的区别对于大多数计算机科学家和软件工程师来说已经足够了。
- en: In summary, we require low level programming languages because the computer
    can understand them, and we require high level programming languages because humans
    can understand them. A later section talks more about compilers and interpreters;
    programs that are used to convert a program that is written in a high level language
    (for humans) into a low level language (for computers).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们需要低级编程语言，因为计算机能够理解它们，而我们需要高级编程语言，因为人类能够理解它们。后面的部分将更多地讨论编译器和解释器；这些程序用于将用高级语言（针对人类）编写的程序转换为低级语言（针对计算机）。
- en: 4.3\. A BABEL OF PROGRAMMING LANGUAGES
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3\. **程序设计语言的多样性**
- en: There are many different programming languages. Here we have included a small
    subset of languages, to illustrate the range of purposes that languages are used
    for. There are many, many more languages that are used for various purposes, and
    have a strong following of people who find them particularly useful for their
    applications.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多不同的程序设计语言。在这里，我们包含了一小部分语言，以展示语言被用于的各种目的。还有许多，许多其他语言被用于各种目的，并有一大批人群积极使用它们来满足他们的应用需求。
- en: For a much larger list you can [check Wikipedia here](http://en.wikipedia.org/wiki/List_of_programming_languages).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更大的列表，你可以[在这里查看维基百科](http://en.wikipedia.org/wiki/List_of_programming_languages)。
- en: 4.3.1\. PYTHON
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1\. **Python语言**
- en: Python is a widely used language, that has also become very popular as a teaching
    language. Many people learn Python as their first programming language. In the
    introduction, we looked at some examples of Python programs, for those who have
    never programmed before.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种广泛使用的语言，也因其成为教学语言而变得非常流行。许多人将Python作为他们的第一种编程语言进行学习。在介绍中，我们看了一些Python程序的示例，供那些之前从未编程过的人参考。
- en: Originally though, Python was intended to be a scripting language. Scripting
    languages have syntax that makes them quick to write programs for file processing
    in, and for doing repetitive tasks on a computer.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最初Python是用作脚本语言的。脚本语言具有使其快速编写文件处理程序和在计算机上执行重复任务的语法。
- en: As an example of a situation where Python is very useful, imagine your teacher
    has given 5 quizzes throughout the year, and recorded the results for each student
    in a file such as this (It could include more than 6 students), where each student’s
    name is followed by their scores. Some students didn’t bother going to class for
    all the quizzes, so have less than 5 results recorded.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Python非常有用的一个例子，想象一下你的老师在一年中给出了5个测验，并记录了每个学生的结果，格式如下（它可能包括超过6个学生），其中每个学生的姓名后面跟着他们的分数。一些学生并没有参加所有的测验，所以记录的结果少于5个。
- en: '[PRE8]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: She realises she needs to know the average (assuming 5 quizzes) that each student
    scored, and with many other things to do does not want to spend much time on this
    task. Using python, she can very quickly generate the data she needs in less than
    10 lines of code.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 她意识到她需要知道每个学生的平均分（假设5个测验），而且由于有很多其他事情要做，她不想在这个任务上花费太多时间。使用Python，她可以在不到10行的代码中非常快速地生成她需要的数据。
- en: Note that understanding the details of this code is irrelevant to this chapter,
    particularly if you aren’t yet a programmer. Just read the comments (the things
    that start with a “#”) if you don’t understand, so that you can get a vague idea
    of how the problem was approached.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，理解这段代码的细节与本章无关，特别是如果你还不是程序员的话。如果你不明白，请阅读注释（以“＃”开头的内容），以便大致了解问题是如何解决的。
- en: '[PRE9]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will generate a file that contains each student’s name followed by the
    result of adding their scores and dividing the sum by 5\. You can try the code
    if you have python installed on your computer (it won’t work on the online interpreter,
    because it needs access to a file system). Just put the raw data into a file called
    “scores.txt” in the same format it was displayed above. As long as it is in the
    same directory as the source code file you make for the code, it will work.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个文件，其中包含每个学生的姓名，后面是将他们的分数相加并除以5的结果。如果你的计算机安装了Python，你可以尝试运行这段代码（它在在线解释器上不起作用，因为它需要访问文件系统）。只需将原始数据放入一个名为“scores.txt”的文件中，格式与上面显示的相同。只要它与你为代码制作的源代码文件在同一个目录中，它就会起作用。
- en: This problem could of course be solved in any language, but some languages make
    it far simpler than others. Standard software engineering languages such as Java,
    which we talk about shortly, do not offer such straight forward file processing.
    Java requires the programmer to specify what to do if opening the file fails in
    order to prevent the program from crashing. Python does not require the programmer
    to do this, although does have the option to handle file opening failing should
    the programmer wish to. Both these approaches have advantages in different situations.
    For the teacher writing a quick script to process the quiz results, it does not
    matter if the program crashes so it is ideal to not waste time writing code to
    deal with it. For a large software system that many people use, crashes are inconvenient
    and a security risk. Forcing all programmers working on that system to handle
    this potential crash correctly could prevent a lot of trouble later on, which
    is where Java’s approach helps.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题当然可以用任何语言解决，但有些语言比其他语言简单得多。标准的软件工程语言，比如我们稍后会谈到的Java，不提供这样直接的文件处理。Java要求程序员指定如果打开文件失败要做什么，以防止程序崩溃。Python不需要程序员这样做，尽管程序员可以选择处理文件打开失败的情况。这两种方法在不同的情况下都有优势。对于写一个快速处理测验结果的脚本的教师来说，如果程序崩溃无所谓，所以最好不要浪费时间编写代码来处理它。对于许多人使用的大型软件系统，崩溃是不方便的，也是安全隐患。强制所有在该系统上工作的程序员正确处理这种潜在的崩溃可能会在以后防止很多麻烦，这就是Java的方法有所帮助的地方。
- en: In addition to straight forward file handling, Python did not require the code
    to be put inside a class or function, and it provided some very useful built in
    functions for solving the problem. For example, the function that found the sum
    of the list, and the line of code that was able to convert the raw line of text
    into a list of numbers (using a very commonly used pattern).
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直接的文件处理之外，Python不需要将代码放在类或函数内部，并且提供了一些非常有用的内置函数来解决问题。例如，找到列表总和的函数，以及能够将原始文本行转换为数字列表的代码行（使用了非常常用的模式）。
- en: This same program written in Java would require at least twice as many lines
    of code.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用Java写的同样的程序将需要至少两倍的代码行数。
- en: There are many other scripting languages in addition to Python, such as Perl,
    Bash, and Ruby.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Python之外，还有许多其他的脚本语言，例如Perl、Bash和Ruby。
- en: 4.3.2\. SCRATCH
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2\. SCRATCH
- en: Scratch is a programming language used to teach people how to program. A drag
    and drop interface is used so that new programmers don’t have to worry so much
    about syntax, and programs written in Scratch are centered around controlling
    cartoon characters or other sprites on the screen.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: Scratch 是一种用于教人如何编程的编程语言。使用拖放界面，这样新程序员就不必过多担心语法，而 Scratch 中的程序主要围绕着控制屏幕上的卡通角色或其他精灵展开。
- en: Scratch is never used in programming in industry, only in teaching. If you are
    interested in trying Scratch, [you can try it out online here](http://scratch.mit.edu/projects/editor/?tip_bar=getStarted),
    no need to download or install anything.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: Scratch 在工业界从不用于编程，只用于教学。如果你有兴趣尝试 Scratch，[你可以在这里在线尝试](http://scratch.mit.edu/projects/editor/?tip_bar=getStarted)，无需下载或安装任何东西。
- en: '[![](563ad2b9ebc86.png)](http://scratch.mit.edu/projects/19711355/#editor)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad2b9ebc86.png)](http://scratch.mit.edu/projects/19711355/#editor)'
- en: Click the image above to load the project and try it for yourself.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 单击上面的图片加载项目并自行尝试。
- en: This is an example of a simple program in Scratch that is similar to the programs
    we have above for Python and Java. It asks the user for numbers until they say
    “stop” and then finds the average of the numbers given.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在 Scratch 中的简单程序示例，类似于我们上面介绍的 Python 和 Java 程序。它询问用户直到他们说“停止”，然后找出给定数字的平均值。
- en: '![](563ad2b8ec441.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad2b8ec441.png)'
- en: 'And this is the output that will be displayed when the green flag is clicked:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击绿旗时将显示的输出如下：
- en: '![](563ad2b86b2d4.png)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad2b86b2d4.png)'
- en: Scratch can be used for simple calculations, creating games and animations.
    However it doesn’t have all the capabilities of other languages.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: Scratch 可以用于简单的计算、创建游戏和动画。但它并没有其他语言的所有功能。
- en: Other educational languages include Alice and Logo. Alice also uses drag and
    drop, but in a 3D environment. Logo is a very old general purpose language based
    on Lisp. It is not used much anymore, but it was famous for having a turtle with
    a pen that could draw on the screen, much like Scratch. The design of Scratch
    was partially influenced by Logo. These languages are not used beyond educational
    purposes, as they are slow and inefficient.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 其他教育性语言包括 Alice 和 Logo。Alice 也使用拖放功能，但是在 3D 环境中。Logo 是一种非常古老的基于 Lisp 的通用语言。它现在用得不多了，但是它因为有一个能在屏幕上画画的海龟而出名，很像
    Scratch。Scratch 的设计部分受到 Logo 的影响。这些语言不会用于除教育目的以外的用途，因为它们速度慢且效率低下。
- en: 4.3.3\. JAVA
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3\. JAVA
- en: Java is a popular general purpose software engineering language. It is used
    to build large software systems involving possibly hundreds or even thousands
    of software engineers. Unlike Python, it forces programmers to say how certain
    errors should be handled, and it forces them to state what type of data their
    variables are intended to hold, e.g. *int* (i.e. a number with no decimal places),
    or *String* (some text data). Python does not require types to be stated like
    this. All these features help to reduce the number of bugs in the code. Additionally,
    they can make it easier for other programmers to read the code, as they can easily
    see what type each variable is intended to hold (figuring this out in a python
    program written by somebody else can be challenging at times, making it very difficult
    to modify their code without breaking it!)
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: Java 是一种流行的通用软件工程语言。它用于构建涉及可能有数百甚至数千名软件工程师的大型软件系统。与 Python 不同，它强制程序员说明应如何处理某些错误，并强制他们声明变量的数据类型，例如
    *int*（即没有小数点的数字）或 *String*（一些文本数据）。Python 不要求像这样声明类型。所有这些功能有助于减少代码中的错误数量。此外，它们可以使其他程序员更容易阅读代码，因为他们可以轻松地看到每个变量的类型意图（在
    Python 程序中找出这一点有时可能具有挑战性，这使得很难在不破坏其代码的情况下修改别人的代码！）
- en: This is the Java code for solving the same problem that we looked at in Python;
    generating a file of averages.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用 Java 解决我们在 Python 中看到的同一个问题的代码；生成一个平均数文件。
- en: '[PRE10]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While the code is longer, it ensures that the program doesn’t crash if something
    goes wrong. It says to *try* opening and reading the file, and if an error occurs,
    then it should *catch* that error and print out an error message to tell the user.
    The alternative (such as in Python) would be to just crash the program, preventing
    anything else from being able to run it. Regardless of whether or not an error
    occurs, the “I am finished!” line will be printed, because the error was safely
    “caught”. Python is able to do error handling like this, but it is up to the programmer
    to do it. Java will not even compile the code if this wasn’t done! This prevents
    programmers from forgetting or just being lazy.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码更长，但它确保程序在出现问题时不会崩溃。它告诉你*尝试*打开和读取文件，如果发生错误，那么它应该*捕获*该错误并打印出错误消息来告诉用户。另一种方法（比如在Python中）是直接崩溃程序，阻止其他任何东西能够运行它。无论是否发生错误，“我完成了！”这一行都会被打印出来，因为错误被安全地“捕获”了。Python能够像这样处理错误，但这取决于程序员是否这样做。如果没有这样做，Java甚至不会编译代码！这可以防止程序员忘记或者只是懒惰。
- en: There are many other general software engineering languages, such as C# and
    C++. Python is sometimes used for making large software systems, although is generally
    not considered an ideal language for this role.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的通用软件工程语言，比如C#和C++。Python有时用于制作大型软件系统，尽管通常不被认为是这种角色的理想语言。
- en: 4.3.4\. JAVASCRIPT
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.4\. JAVASCRIPT
- en: Interpreted in a web browser
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Web浏览器中解释
- en: 'Similar language: Actionscript (Flash)'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似语言：Actionscript（Flash）
- en: Note that this section will be completed in a future version of the field guide.
    For now, you should refer to wikipedia page for more information.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本节将在未来版本的领域指南中完成。目前，您应该参考维基百科页面以获取更多信息。
- en: 4.3.5\. C
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.5\. C
- en: Low level language with the syntax of a high level language
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有高级语言语法的低级语言
- en: Used commonly for programming operating systems, and embedded systems
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常用于编程操作系统和嵌入式系统
- en: Programs written in C tend to be very fast (because it is designed in a way
    that makes it easy to compile it optimally into machine code)
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用C编写的程序往往非常快（因为它设计得可以轻松将其编译为机器码）
- en: Bug prone due to the low level details. Best not used in situations where it
    is unnecessary
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于低级细节，容易出错。最好不在不必要的情况下使用
- en: 'Related languages: C++ (somewhat)'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关语言：C++（有些）
- en: Note that this section will be completed in a future version of the field guide.
    For now, you should refer to wikipedia page for more information.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本节将在未来版本的领域指南中完成。目前，您应该参考维基百科页面以获取更多信息。
- en: 4.3.6\. MATLAB
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.6\. MATLAB
- en: Used for writing programs that involve advanced math (calculus, linear algebra,
    etc.)
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于编写涉及高级数学（微积分，线性代数等）的程序
- en: Not freely available
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不免费提供
- en: 'Related languages: Mathematica, Maple'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关语言：Mathematica，Maple
- en: Note that this section will be completed in a future version of the field guide.
    For now, you should refer to wikipedia page for more information.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本节将在未来版本的领域指南中完成。目前，您应该参考维基百科页面以获取更多信息。
- en: 4.3.7\. ESOTERIC PROGRAMMING LANGUAGES
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.7\. 奇异编程语言
- en: Anybody can make their own programming language. Doing so involves coming up
    with a syntax for your language, and writing a parser and compiler or interpreter
    so that programs in your language can be run. Most programming languages that
    people have made never become widely used.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人都可以制作自己的编程语言。这样做涉及到为您的语言设计一种语法，并编写解析器和编译器或解释器，以便能够运行您语言中的程序。大多数人制作的编程语言从未被广泛使用。
- en: In addition to programming languages that have practical uses, people have made
    many programming languages that were intended to be nothing more than jokes, or
    to test the limits of how obscure a programming language can be. Some of them
    make the low level machine languages you saw earlier seem rather logical! Wikipedia
    has a list of such languages. [http://en.wikipedia.org/wiki/Esoteric_programming_language](http://en.wikipedia.org/wiki/Esoteric_programming_language)
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 除了有实际用途的编程语言之外，人们还制作了许多编程语言，这些语言旨在不仅仅是玩笑，或者测试编程语言可以有多么晦涩。其中一些使您早些时候看到的低级机器语言似乎相当合乎逻辑！维基百科上有一份这样的语言列表。[http://en.wikipedia.org/wiki/Esoteric_programming_language](http://en.wikipedia.org/wiki/Esoteric_programming_language)
- en: You could even make your own programming language if you wanted to!
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以制作自己的编程语言！
- en: 4.4\. HOW DOES THE COMPUTER PROCESS YOUR PROGRAM?
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4\. 计算机如何处理您的程序？
- en: A programming language such as Python or Java is implemented using a program
    itself — the thing that takes your Python program and runs it is a program that
    someone has written!
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如 Python 或 Java 这样的编程语言是使用程序本身实现的 —— 将你的 Python 程序运行起来的程序是其他人编写的程序！
- en: 'Since the computer hardware can only run programs in a low level language (machine
    code), the programming system has to make it possible for your Python instructions
    to be executed using only machine language. There are two broad ways to do this:
    interpreting and compiling.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算机硬件只能运行低级语言（机器码）的程序，因此编程系统必须使你的 Python 指令能够仅使用机器语言执行。有两种主要方法可以做到这一点：解释和编译。
- en: '[This 1983 video](http://www.youtube.com/watch?v=_C5AHaS1mOA) provides a good
    analogy of the difference between an interpreter and a compiler.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '[这段 1983 年的视频](http://www.youtube.com/watch?v=_C5AHaS1mOA) 提供了解释器和编译器之间差异的很好类比。'
- en: The main difference is that a compiler is a program that converts your program
    to machine language, which is then run on the computer. An interpreter is a program
    that reads your program line by line, works out what those instructions are, and
    does them immediately.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于编译器是将你的程序转换为机器语言的程序，然后在计算机上运行该程序。解释器是一个逐行读取你的程序，弄清楚那些指令是什么，并立即执行它们的程序。
- en: There are advantages to both approaches, and each one suits some languages better
    than others. In reality, most modern languages use a mixture of compiling and
    interpreting. For example, most Java programs are *compiled* to an “intermediate
    language” called ByteCode, which is closer to machine code than Java. The ByteCode
    is then executed by an interpreter.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都有其优点，每种方法都更适合某些语言。实际上，大多数现代语言使用编译和解释的混合。例如，大多数 Java 程序都被编译成一种称为 ByteCode
    的“中间语言”，它比 Java 更接近机器码。然后解释器执行这个 ByteCode。
- en: If your program is to be distributed for widespread use, you will usually want
    it to be in machine code because it will run faster, the user doesn’t have to
    have an interpreter for your particular language installed, and when someone downloads
    the machine code, they aren’t getting a copy of your original high-level program.
    Languages where this happens include C#, Objective C (used for programming iOS
    devices), Java, and C.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序需要被广泛使用，通常你会希望它是机器码，因为这样它会运行得更快，用户不必安装你特定语言的解释器，当有人下载机器码时，他们并不会得到你原始高级程序的副本。这种情况发生在包括
    C#、Objective C（用于编程 iOS 设备）、Java 和 C 的语言中。
- en: Interpreted programs have the advantage that they can be easier to program because
    you can test them quickly, trace what is happening in them more easily, and even
    sometimes type in single instructions to see what they do, without having to go
    through the whole compilation process. For this reason they are widely used for
    introductory languages (for example, Scratch and Alice are interpreted), and also
    for simple programs such as scripts that perform simple tasks, as they can be
    written and tested quickly (for example, languages like PHP, Ruby and Python are
    used in these situations).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 解释型程序的优势在于编程更容易，因为你可以快速测试它们，更容易追踪它们中发生的情况，甚至有时可以输入单个指令来查看它们的作用，而无需经过整个编译过程。因此，它们被广泛用于入门语言（例如，Scratch
    和 Alice 是解释型的），也用于执行简单任务的脚本等简单程序，因为它们可以快速编写和测试（例如，PHP、Ruby 和 Python 这些语言在这些情况下使用）。
- en: The diagram below shows the difference between what happens in an interpreter
    and compiler if you write and run a program that sorts some numbers. The compiler
    produces a machine code program that will do the sorting, and the data is fed
    into that second program to get the sorted result. The interpreter simply does
    the sorting on the input by immediately following the instructions in the program.
    The compiler produces a machine code program that you can distribute, but it involves
    an extra phase in the process.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了如果你编写并运行一个排序一些数字的程序，解释器和编译器之间发生的事情的区别。编译器生成一个将进行排序的机器码程序，并将数据输入到第二个程序中以获得排序结果。解释器只是通过立即遵循程序中的指令对输入进行排序。编译器生成一个可以分发的机器码程序，但这涉及到进程中的一个额外阶段。
- en: '![](563ad2b7d4ba1.png)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad2b7d4ba1.png)'
- en: 4.5\. THE WHOLE STORY!
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5\. 故事的全部内容！
- en: There are many different programming languages, and new ones are always being
    invented. Each new language will need a new compiler and/or interpreter to be
    developed to support it. Fortunately there are good tools to help do this quickly,
    and some of these ideas will come up in the *Formal Languages* chapter, where
    things like regular expressions and grammars can be used to describe a language,
    and a compiler can be built automatically from the description.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的编程语言，新的语言也在不断被发明。每种新语言都需要开发一个新的编译器和/或解释器来支持它。幸运的是，有很好的工具可以帮助快速完成这项工作，其中一些想法将在*形式语言*章节中提到，其中像正则表达式和语法可以用来描述一种语言，并且可以从描述中自动生成编译器。
- en: The languages we have discussed in this chapter are ones that you are likely
    to come across in introductory programming, but there are some completely different
    styles of languages that have very important applications. There is an approach
    to programming called [Functional programming](http://en.wikipedia.org/wiki/Functional_programming) where
    all operations are formulated as mathematical functions. Common languages that
    use functional techniques include Lisp, Scheme, Haskel, Clojure and F#; even some
    conventional languages (such as Python) include ideas from functional programming.
    A pure functional programming style eliminates a problem called *side effects*,
    and without this problem it can be easier to make sure a program does exactly
    what it is intended to do. Another important type of programming is [logic programming](http://en.wikipedia.org/wiki/Logic_programming),
    where a program can be thought of as a set of rules stating what it should do,
    rather than instructions on how to do it. The most well-known logic programming
    language is Prolog.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中讨论的语言是你在初级编程中可能会遇到的，但还有一些完全不同风格的语言，它们有非常重要的应用。有一种编程方法称为[函数式编程](http://en.wikipedia.org/wiki/Functional_programming)，其中所有操作都被制定为数学函数。使用函数式技术的常见语言包括
    Lisp、Scheme、Haskel、Clojure 和 F#；甚至一些传统语言（如 Python）也包含了函数式编程的思想。纯函数式编程风格消除了一个叫做*副作用*的问题，没有了这个问题，确保程序完全按照预期运行会更容易。另一种重要的编程类型是[逻辑编程](http://en.wikipedia.org/wiki/Logic_programming)，在这种编程中，程序可以被看作是一组规则，规定了它应该做什么，而不是如何做。最著名的逻辑编程语言是
    Prolog。
- en: 4.6\. FURTHER READING
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6\. 进一步阅读
- en: 4.6.1\. USEFUL LINKS
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.1\. 有用链接
- en: The [TeachICT lesson on programming languages](http://www.teach-ict.com/gcse_computing/ocr/216_programming/programming_languages/miniweb/index.htm) covers
    many of the topics in this chapter
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[TeachICT 关于编程语言的课程](http://www.teach-ict.com/gcse_computing/ocr/216_programming/programming_languages/miniweb/index.htm)涵盖了本章中的许多主题。'
- en: CS Online has a [quick overview of this topic](http://courses.cs.vt.edu/~csonline/ProgrammingLanguages/Lessons/Introduction/index.html)
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CS Online 对这个主题有一个[快速概述](http://courses.cs.vt.edu/~csonline/ProgrammingLanguages/Lessons/Introduction/index.html)。
- en: Wikipedia entries on [Programming language](http://en.wikipedia.org/wiki/Programming_language), [High
    level language](http://en.wikipedia.org/wiki/High-level_programming_language),
    and [`](http://csfieldguide.org.nz/ProgrammingLanguages.html#id2)Low level language
    ’_
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia 上关于[编程语言](http://en.wikipedia.org/wiki/Programming_language)、[高级语言](http://en.wikipedia.org/wiki/High-level_programming_language)和[`](http://csfieldguide.org.nz/ProgrammingLanguages.html#id2)低级语言
    ’_的条目。
- en: '[website including posters comparing programming languages](http://programming.dojo.net.nz/) by
    Samuel Williams'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由塞缪尔·威廉姆斯（Samuel Williams）制作的包含比较编程语言海报的网站[链接](http://programming.dojo.net.nz/)。
- en: '[tutorial comparing programming languages](http://holowczak.com/programming-concepts-tutorial-programmers/)'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[比较编程语言的教程](http://holowczak.com/programming-concepts-tutorial-programmers/)。'
- en: a [discussion of interpreters and compilers](http://pathfinder.scar.utoronto.ca/~dyer/csca57/book_P/node7.html)
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个关于解释器和编译器的讨论[链接](http://pathfinder.scar.utoronto.ca/~dyer/csca57/book_P/node7.html)。
- en: a [poster with full details of the file content in an executable file](http://code.google.com/p/corkami/wiki/PE101?show=content) (the
    exe format)
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含在可执行文件中的文件内容完整细节的海报（exe 格式）[链接](http://code.google.com/p/corkami/wiki/PE101?show=content)。
- en: David Bolton explains a [Programming Language](http://cplus.about.com/od/introductiontoprogramming/p/programming.htm), [Compiler](http://cplus.about.com/od/introductiontoprogramming/p/compiler.htm),
    and [the difference between Compilers and Interpreters](http://cplus.about.com/od/introductiontoprogramming/a/compinterp.htm).
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大卫·博尔顿（David Bolton）解释了一个[编程语言](http://cplus.about.com/od/introductiontoprogramming/p/programming.htm)、[编译器](http://cplus.about.com/od/introductiontoprogramming/p/compiler.htm)以及[编译器和解释器之间的区别](http://cplus.about.com/od/introductiontoprogramming/a/compinterp.htm)。
- en: '[Computerworld article on the A to Z of programming languages](http://www.computerworld.com.au/article/344826/z_programming_languages/)'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[《计算机世界》关于编程语言A到Z的文章](http://www.computerworld.com.au/article/344826/z_programming_languages/)'
- en: '[What is Python?](http://python.about.com/od/gettingstarted/ss/whatispython_4.htm) (compared
    with other languages)'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python是什么？](http://python.about.com/od/gettingstarted/ss/whatispython_4.htm)（与其他语言相比）'
- en: A [very large poster showing a timeline of the development of programming languages](http://www.levenez.com/lang/)
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一张展示编程语言发展时间线的[非常大的海报](http://www.levenez.com/lang/)
- en: '[Hello World program in hundreds of programming languages](http://www.roesler-ac.de/wolfram/hello.htm)'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用数百种编程语言编写的“Hello World”程序](http://www.roesler-ac.de/wolfram/hello.htm)'
- en: '[99 bottles of beer song in hundreds of programming languages](http://99-bottles-of-beer.net/)'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[用数百种编程语言演唱《99瓶啤酒》歌曲](http://99-bottles-of-beer.net/)'
- en: 5\. DATA REPRESENTATION
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 数据表示
- en: 5.1\. WHAT’S THE BIG PICTURE?
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1\. 大局观是什么？
- en: Computers are machines that do stuff with information. They let you view, listen,
    create, and edit information in documents, images, videos, sound, spreadsheets
    and databases. They let you play games in simulated worlds that don’t really exist
    except as information inside the computer’s memory and displayed on the screen.
    They let you compute and calculate with numerical information; they let you send
    and receive information over networks. Fundamental to all of this is that the
    computer has to represent that information in some way inside the computer’s memory,
    as well as storing it on disk or sending it over a network.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机是处理信息的机器。它们让你可以查看、听取、创建和编辑文档、图片、视频、声音、电子表格和数据库中的信息。它们让你在模拟世界中玩游戏，这些世界实际上并不存在，只存在于计算机内存中并显示在屏幕上的信息中。它们让你使用数字信息进行计算和计算；它们让你在网络上发送和接收信息。所有这些的基础是计算机必须以某种方式在计算机内存中表示该信息，并将其存储在磁盘上或通过网络发送。
- en: To make computers easier to build and keep them reliable, everything is represented
    using just two values. You may have seen these two values represented as 0 and
    1, but on a computer they are represented by anything that can be in two states.
    For example, in memory a high or low voltage is used to store each 0 or 1\. On
    a magnetic disk it’s stored with, surprisingly, magnetism (whether a tiny spot
    on the disk is magnetised north or south).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使计算机更易于构建并保持可靠性，一切都是用只有两个值来表示的。你可能已经看到这两个值表示为0和1，但在计算机上它们是由可以处于两种状态的任何东西表示的。例如，在内存中，高或低电压用于存储每个0或1。在磁盘上，它以令人惊讶的方式存储，即磁性（磁盘上的微小点是磁化的北极还是南极）。
- en: 'When we write what is stored in a computer on paper, we normally use “0” for
    one of the states, and “1” for the other state. If a piece of computer memory
    had the following voltages: “low”, “low”, “high”, “low”, “high”, “high”, “high”,
    “high”, “low”, “high”, “low”, “low”, we could allocate “0” to “low”, and “1” to
    high” and write this sequence down as 001011110100\. While this notation is used
    extensively, and you may often hear the data being referred to as being “0’s and
    1’s”, it is important to remember that a computer does *not* store 0’s and 1’s;
    it has no way of doing this. They are just using physical mechanisms such as high
    and low voltage, north or south polarity, and light or dark materials.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将计算机上存储的内容写在纸上时，我们通常使用“0”表示其中一种状态，“1”表示另一种状态。如果一块计算机内存具有以下电压：“低”、“低”、“高”、“低”、“高”、“高”、“高”、“高”、“低”、“高”、“低”、“低”，我们可以将“0”分配给“低”，将“1”分配给“高”，并将这个序列写下来为001011110100。虽然这种表示法被广泛使用，你可能经常听到数据被称为“0”和“1”，但重要的是要记住计算机实际上*不*存储0和1；它没有办法这样做。它们只是使用高低电压、北极性或南极性以及光或暗材料等物理机制。
- en: '**Jargon Buster**'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '**行话解释**'
- en: The use of the two digits 0 and 1 is so common that some of the best known computer
    jargon is used for them. Since there are only two digits, the system is called
    binary. The short word for a “binary digit” is made by taking the first two letters
    and the last letter — a *bit* is just a digit that can have two values.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个数字0和1是如此普遍，以至于一些最著名的计算机行话用于它们。由于只有两个数字，该系统被称为二进制。一个“二进制数字”的简短词是通过取前两个字母和最后一个字母组成的——*位*只是一个可以有两个值的数字。
- en: Every file you save, every picture you make, every download, is just a whole
    lot of bits. Computer scientists don’t spend a lot of time reading bits themselves,
    but knowing how they are stored is really important because it affects the amount
    of space that data will use, the amount of time it takes to send the data to a
    friend (as data that takes more space takes longer to send!) and the quality of
    what is being stored. You may have come across things like “24-bit colour”, “128-bit
    encryption”, “32-bit IPv4 addresses” or “8-bit ASCII”. Understanding what the
    bits are doing enables you to work out how much space will be required to get
    high-quality colour, hard-to-crack secret codes, a unique ID for every device
    in the world, or text that uses more characters than the usual English alphabet.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 您保存的每个文件，制作的每张图片，下载的每个内容，都只是一大堆位。计算机科学家并不花很多时间自己阅读位，但知道它们是如何存储的真的很重要，因为它影响了数据将使用的空间量，将数据发送给朋友所需的时间量（因为占用更多空间的数据发送时间更长！）以及存储的内容的质量。您可能已经遇到过类似“24位色彩”、“128位加密”、“32位IPv4地址”或“8位ASCII”的东西。了解位是如何运作的，使您能够计算出为获得高质量的颜色、难以破解的秘密代码、全球每个设备的唯一标识符或使用比通常的英语字母更多字符的文本所需的空间量。
- en: This chapter is about some of the different methods that computers use to code
    different kinds of information in patterns of these bits, and how this affects
    the cost and quality of what we do on the computer, or even if something is feasible
    at all.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了计算机用于在这些位的模式中编码不同类型信息的一些不同方法，以及这如何影响计算机上所做的工作的成本和质量，甚至是否可行。
- en: 5.2\. GETTING STARTED
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2\. 入门
- en: More than 200 years ago a 15-year-old French boy invented a system for representing
    text using combinations of flat and raised dots on paper so that they could be
    read by touch. The system became very popular with people who had visual impairment
    as it provided a relatively fast and reliable way to “read” text without seeing
    it. Louis Braille’s system is an early example of a “binary” representation of
    data — there are only two symbols (raised and flat), and yet combinations of them
    can be used to represent reference books and works of literature. Each character
    in braille is represented with a cell of 6 dots. Each dot can either be raised
    or not raised. Different numbers and letters can be made by using different patterns
    of raised and not raised dots.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 200多年前，一名15岁的法国男孩发明了一种用平坦和凸起的点的组合来表示文字的系统，以便盲人通过触摸来阅读。这个系统非常受视觉障碍人士的欢迎，因为它提供了一种相对快速和可靠的方式来“阅读”文字而不是看到它。路易斯·布莱叶的系统是“二进制”数据表示的早期示例——只有两种符号（凸起和平坦），但它们的组合可以用来表示参考书籍和文学作品。盲文中的每个字符都用一个6点的单元表示。每个点可以是凸起的或不凸起的。使用不同的凸起和不凸起点的不同图案可以制作出不同的数字和字母。
- en: '![](563ad41d6346e.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad41d6346e.jpg)'
- en: Let’s work out how many different patterns can be made using the 6 dots in a
    Braille character. When working through the material in this section, a good way
    to draw braille on paper without having to actually make raised dots is to draw
    a rectangle with 6 small circles in it, and to colour in the circles that are
    raised, and not colour in the ones that aren’t raised.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算一下在盲文字符的6个点中可以制作多少不同的模式。在本节的材料中，一个在纸上绘制盲文而不必真正制作凸起点的好方法是在一个矩形中绘制6个小圆圈，并将凸起的圆圈涂色，而不是涂色。
- en: If braille used only 2 dots, there would be 4 patterns.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 如果盲文只使用了2个点，那么就会有4种模式。
- en: '![](563ad41cd8f2e.png)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad41cd8f2e.png)'
- en: And with 3 dots there would be 8 patterns
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 并且有3个点的话，将会有8种模式。
- en: '![](563ad41c1d181.png)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad41c1d181.png)'
- en: You may have noticed that there are twice as many patterns with 3 dots as there
    are with 2 dots. It turns out that every time you add an extra dot, that gives
    twice as many patterns (why?), so with 4 dots there are 16 patterns, 5 dots has
    32 patterns, and 6 dots has 64 patterns.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到有3个点的模式比有2个点的模式多一倍。事实证明，每增加一个额外的点，就会产生两倍于之前的模式（为什么？），所以有4个点就有16种模式，5个点有32种模式，6个点有64种模式。
- en: So, Braille can make 64 patterns. That’s enough for all the letters of the alphabet,
    and other symbols too, such as digits and punctuation.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，盲文可以制作64种模式。这足以表示字母表中的所有字母，以及数字和标点符号等其他符号。
- en: 'Braille also illustrates why binary representation is so popular. It would
    be possible to have three kinds of dot: flat, half raised, and raised. A skilled
    braille reader could distinguish them, and with three values per dot, you would
    only need 4 dots to represent 64 patterns. The trouble is that you would need
    more accurate devices to create the dots, and people would need to be more accurate
    at sensing them. If a page was squashed, even very slightly, it could leave the
    information unreadable.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 盲文也说明了为什么二进制表示如此流行。有可能有三种点：平的、半提起的和提起的。一个熟练的盲文读者可以区分它们，每个点三个值，你只需要 4 个点就可以表示
    64 个图案。问题在于，你需要更准确的设备来制造这些点，人们需要更准确地感知它们。如果一页被压扁了，即使是稍微一点，都可能使信息无法阅读。
- en: 'Digital devices almost always use two values (binary) for similar reasons:
    computer disks and memory can be made cheaper and smaller if they only need to
    be able to distinguish between two extreme values (such as a high and low voltage),
    rather than fine-grained distinctions between very subtle differences in voltages.
    Arithmetic is also easy with binary values; if you have only two digits (0 and
    1), then there aren’t many rules to learn - adding digits only requires circuits
    to calculate 0+0, 0+1, 1+0 and 1+1\. You might like to work out how many combinations
    of decimal digits you need to be able to add if you’re doing conventional arithmetic!'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 数字设备几乎总是使用两个值（二进制），原因是类似的：如果计算机磁盘和内存只需要能够区分两个极端值（如高电压和低电压），而不需要对电压的非常微小的差异进行细粒度区分，那么它们就可以更便宜、更小。二进制值也很容易进行算术运算；如果你只有两个数字（0
    和 1），那么就没有太多的规则要学习 - 只需要电路来计算 0+0、0+1、1+0 和 1+1。如果你正在进行传统算术，你可能想算一下你需要能够相加多少组十进制数字！
- en: In fact, every kind of file on a computer is represented using just a whole
    lot of binary digits — text, pictures, spreadsheets, web pages, songs — *everything* is
    stored using just two values. Even the programs (apps) that you run use binary
    representation — sometimes a program file that the computer can run is referred
    to as a “binary file”, which is a bit odd since every file on a computer is binary!
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，计算机上的每一种文件都只是用大量的二进制数字表示的 —— 文本、图片、电子表格、网页、歌曲 —— *所有东西* 都是只用两个值来存储的。即使是你运行的程序（应用）也使用二进制表示
    —— 有时计算机可以运行的程序文件被称为“二进制文件”，这有点奇怪，因为计算机上的每个文件都是二进制的！
- en: 5.3\. REPRESENTING TEXT WITH BITS
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3\. 使用比特表示文本
- en: We saw above that 64 unique patterns can be made using 6 dots in Braille. Count
    how many different upper-case letters, lower-case letters, numbers, and symbols
    that you could insert into a text editor using your keyboard. (Don’t forget to
    count both of the symbols that share the number keys, and the symbols to the side
    that are for punctuation!) The collective name for these is *characters* e.g.
    a, D, 1, h, 6, *, ], and ~ are all characters.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，用 6 个点可以制作 64 个唯一的盲文图案。计算一下，你可以用键盘向文本编辑器中插入多少个不同的大写字母、小写字母、数字和符号。（别忘了要同时计算共享数字键的两个符号，以及标点符号旁边的符号！）这些的统称为
    *字符*，例如，a、D、1、h、6、*、] 和 ~ 都是字符。
- en: Would 6 dots (which can represent 64 patterns) be enough to represent all these
    characters? If you counted correctly, you should find that there were more than
    64 characters! How many bits would you need to be able to represent all the characters
    you counted on your keyboard?
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 6 个点（可以表示 64 个图案）足以表示所有这些字符吗？如果你计算正确，你应该会发现有超过 64 个字符！你需要多少位才能表示键盘上你计算的所有字符？
- en: It turns out that 7 dots is enough as this gives 128 possible patterns, and
    this is exactly what the ASCII code for text does. ASCII is one of the main systems
    that computers use to represent English text. It was first used commercially in
    1963, and despite the big changes in computers since then, it is still the basis
    of how English text is stored on computers.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 结果发现，7 个点足够了，因为这给出了 128 种可能的图案，这正是用于文本的 ASCII 码所做的。ASCII 是计算机用来表示英文文本的主要系统之一。它在
    1963 年首次商业使用，尽管自那时以来计算机发生了很大变化，但它仍然是存储英文文本的基础。
- en: ASCII assigned a different pattern of bits to each of the characters, along
    with a few other “control” characters that you don’t need to worry about yet.
    For reasons that we will get to later, each pattern in ASCII is usually stored
    in 8 bits, with one wasted bit, rather than 7 bits. However, the first bit in
    each 8-bit pattern is a 0, meaning there are still only 128 possible patterns.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII 为每个字符分配了不同的比特模式，还有一些其他的“控制”字符，你暂时不需要担心。由于我们稍后会讨论的原因，ASCII 中的每个模式通常以 8
    位存储，有一个浪费的比特，而不是 7 位。然而，每个 8 位模式的第一个比特是 0，意味着仍然只有 128 个可能的模式。
- en: Below is a table that shows the patterns of bits that ASCII uses for each of
    the characters.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个表格，显示 ASCII 为每个字符使用的比特模式。
- en: '| Binary | Char | Binary | Char | Binary | Char |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| 二进制 | 字符 | 二进制 | 字符 | 二进制 | 字符 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0100000 | Space | 1000000 | @ | 1100000 | [`](http://csfieldguide.org.nz/DataRepresentation.html#id2)
    |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| 0100000 | 空格 | 1000000 | @ | 1100000 | [`](http://csfieldguide.org.nz/DataRepresentation.html#id2)
    |'
- en: '| 0100001 | ! | 1000001 | A | 1100001 | a |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| 0100001 | ! | 1000001 | A | 1100001 | a |'
- en: '| 0100010 | “ | 1000010 | B | 1100010 | b |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| 0100010 | “ | 1000010 | B | 1100010 | b |'
- en: '| 0100011 | # | 1000011 | C | 1100011 | c |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '| 0100011 | # | 1000011 | C | 1100011 | c |'
- en: '| 0100100 | $ | 1000100 | D | 1100100 | d |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '| 0100100 | $ | 1000100 | D | 1100100 | d |'
- en: '| 0100101 | % | 1000101 | E | 1100101 | e |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '| 0100101 | % | 1000101 | E | 1100101 | e |'
- en: '| 0100110 | & | 1000110 | F | 1100110 | f |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '| 0100110 | & | 1000110 | F | 1100110 | f |'
- en: '| 0100111 | ‘ | 1000111 | G | 1100111 | g |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '| 0100111 | ‘ | 1000111 | G | 1100111 | g |'
- en: '| 0101000 | ( | 1001000 | H | 1101000 | h |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| 0101000 | ( | 1001000 | H | 1101000 | h |'
- en: '| 0101001 | ) | 1001001 | I | 1101001 | i |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| 0101001 | ) | 1001001 | I | 1101001 | i |'
- en: '| 0101010 | * | 1001010 | J | 1101010 | j |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| 0101010 | * | 1001010 | J | 1101010 | j |'
- en: '| 0101011 | + | 1001011 | K | 1101011 | k |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| 0101011 | + | 1001011 | K | 1101011 | k |'
- en: '| 0101100 | , | 1001100 | L | 1101100 | l |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| 0101100 | , | 1001100 | L | 1101100 | l |'
- en: '| 0101101 | - | 1001101 | M | 1101101 | m |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '| 0101101 | - | 1001101 | M | 1101101 | m |'
- en: '| 0101110 | . | 1001110 | N | 1101110 | n |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| 0101110 | . | 1001110 | N | 1101110 | n |'
- en: '| 0101111 | / | 1001111 | O | 1101111 | o |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| 0101111 | / | 1001111 | O | 1101111 | o |'
- en: '| 0110000 | 0 | 1010000 | P | 1110000 | p |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| 0110000 | 0 | 1010000 | P | 1110000 | p |'
- en: '| 0110001 | 1 | 1010001 | Q | 1110001 | q |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| 0110001 | 1 | 1010001 | Q | 1110001 | q |'
- en: '| 0110010 | 2 | 1010010 | R | 1110010 | r |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| 0110010 | 2 | 1010010 | R | 1110010 | r |'
- en: '| 0110011 | 3 | 1010011 | S | 1110011 | s |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| 0110011 | 3 | 1010011 | S | 1110011 | s |'
- en: '| 0110100 | 4 | 1010100 | T | 1110100 | t |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| 0110100 | 4 | 1010100 | T | 1110100 | t |'
- en: '| 0110101 | 5 | 1010101 | U | 1110101 | u |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| 0110101 | 5 | 1010101 | U | 1110101 | u |'
- en: '| 0110110 | 6 | 1010110 | V | 1110110 | v |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| 0110110 | 6 | 1010110 | V | 1110110 | v |'
- en: '| 0110111 | 7 | 1010111 | W | 1110111 | w |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| 0110111 | 7 | 1010111 | W | 1110111 | w |'
- en: '| 0111000 | 8 | 1011000 | X | 1111000 | x |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '| 0111000 | 8 | 1011000 | X | 1111000 | x |'
- en: '| 0111001 | 9 | 1011001 | Y | 1111001 | y |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '| 0111001 | 9 | 1011001 | Y | 1111001 | y |'
- en: '| 0111010 | : | 1011010 | Z | 1111010 | z |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
  zh: '| 0111010 | : | 1011010 | Z | 1111010 | z |'
- en: '| 0111011 | ; | 1011011 | [ | 1111011 | { |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
  zh: '| 0111011 | ; | 1011011 | [ | 1111011 | { |'
- en: '| 0111100 | < | 1011100 | \ | 1111100 |  |  |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '| 0111100 | < | 1011100 | \ | 1111100 |  |  |'
- en: '| 0111101 | = | 1011101 | ] | 1111101 | } |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '| 0111101 | = | 1011101 | ] | 1111101 | } |'
- en: '| 0111110 | > | 1011110 | ^ | 1111110 | ~ |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| 0111110 | > | 1011110 | ^ | 1111110 | ~ |'
- en: '| 0111111 | ? | 1011111 | _ | 1111111 |  |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| 0111111 | ? | 1011111 | _ | 1111111 |  |'
- en: For example, the letter c (lower-case) in the table has the pattern “01100011”
    (the 0 at the front is just extra padding to make it up to 8 bits). The letter
    o has the pattern “01101111”. You could write a word out using this code, and
    if you give it to someone else, they should be able to decode it exactly.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，表格中的小写字母 c 具有模式“01100011”（前面的 0 只是额外的填充，使其达到 8 位）。字母 o 的模式为“01101111”。你可以使用这个代码编写一个单词，如果你把它交给别人，他们应该能够准确地解码它。
- en: Computers can represent pieces of text with sequences of these patterns, much
    like Braille does. For example, the word “computers” (all lower-case) would be
    01100011 01101111 01101101 01110000 01110101 01110100 01100101 01110010 01110011.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机可以用这些模式的序列来表示文本片段，就像盲文一样。例如，单词“computers”（全小写）的表示为 01100011 01101111 01101101
    01110000 01110101 01110100 01100101 01110010 01110011。
- en: How would you represent the word “science” in ASCII? What about “Wellington”
    (note that it starts with an upper-case “W”)? How would you represent “358” in
    ASCII (it is three characters, even though it looks like a number)? What about
    the sentence “Hello, how are you?” (look for the comma, question mark, and space
    characters in the ASCII table).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 你将如何用 ASCII 表示单词“science”？“Wellington”呢（注意它以大写的“W”开头）？你将如何表示“358”在 ASCII 中（它是三个字符，尽管看起来像一个数字）？还有句子“Hello,
    how are you？”（在 ASCII 表中查找逗号、问号和空格字符）。
- en: '**Curiosity**'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '**好奇心**'
- en: If you *only* wanted to represent the 26 letters of the alphabet, and weren’t
    worried about upper-case or lower-case, you could get away with using just 5 bits,
    which allows for up to 32 different patterns. Have a look at the last 5 bits of
    each of the 26 lower-case letters in ASCII. Do any of the 26 lower-case letters
    have the same last 5 bits? Have a look at the 26 upper-case letters. Do any of
    the upper-case letters have the same last 5 bits?
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你*只想*表示26个字母表中的字母，并不担心大小写，你可以只用5位，这样可以有32种不同的模式。看看ASCII中每个26个小写字母的最后5位。26个小写字母中有哪些字母的最后5位相同？再看看26个大写字母。有哪些大写字母的最后5位相同？
- en: You may have noticed that none of the lower-case letters have the same last
    5 bits, but they do have the same last 5 bits as their corresponding upper-case
    letter!
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，没有任何小写字母的最后5位相同，但它们的对应大写字母的最后5位是相同的！
- en: For example, a = 1100001 and A = 1000001, they both have 00001 as their last
    5 bits. As another example, s = 1110011 and S = 1010011, they both have 10011
    as their last 5 bits.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，a = 1100001，A = 1000001，它们的最后5位都是00001。再举个例子，s = 1110011，S = 1010011，它们的最后5位都是10011。
- en: An easy way to allocate patterns in this 5 bit system would be to just use the
    last 5 bits for each character in the ASCII table. Therefore A would be 00001,
    b would be 00010, c would be 00011, etc.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个5位系统中分配模式的简单方法是只使用ASCII表中每个字符的最后5位。因此A将是00001，b将是00010，c将是00011，等等。
- en: The word “water” would be 10111 00001 10111 10100 10010
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: “水”这个词的编码是10111 00001 10111 10100 10010
- en: There’s an activity that uses [five-bit text codes hidden in music here](http://csunplugged.org/modem).
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个活动，使用[隐藏在音乐中的五位文本编码](http://csunplugged.org/modem)。
- en: English text can easily be represented using ASCII, but what about languages
    such as Chinese where there are thousands of different characters? The 128 patterns
    aren’t nearly enough to represent such languages! That’s where codes that use
    more than 7 bits become important, and in a later section we’ll look at these,
    but first we need to explore binary number representation and develop some efficient
    ways to talk about longer binary numbers.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 英文文本可以很容易地用ASCII表示，但是对于中文等有成千上万个不同字符的语言呢？128种模式远远不足以表示这样的语言！这就是使用超过7位的编码变得重要的地方，在后面的部分我们将看看这些，但首先我们需要探讨二进制数表示和开发一些有效的方法来讨论更长的二进制数。
- en: '**Curiosity**'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '**好奇心**'
- en: The name “ASCII” stands for “American Standard Code for Information Interchange”,
    which was a particular way of assigning bit patterns to the characters on a typewriter.
    The ASCII system even includes “characters” for ringing a bell (useful for getting
    attention on old telegraph systems), deleting the previous character (kind of
    an early “undo”), and “end of transmission” (to let the receiver know that the
    message was finished). These days those characters are rarely used, but the codes
    for them still exist (they are the missing patterns in the table above). Nowadays
    ASCII has been surplanted by a code called “UTF-8”, which happens to be the same
    as ASCII if the extra left-hand bit is a 0, but opens up a huge range of characters
    if the left-hand bit is a 1.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: “ASCII”这个名字代表“美国信息交换标准代码”，这是一种特定的方式，将比特模式分配给打字机上的字符。ASCII系统甚至包括“字符”用于响铃（在旧电报系统中引起注意很有用），删除前一个字符（一种早期的“撤销”），以及“传输结束”（让接收者知道消息已完成）。如今这些字符很少使用，但它们的编码仍然存在（它们是上表中缺失的模式）。如今ASCII已被一种称为“UTF-8”的编码取代，如果额外的左位为0，则与ASCII相同，但如果左位为1，则可以打开大量字符的范围。
- en: There are several other codes that were popular before ASCII, including the [Baudot
    code](http://en.wikipedia.org/wiki/Baudot_code) and [EBCDIC](http://en.wikipedia.org/wiki/EBCDIC).
    A widely used variant of the Baudot code was the “Murray code”, named after New
    Zealand born inventor [Donald Murray](http://en.wikipedia.org/wiki/Donald_Murray_(inventor)).
    One of Murray’s significant improvements was to introduce the idea of “control
    characters”, such as the carriage return (new line). The “control” key still exists
    on modern keyboards.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASCII之前有几种其他流行的编码，包括[Baudot code](http://en.wikipedia.org/wiki/Baudot_code)和[EBCDIC](http://en.wikipedia.org/wiki/EBCDIC)。Baudot
    code的一个广泛使用的变体是“Murray code”，以新西兰出生的发明家[Donald Murray](http://en.wikipedia.org/wiki/Donald_Murray_(inventor))命名。Murray的一个重要改进是引入“控制字符”的概念，例如回车（换行）。现代键盘上仍然存在“控制”键。
- en: 5.4\. REPRESENTING NUMBERS WITH BITS
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4\. 使用比特表示数字
- en: The number system that humans normally use is in base 10 (also known as decimal).
    It’s worth revising quickly, because binary numbers use the same ideas as decimal
    numbers, just with fewer digits!
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 人类通常使用的数字系统是以 10 为基数的（也称为十进制）。值得迅速复习，因为二进制数使用与十进制数相同的思想，只是数字更少！
- en: In decimal, the value of each digit in a number depends on its place in the
    number. For example, in the amount $123, the 3 represents $3, whereas the 1 represents
    $100\. Each place value in a number is worth 10 times more than the place value
    to its right, i.e. there are the “ones”, the “tens”, the “hundreds”, the “thousands”
    the “ten thousands”, the “hundred thousands”, the “millions”, etc. Also, there
    are 10 different digits (0,1,2,3,4,5,6,7,8,9) that can be at each of those place
    values.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在十进制中，一个数字中每个数字的值取决于它在数字中的位置。例如，在金额 $123 中，3 代表 $3，而 1 代表 $100。数字中的每个位置价值比右边的位置价值高
    10 倍，即有“个位数”，“十位数”，“百位数”，“千位数”，“万位数”，“十万位数”，“百万位数”等。此外，有 10 个不同的数字（0,1,2,3,4,5,6,7,8,9）可以出现在每个位置上。
- en: If you were only able to use one digit to represent a number, then the largest
    number would be 9\. After that, you need a second digit, which goes to the left,
    giving you the next ten numbers (10, 11, 12... 19). It’s because we have 10 digits
    that each one is worth 10 times as much as the one it its right.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只能用一个数字来表示一个数字，那么最大的数字将是 9。之后，你需要第二个数字，它在左边，给出下一个十个数字（10, 11, 12... 19）。这是因为我们有
    10 个数字，每个数字的价值是它右边数字的 10 倍。
- en: 'You may have encountered different ways of expressing numbers using “expanded
    form”. For example, if you want to write the number 90328 in expanded form you
    might have written it as:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能遇到过用“展开形式”表示数字的不同方法。例如，如果你想将数字 90328 写成展开形式，你可能会写成：
- en: 90328 = 90000 + 300 + 20 + 8
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 90328 = 90000 + 300 + 20 + 8
- en: 'A more sophisticated way of writing it is:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的写法是：
- en: 90328 = (9 x 10000) + (0 x 1000) + (3 x 100) + (2 x 10) + (8 x 1)
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 90328 = (9 x 10000) + (0 x 1000) + (3 x 100) + (2 x 10) + (8 x 1)
- en: If you’ve learnt about exponents, you could write it as 90328 = (9 x 104) +
    (0 x 103) + (3 x 102) + (2 x 101) + (8 x 100)
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你学过指数，你可以将其写成 90328 = (9 x 104) + (0 x 103) + (3 x 102) + (2 x 101) + (8 x
    100)
- en: Remember that any number to the power of 0 is 1\. i.e. the 8 x 100 is 8, because
    the 100 is 1.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，任何数的 0 次方都是 1。也就是说，8 x 100 是 8，因为 100 是 1。
- en: The key ideas to notice from this are that the digit on the right (such as the
    8 in 90328) is the one that’s worth the least, and that because we have 10 digits,
    each place is worth 10 times as much as the one to the right (e.g. the 2 in 90328
    is the number of tens, the 3 is the number of 100s, and so on). Exactly the same
    happens with binary numbers.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 从中可以注意到的关键思想是右边的数字（例如 90328 中的 8）是价值最低的数字，并且因为我们有 10 个数字，每个位置的价值是右边位置的 10 倍（例如
    90328 中的 2 是十位数，3 是百位数，依此类推）。二进制数字也完全相同。
- en: 5.4.1\. BINARY NUMBERS
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1\. 二进制数
- en: As discussed earlier, computers can only store information using bits, which
    only have 2 possible states. This means that they cannot represent base 10 numbers
    using digits 0 to 9, the way we write down numbers in decimal; instead, they use
    a base 2 number system, also called binary.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所讨论的，计算机只能使用比特来存储信息，比特只有 2 种可能的状态。这意味着它们无法使用数字 0 到 9 来表示十进制数，就像我们用十进制书写数字一样；相反，它们使用基于
    2 的数字系统，也称为二进制。
- en: '**Curiosity**'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '**好奇心**'
- en: The base 10 (decimal) system is sometimes called denary, which is more consistent
    with the the name binary for the base 2 system. The word “denary” also refers
    to the Roman denarius coin, which was worth ten asses (an “as” was a copper or
    bronze coin).
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制（十进制）系统有时被称为十进制，这更符合二进制系统的名称二进制。词“十进制”还指的是罗马铜币“denarius”，它相当于十个“as”（“as”是铜币或青铜币）。
- en: Because binary is base 2, there are only 2 possible digits (0 and 1), as opposed
    to the 10 in our standard number system, and each place value is 2 times bigger
    than the one to its right (in contrast to our base 10 number system where each
    place is 10 times bigger).
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 因为二进制是基于 2 的，所以只有 2 种可能的数字（0 和 1），而不是我们标准数字系统中的 10 种，并且每个位置的价值是其右边的 2 倍（与我们的十进制数字系统不同，其中每个位置的价值是
    10 倍）。
- en: The interactive below illustrates how this binary number system represents decimal
    numbers. Have a play around with it to see what patterns you can see. The decimal
    (base 10) representation for the binary number currently shown is given by the
    interactive on the far right.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的互动展示了这个二进制数字系统如何表示十进制数字。玩弄一下，看看能发现什么模式。互动在最右边给出了当前显示的二进制数字的十进制（基数10）表示。
- en: '[![](563ad41b5496e.png)Click to load the'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad41b5496e.png)点击加载'
- en: binary number interactive](http://csfieldguide.org.nz/_static/widgets/DR/DR-base-conversion/public_html/index.html?base=2&columns=7&lines=A,B,C&offset=0)
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '[二进制数字互动](http://csfieldguide.org.nz/_static/widgets/DR/DR-base-conversion/public_html/index.html?base=2&columns=7&lines=A,B,C&offset=0)'
- en: To ensure you are understanding correctly how to use the interactive, verify
    that when you enter the binary number 101101 it shows that the decimal representation
    is 45, that when you enter 100000 it shows that the decimal representation is
    32, and when you enter 001010 it shows the decimal representation is 10.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你正确理解了如何使用该互动，请验证当你输入二进制数101101时，它显示十进制表示是45；当你输入100000时，它显示十进制表示是32；当你输入001010时，它显示十进制表示是10。
- en: You should try using the interactive to convert a decimal number to binary.
    For example, choose a number less than 61 (perhaps your house number, a friend’s
    age, or the day of the month you were born on), set all the binary digits to zero,
    and then start with the *left-most* digit (32), trying out if it should be zero
    or one. See if you can find a method for converting the number without too much
    trial and error.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该尝试使用这个互动将一个十进制数转换为二进制。例如，选择一个小于61的数字（也许是你的家庭编号，朋友的年龄，或者你出生的月份的日期），将所有二进制数字设置为零，然后从*最左边*的数字（32）开始，尝试它应该是零还是一。看看能否找到一种不需要太多试错的方法来转换数字。
- en: Can you figure out the binary representation for 23 without using the interactive?
    What about 4, 0, and 32? Check all your answers using the interactive to verify
    they are correct.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 你能在不使用互动的情况下找出23的二进制表示吗？4、0和32呢？使用互动验证所有你的答案以确保它们是正确的。
- en: What is the largest number you can make with this binary interactive? What is
    the smallest? Is there any integer value in between the biggest and the smallest
    that you can’t make? Are there any numbers with more than one representation?
    Why/ why not?
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 这个二进制互动能组成的最大数字是多少？最小数字呢？在最大和最小数字之间有任何你无法组成的整数值吗？有没有多种表示？为什么/为什么不？
- en: You have probably noticed from the interactive that when set to 1, the leftmost
    bit (the “most significant bit”) adds 32 to the total, the next adds 16, and then
    the rest add 8, 4, 2, and 1 respectively. When set to 0, a bit does not add anything
    to the total. So the idea is to make numbers by adding some or all of 32, 16,
    8, 4, 2, and 1 together, and each of those numbers can only be included once.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经从互动中注意到，当设置为1时，最左边的位（“最高有效位”）会给总数加32，接下来的位会加16，然后其余的分别加8、4、2和1。当设置为0时，位不会给总数加任何东西。所以思路是通过将32、16、8、4、2和1中的一些或全部相加来制作数字，每个数字只能包含一次。
- en: 'Rather than just using trial and error to figure out what a decimal number
    is in binary, could you figure out a systematic approach? Have a look at what
    100000 is in binary. What about 011111? Is it possible to make a number over 32
    if the most significant bit is set to a 0? Why? And what about 001000 and 000111?
    Can you see a pattern that would lead to a systematic way of converting decimal
    numbers to binary? Hint: start with deciding the leftmost bit, and then work along
    to the right, bit by bit.'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 与其只是试错来弄清楚一个十进制数在二进制中是什么，你能找到一个系统的方法吗？看看100000在二进制中是什么。011111呢？如果最高有效位设置为0，是否可能得到一个大于32的数字？为什么？001000和000111呢？你能看到导致将十进制数转换为二进制的系统方式的模式吗？提示：从决定最左边的位开始，然后逐位向右工作。
- en: So what happens if we have fewer than 6 bits? For example, with 5 bits, the
    place values would be 16, 8, 4, 2 and 1, so the largest value is 11111 in binary,
    or 31 in decimal. What’s the largest value you can store with 4 bits? 3 bits?
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果比6位更少会发生什么？例如，使用5位时，位值将是16、8、4、2和1，因此最大值是二进制中的11111，或十进制中的31。使用4位能存储的最大值是多少？3位呢？
- en: What would happen if we have 7 bits instead of 6? The seventh bit would have
    a value of 64, and it would be possible to store numbers up to 127.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有7位而不是6位会发生什么？第七位将具有64的值，可以存储的数字将达到127。
- en: '**Extra for Experts**'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '**专家级额外内容**'
- en: 'Can you figure out a systematic approach to counting in binary? i.e. start
    with the number 0, then increment it to 1, then 2, then 3, etc, all the way up
    to the highest number that can be made with the 7 bits. Try counting from 0 to
    16, and see if you can detect a pattern. Hint: Think about how you add 1 to a
    number in base 10\. e.g. how do you work out 7 + 1, 38 + 1, 19 + 1, 99 + 1, 230899999
    + 1, etc? Can you apply that same idea to binary?'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想出一个系统的方法来在二进制中计数吗？即从数字0开始，然后递增到1，然后2，然后3，等等，一直到使用7位可以得到的最大数字。尝试从0数到16，看看是否能发现模式。提示：想想如何在十进制中将1加到一个数字上。例如，如何计算7+1，38+1，19+1，99+1，230899999+1等？你能将相同的思想应用到二进制吗？
- en: Using your new knowledge of the binary number system, can you figure out a way
    to count to higher than 10 using your 10 fingers? What is the highest number you
    can represent using your 10 fingers? What if you included your 10 toes as well
    (so you have 20 fingers and toes to count with).
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你对二进制数字系统的新知识，你能想出一种方法来用你的10根手指计数到更高的数字吗？你能用你的10个手指代表的最大数字是多少？如果你还包括了你的10个脚趾（所以你有20个手指和脚趾可以用来计数）呢？
- en: An important concept with binary numbers is the range of values that can be
    represented using a given number of bits. One bit on its own might not seem very
    useful, but it’s enough to store things like the state of a checkbox (checked
    or not checked). When we have 8 bits the binary numbers start to get useful —
    they can represent values from 0 to 255, so it is enough to store someone’s age,
    the day of the month, and so on.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数字的一个重要概念是可以用给定位数表示的值的范围。一个位可能看起来并不是很有用，但足以存储像复选框的状态（选中或未选中）这样的东西。当我们有8位时，二进制数字开始变得有用
    — 它们可以表示从0到255的值，因此足以存储某人的年龄，月份的日期等。
- en: '**Jargon Buster**'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '**术语解释**'
- en: 'Groups of 8 bits are so useful that they have their own name: a **byte**. Computer
    memory and disk space is usually divided up into bytes, and bigger values are
    stored using more than one byte. For example, two bytes (16 bits) are enough to
    store numbers from 0 to 65,535\. Four bytes (32 bits) can store numbers up to
    42,94,967,295\. You can check these numbers by working out the place values of
    the bits. Every bit that’s added will double the range of the number.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 8位组是如此有用，它们有自己的名称：一个**字节**。计算机内存和磁盘空间通常被分割成字节，而更大的值则使用多个字节存储。例如，两个字节（16位）足以存储从0到65,535的数字。四个字节（32位）可以存储高达42,94,967,295的数字。您可以通过计算位的位置值来检查这些数字。每添加一个位都会使数字的范围加倍。
- en: '**Curiosity**'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '**好奇心**'
- en: Candles on birthday cakes use the base 1 numbering system, where each place
    is worth 1 times the one to its right(!) For example, the number 3 is 111, and
    10 is 1111111111\. This can cause problems as you get older — if you’ve ever seen
    a cake with 100 candles on it, you’ll be aware that it’s a serious fire hazard.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 生日蛋糕上的蜡烛使用的是基数为1的编号系统，其中每个位置的值是其右边的1的倍数（！）。例如，数字3是111，而10是1111111111。随着年龄的增长，这可能会导致问题
    —— 如果你曾经见过一个有100根蜡烛的蛋糕，你会意识到这是一个严重的火灾隐患。
- en: '![](563ad3dc32698.png)'
  id: totrans-599
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad3dc32698.png)'
- en: Luckily it’s possible to use binary notation for birthday candles — each candle
    is either lit or not lit. For example, if you are 18, the binary notation is 10010,
    and you need 5 candles (with only two of them lit).
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，可以用二进制记数法来表示生日蜡烛 —— 每支蜡烛要么点亮，要么熄灭。例如，如果你是18岁，二进制表示法是10010，你需要5根蜡烛（其中只有两根点亮）。
- en: There’s a [video on using binary notation for counting up to 1023 on your hands,
    as well as using it for birthday cakes](http://www.youtube.com/watch?v=GUqle9RE3Y8).
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个[关于如何使用二进制记数法在你的手上计数到1023以及在生日蛋糕上使用它的视频](http://www.youtube.com/watch?v=GUqle9RE3Y8)。
- en: '![](563ad3db99b7d.png)'
  id: totrans-602
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad3db99b7d.png)'
- en: 5.4.2\. SHORTHAND FOR BINARY NUMBERS
  id: totrans-603
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2\. 二进制数字的简写
- en: Most of the time binary numbers are stored electronically, and we don’t need
    to worry about making sense of them. But sometimes it’s useful to be able to write
    down and share numbers, such as the unique identifier assigned to each digital
    device (MAC address), or the colours specified in an HTML page.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，二进制数字被电子存储，我们不需要担心理解它们。但有时候，能够写下并分享数字是很有用的，比如为每个数字设备分配的唯一标识符（MAC地址），或者HTML页面中指定的颜色。
- en: 'Writing out long binary numbers is tedious — for example, suppose you need
    to copy down the 16-bit number 0101001110010001\. A widely used shortcut is to
    break the number up into 4-bit groups (in this case, 0101 0011 1001 0001), and
    then write down the digit that each group represents (giving 5391). There’s just
    one small problem: each group of 4 bits can go up to 1111, which is 15, and the
    digits only go up to 9.'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 写出长长的二进制数很麻烦——例如，假设你需要复制下 16 位数 0101001110010001。一个广泛使用的快捷方式是将数字分成 4 位组（在这种情况下，0101
    0011 1001 0001），然后写下每组代表的数字（得到 5391）。只有一个小问题：每组 4 位可以达到 1111，即 15，而数字只能达到 9。
- en: 'The solution is simple: we introduce symbols for the digits for 1010 (10) to
    1111 (15), which are just the letters A to F. So, for example, the 16-bit binary
    number 1011 1000 1110 0001 can be written more concisely as B8E1\. The “B” represents
    the binary 1011, which is the decimal number 11, and the E represents binary 1110,
    which is decimal 14.'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案很简单：我们引入了符号来表示从 1010（10）到 1111（15）的数字，它们就是字母 A 到 F。所以，例如，16 位二进制数 1011 1000
    1110 0001 可以更简洁地写成 B8E1。 “B” 代表二进制数 1011，即十进制数 11，而 E 代表二进制数 1110，即十进制数 14。
- en: Because we now have 16 digits, this representation is called hexadecimal (or
    hex for short). Converting between binary and hexadecimal is very simple, and
    that’s why hexadecimal is a very common way of writing down large binary numbers.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们现在有了 16 位数字，这种表示被称为十六进制（或简称为十六进制）。在二进制和十六进制之间进行转换非常简单，这就是为什么十六进制是写大型二进制数字的一种非常常见的方式。
- en: 'Here’s a full table of all the 4-bit numbers and their hexadecimal digit equivalent:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是所有的 4 位数及其十六进制数字等价物的完整表格：
- en: '| Binary | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001
    | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '| 二进制 | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001
    | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |'
- en: '| Hex | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '| 十六进制 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |'
- en: For example, the largest 8-bit binary number is 11111111\. This can be written
    as FF in hexadecimal. Both of those representations mean 255 in our conventional
    decimal system (you can check that by converting the binary number to decimal).
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，最大的 8 位二进制数是 11111111。这可以写成十六进制中的 FF。这两种表示在我们的传统十进制系统中都意味着 255（您可以通过将二进制数转换为十进制来验证）。
- en: The largest 16 bit binary number is 1111111111111111, or FFFF in hexadecimal.
    Both of these represent 65535 in decimal.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的 16 位二进制数是 1111111111111111，或者在十六进制中是 FFFF。这两个表示都代表十进制中的 65535。
- en: The hexadecimal system is also known as base 16\. The following interactive
    converts hexadecimal numbers to decimal (base 10), which provides another way
    of thinking about them. But don’t forget that the main point is that hexadecimal
    is an easy shorthand for binary representation.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制系统也被称为 16 进制。以下交互式将十六进制数转换为十进制（十进制），这提供了另一种思考它们的方式。但不要忘记，十六进制是二进制表示的一种简便方式。
- en: '[![](563ad3d921d02.png)Click to load the widget](http://csfieldguide.org.nz/_static/widgets/DR/DR-base-conversion/public_html/index.html?base=16&columns=7&lines=A,B,C&offset=0)'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad3d921d02.png)点击加载小部件](http://csfieldguide.org.nz/_static/widgets/DR/DR-base-conversion/public_html/index.html?base=16&columns=7&lines=A,B,C&offset=0)'
- en: Which notation you use will depend on the situation; binary numbers represent
    what is actually stored, but can be confusing to read and write; hexadecimal numbers
    are a good shorthand; and decimal numbers are used if you’re trying to understand
    the meaning of the number. All three get used in computer science.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用哪种表示法取决于情况；二进制数字表示实际存储的内容，但可能难以阅读和编写；十六进制数字是一个很好的简写；十进制数字则用于理解数字的含义。这三种方式在计算机科学中都会被使用。
- en: 5.4.3\. HOW TO BINARY NUMBERS AFFECT US?
  id: totrans-616
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.3\. 二进制数对我们有什么影响？
- en: The length of a binary number determines the range of values it can represent.
    Often on computers we are dealing with text, images and sound rather than numbers,
    but they do appear in quite a few places, and the accuracy with which they are
    represented can affect what we can do on a computer.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数的长度决定了它可以表示的值的范围。在计算机上，我们通常处理的是文本、图像和声音，而不是数字，但它们确实出现在很多地方，它们的表示精度会影响我们在计算机上可以做的事情。
- en: For example, numbers in spreadsheets usually have a finite precision. Try putting
    the formula “=1/3” into a spreadsheet, and have it represented with maximum accuracy.
    How many decimal places does it store? This will be dictated by the number of
    binary digits that the spreadsheet is storing.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，电子表格中的数字通常具有有限的精度。尝试将公式“=1/3”输入电子表格，并使其以最大精度表示。它存储了多少位小数？这将由电子表格存储的二进制位数决定。
- en: Many programming languages allow the programmer to specify the number of bits
    used to represent each variable (e.g. in the C language a “short int” is 16 bits
    or more, and a “long int” is at least 32 bits); if you are working with a language
    then they could investigate limits on how numbers are represented. Note that some
    languages, including Python, seamlessly changes the size of the representation
    of an integer if it gets too large, so it’s harder to explore these issues in
    Python.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言允许程序员指定用于表示每个变量的位数（例如，在C语言中，“short int”为16位或更多，“long int”至少为32位）；如果您正在使用一种语言，则可以调查关于数字表示的限制。请注意，包括Python在内的一些语言，如果整数的表示过大，它会自动更改表示的大小，因此在Python中探索这些问题更加困难。
- en: Another situation where different numbers of bits in a representation is important
    is IP (Internet Protocol) and MAC (media access control) addresses for devices;
    the recent change from IPv4 to IPv6 was driven by the number of devices you could
    represent, and if you are interested in networks could explore the number of bits
    used for an address, and how many possible devices could exist before we run out
    of numbers.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个表示中不同位数重要的情况是设备的IP（Internet Protocol）和MAC（媒体访问控制）地址；最近从IPv4到IPv6的变化是由你可以表示的设备数量驱动的，如果你对网络感兴趣，可以探索用于地址的位数，以及在我们用完数字之前可能存在的设备数量。
- en: 5.5\. REPRESENTING IMAGES WITH BITS
  id: totrans-621
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5\. 用位表示图像
- en: Warning
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: This section assumes that you understand binary numbers. If you are confused
    by binary numbers still, you should go back to the binary numbers section and
    work through the material there again until you understand it. The first part
    of this section is possible to understand without understanding binary numbers,
    although in order to actually use the material for assessment purposes, you will
    need to understand binary numbers, as the key idea is representing colours using*bits*,
    and the bits in colours are decided based on numbers.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分假定您理解二进制数字。如果您对二进制数字感到困惑，应该返回到二进制数字部分，并再次学习那里的材料，直到您理解为止。这一部分的第一部分可能可以在不理解二进制数字的情况下理解，尽管为了实际将材料用于评估目的，您需要理解二进制数字，因为关键思想是使用*位*表示颜色，而颜色中的位取决于数字。
- en: In school or art class you may have mixed different colours of paint or dye
    together in order to make new colours. This was probably very helpful if the exact
    colour you wanted was not present in your palette, in addition to just being fun
    to experiment with! When mixing paints, red and blue would give purple. If you
    mixed yellow and blue, you would get green. If you mixed red and yellow, you would
    get orange. If you mixed an even amount of the 3 primary colours; blue, red, and
    yellow together, you should get black, although often it would be a murky brown.
    By mixing together various amounts of the three primary colours, along with white
    and black, you can make many different colours.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 在学校或美术课上，您可能已经混合了不同颜色的油漆或染料，以制造新颜色。如果您的调色板上没有您想要的确切颜色，这可能非常有帮助，除了只是很有趣地进行实验！混合油漆时，红色和蓝色会得到紫色。如果你混合黄色和蓝色，你会得到绿色。如果你混合红色和黄色，你会得到橙色。如果你将3种基本颜色——蓝色、红色和黄色的相等数量混合在一起，你应该得到黑色，尽管通常会是一种浑浊的棕色。通过混合不同数量的三原色，以及白色和黑色，你可以制造出许多不同的颜色。
- en: Actually, while the colours blue, red and yellow are commonly used in art classes,
    the very similar primary colours that work better for printing are cyan, magenta
    and yellow (CMY), which are commonly found in computer printers as well as printing
    presses. This kind of mixing is called “subtractive mixing”, because it starts
    with a white canvas or paper, and subtracts colour from it. The below interactive
    allows you to experiment with these in case you’re not familiar with them, or
    in case you just like mixing colours. We’ve also added a “black” mix; it’s not
    strictly necessary (you can get black by putting all the other colours on full),
    but it’s useful for printers because it’s such a common colour.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，尽管蓝色、红色和黄色在艺术课上常用，但更适合印刷的非常相似的原色是青色、品红和黄色（CMY），这些颜色在计算机打印机和印刷机中常见。这种混合称为“减法混合”，因为它从白色画布或纸张开始，并从中减去颜色。下面的交互允许您尝试这些颜色，以防您不熟悉它们，或者只是喜欢混合颜色。我们还添加了一个“黑色”混合；虽然不是绝对必要的（您可以通过将所有其他颜色设置为最大值来获得黑色），但对于打印机来说很有用，因为它是一种常见颜色。
- en: CMY COLOUR MIXER
  id: totrans-626
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CMY颜色混合器
- en: Cyan
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 青色
- en: 0182255
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 0182255
- en: Magenta
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 品红
- en: 0183255
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 0183255
- en: Yellow
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 黄色
- en: '036255'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '036255'
- en: Computer screens and related devices also rely on mixing colours, except they
    go about it in quite a different way — they use a different set of primary colours,
    because they are *additive*, starting with a black screen and adding colour to
    it. For additive colour on computers, the colours red, green and blue (RGB) are
    used. Each pixel on a screen has 3 tiny lights; one red, one green, and one blue.
    By increasing and decreasing the amount of light coming out of each of these 3
    lights, all the different colours can be made.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机屏幕和相关设备也依赖于混合颜色，只不过它们的方式大不相同 —— 它们使用一组不同的原色，因为它们是*添加*的，从黑屏开始并向其添加颜色。在计算机上的添加颜色中，使用红色、绿色和蓝色（RGB）。屏幕上的每个像素都有3个微小的灯；一个红色、一个绿色和一个蓝色。通过增加和减少这3个灯中每一个发出的光的量，可以制作出所有不同的颜色��
- en: You can try additive colours in the following interactive; try different combinations
    of each slider. How do you generate yellow? What happens if they are all at zero?
    All at full value (255)? Halfway? What happens if one colour is at full, and the
    other two are at halfway? How do you get shades of purple, yellow, orange, and
    pink? What happens when you have the same amount of each colour? How do you get
    black? How do you get white?
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下交互中尝试添加颜色；尝试每个滑块的不同组合。如何生成黄色？如果它们全部为零会发生什么？全部为最大值（255）会怎样？中间值呢？如果一种颜色为最大值，另外两种颜色为中间值会怎样？如何获得紫色、黄色、橙色和粉色的色调？当每种颜色数量相同时会发生什么？如何获得黑色？如何获得白色？
- en: The key idea is that you can specify the colour of a pixel using three numbers.
    In the above example, each number is from 0 to 255\. With 256 possible values
    for each of the three components, that gives 256 x 256 x 256 = 16,777,216 possible
    colours, which is more than the human eye can detect. In other words, using just
    three numbers, you can specify pretty much any colour you want — and probably
    a lot that you don’t.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 关键思想是您可以使用三个数字指定像素的颜色。在上面的示例中，每个数字的范围是从0到255。对于每个三个组件有256个可能的值，这给出了256 x 256
    x 256 = 16,777,216 种可能的颜色，这比人眼能够检测到的颜色还要多。换句话说，只需三个数字，您就可以指定几乎任何您想要的颜色 —— 也可能有很多您不想要的颜色。
- en: Of course, a computer screen or printout doesn’t have just one colour on it
    — it has millions of small pixels, each of which has a particular colour.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，计算机屏幕或打印品上不只有一种颜色 —— 它有数百万个小像素，每个像素都有特定的颜色。
- en: The following interactive allows you to zoom in on an image to see the pixels
    that are used to represent it. Each pixel is a solid colour square, and the computer
    needs to store the colour for each pixel. If you zoom in far enough, the interactive
    will show you the red-green-blue values for each pixel. You can pick a pixel and
    put the values on the slider above - it should come out as the same colour as
    the pixel.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 以下交互允许您放大图像以查看用于表示它的像素。每个像素都是一个实色正方形，计算机需要为每个像素存储颜色。如果您放大到足够程度，交互将向您显示每个像素的红绿蓝值。您可以选择一个像素并将值放在上面的滑块上
    - 它应该与像素的颜色相同。
- en: '[![](563ad3d6b6ddd.png)Click to load'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad3d6b6ddd.png)点击加载'
- en: Pixel Interactive](http://csfieldguide.org.nz/_static/interactives/dr/pixel-values/index.html)
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 像素交互](http://csfieldguide.org.nz/_static/interactives/dr/pixel-values/index.html)
- en: '**Jargon Buster**'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '**术语解释**'
- en: The word **pixel** is short for “picture element”. On computer screens and printers
    an image is created by a grid of pixels, each one set to the required colour.
    A pixel is typically a fraction of a millimeter across, and images can be made
    up of millions of pixels (one megapixel is a million pixels).
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: “像素”一词缩写为“picture element”。在计算机屏幕和打印机上，图像是由像素网格创建的，每个像素设置为所需的颜色。一个像素通常跨越几分之一毫米，并且图像可以由数百万像素组成（一个百万像素等于一百万像素）。
- en: '[![](563ad3d5a5a58.jpg)](http://commons.wikimedia.org/wiki/File:Pixel_geometry_01_Pengo.jpg#file)'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad3d5a5a58.jpg)](http://commons.wikimedia.org/wiki/File:Pixel_geometry_01_Pengo.jpg#file)'
- en: '**Curiosity**'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '**好奇心**'
- en: The human eye has millions of light sensors in it, and the ones that detect
    colour are called “cones”. There are three different kinds of cones, which detect
    red, blue, and green light respectively. Colours are perceived by the amount of
    red, blue, and green light in them. Computer screen pixels take advantage of this
    by releasing the amounts of red, blue, and green light that will be perceived
    as the desired colour by your eyes. So when you see “purple”, it’s really the
    red and blue cones in your eyes being stimulated, and your brain converts that
    to a perceived colour.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 人眼中有数百万个光感受器，其中检测颜色的被称为“锥体”。有三种不同类型的锥体，分别检测红色、蓝色和绿色光。颜色通过其中的红色、蓝色和绿色光的量来感知。计算机屏幕像素通过释放红色、蓝色和绿色光的量来利用这一点，这些光将被您的眼睛感知为所需的颜色。所以当你看到“紫色”时，实际上是刺激了你眼睛中的红色和蓝色锥体，而你的大脑将其转化为一种感知到的颜色。
- en: For more information about RGB displays, see [RGB on Wikipedia](http://en.wikipedia.org/wiki/Rgb);
    for more information about the eye sensing the three colours, see [Cone cell](http://en.wikipedia.org/wiki/Cone_cell) and [trichromacy](http://en.wikipedia.org/wiki/Trichromacy) on
    Wikipedia.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 有关RGB显示的更多信息，请参阅[Wikipedia上的RGB](http://en.wikipedia.org/wiki/Rgb)；有关眼睛感知三种颜色的更多信息，请参阅Wikipedia上的[Cone
    cell](http://en.wikipedia.org/wiki/Cone_cell)和[trichromacy](http://en.wikipedia.org/wiki/Trichromacy)。
- en: Even the smallest computer screens have millions of *pixels* on them, and the
    computer needs to represent a colour for each one of those pixels. These days
    photographs are measured in *megapixels* (millions of pixels). To store the image,
    your computer is storing a colour for every one of those pixels, and each of those
    could be using the three numbers above. So a 2 megapixel photo, in its simplest
    form, needs 6 million numbers to be recorded to represent it accurately.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最小的计算机屏幕上也有数百万个*像素*，计算机需要为每个像素表示一种颜色。如今，照片的尺寸是以*百万像素*（百万像素）为单位的。为了存储图像，您的计算机正在为其中的每一个像素存储一种颜色，并且其中的每一个像素都可以使用上述三个数字。因此，一个2百万像素的照片，在其最简单的形式中，需要记录600万个数字才能准确表示它。
- en: 5.5.1\. REPRESENTING HIGH QUALITY IMAGES USING BITS
  id: totrans-647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1\. 使用位表示高质量图像
- en: So now, how can computers represent each possible colour using bits? You may
    have noticed in the above interactive that for each of red, green, and blue, there
    are 256 different positions the slider can be in (don’t forget to include setting
    the slider to 0). From the numbers section, you may remember that to get 256 different
    possibilities, you need 8 bits. So for example, to represent the current value
    of the red slider, you would need 8 bits (28 = 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 =
    256).
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在，计算机如何使用位来表示每种可能的颜色呢？您可能已经注意到，在上面的交互式中，对于红色、绿色和蓝色，滑块可以有256个不同的位置（不要忘记将滑块设置为0）。从数字部分，您可能记得要获得256种不同的可能性，您需要8位。所以例如，要表示红色滑块的当前值，您需要8位（28
    = 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 = 256）。
- en: Because there are three primary colours, each of which has 256 different possible
    values, we need 24 bits in order to have enough possible bit patterns to represent
    all the possible colours that this scheme can represent (3 x 8 = 24).
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有三种原色，每种原色都有256种不同的可能值，所以我们需要24位才能有足够的可能位模式来表示此方案可以表示的所有可能颜色（3 x 8 = 24）。
- en: If you calculate 224 (i.e. the number of bit patterns you can get with 24 bits),
    and 256 x 256 x 256 (i.e. the number of possible colours that can be represented
    using the above interactive), you will find that the result of these two calculations
    are the same; 16,777,216\. This means that there are 16,777,216 different possible
    colours that can be represented using this scheme, and that’s more colours than
    most people can distinguish, which is why 24-bit colour is regarded as high quality.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计算 224（即使用 24 位可以获得的位模式数量）和 256 x 256 x 256（即上述交互中可以表示的可能颜色的数量），你会发现这两个计算的结果是相同的；16,777,216。这意味着使用这种方案可以表示
    16,777,216 种不同的可能颜色，这比大多数人能够区分的颜色还要多，这就是为什么 24 位颜色被视为高质量的原因。
- en: So now that we know we’ll need 24 bits to represent all the possible colours
    that can be made from the scheme in the interactive, how can we assign colours
    to bit patterns?
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们需要 24 位来表示从交互方案中可以制作出的所有可能颜色，那么我们如何将颜色分配给位模式呢？
- en: A sensible way is to use 3 binary numbers that represent the amount of each
    of red, green, and blue in the pixel. In order to do this, you can simply convert
    the decimal values on the interactive that specify how much of each of the primary
    colours is making up the resulting colour into binary, and put them side by side
    to make a full pattern of 24 bits. Because consistency is important in order for
    a computer to make sense of the bit pattern, the binary number for red should
    be put first, followed by green, and then finally blue.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 合理的方法是使用 3 个二进制数来表示每个像素中的红色、绿色和蓝色的量。为了做到这一点，你可以简单地将指定结果颜色中每种基本颜色的数量的十进制值转换为二进制，并将它们并排放置以形成
    24 位的完整模式。因为一致性对于计算机理解位模式是很重要的，所以红色的二进制数应该首先放置，然后是绿色，最后是蓝色。
- en: '![](563ad3d4a9804.png)'
  id: totrans-653
  prefs: []
  type: TYPE_IMG
  zh: '![图片](563ad3d4a9804.png)'
- en: As an example, suppose you have the colour that has red = 145, green = 50, and
    blue = 123 (it is a shade of purple shown in the square above; you can see it
    if you set the sliders to those values in the interactive above). You need to
    convert each of the 3 numbers into binary, using 8 bits for each. You can either
    do this by hand if you are confident with binary numbers, use [this binary number
    interactive with 8 columns](http://csfieldguide.org.nz/_static/widgets/DR/DR-base-conversion/public_html/index.html?base=16&columns=7&lines=A,B,C&offset=0),
    or use a [binary piano](http://csfieldguide.org.nz/_static/files/DR-BinaryPianoUC.pdf).
    You should get red = 10010001, green = 00110010, and blue = 01111011\. This can
    be written as 100100010011001001111011, which is the bit pattern for representing
    that shade of purple. Note that there are no spaces between the 3 numbers, as
    this is a pattern of bits rather than actually being 3 binary numbers, and computers
    don’t have any such concept of a space between bit patterns anyway — everything
    must be a 0 or a 1\. You could write it with spaces to make it easier to read,
    and to represent the idea that they are likely to be stored in 3 8-bit bytes,
    but inside the computer memory there is just a sequence of high and low voltages,
    so even writing 0 and 1 is an arbitrary notation. Note that all leading and trailing
    0’s on each of the components are kept — without them, it would be representing
    a shorter number. Make sure you work through this example yourself, to understand
    how it works.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你有一个颜色，其中红色 = 145，绿色 = 50，蓝色 = 123（它是上面方块中显示的一种紫色；如果你将滑块设置为这些值，你就可以看到它）。你需要将每个
    3 个数字转换为二进制，每个使用 8 位。你可以手工操作，如果你对二进制数字很有信心，使用 [这个具有 8 列的二进制数交互](http://csfieldguide.org.nz/_static/widgets/DR/DR-base-conversion/public_html/index.html?base=16&columns=7&lines=A,B,C&offset=0)，或者使用
    [二进制钢琴](http://csfieldguide.org.nz/_static/files/DR-BinaryPianoUC.pdf)。你应该得到红色
    = 10010001，绿色 = 00110010，蓝色 = 01111011。这可以写为 100100010011001001111011，这是表示这种紫色的位模式。请注意，3
    个数字之间没有空格，因为这是一种位模式，而不是实际的 3 个二进制数，而且计算机根本没有这种位模式之间的概念——一切都必须是 0 或 1。你可以使用空格来使其更易于阅读，并表示它们可能存储在
    3 个 8 位字节中，但在计算机内存中只是一系列高低电压，所以即使写成 0 和 1 也是一种任意的表示。请注意，每个组件上的所有前导和尾随 0 都保留了下来——如果没有它们，它将表示一个较短的数字。确保自己操作此示例，以了解其工作原理。
- en: As long as the computer knows this is a colour (typically because it has been
    taken from a file that is specifying colours, such as GIF or HTML), it will know
    that the first 8 bits specify the amount of red, the next 8 bits specify the amount
    of green, and the last 8 bits specify the amount of blue. The computer won’t actually
    convert the number into decimal, as it works with the binary directly — most of
    the process that takes the bits and makes the right pixels appear is typically
    done by a graphics card or a printer.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 只要计算机知道这是一种颜色（通常是因为它是从指定颜色的文件中获取的，比如GIF或HTML），它就会知道前8位指定红色的量，接下来的8位指定绿色的量，最后的8位指定蓝色的量。计算机实际上不会将数字转换为十进制，因为它直接使用二进制——大部分将位转换为正确像素的过程通常由显卡或打印机完成。
- en: 24 bit colour is sometimes referred to in settings as “True Color” (because
    it is more accurate than the human eye can see). On Apple systems, it is called
    “Millions of colours”.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 24位颜色有时在设置中被称为“真彩色”（因为它比人眼能看到的更准确）。在苹果系统中，它被称为“百万色”。
- en: 5.5.2\. HEXADECIMAL COLOUR CODES
  id: totrans-657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.2. 十六进制颜色代码
- en: 'When writing HTML code, you often need to specify colours for text, backgrounds,
    etc. One way of doing this is to specify the colour name, for example “red”, “blue”,
    “purple”, or “gold”. The use of names limits the number of colours you can represent
    and the shade might not be exactly the one you wanted. A better way is to specify
    the 24 bit colour directly. The problem is that strings of 24 binary digits are
    hard to read, and so colours in HTML use hexadecimal codes as a quick way to write
    the 24 bits, for example #00FF9E. The hash sign just means that it should be interpreted
    as a hexadecimal representation, and since each hexadecimal digit corresponds
    to 4 bits, the 6 digits represent 24 bits of colour information. This “hex triplet”
    format is used in HTML pages to specify colours for things like the background
    of the page, the text, and the colour of links. It is also used in CSS, SVG, and
    other applications.'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写HTML代码时，通常需要为文本、背景等指定颜色。一种方法是指定颜色名称，例如“红色”、“蓝色”、“紫色”或“金色”。使用名称会限制您可以表示的颜色数量，而且颜色可能不会完全符合您想要的颜色。更好的方法是直接指定24位颜色。问题在于，24位二进制数字串很难阅读，因此HTML中的颜色使用十六进制代码作为快速编写24位的方法，例如#00FF9E。井号只是表示应将其解释为十六进制表示，由于每个十六进制数字对应4位，6个数字表示24位颜色信息。这种“十六进制三元组”格式用于HTML页面中指定诸如页面背景、文本和链接颜色之类的颜色。它还用于CSS、SVG和其他应用程序。
- en: 'In the 24 bit colour example earlier, the 24 bit pattern was 100100010011001001111011\.
    This can be broken up into groups of 4 bits: 1001 0001 0011 0010 0111 1011\. Substituting
    a hexadecimal digit for each of the 4-bit groups (using the table above) gives
    91327B. This is the hexadecimal code for this colour!'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的24位颜色示例中，24位模式为100100010011001001111011。这可以分成4位组：1001 0001 0011 0010 0111
    1011。为每个4位组替换一个十六进制数字（使用上面的表）得到91327B。这是这种颜色的十六进制代码！
- en: The hexadecimal notation is extremely useful for people to read or write, as
    it is much easier to type 6 characters rather than 24 1’s and 0’s when specifying
    a colour!
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制表示法对于人们阅读或编写非常有用，因为在指定颜色时，键入6个字符要比键入24个1和0要容易得多！
- en: 'For example, to specify the background colour of a page in HTML, the body tag
    can have a hexadecimal colour added to it like this:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在HTML中指定页面背景颜色，body标签可以添加一个十六进制颜色，如下所示：
- en: '[PRE11]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can use an HTML page to experiment with hexadecimal colours.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用HTML页面来尝试使用十六进制颜色。
- en: Understanding how these hexadecimal colour codes are derived also allows you
    to change them slightly without having to refer back the colour table, when the
    colour isn’t exactly the one you want. Remember that in the 24 bit color code,
    the first 8 bits specify the amount of red (so this is the first 2 digits of the
    hexadecimal code), the next 8 bits specify the amount of green (the next 2 digits
    of the hexadecimal code), and the last 8 bits specify the amount of blue (the
    last 2 digits of the hexadecimal code). To increase the amount of any one of these
    colours, you can change the appropriate hexadecimal letters.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些十六进制颜色代码是如何派生的还允许您稍微更改它们，而无需参考颜色表，当颜色不完全符合您想要的颜色时。请记住，在24位颜色代码中，前8位指定红色的量（因此这是十六进制代码的前2位数字），接下来的8位指定绿色的量（十六进制代码的下2位数字），最后的8位指定蓝色的量（十六进制代码的最后2位数字）。要增加任何一种颜色的量，您可以更改相应的十六进制字母。
- en: 'For example, #000000 has zero for red, green and blue, so setting a higher
    value to the middle two digits (such as #002300) will add some green to the colour.
    What colours will the following codes give? #FF0000, #FF00FF, #FFFFFF ? (You can
    try them out using an HTML file).'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '举例来说，#000000 代表红、绿、蓝三种颜色都为零，所以将中间两位数字设为较高的值（如 #002300）会加入一些绿色到颜色中。以下代码会产生什么颜色？#FF0000，#FF00FF，#FFFFFF？（你可以使用
    HTML 文件尝试它们）。'
- en: 5.5.3\. REPRESENTING COLOURS USING FEWER BITS
  id: totrans-666
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.3\. 使用更少的位表示颜色
- en: What if we were to use fewer than 24 bits to represent each colour, i.e. each
    slider didn’t have as many possible positions it could be in? The following interactive
    shows what would happen with this limitation. You can select a colour by clicking
    on the image on the left, and then try to match it with the 24-bit colour sliders
    (if it’s too difficult, the system will offer to help you; to move the sliders
    by small amounts, you can use the arrow keys).
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用少于24位来表示每种颜色，即每个滑块没有那么多可能的位置会发生什么？以下交互式展示了受到此限制时会发生什么。您可以通过点击左侧的图像来选择颜色，然后尝试使用24位颜色滑块来匹配它（如果太困难，系统将提供帮助；要以小幅度移动滑块，您可以使用箭头键）。
- en: It should be possible to get a perfect match using 24 bit colour. Now try the
    8-bit sliders. These ones have only 8 values for red and green, and just 4 values
    for blue!
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 使用24位颜色应该可以获得完美匹配。现在尝试8位滑块。这些滑块只有8个红色和绿色值，蓝色只有4个值！
- en: The above system used 3 bits to specify the amount of red (8 possible values),
    3 bits to specify the amount of green (again 8 possible values), and 2 bits to
    specify the amount of blue (4 possible values). This gives a total of 8 bits (hence
    the name), which can be used to make 256 different bit patterns, and thus can
    represent 256 different colours.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 上述系统使用3位来指定红色的量（8个可能值），3位来指定绿色的量（同样是8个可能值），以及2位来指定蓝色的量（4个可能值）。这总共是8位（因此得名），可用于生成256种不同的位模式，因此可以表示256种不同的颜色。
- en: 'Using this scheme to represent all the pixels of an image takes one third of
    the number of bits required for 24-bit colour, but it is not as good at showing
    smooth changes of colours or subtle shades, because there are only 256 possible
    colors for each pixel. This is one of the big tradeoffs in data representation:
    do you allocate less space (fewer bits), or do you want higher quality?'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方案来表示图像的所有像素仅需24位色彩所需位数的三分之一，但它不太适合显示颜色的平滑变化或微妙的色调，因为每个像素仅有256种可能的颜色。这是数据表示中的一个重要权衡：你是分配更少的空间（更少的位），还是要更高的质量？
- en: '**Jargon Buster**'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '**行话解释**'
- en: The number of bits used to represent the colours of pixels in a particular image
    is sometimes referred to as its “colour depth” or “bit depth”. For example, an
    image or display with a colour depth of 8-bits has a choice of 256 colours for
    each pixel. There is [more information about this in Wikipedia](http://en.wikipedia.org/wiki/Color_depth).
    Drastically reducing the bit depth of an image can make it look very strange;
    sometimes this is used as a special effect called “posterisation” (ie. making
    it look like a poster that has been printed with just a few colours).
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 用于表示特定图像像素颜色的位数有时被称为其“颜色深度”或“位深度”。例如，具有8位颜色深度的图像或显示器每个像素有256种颜色选择。在维基百科中有关此的[更多信息](http://en.wikipedia.org/wiki/Color_depth)。大幅减少图像的位深度可能会使其看起来非常奇怪；有时这被用作名为“色调分离”的特殊效果（即使其看起来像是只用几种颜色印刷的海报）。
- en: The following interactive shows what happens to images when you use a smaller
    range of colours (including right down to zero bits!) You can choose an image
    using the menu. In which cases is the change in quality most noticeable? In which
    is it not? In which would you actually care about the colours in the image? In
    which situations is colour actually not necessary (i.e. we are fine with two colours)?
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 以下交互式展示了当您使用更少的颜色范围（甚至可以降至零位！）时图像会发生什么变化。您可以使用菜单选择图像。在哪些情况下变化最为明显？哪些情况下不是？您实际上关心图像中的颜色吗？在哪些情况下颜色实际上并不必要（即我们只需要两种颜色）？
- en: One other interesting thing to think about is whether or not we’d want more
    than 24 bit colour. It turns out that the human eye can only differentiate around
    10 million colours, so the 16 million provided by 24 bit colour is already beyond
    what our eyes can distinguish. However, if the image were to be processed by some
    software that enhances the contrast, it may turn out that 24-bit colour isn’t
    sufficient. Choosing the representation isn’t simple!
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的问题是我们是否需要超过24位颜色。事实证明，人眼只能区分大约1000万种颜色，所以24位颜色提供的1600万种颜色已经超出了我们眼睛可以区分的范围。然而，如果图像被某些增强对比度的软件处理，可能会发现24位颜色不够。选择表示形式并不简单！
- en: So is it worth the space saving to put up with a lower quality image? An image
    represented using 24 bit colour would have 24 bits per pixel. In 600 x 800 pixel
    image (which is a reasonable size for a photo), this would contain 600 x 800 =
    480,000 pixels, and thus would use 480,000 x 24 bits = 11,520,000 bits. This works
    out to around 1.44 megabytes. If we use 8-bit colour instead, it will use a third
    of the memory, so it would save nearly a megabyte of storage.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为了节省空间而忍受质量较低的图像值得吗？使用24位颜色表示的图像每个像素有24位。在600 x 800像素的图像中（这对于一张照片来说是一个合理的大小），这将包含600
    x 800 = 480,000像素，因此将使用480,000 x 24位 = 11,520,000位。这大约相当于1.44兆字节。如果我们改用8位颜色，它将使用三分之一的内存，因此将节省近1兆字节的存储空间。
- en: 8 bit colour is not used much anymore, although it can still be helpful in situations
    such as accessing a computer desktop remotely on a slow internet connection, as
    the image of the desktop can instead be sent using 8 bit colour instead of 24
    bit colour. Even though this may cause the desktop to appear a bit strangely,
    it doesn’t stop you from getting whatever it was you needed to get done, done.
    There are also other situations where colour doesn’t matter at all, for example
    diagrams, and black and white printed images.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 8位颜色不再经常使用，尽管在某些情况下仍然有用，比如在慢速互联网连接上远程访问计算机桌面时，可以使用8位颜色而不是24位颜色发送桌面图像。尽管这可能导致桌面看起来有点奇怪，但这并不妨碍你完成需要完成的任务。还有其他一些情况，颜色根本不重要，例如图表和黑白打印图像。
- en: If space really is an issue, then this crude method of reducing the range of
    colours isn’t usually used; instead, compression methods such as JPEG, GIF and
    PNG are used. These make much more clever compromises to reduce the space that
    an image takes, without making it look so bad, including choosing a better palette
    of colours to use rather than just using the simple representation discussed above.
    However, compression methods require a lot more processing, and images need to
    be decoded to the representations discussed in this chapter before they can be
    displayed. We will look at compression methods in a later chapter. The ideas in
    this present chapter more commonly come up when designing systems (such as graphics
    interfaces) and working with high-quality images (such as RAW photographs), and
    typically the goal is to choose the best representation possible without wasting
    too much space.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 如果空间确实是一个问题，那么减少颜色范围的这种粗糙方法通常不会被使用；相反，会使用诸如JPEG、GIF和PNG之类的压缩方法。这些方法做出更加巧妙的妥协，以减少图像占用的空间，而不会使其看起来那么糟糕，包括选择更好的颜色调色板，而不仅仅使用上面讨论的简单表示。然而，压缩方法需要更多的处理，图像需要被解码为本章讨论的表示形式，然后才能显示出来。我们将在后面的章节中讨论压缩方法。本章中的思想更常见地出现在设计系统（如图形界面）和处理高质量图像（如RAW照片）时，通常的目标是选择最佳的表示形式，而不浪费太多空间。
- en: For the purposes of the New Zealand NCEA standards, reducing the bit depth of
    an image is ok as a second compression method to compare to specialised compression
    methods (JPEG, PNG, GIF etc.), but isn’t very suitable for explaining how compression
    works (in the Achieved level requirements).
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新西兰NCEA标准，减少图像的位深度作为与专门的压缩方法（JPEG、PNG、GIF等）进行比较的第二种压缩方法是可以接受的，但不太适合解释压缩原理（在达到水平要求中）。
- en: Now that you know how the 24 bit and 8 bit colour schemes work and how to represent
    them using bits, what are the implications of this in practice? The following
    interactive can be used to upload your own image, and experiment with allocating
    different numbers of bits to each colour. You can use it to demonstrate the effect
    of the different numbers of bits for this data representation.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了24位和8位颜色方案的工作原理以及如何使用位表示它们，那么这在实践中意味着什么？以下交互式内容可用于上传您自己的图像，并尝试为每种颜色分配不同数量的位。您可以使用它来演示不同位数对此数据表示的影响。
- en: 5.6\. GENERAL REPRESENTATIONS OF TEXT
  id: totrans-680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6\. 文本的一般表示
- en: In the introduction we looked at 8-bit ASCII representations of text (which
    really use 7 bits, allowing for 128 different symbols). As with any other kind
    of data represented in binary, we can get improvements by considering larger (or
    smaller) representations.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍中，我们看到了文本的8位ASCII表示（实际上使用了7位，允许128个不同的符号）。与任何其他以二进制表示的数据一样，考虑更大（或更小）的表示形式可以获得改进。
- en: In the [*curiosity section*](http://csfieldguide.org.nz/DataRepresentation.html#curiosity-music) earlier
    we observed that 5 bits are sufficient for simple coding of the English alphabet,
    and for very slow coding systems (like the [video that contains hidden text using
    musical notes](http://www.youtube.com/watch?v=L-v4Awj_p7g)) using 5 bits instead
    of 8 can save some time. The braille system uses only 6 bits for each character,
    which allows for 64 different characters, and it is also better than using 8 bits
    since it would take more paper and more time to read if the longer code was used.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*好奇心部分*](http://csfieldguide.org.nz/DataRepresentation.html#curiosity-music)中，我们观察到5位对于简单编码英文字母以及对于非常慢的编码系统（例如使用音符隐藏文本的视频）是足够的，使用5位而不是8位可以节省一些时间。盲文系统每个字符仅使用6位，允许64个不同的字符，这也比使用8位更好，因为如果使用更长的代码，则需要更多纸张和更多时间来阅读。
- en: But some languages have way more than 32, or 64, or even 128 characters in their
    alphabet. In fact, the majority of the world’s population use such languages!
    In this case, longer codes are needed, and the most widely used approach is a
    system called *Unicode*. A commonly used version of Unicode allows 16 bits per
    character. Because every extra bit that is added doubles the number of patterns
    possible, 16-bit codes have many more representations than 8 bit codes. In fact,
    with 16 bits there are 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x
    2 x 2 = 216 = 65,536 patterns that can be represented. This is enough to assign
    a unique pattern of bits to the main characters in the most common languages,
    although there are also standards that allow 32 bits (4 bytes) for each character.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 但是一些语言的字母表中的字符数量远远超过32、64甚至128个。事实上，世界上大多数人口使用这样的语言！在这种情况下，需要更长的代码，而最常用的方法是一种称为*Unicode*的系统。常用的Unicode版本允许每个字符使用16位。因为每增加一个额外的位数都会使可能的模式数量加倍，16位代码比8位代码有更多的表示形式。事实上，使用16位有2
    x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 = 216 = 65,536种可以表示的模式。这足以为最常见的语言中的主要字符分配唯一的位模式，尽管也有允许每个字符使用32位（4字节）的标准。
- en: The Unicode table is far too big to display in this book, but you can find a
    variety of tables on the internet, and use them to look up codes. [This website
    displays all unicode characters](http://unicode-table.com/en/) with geographical
    data for appropriate characters. The 16- and 32-bit codes are usually written
    using hexadecimal since this is an easy abbreviation for the long binary codes,
    and sections of the Unicode alphabet (different languages) tend to be in multiples
    of 16.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode表太大，无法在本书中显示，但您可以在互联网上找到各种表格，并使用它们查找代码。[这个网站显示所有Unicode字符](http://unicode-table.com/en/)，并提供适当字符的地理数据。16位和32位代码通常使用十六进制编写，因为这是长二进制代码的简便缩写，Unicode字母表的部分（不同语言）往往是16的倍数。
- en: The modern codes associated with Unicode are usually flexible in the size of
    the representation, so 8-bit characters can be used if that is sufficient, but
    16- or 32- bit characters can be invoked for larger alphabets. If you are investigating
    these codes, you will come across standards such as the Universal Character Set
    (UCS), the Unicode/UCS Transformation Format (UTF-8 UTF-16, etc.), and the GB
    18030 standard (which was mandated in the People’s Republic of China from the
    year 2000).
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 与Unicode相关的现代代码通常在表示大小上很灵活，因此如果足够的话可以使用8位字符，但对于更大的字母表，可以调用16位或32位字符。如果你正在研究这些代码，你会遇到诸如通用字符集（UCS）、Unicode/UCS转换格式（UTF-8、UTF-16等）以及GB
    18030标准（从2000年起在中华人民共和国强制实施）等标准。
- en: 5.7\. COMPUTERS REPRESENTING NUMBERS IN PRACTICE
  id: totrans-686
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7\. 计算机中的数字表示实践
- en: A common place that numbers are stored on computers is in spreadsheets or databases.
    Some of the things that we might think of as numbers, such as the telephone number
    (03) 555-1234, aren’t actually stored as numbers, as they contain important characters
    (like dashes and spaces) as well as the leading 0 which would be lost if it was
    stored as a number (the above number would come out as 35551234, which isn’t quite
    right). On the other hand, things that don’t look like a number (such as “30 January
    2014”) are often stored using a value that is converted to a format that is meaningful
    to the reader (try typing two dates into Excel, and then subtract one from the
    other — the result is a useful number). Numbers are commonly used to store things
    as diverse as student marks, prices, statistics, and scientific readings.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机上存储数字的常见地方是电子表格或数据库。我们可能认为的一些东西，比如电话号码（03）555-1234，并不实际存储为数字，因为它们包含重要字符（如破折号和空格），以及前导0，如果存储为数字则会丢失（上述号码将显示为35551234，这不太正确）。另一方面，看起来不像数字的东西（如“2014年1月30日”）通常使用转换为对读者有意义的格式的值来存储（尝试在Excel中输入两个日期，然后相减——结果是一个有用的数字）。数字通常用于存储诸如学生分数、价格、统计数据和科学读数等各种事物。
- en: Any system that stores numbers needs to make a compromise between the number
    of bits allocated to store the number, and the range of values that can be stored.
    For example, Excel spreadsheets have a maximum value that can be stored — try
    calculating 1/3, and display it to as many places of accuracy as possible. In
    some systems (like the Java and C programming languages and databases) it’s possible
    to specify how accurately numbers should be stored; in others it is fixed in advance
    (such as in spreadsheets). Some are able to work with arbitrarily large numbers
    by increasing the space used to store them as necessary (e.g. integers in the
    Python programming language).
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 任何存储数字的系统都需要在存储数字的位数和可存储值的范围之间做出妥协。例如，Excel电子表格有一个可以存储的最大值——尝试计算1/3，并尽可能多地显示精度。在一些系统中（如Java和C编程语言和数据库），可以指定存储数字的精度；在其他系统中，精度是提前固定的（例如在电子表格中）。一些系统可以通过根据需要增加用于存储它们的空间来处理任意大的数字（例如Python编程语言中的整数）。
- en: 'There are two commonly used kinds of numbers: integers and floating point numbers.
    Integers are what you might know as whole numbers, and can be positive or negative,
    whereas floating point numbers can have a decimal point in them, and can also
    be positive or negative. In this section we are just going to focus on integers,
    as representing floating point numbers is a bit more difficult to understand (but
    well worth understanding if you use them a lot)!'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种常用的数字类型：整数和浮点数。整数是你可能知道的整数，可以是正数或负数，而浮点数可以包含小数点，并且也可以是正数或负数。在本节中，我们将专注于整数，因为表示浮点数更难理解（但如果你经常使用它们，理解它们是非常值得的）！
- en: The binary number representation in the previous section only allowed us to
    represent positive numbers. In practice, we will want to be able to represent
    negative numbers as well (such as when the amount of money earned goes to a negative
    amount, or the temperature falls below zero!) In our normal representation of
    base 10 numbers, we represent negative numbers by putting a minus sign in front
    of the number. On a computer we don’t have minus signs, but we can do it by allocating
    one extra bit, called a *sign* bit, to represent the minus sign. We can choose
    the leftmost bit as the sign bit — when the sign bit is set to “0”, that means
    the number is positive and when the sign bit is set to “1”, the number is negative
    (just as if there were a minus sign in front of it). For example, if we wanted
    to represent the number 41 using 6 bits (like above) along with an additional
    7th bit that is the sign bit, assuming the sign bit is first, we would represent
    it by 0101001\. The first bit is a 0, meaning the number is positive, then the
    remaining 6 bits give 41, meaning the number is +41\. If we wanted to make -59,
    this would be 1111011\. The first bit is a 1, meaning the number is negative,
    and then the remaining 6 bits give 59, meaning the number is -59.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中的二进制数表示中，我们只能表示正数。在实践中，我们也希望能够表示负数（比如当赚得的钱数变成负数，或者温度降到零以下时！）。在我们对十进制数的正常表示中，我们通过在数字前面加上一个减号来表示负数。在计算机上，我们没有减号，但我们可以通过分配一个额外的位，称为*符号*位，来表示减号。我们可以选择最左边的位作为符号位
    — 当符号位设置为“0”时，意味着数字是正数，当符号位设置为“1”时，数字是负数（就好像前面有一个减号）。例如，如果我们想用6位（如上所述）来表示数字41，并且额外添加第7位作为符号位，假设符号位在最前面，我们会用0101001来表示它。第一位是0，表示数字是正数，然后剩下的6位给出41，表示数字是+41。如果我们想表示-59，那么就是1111011。第一位是1，表示数字是负数，然后剩下的6位给出59，表示数字是-59。
- en: Using 7 bits as described above (one for the sign, and 6 for the actual number),
    what would be the binary representations for 1, -1, -8, 34, -37, -88, and 102?
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述描述的7位（一个用于符号，6个用于实际数字），数字1，-1，-8，34，-37，-88和102的二进制表示分别是什么？
- en: Suppose we have 8-bit numbers, with the left-most bit as a sign bit. What would
    the decimal values be for the following 10000110? 01111111? How about 10000000?
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有8位数字，最左边的位作为符号位。对于以下数字10000110，01111111，它们的十进制值分别是多少？10000000呢？
- en: The representation 10000000 highlights a problem with this notation, as it represents
    the number -0, which is the same as 0\. That is, there are two ways to represent
    the number 0, which is wasteful, and potentially confusing.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 表示10000000突显了这种表示法的一个问题，因为它表示的是-0，与0相同。也就是说，有两种表示数字0的方式，这是浪费的，也可能会引起混淆。
- en: It turns out that there’s a notation called “two’s complement” for negative
    numbers, which avoids this wastage, and more importantly, makes it easier to do
    arithmetic with negative numbers. It’s beyond what is needed for this topic, but
    the following box gives some more information if you’d like to look into it.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 原来有一种称为“二进制补码”的负数表示法，可以避免这种浪费，更重要的是，使得负数的算术运算更容易。这超出了本主题所需的范围，但以下内容提供了一些更多信息，如果您想了解更多，请查看以下内容。
- en: '**Extra for Experts**'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '**专家额外内容**'
- en: 'Negative numbers are more often stored on computers using a system called “two’s
    complement”. This system makes it very easy to do arithmetic without having to
    treat negative numbers as a special case, so it’s faster and uses less circuitry.
    The principle is based on a fairly simple idea: for example, in decimal, if you
    had to subtract the number 4 from a value, it’s the same if you add 6 and subtract
    10\. Using the complement of the number -4 (i.e. 6) plus an indicator that it’s
    negative can make calculations quicker and simpler. A similar approach applies
    in binary, and it’s even easier because there are only two digits. More[information
    is available here on how negative numbers work](http://www.i-programmer.info/babbages-bag/200-binary-negative-numbers.html?start=1),
    and also on the [Wikipedia page about two’s complement](http://en.wikipedia.org/wiki/Two%27s_complement),
    although it’s quite technical.'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 负数更常使用一种称为“二进制补码”的系统在计算机上存储。这个系统使得进行算术运算变得非常容易，无需将负数视为特殊情况，因此速度更快，电路使用量更少。该原理基于一个相当简单的思想：例如，在十进制中，如果你需要从一个值中减去4，那么如果你加6并减去10，结果是一样的。使用数字-4（即6）的补码以及表示其为负数的指示符可以使计算更快，更简单。类似的方法也适用于二进制，并且更简单，因为只有两个数字。关于负数运算的更多[信息请点击此处](http://www.i-programmer.info/babbages-bag/200-binary-negative-numbers.html?start=1)，以及关于[二进制补码的维基百科页面](http://en.wikipedia.org/wiki/Two%27s_complement)上也有，尽管内容相当技术性。
- en: '**Curiosity**'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '**好奇心**'
- en: In some programming languages there isn’t a check for when a number gets too
    big (overflows). For example, if you have an 8-bit number using two’s complement,
    then 01111111 is the largest number (127), and if you add one without checking,
    it will change to 10000000, which happens to be the number -128\. This can cause
    serious problems if not checked for, and is behind a variant of the Y2K problem,
    called the [Year 2038 problem](http://en.wikipedia.org/wiki/Year_2038_problem),
    involving a 32-bit number overflowing for dates on Tuesday, 19 January 2038.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些编程语言中，没有检查数字是否变得太大（溢出）的检查。例如，如果你有一个使用二进制补码的8位数字，那么01111111是最大的数字（127），如果不进行检查地加1，它将变成10000000，这恰好是数字-128。如果没有进行检查，这可能会导致严重的问题，并且是Y2K问题的一个变体，称为[2038年问题](http://en.wikipedia.org/wiki/Year_2038_problem)，涉及到32位数字在2038年1月19日星期二的日期溢出。
- en: '[![](563ad3d4208cc.png)](http://xkcd.com/571/)'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad3d4208cc.png)](http://xkcd.com/571/)'
- en: Because of the way computer memory is constructed, memory is most commonly used
    in chunks of 8 bits or 32 bits (or even 64 bits) at a time. That means that if
    the computer is representing an integer as a binary number with a sign bit, it
    will commonly use 32 bits, where the first bit is the sign bit, and the other
    31 bits represent the value of the number.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 因为计算机内存的构造方式，内存通常以每次8位或32位（甚至64位）的块来使用。这意味着，如果计算机将整数表示为带有符号位的二进制数，它通常会使用32位，其中第一个位是符号位，其他31位表示数值。
- en: In a computer that uses 32 bits for a number, how many different numbers could
    it represent? What’s the largest number it could represent? Remember that every
    bit you add doubles how many numbers you can make. If you double 64 another 25
    times (so that it is up to 31 bits), i.e. 128, 256, 512, 1024, 2048.... you get
    an end result of 2,147,483,648\. This means that there 2,147,483,648 numbers that
    can be represented with 31 bits, the highest of which is 2,147,483,647\. This
    number is just over 2 billion. With the 32nd bit, the sign bit, this means that
    the number can be positive or negative. This is called a *signed 32 bit integer*.
    So with the signed 32 bit integer, you can represent any number between -2,147,483,647
    and +2,147,483,647.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用32位数字的计算机中，它可以表示多少不同的数字？它能表示的最大数字是多少？请记住，每增加一位，你可以制造的数字就会加倍。如果你将64加倍另外25次（使其达到31位），即128、256、512、1024、2048……你最终得到的结果是2,147,483,648。这意味着有2,147,483,648个数字可以用31位表示，其中最高的是2,147,483,647。这个数字略大于20亿。有了第32位，即符号位，这意味着数字可以是正数或负数。这称为*有符号32位整数*。因此，有了有符号32位整数，你可以表示介于-2,147,483,647和+2,147,483,647之间的任何数字。
- en: There is also such thing as a **32 bit *unsigned* integer**. This does not have
    a signed bit, and the 32nd bit is included as part of the value. As a result,
    it can represent twice as many positive numbers (but no negative numbers) as the
    32 bit *signed* integer above. This would be 4,294,967,296 different numbers,
    with 4,294,967,295 being the highest.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种称为**32位*无符号*整数**的东西。这个没有符号位，并且第32位包含在值的一部分中。因此，它可以表示两倍于上面32位*有符号*整数的正数（但没有负数）。这将是4,294,967,296个不同的数字，其中4,294,967,295是最高的。
- en: How many people are in the world? Would a 32 bit integer like described above
    be large enough to store a different identifier number for each person in the
    world? How many bits of accuracy would you want to allow for possible population
    growth?
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上有多少人？像上面描述的 32 位整数足够大，可以为世界上的每个人存储一个不同的标识符号码吗？你想要允许多少位的精度来考虑可能的人口增长？
- en: '| Type of Number | Unsigned Range | Signed Range |'
  id: totrans-704
  prefs: []
  type: TYPE_TB
  zh: '| 数字类型 | 无符号范围 | 有符号范围 |'
- en: '| --- | --- | --- |'
  id: totrans-705
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 8 bit signed | 0 to 255 | -128 to 127 |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
  zh: '| 8 位有符号 | 0 到 255 | -128 到 127 |'
- en: '| 16 bit signed | 0 to 65,535 | -32,768 to 32,767 |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
  zh: '| 16 位有符号 | 0 到 65,535 | -32,768 到 32,767 |'
- en: '| 32 bit signed | 0 to 4,294,967,295 | −2,147,483,648 to 2,147,483,647 |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
  zh: '| 32 位有符号 | 0 到 4,294,967,295 | −2,147,483,648 到 2,147,483,647 |'
- en: '| 64 bit signed | 0 to 18,446,744,073,709,551,615 | −9,223,372,036,854,775,808
    to 9,223,372,036,854,775,807 |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '| 64 位有符号 | 0 到 18,446,744,073,709,551,615 | −9,223,372,036,854,775,808 到 9,223,372,036,854,775,807
    |'
- en: So when you are storing values on a computer with very limited space, you need
    to be careful to pick a suitable kind of integer that has enough space, but isn’t
    wasting space. You also need to think about whether or not a number could potentially
    be negative.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当你在计算机上存储值时，由于空间非常有限，你需要小心选择一个合适的整数类型，它有足够的空间，但不会浪费空间。你还需要考虑一个数字是否可能是负数。
- en: Think of a few different examples for different sized integers (both signed
    and unsigned ones) of a piece of data that you could store in that sized integer.
    For example, the age of a person could be stored in an 8 bit unsigned integer
    (people can’t be a negative age!), and the number of students in your school could
    be stored in an 8 bit or 16 bit integer, depending on how big your school is!
    What other examples can you think of?
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 想一些不同大小的整数的不同示例（有符号和无符号的），你可以在那个大小的整数中存储一些数据。例如，一个人的年龄可以存储在 8 位无符号整数中（人不能是负年龄！），你学校的学生人数可以存储在
    8 位或 16 位整数中，这取决于你学校有多大！你还能想到哪些其他例子？
- en: What are some examples of numbers you could not represent using any of these
    integers?
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 有哪些数字的例子你不能用任何这些整数表示？
- en: '**Extra for Experts**'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '**专家额外内容**'
- en: Another type of number used in computer systems is the “floating point” value.
    While we won’t look at it in detail, to get a taste of what’s involved, consider
    the bit values in a 4-bit number, which are 8, 4, 2 and 1\. What would the value
    of a bit *to the right* of the one bit be? And to the right of that one?
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机系统中使用的另一种数字类型是“浮点”值。虽然我们不会详细讨论它，但为了体会其中的含义，考虑一下 4 位数字中的比特值，它们是 8、4、2 和 1。位于一个比特右边的比特的值会是多少？再右边的是什么？
- en: The following version of the base conversion interactive has bits that are smaller
    than the 1-bit. Try representing the decimal number 3.5 using this system. How
    about 2.8125? What about 2.8?
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 下面版本的基本转换交互式具有比 1 位还小的位。试着用这个系统表示十进制数 3.5。用这个系统表示 2.8125 如何？2.8 呢？
- en: This system is a fixed-point number system; floating point numbers are based
    on this idea, but allow for the number of digits to be fixed, but the position
    of the point to change (by giving an exponent value).
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统是一个固定点数系统；浮点数基于这个思想，但允许数字的位数是固定的，但点的位置可以改变（通过给出指数值）。
- en: '[![](563ad3ce7f8e6.png)Click to load the widget](http://csfieldguide.org.nz/_static/widgets/DR/DR-base-conversion/public_html/index.html?base=2&columns=14&lines=A,B,C&offset=-8)'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad3ce7f8e6.png)点击加载小部件](http://csfieldguide.org.nz/_static/widgets/DR/DR-base-conversion/public_html/index.html?base=2&columns=14&lines=A,B,C&offset=-8)'
- en: 5.7.1\. NUMBERS IN PROGRAMMING LANGUAGES
  id: totrans-718
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7.1\. 编程语言中的数字
- en: If you are programming in a language (e.g. Python, Java, C, C++, C#) then the
    limitations of data representations become important very quickly, as you will
    have to choose what kind of data representation you want to use, and if it is
    too small then it can “overflow”. For example, if you allocate a variable to be
    stored as a 16 bit unsigned integer, and you are counting how many characters
    there are in a file, then it will fail after 65,535 characters — that’s just a
    65 kilobyte file.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用一种语言进行编程（例如 Python、Java、C、C++、C#），那么数据表示的限制很快就会变得非常重要，因为你将不得不选择想要使用的数据表示形式，并且如果它太小，那么它可能会“溢出”。例如，如果你分配一个变量来存储为
    16 位无符号整数，并且你正在计算文件中有多少个字符，那么它将在 65,535 个字符之后失败 —— 这只是一个 65 千字节的文件。
- en: If the amount of memory your computer has to store its data in is very limited
    (for example, on a small portable device), you might not want to reserve 32 bits
    for a number if it is never going to be over 100\. Or even if there is plenty
    of memory, if you are storing millions of data values then using 16-bit integers
    instead of 8-bit integers will waste millions of bytes of memory.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计算机用于存储数据的内存量非常有限（例如，在小型便携设备上），则如果数字永远不会超过100，您可能不希望为数字保留32位。即使内存充足，如果您存储了数百万个数据值，那么使用16位整数而不是8位整数将浪费数百万字节的内存。
- en: Working out the size of an integer used in a particular programming language
    may take some investigation, as they are usually declared with names like “int”
    and “long”, which don’t say explicitly how many bits they use. For example, in
    the Java programming language, there is a data type called the “byte”, which is
    an 8-bit integer that includes negative numbers (it goes from -128 to 127), whereas
    a “short” integer is 16 bits, an “int” is 32 bits, and a “long” is 64 bits. In
    some cases (such as the “int” type in C) the length of an integer depends on the
    version of the language of the type of computer it is running on, and in other
    cases (such as integers in Python) the representation is automatically changed
    for you if the number gets too big!
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 计算特定编程语言中使用的整数的大小可能需要一些调查，因为它们通常以诸如“int”和“long”之类的名称声明，这些名称并不明确说明它们使用多少位。例如，在Java编程语言中，有一种称为“byte”的数据类型，它是一个8位整数，包括负数（范围从-128到127），而“short”整数是16位，“int”是32位，“long”是64位。在某些情况下（例如C中的“int”类型），整数的长度取决于语言的版本或计算机类型，而在其他情况下（例如Python中的整数），如果数字太大，表示会自动更改！
- en: 5.8\. THE WHOLE STORY!
  id: totrans-722
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.8\. 整个故事！
- en: The kind of image representations covered here are the basic ones used in most
    digital systems, and the main point of this chapter is to understand how digital
    representations work, and the compromises needed between the number of bits, storage
    used, and quality.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涵盖的图像表示形式是大多数数字系统中使用的基本形式，本章的主要观点是理解数字表示的工作原理，以及在位数、存储使用和质量之间所需的妥协。
- en: The colour representation discussed is what is often referred to as “raw” or
    “bitmap” (bmp) representation. For large images, real systems use compression
    methods such as JPEG, GIF or PNG to reduce the space needed to store an image,
    but at the point where an image is being captured or displayed it is inevitably
    represented using the raw bits as described in this chapter, and the basic choices
    for capturing and displaying images will affect the quality and cost of a device.
    Compression is regarded as a form of encoding, and is covered in a later chapter.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 所讨论的颜色表示通常称为“原始”或“位图”（bmp）表示。对于大图像，实际系统使用诸如JPEG、GIF或PNG等压缩方法来减少存储图像所需的空间，但在捕获或显示图像的时候，图像不可避免地使用本章所描述的原始位表示，捕获和显示图像的基本选择将影响设备的质量和成本。压缩被视为一种编码形式，将在后面的章节中介绍。
- en: The representation of numbers is a whole area of study in itself. The choice
    of representation affects how quickly arithmetic can be done on the numbers, how
    accurate the results are, and how much memory or disk space is used up storing
    the data. Even integers have issues like the order in which a large number is
    broken up across multiple bytes. Floating point numbers generally follow common
    standards (the IEEE 754 standard is the most common one) to make it easy to design
    compatible hardware to process them. Spreadsheets usually store numbers using
    a floating point format, which limits the precision of calculations (typically
    about 64 bits are used for each number). There are many experiments that can be
    done (such as calculating 1/3, or adding a very large number to a very small one)
    that demonstrate the limitations of floating point representations.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 数字的表示是一个独立的研究领域。表示的选择影响对数字进行算术运算的速度、结果的准确性以及存储数据所使用的内存或磁盘空间的多少。甚至整数也存在诸如大数如何跨越多个字节的顺序之类的问题。浮点数通常遵循常见标准（IEEE
    754标准是最常见的），以便设计兼容的硬件来处理它们。电子表格通常使用浮点格式存储数字，这限制了计算的精度（每个数字通常使用约64位）。可以进行许多实验（例如计算1/3，或将一个非常大的数字加到一个非常小的数字中），这些实验展示了浮点表示的局限性。
- en: 'The chapter does not (yet) cover other forms of data representation, and you
    may wish to explore these as alternatives. The common ones are:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 本章尚未涵盖其他形式的数据表示，您可能希望将其作为替代方案来探索。常见的包括：
- en: sound (wave files and related storage; for example, 16-bit samples are used
    for “CD quality”, but professional systems use 24-bit or even higher) — for some
    information, see the [Teach with ICT page on sound representation](http://teachwithict.weebly.com/6/post/2014/01/teaching-computer-science-day-15-everything-is-sound.html#sthash.8LIc3W01.dpbs).
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音（波形文件及相关存储；例如，16位样本用于“CD音质”，但专业系统使用24位甚至更高）——有关一些信息，请参阅[ICT教学页面上的声音表示](http://teachwithict.weebly.com/6/post/2014/01/teaching-computer-science-day-15-everything-is-sound.html#sthash.8LIc3W01.dpbs)。
- en: video (which are based on multiple images being played one after the other;
    however, these files are so large that they are almost never stored as a “raw”
    representation)
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频（基于多个图像连续播放；但是，这些文件通常几乎不以“原始”表示形式存储）
- en: 5.9\. FURTHER READING
  id: totrans-729
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.9\. 进一步阅读
- en: This puzzle can be solved using the pattern in binary numbers: [http://www.cs4fn.org/binary/lock/](http://www.cs4fn.org/binary/lock/)
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用二进制数的模式解决这个谜题：[http://www.cs4fn.org/binary/lock/](http://www.cs4fn.org/binary/lock/)
- en: '[This site](http://courses.cs.vt.edu/~csonline/NumberSystems/Lessons/index.html) has
    more complex activities with binary numbers, including fractions, multiplication
    and division.'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '[这个网站](http://courses.cs.vt.edu/~csonline/NumberSystems/Lessons/index.html)有更复杂的二进制数活动，包括分数、乘法和除法。'
- en: 5.9.1\. USEFUL LINKS
  id: totrans-732
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.9.1\. 有用的链接
- en: '[Basics of binary numbers](http://csunplugged.org/binary-numbers)'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[二进制数的基础知识](http://csunplugged.org/binary-numbers)'
- en: '[Representing bits using sound](http://csunplugged.org/modem)'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用声音表示比特](http://csunplugged.org/modem)'
- en: '[Hex game](http://www.purposegames.com/game/049fc90a)'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[十六进制游戏](http://www.purposegames.com/game/049fc90a)'
- en: '[Thriving in our digital world](https://onramps.instructure.com/courses/723227) has
    good illustrations of data representation'
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在数字世界中蓬勃发展](https://onramps.instructure.com/courses/723227)有很好的数据表示图示'
- en: 6\. CODING — INTRODUCTION
  id: totrans-737
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6\. 编码 —— 介绍
- en: 6.1\. WHAT’S THE BIG PICTURE?
  id: totrans-738
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1\. 大局观是什么？
- en: The word “code” has lots of meanings in computer science. It’s often used to
    talk about programming, and a program can be referred to as “source code”. However,
    in this chapter (and the next three chapters), we will use it to talk about representing
    information in useful ways, such as secret codes. In the previous chapter we looked
    at using binary representations to store all kinds of data — numbers, text, images
    and more. But often simple binary representations aren’t so useful. Sometimes
    they take up too much space, sometimes small errors in the data can cause big
    problems, and sometimes we worry that someone else could easily read our messages.
    Most of the the time all three of these things are a problem! The codes that we
    will look overcome all of these problems, and are widely used for storing and
    transmitting important information.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中，“code”一词有许多含义。通常用来谈论编程，而程序则可以称为“source code”。然而，在本章节（以及接下来的三章），我们将用它来讨论以有用的方式表示信息，比如秘密代码。在上一章中，我们讨论了使用二进制表示法来存储各种数据——数字、文本、图像等等。但是，简单的二进制表示法通常并不那么有用。有时它们占用的空间太大，有时数据中的小错误会导致大问题，有时我们担心别人很容易读到我们的消息。大多数时候，这三个问题都是一个问题！我们将要看的代码克服了所有这些问题，并被广泛用于存储和传输重要信息。
- en: 'The three main reasons that we use more complex representations of binary data
    are:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用更复杂的二进制数据表示的三个主要原因是：
- en: '**Compression:** this reduces the amount of space the data needs (for example,
    coding an audio file using MP3 compression can reduce the size of an audio file
    to well under 10% of its original size)'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压缩：**这减少了数据所需的空间（例如，使用MP3压缩编码音频文件可以将音频文件的大小减小到原始大小的10%以下）'
- en: '**Encryption:** this changes the representation of data so that you need to
    have a “key” to unlock the message (for example, whenever your browser uses “https”
    instead of “http” to communicate with a website, encryption is being used to make
    sure that anyone eavesdropping on the connection can’t make any sense of the information)'
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密：**这改变了数据的表示方式，以便您需要一个“密钥”来解锁消息（例如，每当您的浏览器使用“https”而不是“http”与网站通信时，加密都被用来确保任何窃听连接的人无法理解信息）。'
- en: '**Error Control:** this adds extra information to your data so that if there
    are minor failures in the storage device or transmission, it is possible to detect
    that the data has been corrupted, and even reconstruct the information (for example,
    every bar code has an extra digit added to it so that if the bar code is scanned
    incorrectly in a checkout, it makes a warning sound instead of charging you for
    the wrong product).'
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误控制：** 这会向您的数据添加额外的信息，以便在存储设备或传输中发生轻微故障时，可以检测到数据已损坏，甚至重建信息（例如，每个条形码都会添加一个额外的数字，以便如果在结帐时错误扫描条形码，它会发出警告声音而不是为您收取错误的产品费用）。'
- en: Often all three of these are applied to the same data; for example, a photo
    taken on a camera is often compressed using JPG, stored on the camera card with
    error correction, and stored on a backup disk with encryption so that if the disk
    was stolen the data couldn’t be accessed.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有这三种方法都被应用于相同的数据；例如，相机拍摄的照片通常使用JPG进行压缩，使用错误校正存储在相机卡上，并使用加密存储在备份磁盘上，以便如果磁盘被盗取，则无法访问数据。
- en: Without these forms of coding, digital devices would be very slow, have limited
    capacity, be unreliable, and be unable to keep your information private.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这些编码形式，数字设备将非常缓慢，容量有限，不可靠，并且无法保护您的信息隐私。
- en: 6.2\. THE WHOLE STORY!
  id: totrans-746
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2\. **整个故事！**
- en: The idea of encoding data to make the representation more compact, robust or
    secure is centuries old, but the solid theory needed to support codes in the information
    age was developed in the 1940s — not surprisingly considering that technology
    played such an important role in World War II, where efficiency, reliability and
    secrecy were all very important. One of the most celebrated researchers in this
    area was Claude Shannon, who developed the field of “information theory”, which
    is all about how data can be represented effectively.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据进行编码以使表示更紧凑，更健壮或更安全的想法已经存在几个世纪了，但在20世纪40年代开发了支持信息时代的固体理论 —— 这并不奇怪，考虑到技术在第二次世界大战中起了如此重要的作用，效率，可靠性和保密性都非常重要。这个领域中最著名的研究者之一是克劳德·香农，他开发了“信息论”领域，这个领域关注的是数据如何有效地表示。
- en: A key concept in Shannon’s work is a measure of information called “entropy”,
    which established mathematical limits like how small files could be compressed,
    and how many extra bits must be added to a message to achieve a given level of
    reliability. While the idea of entropy is beyond the scope of this section, there
    are some fun games that provide a taste of how you could measure information content
    by guessing what letter comes next; there’s an Unplugged activity called [Twenty
    Guesses](http://csunplugged.org/information-theory), and an [online game for guessing
    sentences](http://www.math.ucsd.edu/~crypto/java/ENTROPY).
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 香农工作中的一个关键概念是一种称为“熵”的信息度量，它建立了数学限制，例如文件可以被压缩到多小，以及必须向消息添加多少额外位才能达到给定可靠性水平。虽然熵的概念超出了本节的范围，但有一些有趣的游戏可以提供一种感觉，即您可以通过猜测下一个字母来测量信息内容；有一个名为[Twenty
    Guesses](http://csunplugged.org/information-theory)的非插电活动，以及一个用于猜测句子的[在线游戏](http://www.math.ucsd.edu/~crypto/java/ENTROPY)。
- en: 6.3\. FURTHER READING
  id: totrans-749
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3\. **进一步阅读**
- en: 'James Gleick’s book [The Information: A History, a Theory, a Flood](http://www.amazon.com/The-Information-History-Theory-Flood/dp/1400096235) provides
    an interesting view of the history of several areas relating to coding.'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 詹姆斯·格莱克的书[《信息：一个历史，一个理论，一场洪水》](http://www.amazon.com/The-Information-History-Theory-Flood/dp/1400096235)提供了与编码相关的几个领域历史的有趣视角。
- en: 6.3.1\. USEFUL LINKS
  id: totrans-751
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1\. **有用链接**
- en: A good collection of resources related to all three kinds of coding is available
    in the [Bletchley Park Codes Resources](http://www.cimt.plymouth.ac.uk/resources/codes/)
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关所有三种编码的资源的良好集合可在[布莱切利公园编码资源](http://www.cimt.plymouth.ac.uk/resources/codes/)找到
- en: '[Entropy and information theory](http://en.wikipedia.org/wiki/Entropy_(information_theory))'
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[熵和信息理论](http://en.wikipedia.org/wiki/Entropy_(information_theory))'
- en: '[History of information theory and its relationship to entropy in thermodynamics](http://en.wikipedia.org/wiki/History_of_entropy#Information_theory)'
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[信息论的历史及其与热力学中的熵的关系](http://en.wikipedia.org/wiki/History_of_entropy#Information_theory)'
- en: '[Timeline of information theory](http://en.wikipedia.org/wiki/Timeline_of_information_theory)'
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[信息论时间表](http://en.wikipedia.org/wiki/Timeline_of_information_theory)'
- en: '[Shannon’s seminal work in information theory](http://en.wikipedia.org/wiki/A_Mathematical_Theory_of_Communication)'
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[香农在信息论中的开创性工作](http://en.wikipedia.org/wiki/A_Mathematical_Theory_of_Communication)'
- en: 7\. COMPRESSION CODING
  id: totrans-757
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7\. **压缩编码**
- en: 7.1\. WHAT’S THE BIG PICTURE?
  id: totrans-758
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1\. **整体看问题**
- en: Data compression reduces the amount of space needed to store files. If you can
    halve the size of a file, you can store twice as many files for the same cost,
    or you can download the files twice as fast (and at half the cost if you’re paying
    for the download). Even though disks are getting bigger and high bandwidth is
    becoming common, it’s nice to get even more value by working with smaller, compressed
    files. For large data warehouses, like those kept by Google and Facebook, halving
    the amount of space taken can represent a massive reduction in the space and computing
    required, and consequently big savings in power consumption and cooling, and a
    huge reduction in the impact on the environment.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 数据压缩减少了存储文件所需的空间。如果你能将文件大小减半，你可以以相同的成本存储两倍数量的文件，或者你可以以两倍的速度下载文件（如果你为下载付费的话，成本会减半）。即使磁盘变得更大，高带宽变得普遍，通过使用更小、压缩的文件来获得更多价值也是一件好事。对于像谷歌和Facebook这样的大型数据仓库，减少占用空间的一半可以大大减少所需的空间和计算量，因此可以节省大量的能源消耗和冷却成本，并且对环境影响大大减少。
- en: Common forms of compression that are currently in use include JPEG (used for
    photos), MP3 (used for audio), MPEG (used for videos including DVDs), and ZIP
    (for many kinds of data). For example, the JPEG method reduces photos to a tenth
    or smaller of their original size, which means that a camera can store 10 times
    as many photos, and images on the web can be downloaded 10 times faster.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 目前使用的常见压缩形式包括JPEG（用于照片）、MP3（用于音频）、MPEG（用于视频，包括DVD）和ZIP（用于许多种类的数据）。例如，JPEG方法将照片减小到原始大小的十分之一或更小，这意味着相机可以存储十倍数量的照片，而网页上的图像可以下载十倍快。
- en: So what’s the catch? Well, there can be an issue with the quality of the data
    — for example, a highly compressed JPEG image doesn’t look as sharp as an image
    that hasn’t been compressed. Also, it takes processing time to compress and decompress
    the data. In most cases, the tradeoff is worth it, but not always.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 那么有什么问题吗？嗯，数据质量可能会有问题——例如，高度压缩的JPEG图像看起来不像未压缩的图像那么清晰。而且，压缩和解压缩数据需要处理时间。在大多数情况下，这种权衡是值得的，但并非总是如此。
- en: Move your cursor or tap the image to compare the two images
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 移动你的光标或点击图片来比较这两张图片
- en: '![](563ad56eb6251.jpg)'
  id: totrans-763
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad56eb6251.jpg)'
- en: '**Left is low quality JPEG (20Kb) - Right is high quality JPEG (88Kb)**'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '**左侧是低质量JPEG（20Kb）- 右侧是高质量JPEG（88Kb）**'
- en: In this chapter we’ll look at how compression might be done, what the benefits
    are, and the costs associated with using compressed data that need to be considered
    when deciding whether or not to compress data. We’ll start with a simple example
    — Run Length Encoding — which gives some insight into the benefits and the issues
    around compression.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看如何进行压缩，压缩的好处是什么，以及在决定是否压缩数据时需要考虑的与使用压缩数据相关的成本。我们将从一个简单的示例开始——运行长度编码——这个示例可以让我们了解压缩的好处和问题。
- en: In this activity, students simulate writing some text using a method used by
    Jean-Dominique Bauby, who was completely unable to move except for blinking one
    eye. With a simple binary interface (blinking or not blinking) he was able to
    author an entire book. It is well worth getting students to work in pairs, and
    have one try to communicate a word or short phrase strictly by blinking only.
    It raises many questions, including how it could be done in the shortest time
    and with the minimum effort. Of course, the first step is to work out how to convey
    any text at all!
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，学生们模拟使用了Jean-Dominique Bauby使用的方法来写一些文本，他完全不能移动，除了眨眼。通过一个简单的二进制接口（眨眼或不眨眼），他能够写作一整本书。让学生成对工作，并让其中一名学生尝试仅通过眨眼来传达一个单词或短语，这是非常值得的。这引发了许多问题，包括如何以最短的时间和最小的努力来完成。当然，第一步是弄清楚如何传达任何文本！
- en: 7.2\. RUN LENGTH ENCODING
  id: totrans-767
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2\.  运行长度编码
- en: Imagine we have the following simple black and white image.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们有以下简单的黑白图片。
- en: '![](563ad56e2728e.png)'
  id: totrans-769
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad56e2728e.png)'
- en: One very simple way a computer can store this image is by using a format where
    0 means white and 1 means black. The above image would be represented in the following
    way
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机可以存储此图像的一种非常简单的方法是使用一个格式，其中0表示白色，1表示黑色。上述图像将以以下方式表示
- en: '[PRE12]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are 15 (rows) by 15 (columns) = 225 bits representing this image. Can
    we represent the same image using fewer bits, in a way that a computer would still
    be able to understand it? Imagine that you had to read it out to someone... after
    a while you might say things like “five zeroes” instead of “zero zero zero zero
    zero”. This technique is used to save space for storing digital images, and is
    known as run length encoding (RLE). In run length encoding, we replace each row
    with numbers that say how many consecutive pixels are the same colour, *always
    starting with the number of white pixels*. For example, the first row in the image
    above contains 1 white, 2 black, 4 white, 1 black, 4 white, 2 black, and 1 white
    pixel. This could be represented as;
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 有 15（行）乘以 15（列）= 225 位来表示这张图像。我们能够用更少的位来表示相同的图像吗，以一种计算机仍能理解的方式呢？想象一下，如果你不得不向某人读出来...
    过了一会儿，你可能会说“五个零”而不是“零零零零零”。这种技术被用来节省存储数字图像的空间，并且被称为运行长度编码（RLE）。在运行长度编码中，我们用数字替换每一行，这些数字表示连续的像素有多少个相同的颜色，*始终以白色像素的数量开始*。例如，上图中的第一行包含
    1 个白色像素、2 个黑色像素、4 个白色像素、1 个黑色像素、4 个白色像素、2 个黑色像素和 1 个白色像素。这可以表示为;
- en: '[PRE13]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For the second row, because we need to say what the number of white pixels is
    before we say the number of black, we need to explicitly say there are 0 at the
    start of the row. This would give
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二行，因为我们需要在说出黑色像素的数量之前说明白色像素的数量，所以我们需要明确表示在行的开头有多少个白色像素。这将得到
- en: '[PRE14]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And the third row contains 5 whites, 5 blacks, 5 whites. This would give
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行包含 5 个白色像素、5 个黑色像素和 5 个白色像素。这将得到
- en: '[PRE15]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So, we have determined that the first 3 rows of the file can be represented
    using RLE as:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经确定文件的前三行可以使用 RLE 表示为：
- en: '[PRE16]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Work out what the other rows would be, and write them out as well.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 计算出其他行会是什么样子，并将它们写出来。
- en: Which representation takes less space to store?
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种表示方法需要更少的存储空间？
- en: One simple way to consider this is to imagine you were typing these representations,
    so you could think of each of the original bits being stored as one character,
    and each of the RLE codes using a character for each digit and comma (this is
    a bit crude, but it’s a starting point).
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的考虑方法是想象你在输入这些表示时，每个原始位被存储为一个字符，而每个 RLE 代码使用一个字符表示每个数字和逗号（这有点粗糙，但这是一个起点）。
- en: In the original representation, 225 bits were required to represent the image.
    Count up the number of commas and digits (but not spaces or newlines, ignore those)
    in the new representation. This is the number of characters required to represent
    the image with the new representation (to ensure you are on the right track, the
    first 3 rows that were given to you contain 29 characters)
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始表示中，需要 225 位来表示图像。数一下新表示中的逗号和数字的数量（但不包括空格或换行符，忽略这些）。这是用新表示来表示图像所需的字符数（为了确保你走在正确的轨道上，给你的前三行包含
    29 个字符）。
- en: Assuming you got the new image representation correct, and counted correctly,
    you should have found there are 119 characters in the new image (double check
    if your number differs!) This means that the new representation only requires
    around 53% as many characters to represent (calculated using 119/225)! This is
    a significant reduction in the amount of space required to store the image. The
    new representation is a *compressed* form of the old one.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经正确地获得了新的图像表示，并且正确地计数了，你应该已经发现新图像中有 119 个字符（如果你的数字不同，请再检查一下！）这意味着新表示仅需要大约原来字符数的
    53% 来表示（使用 119/225 计算）！这大大减少了存储图像所需空间的量。新的表示是旧表示的一种*压缩*形式。
- en: In practice this method (with some extra tricks) can be used to compress images
    to about 15% of their original size. In real systems, the image only uses one
    bit for every pixel to store the black and white values (not one character, which
    we used for our calculations). The run length numbers are also stored much more
    efficiently, again using bit patterns that take very little space to represent
    the numbers. The bit patterns used are usually based on a technique called Huffman
    coding, but that is beyond what we want to get into here.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这种方法（加上一些额外的技巧）可以将图像压缩到其原始大小的约 15%。在真实系统中，图像仅使用一个比特来存储黑色和白色值（而不是一个字符，我们用于计算）。运行长度数字也以更有效的方式存储，再次使用几乎不占用空间的位模式来表示数字。使用的位模式通常基于一种称为哈夫曼编码的技术，但这超出了我们想要探讨的范围。
- en: The main place that black and white scanned images are used now is on fax machines,
    which used this approach to compression. One reason that it works so well with
    scanned pages the number of consecutive white pixels is huge. In fact, there will
    be entire scanned lines that are nothing but white pixels. A typical fax page
    is 200 pixels across or more, so replacing 200 bits with one number is a big saving.
    The number itself can take a few bits to represent, and in some places on the
    scanned page only a few consecutive pixels are replaced with a number, but overall
    the saving is significant. In fact, fax machines would take 7 times longer to
    send pages if they didn’t use compression.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，黑白扫描图像主要用于传真机上，传真机使用这种压缩方法。它能够在扫描页中工作得如此出色的一个原因是连续白色像素的数量是巨大的。事实上，会有整行的扫描线都是白色像素。典型的传真页宽度为200像素或更多，因此用一个数字代替200位是一个很大的节省。这个数字本身可能需要几位来表示，并且在扫描页的某些地方，只有几个连续的像素被一个数字替代，但总体上节省很大。事实上，如果不使用压缩，传真机发送页面会慢7倍。
- en: Just to ensure that we can reverse the compression process, what is the original
    representation (zeroes and ones) of this (compressed) image?
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们能够逆转压缩过程，这个（压缩的）图像的原始表示（零和一）是什么？
- en: '[PRE17]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What is the image of? How good was the compression on this image? (Look back
    at the calculation above for the amount of compression).
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 图像是什么？这张图像的压缩效果如何？（回顾上面计算的压缩量。）
- en: '[![](563ad56d61c9f.png)Click to load'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad56d61c9f.png)点击加载'
- en: Run Length Encoding](http://csfieldguide.org.nz/_static/interactives/cc/run-length-encoding/index.html)
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 行程长度编码](http://csfieldguide.org.nz/_static/interactives/cc/run-length-encoding/index.html)
- en: Created by Hannah Taylor
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 由汉娜·泰勒创建
- en: As the compressed representation of the image can be converted back to the original
    representation, and both the original representation and the compressed representation
    would give the same image when read by a computer, this compression algorithm
    is called *lossless*, i.e. none of the data was lost from compressing the image,
    and as a result the compression could be undone exactly.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图像的压缩表示可以转换回原始表示，并且当计算机读取时，原始表示和压缩表示会给出相同的图像，所以这种压缩算法被称为*无损*，即从压缩图像中没有丢失任何数据，因此压缩可以完全恢复。
- en: Not all compression algorithms are lossless. In some types of files, in particular
    photos, sound, and videos, we are willing to sacrifice a little bit of the quality
    (i.e. lose a little of the data representing the image) if it allows us to make
    the file size a lot smaller. For downloading very large files such as movies,
    this can be essential to ensure the file size is not so big that it is infeasible
    to download! These compression methods are called *lossy*. If some of the data
    is lost, it is impossible to convert the file back to the exactly the original
    form when lossy compression was used, but the person viewing the movie or listening
    to the music may not mind the lower quality if the files are smaller. Later in
    this chapter, we will investigate the effects some lossy compression algorithms
    have on images and sound.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的压缩算法都是无损的。在某些类型的文件中，特别是照片、声音和视频中，我们愿意牺牲一点质量（即丢失一些代表图像的数据），如果这样做可以使文件大小变得更小。对于下载非常大的文件，比如电影，这是至关重要的，以确保文件大小不会太大而无法下载！这些压缩方法被称为*有损*。如果丢失了一些数据，就无法将文件转换回使用有损压缩时的确切原始形式，但是如果文件更小，观看电影或听音乐的人可能不会在意较低的质量。在本章的后面，我们将研究一些有损压缩算法对图像和声音的影响。
- en: Now that you know how run length encoding works, you can come up with and compress
    your own black and white image, as well as uncompress an image that somebody else
    has given you.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了如何运用行程长度编码，你可以想出并压缩你自己的黑白图像，以及解压别人给你的图像。
- en: Start by making your own picture with ones and zeroes. (Make sure it is rectangular
    — all the rows should have the same length.) You can either draw this on paper
    or prepare it on a computer (using a fixed width font, otherwise it can become
    really frustrating and confusing!) In order to make it easier, you could start
    by working out what you want your image to be on grid paper (such as that from
    a math exercise book) by shading in squares to represent the black ones, and leaving
    them blank to represent the white ones. Once you have done that, you could then
    write out the zeroes and ones for the image.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 首先用1和0制作你自己的图片。（确保它是矩形的 — 所有行应该具有相同的长度。）你可以在纸上画，也可以在电脑上准备（使用等宽字体，否则会变得非常沮丧和混乱！）为了更容易，你可以先在方格纸上（比如数学练习册上）上描绘出你想要的图片，用方块涂黑表示黑色的部分，留白表示白色的部分。一旦你做到了，你可以写出图片的零和一。
- en: Work out the compressed representation of your image using run length coding,
    i.e. the run lengths separated by commas form that was explained above.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 使用游程长度编码计算图像的压缩表示，即由上面解释过的逗号分隔的游程长度形成的形式。
- en: Now, swap a copy of the *compressed representation* (the run length codes, not
    the original uncompressed representation) with a classmate. You should each uncompress
    the other person’s image, to get back to the original uncompressed representations.
    Check to make sure the conversions back to the uncompressed representations was
    done correctly by making sure the images are the same.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用同学的一份*压缩表示*副本（游程长度代码，而不是原始的未压缩表示）交换一下。你们每个人都应该解压缩对方的图像，以恢复到原始的未压缩表示。通过确保转换回未压缩表示的正确性来检查，确保图像是相同的。
- en: Imagining that you and your friend are both computers, by doing this you have
    shown that images using these systems of representations can be compressed on
    one computer, and decompressed on another. It is very important for compression
    algorithms to have this property in order to be useful. It wouldn’t be very good
    if a friend gave you a song they’d compressed on their computer, but then your
    computer was unable to make sense of the representation the compressed song was
    using!
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你和你的朋友都是计算机，通过这样做，你表明了使用这些表示系统的图像可以在一台计算机上进行压缩，并在另一台计算机上进行解压缩。压缩算法具有这一属性非常重要。如果一个朋友把他们在自己的计算机上压缩的歌曲给了你，但是你的计算机无法理解压缩的歌曲使用的表示方法，那就不太好了！
- en: '**Extra for Experts**'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '**专家专用**'
- en: What is the image with the best compression (i.e. an image that has a size that
    is a very small percentage of the original) that you can come up with? This is
    the best case performance for this compression algorithm.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想出哪种压缩效果最好的图像（即尺寸非常小，是原始图像的很小百分比）？这是该压缩算法的最佳性能情况。
- en: What about the worst compression? Can you find an image that actually has a *larger* compressed
    representation? (Don’t forget the commas in the version we used!) This is the
    worst case performance for this compression algorithm.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 那最差的压缩呢？你能找到一个压缩表示实际上比原始表示*更大*的图像吗？（别忘了我们使用的版本中的逗号！）这是该压缩算法的最差性能情况。
- en: In fact, any *lossless* compression algorithm will have cases where the compressed
    version of the file is larger than the uncompressed version! Computer scientists
    have even proven this to be the case, meaning it is impossible for anybody to
    ever come up with a lossless compression algorithm that makes *all* possible files
    smaller. In most cases this isn’t an issue though, as a good lossless compression
    algorithm will tend to give the best compression on common patterns of data, and
    the worst compression on ones that are highly unlikley to occur.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，任何*无损*压缩算法都会存在一种情况，即文件的压缩版本比未压缩版本更大！计算机科学家甚至已经证明了这一点，这意味着任何人都不可能提出一种无损压缩算法，使*所有*可能的文件都变小。不过在大多数情况下，这并不是一个问题，因为一个良好的无损压缩算法通常会在常见的数据模式上获得最佳压缩，在高度不太可能发生的数据模式上获得最差的压缩。
- en: '**Extra for Experts**'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '**专家专用**'
- en: 'There is actually an image format that uses the simple one-character-per-pixel
    representation we used at the start of this section. The format is called portable
    bitmap format (PBM). PBM files are saved with the file extension “.pbm”, and contain
    a simple header, along with the the image data. The data in the file can be viewed
    by opening it in a text editor, much like opening a .txt file, and the image itself
    can be viewed by opening it in a drawing or image viewing program that supports
    PBM files (they aren’t very well supported, but a number of image viewing and
    editing programs can display them). A pbm file for the diamond image used earlier
    would be as follows:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有一种图像格式使用了我们在本节开始时使用的简单的每像素一个字符的表示方法。该格式称为便携式位图格式（PBM）。PBM文件以扩展名“.pbm”保存，并包含一个简单的标题，以及图像数据。文件中的数据可以通过在文本编辑器中打开它来查看，就像打开.txt文件一样，图像本身可以通过在支持PBM文件的绘图或图像查看程序中打开它来查看（它们支持得不是很好，但许多图像查看和编辑程序可以显示它们）。用于前面使用的钻石图像的pbm文件如下：
- en: '[PRE18]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first 2 lines are the header. The first line specifies the format of the
    file (P1 means that the file contains ASCII zeroes and ones. The second line specifies
    the width and then the height of the image in pixels. This allows the computer
    to know the size and dimensions of the image, even if the newline characters separating
    the rows in the file were missing. The rest of the data is the image, just like
    above. If you wanted to, you could copy and paste this representation (including
    the header) into a text file, and save it with the file extension .pbm. If you
    have a program on your computer able to open PBM files, you could then view the
    image with it. You could even write a program to output these files, and then
    display them as images.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行是标题。第一行指定文件的格式（P1表示文件包含ASCII的零和一）。第二行指定图像的宽度，然后是像素的高度。这使得计算机即使在文件中缺少分隔行的换行符的情况下也能知道图像的大小和尺寸。其余的数据就是图像，就像上面一样。如果你愿意，你可以复制并粘贴这个表示（包括标题）到一个文本文件中，并将其保存为文件扩展名为.pbm。如果您的计算机上有能够打开PBM文件的程序，您可以使用它查看图像。你甚至可以编写一个程序来输出这些文件，然后将它们显示为图像。
- en: There are variations of this format that pack the pixels into bits instead of
    characters, and variations that can be used for grey scale and colour images.
    More[information about this format is available on Wikipedia](http://en.wikipedia.org/wiki/Netpbm_format).
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式有将像素打包成位而不是字符的变体，还有用于灰度和彩色图像的变体。有关此格式的更多信息，请参见[维基百科](http://en.wikipedia.org/wiki/Netpbm_format)。
- en: '7.3\. IMAGE COMPRESSION: JPEG'
  id: totrans-809
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3\. 图像压缩：JPEG
- en: Images can take up a lot of space, and most of the time that pictures are stored
    on a computer they are compressed to avoid wasting too much space. With a lot
    of images (especially photographs), there’s no need to store the image exactly
    as it was originally, because it contains way more detail than anyone can see.
    This can lead to considerable savings in space, especially if the details that
    are missing are the kind that people have trouble perceiving. This kind of compression
    is called lossy compression. There are other situations where images need to be
    stored exactly as they were in the original, such as for medical scans or very
    high quality photograph processing, and in these cases lossless methods are used,
    or the images aren’t compressed at all (e.g. using RAW format on cameras).
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 图像可能占用大量空间，在大多数情况下，图片存储在计算机上时都会进行压缩，以避免浪费太多空间。对于许多图像（尤其是照片），没有必要完全按照原样存储图像，因为它包含的细节远远超过了任何人可以看到的。这可以节省大量空间，特别是如果丢失的细节是人们难以感知的那种。这种压缩称为有损压缩。还有其他一些情况，图像需要完全按照原样存储，例如医学扫描或非常高质量的照片处理，这些情况下使用无损方法，或者根本不压缩图像（例如在相机上使用RAW格式）。
- en: In the data representation section we looked at how the size of an image file
    can be reduced by using fewer bits to describe the colour of each pixel. However,
    image compression methods such as JPEG take advantage of patterns in the image
    to reduce the space needed to represent it, without impacting the image unnecessarily.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据表示部分，我们看到了如何通过使用较少的位来描述每个像素的颜色来减少图像文件的大小。然而，诸如JPEG之类的图像压缩方法利用图像中的模式来减少表示它所需的空间，而不会对图像造成不必要的影响。
- en: 'The following three images show the difference between reducing bit depth and
    using a specialised image compression system. The left hand image is the original,
    which was 24 bits per pixel. The middle image has been compressed to one third
    of the original size using JPEG; while it is a “lossy” version of the original,
    the difference is unlikely to be perceptible. The right hand one has had the number
    of colours reduced to 256, so there are 8 bits per pixel instead of 24, which
    means it is also stored in a third of the original size. Even though it has lost
    just as many bits, the information removed has had much more impact on how it
    looks. This is the advantage of JPEG: it removes information in the image that
    doesn’t have so much impact on the perceived quality. Furthermore, with JPEG,
    you can choose the tradeoff between quality and file size.'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三幅图展示了减少位深度和使用专门的图像压缩系统之间的区别。左侧图像是原始图像，每个像素为24位。中间图像使用JPEG压缩到原始大小的三分之一；虽然这是原始图像的“有损”版本，但差异不太可能被察觉。右侧图像将颜色数量减少到256，因此每个像素有8位而不是24位，这意味着它也以原始大小的三分之一存储。尽管失去了同样多的位，但删除的信息对外观产生了更大的影响。这就是JPEG的优势：它删除了图像中对感知质量影响不大的信息。此外，使用JPEG，您可以选择质量和文件大小之间的权衡。
- en: Reducing the number of bits (the colour depth) is sufficiently crude that we
    don’t really regard it as a compression method, but just a low quality representation.
    Image compression methods like JPEG, GIF and PNG are designed to take advantage
    of the patterns in an image to get a good reduction in file size without losing
    more quality than necessary.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 减少位数（颜色深度）是相当粗糙的，我们实际上不将其视为一种压缩方法，而只是一种低质量的表示。像JPEG、GIF和PNG这样的图像压缩方法旨在利用图像中的模式，以在不失去比必要更多的质量的情况下获得良好的文件大小缩减。
- en: '![](563ad5689cad1.png)'
  id: totrans-814
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad5689cad1.png)'
- en: For example, the following image shows a zoomed in view of the pixels that are
    part of the detail around an eye from the above (high quality) image.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的图像显示了从上述（高质量）图像中眼睛周围细节的像素的放大视图。
- en: '![](563ad56825c7f.png)'
  id: totrans-816
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad56825c7f.png)'
- en: Notice that the colours in adjacent pixels are often very similar, even in this
    part of the picture that has a lot of detail. For example, the pixels shown in
    the red box below just change gradually from very dark to very light.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，相邻像素的颜色通常非常相似，即使在这幅细节丰富的图片中也是如此。例如，下面红色框中显示的像素从非常暗逐渐变为非常亮。
- en: '![](563ad5679ecd4.png)'
  id: totrans-818
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad5679ecd4.png)'
- en: Run-length encoding wouldn’t work in this situation. You could use a variation
    that specifies a pixel’s colour, and then says how many of the following pixels
    are the same colour, but although most adjacent pixels are nearly the same, the
    chances of them being identical are very low, and there would be almost no runs
    of identical colours.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，游程编码不起作用。您可以使用一种变体，指定一个像素的颜色，然后说明接下来的像素中有多少个是相同颜色的，但是尽管大多数相邻像素几乎相同，它们完全相同的机会非常低，几乎没有相同颜色的序列。
- en: But there is a way to take advantage of the gradually changing colours. For
    the pixels in the red box above, you could generate an approximate version of
    those colours by specifying just the first and last one, and getting the computer
    to interpolate the ones in between smoothly. Instead of storing 5 pixel values,
    only 2 are needed, yet someone viewing it probably wouldn’t notice any difference.
    This would be *lossy* because you can’t reproduce the original exactly, but it
    would be good enough for a lot of purposes, and save a lot of space.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一种方法可以利用逐渐变化的颜色。对于上面红色框中的像素，您可以通过仅指定第一个和最后一个像素，并让计算机平滑地插值中间的像素来生成这些颜色的近似版本。只需要存储2个像素值，而不是5个像素值，但观看者可能不会注意到任何差异。这将是*有损*的，因为您无法精确复制原始图像，但对于许多目的来说，这将足够好，并节省大量空间。
- en: The JPEG system, which is widely used for photos, uses a more sophisticated
    version of this idea. Instead of taking a 5 by 1 run of pixels as we did above,
    it works with 8 by 8 blocks of pixels. And instead of estimating the values with
    a linear function, it uses combinations of cosine waves.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 用于照片的广泛使用的JPEG系统使用了这个想法的更复杂版本。与上面我们所做的5×1像素运行不同，它使用8×8像素块。而且，它不是用线性函数估计值，而是使用余弦波的组合。
- en: '**Jargon Buster**'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '**术语解释**'
- en: A cosine wave form is from the trig function that is often used for calculating
    the sides of a triangle. If you plot the cosine value from 0 to 180 degrees, you
    get a smooth curve going from 1 to -1\. Variations of this plot can be used to
    approximate the value of pixels, going from one colour to another. If you add
    in a higher frequency cosine wave, you can produce interesting shapes. In theory,
    any pattern of pixels can be created by adding together different cosine waves!
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 余弦波形是三角函数中经常用于计算三角形边的函数。如果你绘制从 0 到 180 度的余弦值，你会得到一个平滑的曲线，从 1 到 -1。这种曲线的变化可以用来近似像素值，从一种颜色过渡到另一种颜色。如果加入更高频率的余弦波，你可以产生有趣的形状。理论上，通过组合不同的余弦波，可以创建任何像素模式！
- en: '![](563ad567142a9.png)'
  id: totrans-824
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad567142a9.png)'
- en: You can see the 8 by 8 blocks of pixels if you zoom in on a heavily compressed
    JPEG image. For example, the following image has been very heavily compressed
    using JPEG (it is just 1.5% of its original size).
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你放大一个经过严重压缩的 JPEG 图像，你会看到 8 x 8 像素块。例如，下面的图像经过 JPEG 严重压缩（仅为原始大小的 1.5%）。
- en: '![](563ad56603451.png)'
  id: totrans-826
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad56603451.png)'
- en: 'If we zoom in on the eye area , you can see the 8 x 8 blocks of pixels:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们放大眼睛区域，你可以看到 8 x 8 像素块：
- en: '![](563ad560553f4.png)'
  id: totrans-828
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad560553f4.png)'
- en: Notice that there is very little variation across each block. In the following
    image the block in the red box only changes from top to bottom, and could probably
    be specified by giving just two values, and having the ones in between calculated
    by the decoder as for the line example before. The green square only varies from
    left to right, and again might only need 2 values stored instead of 64\. The blue
    block has only one colour in it! The yellow block is more complicated because
    there is more activity in that part of the image, which is where the cosine waves
    come in. A “wave” value varies up and down, so this one can be represented by
    a left-to-right variation from dark to light to dark, and a top-to-bottom variation
    mainly from dark to light. Thus still only a few values need to be stored instead
    of the full 64.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个块之间的变化很小。在下面的图像中，红色框中的块只在上下方向变化，可能只需要给出两个值，中间的值由解码器计算，就像之前的线条示例一样。绿色方块只在左右方向变化，可能只需要存储
    2 个值而不是 64 个。蓝色块中只有一种颜色！黄色块更复杂，因为图像的这部分活动更多，这就是余弦波的作用。一个“波”值上下变化，因此可以通过从暗到亮再到暗的左右变化，以及从暗到亮的主要上下变化来表示。因此，仍然只需要存储少量值，而不是全部
    64 个。
- en: '![](563ad55f7eb84.png)'
  id: totrans-830
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad55f7eb84.png)'
- en: The quality is quite low, but the saving in space is huge — it’s more than 60
    times smaller (for example, it would download 60 times faster). Higher quality
    JPEG images store more detail for each 8 by 8 block, which makes it closer to
    the original image, but makes bigger files because more details are being stored.
    You can experiment with these tradeoffs by saving JPEGs with differing choices
    of the quality, and see how the file size changes. Most image processing software
    offers this option when you save an image as a JPEG.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 质量相当低，但节省的空间巨大 — 它比原始大小小 60 多倍（例如，下载速度会快 60 倍）。质量更高的 JPEG 图像为每个 8 x 8 块存储更多细节，使其更接近原始图像，但因为存储了更多细节，文件更大。你可以通过以不同质量选择保存
    JPEG 图像来尝试这些权衡，并查看文件大小的变化。大多数图像处理软件在将图像保存为 JPEG 时提供此选项。
- en: '**Jargon Buster**'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '**行话解释**'
- en: The name “JPEG” is short for “Joint Photographic Experts Group”, a committee
    that was formed in the 1980s to create standards so that digital photographs could
    be captured and displayed on different brands of devices. Because some file extensions
    are limited to three characters, it is often seen as the ”.jpg” extension.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: “JPEG” 的名称缩写为 “联合摄影专家小组”，这是一个于 1980 年代成立的委员会，旨在制定标准，以便数字照片可以在不同品牌的设备上捕捉和显示。由于某些文件扩展名仅限于三个字符，因此通常看到的是“.jpg”
    扩展名。
- en: '**Extra for Experts**'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '**专家专用**'
- en: The cosine waves used for JPEG images are based on a “Discrete Cosine Transform”.
    The “Discrete” means that the waveform is digital — it is the opposite of continuous,
    where any value can occur. In a JPEG wave, there are only 8 x 8 values (for the
    block being coded), and each of those values can have a limited range of numbers
    (binary integers), rather than any value at all.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 JPEG 图像的余弦波基于“离散余弦变换”。 “离散”意味着波形是数字化的 — 与连续相反，连续波形可以取任何值。在 JPEG 波形中，每个块只有
    8 x 8 个值，并且每个值只能有一定范围的数字（二进制整数），而不是任意值。
- en: 'An important issue arises because JPEG represents images as smoothly varying
    colours: what happens if the colours change suddenly? In that case, lots of values
    need to be stored so that lots of cosine waves can be added together to make the
    sudden change in colour, or else the edge of the image become fuzzy. You can think
    of it as the cosine waves overshooting on the sudden changes, producing artifacts
    like the ones in the following image where the edges are messy.'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的问题是JPEG将图像表示为平滑变化的颜色：如果颜色突然改变会发生什么？在这种情况下，需要存储大量值，以便将大量余弦波相加以形成颜色的突然变化，否则图像的边缘会变得模糊。你可以将它想象成余弦波在突然变化时过度振荡，产生像下图中边缘凌乱的伪影。
- en: '![](563ad55ee7624.jpg)'
  id: totrans-837
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad55ee7624.jpg)'
- en: The original had sharp edges, but this zoomed in view of the JPEG version of
    it show that not only are the edges gradual, but some darker pixels occur further
    into the white space, looking a bit like shadows or echoes.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 原图有锐利的边缘，但这个JPEG版本的放大视图显示，边缘不仅是渐变的，而且一些较暗的像素出现在白色空间的更深处，看起来有点像阴影或回声。
- en: '![](563ad55e4055f.jpg)'
  id: totrans-839
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad55e4055f.jpg)'
- en: For this reason, JPEG is used for photos and natural images, but other techniques
    (such as GIF and PNG, which we will look at in another section) work better for
    artificial images like this one.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因，JPEG用于照片和自然图像，但其他技术（如GIF和PNG，我们将在另一节中讨论）对于像这样的人工图像效果更好。
- en: '7.4\. IMAGE COMPRESSION: GIF AND PNG'
  id: totrans-841
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4\. 图像压缩：GIF和PNG
- en: '[appearing soon!]'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '[即将出现！]'
- en: 7.5\. GENERAL PURPOSE COMPRESSION
  id: totrans-843
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5\. 通用目的压缩
- en: General purpose compression methods need to be lossless because you can’t assume
    that the user won’t mind if the data is changed. The most widely used general
    purpose compression algorithms (such as ZIP, gzip, and rar) are based on a method
    called “Ziv-Lempel coding”, invented by Jacob Ziv and Abraham Lempel in the 1970s.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 通用目的的压缩方法需要是无损的，因为您不能假设用户不介意数据被更改。最广泛使用的通用目的压缩算法（如ZIP、gzip和rar）基于一种称为“Ziv-Lempel编码”的方法，由雅各布·齐夫和亚伯拉罕·伦佩尔在1970年代发明。
- en: We’ll look at this with a text file as an example. The main idea of Ziv-Lempel
    coding is that sequences of characters are often repeated in files (for example,
    the sequence of characters “image ” appears often in this chapter), and so instead
    of storing the repeated occurrence, you just replace it with a reference to where
    it last occurred. As long as the reference is smaller than the phrase being replaced,
    you’ll save space. Typically this systems based on this approach can be used to
    reduce text files to as little as a quarter of their original size, which is almost
    as good as any method known for compressing text.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以文本文件为例来看看这个问题。Ziv-Lempel编码的主要思想是文件中的字符序列经常重复出现（例如，在本章中，“image ”的字符序列经常出现），因此，您只需将重复出现的内容替换为它最后出现的位置的引用。只要引用小于被替换的短语，您就会节省空间。基于这种方法的系统通常可以将文本文件减少到原始大小的四分之一，这几乎与任何已知的压缩文本的方法一样好。
- en: The following interactive allows you to explore this idea. The empty boxes have
    been replaced with a reference to the text occurring earlier. You can click on
    a box to see where the reference is, and you can type the referenced characters
    in to decode the text. What happens if a reference is pointing to another reference?
    As long as you decode them from first to last, the information will be available
    before you need it.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 以下交互式内容允许您探索这个想法。空白框已用对前文的引用替换。您可以单击框以查看引用的位置，您可以键入引用的字符以解码文本。如果一个引用指向另一个引用会发生什么？只要按顺序解码它们，信息就会在您需要之前可用。
- en: You can also enter your own text by clicking on the “Text” tab. You could paste
    in some text of your own to see how many characters can be replaced with references.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过点击“文本”选项卡输入自己的文本。你可以粘贴一些自己的文本来查看有多少字符可以用引用替换。
- en: 'The references are actually two numbers: the first says how many characters
    to count back to where the previous phrase starts, and the second says how long
    the referenced phrase is. Each reference typically takes about the space of one
    or two characters, so the system makes a saving as long as two characters are
    replaced. The options in the interactive above allow you to require the replaced
    length to be at least two, to avoid replacing a single character with a reference.
    Of course, all characters count, not just letters of the alphabet, so the system
    can also refer back to the white spaces between words. In fact, some of the most
    common sequences are things like a full stop followed by a space.'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 引用实际上是两个数字：第一个数字表示向前数多少个字符到达前一个短语的起始位置，第二个数字表示引用短语的长度。每个引用通常需要大约一个或两个字符的空间，因此只要替换两个字符，系统就可以节省空间。上面的选项允许你要求替换的长度至少为两个字符，以避免用引用替换单个字符。当然，所有字符都计算在内，不仅是字母，所以系统也可以引用单词之间的空格。事实上，一些最常见的序列是句号后面跟着一个空格。
- en: This approach also works very well for black and white images, since sequences
    like “10 white pixels” are likely to have occurred before. Here are some of the
    bits from the example earlier in this chapter; you can paste them into the interactive
    above to see how many pointers are needed to represent it.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于黑白图像也非常有效，因为像“10个白色像素”这样的序列很可能之前已经出现过。这里是本章前面示例中的一些位，你可以将它们粘贴到上面的交互中，看看需要多少指针来表示它。
- en: '[PRE19]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In fact, this is essentially what happens with GIF and PNG images; the pixel
    values are compressed using the Ziv-Lempel algorithm, which works well if you
    have lots of consecutive pixels the same colour. But it works very poorly with
    photographs, where pixel patterns are very unlikely to be repeated.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这基本上就是GIF和PNG图像的工作原理；像素值使用Ziv-Lempel算法进行压缩，如果有很多连续的像素颜色相同，则该算法效果很好。但对于照片来说，情况就非常糟糕了，因为像素模式很不可能重复。
- en: '**Curiosity**'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '**好奇心**'
- en: The method we have described here is named “Ziv-Lempel” compression after Jacob
    Ziv and Abraham Lempel, the two computer scientists who invented it in the 1970s.
    Unfortunately someone mixed up the order of their names when they wrote an article
    about it, and called it “LZ” compression instead of “ZL” compression. So many
    people copied the mistake that Ziv and Lempel’s method is now usually called “LZ
    compression”!
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里描述的方法被称为“Ziv-Lempel”压缩，以杰克·齐夫和亚伯拉罕·莱姆佩尔命名，这两位计算机科学家在1970年代发明了它。不幸的是，有人在写一篇关于它的文章时弄混了他们的名字顺序，并将其称为“LZ”压缩，而不是“ZL”压缩。因此，许多人都复制了这个错误，以至于齐夫和莱姆佩尔的方法现在通常被称为“LZ压缩”！
- en: 7.6\. AUDIO COMPRESSION
  id: totrans-854
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6\. 音频压缩
- en: One of the most widely used methods for compressing music is MP3, which is actually
    from a video compression standard. The Motion Picture Expert Group (MPEG) was
    a consortium of companies and researchers that got together to agree on a standard
    so that people could easily play the same videos on different brands of equipment
    (especially from DVD). The very first version of their standard (called MPEG 1)
    had three methods of storing the sound track (layer 1, 2 and 3). One of those
    methods (MPEG 1 layer 3) became very popular for compressing music, and was abbreviated
    to MP3.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用于压缩音乐的方法之一是MP3，实际上来自视频压缩标准。影像专家组（MPEG）是一个由公司和研究人员组成的联盟，他们聚集在一起达成一个标准，以便人们可以在不同品牌的设备上轻松播放相同的视频（特别是来自DVD）。他们标准的第一个版本（称为MPEG
    1）有三种存储音轨的方法（层1、2和3）。其中一种方法（MPEG 1层3）因为在压缩音乐方面非常流行，被缩写为MP3。
- en: Most other audio compression methods use a similar approach to the MP3 method,
    although some offer better quality for the same amount of storage (or less storage
    for the same quality). It’s not essential to know how this works, but the general
    idea is to break the sound down into bands of different frequencies, and then
    represent each of those bands by adding together the values of a simple formula
    (the sum of cosine waves, to be precise).
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数其他音频压缩方法采用与MP3方法类似的方法，尽管有些方法在相同存储量下提供更好的质量（或者在相同质量下需要更少的存储空间）。了解这个方法的工作原理并不是必需的，但一般的想法是将声音分解成不同频率的频段，然后通过将这些频段的值相加得到一个简单公式的值（准确来说是余弦波的总和）来表示每个频段。
- en: There is some [more detail about how MP3 coding works on the cs4fn site](http://www.cs4fn.org/mathemagic/sonic.html),
    and also in [an article on the I Programmer site](http://www.i-programmer.info/babbages-bag/1222-mp3.html).
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 关于MP3编码的详细信息，请参阅cs4fn网站的[更多详细信息](http://www.cs4fn.org/mathemagic/sonic.html)，以及I程序员网站上的[一篇文章](http://www.i-programmer.info/babbages-bag/1222-mp3.html)。
- en: Other audio compression systems that you might come across include AAC, ALAC,
    Ogg Vorbis, and WMA. Each of these has various advantages over others, and some
    are more compatible or open than others.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到的其他音频压缩系统包括AAC、ALAC、Ogg Vorbis和WMA。每种系统都有其它系统相比的各种优势，并且有些比其他系统更兼容或更开放。
- en: 'The main questions with compressed audio are how small the file can be made,
    and how good the quality is of the human ear. (There is also the question of how
    long it takes to encode the file, which might affect how useful the system is.)
    The tradeoff between quality and size of audio files can depend on the situation
    you’re in: if you are jogging and listening to music then the quality may not
    matter so much, but it’s good to reduce the space available to store it. On the
    other hand, someone listening to a recording at home on a good sound system might
    not mind about having a large device to store the music, as long as the quality
    is high.'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩音频的主要问题是文件可以变得多小以及人耳的音质如何。（还有一个问题是编码文件需要多长时间，这可能会影响系统的实用性。）音频文件质量和大小之间的权衡取决于你所处的情况：如果你正在慢跑并听音乐，那么质量可能不太重要，但减少用于存储音乐的空间是不错的。另一方面，如果有人在家里用好的音响系统收听录音，那么只要质量高，拥有大型设备来存储音乐可能并不重要。
- en: To evaluate an audio compression you should choose a variety of recordings that
    you have high quality originals for, typically on CD (or using uncompressed WAV
    or AIFF files). Choose different styles of music, and other kinds of audio such
    as speech, and perhaps even create a recording that is totally silent. Now convert
    these recordings to different audio format. One system for doing this that is
    free to download is Apple’s iTunes, which can be used to rip CDs to a variety
    of formats, and gives a choice of settings for the quality and size. A lot of
    other audio systems are able to convert files, or have plugins that can do the
    conversion.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 要评估音频压缩，你应该选择多种你有高质量原始文件的录音，通常是在CD上（或使用无压缩的WAV或AIFF文件）。选择不同风格的音乐和其他种类的音频，例如演讲，甚至可能创建一个完全沉默的录音。现在将这些录音转换为不同的音频格式。一个可免费下载的执行此操作的系统是苹果的iTunes，它可用于将CD转换为各种格式，并提供了质量和大小的选择。许多其他音频系统能够转换文件，或者具有能够进行转换的插件。
- en: Compress each of your recordings using a variety of methods, making sure that
    each compressed file is created from a high quality original. Make a table showing
    how long it took to process each recording, the size of the compressed file, and
    some evaluation of the quality of the sound compared with the original. Discuss
    the tradeoffs involved — do you need much bigger files to store good quality sound?
    Is there a limit to how small you can make a file and still have it sounding ok?
    Do some methods work better for speech than others? Does a 2 minute recording
    of silence take more space than a 1 minute recording of silence? Does a 1 minute
    recording of music use more space than a minute of silence?
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 使用各种方法压缩每个录音，确保每个压缩文件都是由高质量原始文件创建的。制作一张表格，显示处理每个录音所需的时间，压缩文件的大小以及与原始文件相比声音质量的评估。讨论所涉及的权衡——你是否需要更大的文件来存储良好质量的声音？你能把文件做得越小声音还是正常的？一些方法对话音的效果更好吗？沉默的2分钟录音比1分钟的沉默录音占用更多空间吗？音乐的1分钟录音比1分钟的沉默录音占用更多空间吗？
- en: 7.7\. THE WHOLE STORY!
  id: totrans-862
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7\. 故事的全貌！
- en: The details of how compression systems work have been glossed over in this chapter,
    as we have been more concerned about the file sizes and speed of the methods than
    how they work. Most compression systems are variations of the ideas that have
    been covered here, although one fundamental method that we haven’t mentioned is
    Huffman coding, which turns out to be useful as the final stage of all of the
    above methods, and is often one of the first topics mentioned in textbooks discussing
    compression (there’s a brief [explanation of it here](http://www.cimt.plymouth.ac.uk/resources/codes/codes_u17_text.pdf).
    A closely related system is Arithmetic coding (there’s an [explanation of it here](http://www.cimt.plymouth.ac.uk/resources/codes/codes_u18_text.pdf)).
    Also, motion picture compression has been omitted, even though compressing videos
    saves more space than most kinds of compression. Most video compression is based
    on the “MPEG” standard (Motion Picture Experts Group). There is some information
    about how this works in the [CS4FN article on “Movie Magic”](http://www.cs4fn.org/films/mpegit.php).
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中忽略了压缩系统的工作细节，因为我们更关心的是文件大小和方法的速度，而不是它们的工作原理。大多数压缩系统都是这里介绍的思想的变体，尽管我们没有提到的一个基本方法是哈夫曼编码，它被证明对于上述所有方法的最后阶段是有用的，并且通常是讨论压缩的教科书中首先提到的主题之一（这里有一个简短的[解释](http://www.cimt.plymouth.ac.uk/resources/codes/codes_u17_text.pdf)）。一个密切相关的系统是算术编码（这里有一个[解释](http://www.cimt.plymouth.ac.uk/resources/codes/codes_u18_text.pdf)）。此外，尽管压缩视频比大多数压缩方法节省更多空间，但动画压缩已被省略。大多数视频压缩都是基于“MPEG”标准（运动图像专家组）。在“电影魔术”上有关于这个工作原理的一些信息[CS4FN文章](http://www.cs4fn.org/films/mpegit.php)。
- en: The Ziv-Lempel method shown is a variation of the so-called “LZ77” method. Many
    of the more popular compression methods are based on this, although there are
    many variations, and one called “LZW” has also been used a lot. Another high-compression
    general-purpose compression method is bzip, based on a very clever method called
    the Burrows-Wheeler Transform.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的齐夫-莱姆佩尔方法是所谓的“LZ77”方法的变体。许多更流行的压缩方法都是基于这个方法的，尽管有许多变体，还有一个叫做“LZW”的方法也被广泛使用。另一种高压缩通用压缩方法是基于一个非常聪明的方法称为Burrows-Wheeler变换的bzip。
- en: Questions like “what is the most compression that can be achieved” are addressed
    by the field of [information theory](http://en.wikipedia.org/wiki/Information_theory).
    There is an [activity on information theory on the CS Unplugged site](http://csunplugged.org/information-theory),
    and there is a [fun activity that illustrates information theory](http://www.math.ucsd.edu/~crypto/java/ENTROPY/).
    Based on this theory, it seems that English text can’t be compressed to less than
    about 12% of its original size at the very best. Images, sound and video can get
    much better compression because they can use lossy compression, and don’t have
    to reproduce the original data exactly.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 像“最大可以实现多少压缩”这样的问题是由信息论领域解决的。在CS Unplugged网站上有一个关于信息论的[活动](http://csunplugged.org/information-theory)，还有一个[有趣的活动来说明信息论](http://www.math.ucsd.edu/~crypto/java/ENTROPY/)。根据这个理论，英文文本在最好的情况下不能压缩到原始大小的12%以下。图像、声音和视频可以获得更好的压缩，因为它们可以使用有损压缩，并且不必完全复制原始数据。
- en: 7.8\. FURTHER READING
  id: totrans-866
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8\. 进一步阅读
- en: “The Data Compression Book” by Mark Nelson and Jean-Loup Gailly is a good overview
    of this topic
  id: totrans-867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马克·尼尔森和让-卢·盖利的《数据压缩书》是这个主题的一个很好的概述
- en: A list of books on this topic (and lots of other information about compression)
    is available from [The Data Compression Site](http://www.data-compression.info/Books/).
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关此主题的书籍列表（以及有关压缩的大量其他信息）可从[数据压缩站点](http://www.data-compression.info/Books/)获取。
- en: Gleick’s book “The Information” has some background to compression, and coding
    in general.
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格雷克的书《信息》对压缩和编码有一些背景知识。
- en: 7.8.1\. USEFUL LINKS
  id: totrans-870
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.8.1\. 有用链接
- en: Images, run-length-coding [http://csunplugged.org/image-representation](http://csunplugged.org/image-representation) This
    is also relevant to binary representations in general, although is probably best
    used in the compression section.
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像，行程编码 [http://csunplugged.org/image-representation](http://csunplugged.org/image-representation)
    这也与一般的二进制表示相关，尽管可能最好在压缩部分中使用。
- en: There is a detailed section on [JPEG encoding on Wikipedia](http://en.wikipedia.org/wiki/Jpeg).
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[维基百科上关于JPEG编码的详细部分](http://en.wikipedia.org/wiki/Jpeg)。'
- en: Text compression [http://csunplugged.org/text-compression](http://csunplugged.org/text-compression)
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本压缩 [http://csunplugged.org/text-compression](http://csunplugged.org/text-compression)
- en: 8\. ENCRYPTION CODING
  id: totrans-874
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8\. 加密编码
- en: 8.1\. WHAT’S THE BIG PICTURE?
  id: totrans-875
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1\. **整体情况如何？**
- en: 'Encryption is used to keep data secret. In its simplest form, a file or data
    transmission is garbled so that only authorised people with a secret key can unlock
    the original text. If you’re using digital devices then you’ll be using systems
    based on encryption all the time: when you use online banking, when you access
    data through through wifi, when your web browser remembers your password, when
    you pay for something with a credit card (either by swiping, inserting or tapping),
    in fact, nearly every activity will involve layers of encryption. Without encryption,
    your information would be wide open to the world — anyone could pull up outside
    a house and read all the data going over your wifi, and stolen laptops, hard disks
    and SIM cards would yield all sorts of information about you — so encryption is
    critical to having computer systems work at all.'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 加密用于保持数据机密。在其最简单的形式中，文件或数据传输被加密，以便只有授权的人员使用秘密密钥才能解锁原始文本。如果你使用数字设备，那么你将始终在使用基于加密的系统：当你使用在线银行时，当你通过wifi访问数据时，当你的网络浏览器记住你的密码时，当你用信用卡支付某物（无论是刷卡、插入还是轻点）时，事实上，几乎每个活动都会涉及到加密的层面。没有加密，你的信息将对世界敞开
    —— 任何人都可以在房子外面停下来，阅读你wifi上传输的所有数据，而丢失的笔记本电脑、硬盘和SIM卡将提供关于你的各种信息 —— 所以加密对于使计算机系统正常运行至关重要。
- en: Of course, we wouldn’t need encryption if we lived in a world where everyone
    was honest and could be trusted, and it was ok for anyone to have access to all
    your personal information such as health records, online discussions, bank accounts
    and so on, and if you knew that no-one would interfere with things like aircraft
    control systems and computer controlled weapons. However, information is worth
    money, people value their privacy, and safety is important, so encryption has
    become fundamental to the design of computer systems. Even breaking the security
    on a traffic light system could be used to personal advantage!
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们生活在一个人人诚实且值得信任的世界，任何人都可以访问所有你的个人信息，如健康记录、在线讨论、银行账户等，并且你知道没有人会干扰到飞机控制系统和计算机控制武器等事物，那么我们就不需要加密。然而，信息价值连城，人们重视他们的隐私，安全是重要的，所以加密已经成为计算机系统设计的基础。甚至破解交通信号系统的安全性都可以用于个人利益！
- en: '**Curiosity**'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '**好奇心**'
- en: An interesting example of the value of using encryption outside of secret messages
    is the two engineers who were convicted of changing traffic light patterns to
    cause chaos during a strike [http://latimesblogs.latimes.com/lanow/2009/12/engineers-who-hacked-in-la-traffic-signal-computers-jamming-traffic-sentenced.html](http://latimesblogs.latimes.com/lanow/2009/12/engineers-who-hacked-in-la-traffic-signal-computers-jamming-traffic-sentenced.html).
    A related problem in the US was traffic signals that could respond to codes from
    emergency vehicles to change to green; originally these didn’t use encryption,
    and people could figure out how to trigger them to their own advantage.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的例子是在秘密消息之外使用加密的价值，两名工程师因改变交通信号灯的模式以在罢工期间造成混乱而被判有罪[http://latimesblogs.latimes.com/lanow/2009/12/engineers-who-hacked-in-la-traffic-signal-computers-jamming-traffic-sentenced.html](http://latimesblogs.latimes.com/lanow/2009/12/engineers-who-hacked-in-la-traffic-signal-computers-jamming-traffic-sentenced.html)。在美国的一个相关问题是交通信号灯可以响应紧急车辆的代码而变为绿色；最初这些代码并没有使用加密，人们可以想办法触发它们以获得自己的利益。
- en: Like all technologies, encryption can be used for good and bad purposes. A human
    rights organisation might use encryption to secretly send photographs of human
    rights abuse to the media, while drug traffickers might use it to avoid having
    their plans read by investigators. Understanding how encryption works and what
    is possible can help to make informed decisions around things like freedom of
    speech, human rights, tracking criminal activity, personal privacy, identity theft,
    online banking and payments, and the safety of systems that might be taken over
    if they were “hacked into”.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有技术一样，加密可用于良好和不良的目的。一个人权组织可能会使用加密将侵犯人权的照片秘密发送给媒体，而毒品走私者可能会使用它来避免调查人员阅读他们的计划。了解加密的工作原理以及可能性可以帮助做出关于言论自由、人权、追踪犯罪活动、个人隐私、身份盗窃、在线银行和支付以及可能被“黑入”的系统安全的知情决策。
- en: 'An encryption system is really two programs: one to *encrypt* some data (referred
    to as *plaintext*) into a form that looks like nonsense (the *ciphertext*), and
    a second program that can *decrypt* the ciphertext back into the plaintext form.'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 加密系统实际上是两个程序：一个用于将一些数据（称为明文）加密为看起来像无意义的形式（密文），另一个程序可以将密文解密回明文形式。
- en: A big issue with encryption systems is people who want to break into them and
    decrypt messages without the key. Some systems that were used many years ago were
    discovered to be insecure because of attacks, so could no longer be used. It is
    possible that somebody will find an effective way of breaking into the widespread
    systems we use these days, which would result in a lot of chaos!
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 加密系统的一个重大问题是想要破解它们并在没有密钥的情况下解密消息的人。许多年前使用过的一些系统被发现因为受到攻击而不再安全，因此不能再使用了。现在有可能有人会找到一种有效的方法来破解我们这些天使用的广泛系统，这将导致很多混乱！
- en: '**Jargon Buster**'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '**行话解释**'
- en: There are various words that can be used to refer to trying to get the plaintext
    from a ciphertext, including decipher, decrypt, crack, and cryptanalysis. Often
    the process of trying to break cryptography is referred to as an “attack”. The
    term “hack” is also sometimes used, but it has other connotations, and is only
    used informally.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种各样的词语可以用来指代从密文中获取明文的过程，包括解密、破解和密码分析。经常将试图破解加密称为“攻击”。术语“黑客”有时也会被使用，但它有其他内涵，只是非正式的用法。
- en: Of course, encryption doesn’t fix all our security problems, and because we
    have such good encryption systems available, information thieves must turn to
    other approaches, especially social engineering. The easiest way to get a user’s
    password is to ask them! A [phishing attack](http://en.wikipedia.org/wiki/Phishing) does
    just that, and there are estimates that as many as 1 in 20 computer users have
    given out secret information this way at some stage.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，加密并不能解决我们所有的安全问题，而且由于我们有这么好的加密系统可用，信息窃贼必须转向其他方法，尤其是社会工程。获得用户密码的最简单方法是询问他们！钓鱼攻击就是这样做的，据估计，多达
    20 名电脑用户曾经通过这种方式泄露过秘密信息。
- en: Other social engineering approaches that can be used include bribing or blackmailing
    people who have access to a system, or simply looking for a password written on
    a sticky note on someone’s monitor! Gaining access to someone’s email account
    is a particularly easy way to get lots of passwords, because many “lost password”
    systems will send a new password to their email account.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用的其他社会工程方法包括贿赂或敲诈那些有权访问系统的人，或者简单地寻找写在某人监视器上的便条上的密码！获得某人的电子邮件帐户访问权限是获取许多密码的特别简单的方法，因为许多“丢失密码”系统会将新密码发送到他们的电子邮件帐户。
- en: '**Jargon Buster**'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '**行话解释**'
- en: When describing an encryption scenario, cryptographers often use the fictitious
    characters “Alice” and “Bob”, with a message being sent from Alice to Bob (A to
    B). We always assume that someone is eavesdropping on the conversation (in fact,
    if you’re using a wireless connection, it’s trivial to pick up the transmissions
    between Alice and Bob as long as you’re in reach of the wireless network that
    one of them is using). The fictitious name for the eavesdropper is usually Eve.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述加密场景时，密码学家经常使用虚构的人物“爱丽丝”和“鲍勃”，一个消息从爱丽丝发送给鲍勃（A 到 B）。我们总是假设有人正在窃听对话（事实上，如果你正在使用无线连接，只要你在无线网络的范围内，就很容易捕获到爱丽丝和鲍勃之间的传输）。窃听者的虚构名通常是伊芙。
- en: '[![](563ad5ef16f7f.png)](http://xkcd.com/1323/)'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad5ef16f7f.png)](http://xkcd.com/1323/)'
- en: 'People who try to decrypt messages are called cryptanalysts; more informal
    terms like hackers and crackers are sometimes used, generally with the implication
    that they have bad intentions. Being a cryptanalyst is generally a good thing
    to do though: people who use encryption systems actually want to know if they
    have weaknesses, and don’t want to wait until the bad guys find out for them.
    It’s like a security guard checking doors on a building; the guard hopes that
    they can’t get in, but if a door is found unlocked, they can do something about
    it to make sure the bad guys can’t get in. Of course, if a security guard finds
    an open door, and takes advantage of that to steal something for themselves, they’re
    no longer doing their job properly!'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试解密消息的人称为密码分析员；更非正式的术语如黑客和破解者有时会被使用，通常暗示他们有恶意。成为密码分析员通常是一件好事：使用加密系统的人实际上希望知道它们是否存在弱点，并且不希望等到坏人替他们发现。这就像一个保安检查建筑物的门；保安希望他们无法进入，但如果发现有门没锁，他们可以采取措施确保坏人无法进入。当然，如果保安发现一扇敞开的门，并利用它偷走了东西，他们就不再适合做好自己的工作了！
- en: '**Curiosity**'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '**好奇心**'
- en: 'There are several other characters used to describe activities around encryption
    protocols: for example Mallory (a malicious attacker) and Trudy (an intruder).
    Wikipedia has a [list of Alice and Bob’s friends](http://en.wikipedia.org/wiki/Alice_and_Bob).'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个其他字符用于描述围绕加密协议的活动：例如 Mallory（一个恶意攻击者）和 Trudy（一个入侵者）。维基百科有一份[爱丽丝和鲍勃的朋友列表](http://en.wikipedia.org/wiki/Alice_and_Bob)。
- en: 8.2\. SUBSTITUTION CIPHERS
  id: totrans-893
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2\. 替换密码
- en: For these activities, you will need to have pen and paper in front of you to
    figure out the answers in this section.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些活动，你需要在你面前准备纸和笔来解决本节中的问题。
- en: Working in a group with 1 or 2 of your classmates (or by yourself if nobody
    else is around), can you figure out what the following message, encrypted with
    a simple cipher, says?
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 与你的1或2位同学一起（如果周围没有其他人，则可以自己操作），你能否弄清楚以下用简单密码加密的消息是什么？
- en: '[PRE20]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: What techniques did your group use to decrypt the message?
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的小组使用了什么技巧来解密消息？
- en: If you haven’t already, write out each letter in the alphabet, and then the
    letter that it corresponds to in the cipher (for the ones that are known, i.e.
    actually were in the cipher). Can you see a pattern?
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你还没有，写出字母表中的每个字母，然后写出它在密码中对应的字母（对于已知的那些，即实际上在密码中的）。你能看出一种模式吗？
- en: If you were going to make a secret message of your own using this same cipher,
    how would you go about it?
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你要用同样的密码制作自己的秘密消息，你会怎么做？
- en: What would be wrong with using this cipher method for a secret you’d never want
    anybody else finding out?
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于你永远不想让别人知道的秘密使用这种密码方法会有什么问题？
- en: 'You may have realised that there was a pattern in how letters from the original
    message corresponded to letters in the decoded one: a letter in the original message
    is decoded to the letter that is 10 places before it in the alphabet. The conversion
    table you drew should have highlighted this. Here’s the table for the letter correspondences,
    where the letter “K” translates to an “A”'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到原始消息中的字母与解码后的字母对应有一种模式：原始消息中的一个字母解码为字母表中它之前10个位置的字母。你绘制的转换表应该已经突显了这一点。以下是字母对应关系表，其中字母“K”转换为“A”。
- en: '![](563ad5edb794d.png)'
  id: totrans-902
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad5edb794d.png)'
- en: The same idea can generate other codes, such as the following one where each
    letter is replaced with the one that is 8 places earlier.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的思想可以生成其他代码，比如下面这个代码，其中每个字母被其前8个字母替换。
- en: '![](563ad5ed0b4f5.png)'
  id: totrans-904
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad5ed0b4f5.png)'
- en: We sometimes say that the alphabet has been *rotated* by 8\. This system of
    rotating each letter in a piece of text by a certain amount in order to encrypt
    it is called Caesar Cipher, named after Julius Caesar, who used it with a rotation
    of 3 to disguise messages.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时说字母表被*旋转*了8位。将文本中的每个字母按一定数量旋转以加密它的系统被称为凯撒密码，以朱利叶斯·凯撒命名，他使用旋转3来掩盖消息。
- en: You can experiment with this cipher using this interactive.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个交互式工具来尝试这个密码。
- en: PLAINTEXT
  id: totrans-907
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 明文
- en: ENCRYPT
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 加密
- en: ROTATION AMOUNT
  id: totrans-909
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 旋转数量
- en: CIPHERTEXT
  id: totrans-910
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 密文
- en: DECRYPT
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 解密
- en: In this system, the amount of rotation is referred to as a *key*, since you
    can unlock the message if you know the key. Normally the sender and receiver would
    agree on a key in advance (and in person), so that the receiver can easily unlock
    the message.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系统中，旋转的数量被称为*密钥*，因为如果你知道密钥，就可以解锁消息。通常发送方和接收方会事先（并且亲自）商定一个密钥，以便接收方可以轻松解锁消息。
- en: However, this encryption method isn’t very secure, and you’ve probably already
    figured out how to crack a coded message. You actually only need to work out what
    one of the corresponding letters is, and then use that to calculate what the rotation
    is, which immediately gives you the key.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种加密方法并不是很安全，你可能已经想出了如何破译编码信息。实际上，你只需要计算出一个对应字母是什么，然后用它来计算旋转是多少，这立即给你提供了密钥。
- en: If for example you identify that the letter “Y” in the encrypted message is
    in place of the letter “R”, you can calculate the rotation by working out how
    many places R is before Y in the alphabet (it might help to write the alphabet
    out on a piece of paper so that you can count the places, as saying the alphabet
    backwards is quite challenging for most people!) As R is 7 places before Y, this
    means that the rotation for this cipher must be 7, and you should be able to convert
    all letters in the encrypted message to an understandable message by subtracting
    7 from them. The quickest way of going about this though would be to write out
    a conversion table like the ones above.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你确定加密消息中的字母“Y”代表字母“R”，你可以通过计算R在字母表中在Y之前多少个位置（可能需要在纸上写出字母表，以便可以数出位置，因为大多数人说字母表倒着说是相当具有挑战性的！）由于R在Y之前7个位置，这意味着此密码的旋转必须为7，你应该能够通过从中减去7来将加密消息中的所有字母转换为可理解的消息。不过，最快的方法是写出一个像上面那样的转换表。
- en: '**Curiosity**'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '**好奇心**'
- en: The Caesar cipher with a key of 13 is the same as an approach called [ROT13
    (rotate 13 characters)](http://en.wikipedia.org/wiki/Rot_13), which is sometimes
    used to obscure things like the punchline of a joke, a spoiler for a story, the
    answer to a question, or text that might be offensive. It is easy to decode (and
    there are plenty of automatic systems for doing so), but the user has to deliberately
    ask to see the deciphered version. A key of 13 for a Caesar cipher has the interesting
    property that the encryption method is identical to the decryption method i.e.
    the same program can be used for both. Actually, many strong encryption methods
    try to make the encryption and decryption processes as similar as possible so
    that the same software and/or hardware can be used for both parts of the task,
    perhaps with only minor adaptions.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 使用密钥为13的凯撒密码与一种称为[ROT13（旋转13个字符）](http://en.wikipedia.org/wiki/Rot_13)的方法相同，有时用于模糊事物，如笑话的结尾，故事的剧透，问题的答案，或可能令人反感的文本。它很容易解码（有很多自动系统可以做到），但用户必须有意要求查看解密版本。凯撒密码的密钥为13具有有趣的特性，即加密方法与解密方法相同，即相同的程序可以用于两者。实际上，许多强加密方法试图使加密和解密过程尽可能相似，以便可以使用相同的软件和/或硬件来执行任务的两个部分，也许只需进行轻微调整。
- en: Taking advantage of the idea that you only need to figure out 1 letter to decide,
    can you figure out what the following message says? Which letter is the best one
    to try and guess? Why? What was the rotation? You may make a few incorrect guesses
    before figuring it out, so be prepared for that! Once you think you know what
    one of the letters in the ciphertext might correspond to in the plaintext, work
    out what the rotation is, and then write out the conversions for that rotation
    and decode the start of the message using that conversion table to see whether
    or not it makes sense. If the first few words seem to be meaningless, then that
    rotation is probably not the correct one.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 利用只需找出1个字母来决定的想法，你能猜出以下消息说了什么吗？哪个字母是最好的猜测？为什么？旋转是多少？在弄清楚之前，你可能会猜错几次，所以要做好准备！一旦你认为知道密文中的一个字母可能对应明文中的哪个字母，就计算旋转是多少，然后根据该转换表解码消息的开头，看看是否有意义。如果前几个单词似乎毫无意义，那么该旋转可能不正确。
- en: '[PRE21]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that you know how to decipher a message that is using Caesar Cipher without
    actually knowing the key, you should be able to see that it would be very easy
    to decipher a message if you know the key. The following message was encrypted
    using a rotation of 6\. Generate the conversion table for a rotation of 6\. This
    should allow you to easily decipher the following message. What does the message
    say? (Use only the conversion table to figure it out!)
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何解密使用凯撒密码加密的消息而不实际知道密钥，你应该能够看到如果知道密钥，解密消息将非常容易。以下消息是使用旋转6加密的。生成旋转6的转换表。这应该让你轻松解密以下消息。消息是什么？（仅使用转换表来解密！）
- en: '[PRE22]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It shouldn’t be too difficult to see how a message can be *encrypted* using
    Caesar Cipher. Previously, you were generating conversion tables that converted
    from the ciphertext to the plaintext. In a very similar way, you can generate
    conversion tables that convert from the plaintext to the ciphertext. The only
    difference is that instead of subtracting the rotation, you are adding it. i.e.
    if the rotation was 5, then the letter “H” in the plaintext would go to the letter
    that is 5 places forward in the alphabet, which is “M”.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 应该不难看出如何使用凯撒密码加密消息。以前，你生成的转换表是从密文转换为明文。以非常相似的方式，你可以生成从明文到密文的转换表。唯一的区别是，你不是减去旋转，而是加上它。即如果旋转是5，那么明文中的字母“H”将转到字母表中向前5个位置的字母，“M”。
- en: Using a rotation of 3, generate a conversion table, and then the ciphertext,
    for the following message.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 使用旋转3，生成一个转换表，然后是以下消息的密文。
- en: '[PRE23]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that all that is out of the way, you can encrypt your own messages (assuming
    it doesn’t matter too much if somebody deciphers them — as you saw above, this
    is not a very secure cipher!). Decide on a message to encrypt, and a rotation
    key. Generate a conversion table, and then encrypt your message.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有这些都搞定了，你可以加密自己的消息（假设如果有人解密它们并不太重要——正如你上面看到的，这不是一个非常安全的密码！）。决定要加密的消息和旋转密钥。生成一个转换表，然后加密你的消息。
- en: If a friend is also doing this activity, once you have your encrypted message
    you could give them the ciphertext and the rotation key (and get them to give
    you theirs), and see if you can decrypt one another’s messages (remember to generate
    a conversion table).
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个朋友也在做这个活动，一旦你有了加密的消息，你可以给他们密文和旋转密钥（并让他们给你他们的），看看你是否可以解密彼此的消息（记得生成一个转换表）。
- en: '**Jargon Buster**'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '**术语解释**'
- en: 'The Caesar is an example of a *substitution cipher*, where each letter is substituted
    for another one. Other substitution ciphers improve on the Caesar cipher by not
    having all the letters in order, and some older written ciphers use different
    symbols for each symbol. However, substitution ciphers are easy to attack because
    a statistical attack is so easy: you just look for a few common letters and sequences
    of letters, and match that to common patterns in the language.'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码是*替换密码*的一个例子，其中每个字母都被替换为另一个字母。其他替换密码通过不按顺序排列所有字母来改进凯撒密码，一些较旧的书面密码使用不同的符号代替每个符号。然而，替换密码易受攻击，因为统计攻击非常容易：你只需寻找一些常见的字母和字母序列，并将其与语言中的常见模式匹配。
- en: 8.3\. PROBLEMS WITH SUBSTITUTION CIPHERS
  id: totrans-928
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3\. 替换密码的问题
- en: 'We have looked at one way of cracking Caesar cipher: using patterns in the
    text. By looking for patterns such as one letter words, other short words, double
    letter patterns, apostrophe positions, and knowing rules such as all words (excluding
    some acronyms and words written in txt language of course) must contain at least
    one of a, e, i, o, u, or y, you were probably able to decipher the messages in
    the book with little difficulty.'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过破解凯撒密码的一种方法：利用文本中的模式。通过寻找诸如单字母单词、其他短词、双字母模式、撇号位置等模式，并知道规则，例如所有单词（当然不包括一些首字母缩写词和用txt语言书写的词）必须至少包含一个a、e、i、o、u或y，你可能能够轻松解密书中的消息。
- en: There are many other ways of cracking Caeser cipher which we will look at in
    this section. Understanding various common attacks on ciphers is important when
    looking at the security of more sophisticated ciphers.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看破解凯撒密码的许多其他方法。了解对密码的各种常见攻击在查看更复杂密码的安全性时非常重要。
- en: 8.3.1\. FREQUENCY ANALYSIS ATTACKS
  id: totrans-931
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1\. 频率分析攻击
- en: Frequency analysis means looking at how many times each letter appears in the
    encrypted message, and using this information to crack the message. A letter that
    appears many times in a message is far more likely to be “T” than “Z”!
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 频率分析意味着查看加密消息中每个字母出现的次数，并利用此信息破解消息。在消息中出现多次的字母更有可能是“T”而不是“Z”！
- en: For example, try copying and pasting the following text into the statistical
    analyser at [http://www.richkni.co.uk/php/crypta/freq.php](http://www.richkni.co.uk/php/crypta/freq.php).
    What is the most common letter in the code? Which English letter is that likely
    to be?
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尝试将以下文本复制并粘贴到[http://www.richkni.co.uk/php/crypta/freq.php](http://www.richkni.co.uk/php/crypta/freq.php)的统计分析器中。代码中最常见的字母是什么？这可能是哪个英文字母？
- en: '[PRE24]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The most common letter in most English text is the letter E, so it makes sense
    to try to decrypt the message guessing that the most common letter in the ciphertext
    corresponds to E.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数英文文本中最常见的字母是字母E，因此猜测密文中最常见的字母对应于E是有道理的。
- en: If that doesn’t work, you could see if the second most common letter in the
    ciphertext is E, and so on.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这行不通，您可以查看密文中第二常见的字母是否是E，依此类推。
- en: '**Curiosity**'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '**好奇心**'
- en: Although in almost all English texts the letter E is the most common letter,
    it isn’t always. For example, the [1939 novel *Gadsby* by Ernest Vincent Wright](http://en.wikipedia.org/wiki/Gadsby_(novel))doesn’t
    contain a single letter E (this is called a lipogram). Furthermore, the text you’re
    attacking may not be English. During World War 1 and 2, the US military had many
    Native American [Code talkers](http://en.wikipedia.org/wiki/Code_talker) translate
    messages into their own language, which provided a strong layer of security at
    the time.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管几乎所有英文文本中字母E是最常见的字母，但并非总是如此。例如，1939年厄内斯特·文森特·赖特（Ernest Vincent Wright）的小说*Gadsby*就没有一个字母E（这被称为唇音法）。此外，您攻击的文本可能不是英文。在一战和二战期间，美国军方有许多美洲原住民*密码破译员*将消息翻译成他们自己的语言，这在当时提供了强大的安全保障。
- en: '**Curiosity**'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '**好奇心**'
- en: A slightly stronger cipher than the Caesar cipher is the [Vigenere cipher](http://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher),
    which is created by using multiple Caesar ciphers, where there is a key phrase
    (e.g. “acb”), and each letter in the key gives the offset (in the example this
    would be 1, 3, 2). These offsets are repeated to give the offset for encoding
    each character in the plaintext.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 比凯撒密码略强的密码是*维吉尼亚密码*，它是通过使用多个凯撒密码创建的，其中有一个关键短语（例如“acb”），关键短语中的每个字母都给出偏移量（在示例中，这将是1、3、2）。这些偏移量被重复使用以给出对明文中每个字符进行编码的偏移量。
- en: By having multiple caesar ciphers, common letters such as E will no longer stand
    out as much, making frequency analysis a lot more challenging. The following website
    shows the effect on the distribution. [http://www.simonsingh.net/The_Black_Chamber/vigenere_strength.html](http://www.simonsingh.net/The_Black_Chamber/vigenere_strength.html)
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用多个凯撒密码，常见字母如E将不再如此突出，使频率分析变得更具挑战性。以下网站显示了分布的影响。[http://www.simonsingh.net/The_Black_Chamber/vigenere_strength.html](http://www.simonsingh.net/The_Black_Chamber/vigenere_strength.html)
- en: However, while this makes the Vigenere cipher more challenging to crack than
    the Caeser cipher, ways have been found to crack it. In fact, once you know the
    key length, it just breaks down to cracking several Caesar ciphers (which you
    have seen is straightforward!). Several statistical methods have been devised
    for working out the key length.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管这使得破解维吉尼亚密码比破解凯撒密码更具挑战性，但已经找到了破解它的方法。实际上，一旦您知道了密钥长度，它只是分解为破解几个凯撒密码（正如您已经看到的那样简单！）。已经制定了几种统计方法来计算密钥长度。
- en: A brute force attack is harder for the Vigenere cipher because there are a lot
    more possible keys. In principle there isn’t a limit to the number of key phrases
    possible, although if the phrase is too long then keeping track of the key would
    be difficult.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 对于维吉尼亚密码，暴力破解更加困难，因为可能的密钥要多得多。原则上，可能的关键短语数没有限制，尽管如果短语太长，则跟踪密钥将会很困难。
- en: The Vigenere cipher is known as a *polyalphabetic substitution cipher*, since
    it is uses multiple substitution rules.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 维吉尼亚密码被称为*多字母替换密码*，因为它使用多个替换规则。
- en: 8.3.2\. PLAIN TEXT ATTACKS
  id: totrans-945
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2\. 明文攻击
- en: Another kind of attack is the *known plaintext* attack, where you know part
    or all of the solution. For example, if you know that I start all my messages
    with “HI THERE”, what is the key for the following message?
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种攻击方式是*已知明文*攻击，其中您知道部分或全部解决方案。例如，如果您知道我所有的消息都以“HI THERE”开头，那么以下消息的密钥是什么？
- en: '[PRE25]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Even if you did not know the key was a rotation, you have learnt that A->H,
    B->I, M->T, X->E, and K->R. This goes a long way towards deciphering the message!
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不知道密钥是旋转，你已经学会了 A->H，B->I，M->T，X->E 和 K->R。这在解密消息方面帮助很大！
- en: A known plaintext attack is trivial for a Caesar cipher, but a good code shouldn’t
    have this vulnerability because there it can be surprisingly easy for someone
    to know that a particular message is being sent. For example, a common message
    might be “Nothing to report”, or in online banking there are likely to be common
    messages like headings in a bank account or parts of the web page that always
    appear.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 对于凯撒密码来说，已知明文攻击是微不足道的，但是一个好的代码不应该有这种漏洞，因为对于某人来说，知道特定消息正在被发送可能会非常容易。例如，一个常见的消息可能是“没有报告”，或者在线银行可能会有像银行帐户标题或网页的部分这样的常见消息。
- en: Even worse is a *chosen plaintext attack*, where you trick someone into sending
    your chosen message through their system.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是*选择性明文攻击*，其中您欺骗某人通过他们的系统发送您选择的消息。
- en: For this reason, it is essential for any good cryptosystem to not be breakable,
    even if the attacker has pieces of plaintext along with their corresponding ciphertext
    to work with.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因，任何好的加密系统都必须是无法破解的，即使攻击者拥有一些明文以及相应的密文也是如此。
- en: Also, the cryptosystem should not give different ciphertext each time the same
    plaintext message is encrypted. It may initially sound impossible to achieve this,
    although there are several clever techniques used by real cryptosystems.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，加密系统不应在加密相同明文消息时每次产生不同的密文。这一开始听起来可能不可能实现，尽管真实加密系统使用了几种巧妙的技术。
- en: 8.3.3\. BRUTE FORCE ATTACKS TO GUESS THE KEY
  id: totrans-953
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3\. 猜测密钥的穷举攻击
- en: Another approach to cracking a ciphertext is a *brute force attack*, which involves
    trying out all possible keys, and seeing if any of them produce intelligible text.
    This is easy for a Caesar cipher because there are only 25 possible keys. For
    example, the following ciphertext is a single word, but is too short for a statistical
    attack. Try putting it into the decoder above, and trying keys until you decipher
    it.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 破解密文的另一种方法是*穷举攻击*，它涉及尝试所有可能的密钥，看看它们中的任何一个是否产生可理解的文本。这对于凯撒密码很容易，因为只有25个可能的密钥。例如，以下密文是一个单词，但对于统计攻击来说太短了。尝试将其放入上面的解码器中，并尝试密钥直到解密它。
- en: '[PRE26]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These days encryption keys are normally numbers that are 128 bits or longer.
    You could calculate how long it would take to try out every possible 128 bit number
    if a computer could test a million every second (including testing if each decoded
    text contains English words). It will eventually crack the message, but would
    it be any use after that amount of time?
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，加密密钥通常是128位或更长的数字。如果一台计算机每秒可以测试一百万个（包括测试每个解码文本是否包含英文单词），您可以计算尝试每个可能的128位数字需要多长时间。它最终会破解消息，但在那么长时间后是否还有用呢？
- en: '**Key size in general substition ciphers**'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '**一般替代密码的密钥大小**'
- en: While Caesar cipher has a key specifying a rotation, a more general substitution
    cipher could randomly scramble the entire alphabet. This requires a key consisting
    of a sequence of 26 letters or numbers, specifying which letter maps onto each
    other one. For example, the first part of the key could be “D, Z, E”, which would
    mean D -> A, Z -> B, E ->C. The key would have to have another 23 letters in order
    to specify the rest of the mapping.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管凯撒密码具有指定旋转的密钥，但更一般的替代密码可以随机打乱整个字母表。这需要一个由26个字母或数字组成的密钥，指定了每个字母映射到其他字母的顺序。例如，密钥的第一部分可以是“D，Z，E”，这意味着
    D -> A，Z -> B，E ->C。密钥还必须包含另外的23个字母，以指定映射的其余部分。
- en: This increases the number of possible keys, and thus reduces the risk of a brute
    force attack. A can be substituted for any of the 26 letters in the alphabet,
    B can then be substituted for any of the 25 remaining letters (26 minus the letter
    already substituted for A), C can then be substituted for any of the 24 remaining
    letters…
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 这增加了可能的密钥数量，从而减少了穷举攻击的风险。A 可以替代字母表中的任何一个字母，然后 B 可以替代剩余的 25 个字母中的任何一个（26 减去已替代
    A 的字母），然后 C 可以替代剩余的 24 个字母中的任何一个……
- en: This gives us 26 possibilities for A times 25 possibilities for B times 24 possibilities
    for C.. all the way down to 2 possibilities for Y and 1 possibility for Z. 26*25*24*23*22*21*20*19*18*17*16*15*14*13*12*11*10*9*8*7*6*5*4*3*2*1
    = 26! Representing each of these possibilites requires around 88 bits, making
    the cipher’s key size around 88 bits!
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们26个A的可能性乘以25个B的可能性乘以24个C的可能性..一直到2个Y的可能性和1个Z的可能性。26*25*24*23*22*21*20*19*18*17*16*15*14*13*12*11*10*9*8*7*6*5*4*3*2*1
    = 26! 表示这些可能性需要大约88位，使得密码的密钥大小约为88位！
- en: However, this only solves one of the problems. The other techniques for breaking
    caeser cipher we have looked at are still highly effective on all substitution
    ciphers. For this reason, we need better ciphers in practice, which we will look
    at shortly!
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只解决了其中一个问题。我们已经看过的破解凯撒密码的其他技术在所有替换密码上仍然非常有效。因此，实际上我们需要更好的密码，我们很快会看到！
- en: '**Jargon Buster**'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '**术语解释**'
- en: The main terminology you should be familiar with now is that a *plaintext* is *encrypted* by
    to create a *ciphertext* using an *encryption key*. Someone without the encryption
    key who wants to *attack* the cipher could try various approaches, including a *brute
    force attack* (trying out all possible keys), a *frequency analysis attack* (looking
    for statistical patterns), and a *known plaintext attack* (matching some known
    text with the cipher to work out the key).
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该熟悉的主要术语是，*明文*通过使用*加密密钥*加密以创建*密文*。没有加密密钥的人想要*攻击*密码可能会尝试各种方法，包括*暴力破解攻击*（尝试所有可能的密钥）、*频率分析攻击*（寻找统计模式）和*已知明文攻击*（将一些已知文本与密码匹配以找出密钥）。
- en: '**Steganography**'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐写术**'
- en: Cryptography is about hiding the content of a message, but sometimes it’s important
    to hide the *existence* of the message. Otherwise an enemy might figure out that
    something is being planned just because a lot more messages are being sent, even
    though they can’t read them. One way to achieve this is via *steganography*, where
    a secret message is hidden inside another message that seems innocuous. A classic
    scenario would be to publish a message in the public notices of a newspaper or
    send a letter from prison where the number of letters in each word represent a
    code. To a casual reader, the message might seem unimportant (and even say the
    opposite of the hidden one), but someone who knows the code could work it out.
    Messages can be hidden in digital images by making unnoticable changes to pixels
    so that they store some information. You can find out [more about steganography
    on Wikipedia](http://en.wikipedia.org/wiki/Steganography) or in this [lecture
    on steganography](http://www.youtube.com/watch?v=Py-qu9KWXhk#t=29).
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学是关于隐藏消息内容的，但有时隐藏消息的*存在*也很重要。否则，敌人可能会因为发送了更多的消息而猜测到正在计划某事，即使他们无法阅读这些消息。实现这一目标的一种方法是通过*隐写术*，在一个看似无害的消息中隐藏一个秘密消息。一个经典的场景可能是在报纸的公告中发布一条消息，或者从监狱寄出一封信，其中每个单词的字母数代表一个代码。对于一个随意读者来说，这条消息可能看起来不重要（甚至说出隐藏消息的反面），但了解代码的人可以解读出来。消息可以通过对像素进行微不可见的更改来隐藏在数字图像中，以便存储一些信息。你可以在维基百科上找到[更多关于隐写术的信息](http://en.wikipedia.org/wiki/Steganography)，或者在这个[关于隐写术的讲座](http://www.youtube.com/watch?v=Py-qu9KWXhk#t=29)中了解更多。
- en: Two fun uses of steganography that you can try to decode yourself are a [film
    about ciphers that contains hidden ciphers (called “The Thomas Beale Cipher”)](http://www.thomasbealecipher.com/),
    and an activity that has [five-bit text codes hidden in music](http://csunplugged.org/modem).
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试自己解码的两种有趣的隐写术用途是一个[关于包含隐藏密码的密码的电影（名为“托马斯·比尔密码”）](http://www.thomasbealecipher.com/)，以及一个在音乐中隐藏了[五位文本代码的活动](http://csunplugged.org/modem)。
- en: 8.4\. PUBLIC KEY SYSTEMS
  id: totrans-967
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4\. **公钥系统**
- en: 8.4.1\. THE KEY DISTRIBUTION PROBLEM
  id: totrans-968
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1\. **密钥分发问题**
- en: Alice sending an encrypted message to Bob raises an interesting problem in encryption.
    The ciphertext itself can safely be sent across an “unsafe” network (one that
    Eve is listening on), but the key cannot. How can Alice get the key to Bob? Remember
    the key is the thing that tells Bob how to convert the ciphertext back to plaintext.
    So Alice can’t include it in the encrypted message, because then Bob would be
    unable to access it! Alice can’t just include it as plaintext either, because
    then Eve will be able to get ahold of it and use it to decrypt any messages that
    come through using it! You might ask why Alice doesn’t just encrypt the key using
    a different encryption scheme, but then how will Bob know the new key? Alice would
    need to tell Bob the key that was used to encrypt it... and so on... this idea
    is definitely out!
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 艾丽斯向鲍勃发送加密消息在加密中引起了一个有趣的问题。密文本身可以安全地通过“不安全”的网络（即夏娃正在监听的网络）发送，但密钥不能。艾丽斯如何将密钥传递给鲍勃？请记住，密钥是告诉鲍勃如何将密文转换回明文的东西。所以艾丽斯不能将它包含在加密消息中，因为那样鲍勃将无法访问它！艾丽斯也不能将其作为明文包含，因为那样夏娃将能够获得并使用它来解密使用它的任何消息！你可能会问为什么艾丽斯不只是使用不同的加密方案加密密钥，但那么鲍勃如何知道新密钥？艾丽斯需要告诉鲍勃用于加密的密钥...依此类推...这个想法绝对不可行！
- en: Remember that Alice and Bob might be in different countries, and can only communicate
    through the internet. This also rules out Alice simply passing Bob the key in
    person.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，艾丽斯和鲍勃可能在不同的国家，并且只能通过互联网进行通信。这也排除了艾丽斯简单地亲自传递密钥给鲍勃的可能性。
- en: Distributing keys physically is very expensive, and up to the 1970s large sums
    of money were spent physically sending keys internationally. Systems like this
    are call*symmetric* encryption, because Alice and Bob both need an identical copy
    of the key. The breakthrough was the realisation that you could make a system
    that used different keys for encoding and decoding!
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 将密钥物理分发非常昂贵，直到1970年代，大量资金被用于物理发送密钥国际间。这样的系统称为*对称*加密，因为艾丽斯和鲍勃都需要一份相同的密钥副本。突破在于意识到你可以设计一个使用不同密钥进行编码和解码的系统！
- en: 8.4.2\. SOLVING THE PROBLEM WITH PUBLIC KEY SYSTEMS
  id: totrans-972
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2\. 通过公钥系统解决问题
- en: One of the remarkable discoveries in computer science in the 1970s was a method
    called *public key encryption*, where it’s fine to tell everyone what the key
    is to encrypt any messages, but you need a special private key to decrypt it.
    Because Alice and Bob use different keys, this is called an *asymmetric* encryption
    system.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪70年代计算机科学中一个显著的发现是一种称为*公钥加密*的方法，其中可以告诉每个人用于加密任何消息的密钥，但需要一个特殊的私密密钥来解密它。因为艾丽斯和鲍勃使用不同的密钥，所以这被称为一个*非对称*加密系统。
- en: It’s like giving out padlocks to all your friends, so anyone can lock a box
    and send it to you, but if you have the only (private) key, then you are the only
    person who can open the boxes. Once your friend locks a box, even they can’t unlock
    it. It’s really easy to distribute the padlocks. Public keys are the same — you
    can make them completely public — often people put them on their website or attach
    them to all emails they send. That’s quite different to having to hire a security
    firm to deliver them to your colleague.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像给所有朋友分发挂锁，这样任何人都可以锁上盒子并把它寄给你，但如果你拥有唯一（私密）密钥，那么只有你才能打开盒子。一旦你的朋友锁上盒子，即使他们自己也无法打开。分发挂锁非常容易。公钥也是一样的
    - 你可以完全公开它们 - 通常人们将它们放在他们的网站上或附加到他们发送的所有电子邮件上。这与不得不雇佣安全公司将它们递送给你的同事完全不同。
- en: Public key encryption is very heavily used for online commerce (such as internet
    banking and credit card payment) because your computer can set up a connection
    with the business or bank automatically using a public key system without you
    having to get together in advance to set up a key. Public key systems are generally
    slower than symmetric systems, so the public key system is often used to then
    send a new key for a symmetric system just once per session, and the symmetric
    key can be used from then on with a faster symmetric encryption system.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密在在线商务中被广泛使用（例如互联网银行和信用卡支付），因为您的计算机可以使用公钥系统自动与企业或银行建立连接，而无需您事先会面设置密钥。公钥系统通常比对称系统慢，因此通常使用公钥系统一次向会话发送一个新的对称系统密钥，然后从那时起使用更快的对称加密系统。
- en: A very popular public key system is RSA. The following interactives use RSA
    so that you can try using a public key system for yourself.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常流行的公钥系统是RSA。以下互动使用RSA，这样你就可以尝试使用公钥系统。
- en: Firstly, you will need to generate a pair of keys using the key generator interactive.
    Note that each key consists of two numbers and the interactive separates them
    with a “+” (this does not mean addition). You should keep the private key secret,
    and publicly announce the public key so that your friends can send you messages
    (e.g. put it on the whiteboard, or email it to some friends). Make sure you save
    your keys somewhere so you don’t forget them — a text file would be best.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要使用密钥生成器交互式生成一对密钥。请注意，每个密钥都由两个数字组成，交互式用“+”分隔它们（这并不意味着加法）。您应该保密私钥，并公开宣布公钥，以便您的朋友可以向您发送消息（例如，将其放在白板上，或将其电子邮件给一些朋友）。确保您将密钥保存在某个地方，以防忘记它们
    — 最好是一个文本文件。
- en: RSA Key Generator
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 密钥生成器
- en: Public Key
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥
- en: Private Key
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥
- en: The second interactive is the encrypter, and it is used to encrypt or decrypt
    messages with the keys. In order to encrypt messages for you, your friends should
    use your public key (and select the “encrypt” button on the interactive). In order
    to decrypt the messages your friends have sent you, you should use your private
    key (and select the “decrypt” button on the interactive).
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个交互式是加密器，用于使用密钥加密或解密消息。为了为您加密消息，您的朋友应该使用您的公钥（并在交互式上选择“加密”按钮）。为了解密您的朋友发送给您的消息，您应该使用您的私钥（并在交互式上选择“解密”按钮）。
- en: RSA Encrypter & Decrypter
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 加密器和解密器
- en: Mode
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 模式
- en: Encrypt Decrypt
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 加密 解密
- en: Key
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥
- en: Text
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 文本
- en: Output
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 输出
- en: Despite even your enemies knowing your public key (as you publically announced
    it), they cannot use it to decrypt your messages which were encrypted using the
    public key.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是您的敌人知道您的公钥（因为您公开宣布了它），他们也不能使用它来解密使用公钥加密的您的消息。
- en: '**Digital Signatures** In order to encrypt a message, the public key is used.
    In order to decrypt it, the corresponding private key must be used. But what would
    happen if the message was encrypted using the *private* key? Could you then decrypt
    it with the public key? Initially this might sound like a silly thing to do, as
    why would you encrypt a message which can be decrypted using a key that everybody
    in the world can access!?! It turns out that indeed, encrypting a message with
    the private key and then decrypting it with the public key works, and it has a
    very useful application! The only person who is able to *encrypt* the message
    using the *private* key is the person who owns the private key. The public key
    will only decrypt the message if the private key that was used to encrypt it actually
    is the public key’s corresponding private key! If the message can’t be decrypted,
    then it could not have been encrypted with that private key. This allows the sender
    to prove that the message actually is from them, and is known as a digital signature.'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字签名** 为了加密一条消息，使用公钥。为了解密它，必须使用相应的私钥。但是如果使用 *私钥* 加密消息会发生什么呢？你能用公钥解密吗？起初，这可能听起来很愚蠢，因为为什么你要用全世界都可以访问的密钥来加密一条消息呢？事实证明，使用私钥加密消息然后使用公钥解密是有效的，并且有一个非常有用的应用！能够 *加密* 消息的唯一人是拥有私钥的人。只有在使用私钥加密的消息确实是公钥的相应私钥时，公钥才能解密消息！如果消息无法解密，则不能用该私钥加密。这使得发送者能够证明消息确实来自他们，被称为数字签名。'
- en: You could check that someone is the authentic private key holder by giving them
    a phrase to encrypt with their private key. You then decrypt it with the public
    key to check that they encrypted the phrase you gave them.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给予某人一句话并用他们的私钥加密，你可以检查某人是否是真正的私钥持有者。然后，你用公钥解密它来检查他们是否加密了你给他们的短语。
- en: Note that this interactive’s implementation of RSA only uses around 50 bits
    of encryption and has other weaknesses. It is just for demonstrating the concepts
    here and is not quite the same as the implementations used in live encryption
    systems. In the RSA chapter, we will look at a more realistic implementation.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此交互式的 RSA 实现仅使用约 50 位的加密，并具有其他弱点。这只是为了演示这里的概念，并不完全与实际加密系统中使用的实现相同。在 RSA
    章节中，我们将看到一个更实际的实现。
- en: There’s a [video illustrating how public key systems work using a padlock analogy
    which might help to understand how asymmetric keys could work.](http://www.youtube.com/watch?v=a72fHRr6MRU)
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 [视频以挂锁类比说明公钥系统如何工作，可能有助于理解非对称密钥如何工作。](http://www.youtube.com/watch?v=a72fHRr6MRU)
- en: '**Jargon Buster**'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '**术语解释**'
- en: 'Public key systems rely on *one way functions*, which are mathematical functions
    where it’s easy to calculate the output for a particular input, but very hard
    to work out the input given the output. In the physical world a telephone book
    is a one-way function: if you’re given a name, it’s easy to work out the number,
    but given someone’s phone number, it’s difficult to work out their name from the
    phone book. In cryptography a widely used one-way function is multiplying numbers.
    Given two large numbers, you can multiply them very quickly, but given the result
    of the multiplication, it is very difficult to find out what its factors are.
    For example, see if you can work out which numbers multiply to give 806,849,546,124,373,268,247,678,601\.
    You could try writing a program to try every combination of factors, but you’ll
    probably find it takes too long. Although this particular number can be factorised
    by modern software, larger numbers can’t be, and this is a problem that mathematicians
    and computer scientists can’t find an efficient solution to.'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥系统依赖于*单向函数*，这是数学函数，对于特定输入很容易计算输出，但很难根据输出计算出输入。在物理世界中，电话簿是一个单向函数：如果给定一个名字，很容易找到号码，但给定某人的电话号码，从电话簿中找到他们的名字很困难。在密码学中，一个广泛使用的单向函数是乘法。给定两个大数，你可以很快地将它们相乘，但是给定乘法的结果，很难找出它的因数是什么。例如，看看你能否计算出哪些数字相乘得到806,849,546,124,373,268,247,678,601。你可以尝试编写一个程序来尝试每种因数的组合，但你可能会发现这需要太长时间。虽然这个特定数字可以被现代软件分解，但更大的数字无法分解，这是数学家和计算机科学家找不到有效解决方案的问题。
- en: '**Jargon Buster**'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '**术语解释**'
- en: The methods that we considered at the start of this chapter are *symmetric key* systems,
    which just means that you use the same key to encode and decode the text. Public
    key systems are often called *asymmetric key* systems, where the sender and receiver
    have different keys. An asymmetric system can make it a lot easier to distribute
    the encryption key, because if the eavesdropper gets hold of it, all they can
    do is encrypt messages, not decrypt them, so they are no use for attacking messages.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开头考虑的方法是*对称密钥*系统，这意味着您使用相同的密钥来编码和解码文本。公钥系统通常被称为*非对称密钥*系统，发送方和接收方有不同的密钥。非对称系统可以使分发加密密钥变得更容易，因为如果窃听者获得了密钥，他们只能加密消息，而不能解密消息，因此对于攻击消息是无用的。
- en: 8.5\. THE RSA CRYPTOSYSTEM
  id: totrans-997
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5. RSA加密系统
- en: The RSA cryptosystem is a widely used algorithm for public key systems. Many
    real world cryptosystems are based on RSA. Because it is a public key system,
    this means that keys are in pairs; a private key and a public key. A message that
    was encrypted using the public key can only be decrypted using the private key.
    This means that the key owner is able to keep their private key secret, and distribute
    their public key to the world.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: RSA加密系统是公钥系统的广泛使用算法。许多现实世界的加密系统都是基于RSA的。因为它是一个公钥系统，这意味着密钥是成对的；一个私钥和一个公钥。使用公钥加密的消息只能使用私钥解密。这意味着密钥所有者能够保持他们的私钥秘密，并将他们的公钥分发给世界。
- en: In a nutshell, the RSA cryptosystem uses some clever math based on the unsolved
    mathematical problem of efficiently *factoring* a number which is the product
    of two prime numbers. If you need a reminder of what prime numbers and factoring
    a number are, read the Jargon Buster just below.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，RSA加密系统使用一些聪明的数学，基于未解决的数学问题，即有效地*分解*两个质数的乘积。如果您需要提醒什么是质数和分解一个数字，请阅读下面的术语解释。
- en: '**Jargon Buster**'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: '**术语解释**'
- en: 'Remember that the factors of a number are all the numbers which divide into
    it without giving a remainder. For example: The factors of 12 are 1, 2, 3, 4,
    6, and 12\. Numbers such as 5 and 7 are NOT factors of 12, because 12 divided
    by 7 gives 1 remainder 5.'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 记住一个数字的因数是所有能够整除它而不产生余数的数字。例如：12的因数是1、2、3、4、6和12。像5和7这样的数字不是12的因数，因为12除以7余1余5。
- en: If a number only has 1 and itself as factors (i.e. all other numbers would give
    a remainder if divided into it), it is a prime number (For example, the factors
    of 37 are only 1 and 37, making it a prime number).
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数字只有1和它自己作为因数（即所有其他数字如果被除以它会产生余数），那么它是一个质数（例如，37的因数只有1和37，使其成为质数）。
- en: Factoring means to find all the factors of a number.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 分解意味着找到一个数字的所有因数。
- en: Currently the only known algorithm to find what the two primes that were multiplied
    are is a brute force one that has to try most of the possibilities that are less
    the the number itself. If the number is massive, then that is a huge number of
    possibilities that need to be checked, and it cannot be done before the sun is
    expected to burn out, even with huge amounts of computing power! This problem
    is known as the *factoring problem*. A public and private key pair has a mathematical
    relationship to the primes that were used.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 目前已知的唯一算法是通过蛮力法来查找相乘的两个质数，需要尝试大多数小于该数本身的可能性。如果这个数字非常大，那么需要检查的可能性就会非常多，即使使用大量的计算能力，也无法在太阳预计燃尽之前完成！这个问题被称为*因子分解问题*。公钥和私钥对具有与使用的质数的数学关系。
- en: If somebody was to find a good solution to this problem that could work on massive
    numbers, then RSA would no longer be secure, unlocking many important computer
    systems around the world including banks! Mathematicians are quite confident no
    such solution exists though. We aren’t going to go any further into the mathematical
    details here.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人找到了一个可以处理大数字的好解决方案，那么 RSA 将不再安全，解锁全球许多重要的计算机系统，包括银行！数学家相当有信心，没有这样的解决方案存在。我们在这里不打算进一步探讨数学细节。
- en: The following interactive provides a key generator and encrypter/decrypter for
    RSA. [http://travistidwell.com/jsencrypt/demo/](http://travistidwell.com/jsencrypt/demo/)
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 以下互动提供了 RSA 的密钥生成器和加密器/解密器。[http://travistidwell.com/jsencrypt/demo/](http://travistidwell.com/jsencrypt/demo/)
- en: Keys of various sizes can be generated, and then used to encrypt a message.
    Encryption is carried out using the *public key*. Decryption is carried out using
    the *private key*
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 可以生成各种大小的密钥，然后用于加密消息。加密使用*公钥*进行，解密使用*私钥*进行。
- en: '**Easy vs Difficult problems in Computer Science**'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算机科学中的简单与困难问题**'
- en: If you were asked to multiply the following two big prime numbers, you might
    find it a bit tiring to do by hand (although it is definitely doable!), but could
    get an answer in milliseconds by putting it in the big numbers calculator! (included
    just below this box).
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你被要求计算下面两个大质数的乘积，你可能会觉得手动计算有点累（尽管肯定是可以做到的！），但是通过将其输入到大数字计算器中，你可以在毫秒内得到答案！（包含在此框的正下方）。
- en: '[PRE27]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If on the other hand you were asked what two prime numbers were multiplied to
    get the following big number, you’d have a lot more trouble! (If you do find the
    answer, let us know! We’d be very interested to hear about it!)
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果有人问你要得到下面这个大数的两个质数，你会遇到更多麻烦！（如果你找到了答案，请告诉我们！我们会非常感兴趣听到！）
- en: '[PRE29]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So why is it that despite these two problems being similar, one of them is “easy”
    and the other one is “hard”? Well, it comes down to the algorithms we have to
    solve each of the problems. You have probably done long multiplication in school
    by making one line for each digit in the second number and then adding all the
    rows together. We can analyse the speed of this algorithm, much like we did in
    the algorithms chapter for sorting and searching. Assuming that each number has
    the same number of digits, which we will call n (“Number of digits”), we need
    to write n rows. For each of those n rows, we will need to do around n multiplications.
    That gives us n*n little multiplications. We need to add the n rows together at
    the end as well, but that doesn’t take long so lets ignore that part. We have
    determined that the number of small multiplications needed to multiply two big
    numbers is approximately the square of the number of digits. So for two numbers
    with 1000 digits, that’s 1,000,000 little multiplication operations. A computer
    can do that in less than a second! If you know about Big-O notation, this is a
    O(n^2) algorithm, where n is the number of digits! Note that some slightly better
    algorithms have been designed, but this estimate is good enough for our purposes.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么尽管这两个问题相似，一个“简单”而另一个“难”呢？嗯，这归结于我们用来解决每个问题的算法。你可能在学校里通过为第二个数字的每个数字都划出一行，然后将所有行加在一起来做长乘法。我们可以分析这个算法的速度，就像我们在算法章节对排序和搜索所做的那样。假设每个数字具有相同的位数，我们将其称为n（“数字位数”），我们需要写n行。对于这n行中的每一行，我们将需要大约n次乘法。这给我们带来了n*n个小乘法。我们还需要在最后将这n行加在一起，但那不需要太长时间，所以让我们忽略那部分。我们已经确定了将两个大数相乘所需的小乘法数量大约是数字位数的平方。所以对于两个有1000位数的数字来说，那就是100万个小乘法操作。一个计算机可以在不到一秒的时间内完成这个操作！如果你了解大O符号，这是一个O(n^2)的算法，其中n是数字的位数！请注意，已经设计了一些稍微好一点的算法，但是这个估计已经足够满足我们的需求。
- en: For the second problem, we’d need an algorithm that could find the two numbers
    that were multiplied together. You might initially say, why can’t we just reverse
    the multiplication? The reverse of multiplication is division, so can’t we just
    divide to get the two numbers? It’s a good idea, but it won’t work. For division
    we need to know the big number, and one of the small numbers we want to divide
    into it, and that will give us the other small number. But in this case, we *only* know
    the big number. So it isn’t a straightforward long division problem at all! It
    turns out that there is no known good algorithm to solve the problem. One way
    is to just try every number that is less than the number (well, we only need to
    go up to the square root, but that doesn’t help much!) There is still billions
    of billions of billions of numbers we need to check. Even a computer that could
    check 1 billion possibilities a second isn’t going to help us much with this!
    If you know about Big-O notation, this is an O(10^n) algorithm, where n is the
    number of digits – even small numbers of digits are just too much to deal with!
    There are slightly better solutions, but none of them shave off enough time to
    actually be useful for problems of the size of the one above!
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个问题，我们需要一个能够找到相乘的两个数字的算法。你可能一开始会说，为什么我们不能简单地将乘法倒过来呢？乘法的倒数是除法，所以我们不能只是除以得到这两个数字吗？这是一个好主意，但是不起作用。对于除法，我们需要知道大数和我们想要除以的其中一个小数，这样就可以得到另一个小数。但在这种情况下，我们**仅仅**知道大数。所以这根本不是一个简单的长除法问题！事实证明，没有已知的好算法来解决这个问题。一种方法是尝试每一个比这个数小的数字（好吧，我们只需要一直尝试到平方根，但这并没有帮助多少！）我们仍然需要检查数十亿亿亿个数字。即使是一个可以每秒检查
    10 亿个可能性的计算机也不会对我们有太大帮助！如果你了解大O符号，这是一个O(10^n)的算法，其中n是数字的位数 - 即使是小位数也太难处理了！有稍微好一点的解决方案，但是它们都没有减少足够的时间来真正对上述问题大小有用！
- en: The chapter on Complexity and Tractability looks at more computer science problems
    which are surprisingly challenging to solve. If you found this stuff interesting,
    do read about Complexity and Tractability when you are finished here!
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 关于复杂性和可解性的章节涵盖了更多令人惊讶的难以解决的计算机科学问题。如果你觉得这些东西有趣，请在完成这里的阅读后阅读关于复杂性和可解性的内容！
- en: '[![](563ad5ec6def9.png)Click to load'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad5ec6def9.png)点击加载'
- en: big number calculator](http://csfieldguide.org.nz/_static/widgets/big-calculator.html?plain=true%20frameborder=)
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: '[大数计算器](http://csfieldguide.org.nz/_static/widgets/big-calculator.html?plain=true%20frameborder=)'
- en: What isn’t known though, is whether or not the general problem of breaking RSA
    is actually as difficult as the factoring problem. In other words, is there a
    completely different way of breaking it that does not involve factoring numbers?
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，不知道的是，是否破解 RSA 的一般问题实际上是否像分解问题一样困难。换句话说，是否有一种完全不涉及分解数字的方式来破解它？
- en: What happens when we try the tricks that we could use to break Caesar cipher?
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试我们可以用来破解凯撒密码的技巧时会发生什么？
- en: 8.5.1\. DOES RSA REVEAL ANY PATTERNS IN THE CIPHERTEXT?
  id: totrans-1021
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.1\. RSA 密文中是否显露出任何模式？
- en: You will need to scroll up to the Caesar cipher interactive for this exercise.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要向上滚动到凯撒密码交互以进行此练习。
- en: 'Using a Caesar cipher key of your choice, encrypt a short sentence, for example:'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您选择的凯撒密码密钥，加密一句简短的句子，例如：
- en: '[PRE30]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, encrypt a very similar sentence using the same key, for example:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用相同的密钥加密一个非常相似的句子，例如：
- en: '[PRE31]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Put the ciphertext for each side by side. As you might expect, they look very
    similar. This is problematic given that if Eve has the first message, she could
    probably use it to guess the second one! This means Caesar cipher is not *semantically
    secure*. It is essential that ciphers used in practice are!
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个密文并排放置。正如你可能预料的那样，它们看起来非常相似。鉴于如果伊芙拥有第一条消息，她可能会用它来猜测第二条消息！这意味着凯撒密码不是*语义安全*的。在实践中使用的密码必须是!
- en: But what about RSA? Do similar plaintext messages lead to similar ciphertext
    messages when RSA is used?
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 RSA 呢？当使用 RSA 时，类似的明文消息是否会导致类似的密文消息？
- en: In order to find out, generate an RSA key and use it to encrypt each of the
    two above messages. What do you observe?
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出，生成一个 RSA 密钥并使用它来加密上述两条消息。你观察到了什么？
- en: Because of how RSA encrypts messages, the way each character is jumbled is dependent
    on all the other characters in the message. This makes many of the analysis techniques
    we used to break Caeser cipher useless for breaking RSA! Well, nearly...
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 RSA 加密消息的方式，每个字符的混淆方式取决于消息中的所有其他字符。这使得我们用来破解凯撒密码的许多分析技术对于破解 RSA 来说毫无用处！好吧，几乎……
- en: '**Jargon Buster: Semantically Secure**'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '**术语解释：语义安全**'
- en: Semantically secure means that there is no known efficient algorithm that can
    use the ciphertext to get any information about the plaintext, other than the
    length of the message. It is very important that cryptosystems used in practice
    are semantically secure.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 语义安全意味着没有已知的有效算法可以使用密文获取有关明文的任何信息，除了消息的长度。实践中使用的密码系统非常重要的是语义安全的。
- en: 8.5.2\. ADDING PADDING TO THE PLAINTEXT
  id: totrans-1033
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.2\. 向明文添加填充
- en: The plain RSA algorithm actually fails one important requirement of a good cryptosystem
    though! If Eve thinks she knows what message Alice is sending to Bob using public
    key encryption, she can attempt to encrypt that message using the public key and
    then see if the ciphertext she gets is the same as what Alice sent. If it is,
    she now knows what Alice sent Bob!
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，普通的 RSA 算法实际上没有满足一个好的密码系统的一个重要要求！如果伊芙认为她知道爱丽丝使用公钥加密发送给鲍勃的消息是什么，她可以尝试使用公钥加密该消息，然后看看她得到的密文是否与爱丽丝发送的相同。如果是，她现在知道爱丽丝发送给鲍勃的内容！
- en: Luckily, a simple solution to this problem has been found. Alice can add random *padding* to
    the plaintext message, which then gets mixed into her message in the ciphertext.
    As long as Bob’s computer knows how much padding is on the message so that once
    it decrypts the message, it can throw away the padding, this will work.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，已经找到了这个问题的一个简单解决方案。爱丽丝可以向明文消息中添加随机*填充*，然后将其混合到她的消息中以生成密文。只要鲍勃的计算机知道消息上有多少填充，以便在解密消息后，它可以丢弃填充，这将起作用。
- en: For example, assume 5 characters of padding have been added onto the end of
    Alice’s message. Hi Bob, want to meet for lunch?1si98 Even if Eve knew it was
    likely Alice was asking Bob to go to lunch with her, she would have no way of
    knowing what random padding has been used. She might try Hi Bob, want to meet
    for lunch?72kld
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设已经向爱丽丝的消息末尾添加了 5 个字符的填充。嗨，鲍勃，想要一起吃午饭吗？1si98即使伊芙知道爱丽丝很可能是在邀请鲍勃和她一起吃午饭，她也无法知道使用了什么随机填充。她可能会尝试嗨，鲍勃，想要一起吃午饭吗？72kld
- en: Try encrypting both of these messages using the same public key. Is there any
    way to know from the ciphertext that they are even the same message?
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用相同的公钥加密这两条消息。有办法从密文中知道它们甚至是相同的消息吗？
- en: Cryptosystems which implement RSA use padding in order to counteract this weakness
    of RSA in practice. This makes them *semantically secure*
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 实施RSA的加密系统使用填充以抵消RSA在实践中的这种弱点。这使它们在语义上是安全的。
- en: 8.5.3\. CAN WE JUST GUESS THE RSA KEY?
  id: totrans-1039
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.3\. 我们可以猜测RSA密钥吗？
- en: You might remember from the Algorithms chapter that problems can have good and
    bad algorithms to solve them, and that a good algorithm is fast even when the
    size of the problem is massive. While we have no good algorithms for breaking
    a message that is encrypted with RSA without the key, we have good algorithms
    for encrypting or decrypting the message, given the appropriate key. This means
    that large keys can be used, that will take a long time to guess with brute force.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得算法章节中提到，问题可以有好的和坏的算法来解决，而好的算法在解决大规模问题时也能够迅速运行。尽管我们没有好的算法来破解用RSA加密的消息而不使用密钥，但是我们有很好的算法来加密或解密消息，只要有适当的密钥。这意味着可以使用大型密钥，这将需要很长时间才能用暴力方法猜测。
- en: If we were using a key size of 1024 bits (which is pretty standard), this would
    mean that there are 2^1024 different possible keys. Even if every computer in
    the world was working to guess the key and was able to check a million combinations
    a second, the universe will still end well before the key is guessed!
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用1024位的密钥大小（这是相当标准的），这意味着有2^1024种不同的可能密钥。即使世界上的每台计算机都在工作以猜测密钥，并且能够每秒检查一百万个组合，宇宙仍将在密钥被猜出之前结束！
- en: You might like to calculate how long it would take for various levels of encryption
    to be broken. e.g. 256, 1024, 2048, and 4096 using a big numbers calculator.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要计算各种加密级别被破解需要多长时间。例如，256、1024、2048和4096使用大型数字计算器。
- en: RSA normally uses keys in the size range of 1024 bits to 4096 bits. This makes
    it incredibly unlikely for somebody to guess the key!
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: RSA通常使用1024位到4096位的密钥范围。这使得有人猜测密钥的可能性极小！
- en: 8.5.4\. A PITFALL OF RSA
  id: totrans-1044
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.4\. RSA的一个陷阱
- en: So far RSA has held up really well against the potential attacks we have looked
    at. However, one big problem exists. How can Alice be certain that the public
    key she is about to use actually is Bob’s? This problem isn’t trivial, as Eve
    could easily publish that a public key belongs to Bob, when infact it is Eve that
    has the private key for it! All she has to do is get Alice to encrypt a message
    with that public key, mistakenly believing it is Bob’s, and she can now intercept
    and read the message with the private key she holds!
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，RSA对我们所关注的潜在攻击表现得非常出色。但是，存在一个大问题。Alice如何确保她即将使用的公钥实际上是Bob的？这个问题并不是微不足道的，因为Eve很容易发布一个公钥属于Bob，而事实上是Eve拥有它的私钥！她所要做的就是让Alice使用那个错误地相信是Bob的公钥加密消息，然后她就可以拦截并读取使用她持有的私钥的消息了！
- en: No mathematical solution exists, although there is a practical solution. Public
    Key Certificates are distributed by Public Key Certificate Authorities (CA’s)
    in order to prove the ownership of a public key. This now assumes that the CA’s
    are trustworthy and that they won’t be fooled or compromised. For the most part
    it works, although there have been some [worrying exceptions…](http://en.wikipedia.org/wiki/Certificate_authority#CA_compromise)
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 没有数学解决方案，尽管存在实际解决方案。公钥证书由公钥证书颁发机构（CA）分发，以证明公钥的所有权。这现在假定CA是值得信任的，并且它们不会被欺骗或被破坏。大部分情况下它是有效的，尽管也有一些[令人担忧的例外情况…](http://en.wikipedia.org/wiki/Certificate_authority#CA_compromise)
- en: 8.6\. THE WHOLE STORY!
  id: totrans-1047
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6\. 故事的全部！
- en: Many of the examples in this chapter use very weak encryption methods that were
    chosen to illustrate concepts, but would never be used for commercial or military
    systems.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多示例使用非常薄弱的加密方法来说明概念，但绝不会用于商业或军事系统。
- en: There are many aspects to computer security beyond encryption. For example,
    access control (such as password systems and security on smart cards) is crucial
    to keeping a system secure. Another major problem is writing secure software which
    doesn’t leave ways for a user to get access to information that they shouldn’t
    (such as typing a database command into a website query and have the system accidentally
    run it, or overflowing the buffer with a long input, which could accidentally
    replace parts of the program). Also, systems need to be protected from “denial
    of service” (DOS) attacks, where they get so overloaded with requests (e.g. to
    view a web site) that the server can’t cope, and legitimate users get very slow
    response from the system, or it might even fail completely.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机安全除了加密之外还有许多方面。例如，访问控制（如密码系统和智能卡上的安全性）对保持系统安全至关重要。另一个主要问题是编写安全软件，不会留下用户获取不应获取的信息的方法（例如，在网站查询中键入数据库命令并使系统意外运行它，或者用长输入溢出缓冲区，可能会意外替换程序的某些部分）。此外，系统需要受到“拒绝服务”（DOS）攻击的保护，即它们因请求（例如查看网站）过多而超负荷，服务器无法应对，并且合法用户从系统获得的响应非常缓慢，或者甚至可能完全失败。
- en: For other kinds of attacks relating to computer security, see the [Wikipedia
    entry on Hackers](http://en.wikipedia.org/wiki/Hacker_(computer_security)).
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 关于计算机安全的其他类型攻击，请参阅[黑客的维基百科条目](http://en.wikipedia.org/wiki/Hacker_(computer_security))。
- en: There’s a dark cloud hanging over the security of all current encryption methods: [Quantum
    computing](http://en.wikipedia.org/wiki/Quantum_computer). Quantum computing is
    in its infancy, but if this approach to computing is successful, it has the potential
    to run very fast algorithms for attacking our most secure encryption systems (for
    example, it could be used to factorise numbers very quickly). In fact, the quantum
    algorithms have already been invented, but we don’t know if quantum computers
    can be built to run them. Such computers aren’t likely to appear overnight, and
    if they do become possible, they will also open the possibility for new encryption
    algorithms. This is yet another mystery in computer science where we don’t know
    what the future holds, and where there could be major changes in the future. But
    we’ll need very capable computer scientists around at the time to deal with these
    sorts of changes!
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 当前所有加密方法的安全性都笼罩着一层阴影：[量子计算](http://en.wikipedia.org/wiki/Quantum_computer)。量子计算处于初级阶段，但如果这种计算方法成功，它有可能以非常快的算法运行攻击我们最安全的加密系统（例如，它可能被用于快速因式分解数字）。事实上，量子算法已经被发明出来，但我们不知道量子计算机是否能够运行它们。这样的计算机不太可能一夜之间出现，而且如果它们变得可能，它们也将为新的加密算法打开可能性。这是计算机科学中的另一个未解之谜，我们不知道未来会发生什么变化，未来可能会发生重大变化。但在那个时候，我们将需要非常有能力的计算机科学家来处理这些变化！
- en: On the positive side, [quantum information transfer protocols](http://en.wikipedia.org/wiki/Quantum_cryptography_protocol) exist
    and are used in practice (using specialised equipment to generate quantum bits);
    these provide what is in theory a perfect encryption system, and don’t depend
    on an attacker being unable to solve a particular computational problem. Because
    of the need for specialised equipment, they are only used in high security environments
    such as banking.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 在积极的一面，[量子信息传输协议](http://en.wikipedia.org/wiki/Quantum_cryptography_protocol)存在并且在实践中被使用（使用专门的设备生成量子位）；这些在理论上提供了完美的加密系统，不依赖于攻击者无法解决特定的计算问题。由于需要专门的设备，它们仅在银行等高安全环境中使用。
- en: 8.7\. FURTHER READING
  id: totrans-1053
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7\. 进一步阅读
- en: The [Wikipedia entry on cryptography](http://en.wikipedia.org/wiki/Cryptography) has
    a fairly approachable entry going over the main terminology used in this chapter
    (and a lot more)
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '[密码学的维基百科条目](http://en.wikipedia.org/wiki/Cryptography)具有相当易懂的入口，介绍了本章节使用的主要术语（以及更多）。'
- en: The encryption methods used these days rely on fairly advanced maths; for this
    reason books about encryption tend to either be beyond high school level, or else
    are about codes that aren’t actually used in practice.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 当今使用的加密方法依赖于相当先进的数学；因此，关于加密的书籍往往要么超出高中水平，要么是关于实际上并未使用的密码。
- en: There are lots of intriguing stories around encryption, including its use in
    wartime and for spying e.g.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 加密领域有许多引人入胜的故事，包括其在战时和间谍活动中的应用等。
- en: How I Discovered World War II’s Greatest Spy and Other Stories of Intelligence
    and Code (David Kahn)
  id: totrans-1057
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何发现第二次世界大战最伟大的间谍和其他情报和密码的故事（大卫·卡恩）
- en: 'Decrypted Secrets: Methods and Maxims of Cryptology (Friedrich L. Bauer)'
  id: totrans-1058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密的秘密：密码学的方法与格言（弗里德里希·L·鲍尔）
- en: 'Secret History: The Story of Cryptology (Craig Bauer)'
  id: totrans-1059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密历史：密码学的故事（克雷格·鲍尔）
- en: 'The Codebreakers: The Comprehensive History of Secret Communication from Ancient
    Times to the Internet (David Kahn) — this book is an older version of his new
    book, and may be hard to get'
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破译者：从古至今的秘密通信全面历史（大卫·卡恩）——这本书是他新书的旧版本，可能很难获取。
- en: 'The following activities explore cryptographic protocols using an Unplugged
    approach; these methods aren’t strong enough to use in practice, but provide some
    insight into what is possible:'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 以下活动探讨了使用脱机方法的加密协议；这些方法不足以在实践中使用，但可以提供一些了解：
- en: '[http://csunplugged.org/information-hiding](http://csunplugged.org/information-hiding)'
  id: totrans-1062
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://csunplugged.org/information-hiding](http://csunplugged.org/information-hiding)'
- en: '[http://csunplugged.org/cryptographic-protocols](http://csunplugged.org/cryptographic-protocols)'
  id: totrans-1063
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://csunplugged.org/cryptographic-protocols](http://csunplugged.org/cryptographic-protocols)'
- en: '[http://csunplugged.org/public-key-encryption](http://csunplugged.org/public-key-encryption)'
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://csunplugged.org/public-key-encryption](http://csunplugged.org/public-key-encryption)'
- en: '[War in the fifth domain](http://www.economist.com/node/16478792) looks at
    how encryption and security are key to our defence against a new kind of war.'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: '[第五域的战争](http://www.economist.com/node/16478792) 研究了加密和安全如何是我们防御一种新型战争的关键。'
- en: There are lots of [articles in cs4fn on cryptography](http://www.cs4fn.org/security/crypto/),
    including [a statistical attack that lead to a beheading](http://www.cs4fn.org/security/beheading/secrets1.html).
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多关于密码学的文章，包括导致斩首的统计攻击。
- en: 'The book “Hacking Secret Ciphers with Python: A beginner’s guide to cryptography
    and computer programming with Python” (by Al Sweigart) goes over some simple ciphers
    including ones mentioned in this chapter, and how they can be programmed (and
    attacked) using Python programs.'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍《用Python破译秘密密码：一本关于密码学和使用Python进行计算机编程的初学者指南》（作者：阿尔·斯维加特）介绍了一些简单的密码，包括本章中提到的密码，以及如何使用Python程序进行编程（和攻击）。
- en: 8.7.1\. USEFUL LINKS
  id: totrans-1068
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.1\. 有用的链接
- en: '[How Stuff Works entry on Encryption](http://www.howstuffworks.com/encryption.htm)'
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[加密的工作原理](http://www.howstuffworks.com/encryption.htm)'
- en: '[Cryptool](http://www.cryptool.org/) is a free system for trying out classical
    and modern encryption methods. Some are beyond the scope of this chapter, but
    many will be useful for running demonstrations and experiments in cryptography.'
  id: totrans-1070
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Cryptool](http://www.cryptool.org/) 是一个免费的系统，用于尝试经典和现代加密方法。其中一些超出了本章的范围，但许多对于在密码学中进行演示和实验是有用的。'
- en: '[Wikipedia entry on Cryptographic keys](http://en.wikipedia.org/wiki/Key_%28cryptography%29)'
  id: totrans-1071
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[维基百科关于密码键的条目](http://en.wikipedia.org/wiki/Key_%28cryptography%29)'
- en: '[Wikipedia entry on the Caesar cipher](http://en.wikipedia.org/wiki/Caesar_cypher)'
  id: totrans-1072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[维基百科关于凯撒密码的条目](http://en.wikipedia.org/wiki/Caesar_cypher)'
- en: '[Videos about modern encryption methods](http://simonsingh.net/media/online-videos/cryptography/the-science-of-secrecy-going-public/)'
  id: totrans-1073
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[关于现代加密方法的视频](http://simonsingh.net/media/online-videos/cryptography/the-science-of-secrecy-going-public/)'
- en: '[Online interactives for simple ciphers](http://www.braingle.com/brainteasers/codes/index.php)'
  id: totrans-1074
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简单密码的在线互动](http://www.braingle.com/brainteasers/codes/index.php)'
- en: 9\. ERROR CONTROL CODING
  id: totrans-1075
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9\. 错误控制编码
- en: 9.1\. WHAT’S THE BIG PICTURE?
  id: totrans-1076
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1\. 大局是什么？
- en: The parity magic trick (in the video above) enables the magician to detect which
    card out of dozens has been flipped over while they weren’t looking. The magic
    in the trick is actually computer science, using the same kind of technique that
    computers use to detect and correct errors in data. We will talk about how it
    works in the next section.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 平均数魔术（在上面的视频中）使魔术师能够在他们不看的时候检测到已经翻转的数十张卡片中的哪一张。这个魔术的技巧实际上是计算机科学，使用与计算机在数据中检测和纠正错误时相同类型的技术。我们将在下一节讨论它是如何工作的。
- en: The same thing is happening to data stored on computers — while you (or the
    computer) is looking away, some of it might accidentally change because of a minor
    fault. When the computer reads the data, you don’t want it to just use the incorrect
    values. At the least you want it to detect that something has gone wrong, and
    ideally it should do what the magician did, and put it right.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机上存储的数据也发生了同样的事情——当您（或计算机）转身时，由于小故障，一些数据可能会意外更改。当计算机读取数据时，您不希望它只是使用不正确的值。至少，您希望它能够检测到出现了错误，并且理想情况下，它应该像魔术师一样做，将其纠正。
- en: This chapter is about guarding against errors in data in its many different
    forms — data stored on a harddrive, on a CD, on a floppy disk, on a solid state
    drive (such as that inside a cellphone, camera, or mp3 player), data currently
    in RAM (particularly on servers where the data correctness is critical), data
    going between the RAM and hard drive or between an external hard drive and the
    internal hard drive, data currently being processed in the processor or data going
    over a wired or wireless network such as from your computer to a server on the
    other side of the world. It even includes data such as the barcodes printed on
    products or the number on your credit card.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的是防范数据中错误的多种不同形式 — 存储在硬盘上的数据，存储在光盘、软盘、固态硬盘上的数据（如手机、相机或 MP3 播放器内部的数据），目前存储在
    RAM 中的数据（特别是在数据正确性至关重要的服务器上），在 RAM 和硬盘之间或在外部硬盘与内部硬盘之间传输的数据，目前在处理器中处理的数据或通过有线或无线网络传输的数据，例如从您的计算机到世界另一端的服务器。甚至包括产品上打印的条形码或您的信用卡号。
- en: If we don’t detect that data has been changed by some physical problem (such
    as small scratch on a CD, or a failing circuit in a flash drive), the information
    will just be used with incorrect values. A very poorly written banking system
    could potentially result in your bank balance being changed if just one of the
    bits in a number was changed by a cosmic ray affecting a value in the computer’s
    memory! If the barcode on the packet of chips you buy from the shop is scanned
    incorrectly, you might be charged for shampoo instead. If you transfer a music
    file from your laptop to your mp3 player and a few of the bits were transferred
    incorrectly, the mp3 player might play annoying glitches in the music. Error control
    codes guard against all these things, so that (most of the time) things just work
    without you having to worry about such errors.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有检测到数据由于某种物理问题（如 CD 上的小划痕或闪存驱动器中的电路故障）而发生更改，那么信息将会以不正确的值使用。一个编写非常糟糕的银行系统可能会导致您的银行余额发生更改，如果计算机内存中的值受到宇宙射线的影响而更改了一个位！如果从商店购买的薯片袋上的条形码被错误扫描，您可能会被收取洗发水的费用。如果您从笔记本电脑转移到
    MP3 播放器的音乐文件中有一些位传输不正确，MP3 播放器可能会在音乐中播放烦人的故障。错误控制编码防范所有这些问题，使得（大部分时间）事情只是正常运行，而无需担心此类错误。
- en: There are several ways that data can be changed accidentally. Networks that
    have a lot of “noise” on them (caused by poor quality wiring, electrical interference,
    or interference from other networks in the case of wireless). The bits on disks
    are very very small, and imperfections in the surface can eventually cause some
    of the storage to fail. The surfaces on compact disks and DVDs are exposed, and
    can easily be damaged by storage (e.g. in heat or humidity) and handling (e.g.
    scratches or dust). Errors can also occur when numbers are typed in, such as entering
    a bank account number to make a payment into, or the number of a container that
    is being loaded onto a ship. A barcode on a product might be slightly scratched
    or have a black mark on it, or perhaps the package is bent or is unable to be
    read properly due to the scanner being waved too fast over it. Bits getting changed
    on permanent storage (such as hard drives, optical disks, and solid state drives)
    is sometimes referred to as bit rot, and the [wikipedia page on bit rot](http://en.wikipedia.org/wiki/Bit_rot) has
    a list of more ways that these errors can occur.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可能会因多种原因而发生意外更改。网络上可能存在大量的“噪音”（由于质量低劣的布线、电气干扰或无线网络中其他网络的干扰）。硬盘上的位非常非常小，表面的瑕疵最终可能导致部分存储失败。光盘和
    DVD 的表面是裸露的，容易受到存储（如高温或湿度）和处理（如划痕或灰尘）的损害。在输入数字时也可能出错，比如输入用于付款的银行账号，或者正在装载到船上的集装箱号码。产品上的条形码可能会有轻微划痕或黑色污渍，或者包装被弯曲或由于扫描仪快速移动而无法正确读取。在永久存储介质（如硬盘、光盘和固态硬盘）上发生位变化有时被称为位腐败，[位腐败的维基百科页面](http://en.wikipedia.org/wiki/Bit_rot)列出了更多这些错误可能发生的方式。
- en: Nobody wants a computer that is unreliable and won’t do what it’s supposed to
    do because of bits being changed! So, how can we deal with these problems?
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人希望计算机不可靠，因为位被更改而无法按照预期运行！那么，我们如何处理这些问题呢？
- en: Error control coding is concerned with detecting when these errors occur, and
    if practical and possible, correcting the data to what it is supposed to be.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 错误控制编码涉及到检测这些错误的发生，并在实践和可能的情况下将数据更正为其应有的值。
- en: Some error control schemes have error correction built into them, such as the
    parity method that was briefly introduced at the beginning of this section. You
    might not understand yet how the parity trick worked, but after the card was flipped,
    the magician *detected* which card was flipped, and was able to *correct* it.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 一些错误控制方案中内置了错误校正，比如在本节开头简要介绍的奇偶校验方法。也许你还不明白奇偶校验技巧是如何工作的，但在卡片翻转后，魔术师*检测到*哪张卡片被翻动了，并且能够*纠正*它。
- en: Other error control schemes, such as those that deal with sending data from
    a server overseas to your computer, send the data in very small pieces called
    packets (the network protocols chapter talks about this) and each packet has error
    detection information added to it.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 其他的错误控制方案，比如处理从海外服务器发送到您计算机的数据，会将数据分成非常小的片段，称为数据包（网络协议章节介绍了这一点），每个数据包都会添加错误检测信息。
- en: Error detection is also used on barcode numbers on products you buy, as well
    as the unique ISBN (International Standard Book Number) that all books have, and
    even the 16 digit number on a credit card. If any of these numbers are typed or
    scanned incorrectly, there’s a good chance that the error will be detected, and
    the user can be asked to re-enter the data.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 条形码上也使用了错误检测，用于您购买的产品，以及所有图书都有的唯一的ISBN（国际标准图书编号），甚至是信用卡上的16位数。如果其中任何一个号码输入或扫描错误，很有可能会检测到错误，并要求用户重新输入数据。
- en: By the end of this chapter, you should understand the basic idea of error control
    coding, the reasons that we require it, the differences between algorithms that
    can detect errors and those that can both detect and correct errors, and some
    of the ways that error control coding is used, in particular parity (focussing
    on the parity magic trick) and the check digits used to ensure book numbers, barcode
    numbers, and credit card numbers are entered correctly.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，你应该理解错误控制编码的基本概念，我们为什么需要它，能够检测错误和能够检测和纠正错误之间的算法的区别，以及错误控制编码的一些应用方式，特别是奇偶校验（重点放在奇偶校验魔术技巧上）和用于确保书号、条形码号和信用卡号正确输入的检查位。
- en: 9.2\. THE PARITY MAGIC TRICK
  id: totrans-1088
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2\. 奇偶校验魔术技巧
- en: If you have never seen the parity magic trick before, check out the video in
    the “What’s the Bigger Picture?” section above. This section assumes that you
    know what is meant by the parity magic trick, but now we’ll explain how it actually
    works!
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未见过奇偶校验魔术技巧，请查看上面“更大的图景是什么？”部分的视频。本节假设您知道奇偶校验魔术技巧是什么意思，但现在我们将解释它是如何实际工作的！
- en: A magician asks an observer to lay out a square grid of two-sided cards, and
    the magician then says they are going to make it a bit harder, and add an extra
    row and column to the square. The magician then faces the other way while the
    observer flips over one card. The magician turns back around again, and tells
    the observer which card was flipped!
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 一个魔术师要求一个观察者摆出一个双面卡片的正方形网格，然后魔术师说他们要让它变得更难一些，并在正方形上增加一行和一列。然后，当观察者翻转一张卡片时，魔术师背过身去。魔术师再次转过身来，告诉观察者哪张卡片被翻动了！
- en: The question now is, how did the magician know which card had been flipped without
    seeing the card being flipped, or memorising the layout?! The short answer is
    error control coding. Let’s look more closely at that…
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，魔术师如何在没有看到卡片被翻动或记忆布局的情况下知道哪张卡片被翻动了呢？简短的答案是错误控制编码。让我们更仔细地看看...
- en: 9.2.1\. CARRYING OUT THE PARITY TRICK
  id: totrans-1092
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1\. 执行奇偶校验技巧
- en: You are now going to take the role of the magician and carry out the trick yourself.
    The interactive below will allow you to practice it.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将扮演魔术师的角色，并执行这个技巧。下面的互动将让您练习它。
- en: In the interactive, the computer has a 7x7 grid of black and white cards. You
    must choose the colour of an extra card for each row (at the right) and column
    (at the bottom), making an 8x8 grid of cards. Each extra card should be chosen
    so that each row and column has an even number of black cards (since there are
    8 cards, there will also be an even number of white cards). The bottom right-hand
    card can be chosen from either its row or column; they should both give the same
    colour. Once you think you have this correct, you should tell the computer to
    flip a card. An animation will appear for a few seconds, and then the cards will
    reappear with one card flipped (all the rest will be the same as before). Your
    task is to identify the flipped card. You should be able to do this *without* having
    memorised the layout. Remember the pattern you made with the extra cards you added?
    That’s the key to figuring it out. Once you think you have identified the card,
    click it to see whether or not you were right! The interactive will guide you
    through these instructions. If you are completely stuck identifying the flipped
    card, a hint follows the interactive, although you should try and figure it out
    for yourself first! Make sure you add the extra cards correctly; the computer
    won’t tell you if you get them wrong, and you probably won’t be able to identify
    the flipped card if the extra cards aren’t chosen correctly.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式中，计算机有一个 7x7 的黑白卡片网格。你必须为每行（在右边）和每列（在底部）选择一个额外卡片的颜色，形成一个 8x8 的卡片网格。每个额外卡片应该被选择，以便每行和每列都有偶数个黑色卡片（因为有
    8 张卡片，所以也会有偶数个白色卡片）。右下角的卡片可以从其行或列中选择；它们应该都给出相同的颜色。一旦你认为这个正确，你应该告诉计算机翻转一张卡片。一个动画会出现几秒钟，然后卡片将重新出现，其中一张卡片被翻转（其余都与之前相同）。你的任务是识别被翻转的卡片。你应该能够在没有记住布局的情况下完成这个任务。记住你用添加的额外卡片做成的图案？这就是解决问题的关键。一旦你认为你已经识别出了卡片，点击它查看你是否正确！交互式将指导你完成这些说明。如果你完全卡在识别翻转的卡片上，交互式后面会有一个提示，但你应该尝试自己解决问题！确保你正确添加了额外卡片；计算机不会告诉你如果你选择错了，如果额外卡片选择错误，你可能无法识别翻转的卡片。
- en: '[![](563ad79c608bd.png)Click to load the parity widget](http://csfieldguide.org.nz/_static/widgets/DR/DR-Parity/public_html/index.html)'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad79c608bd.png)点击加载奇偶校验小部件](http://csfieldguide.org.nz/_static/widgets/DR/DR-Parity/public_html/index.html)'
- en: Remember how you made it so that each column had an even number of black cards?
    When a card is flipped, this results in the row and column that the card was in
    having an odd number of black cards. So all you need to do is to identify the
    row and column that have an odd number of black and white cards, and the card
    that is at the intersection of them must be the one that was flipped!
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 记得你是怎样做的，以使得每一列都有偶数个黑色卡片吗？当一张卡片被翻转时，这导致了卡片所在的行和列的黑色卡片数量为奇数。因此，你所需要做的就是确定有奇数个黑色和白色卡片的行和列，并且位于它们交点处的卡片必须是被翻转的那张！
- en: What we saw above is a simple error control coding algorithm, known as *2-dimensional
    parity*.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面看到的是一个简单的错误控制编码算法，称为*二维奇偶校验*。
- en: 'The cards represent bits, with their two states being black and white (in the
    “data representation” chapter we looked at how a bit can be stored by anything
    that can be in one of two states: shiny/not shiny, magnetised/not magnetised,
    high voltage/low voltage, black/white, etc). The original 7x7 cards that the computer
    laid out for you could be some kind of data, for example some text represented
    using bits, or an image, or some numbers. Although they are laid out in a grid,
    on a computer the rows of bits would be stored or transmitted one after the other
    (as 8 lots of 8 bits).'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 这些卡片代表位，它们有黑色和白色两种状态（在“数据表示”章节中，我们看到位可以通过任何可以处于两种状态中的事物来存储：闪亮/不闪亮，磁化/未磁化，高电压/低电压，黑/白等）。计算机为你摆出的原始
    7x7 卡片可以是某种数据，例如使用位表示的一些文本，或者图像，或者一些数字。虽然它们是按网格布置的，但在计算机上，位的行将依次存储或传输（作为 8 组 8
    位）。
- en: The extra cards you added are called *parity bits*. Parity simply means whether
    a number is even or odd (the word comes from the same root as “pair”). By adding
    the extra cards in a way that ensured an even number of black cards in each row
    and column, you made it so that the rows and columns had what is called *even
    parity*.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加的额外卡片被称为*奇偶校验位*。奇偶校验简单地表示一个数字是偶数还是奇数（这个词源自“pair”）。通过以确保每行和每列中的黑色卡片数量为偶数的方式添加额外卡片，你使得行和列具有所谓的*偶校验*。
- en: When a card was flipped, this simulated an error being made in your data (such
    as a piece of dust landing on a bit stored on a CD, or a cosmic ray changing a
    bit stored on a hard disk, or electrical interference changing a bit being sent
    over a network cable). Because you knew that each row and column was supposed
    to have an even number of black and white cards in it, you could tell that there
    was an error from the fact that there was a column and row that had an odd number
    of black cards in it. This means that the algorithm is able to detect errors,
    i.e. it has **error detection**. The specific card that had been flipped was at
    the intersection of the row and column that had an odd number of black cards and
    white cards in them, and because you were able to identify exactly which card
    was flipped, you were able to correct the error, i.e the algorithm has **error
    correction**.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 当一张卡片被翻转时，这就模拟了数据中发生错误的情况（比如一粒灰尘落在存储在 CD 上的位上，或者宇宙射线改变了存储在硬盘上的位，或者电气干扰改变了通过网络电缆发送的位）。因为你知道每行和每列应该有偶数张黑卡和白卡，你可以从有一列和一行中有奇数张黑卡的事实中知道有错误发生。这意味着该算法能够检测错误，即具有**错误检测**功能。被翻转的具体卡片位于具有奇数张黑卡和白卡的行和列的交叉点，因为你能够准确地识别哪张卡片被翻转，所以你能够纠正错误，即该算法具有**错误纠正**功能。
- en: If you had not added the parity bits, you would have had no way of even knowing
    an error had occurred, unless you had memorised the entire layout of cards! And
    what if more than one bit had been flipped? We’ll consider this later.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有添加奇偶校验位，你甚至都不知道发生了错误，除非你记住了整个卡片的布局！如果有多个位被翻转了呢？我们稍后再讨论这个问题。
- en: '**Being a magician**'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: '**成为一个魔术师**'
- en: Now that you have learnt how the parity trick works, you might like to try it
    with a physical set of cards like the busker in the video, or you could use any
    objects with two distinct sides, such as coins or cups. You could use playing
    cards, but the markings can be distracting, and cards with two colours are easiest
    (you can make them by cutting up sheets of card with the two colours on, or single
    coloured card with a scribble or sticker on one side).
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了奇偶校验的技巧，你可能想尝试用视频中的街头艺人那样的实体卡片集，或者你可以使用任何具有两个不同面的物体，比如硬币或杯子。你可以使用扑克牌，但是上面的标记可能会分散注意力，而具有两种颜色的卡片最容易（你可以通过剪裁带有两种颜色的卡片或单色卡片的一面上有涂鸦或贴纸来制作它们）。
- en: 'You can find details and lots of ideas relating to the trick [here](http://csunplugged.org/error-detection),
    or follow these instructions:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到关于这个技巧的详细信息和许多想法，或者按照以下说明操作：
- en: Ask a friend to lay out 25 cards in a 5 by 5 grid, trying to have a reasonably
    random mix of blacks and whites (this is smaller than the one in the interactive,
    but it is easier to have fewer cards to avoid errors in the next step!)
  id: totrans-1105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求一个朋友在 5x5 的网格中摆放 25 张卡片，尽量让黑卡和白卡有一个相对随机的混合（这比互动中的要小，但为了避免下一步中的错误，卡片数量较少更容易！）
- en: Take all the remaining cards, and then say that actually, 5 by 5 is too easy
    so you are going to make it 6 by 6\. Instead of adding the new row and column
    randomly though, you are adding them in the way you did in the interactive (even
    parity). Do this as fast as you can without making errors (it can look very casual
    if you practise this, even though the cards are being carefully selected).
  id: totrans-1106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿起剩下的所有卡片，然后说实际上，5x5 太容易了，所以你要把它变成 6x6。但是，你不是随机添加新的行和列，而是按照你在互动中所做的方式添加（偶校验）。尽量快速地做到没有错误（如果你练习过，这看起来可能非常随意，尽管卡片是精心选择的）。
- en: Tell your friend that you are going to face the other way, and you want them
    to flip over one card while you are not looking.Check that they’ve flipped exactly
    one card.
  id: totrans-1107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉你的朋友，你要背对着他们，让他们在你不看的时候翻一张卡片。确保他们只翻了一张卡片。
- en: Turn around again once they have flipped a card, look through the rows and columns,
    identifying a row and then a column that has an odd number of black cards in it.
    The flipped card will be the one at the intersection of that row and column. Flip
    that card back over.
  id: totrans-1108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们翻转一张卡片后再次转身，浏览行和列，识别有奇数张黑卡的行和列。被翻转的卡片将位于该行和列的交叉点处。将该卡片翻回去。
- en: It would take some practice to be able to add the extra cards, and identify
    the flipped card without the observer noticing that you are thinking hard about
    it. With practice you should be able to do it while having a casual conversation.
    Once you master it, you’ve got a great trick for parties, or even for busking.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一些练习才能添加额外的卡片，并且在观察者没有注意到你在认真思考的情况下识别出被翻转的卡片。通过练习，你应该能够在进行随意对话的同时做到这一点。一旦掌握了这个技巧，你就有了一个很棒的派对把戏，甚至可以用来卖艺。
- en: To make it more showy, you can pretend that you are mind reading the person,
    waving your hands over the cards. A particular impressive variation is to have
    an assistant come in to the room after the card has been flipped; even though
    they haven’t seen any of the setup, they will still be able to detect the error.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更具吸引力，你可以假装自己能够读取他人的思维，在卡片上挥动手。一个特别令人印象深刻的变化是在卡片被翻转后让助手进入房间；即使他们没有看到任何设置，他们仍然能够检测到错误。
- en: 9.2.2\. INVESTIGATING THE PARITY TRICK A LITTLE FURTHER
  id: totrans-1111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2\. 进一步探讨奇偶校验技巧
- en: At this point, you should be able to carry out the parity trick well enough
    that you can demonstrate that you understand how to do it. The remainder of this
    section is focussed on exploring further ideas in error control coding related
    to the parity trick. You can either continue to read through the rest of this
    section and explore the interesting questions raised, or you can skip forward
    to one of the other sections.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你应该能够熟练地执行奇偶校验技巧，以证明你理解如何做到这一点。本节的其余部分侧重于探索与奇偶校验相关的错误控制编码的更多想法。你可以继续阅读本节的其余部分并探索引起兴趣的问题，或者跳转到其他部分。
- en: It would be ideal to have some physical parity cards at this point that you
    can layout in front of you and play around with to explore the questions raised.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 此时最理想的情况是你有一些物理奇偶校验卡，可以在你面前摆出来，玩弄一下，以探索所提出的问题。
- en: An error control coding algorithm can often detect errors more easily than it
    can correct them. Errors involving multiple bits can sometimes even go undetected.
    What if the computer (or your friend if you were being a magician with actual
    parity cards) had been sneaky and turned over two cards instead of one? You could
    start by getting a friend or classmate to actually do this. Repeat it a few times.
    Are you always able to correct the errors, or do you get it wrong?
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 错误控制编码算法通常更容易检测错误，而不是纠正错误。涉及多个位的错误有时甚至可能被忽略。如果计算机（或者如果你正在用实际的奇偶校验卡做魔术时，你的朋友）偷偷地翻转了两张卡片怎么办？你可以请一个朋友或同学来实际操作一下。重复几次。你总是能够纠正错误吗，还是会出错？
- en: Remember that to *detect* errors using this algorithm, you know that if one
    or more rows and/or columns has an odd number of blacks and whites in it, that
    there must be at least one error. In order to *correct* errors you have to be
    able to pinpoint the specific card(s) that were flipped.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用这种算法来*检测*错误，你知道如果一行或多行和/或一列或多列中有奇数个黑色和白色，那么必定至少有一个错误。为了*纠正*错误，你必须能够准确定位被翻转的具体卡片。
- en: Are you always able to detect when an error has occurred if 2 cards have been
    flipped? Why? Are you ever able to correct the error? What about with 3 cards?
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果翻转了2张卡片，你总是能够检测到错误吗？为什么？你能够纠正错误吗？那么3张卡片呢？
- en: There is actually a way to flip 4 cards where the error is then *undetected* meaning
    that the algorithm will be unable to detect the error. Can you find a way of doing
    this?
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有一种方法可以翻转4张卡片，使得错误*无法被检测*，这意味着算法将无法检测到错误。你能找到一种方法吗？
- en: With more parity cards, we can detect and possibly correct more errors. Lets
    explore a very simple system with minimal parity cards. We can have a 7x7 grid
    of data with just one parity card. That parity card makes it so that there is
    an even number of black cards in the entire layout (including the parity card).
    How can you use this to detect errors? Are you ever able to correct errors in
    this system? In what situations do errors go undetected (think when you have multiple
    errors, i.e. more than one card flipped).
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 有了更多的奇偶校验卡，我们可以检测并可能纠正更多的错误。让我们探索一个非常简单的系统，只有最少的奇偶校验卡。我们可以有一个7x7的数据网格，只有一张奇偶校验卡。那张奇偶校验卡使得整个布局中（包括奇偶校验卡在内）的黑卡数量是偶数。你如何利用这一点来检测错误？在这个系统中你能够纠正错误吗？在什么情况下错误会被忽略（考虑当有多个错误时，即多张卡片被翻转）？
- en: So going back to the actual parity trick that has the 7 by 7 grid, and 15 parity
    cards to make it 8 by 8, it is interesting to note that only 1 extra card was
    needed to detect that an error had occurred, but an extra 15 cards were needed
    to be able to correct the error. In terms of the cost of an algorithm, it costs
    a lot more space to be able to correct errors than it does to be able to simply
    detect them!
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 回到实际的偶校验技巧，即7x7网格和15个偶校验卡，令人感兴趣的是，只需要额外的1张卡片就能检测到发生了错误，但需要额外的15张卡片才能纠正错误。 就算法成本而言，纠正错误所需的空间成本远远高于仅仅检测错误所需的空间成本！
- en: What happens when you use grids of different sizes? The grid doesn’t have to
    have an even number of black cards *and* an even number of white cards, it just
    happens that whenever you have an even number sized grid with the parity bits
    added (e.g. the 8x8 we have mostly used in this section) and you have an even
    number of black cards, you will also have to have an even number of whites, which
    makes it a bit easier to keep track of.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用不同大小的网格时会发生什么？ 网格不必具有偶数张黑卡和偶数张白卡，只是每当你在带有偶校验位的偶数大小网格上增加奇校验位（例如，在本节中我们主要使用的8x8），并且你有偶数张黑卡时，你也必须有偶数张白卡，这样更容易跟踪。
- en: Try a 6x6 grid with parity cards to make it 7x7\. The parity cards simply need
    to make each row and column have an even number of black cards (in this case there
    will always be an odd number of white cards in each row and column). The error
    detection is then looking for rows and columns that have an odd number of black
    cards in them (but an even number of white cards). Interestingly, the grid doesn’t
    even have to be a square! You could use 4x7 and it would work!
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用带有偶校验卡的6x6网格使其变为7x7。 偶校验卡只需要使每行和每列都有偶数张黑卡（在这种情况下，每行和每列总会有奇数张白卡）。 然后，错误检测正在寻找具有奇数张黑卡（但偶数张白卡）的行和列。
    有趣的是，网格甚至不必是正方形！ 你可以使用4x7，它也会起作用！
- en: There’s also no limit on the size. You could create a 10x10 grid (100 cards),
    and still be able to detect which card has been flipped over. Larger grids make
    for an even more impressive magic trick.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 大小没有限制。 你可以创建一个10x10的网格（100张卡片），仍然能够检测到哪张卡片被翻转了。 更大的网格会使魔术效果更加令人印象深刻。
- en: 9.3\. CHECK DIGITS ON BARCODES AND OTHER NUMBERS
  id: totrans-1123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3\. 条形码和其他数字的校验位
- en: You probably wouldn’t be very happy if you bought a book online by entering
    the ISBN (International Standard Book Number), and the wrong book was sent to
    you, or if a few days after you ordered it, you got an email saying that the credit
    card number you entered was not yours, but was instead one that was one digit
    different and another credit card holder had complained about a false charge.
    Or if you went to the shop to buy a can of drink and the scanner read it as being
    a more expensive product. Sometimes, the scanner won’t even read the barcode at
    all, and the checkout operator has to manually enter the number into the computer
    — but if they don’t enter it exactly as it is on the barcode you could end up
    being charged for the wrong product. These are all examples of situations that
    error control coding can help prevent.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过输入国际标准书号（ISBN）在线购买一本书，但收到的却是错误的书，或者在你下单几天后，收到一封电子邮件说你输入的信用卡号不是你的，而是一个数字不同的卡号，另一个持卡人投诉了虚假费用。
    或者如果你去商店买一罐饮料，而扫描器将其读成更贵的产品。 有时，扫描器甚至根本无法读取条形码，收银员必须手动将编号输入计算机——但如果他们输入的编号与条形码上的完全不同，你可能会被收取错误的产品费用。
    这些都是错误控制编码可以帮助防止的情况的示例。
- en: Barcode numbers, credit card numbers, ISBNs, the NHI (National Health Index,
    the unique identifier given to all users of the NZ health system), IRD numbers
    (Inland Revenue Department number for all NZ taxpayers) all have error control
    coding in them to help reduce the chance of errors. The last digit in each of
    these numbers is a check digit, which is obtained doing a special calculation
    on all the other digits in the number. If for example you enter your credit card
    number into a web form to buy something, it will calculate what the 16th digit
    should be, using the first 15 digits and the special calculation (there are 16
    digits in a credit card number). If the 16th digit that it expected is not the
    one you entered, it can tell that there was an error made when the number was
    entered and will notify you that the credit card number is not valid.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 条形码号码、信用卡号码、ISBN 号码、NHI（国家卫生指标，分配给所有新西兰卫生系统用户的唯一标识符）、IRD 号码（新西兰所有纳税人的税务局号码）都有错误控制编码，以帮助减少错误的机会。这些数字中的最后一位是一个校验位，通过对号码中的所有其他数字进行特殊计算获得。例如，如果你在网页表单中输入你的信用卡号码来购买东西，它将使用前
    15 位数字和特殊计算来计算第 16 位应该是什么。如果它期望的第 16 位不是你输入的那个，它可以知道在输入号码时出现了错误，并会通知你该信用卡号码无效。
- en: In this section we will be initially looking at one of the most commonly used
    barcode number formats used on most products you buy from supermarkets and other
    shops. We will then be having a look at credit card numbers. You don’t have to
    understand *why* the calculations work so well (this is advanced math, and isn’t
    important for understanding the overall ideas), and while it is good for you to
    know what the calculation is, it is not essential. So if math is challenging and
    worrying for you, don’t panic too much because what we are looking at in this
    section isn’t near as difficult as it might initially appear!
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们首先将介绍你从超市和其他商店购买的大多数产品上使用的最常见的条形码编号格式之一。然后我们将看看信用卡号码。你不必理解*为什么*计算如此有效（这是高级数学，对于理解整体思想并不重要），虽然你知道计算是什么很好，但也不是必需的。所以如果数学对你来说很具挑战性和令人担忧，不要太担心，因为我们在这一部分看的东西并不像它一开始看起来的那么困难！
- en: 9.3.1\. CHECK DIGITS ON PRODUCT BARCODES
  id: totrans-1127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1\. 检查产品条形码的校验位
- en: Most products you can buy at the shop have a barcode on them with a 13 digit
    global trade item number (referred to as GTIN-13). The first 12 digits are the
    actual identification number for the product, the 13th is the check digit calculated
    from the other 12\. Not all barcodes are GTIN-13, there are several others around.
    If the barcode has 13 numbers in it, it is almost certainly GTIN-13.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 你在商店里买的大多数产品上都有一个带有 13 位全球贸易商品编号（称为 GTIN-13）的条形码。前 12 位是产品的实际识别号码，第 13 位是从其他
    12 位计算出来的校验位。并非所有的条形码都是 GTIN-13，周围还有几个其他的。如果条形码中有 13 个数字，它几乎肯定是 GTIN-13。
- en: The following spreadsheet checks GTIN-13 barcodes. Enter a barcode number into
    the interactive, and it will tell you whether or not you typed it correctly! Start
    by using the barcode number of a box of 30 cans of coke; “9 300675 036009”. What
    happens if you then change one digit to something else?
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的电子表格检查 GTIN-13 条形码。在交互式中输入一个条形码号码，它会告诉你你是否输入正确！首先使用一盒 30 罐可乐的条形码号码；“9 300675
    036009”。如果你把其中一个数字改成其他的会发生什么？
- en: '[Click here to download the spreadsheet.](http://csfieldguide.org.nz/_static/interactives/ec/isbncreditcardcheckerv2.xlsx)'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击这里下载电子表格。](http://csfieldguide.org.nz/_static/interactives/ec/isbncreditcardcheckerv2.xlsx)'
- en: Have a look for another product that has a barcode on it, such as a food item
    from your lunch, or a stationery item. Your teacher might also bring various packaging
    that has barcodes on it for you to try. Note that some barcodes are a little different.
    Make sure the barcodes that you are using have 13 digits (although you might like
    to go and find out how the check digit works on some of the other ones). Hopefully
    you will find that the interactive is always able to determine whether or not
    you typed the barcode correctly!
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 找一个另外有条形码的产品，比如你午餐的食物，或者一个文具项目。你的老师也可能会带来各种有条形码的包装让你试试。请注意，有些条形码可能略有不同。确保你使用的条形码有
    13 位数字（尽管你可能想去了解其他条形码上的校验位是如何工作的）。希望你会发现这个交互式工具总是能够确定你是否正确输入了条形码！
- en: One of the following product numbers has one incorrect digit. Can you tell which
    of the products is wrong?
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下产品编号中有一个数字错误。你能告诉哪个产品是错的吗？
- en: 9 400550 619775
  id: totrans-1133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 9 400550 619775
- en: 9 400559 001014
  id: totrans-1134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 9 400559 001014
- en: 9 300617 013199
  id: totrans-1135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 9 300617 013199
- en: If you were scanning the above barcodes in a supermarket, the incorrect one
    will need to be rescanned, and the system can tell that it’s a wrong number without
    even having to look it up.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在超市扫描上述条形码，错误的那个将需要重新扫描，系统可以在甚至不需要查找的情况下知道这是一个错误的数字。
- en: You could try swapping barcode numbers with a classmate, but before giving them
    the number toss a coin, and if it’s heads, change one digit of the barcode before
    you give it to them. Can they determine that they’ve been given an erroneous barcode?
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试和同学交换条形码编号，但在给他们编号之前，先抛一枚硬币，如果是正面，就在给他们编号之前改变一位条形码数字。他们能确定自己被给了一个错误的条形码吗？
- en: If one of the digits is incorrect, this calculation will produce a different
    value to the checksum, and signals an error. So single digit errors will always
    be detected, but what if two digits change — will that always detect the error?
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一个数字不正确，这个计算将产生与校验和不同的值，并且会发出错误信号。因此，单个数字错误总是会被检测到，但是如果两个数字发生变化会怎样——那总是会检测到错误吗？
- en: What if the error is in the checksum itself but not in the other digits - will
    that be detected?
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错误出现在校验和本身而不是其他数字上——那会被检测到吗？
- en: 9.3.2\. HOW DO CHECK DIGITS PROTECT AGAINST COMMON HUMAN ERRORS?
  id: totrans-1140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2\. 检验位如何防止常见的人为错误？
- en: People can make mistakes when they enter numbers into computers, and even barcode
    scanners can get a digit wrong. Check digits attempt to detect when an error has
    occurred and notify the computer and/or person of it. Suppose you give your cellphone
    number to a friend so that they can contact you later. To ensure that you told
    them the number correctly, you may get them to text you immediately to confirm
    (and so that you have their number too). If you don’t get the text you will probably
    double check the number and will find that your friend made an error, for example
    they got a digit wrong or they reversed 2 digits next to one another. Mistakes
    happen, and good systems prevent those mistakes from having annoying or even serious
    consequences. If a check digit is being used, there is a good chance that the
    error will be detected when the check digit is not what the computer expects it
    to be.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们将数字输入计算机时，可能会出错，甚至条形码扫描仪也可能出错。检查数字试图检测是否发生错误，并通知计算机和/或人员。假设你把你的手机号码给一个朋友，以便他们以后联系你。为了确保你把号码告诉他们正确，你可能让他们立即发短信给你确认一下（这样你也有了他们的号码）。如果你没有收到短信，你可能会再次检查号码，并发现你的朋友出错了，例如他们错误地输入了一个数字，或者他们颠倒了相邻的
    2 位数字。错误是常有的事，而良好的系统能够防止这些错误带来烦人甚至严重的后果。如果使用检验位，当检验位不符合计算机的期望值时，很可能会检测到错误。
- en: 'Some of the really common errors are:'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 一些真正常见的错误包括：
- en: Getting one digit wrong (substitution)
  id: totrans-1143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错一个数字（替换）
- en: Swapping two digits that are adjacent (transposition)
  id: totrans-1144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换相邻的两个数字（转位）
- en: Missing a digit
  id: totrans-1145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 漏掉一个数字
- en: Adding a digit
  id: totrans-1146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个数字
- en: The last two will be picked up from the expected length of the number; for example,a
    GTIN-13 has 13 numbers, so if 12 or 14 were entered, the computer immediately
    knows this is not right. The first two depend on the check digit in order to be
    detected. Interestingly, all one digit errors will be detected by common checksum
    systems, and *most* transpositions will be detected (can you find examples of
    transpositions that aren’t detected, using the interactive above?)
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个错误将从数字的期望长度中被捕获；例如，GTIN-13 有 13 个数字，因此如果输入了 12 或 14，计算机立即知道这不对。前两个依赖于检验位以便被检测到。有趣的是，所有的一位数错误都将被常见的校验和系统检测到，并且*大多数*转位都将被检测到（你能找到使用上面的交互式工具无法检测到的转位的例子吗？）
- en: There are also some less common errors that people make - Getting a digit wrong
    in two or more different places - Doubling the wrong digit, e.g. putting 3481120
    instead of 3481220 - Muddling 3 digits, e.g. 14829 instead of 12489 - Phonetic
    errors are possible when the number was read and typed by somebody listening (or
    reading the number to themselves as they type it). For example, “three-forty”
    (340) might be heard as “three-fourteen” (314), and numbers like 5 and 9 can sound
    similar on a bad phone line.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 人们还会犯一些较少见的错误——在两个或更多不同的地方把一个数字弄错——加倍错误的数字，例如，输入 3481120 而不是 3481220——混淆 3 个数字，例如，输入
    14829 而不是 12489——当数字是通过听或者自己在打字时阅读时，可能会出现听觉错误。例如，“三百四十”（340）可能被听成“三十四”（314），而在信号不好的电话线上，数字
    5 和 9 可能听起来相似。
- en: Experiment further with the interactives for the product barcodes and/or credit
    card numbers. What errors are picked up? What errors can you find that are not?
    Are the really common errors nearly always picked up? Can you find any situations
    that they are not? Try to find examples of errors that are detected and errors
    that are not for as many of the different types of errors as you can.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步尝试与产品条形码和/或信用卡号交互。哪些错误被检测到？你能找到哪些没有被检测到的错误？真的常见错误几乎总是被检测到吗？你能找到任何情况下它们没有被检测到的例子吗？尽量找到尽可能多种不同类型的错误的检测和未检测的示例。
- en: Writing a program to calculate checksums is a good programming exercise. It
    can be made simple by having each digit entered separately, or part of the exercise
    could be to separate the digits. It’s also not hard to create a spreadsheet to
    do these calculations.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个计算校验和的程序是一个很好的编程练习。可以通过单独输入每个数字或将其分开来使其变得简单。也不难创建一个电子表格来进行这些计算。
- en: 9.3.3\. HOW IS THE CHECK DIGIT ON PRODUCT BARCODES CALCULATED?
  id: totrans-1151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.3\. 产品条形码的检验位是如何计算的？
- en: The first 12 numbers of the barcode represent information such as the country
    origin, manufacturer, and an identifier for the product. The 13th digit is a check
    digit, it is calculated from the first 12 digits.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 条形码的前12个数字表示信息，例如国家/地区来源，制造商和产品标识符。第13位数字是检验位，它是从前12位数字计算得出的。
- en: So, given the first 12 digits of a barcode number, how is the 13th digit calculated?
    The following algorithm is used (also, see the example below).
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 给定条形码号码的前12位数字，第13位数字是如何计算的呢？使用以下算法（也请参见下面的示例）。
- en: Multiply every second digit (starting with the second digit) by 3, and every
    other digit by 1 (so they stay the same).
  id: totrans-1154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个第二个数字（从第二个数字开始）乘以3，将其他每个数字乘以1（保持不变）。
- en: Add up all the multiplied numbers to obtain the *sum*.
  id: totrans-1155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有乘以的数字相加以得到*总和*。
- en: The check digit is whatever number would have to be added to the sum in order
    to bring it up to a multiple of 10 (i.e. the last digit of the sum should be 0).
    Or more formally, take the last digit of the sum and if it is 0, the check digit
    is 0\. Otherwise, subtract the last digit from 10 to obtain the check digit.
  id: totrans-1156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检验位是必须添加到总和中以使其成为10的倍数的数字（即总和的最后一位应为0）。或者更正式地说，取总和的最后一位数字，如果它为0，则检验位为0。否则，从10中减去最后一位数字以获得检验位。
- en: Lets look at an example to illustrate this algorithm. We want to confirm that
    the check digit that was put on the barcode of a bottle of coke was the correct
    one. Its barcode number is 9300675032247\. The last digit, 7, is the check digit.
    So we take the first 12 digits and multiply them by 1 or 3, depending on their
    positions (9x1+3x3+0x1+0x3+6x1+7x3+5x1+0x3+3x1+2x3+2x1+4x3). We then add up all
    the multiplied numbers, obtaining a sum of 73\. We want to add the check digit
    that will bring the sum up to the nearest multiple of 10, which is 80\. This number
    is 7, which is indeed the check digit on the coke bottle’s barcode.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子来说明这个算法。我们想要确认一瓶可乐的条形码上放置的检验位是否正确。它的条形码号码是9300675032247。最后一位数字7是检验位。所以我们取前12位数字，分别乘以1或3，取决于它们的位置（9x1+3x3+0x1+0x3+6x1+7x3+5x1+0x3+3x1+2x3+2x1+4x3）。然后我们将所有乘以的数字相加，得到总和为73。我们想要添加检验位，使总和接近10的倍数，即80。这个数字是7，它确实是可乐瓶条形码上的检验位。
- en: The algorithm to check whether or not a barcode number was correctly entered
    is very similar. This time, we are using all 13 digits.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检查条形码号码是否输入正确的算法非常相似。这次，我们使用了所有13位数字。
- en: Multiply every second digit (starting with the second digit) by 3, and every
    other digit by 1\. This includes the 13th digit.
  id: totrans-1159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个第二个数字（从第二个数字开始）乘以3，将其他每个数字乘以1。这包括第13位数字。
- en: Add up all the multiplied numbers to obtain the *sum*
  id: totrans-1160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有乘以的数字相加以得到*总和*。
- en: If the last digit of the sum is a 0, the number was entered correctly.
  id: totrans-1161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果总和的最后一位是0，则输入的数字是正确的。
- en: '**Hint**'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**'
- en: A quick way to add up a checksum that can be done in your head with some practice
    is to separate the numbers to be multiplied by 3, add them up, and then multiply
    by 3\. For the example above (9300675032247) the two groups are 9+0+6+5+3+2+7
    = 32 and 3+0+7+0+2+4= 16\. So we add 32 + 16x3, which gives the total of 80 including
    the check digit.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以通过一些实践在头脑中完成的快速添加校验和的方法是将要乘以3的数字分开，将它们相加，然后乘以3。对于上面的例子（9300675032247），两组数字分别是9+0+6+5+3+2+7
    = 32 和 3+0+7+0+2+4= 16。因此我们将32 + 16x3相加，得到总和为80，包括检验位。
- en: '**For Experts: Why does this algorithm work so well?**'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于专家：为什么这个算法如此有效？**'
- en: In order to be effective, the algorithm needs to ensure the multiplied digits
    will not add up to a multiple of 10 any more if the digits are changed slightly.
    The choice of multipliers affects how likely it is to detect small changes in
    the input. It’s possible to analyse these mathematically to work out what sorts
    of errors can be detected.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效，算法需要确保如果稍微改变数字，则乘以数字的乘积将不再总和为 10 的倍数。乘数的选择影响了检测输入中小改变的可能性。可以对这些进行数学分析，以确定可以检测到什么样的错误。
- en: The check digit on barcodes is described in the >. Basically every second digit
    is multiplied by 3, and the sum of these multiples are added to the remaining
    digits.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 条形码上的校验位在 > 中描述。基本上，每隔一个数字乘以 3，这些倍数的总和添加到剩余的数字中。
- en: Lets look at some smaller examples with 5 digits (4 normal digits and a check
    digit), as the same ideas will apply to the 13 digit numbers.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些带有 5 位数字（4 个常规数字和一个校验位）的较小示例，因为相同的思想将适用于 13 位数字。
- en: If we need a check digit for 8954, we would calculate (8x1)+(9x3)+(5x1)+(4x3)=52,
    and in order to bring this up to 60, we need to add 8\. This makes the full number
    89548.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要 8954 的校验位，我们将计算 (8x1)+(9x3)+(5x1)+(4x3)=52，并且为了将其增加到 60，我们需要添加 8。这使得完整数字为
    89548。
- en: The first thing we should observe is that only the ones column (last digit)
    of each number added have any impact on the check digit. 8+27+5+12=52, and 8+7+5+2=22
    (only looking at the last digit of each number we are adding). Both these end
    in a 2, and therefore need 8 to bring them up to the nearest multiple of 10\.
    You might be able to see why this is if you consider that the “2” and “1” were
    cut from the tens column, they are equal to 10+20=30, a multiple of 10\. Subtracting
    them only affects the tens column and beyond. This is always the case, and therefore
    we can simplify the problem by only adding the ones column of each number to the
    sum. (This can also be used as a shortcut to calculate the checksum in your head).
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该观察到的第一件事是，每个添加的数字的个位数（最后一位）对校验位都有影响。8+27+5+12=52，而 8+7+5+2=22（只关注我们要添加的每个数字的个位数）。这两个都以
    2 结尾，因此需要 8 将它们增加到最接近的 10 的倍数。如果您考虑从十位数中删除的“2”和“1”，您可能能够看出为什么。它们等于 10+20=30，是
    10 的倍数。减去它们只会影响十位数及其之后的部分。这总是如此，因此我们可以通过只将每个数字的个位数添加到总和中来简化问题。（这也可以用作在头脑中计算校验和的快捷方式）。
- en: '*Protection against single digit errors*'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: '*对单个数字错误的保护*'
- en: Next, lets look at why changing *one* digit in the number to another digit will *always* be
    detected with this algorithm. Each digit will contribute a number between 0 and
    9 to the sum (remember we only care about the ones column now). As long as changing
    the digit will result in it contributing a different amount to the sum, it becomes
    impossible for it to still sum to a multiple of 10\. Remember that each digit
    is either multiplied by 1 or 3 before its ones column is added to the sum.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看为什么改变数字中的 *一个* 数字为另一个数字将始终被此算法检测到。每个数字将为总和贡献一个介于 0 到 9 之间的数字（现在只关心个位数）。只要改变数字导致其对总和贡献的金额不同，它就不可能仍然总和为
    10 的倍数。记住，每个数字在其个位数被加到总和之前都会被乘以 1 或 3。
- en: A number being multiplied by 1 will always contribute itself to the sum. If
    for example the digit was supposed to be 9, no other single digit can contribute
    9 to the sum. So those multiplied by 1 are fine.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 被乘以 1 的数字将始终将其自身贡献给总和。例如，如果数字应该是 9，那么没有其他单个数字可以为总和贡献 9。因此，那些乘以 1 的数字是可以的。
- en: But what about those multiplied by 3? To answer that, we need to look at what
    each different digit contributes to the sum when multiplied by 3.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 但是那些乘以 3 的数字呢？为了回答这个问题，我们需要看一下每个不同数字在被乘以 3 时对总和贡献了什么。
- en: 1 -> 3
  id: totrans-1174
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 -> 3
- en: 2 -> 6
  id: totrans-1175
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 -> 6
- en: 3 -> 9
  id: totrans-1176
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 -> 9
- en: 4 -> 2 (from 1*2*)
  id: totrans-1177
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 -> 2 (从 1*2*)
- en: 5 -> 5 (from 1*5*)
  id: totrans-1178
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 -> 5 (从 1*5*)
- en: 6 -> 8 (from 1*8*)
  id: totrans-1179
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6 -> 8 (从 1*8*)
- en: 7 -> 1 (from 2*1*)
  id: totrans-1180
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7 -> 1 (从 2*1*)
- en: 8 -> 4 (from 2*4*)
  id: totrans-1181
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8 -> 4 (从 2*4*)
- en: 9 -> 7 (from 2*7*)
  id: totrans-1182
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 9 -> 7 (从 2*7*)
- en: 0 -> 0
  id: totrans-1183
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 -> 0
- en: If you look at the right hand column, you should see that no number is repeated
    twice. This means that no digit contributes the same amount to the sum when it
    is multiplied by 3!
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看右边的列，你会发现没有数字重复两次。这意味着当乘以 3 时，没有数字对总和贡献相同的金额！
- en: Therefore, we know that all single digit errors will be detected.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道所有单个数字错误都将被检测到。
- en: '*Protection against swapping adjacent digit errors*'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '*对换相邻数字错误的保护*'
- en: Seeing why the algorithm is able to protect against most swap errors is much
    more challenging.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 看出为什么算法能够防止大多数换位错误是非常具有挑战性的。
- en: If two digits are next to one another, one of them must be multiplied by 1,
    and the other by 3\. If they are swapped, then this is reversed. For example,
    if the number 89548 from earlier is changed to 8*59*48, then (5x3)+(9x1)=24 is
    being added to the total instead of (9x3)+(5x1)=32\. Because 24 and 32 have different
    values in their ones columns, the amount contributed to the total is different,
    and therefore the error will be detected.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个数字相邻，其中一个必须乘以1，另一个必须乘以3。如果它们被交换，那么这个过程将被颠倒。例如，如果之前的数字89548改为8*59*48，那么（5x3）+（9x1）=24将被加到总和中，而不是（9x3）+（5x1）=32。因为24和32在个位数上有不同的值，对总和的贡献是不同的，因此将检测到错误。
- en: 'But are there any cases where the totals will have the same values in their
    ones columns? Another way of looking at the problem is to take a pair of rows
    from the table above, for example:'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 但是是否存在任何情况，其中总和将在它们的个位数上具有相同的值？另一种看待这个问题的方法是从上面的表中取一对行，例如：
- en: 8 -> 4
  id: totrans-1190
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8 -> 4
- en: 2 -> 6
  id: totrans-1191
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 -> 6
- en: Remember that the first column is how much will be contributed to the total
    for digits being multiplied by 1, and the second column is for those being multiplied
    by 3\. Because adjacent digits are each multiplied by a different amount (one
    by 3 and the other by 1), the numbers diagonal to each other in the chosen pair
    will be added.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，第一列是由数字乘以1贡献给总和的量，而第二列是由数字乘以3的量。因为相邻的数字分别被乘以不同的量（一个乘以3，另一个乘以1），所以在所选对角线上对角线上的数字将被加起来。
- en: If for example the first 2 digits in a number are “28”, then we will add 2+4=6
    to the sum. If they are then reversed, we will add 8+6=14, which is equivalent
    to 4 as again, the “10” part does not affect the sum. 8+6 and 2+4 are the diagonals
    of the pair!
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果数字中的前两个数字是“28”，那么我们将把2+4=6加到总和中。如果它们被颠倒，我们将加上8+6=14，这等价于4，因为“10”部分再次不影响总和。8+6和2+4是这对的对角线！
- en: '*8* -> **4**'
  id: totrans-1194
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*8* -> **4**'
- en: '**2** -> *6*'
  id: totrans-1195
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** -> *6*'
- en: So the question now is, can you see any pairs where the diagonals would add
    up to the same value? There is one!
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在的问题是，你能看到任何对角线的数字和是相同的吗？有一个！
- en: '*Protection against twin errors*'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: '*对双重错误的保护*'
- en: A twin error is where a digit that is repeated twice in a number is changed
    to a different digit that is repeated twice. For example, if we have “22” in the
    number, somebody might somehow change it to “88”.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 双重错误是指一个数字中重复出现两次的数字被改成另一个重复出现两次的数字。例如，如果数字中有“22”，某人可能会将其某种方式改成“88”。
- en: When two numbers are side by side, one is multiplied by 3 and the other by 1\.
    So the amount contributed to the total is the sum of the number’s row in the above
    table. For example, 2 has the row “2->6”. This means that 2+6=8 will be contributed
    to the sum as a result of these two digits.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个数字并排时，一个被乘以3，另一个被乘以1。所以对总和的贡献量是上表中数字的总和。例如，2的行是“2->6”。这意味着2+6=8将作为这两个数字的结果贡献给总和。
- en: If any rows add up to the same number, this could be a problem. Where the sum
    was over 10, the tens column has been removed.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何行的总和相同，这可能是一个问题。当和超过10时，十位已被去除。
- en: 1 -> 3 adds to “4”
  id: totrans-1201
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 -> 3 加起来是“4”
- en: 2 -> 6 adds to “8”
  id: totrans-1202
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 -> 6 加起来是“8”
- en: 3 -> 9 adds to “2”
  id: totrans-1203
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 -> 9 加起来是“2”
- en: 4 -> 2 adds to “6”
  id: totrans-1204
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 -> 2 加起来是“6”
- en: 5 -> 5 adds to “0”
  id: totrans-1205
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 -> 5 加起来是“0”
- en: 6 -> 8 adds to “4”
  id: totrans-1206
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6 -> 8 加起来是“4”
- en: 7 -> 1 adds to “8”
  id: totrans-1207
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7 -> 1 加起来是“8”
- en: 8 -> 4 adds to “2”
  id: totrans-1208
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8 -> 4 加起来是“2”
- en: 9 -> 7 adds to “6”
  id: totrans-1209
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 9 -> 7 加起来是“6”
- en: 0 -> 0 adds to “0”
  id: totrans-1210
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 -> 0 加起来是“0”
- en: Some of the rows add up to the same number! Because both 4 and 9 add up to 6,
    the error will not be detected if “44” changes to “99” in a number!
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 一些行的总和相同！因为4和9都加起来是6，如果数字中的“44”改成“99”，那么错误将不会被检测到！
- en: Rows that do not add will be detected. From the example above, if 22 changes
    to 88, this will be detected because 22’s total is 8, and 88’s total is 2.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 不加的行将被检测到。从上面的例子来看，如果22变成88，这将被检测到，因为22的总和是8，88的总和是2。
- en: '*An error which is never detected*'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: '*永远不会被检测到的错误*'
- en: Another error that people sometimes make is the jump transposition error. This
    is where two digits that have one digit in between them are swapped, for example,
    812 to 218.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 有时人们会犯的另一个错误是跳跃换位错误。这是指两个数字中间有一个数字的数字被交换，例如，812变成218。
- en: A pair of numbers that are two apart like this will always be multiplied by
    the same amount as each other, either 1 or 3\. This means that the change in position
    of the numbers does not affect what they are multiplied by, and therefore what
    they contribute to the sum. So this kind of error will never be detected.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 两个数字之间相差两个像这样的一对数字将始终以相同的倍数相乘，要么是1，要么是3。这意味着数字的位置变化不会影响它们相乘的数量，因此也不会影响它们对总和的贡献。因此，这种错误永远不会被检测到。
- en: 9.3.4\. CHECK DIGITS ON CREDIT CARD NUMBERS
  id: totrans-1216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.4\. 信用卡号的校验位
- en: 'Credit card numbers also have check digits. These can be used by online purchasing
    systems to ensure that the credit card number entered was entered correctly way
    before having to check with the bank to see if the number is legitimate. This
    isn’t a good protection against fraud, but it does check that a legitimate user
    hasn’t made a simple mistake that makes it look like they are trying to commit
    a fraud, or that a completely random number has been typed in. A credit card number
    has 16 digits in it: 15 digits that make up the number, and then the last digit
    is a check digit.'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 信用卡号也有校验位。在线购买系统可以使用这些校验位来确保输入的信用卡号在与银行核对之前是正确的。这不是对抗欺诈的良好保护措施，但它确实检查了一个合法用户是否犯了一个简单的错误，使其看起来像是在试图实施欺诈，或者输入了一个完全随机的号码。信用卡号有16位数字：前15位组成数字，然后最后一位是校验位。
- en: Before we go any further investigating credit card numbers, there are a few
    ethical and privacy issues we must consider. While credit card numbers are not
    secret, just like your home address you would not give your credit card number
    to just anybody. There are fraudsters around who collect credit card numbers and
    attempt to use other peoples credit cards. (One of the main reasons Paypal exists
    is that it hides the credit card number from the seller, and only Paypal needs
    to be trusted with this sensitive information, rather than every person you make
    a payment to on the internet.)
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步调查信用卡号之前，我们必须考虑一些伦理和隐私问题。虽然信用卡号不是秘密的，就像你的家庭地址一样，你不会把你的信用卡号随便给别人。有些欺诈者会收集信用卡号，并试图使用他人的信用卡。（Paypal存在的主要原因之一是它将信用卡号隐藏在卖方处，只有Paypal需要信任这些敏感信息，而不是你在互联网上向每个收款人付款时都需要信任。）
- en: It is not really a good idea to include experiments in an assessed report that
    contain your credit card number or your parents’ credit card number. You also
    need to be careful about making credit card numbers up, as the number you make
    up could potentially be somebody’s valid credit card number. There is a range
    of credit card numbers that are only used as test numbers, which start with 5413
    30\. If you are giving examples using credit cards, we recommend that you use
    numbers in this range in your report. You can use the following generator to generate
    test credit card numbers in this range.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 在一份评估报告中包含你的信用卡号或父母的信用卡号的实验并不是一个好主意。你还需要注意编造信用卡号，因为你编造的号码有可能是别人的有效信用卡号。有一系列仅用作测试号码的信用卡号，以`5413
    30`开头。如果你在报告中使用信用卡作为示例，我们建议你使用这个范围内的号码。你可以使用以下生成器生成该范围内的测试信用卡号。
- en: JACK PUT THE CREDIT CARD NUMBER GENERATOR HERE
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 杰克在这里放置了信用卡号生成器
- en: The interactive below allows you to experiment with numbers from the above generator,
    and see what kinds of errors are detected and which are not (use the information
    from the previous sections to guide your experimentation). Note that it only accepts
    numbers from the above generator, as we don’t want you checking real credit card
    numbers with this interactive!
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的交互式界面允许你使用上面的生成器中的数字进行实验，并查看检测到的错误和未检测到的错误的种类（使用前面章节的信息来指导你的实验）。请注意，它仅接受来自上面生成器的数字，因为我们不希望你使用这个交互式界面检查真实的信用卡号！
- en: 9.3.5\. THE ALGORITHM FOR CALCULATING CREDIT CARD NUMBER CHECK DIGITS
  id: totrans-1222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.5\. 计算信用卡号校验位的算法
- en: 9.4\. THE WHOLE STORY!
  id: totrans-1223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4\. 故事的全貌！
- en: The codes discussed in this chapter are all widely used, but the most widely
    used codes for data storage are more sophisticated because they need to deal with
    more complex errors than a single bit changing. For example, if a CD is scratched
    of a hard disk has a small fault, it’s likely to affect many adjacent bits. These
    systems use codes based on more advanced mathematical concepts. The most widely
    used codes for storage and data transfer are [the Reed-Solomon codes](http://en.wikipedia.org/wiki/Reed_Solomon) and [Cyclic
    Redundancy Check (CRC)](http://en.wikipedia.org/wiki/CRC32). For human readable
    numbers such as bar codes, bank numbers, tax numbers, social security numbers
    and so on, [checksums](http://en.wikipedia.org/wiki/Checksum) are very common,
    and the [Luhn algorithm](http://en.wikipedia.org/wiki/Luhn_algorithm) is one of
    the more widely used. Larger checksums are also used to check that downloaded
    files are correct. The parity method is a form of [Hamming code](http://en.wikipedia.org/wiki/Hamming_code).
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的代码都是广泛使用的，但用于数据存储的最广泛使用的代码更为复杂，因为它们需要处理比单个位更复杂的错误。例如，如果光盘划伤或硬盘有小故障，很可能会影响许多相邻的位。这些系统使用基于更高级数学概念的代码。用于存储和数据传输的最广泛使用的代码是
    [Reed-Solomon codes](http://en.wikipedia.org/wiki/Reed_Solomon) 和 [Cyclic Redundancy
    Check (CRC)](http://en.wikipedia.org/wiki/CRC32)。对于像条形码、银行账号、税号、社会保障号等人类可读的数字，
    [校验和](http://en.wikipedia.org/wiki/Checksum) 非常常见，其中 [Luhn algorithm](http://en.wikipedia.org/wiki/Luhn_algorithm)
    是其中较广泛使用的。更大的校验和也用于检查下载的文件是否正确。奇偶校验方法是 [Hamming code](http://en.wikipedia.org/wiki/Hamming_code)
    的一种形式。
- en: 9.5\. FURTHER READING
  id: totrans-1225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5\. 进一步阅读
- en: 9.5.1\. USEFUL LINKS
  id: totrans-1226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.1\. 有用链接
- en: '[CS Unplugged Parity Trick](http://csunplugged.org/error-detection)'
  id: totrans-1227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CS Unplugged 奇偶校验技巧](http://csunplugged.org/error-detection)'
- en: '[CS4FN](http://csfieldguide.org.nz/cs4fn.org) has a [free book](http://www.cs4fn.org/magic/) that
    contains the Parity Trick and a number of other tricks related to computer science.'
  id: totrans-1228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CS4FN](http://csfieldguide.org.nz/cs4fn.org) 提供了一本 [免费书](http://www.cs4fn.org/magic/)，其中包含奇偶校验技巧和许多与计算机科学相关的其他技巧。'
- en: Techradar has more [information about error detection and correction](http://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736)
  id: totrans-1229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Techradar 提供了更多关于 [错误检测和纠正的信息](http://www.techradar.com/news/computing/how-error-detection-and-correction-works-1080736)。
- en: '[An explanation of error correcting codes](http://www.multiwingspan.co.uk/as1.php?page=error)'
  id: totrans-1230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[纠错码的解释](http://www.multiwingspan.co.uk/as1.php?page=error)'
- en: '[A check digit calculator for common bar codes](http://www.gs1.org/barcodes/support/check_digit_calculator)'
  id: totrans-1231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[常见条形码的校验位计算器](http://www.gs1.org/barcodes/support/check_digit_calculator)'
- en: 10\. ARTIFICIAL INTELLIGENCE
  id: totrans-1232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10\. 人工智能
- en: 10.1\. WHAT’S THE BIG PICTURE?
  id: totrans-1233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1\. 大局观
- en: Artificial Intelligence conjures up all sorts of images — perhaps you think
    of friendly systems that can talk to you and solve tough problems; or maniac robots
    that are bent on world domination? There’s the promise of driverless cars that
    are safer than human drivers, and the worry of medical advice systems that hold
    peoples lives in their virtual hands. The field of Artificial Intelligence is
    a part of computer science that has a lot of promise and also raises a lot of
    concerns. It can be used to make decisions in systems as large as an aeroplane
    or an [autonomous dump truck](http://www.komatsu.com/ce/currenttopics/v09212/index.html) ,
    or as small as a mobile phone that accurately predicts text being typed into it.
    What they have in common is that they try to mimic aspects of human intelligence.
    And importantly, such systems can be of significant help in people’s everyday
    lives.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能引发了各种各样的想象 —— 或许你会想到可以与你交谈并解决棘手问题的友好系统；或者狂热的机器人试图统治世界？有无人驾驶汽车的承诺，比人类驾驶员更安全；还有担心的医疗建议系统，掌握着人们生命的虚拟掌控权。人工智能领域是计算机科学的一部分，具有很多承诺，同时也引发了很多关注。它可以用于在像飞机或
    [自动卡车](http://www.komatsu.com/ce/currenttopics/v09212/index.html) 这样的大型系统中做出决策，也可以用于在手机这样的小型系统中准确预测输入的文本。它们的共同点是试图模仿人类智能的某些方面。而且，这样的系统在人们的日常生活中可以提供重要帮助。
- en: AI (also known as intelligent systems) is primarily a branch of computer science
    but it has borrowed a lot of concepts and ideas from other fields, especially[mathematics](http://en.wikipedia.org/wiki/Mathematics) (particularly
    logic, combinatorics, statistics, probability and optimisation theory), [biology](http://en.wikipedia.org/wiki/Biology) , [psychology](http://en.wikipedia.org/wiki/Psychology) , [linguistics](http://en.wikipedia.org/wiki/Linguistics) , [neuroscience](http://en.wikipedia.org/wiki/Neuroscience) and [philosophy](http://en.wikipedia.org/wiki/Philosophy).
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 人工智能（也称为智能系统）主要是计算机科学的一个分支，但它从其他领域，特别是[数学](http://zh.wikipedia.org/wiki/数学)（特别是逻辑、组合学、统计学、概率论和优化理论）、[生物学](http://zh.wikipedia.org/wiki/生物学)、[心理学](http://zh.wikipedia.org/wiki/心理学)、[语言学](http://zh.wikipedia.org/wiki/语言学)、[神经科学](http://zh.wikipedia.org/wiki/神经科学)和[哲学](http://zh.wikipedia.org/wiki/哲学)中借鉴了许多概念和思想。
- en: In this chapter we’ll explore a range of these intelligent systems. Inevitably
    this will mean dealing with ethical and philosophical issues too — do we really
    want machines to take over some of our jobs? Can we trust them? Might it all go
    too far one day? What do we really mean by a computer being intelligent? While
    we won’t address these questions directly in this chapter, gaining some technical
    knowledge about AI will enable you to make more informed decisions about the deeper
    issues.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一系列这样的智能系统。这必然意味着也要涉及道德和哲学问题 — 我们真的想让机器接管我们的一些工作吗？我们能相信它们吗？有一天会不会走得太远？我们所说的计算机智能到底是什么意思？虽然我们不会在本章直接回答这些问题，但是了解一些人工智能的技术知识将使你能够更加明智地对待更深层次的问题。
- en: 10.2\. CHATTERBOTS AND THE TURING TEST
  id: totrans-1237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2\. 聊天机器人和图灵测试
- en: '![](563ad8f58e4e0.jpg)'
  id: totrans-1238
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad8f58e4e0.jpg)'
- en: Many humans take for granted the fact that they can easily have a conversation
    with another person, and choose appropriate things to say based on the conversation.
    The ability to do this is a form of intelligence, and for computers it isn’t so
    easy! Many attempts have been made to design computer programs that can have a
    conversation with a human and sound intelligent. These computer programs are called *chatterbots*,
    or just *chatbots*. This book uses the former term, although you may see both
    being used in other books or websites.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人都认为他们可以轻松与其他人进行对话，并根据对话选择适当的话语，这一点理所当然。能够做到这一点是一种智能的表现，对于计算机来说并不容易！已经有许多尝试设计可以与人类对话并听起来智能的计算机程序。这些计算机程序被称为*聊天机器人*，或者只是*聊天机器人*。本书使用前一种术语，尽管你可能会在其他书籍或网站中看到两者都在使用。
- en: 10.2.1\. A THERAPY SESSION WITH ELIZA THE CHATTERBOT
  id: totrans-1240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1\. 与聊天机器人艾丽莎的治疗会话
- en: One such chatterbot is **Eliza**. Eliza attempts to sound like a Rogerian Psychotherapist,
    and sounds most intelligent in the kind of conversation that would be had in such
    a therapy session. ([Rogerian Psychotherapy](http://en.wikipedia.org/w/index.php?title=Rogerian_psychotherapy) is
    a technique that revolves around trying to understand the client by asking questions
    and reflecting their statements back to clarify that they’ve been understood).
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个这样的聊天机器人是**艾丽莎**。艾丽莎试图模仿罗杰斯心理治疗师的风格，在这种治疗会话中最显得智能。（[罗杰斯心理治疗](http://zh.wikipedia.org/w/index.php?title=罗杰斯心理治疗)是一种围绕着试图通过提问和反映他们的陈述来理解客户的技术）。
- en: Warning
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Eliza is a system that was intended to get people thinking about AI, and you
    should *not* use it for your own therapeutic usage. You should never enter personal
    information into a computer that you wouldn’t want anybody else reading, as you
    can never be certain that the web site isn’t going to store the information or
    pass it on to someone. So you don’t want to be telling Eliza the kinds of things
    a person would say in a therapy session — just make stuff up when talking to Eliza!
    For the same reason, do *not* tell any chatterbot other personal information such
    as your full name, date of birth, or address.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 艾丽莎是一个旨在让人们思考人工智能的系统，你不应该将其用于你自己的治疗用途。你永远不应该在计算机中输入你不希望任何其他人阅读的个人信息，因为你无法确定网站是否会存储信息或将其传递给其他人。所以你不应该告诉艾丽莎人们在治疗会话中会说的那种事情
    — 只需在与艾丽莎交谈时编造东西！出于同样的原因，不要告诉任何其他聊天机器人你的其他个人信息，如你的全名、出生日期或地址。
- en: Go to the link just below and have a conversation with Eliza (keeping in mind
    that she is supposed to be a Rogerian Psychotherapist, so will respond like one).
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下面的链接，与艾丽莎进行一次对话（请记住她被认为是一位罗杰斯心理治疗师，所以会像一个人一样回应）。
- en: '[Click here for the Eliza chatterbot at nlp-addiction](http://nlp-addiction.com/eliza/)'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击此处查看nlp-addiction上的Eliza聊天机器人](http://nlp-addiction.com/eliza/)'
- en: '![](563ad8f4d5b30.png)'
  id: totrans-1246
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad8f4d5b30.png)'
- en: Do you think Eliza is as smart as a human? Would you believe she was a human
    if somebody told you she was?
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为Eliza和人一样聪明吗？如果有人告诉你她是一个人，你会相信吗？
- en: 'You will probably agree that while Eliza sounds somewhat intelligent at times,
    she gives very vague and general replies, forgets earlier parts of the conversation,
    and says some things that sound very strange! As an example, here is a conversation
    with Eliza:'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会同意，虽然Eliza有时听起来有些聪明，但她的回复非常模糊和笼统，忘记了对话的早期部分，并且说一些听起来非常奇怪的事情！例如，这是一个与Eliza的对话：
- en: '**Eliza**: Hello, I am Eliza. **Human**: Hello I am a human **Eliza**: Do you
    believe it is normal to be a human? **Human**: Yes **Eliza**: Are you Sure? **Human**:
    Yes **Eliza**: Why did you repeat yourself?'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '**Eliza**：你好，我是Eliza。 **Human**：你好，我是一个人 **Eliza**：你认为做一个人是正常的吗？ **Human**：是的
    **Eliza**：你确定吗？ **Human**：是的 **Eliza**：你为什么重复你自己？'
- en: Eliza often gives very general replies by looking for suitable rules based only
    on the line you’ve just typed, and that often leads to some very weird conversations,
    such as the one above! In this case Eliza used pattern matching to determine that
    it might be appropriate to ask me “Do you believe it is normal to be a human?”,
    as I had said I was a human; if I had said “I am a banana” then the same rule
    would have responded with “Do you believe it is normal to be a banana?”. When
    I answered “Yes”, Eliza didn’t actually understand the *meaning* of me saying
    “Yes”, so simply asked me if I was sure, as it has a general response that says
    a good way of responding to somebody saying “Yes” is to ask them if they were
    sure. Eliza also has rules that are triggered if somebody repeats themselves that
    say she should ask them why. Because Eliza doesn’t actually understand meanings
    but instead just follows rules that say what might be appropriate responses, she
    had no way of knowing that it actually *was* meaningful for me to respond with
    “Yes” twice! This is a big giveaway that Eliza really isn’t that intelligent,
    and doesn’t actually understand meanings in conversation, or even whether or not
    a response to her own question is actually reasonable.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: Eliza经常根据你刚刚输入的内容寻找合适的规则来给出非常笼统的回复，这经常会导致一些非常奇怪的对话，就像上面的那个！在这种情况下，Eliza使用模式匹配来确定可能适合问我“你认为做一个人是正常的吗？”，因为我说我是一个人；如果我说“我是一个香蕉”，那么相同的规则就会回答“你认为做一个香蕉是正常的吗？”。当我回答“是的”时，Eliza实际上并不理解我说“是”的*含义*，所以只是简单地问我是否确定，因为它有一个通用的回复，说对于某人说“是”的一个好的回应方式是问他们是否确定。Eliza还有一些规则，如果有人重复自己，她应该问他们为什么。因为Eliza实际上并不理解含义，而只是遵循规则，说可能是适当的回应是什么，所以她无法知道我两次回答“是”实际上*是*有意义的！这是Eliza实际上并不那么聪明的一个很大的线索，她实际上并不理解对话中的含义，甚至不知道对她自己问题的回答是否真的合理。
- en: Now go back and have another conversation with Eliza. There are many other examples
    of Eliza saying stuff that makes no sense such as the above dialogue. How many
    can you find? In addition, how does Eliza respond when you do the following things?
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回去再与Eliza进行一次对话。还有许多其他Eliza说一些毫无意义的东西的例子，如上述对话。你能找到多少个？此外，当你做以下事情时，Eliza会如何回应？
- en: Try being a “parrot” that just copies everything Eliza says.
  id: totrans-1252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试成为一个“鹦鹉”，只是复制Eliza说的一切。
- en: What happens when you don’t give meaningful answers to her questions?
  id: totrans-1253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你对她的问题不给出有意义的回答时会发生什么？
- en: If you say the same thing you said earlier in the conversation, does Eliza always
    respond in the same way? (When you say it immediately after, she probably won’t,
    as she’ll comment on the fact that you repeated yourself the second time!)
  id: totrans-1254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在对话中重复你之前说过的话，Eliza是否总是以相同的方式回答？（当你第二次立即重复时，她可能不会，因为她会评论你第二次重复自己的事实！）
- en: What happens when you talk about things that are unrelated to what would be
    said in a therapy session, i.e. you try to have a general conversation with Eliza
    (remember that Eliza works in a restricted domain, i.e. she assumes she is a therapist).
  id: totrans-1255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你谈论与治疗会话中会说的内容无关的事情时，即你试图与Eliza进行一般性对话时会发生什么？（请记住，Eliza工作在一个受限的领域，即她假设自己是一名治疗师）。
- en: 10.2.2\. ALICE THE CHATTERBOT
  id: totrans-1256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2\. ALICE THE CHATTERBOT
- en: We saw above that Eliza is a chatterbot who works with a restricted domain (trying
    to take the role of a therapist), and tried to sound intelligent by giving very
    general responses. As you probably found out though, this quickly reveals that
    Eliza really isn’t intelligent at all, and will just repeat the same things over
    and over again. In addition, you probably also noticed that Eliza frequently doesn’t
    make a lot of sense, and comes up with sentences that make no sense to a human.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以上看到，Eliza 是一个 chatterbot，她的工作领域受限（试图扮演心理医生的角色），并试图通过给出非常笼统的回答来表现出智能。但正如你可能发现的那样，这很快就表明
    Eliza 其实并不聪明，只会一遍又一遍地重复同样的事情。此外，你可能还注意到 Eliza 经常讲不通，会说出对人类来说毫无意义的句子。
- en: Try having a conversation with another chatterbot — Alice. Note that she knows
    you as “judge”. You might work out why she calls you this once you have read the
    sections on the Turing Test below!
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试与另一个 chatterbot —— Alice 进行对话。请注意，她把你称为“评委”。一旦你阅读了下面关于图灵测试的部分，你可能会明白为什么她会这样称呼你！
- en: '[Click here for the Alice chatterbot at pandorabots.com](http://www.pandorabots.com/pandora/talk?botid=f5d922d97e345aa1)'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击这里查看 pandorabots.com 上的 Alice chatterbot](http://www.pandorabots.com/pandora/talk?botid=f5d922d97e345aa1)'
- en: '![](563ad8f4665e3.png)'
  id: totrans-1260
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad8f4665e3.png)'
- en: Does Alice sound more intelligent than Eliza? Does she sound as intelligent
    as a human, or can you trick her into saying things that make no sense? Try using
    the same tricks you used to fool Eliza and see if they fool Alice as well. (Look
    back at the list of bullet points in the Eliza section just above).
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: Alice 听起来比 Eliza 更聪明吗？她听起来像一个人类那样聪明吗，还是你可以用同样的技巧来愚弄她，让她说出毫无意义的话？试试看用来愚弄 Eliza
    的同样技巧，看看它们是否也能愚弄 Alice。（回头看看上面 Eliza 部分的项目列表）。
- en: Like Eliza, Alice also uses hard coded rules to know what to say, although she
    has a lot more of these rules and a more sophisticated algorithm for choosing
    which rules should be used to determine what to say. If you want to know more,
    just ask Alice how she works, and she’ll tell you!
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Eliza 一样，Alice 也使用硬编码规则来知道该说些什么，尽管她拥有更多的这些规则和一个更复杂的算法来选择应该使用哪些规则来确定该说什么。如果你想了解更多，请问
    Alice 她是如何工作的，她会告诉你的！
- en: Some possible rules that Alice might have are,
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: Alice 可能有的一些可能的规则是，
- en: If “favourite colours” are mentioned, say your favourite colour is “green”,
  id: totrans-1264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提到“最喜欢的颜色”，就说你最喜欢的颜色是“绿色”，
- en: if family members are mentioned (e.g. “mum”, “dad”, or “brother”) say something
    that is about family.
  id: totrans-1265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提到了家庭成员（例如“妈妈”、“爸爸”或“兄弟”），就说些关于家庭的事情。
- en: To use the rules, the chatterbot analyses your last sentence (and possibly earlier
    sentences also) by matching the sentence against the patterns in its rules. If
    the sentence matches the rule pattern, it “activates” the rule. The rule will
    specify a reply. Sometimes the reply is just a template for a sentence, and the
    chatterbot analyses the text you typed to extract words that can be inserted into
    the template. That’s why the replies sometimes use part of what you typed.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些规则，chatterbot 通过将句子与其规则中的模式进行匹配来分析你最后的句子（可能还有之前的句子）。如果句子与规则模式匹配，则“激活”规则。规则将指定一个回复。有时回复只是一个句子的模板，chatterbot
    分析你输入的文本以提取可以插入模板的单词。这就是为什么回复有时会使用你输入的部分内容。
- en: The quality of these rules determines how intelligent the chatterbot will sound.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则的质量决定了 chatterbot 的听起来有多聪明。
- en: While Alice is undoubtedly more intelligent than Eliza, Alice still has her
    limitations. Sometimes she even admits to those limitations!
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Alice 无疑比 Eliza 更聪明，但 Alice 仍然有她的局限性。有时她甚至承认这些局限性！
- en: '**Judge**: What will happen in the year 2000 **ALICE**: I cannot predict the
    future. **Judge**: That is the past **ALICE**: Yes it is one of the past. **Judge**:
    Then why did you say you can’t predict the future? **ALICE**: It was a preprogrammed
    response completely determined by your statements.'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: '**评委**：2000 年会发生什么**ALICE**：我不能预测未来。**评委**：那是过去**ALICE**：是的，这是过去之一。**评委**：那你为什么说你不能预测未来呢？**ALICE**：这是一个完全由你的陈述确定的预设响应。'
- en: I suppose I was a bit mean for tricking her and saying “what will”. Her rules
    assume a human wouldn’t mislead her like that.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我有点刻薄，骗她说“将要”这样的话。她的规则假定一个人类不会像那样误导她。
- en: 10.2.3\. CHATTERBOTS THAT LEARN FROM HUMANS
  id: totrans-1271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3\. 从人类学习的 chatterbots
- en: We saw in the previous sections examples of two chatterbots that have rules
    that help them determine suitable things to say. One of those chatterbots only
    works in a restricted domain, taking the role of a therapist, and is unable to
    have very general conversations, and the other is able to have more general conversations.
    Both these chatterbots had their *rules* of what to say determined by programmers *at
    the time of programming*, and these rules will never be changed unless a programmer
    decides to change them.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们看到了两个聊天机器人的例子，它们有规则来帮助它们确定适合说的事情。其中一个聊天机器人只在一个受限领域内工作，扮演心理医生的角色，无法进行非常一般性的对话，而另一个能够进行更一般性的对话。这两个聊天机器人的*规则*在编程时由程序员确定，除非程序员决定更改这些规则，否则这些规则永远不会改变。
- en: There are other chatterbots that are able to *learn* their rules from the humans
    they have conversations with. By looking at how a human responds to various dialogues,
    the chatterbot attempts to learn how it should respond in various situations.
    The idea is that if it responds in similar ways to what a human does, then perhaps
    it will sound like a human. Most of these chatterbots aim to have very general
    conversations, i.e. they aren’t restrained to one domain such as Eliza the therapist
    is.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他聊天机器人能够从与人类对话中*学习*它们的规则。通过观察人类如何回应各种对话，聊天机器人试图学习在不同情况下应该如何回应。其想法是，如果它的回应方式类似于人类的方式，那么也许它会听起来像一个人类。大多数这些聊天机器人的目标是进行非常一般性的对话，即它们不受限于像心理医生艾丽莎那样的一个领域。
- en: If it is human intelligence you are trying to simulate, then perhaps learning
    from humans is the way to go?
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图模拟人类智能，那么也许从人类那里学习是一个好方法？
- en: Warning
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Please note that the following exercise involves interacting with one of these
    chatterbots. Because the chatterbot has learnt from humans, it will quite possibly
    have been taught to say things that you may find highly offensive. While we have
    tried to choose chatterbots that mostly say things that aren’t going to offend,
    it is impossible to guarantee this, so use your discretion with them; you can
    skip this section and still cover the main concepts of this chapter. Because Eliza
    and Alice don’t learn from humans, they won’t say offensive things unless you
    do first!
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下练习涉及与这些聊天机器人之一进行互动。由于聊天机器人是从人类那里学习的，它很可能已经被教导说一些你可能会觉得非常冒犯的话。虽然我们已经尽量选择那些大多不会冒犯的聊天机器人，但无法保证这一点，所以请谨慎使用；你可以跳过这一部分，仍然涵盖本章的主要概念。因为艾丽莎和爱丽丝不会从人类那里学习，除非你先这样做，否则它们不会说冒犯性的话！
- en: And again, don’t tell the chatterbots your personal details (such as your full
    name, date of birth, address, or any other information you wouldn’t be happy sharing
    with everybody). Make stuff up where necessary. A chatterbot that learns from
    people quite possibly *will* pass on what you say to other people in an attempt
    to sound intelligent to *them*!
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，不要告诉聊天机器人你的个人信息（比如你的全名、出生日期、地址，或者任何你不愿意与所有人分享的信息）。必要时编造一些内容。一个从人类那里学习的聊天机器人很可能*会*把你说的话传给其他人，以试图对*他们*显得聪明！
- en: These warnings will make more sense once you’ve learnt how these chatterbots
    work.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 这些警告在你学会这些聊天机器人如何工作之后会更有意义。
- en: An example of a chatterbot that learns from humans is Cleverbot.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 一个从人类那里学习的聊天机器人的例子是Cleverbot。
- en: '[Click on this link to have a conversation with Cleverbot](http://www.cleverbot.com/)'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '[点击这个链接与Cleverbot进行对话](http://www.cleverbot.com/)'
- en: '[![](563ad8f3c0670.png)](http://www.cleverbot.com/)'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad8f3c0670.png)](http://www.cleverbot.com/)'
- en: Unlike Eliza and Alice, whose rules of what to say were determined by programmers,
    Cleverbot learns rules based on what people say. For example, when Cleverbot says
    “hi” to a person, it keeps track of all the different responses that people make
    to that, such as “hi”, “hello!”, “hey ya”, “sup!”. A rule is made that says that
    if somebody says hi to you, then the things that people have commonly said in
    response to Cleverbot saying hi are appropriate things to say in response to “hi”.
    In turn, when Cleverbot says something like “sup!” or “hello!”, it will look at
    how humans respond to that in order to learn appropriate response for those. And
    then it will learn responses for those responses. This allows Cleverbot to built
    up an increasingly large database.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 与Eliza和Alice不同，其说话规则由程序员确定，Cleverbot的规则是基于人们说的话学习的。例如，当Cleverbot对一个人说“嗨”时，它会追踪人们对此的所有不同回应，如“嗨”，“你好！”，“嘿”，“嗨，你好”。制定了一个规则，即如果有人对你说“嗨”，那么人们对Cleverbot说“嗨”的常见回应是适合作为对“嗨”回应的事情。反过来，当Cleverbot说类似“嘿！”或“你好！”之类的话时，它将查看人们对此如何回应，以学习适当的回应。然后它会学习对这些回应的回应。这使Cleverbot能够建立起越来越庞大的数据库。
- en: An implication of learning from humans is that Cleverbot makes the assumption
    that the humans actually *are* intelligent, and will teach it to say intelligent
    things. If for example people told Cleverbot something like “School is boring”
    in response to Cleverbot saying “hi”, Cleverbot might learn that when a person
    says “hi” to it, it should say “School is boring”!
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 从人类学习的一个含义是，Cleverbot假设人类实际上是聪明的，并且会教它说聪明的话。例如，如果人们对Cleverbot说“嗨”的回应是“学校很无聊”，那么Cleverbot可能会学到，当一个人对它说“嗨”时，它应该说“学校很无聊”！
- en: '**Curiosity: A short film written by Cleverbot**'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: '**好奇心：由Cleverbot编写的短片**'
- en: Check out the short film [“Do You Love Me”](http://www.youtube.com/watch?v=QkNA7sy5M5s) (~3
    mins), that Chris R Wilson collaborated with Cleverbot to write a movie script.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 观看由Chris R Wilson与Cleverbot合作编写的短片[“Do You Love Me”](http://www.youtube.com/watch?v=QkNA7sy5M5s)（约3分钟）。
- en: 10.2.4\. EVEN MORE CHATTERBOTS!
  id: totrans-1286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4\. 还有更多的聊天机器人！
- en: There are even more chatterbots you can talk to. Try looking at the [list on
    wikipedia](http://en.wikipedia.org/wiki/List_of_chatterbots), or doing a google
    search for chatterbots. Each chatterbot on this list has its own wikipedia page.
    You should be able to find the chatterbots by either an internet search, or looking
    at the references of the wikipedia pages. Some of these will have rules that were
    determined by programmers, and others will have rules that were learnt from humans.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以和更多的聊天机器人交谈。试着看看维基百科上的[列表](http://en.wikipedia.org/wiki/List_of_chatterbots)，或者在Google上搜索聊天机器人。此列表上的每个聊天机器人都有自己的维基百科页面。你应该能够通过互联网搜索或查看维基百科页面的参考资料找到这些聊天机器人。其中一些将具有由程序员确定的规则，而其他一些将具有从人类那里学到的规则。
- en: If you have a device that runs Apple iOS (for example an iPhone), have a look
    at the [Siri](http://en.wikipedia.org/wiki/Siri_%28software%29) chatterbot in
    the device’s help system. Siri is an example of a chatterbot that has the job
    of *helping* a human, unlike most chatterbots which simply have the purpose of
    web entertainment. It also has voice recognition, so you can talk to it rather
    than just typing to it.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一台运行Apple iOS的设备（例如iPhone），可以查看设备帮助系统中的[Siri](http://en.wikipedia.org/wiki/Siri_%28software%29)聊天机器人。Siri是一个聊天机器人的例子，其工作是*帮助*人类，而不像大多数聊天机器人那样只是网络娱乐的目的。它还具有语音识别功能，因此您可以与它交谈而不仅仅是与它打字。
- en: 10.2.5\. THE TURING TEST
  id: totrans-1289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.5\. 图灵测试
- en: In the above sections you met some chatterbots, and (hopefully!) have drawn
    the conclusion that they aren’t entirely convincing in terms of sounding like
    a human (although some are better than others!). But maybe soon, there will be
    new chatterbots that don’t have the same limitations. Should we consider them
    to be intelligent? How could we tell? Is there a formal way we can determine whether
    or not a chatterbot is of the level of human intelligence?
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的部分中，你遇到了一些聊天机器人，并且（希望！）已经得出结论，它们在听起来像人类方面并不完全令人信服（尽管有些比其他人更好！）。但也许很快就会有新的聊天机器人，它们没有相同的限制。我们应该认为它们是智能的吗？我们怎么知道？有没有一种正式的方法可以确定聊天机器人是否达到了人类智能的水平？
- en: A very famous computer scientist, Alan Turing, answered this question back in
    1950, before the first chatterbots even existed! Alan Turing had an extraordinary
    vision of the future, and knew that coming up with computers that were intelligent
    would become a big thing, and that we would need a way to know when we have succeeded
    in creating a truly intelligent computer.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 一位非常著名的计算机科学家，艾伦·图灵，于1950年回答了这个问题，甚至在第一个聊天机器人出现之前！艾伦·图灵对未来有着非凡的愿景，并知道创造智能计算机将成为一件大事，并且我们需要一种方法来知道我们何时成功地创造出真正智能的计算机。
- en: He thought about how intelligence could be defined (defining intelligence is
    surprisingly difficult!), and decided that one way would be to say that a human
    was intelligent, and that if a computer was able to communicate convincingly like
    a human, then it must be intelligent also. This definition doesn’t cover all of
    intelligence, as it only considers what a person or a computer says and ignores
    other components of intelligence such as determining the best way to walk through
    a building (or maze) or deciding how to act in a specific situation (such as at
    a social event, when deciding what to do next at work, or when lost). However,
    communication is still a very significant component of human intelligence.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 他思考了智能如何被定义（定义智能出奇地困难！），并决定一个方法是说一个人是智能的，如果一个计算机能够像人类一样令人信服地进行交流，那么它也必须是智能的。这个定义并不涵盖所有智能，因为它只考虑了一个人或计算机所说的内容，并忽略了智能的其他组成部分，比如确定最佳的步行方式（或迷宫中的行走方式）或在特定情况下（比如在社交活动中，在工作中下一步该怎么做，或者在迷路时）决定如何行动。然而，交流仍然是人类智能的一个非常重要的组成部分。
- en: In order to test whether or not a computer program can communicate like a human,
    Turing proposed a test. In addition to the computer program, two humans are required
    to carry out the test. One of the humans act as an interrogator, and the other
    as a “human” to compare the computer program to. The interrogator is put in a
    separate room from the computer running the computer program and the “human”.
    The interrogator has conversations with both the human and the computer program,
    but isn’t told which one they are having the conversation with at each time. The
    conversations are both carried out over something like an instant messaging program
    so that actual speech isn’t required from the computer program. During the conversations,
    the human has to convince the interrogator that they are indeed the human, and
    the computer program has to convince the interrogator that IT is actually the
    human. At the end of the conversations, the interrogator has to say which was
    the computer and which was the human. If they can’t reliably tell, then the computer
    is said to have passed the test.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试计算机程序是否能像人类一样进行交流，图灵提出了一个测试。除了计算机程序外，还需要两名人类来进行测试。其中一名人类充当询问者，另一名充当与计算机程序进行比较的“人类”。询问者与运行计算机程序和“人类”的计算机分开放置在另一个房间。询问者与人类和计算机程序进行对话，但在每次对话中都不会被告知他们正在与哪个进行对话。这些对话都通过类似即时消息传递程序进行，因此计算机程序不需要进行实际语音交流。在对话过程中，人类必须说服询问者他们确实是人类，而计算机程序必须说服询问者它实际上是人类。在对话结束时，询问者必须说出哪个是计算机，哪个是人类。如果他们无法可靠地判断，则认为计算机通过了测试。
- en: This test proposed by Turing eventually became very famous and got the name
    “The Turing Test”. One of the motivations for writing chatterbots is to try and
    make one that passes the Turing Test. Unfortunately, making a chatterbot that
    successfully passes the Turing Test hasn’t yet been achieved, and whether or not
    it is even possible is still an open question in computer science, along with
    many other questions in artificial intelligence that you will encounter later
    in this chapter.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵提出的这个测试最终变得非常著名，并得名为“图灵测试”。编写聊天机器人的一个动机是尝试制作一个通过图灵测试的聊天机器人。不幸的是，成功通过图灵测试的聊天机器人尚未实现，甚至是否可能实现仍然是计算机科学中一个悬而未决的问题，与本章后面将遇到的许多其他人工智能问题一样。
- en: Other forms of the Turing Test exist as well. Action games sometimes have computer
    controlled characters that fight your own character, in place of a second human
    controlled character. A variation of the Turing Test can be used to determine
    whether or not the computer controlled player seems to have human intelligence
    by getting an interrogator to play against both the computer character and the
    human character, and to see whether or not they can tell them apart.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵测试还有其他形式存在。动作游戏有时会有计算机控制的角色与你的角色战斗，而不是第二个由人类控制的角色。图灵测试的一种变体可以用来确定计算机控制的玩家是否具有人类智能，方法是让一个审讯员同时对抗计算机角色和人类角色，看看他们能否区分出它们。
- en: Infact, many parts of human intelligence could be tested using a variation of
    the Turing Test. If you wanted a computer chess player that seemed like a human
    as opposed to a computer (as some people might prefer to be playing against a
    human rather than a computer), you could use a Turing Test for this as well! What
    other possible Turing Tests can you think of?
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，人类智能的许多部分都可以使用图灵测试的变体来进行测试。如果你想要一个看起来像人类而不是计算机的国际象棋程序（因为有些人可能更喜欢与人类对弈而不是与计算机对弈），你也可以使用图灵测试！你还能想到哪些可能的图灵测试呢？
- en: In the next section, you will actually carry out the Turing Test on a chatterbot.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将会对一个闲聊机器人进行图灵测试。
- en: '**Curiosity: The real Turing test**'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: '**好奇心：真实的图灵测试**'
- en: Alan Turing actually started by suggesting a simple party game requiring three
    players, where the first player was female, the second player was male, and the
    third player could be either male or female, and took the role of the “interrogator”.
    The interrogator would be in a separate room to the other two players, and could
    only communicate with them by passing written notes (for example, by passing the
    notes under a door). The male had to try and convince the interrogator that he
    was actually female, and the female had to try and convince the interrogator that
    she *was* the female. At the end the interrogator had to say which was the male
    and which was the female, and if the interrogator guessed incorrectly, then the
    male “won”.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 艾伦·图灵实际上首先建议了一个简单的三人派对游戏，其中第一个玩家是女性，第二个玩家是男性，第三个玩家可以是男性也可以是女性，他扮演“审讯员”的角色。审讯员将与其他两名玩家分开在一个房间里，只能通过传递书面笔记与他们交流（例如，通过门底传递笔记）。男性必须试图说服审讯员他实际上是女性，而女性必须试图说服审讯员她就是女性。最后，审讯员必须说出谁是男性，谁是女性，如果审讯员猜错了，那么男性“赢了”。
- en: '10.2.6\. ACTIVITY: RUN YOUR OWN TURING TEST'
  id: totrans-1300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.6\. 活动：进行你自己的图灵测试
- en: This section will involve you actually carrying out the Turing Test. Read this
    entire section carefully (and the previous section if you haven’t done so already)
    before you start, and make sure you understand it all before starting.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将会亲自进行图灵测试。在开始之前，请仔细阅读整个章节（如果你还没有这样做，请阅读前一节），确保你理解了所有内容。
- en: In science classes, such as biology, physics, and chemistry, carrying out experiments
    is commonly done. If you have taken classes like these, you will probably know
    that if an experiment isn’t carried out properly (e.g. in chemistry some students
    are tempted to put in more of a chemical than the instructions say to, or when
    timing is important this is easy to get wrong), then the results will not necessarily
    be the ones you are after and your experiment is essentially meaningless and pointless.
    You also have to be careful that other factors don’t affect the results. e.g.
    controlling temperature and moisture in biology experiments that involve growing
    micro-organisms.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 在科学课上，比如生物学、物理学和化学课上，进行实验是很常见的。如果你上过这样的课，你可能知道，如果实验没有进行正确（例如，在化学中，有些学生可能会加入比说明书上说的更多的化学物质，或者在时间控制方面容易出错），那么结果可能不会是你想要的，你的实验基本上是毫无意义的。你还必须注意其他因素不会影响结果。例如，在涉及培养微生物的生物学实验中控制温度和湿度。
- en: Carrying out the Turing Test is carrying out an experiment, just like carrying
    out experiments in chemistry classes. And just like the chemistry experiments,
    carrying out the Turing Test requires being careful to follow instructions correctly,
    and controlling factors that could potentially affect the results but aren’t part
    of what is being tested. You should keep this in mind while you are carrying out
    this project.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 进行图灵测试就像进行实验一样，就像在化学课上进行实验一样。就像化学实验一样，进行图灵测试需要小心遵循正确的指示，并控制可能影响结果但不是被测试的因素。在进行这个项目时，请记住这一点。
- en: For example, most chatterbots communicate in a text form rather than verbal.
    Communicating in a verbal form involves not only choosing intelligent sounding
    things to say, but also involves having a convincing voice and pronouncing words
    correctly. Tone of voice or accent could potentially make it very obvious to the
    interrogator which conversation was with the human and which was the computer,
    without them even having to consider what was actually said in the conversation.
    This is not what the Turing Test is supposed to be testing! Therefore, the Turing
    Test will have both the computer and the human communicating in a written form.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，大多数聊天机器人是以文本形式进行交流，而不是口头交流。口头交流不仅涉及选择智能的发言内容，还涉及拥有令人信服的声音和正确发音。语调或口音可能会让询问者很明显地知道哪个对话是与人类进行的，哪个是与计算机进行的，甚至不需要考虑对话中实际说了什么。这不是图灵测试应该测试的内容！因此，图灵测试将让计算机和人类以书面形式进行交流。
- en: As another example, speed of response could have an impact. The computer is
    likely to be able to reply instantly, whereas the human will need time to think
    and then write their reply. To prevent the interrogator from making their decision
    based on the speed instead of the content, the speed of response needs to be controlled
    as well. The way of carrying out the Turing Test described below tries to control
    these additional factors.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，回应速度可能会产生影响。计算机可能能够立即回复，而人类需要时间思考然后写出他们的回复。为了防止询问者基于速度而不是内容做出决定，还需要控制回应速度。下面描述的进行图灵测试的方式试图控制这些额外因素。
- en: Choose a chatterbot from the list on Wikipedia (see the above chatterbots section),
    or possibly use Alice or Cleverbot (Eliza isn’t recommended for this). You will
    be taking the role of the interrogator, but will need another person to act as
    the “human”. For this it is recommended you choose a person in your class who
    you don’t know very well. Do *not* choose your best friend in the class, because
    you will know their responses to questions too well, so will be able to identify
    them from the chatterbot based on their personality rather than the quality of
    the chatterbot.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 从维基百科的列表中选择一个聊天机器人（请参见上面的聊天机器人部分），或者可能使用Alice或Cleverbot（Eliza不推荐用于此）。你将扮演询问者的角色，但需要另一个人扮演“人类”的角色。因此建议选择一个你不太了解的班上的人。不要选择你在班上最好的朋友，因为你会太了解他们对问题的回答，所以会根据他们的个性而不是聊天机器人的质量来识别他们。
- en: In addition to the chatterbot and your classmate to act as the human, you will
    need access to a room with a computer with internet (this could just be the computer
    classroom), another room outside it (a hallway would be fine), pieces of paper,
    2 pens, and a coin or a dice.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 除了聊天机器人和你的同学扮演人类角色外，你还需要进入一个带有互联网的计算机的房间（这可能只是计算机教室），以及房间外的另一个房间（走廊也可以），纸张，2支笔，以及一枚硬币或一个骰子。
- en: The chatterbot should be loaded on the computer to be used, and your classmate
    should be in the same room with the computer. You should be outside that room.
    As the interrogator, you will first have a conversation with either your classmate
    or the computer, and then a conversation with the other one. You should not know
    which order you will speak to them; to determine which you speak to first your
    classmate should use the dice or the coin to randomly decide (and shouldn’t tell
    you).
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天机器人应该加载在要使用的计算机上，你的同学应该在同一个房间里。你应该在那个房间外面。作为询问者，你将首先与你的同学或计算机进行对话，然后与另一个进行对话。你不应该知道你将与他们中的哪一个先交谈；为了确定你先与哪个交谈，你的同学应该使用骰子或硬币随机决定（并且不告诉你）。
- en: In order to carry out the conversations, start by writing something at the top
    of the piece of paper such as “hello” or “hi” or “how are you?”. Put a mark next
    to the line to make it clear that line was written by YOU. Pass the piece of paper
    into the room where your classmate and the computer are (if you can, slide it
    under the door) where your classmate will write a reply on it and pass it back
    to you. You should then write a reply to that and repeat the process. Each conversation
    should be on a separate piece of paper, and be around 20 to 40 lines long (this
    means that each person/ computer should say around 10 - 20 lines in each conversation).
    Put a mark next to each of the lines you write, so that it is clear who wrote
    which lines.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行对话，首先在纸的顶部写下一些东西，比如“你好”或“嗨”或“你好吗？”。在该行旁边做个标记，以明确表明该行是由你写的。将纸张传递到你的同学和计算机所在的房间（如果可以的话，可以将其滑到门下面），你的同学会在上面写下回复，并将其传递回给你。然后你应该写下一个回复，重复这个过程。每个对话应该在一张独立的纸上进行，并且大约有
    20 到 40 行（这意味着每个人/计算机在每个对话中应该说大约 10 - 20 行）。在你写的每一行旁边做个标记，以便清楚地表明是谁写的哪些行。
- en: If your classmate is currently supposed to be having the conversation (rather
    than the chatterbot), they will write the reply based on what they would say.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的同学目前应该正在进行对话（而不是 chatterbot），他们将根据自己会说的话写回复。
- en: If the chatterbot is currently supposed to be having the conversation, your
    classmate should type what you said into the chatterbot and then write its reply
    on the piece of paper. Before submitting the line to the chatterbot, they should
    double check it was entered correctly.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前 chatterbot 应该正在进行对话，你的同学应该将你说的话输入 chatterbot，并在纸上写下它的回复。在提交给 chatterbot
    之前，他们应该仔细检查是否输入正确。
- en: A problem is that it will take longer for the conversation between you and the
    chatterbot than between you and the classmate, because of the need for your classmate
    to type what you say to the chatterbot. You wouldn’t want to make it obvious which
    was the computer and which was the human due to that factor! To deal with this,
    you could intentionally delay for a while before each reply to that they all take
    exactly one minute.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题是，由于需要你的同学将你对 chatterbot 说的话输入，所以你和 chatterbot 之间的对话会比你和同学之间的对话时间更长。你不希望由于这个因素而明显地让计算机和人类区分开来！为了解决这个问题，你可以在每次回复之前故意延迟一段时间，以确保它们都花费一分钟。
- en: You can ask whatever you like, although keep in mind that you should be assuming
    you don’t know your classmate already, so don’t refer to common knowledge about
    previous things that happened such as in class or in the weekend in what you ask
    your classmate or the chatterbot. This would be unfair to the chatterbot since
    it can’t possibly know about those things. Remember you’re evaluating the chatterbot
    on its ability to display human intelligence, not on what it doesn’t know about.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以询问任何你想问的问题，尽管请记住你应该假设你还不认识你的同学，所以不要在你问同学或 chatterbot 的问题中提及关于以前发生的事情的常识，比如在课堂上或周末发生的事情。这对
    chatterbot 是不公平的，因为它不可能知道这些事情。记住你是在评估 chatterbot 的展示人类智能的能力，而不是它不知道的东西。
- en: Good conversation topics would be favourite colours, games, foods, the weather,
    and the kinds of conversation topics you’d have with a person you don’t know but
    are having a friendly conversation with at work, the supermarket, or a party.
    Coming up with good things to ask is challenging but just ask yourself whether
    something would require knowledge of an event that not everybody could be expected
    to have.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 好的对话话题可能是最喜欢的颜色、游戏、食物、天气，以及你与不认识但在工作、超市或派对上友好交谈的人会谈论的话题类型。想出好的问题是有挑战性的，但只需问问自己是否需要某些事件的知识，而不是每个人都可以预期具备这些知识。
- en: Once both conversations are complete, you as the interrogator has to say which
    was your classmate, and which was the chatterbot. Your classmate should tell you
    whether or not you were correct.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦两个对话都完成了，你作为审问者必须说出哪个是你的同学，哪个是 chatterbot。你的同学应该告诉你你是否正确。
- en: 'These are some questions you can consider after you have finished carrying
    out the Turing Test:'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行图灵测试后，你可以考虑一些问题：
- en: How were you able to tell which was the chatterbot and which was your classmate?
  id: totrans-1317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是如何能够分辨出哪个是 chatterbot，哪个是你的同学的呢？
- en: Were there any questions you asked that were “unfair” — that depended on knowledge
    your classmate might have but no-one (computer or person) from another place could
    possibly have?
  id: totrans-1318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否提出了任何“不公平”的问题 —— 这些问题依赖于你的同学可能知道但其他地方（无论是计算机还是人）都不可能知道的知识？
- en: 'Which gave it away more: the content of the answers, or the way in which the
    content was expressed?'
  id: totrans-1319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是回答的内容更容易暴露问题，还是内容表达的方式更容易暴露问题？
- en: '![](563ad8f32f57b.png)'
  id: totrans-1320
  prefs: []
  type: TYPE_IMG
  zh: '![](563ad8f32f57b.png)'
- en: '10.2.7\. PROJECT: INVESTIGATING CHATTERBOTS AND THE TURING TEST'
  id: totrans-1321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.7\. 项目：调查聊天机器人和图灵测试
- en: In this project, you will write a report about your investigations of Chatterbots
    and the Turing Test.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将撰写一份关于你对聊天机器人和图灵测试的调查的报告。
- en: The report consists of 2 parts. The first involves demonstrating that you understand
    the Turing Test by carrying out your own Turing Test and then answering some questions
    about the Turing Test. The second part involves having conversations with several
    chatterbots and investigating some common techniques they used in order to sound
    as though they have human intelligence.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 报告分为两部分。第一部分涉及通过进行自己的图灵测试来证明你理解图灵测试，并回答一些关于图灵测试的问题。第二部分涉及与几个聊天机器人进行对话，并调查它们用来表现得像有人类智能的一些常见技巧。
- en: If you haven’t already, carry out the Turing Test in the project in the above
    section. Once you have carried out the Turing Test and have your two conversations,
    answer the following questions in your report, to show you understand the Turing
    Test. *Make sure you include the two conversations in your report!*
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有在上述部分的项目中进行图灵测试，请进行图灵测试。一旦你完成了图灵测试并有了两次对话，回答以下问题以展示你理解图灵测试。*确保在报告中包含这两次对话！*
- en: Explain what the Turing Test is for, using your experience with chatterbots
    as an example.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 用你对聊天机器人的经验举例解释图灵测试的目的。
- en: Describe what you did to run a Turing Test, including a copy of the two conversations.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 描述你进行图灵测试的过程，包括两次对话的副本。
- en: When you were carrying out the Turing Test, you had to be careful to avoid external
    factors that gave away which was the computer and which was the human. Explain
    some of these factors and why it is important to avoid them. (Some of them were
    mentioned in the text above!)
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行图灵测试时，你必须小心避免暴露哪个是计算机哪个是人类的外部因素。解释其中一些因素以及避免它们的重要性。 （有些因素在上面的文本中提到！）
- en: Explain how the Turing Test could be used to evaluate a new chatbot. Discuss
    other possible applications of the Turing Test or similar tests for other programs
    that are supposed to be intelligent.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 解释图灵测试如何用于评估新的聊天机器人。讨论图灵测试或类似测试在其他被认为具有智能的程序的其他可能应用。
- en: Discuss whether or not the Turing test is a good test of intelligence, giving
    reasons for your answer and using examples from your chatterbot experiments. What
    parts of *human* intelligence would the Turing test not capture?
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论图灵测试是否是智能的良好测试，给出你的答案理由，并使用你对聊天机器人实验的例子。图灵测试无法捕捉到哪些*人类*智能的部分？
- en: Before completing this second part of your report, you should ensure you have
    talked to at least three chatterbots (either the ones talked about in this book
    or other ones you find).
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成报告的第二部分之前，你应该确保至少与三个聊天机器人交谈过（可以是本书中提到的那些，也可以是你找到的其他聊天机器人）。
- en: What is it that chatterbots are trying to accomplish?
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天机器人试图实现什么目标？
- en: Describe the chatterbots that you have investigated. Show a brief conversation
    with each of them to illustrate what they do (no more than 10 lines for each conversation).
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 描述你调查过的聊天机器人。展示每个聊天机器人的简短对话，以说明它们的功能（每次对话不超过10行）。
- en: Choose at least two techniques used by chatterbots in an attempt to sound like
    they have human intelligence. The techniques you choose could be the identification
    of key words, canned responses, learning from humans, giving very general replies,
    or anything else you notice about how a chatterbot tends to speak or react that
    is an attempt to make it sound human (including techniques that make sense in
    some cases that the chatterbot uses them, but not in others!)
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 选择至少两种聊天机器人用来试图表现得像有人类智能的技巧。你选择的技巧可能是关键词的识别、固定回复、从人类那里学习、给出非常一般性的回复，或者你注意到的聊天机器人倾向于说话或反应的任何其他技巧，这些技巧试图使其听起来像人类（包括在某些情况下聊天机器人使用它们有意义，但在其他情况下不适用的技巧！）
- en: For each of the techniques you choose, do the following.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你选择的每一种技巧，都要做以下事情。
- en: Explain how the technique works, using specific examples.
  id: totrans-1335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用具体示例解释技术的工作原理。
- en: Give examples of specific chatterbots that use this technique, and examples
    of conversations with these chatterbots where it is obvious that they are using
    these techniques.
  id: totrans-1336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供使用此技术的特定聊天机器人的示例，以及与这些聊天机器人的对话示例，其中显然它们正在使用这些技术。
- en: Explain your examples in terms of the technique(s) they are illustrating.
  id: totrans-1337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用示例解释所示技术。
- en: Discuss how well the techniques work and when they break.
  id: totrans-1338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论这些技术在何时运作良好以及何时会出现问题。
- en: Which techniques seemed to be the most effective, if any? How could you tell
    that these chatterbots weren’t actually human? What were the main limitations
    of the chatterbots? Which chatterbot out of the ones you talked to do you think
    was the most intelligent? Which was the least intelligent? Why?
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有的话，哪些技术似乎最有效？你如何能够知道这些聊天机器人实际上并不是人类？聊天机器人的主要局限是什么？在你谈论的聊天机器人中，你认为哪个最聪明？哪个最笨？为什么？
- en: Most of the chatterbots you have looked at here exist solely for the purpose
    of web entertainment, or as attempts to pass the Turing Test. These however aren’t
    the only applications of chatterbots. Discuss how chatterbots be useful in other
    applications, for example, help systems and games? Can you think of any other
    possible applications for chatterbots?
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你看过的大多数聊天机器人仅存在于网络娱乐的目的，或者作为通过图灵测试的尝试。然而，这并不是聊天机器人的唯一应用。讨论一下聊天机器人在其他应用中可能有用，例如帮助系统和游戏？你能想到其他可能的聊天机器人应用吗？
- en: 10.3\. THE WHOLE STORY!
  id: totrans-1341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3\. 整个故事！
- en: In this chapter so far, we have only talked about one application of AI. AI
    contains many more exciting applications, such as computers that are able to play
    board games against humans, computers that are able to learn, and computers that
    are able to control robots that are autonomously exploring an environment too
    dangerous for humans to enter.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们只谈到了人工智能的一个应用。人工智能包含许多更令人兴奋的应用，例如能够与人类玩棋盘游戏的计算机，能够学习的计算机，以及能够控制机器人的计算机，这些机器人正在自主地探索对人类来说太危险的环境。
- en: Eventually further sections on other topics in AI will be added to this chapter.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，本章节将添加有关人工智能其他主题的进一步内容。
- en: 10.4\. FURTHER READING
  id: totrans-1344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4\. 进一步阅读
- en: '[Artificial Intelligence Strong and Weak - I Programmer](http://www.i-programmer.info/babbages-bag/297-artificial-intelligence.html)'
  id: totrans-1345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[人工智能的强与弱 - 程序员](http://www.i-programmer.info/babbages-bag/297-artificial-intelligence.html)'
- en: '[The Paradox of Artificial Intelligence - I Programmer](http://www.i-programmer.info/programming/artificial-intelligence/2437-the-paradox-of-artificial-intelligence.html)'
  id: totrans-1346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[人工智能的悖论 - 程序员](http://www.i-programmer.info/programming/artificial-intelligence/2437-the-paradox-of-artificial-intelligence.html)'
- en: 10.4.1\. USEFUL LINKS
  id: totrans-1347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1\. 有用链接
- en: '[CS Unplugged - Programming Languages - Harold the Robot](http://csunplugged.org/programming-languages-0) -
    related to why AI is so tricky'
  id: totrans-1348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CS Unplugged - 编程语言 - 哈罗德机器人](http://csunplugged.org/programming-languages-0) -
    与为什么人工智能如此棘手有关'
- en: '[CS Unplugged - Artificial Intelligence - The Intelligent Piece of Paper](http://csunplugged.org/intelligent-paper)'
  id: totrans-1349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CS Unplugged - 人工智能 - 智能纸](http://csunplugged.org/intelligent-paper)'
- en: '[CS Unplugged - The Turing Test - Conversations with Computers](http://csunplugged.org/turing-test)'
  id: totrans-1350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CS Unplugged - 图灵测试 - 与计算机的对话](http://csunplugged.org/turing-test)'
- en: '[Wikipedia- Outline of Artificial Intelligence](http://en.wikipedia.org/wiki/Outline_of_artificial_intelligence)'
  id: totrans-1351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[维基百科 - 人工智能大纲](http://en.wikipedia.org/wiki/Outline_of_artificial_intelligence)'
- en: '[Wikipedia - Turing Test](http://en.wikipedia.org/wiki/Turing_test)'
  id: totrans-1352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[维基百科 - 图灵测试](http://en.wikipedia.org/wiki/Turing_test)'
- en: '[Wikipedia - Machine Learning](http://en.wikipedia.org/wiki/Machine_learning)'
  id: totrans-1353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[维基百科 - 机器学习](http://en.wikipedia.org/wiki/Machine_learning)'
- en: '[CS 4 FUN - Meet the Chatterbots](http://www.cs4fn.org/ai/meetthechatterbots.php)'
  id: totrans-1354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[有趣的计算机科学 - 见见聊天机器人](http://www.cs4fn.org/ai/meetthechatterbots.php)'
- en: '[CS 4 FUN - The Illusion of Intelligence](http://www.cs4fn.org/ai/illusionintelligence.php)'
  id: totrans-1355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[有趣的计算机科学 - 智能的幻觉](http://www.cs4fn.org/ai/illusionintelligence.php)'
- en: '[Alice Bot](http://www.alicebot.org/)'
  id: totrans-1356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Alice Bot](http://www.alicebot.org/)'
- en: '[IEEE Spectrum](http://spectrum.ieee.org/robotics/artificial-intelligence)'
  id: totrans-1357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[IEEE Spectrum](http://spectrum.ieee.org/robotics/artificial-intelligence)'
- en: '[TED Conversations matching Artificial Intelligence](http://www.ted.com/conversations/topics/artificial+intelligence)'
  id: totrans-1358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[TED 对话与人工智能的匹配](http://www.ted.com/conversations/topics/artificial+intelligence)'
- en: 11\. COMPLEXITY AND TRACTABILITY
  id: totrans-1359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11\. 复杂性和可处理性
- en: 11.1\. WHAT’S THE BIG PICTURE?
  id: totrans-1360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1\. 大局是什么？
- en: Are there problems that are too hard even for computers? Yes. In the chapter
    on Artificial Intelligence we’ll see that just having a conversation — chatting
    — is something computers can’t do well, not because they can’t speak but rather
    because they can’t understand or think of sensible things to say. However, that’s
    not the kind of hard problem we’re talking about here — it’s not that computers
    couldn’t have conversations, more that we don’t know just how we do it ourselves
    and so we can’t tell the computer what to do.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机会遇到太难的问题吗？是的。在人工智能章节中，我们会看到，仅仅进行对话——聊天——是计算机无法做到的事情，不是因为它们不能说话，而是因为它们无法理解或者想出明智的话来说。然而，这并不是我们在这里讨论的那种难题——不是因为计算机无法进行对话，而更多是因为我们自己不知道该怎么做，所以无法告诉计算机该做什么。
- en: 'In this chapter we’re going to look at problems where it’s easy to tell the
    computer what to do — by writing a program — but the computer *can’t* do what
    we want because it takes far too long: millions of centuries, perhaps. Not much
    good buying a faster computer: if it were a hundred times faster it would still
    take millions of years; even one a million times faster would take hundreds of
    years. That’s what you call a *hard* problem—one where it takes far longer than
    the lifetime of the fastest computer imaginable to come up with a solution! The
    area of *tractability* explores problems and algorithms that can take an impossible
    amount of computation to solve except perhaps for very small examples of the problem.
    We’ll define what we mean by *tractable* later on, but put very crudely, a tractable
    problem is one which we can write programs for that finish in a reasonable amount
    of time, and an intractable problem is one that will generally end up taking way
    too long.'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将研究一些问题，我们很容易告诉计算机该怎么做——通过编写程序——但是计算机*无法*做到我们想要的，因为这需要太长的时间：也许需要数百万个世纪。买一个更快的计算机也没有多大用处：如果它快了一百倍，仍然需要数百万年；即使是快了一百万倍，也需要数百年。这就是所谓的*难*问题——一个需要比想象中最快的计算机的寿命还要长得多的时间来得到解决方案的问题！可处理性的领域探讨了那些除了可能是问题的非常小的示例之外，解决起来需要不可能的计算量的问题和算法。我们稍后会定义我们所说的*可处理性*，但粗略地说，一个可处理的问题是我们可以为其编写程序并在合理的时间内完成的问题，而一个不可处理的问题则是通常会花费太长时间的问题。
- en: Knowing when a problem you are trying to solve is one of these hard problems
    is very important. Otherwise it is easy to waste huge amounts of time trying to
    invent a clever program to solve it, and never getting anywhere. A computer scientist
    needs to be able to recognise a problem as an intractable problem, so that they
    can use other approaches. A very common approach is to give up on getting a perfect
    answer, and instead just aim for an approximately correct answer. There are a
    variety of techniques for getting good approximate answers to hard problems; a
    way of getting an answer that isn’t guaranteed to give the exact correct answer
    is sometimes referred to as a *heuristic*.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 知道你正在尝试解决的问题是否是这些难题之一非常重要。否则，很容易浪费大量时间尝试发明一个聪明的程序来解决它，却毫无进展。计算机科学家需要能够识别一个问题是否是一个不可处理的问题，以便他们可以使用其他方法。一个非常常见的方法是放弃追求完美答案，而是只追求一个大致正确的答案。有各种技术可以获得良好的近似解来解决难题；一种得到的答案并不能保证给出精确正确答案的方法有时被称为*启发式*。
- en: One important example of an intractable problem that this chapter looks at is
    the travelling salesman problem (TSP for short). It’s a simple problem; if you’ve
    got a collection of places that you need to visit, and you know the distance to
    travel between each pair of places, what’s the shortest route that visits all
    of the places exactly once? This is a very practical problem that comes up with
    courier vehicles choosing routes to deliver parcels, rock bands planning tours,
    and even a designated driver dropping friends off after an event. In fact, the
    measurement between cities doesn’t have to be distance. It could actually be the
    dollar cost to travel between each pair of cities. For example, if you needed
    to visit Queenstown, Christchurch, Auckland, and Wellington one after the other
    while minimising airfares and you knew the cost of an airfare between each pair
    of those 4 cities, you could work out what the cheapest way of flying to each
    of them is. This is still an example of TSP.
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要讨论的一个重要例子是旅行推销员问题（TSP简称）。这是一个简单的问题；如果您有一系列需要访问的地方，并且您知道每对地方之间的旅行距离，那么访问所有地方的最短路线是什么？这是一个非常实际的问题，在快递车辆选择路线来递送包裹、摇滚乐队计划巡回演出，甚至是指定驾驶员在活动结束后送朋友回家时都会遇到。实际上，城市之间的距离测量并不一定是距离。它实际上可以是每对城市之间旅行的美元成本。例如，如果您需要依次访问皇后镇、基督城、奥克兰和惠灵顿，并且要最小化机票费用，并且您知道这
    4 个城市之间的机票费用，那么您可以计算出去这些城市中的每一个的最便宜的飞行方式是什么。这仍然是TSP的一个例子。
- en: The following interactive has a program that solves the problem for however
    many cities you want to select by trying out all possible routes, and recording
    the best so far. You can get a feel for what an intractable problem looks like
    by seeing how long the interactive takes to solve the problem for different size
    maps. Try generating a map with about 5 cities, and press “Start” to solve the
    problem.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 以下互动程序可以根据您选择的城市数量解决问题，方法是尝试所有可能的路线，并记录迄今为止最佳路线。通过观察互动解决不同大小地图的问题所需的时间，您可以对难以解决的问题有所了解。尝试生成一个大约有
    5 个城市的地图，并按“开始”来解决这个问题。
- en: Now try it for 10 cities (twice as many). Does it take twice as long? How about
    twice as many again (20 cities)? What about 50 cities? Can you guess how long
    it would take? You’re starting to get a feel for what it means for a problem to
    be *intractable*.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试 10 个城市（是原来的两倍）。用时会是两倍吗？再尝试两倍的数量（20 个城市）呢？那么 50 个城市呢？你能猜出需要多长时间吗？你开始对问题“难以解决”有了一些感觉。
- en: Of course, for some situations, intractable problems are a good thing. In particular,
    most security and cryptography algorithms are based on intractable problems; the
    codes could be broken, but it would take billions of years and so would be futile.
    In fact, if anyone ever finds a fast algorithm for solving such problems, a lot
    of computer security systems would stop being secure overnight! So one of the
    jobs of computer scientists is to be confident that such solutions *don’t* exist!
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于某些情况来说，难以解决的问题是一件好事。特别是，大多数安全和加密算法都是基于难以解决的问题；密码可能会被破解，但需要数十亿年，所以这是徒劳的。实际上，如果有人找到了一种快速解决这些问题的算法，那么很多计算机安全系统将在一夜之间失去安全性！因此，计算机科学家的工作之一就是确保这样的解决方案*不存在*！
- en: 'In this chapter we will look at the TSP and other problems for which *no* tractable
    solutions are known, problems that would take computers millions of centuries
    to solve. And we will encounter what is surely the greatest mystery in computer
    science today: that *no-one knows* whether there’s a more efficient way of solving
    these problems! It may be just that no-one has come up with a good way yet, or
    it may be that there is no good way. We don’t know which.'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨TSP和其他一些问题，这些问题没有已知的可行解决方案，这些问题需要计算机数百万个世纪才能解决。我们将遇到计算机科学中无疑是最大的谜团之一：*没有人知道*是否存在更高效的解决这些问题的方法！也许只是还没有人提出一个好方法，或者可能根本就没有好方法。我们不知道是哪种情况。
- en: '[![](563ad96f09743.png)](http://xkcd.com/287/)'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad96f09743.png)](http://xkcd.com/287/)'
- en: But let’s start with a familiar problem that we can actually solve.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，让我们从一个我们实际上可以解决的熟悉问题开始。
- en: 11.2\. ALGORITHMS, PROBLEMS, AND SPEED LIMITS
  id: totrans-1371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2\. 算法、问题和速度限制
- en: '[*Complexity*](http://csfieldguide.org.nz/appendices/Glossary.html#term-complexity) is
    an important concept with problems and algorithms that solve them. Usually complexity
    is just the amount of time it takes to solve a problem, but there are several
    ways that we can measure the “time”. Using the actual time on a particular computer
    can be useful, but to get a rough idea of the inherent behaviour of an algorithm,
    computer scientists often start by estimating the number of steps the algorithm
    will take for *n* items. For example, a linear search can end up checking each
    of *n* items being searched, so the algorithm will take *n* steps. An algorithm
    that compares every pair of values in a list of *n* items will have to make n2comparisons,
    so we can characterise it as taking about n2 steps. This gives us a lot of information
    about how good an algorithm is without going into details of which computer it
    was running on, which language, and how well written the program was. The term *complexity* is
    generally used to refer to these rough measures.'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: '[*复杂性*](http://csfieldguide.org.nz/appendices/Glossary.html#term-complexity)是解决问题和解决方案的算法中的一个重要概念。通常复杂性只是解决问题所需的时间，但我们可以用几种方式来衡量“时间”。使用特定计算机上的实际时间可能很有用，但为了大致了解算法的固有行为，计算机科学家通常从估计算法对*n*个项目所需的步骤开始。例如，线性搜索可能最终检查正在搜索的每个*n*个项目，因此该算法将需要*n*步。一个比较列表中*n*个项目中每对值的算法将不得不进行n2次比较，因此我们可以将其描述为大约需要n2步。这为我们提供了关于算法的好坏的许多信息，而不必深入研究在哪台计算机上运行，使用哪种语言，以及程序编写得有多好。术语*复杂性*通常用于指代这些粗略的度量。'
- en: Having a rough idea of the complexity of a problem helps you to estimate how
    long it’s likely to take. For example, if you write a program and run it with
    a simple input, but it doesn’t finish after 10 minutes, should you quit, or is
    it about to finish? It’s better if you can estimate the number of steps it needs
    to make, and then extrapolate from the time it takes other programs to find related
    solutions.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 大致了解问题的复杂性有助于你估计它可能需要多长时间。例如，如果你编写一个程序并用简单输入运行它，但10分钟后它还没有完成，你应该放弃吗，还是它即将完成？如果你能估计它需要执行的步骤数量，然后从其他程序找到相关解决方案所需的时间进行推断，那就更好了。
- en: '**Jargon Buster: Asymptotic complexity**'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: '**术语解释：渐近复杂度**'
- en: If you’re reading about complexity, you may come across some terminology like
    “Big Oh” notation and “asymptotic complexity”, where an algorithm that takes about
    n2 steps is referred to as O(n2). We won’t get into these in this chapter, but
    here’s a little information in case you come across the terms in other reading.
    “Big Oh” notation is a precise way to talk about complexity, and is used with
    “asymptotic complexity”, which simply means how an algorithm performs for large
    values of *n*. The “asymptotic” part means as *n* gets really large — when this
    happens, you are less worried about small details of the running time. If an algorithm
    is going to take seven days to complete, it’s not that interesting to find out
    that it’s actually 7 days, 1 hour, 3 minutes and 4.33 seconds, and it’s not worth
    wasting time to work it out precisely.
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在阅读关于复杂性的内容，你可能会遇到一些术语，比如“大O符号”和“渐近复杂度”，其中一个大约需要n2步的算法被称为O(n2)。我们在本章不会深入讨论这些内容，但如果你在其他阅读中遇到这些术语，这里有一些信息。
    “大O符号”是一个精确描述复杂性的方式，通常与“渐近复杂度”一起使用，它简单地表示算法在*n*的大值情况下的表现。 “渐近”部分意味着当*n*变得非常大时
    — 当这种情况发生时，你不太担心运行时间的细节。如果一个算法需要七天才能完成，了解它实际上是7天1小时3分钟4.33秒并不那么有趣，也不值得浪费时间精确计算。
- en: We won’t use precise notation for asymptotic complexity (which says which parts
    of speed calculations you can safely ignore), but we will make rough estimates
    of the number of operations that an algorithm will go through. There’s no need
    to get too hung up on precision since computer scientists are comfortable with
    a simple characterisation that gives a ballpark indication of speed.
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会使用精确的渐近复杂度符号（它说你可以安全忽略哪些速度计算的部分），但我们会粗略估计算法将经历的操作数量。不需要过于纠结于精确性，因为计算机科学家习惯于简单的表征，给出速度的大致指示。
- en: For example, consider using selection sort to put a list of *n* values into
    increasing order. (This is explained in the chapter on algorithms). Suppose someone
    tells you that it takes 30 seconds to sort a thousand items. Does that sounds
    like a good algorithm? For a start, you’d probably want to know what sort of computer
    it was running on - if it’s a supercomputer then that’s not so good; if it’s a
    tiny low-power device like a smartphone then maybe it’s ok.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑使用选择排序将一组*n*个值按升序排列。（这在算法章节中有解释）。假设有人告诉你，排序一千个项目需要30秒。这听起来像是一个好算法吗？首先，你可能想知道它运行在什么样的计算机上
    - 如果是超级计算机那就不太好；如果是像智能手机这样的微型低功耗设备，那也许还可以。
- en: Also, a single data point doesn’t tell you how well the system will work with
    larger problems. If the selection sort algorithm above was given 10 thousand items
    to sort, it would probably take about 50 minutes (3000 seconds) — that’s 100 times
    as long to process 10 times as much input.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，单个数据点并不能告诉你系统在处理更大问题时的效果如何。如果上面的选择排序算法要排序一万个项目，那可能需要大约50分钟（3000秒） - 这是处理输入增加了十倍所需时间的100倍。
- en: 'These data points for a particular computer are useful for getting an idea
    of the performance (that is, complexity) of the algorithm, but they don’t give
    a clear picture. It turns out that we can work out exactly how many steps the
    selection sort algorithm will take for *n* items: it will require about n(n-1)/2
    operations, or in expanded form,n2/2 - n/2 operations. This formula applies regardless
    of the kind of computer its running on, and while it doesn’t tell us the time
    that will be taken, it can help us to work out if it’s going to be reasonable.'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定计算机的这些数据点对于了解算法的性能（即复杂性）是有用的，但它们并不能给出一个清晰的图景。事实证明，我们可以准确地计算出选择排序算法对*n*个项目需要多少步骤：它将需要大约n(n-1)/2个操作，或者展开形式为n2/2
    - n/2个操作。这个公式适用于计算机的类型，虽然它不告诉我们需要多少时间，但它可以帮助我们判断是否合理。
- en: 'From the above formula we can see why it gets bad for large values of *n* :
    the number of steps taken increases with the square of the size of the input.
    Putting in a value of 1 thousand for *n* tells us that it will use 1,000,000/2
    - 1,000/2 steps, which is 499,500 steps.'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的公式中我们可以看出为什么在*n*的大值上会变得糟糕：所需的步骤数随着输入大小的平方增加。为*n*输入值放入1千告诉我们它将使用1,000,000/2
    - 1,000/2个步骤，即499,500个步骤。
- en: Notice that the second part (1000/2) makes little difference to the calculation.
    If we just use the n2/2 part of the formula, the estimate will be out by 0.1%,
    and quite frankly, the user won’t notice if it takes 20 seconds or 19.98 seconds.
    That’s the point of asymptotic complexity — we only need to focus on the most
    significant part of the formula, which contains n2.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第二部分（1000/2）对计算几乎没有影响。如果我们只使用公式的n2/2部分，估计将偏离0.1%，而且坦率地说，用户不会注意到它需要20秒还是19.98秒。这就是渐近复杂度的要点
    - 我们只需要关注公式中最重要的部分，其中包含n2。
- en: Also, since measuring the number of steps is independent of the computer it
    will run on, it doesn’t really matter if it’s described as n2/2 or n2\. The amount
    of time it takes will be proportional to both of these formulas, so we might as
    well simplify it to n2\. This is only a rough characterisation of the selection
    sort algorithm, but it tells us a lot about it, and this level of accuracy is
    widely used to quickly but fairly accurately characterise the complexity of an
    algorithm. In this chapter we’ll be using similar crude characterisations because
    they are usually enough to know if an algorithm is likely to finish in a reasonable
    time or not.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，由于测量步骤数与将要运行的计算机无关，因此它是否描述为n2/2或n2并不重要。所花费的时间将与这两个公式成比例，所以我们可以简化为n2。这只是对选择排序算法的粗略描述，但它告诉了我们很多信息，而且这种精度水平被广泛用于快速但相当准确地描述算法的复杂性。在本章中，我们将使用类似的粗糙描述，因为它们通常足以判断算法是否可能在合理的时间内完成。
- en: If you’ve studied algorithms, you will have learnt that some sorting algorithms,
    such as mergesort and quicksort, are inherently faster than other algorithms,
    such as insertion sort, selection sort, or bubble sort. It’s obviously better
    to use the faster ones. The first two have a complexity of n log(n) time (that
    is, the number of steps that they take is roughly proportional to n log(n)), whereas
    the last three have complexity of n2\. Generally the consequence of using the
    wrong sorting algorithm will be that a user has to wait many minutes (or perhaps
    hours) rather than a few seconds or minutes.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你学过算法，你会知道一些排序算法，比如归并排序和快速排序，本质上比其他算法，比如插入排序、选择排序或冒泡排序更快。显然最好使用更快的算法。前两种的复杂度是
    n log(n) 时间（也就是说，它们所需的步骤数量大致与 n log(n) 成比例），而后三种的复杂度是 n2。通常使用错误的排序算法的后果是用户必须等待很多分钟（或者也许几个小时）而不是几秒钟或几分钟。
- en: Here we’re going to consider another possible sorting algorithm, called *permutation
    sort*. Permutation sort says “Let’s list all the possible orderings (“permutations”)
    of the values to be sorted, and check each one to see if it is sorted, until the
    sorted order is found”. This algorithm is straightforward to describe, but is
    it any good?
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将考虑另一种可能的排序算法，称为*排列排序*。排列排序说：“让我们列出要排序的值的所有可能排序（“排列”），并检查每一个是否已排序，直到找到排序顺序”。这个算法很容易描述，但它好吗？
- en: 'For example, if you are sorting the numbers 45, 21 and 84, then every possible
    order they can be put in (that is, all permutations) would be listed as:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你要排序数字 45, 21 和 84，那么它们可以被放置的每种可能顺序（即所有排列）将被列出为：
- en: 45, 21, 84
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 45, 21, 84
- en: 45, 84, 21
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 45, 84, 21
- en: 21, 45, 84
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 21, 45, 84
- en: 21, 84, 45
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 21, 84, 45
- en: 84, 21, 45
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 84, 21, 45
- en: 84, 45, 21
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 84, 45, 21
- en: Going through the above list, the only line that is in order is 21, 45, 84,
    so that’s the solution. It’s a very inefficient approach, but it will help to
    illustrate what we mean by tractability.
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上面的列表，唯一按顺序排列的是 21, 45, 84，所以这就是解决方案。这是一种非常低效的方法，但它将帮助说明我们所说的可处理性。
- en: In order to understand how this works, and the implications, choose four different
    words (in the example below we have used colours) and list all the possible orderings
    of the four words. Each word should appear exactly once in each ordering. You
    can either do this yourself, or use an online permutation generator such as[JavaScriptPermutations](http://users.telenet.be/vdmoortel/dirk/Maths/permutations.html) or [Text
    Mechanic](http://textmechanic.com/Permutation-Generator.html).
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这是如何工作的，以及其含义，选择四个不同的单词（在下面的示例中我们使用了颜色）并列出这四个单词的所有可能排序。每个单词在每个排序中应该只出现一次。你可以自己做，也可以使用在线排列生成器，比如[JavaScriptPermutations](http://users.telenet.be/vdmoortel/dirk/Maths/permutations.html)或[Text
    Mechanic](http://textmechanic.com/Permutation-Generator.html)。
- en: 'For example if you’d picked red, blue, green, and yellow, the first few orderings
    could be:'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你选择了红色、蓝色、绿色和黄色，前几个排序可能是：
- en: red, blue, green, yellow
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 红色，蓝色，绿色，黄色
- en: red, blue, yellow, green
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 红色，蓝色，黄色，绿色
- en: red, yellow, blue, green
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 红色，黄色，蓝色，绿色
- en: red, yellow, green, blue
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 红色，黄色，绿色，蓝色
- en: They do not need to be in any particular order, although a systematic approach
    is recommended to ensure you don’t forget any!
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不需要按任何特定顺序排列，尽管建议采用系统化方法以确保不遗漏任何一个！
- en: Once your list of permutations is complete, search down the list for the one
    that has the words sorted in alphabetical order. The process you have just completed
    is using permutation sort to sort the words.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的排列列表完成，沿着列表搜索那个按字母顺序排序的。你刚刚完成的过程是使用排列排序来排序单词。
- en: Now add another word. How many possible orderings will there be with 5 words?
    What about with only 2 and 3 words — how many orderings are there for those? If
    you gave up on writing out all the orderings with 5 words, can you now figure
    out how many there might be? Can you find a pattern? How many do you think there
    might be for 10 words? (You don’t have to write them all out!).
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再添加一个单词。有 5 个单词时会有多少种可能的排序？对于只有 2 个和 3 个单词，会有多少种排序？如果你放弃了写出所有 5 个单词的排序，现在能想出可能有多少种吗？你能找到一个模式吗？你认为
    10 个单词可能有多少种排序？（你不必全部写出！）
- en: If you didn’t find the pattern for the number of orderings, think about using
    factorials. For 3 words, there are 3! (“3 factorial”) orderings. For 5 words,
    there are 5! orderings. Check the jargon buster below if you don’t know what a
    “factorial” is, or if you have forgotten!
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您找不到排序数量的模式，请考虑使用阶乘。对于3个单词，有3！（“3的阶乘”）个排序。对于5个单词，有5！个排序。如果您不知道“阶乘”是什么，或者如果您忘记了，请查看下面的术语解释！
- en: '**Jargon Buster**'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: '**术语解释**'
- en: 'Factorials are very easy to calculate; just multiply together all the integers
    from the number down to 1\. For example, to calculate 5! you would simply multiply:
    5 x 4 x 3 x 2 x 1 = 120\. For 8! you would simply multiply 8 x 7 x 6 x 5 x 4 x
    3 x 2 x 1 = 40,320.'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘计算非常简单；只需将从该数字到1的所有整数相乘即可。例如，要计算5！，您只需乘以：5 x 4 x 3 x 2 x 1 = 120。对于8！，您只需乘以8
    x 7 x 6 x 5 x 4 x 3 x 2 x 1 = 40,320。
- en: As stated above, the factorial of a number tells you how many permutations (orderings)
    there would be for that number of words (assuming they are all different). This
    means that if you are arranging 8 words, there will be 40,320 ways of arranging
    them (which is why you weren’t asked to try this in the first exercise!!)
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，一个数字的阶乘告诉您有多少个排列（排序）可能性（假设它们都不同）。这意味着如果您正在安排8个单词，将有40,320种排列方式（这就是为什么您在第一个练习中没有被要求尝试这样做的原因！）
- en: Your calculator may have a ”!” button for calculating factorials and spreadsheets
    usually have a “FACT” function, although for the factorials under 10 in this section,
    we recommend that you calculate them the long way, and then use the calculator
    as a double check. Ensuring you understand how a factorial is calculated is essential
    for understanding the rest of this section!
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 您的计算器可能有一个“！”按钮用于计算阶乘，而电子表格通常具有“FACT”函数，尽管在本节中阶乘小于10的情况下，我们建议您按照传统方法计算它们，然后使用计算器进行双重检查。确保您理解如何计算阶乘对于理解本节的其余部分至关重要！
- en: For factorials of larger numbers, most desktop calculators won’t work so well;
    for example, 100! has 158 digits. You can use the calculator below to work with
    huge numbers (especially when using factorials and exponents).
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较大数字的阶乘，大多数桌面计算器效果不佳；例如，100！有158位数字。您可以使用下面的计算器来处理大数（尤其是在使用阶乘和指数时）。
- en: '[![](563ad96e90e82.png)Click to load'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad96e90e82.png)点击加载'
- en: big number calculator](http://csfieldguide.org.nz/_static/widgets/big-calculator.html?plain=true%20frameborder=)
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 大数计算器](http://csfieldguide.org.nz/_static/widgets/big-calculator.html?plain=true%20frameborder=)
- en: Try calculating 100! using this calculator — that’s the number of different
    routes that a travelling salesman might take to visit 100 places (not counting
    the starting place). With this calculator you can copy and paste the result back
    into the input if you want to do further calculations on the number. If you are
    doing these calculations for a report, you should also copy each step of the calculation
    into your report to show how you got the result.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用此计算器计算100！- 这是旅行推销员可能选择访问100个地方的不同路线的数量（不包括起始地点）。使用此计算器，您可以复制并粘贴结果回输入框，以便进行进一步的计算。如果您正在为报告进行这些计算，还应将每个计算步骤复制到报告中，以显示您是如何得出结果的。
- en: There are other big number calculators available online; for example, the [Big
    Integer Calculator](http://www.javascripter.net/math/calculators/100digitbigintcalculator.htm).
    Other big calculators are available online, or you could look for one to download
    for a desktop machine or smartphone.
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 在线提供其他大数计算器；例如，[大整数计算器](http://www.javascripter.net/math/calculators/100digitbigintcalculator.htm)。其他大型计算器可在网上找到，或者您可以寻找一个用于桌面机或智能手机的下载版本。
- en: As a final exercise on permutation sort, calculate how long a computer would
    take to use permutation sort to sort 100 numbers. Remember that you can use the
    calculator that was linked to above. Assume that you don’t have to worry about
    how long it will take to generate the permutations, only how long it will take
    to check them. Assume that you have a computer that creates and checks an ordering
    every nanosecond.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 作为排列排序的最后一个练习，请计算计算机使用排列排序对100个数字进行排序需要多长时间。请记住，您可以使用上面链接的计算器。假设您不必担心生成排列需要多长时间，只需检查它们需要多长时间。假设您有一台每纳秒创建和检查一个排序的计算机。
- en: How many orderings need to be checked for sorting 100 numbers?
  id: totrans-1413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序100个数字需要检查多少种排列？
- en: How many orderings can be checked in a second?
  id: totrans-1414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一秒钟内可以检查多少种排列？
- en: How many orderings can be checked in a year?
  id: totrans-1415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一年内可以检查多少种排列？
- en: How many years will checking all the orderings take?
  id: totrans-1416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查所有排序需要多少年？
- en: 'And as an interesting thing to think about, do some calculations based on the
    assumptions listed below. How long would it take to use permutation sort on 100
    numbers? What would happen first: the algorithm would finish, or the universe
    would end?'
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个有趣的思考问题，根据下面列出的假设进行一些计算。使用置换排序对100个数字排序需要多长时间？算法会先完成，还是宇宙会先终结？
- en: There are 1082 atoms in the universe
  id: totrans-1418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宇宙中有1082个原子。
- en: The universe has another 14 billion years before it ends
  id: totrans-1419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在宇宙结束之前还有140亿年。
- en: Suppose every atom in the universe is a computer that can check an ordering
    every nanosecond
  id: totrans-1420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设宇宙中的每个原子都是一个可以每纳秒检查一个排序的计算机。
- en: By now, you should be very aware of the point that is being made. Permutation
    sort is so inefficient that sorting 100 numbers with it takes so long that it
    is essentially impossible. Trying to use permutation sort with a non trivial number
    of values simply won’t work. While selection sort is a lot slower than quick sort
    or merge sort, it wouldn’t be impossible for Facebook to use selection sort to
    sort their list of 1 billion users. It would take a lot longer than quick sort
    would, but it would be doable. Permutation sort on the other hand would be impossible
    to use!
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经非常清楚正在传达的观点。置换排序是如此低效，以至于用它对100个数字进行排序需要的时间是非常长的，以至于基本上是不可能的。试图用置换排序处理非常多的值根本行不通。虽然选择排序比快速排序或归并排序慢得多，但Facebook使用选择排序对其10亿用户列表进行排序不会是不可能的。它会比快速排序慢得多，但是可以做到。另一方面，使用置换排序将是不可能的！
- en: At this point, we need to now distinguish between algorithms that are essentially
    usable, and algorithms that will take billions of year to finish running, even
    with a small input such as 100 values.
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们现在需要区分基本可用的算法和即使在一个小的输入（如100个值）上运行也需要数十亿年才能完成的算法。
- en: Computer Scientists call an algorithm “intractable” if it would take a completely
    unreasonable amount of time to run on reasonably sized inputs. Permutation sort
    is a good example of an intractable algorithm. The term “intractable” is used
    a bit more formally in computer science; it’s explained in the next section.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家们称算法为“无法解决的”，如果它在合理大小的输入上运行需要完全不合理的时间。置换排序是一个无法解决的算法的好例子。术语“无法解决的”在计算机科学中使用得更加正式；在下一节中会解释。
- en: 'But the *problem* of sorting items into order is not intractable - even though
    the Permutation sort algorithm is intractable, there are lots of other efficient
    and not-so-efficient algorithms that you could use to solve a sorting problem
    in a reasonable amount of time: quick sort, merge sort, selection sort, even bubble
    sort! However, there are some problems in which the ONLY known algorithm is one
    of these intractable ones. Problems in this category are known as *intractable
    problems*.'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 但是将项目排序的*问题*并非是无法解决的 - 即使置换排序算法是无法解决的，也有许多其他有效和不那么有效的算法可以用来在合理的时间内解决排序问题：快速排序、归并排序、选择排序，甚至是冒泡排序！然而，有些问题的唯一已知算法是这些无法解决的算法之一。这一类问题被称为*无法解决的问题*。
- en: '**Curiosity : Towers of Hanoi**'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: '**好奇心：汉诺塔**'
- en: The Towers of Hanoi problem is a challenge where you have a stack of disks of
    increasing size on one peg, and two empty pegs. The challenge is to move all the
    disks from one peg to another, but you may not put a larger disk on top of a smaller
    one. There’s a description of it at [Wikipedia](http://en.wikipedia.org/wiki/Tower_of_Hanoi).
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 汉诺塔问题是一种挑战，其中一个柱子上有一叠逐渐增大的圆盘，而另外两个柱子为空。挑战是将所有圆盘从一个柱子移到另一个柱子，但是你不能把一个较大的圆盘放在一个较小的圆盘上面。在[Wikipedia](http://en.wikipedia.org/wiki/Tower_of_Hanoi)上有关于它的描述。
- en: This problem cannot be solved in fewer than 2n-1 moves, so it’s an intractable
    problem (a computer program that lists all the moves to make would use at least
    2n - 1 steps). For 6 disks it only needs 63 moves, but for 50 disks this would
    be 1,125,899,906,842,623 moves.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题不能在少于2n-1步中解决，因此它是一个无法解决的问题（一个列出所有步骤的计算机程序至少需要2n-1步）。对于6个圆盘，只需要63步，但对于50个圆盘来说，这将是1,125,899,906,842,623步。
- en: We usually characterise a problem like this as having a complexity of 2n, as
    subtracting one to get a precise value makes almost no difference, and the shorter
    expression is simpler to communicate to others.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将这样的问题描述为具有2n的复杂度，因为减去一个以获得精确值几乎没有影响，并且更短的表达方式更简单地传达给他人。
- en: The Towers of Hanoi is one problem where we know for sure that it will take
    exponential time. There are many intractable problems where this isn’t the case
    — we don’t have tractable solutions for them, but we don’t know for sure if they
    don’t exist. Plus this isn’t a real problem — it’s just a game (although there
    is a backup system based on it). But it is a nice example of an exponential time
    algorithm, where adding one disk will double the number of steps required to produce
    a solution.
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 汉诺塔问题是一个我们确定需要指数时间解决的问题。有许多棘手的问题并非如此——我们没有它们的可解决方案，但我们不确定是否不存在。此外，这并不是一个真正的问题——它只是一个游戏（尽管基于它有一个备用系统）。但它是指数时间算法的一个很好的例子，添加一个盘子将使得产生解决方案所需的步骤数量加倍。
- en: 11.3\. TRACTABILITY
  id: totrans-1430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3\. 可解性
- en: There’s a very simple rule that computer scientists use to decide if an algorithm
    is tractable or not, based on the complexity (estimated number of steps) of the
    algorithm. Essentially, if the algorithm takes an exponential amount of time or
    worse for an input of size *n*, it is labelled as intractable. This simple rule
    is a bit crude, but it’s widely used and provides useful guidance. (Note that
    a factorial amount of time, *n!*, is intractable because it’s bigger than an exponential
    function.)
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家用一个非常简单的规则来判断算法是否可解，该规则基于算法的复杂性（估计的步骤数量）。基本上，如果算法对于大小为 n 的输入需要指数级时间或更多时间，那么它被标记为不可解。这个简单规则有点粗糙，但它被广泛使用并提供了有用的指导。（请注意，阶乘数量的时间，n！，不可解，因为它比指数函数更大。）
- en: To see what this means, let’s consider how long various algorithms might take
    to run. The following interactive will do the calculations for you to estimate
    how long an algorithm might take to run. You can choose if the running time is
    exponential (that is, 2n, which is the time required for the Towers of Hanoi problem
    with *n*disks), or factorial (that is, n!, which is the time required for checking
    all possible routes a travelling salesman would make to visit *n* places other
    than the starting point). You can use the interactive below to calculate the time.
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看清楚这意味着什么，让我们考虑各种算法可能运行的时间。以下交互式将为您进行计算，估算算法可能运行的时间。您可以选择运行时间是否是指数级（即，2n，这是解决汉诺塔问题所需的时间，有
    n 个盘子），或者是阶乘级（即，n！，这是检查旅行推销员除了起点之外访问 n 个地方所有可能路线所需的时间）。您可以使用下面的交互式计算时间。
- en: For example, try choosing the factorial time for the TSP, and put in 20 for
    the value of *n* (i.e. this is to check all possible travelling salesman visits
    to 20 places). Press the return or tab key to update the calculation. The calculator
    will show a large number of seconds that the program will take to run; you can
    change the units to years to see how long this would be.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尝试为 TSP 选择阶乘时间，并将 n 的值设为 20（即，这是为了检查旅行推销员访问 20 个地方的所有可能路线）。按回车或制表键以更新计算。计算器将显示程序运行所需的大量秒数；您可以将单位更改为年来查看其持续时间。
- en: '[![](563ad96e245ff.png)Click to load'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad96e245ff.png)点击加载'
- en: big number calculator](http://csfieldguide.org.nz/_static/widgets/tract-scaling-v2.html)
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: '[大数计算器](http://csfieldguide.org.nz/_static/widgets/tract-scaling-v2.html)'
- en: So far the calculation assumes that the computer would only do 1 operation per
    second; try changing to a million (1,000,000) operations per second, which is
    more realistic, and see how long that would take.
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，计算假设计算机每秒只执行 1 次操作；尝试将其更改为一百万（1,000,000）次操作每秒，这更真实，看看那需要多长时间。
- en: Another way to solve problems faster is to have multiple processors work on
    different solutions at the same time. If you were to buy 1,000 processors (e.g.
    1,000 computers, or 250 4-core computers) and have each one test out different
    routes, then the solution could be found 1,000 times faster. Try changing the
    number of processors to 1,000, and see how long that would take (you may need
    to change the units back — is it seconds? hours? days?)
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题更快的另一种方法是让多个处理器同时处理不同的解决方案。如果您购买了 1,000 个处理器（例如 1,000 台计算机或 250 台 4 核计算机）并让每个处理器测试不同的路线，那么解决方案将找到
    1,000 倍快。尝试将处理器数量更改为 1,000，看看需要多长时间（您可能需要将单位更改回来——是秒？小时？天？）
- en: The interactive above estimates the amount of time taken for various algorithms
    to run given *n* values to be processed. Let’s assume that we have a *very* fast
    computer, faster than any that exist. Try putting in the assumption that the computer
    can do a million million (1,000,000,000,000) steps per second. Is that achievable?
    But what if you add just two more locations to the problem (i.e. n=22 instead
    of n=20)?
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的交互式估计了各种算法在给定要处理的*n*值时运行的时间量。让我们假设我们有一台非常快的计算机，比任何现有的都快。试试假设计算机每秒可以执行一百万亿（1,000,000,000,000）步骤。这是可行的吗？但是如果你将问题的位置增加两个（即n=22而不是n=20）呢？
- en: Now, consider an algorithm that has a complexity of n2 (there are lots that
    take roughly this number of steps, including selection sort which was mentioned
    earlier). Type in a value of 1,000,000 for *n* to see how long it might take to
    sort a million items on a single processor (keep the number of steps per second
    at 1,000,000,000,000, but set the number of processors to just 1) — it should
    show that it will only take about 1 second on our hypothetical very fast machine.
    Now put in 10 million for *n* — although it’s sorting a list 10 times as big,
    it takes more than 10 times as long, and will now take a matter of minutes rather
    than seconds. At what value of *n* does the amount of time become out of the question
    — that is, how large would the problem need to be for it to take years to finish?
    Is anyone ever likely to be sorting this many values — for example, what if for
    some reason you were sorting the name of every person in the world, or every base
    in the human genome?
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑一个时间复杂度为n²的算法（有很多算法大致需要这么多步骤，包括前面提到的选择排序）。键入一个值为1,000,000的*n*，看看在单个处理器上对一百万个项目进行排序需要多长时间（保持每秒步骤数为1,000,000,000,000，但将处理器数设置为1）——它应该显示在我们假设的非常快的机器上只需要大约1秒钟。现在为*n*放入10,000,000——尽管它在排序一个大小为10倍的列表，但花费的时间不止是10倍长，现在需要几分钟而不是几秒钟。在*n*的什么值上，时间量会变得难以接受——也就是说，问题需要有多大才能花费数年的时间完成？有人会真的排序这么多值吗——例如，如果出于某种原因你要对世界上每个人的名字进行排序，或者对人类基因组中的每个碱基进行排序呢？
- en: What about an algorithm with complexity of n3? What’s the largest size input
    that it can process in a reasonable amount of time?
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 对于时间复杂度为n³的算法呢？它能在合理的时间内处理的最大输入大小是多少？
- en: Now try the same when the number of steps is 2n, but start with a value of 10
    for *n* , then try 30, 40 , 50 and so on. You’ll probably find that for an input
    of about 70 items it will take an unreasonable amount of time. Is it much worse
    for 80 items?
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试相同的步骤数为2n，但*n*的值从10开始，然后尝试30、40、50等等。你可能会发现，对于约70个项目的输入，需要的时间是不合理的。对于80个项目来说，情况是否会更糟？
- en: Now try increasing the number of operations per second to 10 times as many.
    Does this help to solve bigger problems?
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试将每秒的操作次数增加到10倍。这有助于解决更大的问题吗？
- en: Trying out these figures you will likely have encountered the barrier between
    “tractable” and “intractable” problems. Algorithms that take n2, n3 or even n4 time
    to solve a problem (such as sorting a list) aren’t amazing, but at least with
    a fast enough computer and for the size of inputs we might reasonably encounter,
    we have a chance of running them within a human lifetime, and these are regarded
    as *tractable* . However, for algorithms that take 2n, 3n or more steps, the amount
    of time taken can end up as billions of years even for fairly small problems,
    and using computers that are thousand times faster still doesn’t help to solve
    much bigger problems. Such problems are regarded as *intractable* . Mathematically,
    the boundary between tractable and intractable is between a polynomial number
    of steps (polynomials are formulas made up of n2, n3, n4 and so on), and an exponential
    number of steps (2n, 3n, 4n, and so on).
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些数字，你可能已经遇到了“可解”和“不可解”问题之间的障碍。需要n²、n³甚至n⁴时间来解决问题（例如对列表进行排序）的算法并不是太好，但至少对于足够快的计算机和我们可能会遇到的输入大小，我们有机会在人类一生内运行它们，这些被视为*可解*的。然而，对于需要2ⁿ、3ⁿ甚至更多步骤的算法，即使对于相当小的问题，花费的时间也可能达到数十亿年，即使使用速度快一千倍的计算机也无法解决更大的问题。这样的问题被视为*不可解*的。从数学上讲，可解和不可解之间的界限在于多项式步骤（多项式是由n²、n³、n⁴等组成的公式）和指数步骤（2ⁿ、3ⁿ、4ⁿ等）之间。
- en: The two formulas n2 and 2n look very similar, but they are really massively
    different, and can mean a difference between a few seconds and many millennia
    for the program to finish. The whole point of this chapter is to develop an awareness
    that there are many problems that we have tractable algorithms for, but there
    are also many that we haven’t found any tractable algorithms for. It’s very important
    to know about these, since it will be futile to try to write programs that are
    intractable, unless you are only going to be processing very small problems.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 两个公式n2和2n看起来非常相似，但它们实际上差异巨大，可能意味着程序完成的时间从几秒到许多千年的差距。本章的整个重点是要意识到我们有许多已知可解算法的问题，但也有许多我们尚未找到可解算法的问题。了解这些问题非常重要，因为编写难以解决的程序将是徒劳的，除非你只处理非常小的问题。
- en: Note that algorithms that take a factorial amount of time (n!, or 1 \times 2
    \times 3 \times \ldots n) are in the intractable category (in fact, they take
    times that are a lot worse than 2n).
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，需要阶乘时间（n！，或1 \times 2 \times 3 \times \ldots n）的算法属于难以解决的范畴（事实上，它们所需的时间远远超过2n）。
- en: Essentially any algorithm that tries out all combinations of the input will
    inevitably be intractable because the number of combinations is likely to be exponential
    or factorial. Thus an important point is that it’s usually not going to work to
    design a system that just tries out all possible solutions to see which is the
    best.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，任何尝试尝试所有输入组合的算法都将不可避免地难以解决，因为组合数量可能是指数级或阶乘。因此，一个重要的观点是，通常设计一个系统，仅尝试所有可能的解决方案以找到最佳解决方案是行不通的。
- en: Although we’ve provided n6 as an example of a tractable time, nearly all algorithms
    you’re likely to encounter will be n3 and better, or 2n and worse — only very
    specialised ones fall in the gap between those. So there’s a big gulf between
    tractable and intractable problems, and trying to grapple with it is one of the
    biggest problems in computer science!
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们提供了n6作为可解时间的示例，但你可能会遇到的几乎所有算法都是n3和更好的，或者是2n和更差的 —— 只有很少专业化的算法属于这之间的差距。因此，在可解和难以解决的问题之间存在很大的鸿沟，试图解决它是计算机科学中最大的问题之一！
- en: What about Moore’s law, which says that computing power is increasing exponentially?
    Perhaps that means that if we wait a while, computers will be able to solve problems
    that are currently intractable? Unfortunately this argument is wrong; intractable
    problems are also exponential, and so the rate of improvement due to Moore’s law
    means that it will only allow for slightly larger intractable problems to be solved.
    For example, if computing speed is doubling every 18 months (an optimistic view
    of Moore’s law), and we have an intractable problem that takes 2n operations to
    solve (many take longer than this), then in 18 months we will be able to solve
    a problem that’s just one item bigger. For example, if you can solve an exponential
    time problem for 50 items (50 countries on a map to colour, 50 cities for a salesman
    to tour, or 50 rings on a Towers of Hanoi problem) in 24 hours, then in 18 months
    you can expect to buy a computer that could solve it for 51 items at best! And
    in 20 years you’re likely to be able to get a computer that could solve for 55
    items in one day. You’re going to have to be more than patient if you want Moore’s
    law to help out here — you have to be prepared to wait for decades for a small
    improvement!
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 那么摩尔定律呢？它说计算能力呈指数增长？也许这意味着如果我们等一段时间，计算机就能解决目前难以解决的问题？不幸的是，这个论点是错误的；难以解决的问题也是指数级的，所以由于摩尔定律带来的改进速度只能让稍微大一点的难以解决的问题得到解决。例如，如果计算速度每18个月翻倍一次（摩尔定律的乐观看法），而我们有一个需要2n次操作才能解决的难以解决的问题（许多问题需要更长的时间），那么在18个月内我们将能够解决一个大一点的问题。例如，如果你可以在24小时内为50个项目（地图上的50个国家着色，推销员要游览的50个城市，或者汉诺塔问题中的50个环）解决指数级的时间问题，那么在18个月内你可以期望购买一台能够在最好的情况下为51个项目解决问题的计算机！而在20年内，你可能能够获得一台能够在一天内为55个项目解决问题的计算机。如果你希望摩尔定律能够帮助解决这个问题，那么你必须耐心等待几十年的时间！
- en: 'Remember that if you need to do calculations of huge numbers, there’s a calculator
    here that you can use:'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你需要计算大数，这里有一个你可以使用的计算器：
- en: '[![](563ad96d9b972.png)Click to load'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](563ad96d9b972.png)点击加载'
- en: big number calculator](http://csfieldguide.org.nz/_static/widgets/big-calculator.html?plain=true%20frameborder=)
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: '[大数计算器](http://csfieldguide.org.nz/_static/widgets/big-calculator.html?plain=true%20frameborder=)'
- en: 11.4\. THE TRAVELLING SALESMAN PROBLEM
  id: totrans-1452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4\. 旅行推销员问题
- en: An example of an intractable problem is the Travelling Salesman Problem (TSP).
    The TSP involves a bunch of locations (cities, houses, airports,....) where you
    can travel between any possible pair of locations. The goal is to find the shortest
    route that will go through all the locations once — this is what the interactive
    at the start of this chapter does.
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不可解决问题的例子是旅行推销员问题（TSP）。TSP涉及到一堆地点（城市，房屋，机场，...）你可以在这些地点之间旅行。目标是找到一条通过所有地点的最短路径，这就是本章开始处的互动所做的事情。
- en: Researchers have spent a lot of time trying to find efficient solutions to the
    Travelling Salesman Problem, yet have been unable to find a *tractable* algorithm
    for solving it. As you learnt in the previous section, *intractable* algorithms
    are very slow, to the point of being impossible to use. As the only solutions
    to TSP are intractable, TSP is known as an *intractable problem*.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员花了很多时间尝试找到旅行推销员问题的高效解决方案，但未能找到一个可行的算法来解决它。正如您在前一节中学到的，不可解决的算法非常慢，甚至不可能使用。由于TSP的唯一解决方案是不可解决的，因此TSP被称为不可解决的问题。
- en: It hasn’t actually been *proven* that there is no tractable solution to TSP,
    although many of the world’s top computer scientists have worked on this problem
    for the last 40 years, trying to find a solution but without success. What they
    have managed to do is find thousands of other problems that are also intractable,
    and more importantly, if a solution is found for any one of these problems, we
    know how to convert it to a solution for any of the others (these are called NP-complete
    problems). They all stand and fall together, including the TSP problem. So it’s
    not just being lazy if you give up on finding an optimal TSP algorithm — people
    have tried for decades and not found a tractable algorithm. Of course, this is
    also a strong motivator to try to find one — if you do, you will have solved thousands
    of other problems at the same time! This is a great thing for a researcher to
    do, but if you have a program to get finished by the end of the month, it’s not
    a good bet to work on it.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上并没有被证明TSP没有可行的解决方案，尽管世界上许多顶级计算机科学家在过去的40年中一直致力于解决这个问题，但没有成功。他们设法找到了成千上万其他同样不可解决的问题，更重要的是，如果为任何一个问题找到了解决方案，我们知道如何将其转换为其他任何问题的解决方案（这些被称为NP完全问题）。他们一起站着和倒下，包括TSP问题。因此，如果你放弃寻找最优TSP算法，这并不仅仅是懒惰——人们已经尝试了几十年，没有找到可行的算法。当然，这也是一个强有力的动力，试图找到一个——如果你找到了，你将同时解决成千上万其他问题！这对于一个研究人员来说是一件很好的事情，但如果你有一个计划在月底完成的程序，那么这不是一个好的赌注去做。
- en: Current algorithms for finding the optimal TSP solution aren’t a lot better
    than simply trying out all possible paths through the map (as in the interactive
    at the start of this chapter). The number of possible paths gets out of hand;
    it’s an intractable approach. In the project below you’ll be estimating how long
    it would take.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 目前寻找最优TSP解决方案的算法并不比简单地尝试地图上所有可能路径（就像本章开始的互动一样）好多少。可能路径的数量变得无法控制；这是一种不可解决的方法。在下面的项目中，您将估计需要多长时间。
- en: While TSP was originally identified as being the problem that sales people face
    when driving to several different locations and wanting to visit them in the order
    that leads to the shortest route (less petrol usage), the same problem applies
    to many other situations as well. Courier and delivery companies have variants
    of this problem — often with extra constraints such as limits on how long a driver
    can work for, or allowing for left hand turns being faster than right-hand ones
    (in NZ at least!)
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管TSP最初被确定为销售人员在驾驶到不同地点并希望按照最短路线的顺序访问它们时面临的问题（使用更少的汽油），但同样的问题也适用于许多其他情况。快递和送货公司也有这个问题的变种——通常有额外的约束条件，例如驾驶员工作时间的限制，或者允许左转比右转更快（至少在新西兰是这样）！
- en: Since these problems are important for real companies, it is not reasonable
    to simply give up and say there is no solution. Instead, when confronted with
    an intractable problem, computer scientists look for algorithms that produce approximate
    solutions — solutions that are not perfectly correct or optimal, but are hopefully
    close enough to be useful. By relaxing the requirement that the solution has to
    be perfectly correct, it is often possible to come up with tractable algorithms
    that will find good enough solutions in a reasonable time. This kind of algorithm
    is called a *heuristic* - it uses rules of thumb to suggest good choices and build
    up a solution made of pretty good choices.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些问题对于真实的公司来说非常重要，简单放弃并说没有解决方案是不合理的。相反，当面对一个棘手的问题时，计算机科学家会寻找产生近似解决方案的算法——这些解决方案可能不是完全正确或最优的，但希望它们足够接近以至于有用。通过放宽解决方案必须完全正确的要求，通常可以提出可行的算法，在合理的时间内找到足够好的解决方案。这种算法被称为*启发式算法*——它使用经验法则来建议好的选择，并构建由相当好的选择组成的解决方案。
- en: A simple heuristic that often works OK is a *greedy* heuristic algorithm — an
    algorithm that just takes what looks like the best choice at each step. For example,
    for the TSP, a greedy heuristic algorithm might repeatedly take the route to the
    next closest city. This won’t always be the best choice, but it is very fast,
    and experience shows that it is typically no more than 25% worse than the optimal.
    There are more sophisticated ways of designing approximate algorithms that can
    do better than this (some can get within 3% of optimal for the TSP), but they
    take longer to run.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的启发式算法通常是可以的，它是一种*贪婪*启发式算法——一种只在每一步中选择看起来最好的选择的算法。例如，对于TSP，一个贪婪的启发式算法可能会反复选择通往下一个最近城市的路线。这并不总是最佳选择，但它非常快速，经验表明它通常不会比最优解差超过25%。设计近似算法的更复杂的方式可以做得更好（一些可以在TSP上达到最优的3%），但运行时间更长。
- en: There are software companies that work on trying to make better and better approximate
    algorithms for guiding vehicles by GPS for delivery routes. Companies that write
    better algorithms can charge a lot of money if their routes are faster, because
    of all the fuel and time savings that can be made.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些软件公司致力于开发越来越好的近似算法，用于通过GPS引导车辆进行交付路线。如果某公司编写了更好的算法，可以收取很多钱，因为其路线更快，可以节省燃料和时间。
- en: An interesting thing with intractability is that you can have two very similar
    problems, with one being intractable and the other being tractable. For example,
    finding the shortest route between two points (like a GPS device usually does)
    is a tractable problem, yet finding the shortest route around multiple points
    (the TSP) isn’t. By the way, finding the *longest* path between two points (without
    going along any route twice) is also intractable, even though finding the *shortest* path
    is tractable!
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 关于棘手性的一个有趣之处在于，你可以有两个非常相似的问题，一个是棘手的，另一个是可解的。例如，找到两点之间的最短路线（就像GPS设备通常所做的）是一个可解的问题，但找到穿过多个点的最短路线（TSP）却不是。顺便说一下，找到两点之间的*最长*路径（不沿任何路径两次）也是棘手的，尽管找到*最短*路径是可解的！
- en: '11.4.1\. PROJECT: THE CRAYPOTS PROBLEM'
  id: totrans-1462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.1\. 项目：CRAYPOTS问题
- en: You should present your findings for this project in a written report where
    you include your answers to the exercises, the maps you make, and written explanations
    to explain what you have found out and learnt.
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在一份书面报告中呈现你对这个项目的发现，包括你对练习的答案，你制作的地图，以及书面解释来解释你发现和学到了什么。
- en: This project is based around a scenario where there is a cray fisher who has
    around 18 craypots that have been laid out in open water. Each day the fisher
    uses a boat to go between the craypots and check each one for crayfish.
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目基于一个场景，其中有一位捕虾人在开放水域放置了大约18个捕虾笼。每天，这位捕虾人都会使用小船在捕虾笼之间穿行，并检查每一个捕虾笼里是否有龙虾。
- en: The cray fisher has started wondering what the shortest route to take to check
    all the craypots would be, and has asked you for your help. Because every few
    weeks the craypots need to be moved around, the fisher would prefer a general
    way of solving the problem, rather than a solution to a single layout of craypots.
    Therefore, your investigations must consider more than one possible layout of
    craypots, and the layouts investigated should have the craypots placed *randomly* i.e.
    not in lines, patterns, or geometric shapes.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: When asked to generate a random map of craypots, get a pile of coins (or counters)
    with however many craypots you need, and scatter them onto an A4 piece of paper.
    If any land on top of each other, place them beside one another so that they are
    touching but not overlapping. One by one, remove the coins, making a dot on the
    paper in the centre of where each coin was. Number each of the dots. Each dot
    represents one craypot that the cray fisher has to check. You should label the
    top left corner or the paper as being the boat dock, where the cray fisher stores
    the boat.
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: Generate a map with 7 or 8 craypots using the random map generation method described
    above. *Make an extra copy of this map, as you will need it again later.*
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: Using your intuition, find the shortest path between the craypots.
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: Now generate a map (same method as above) with somewhere between 15 and 25 craypots. *Make
    more than one copy of this map, as you will need it again later*
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: Now on this new map, try to use your intuition to find the shortest path between
    the craypots. Don’t spend more than 5 minutes on this task; you don’t need to
    include the solution in your report. Why was this task very challenging? Can you
    be sure you have an optimal solution?
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: Unless your locations were laid out in a circle or oval, you probably found
    it very challenging to find the shortest route. A computer would find it even
    harder, as you could at least take advantage of your visual search and intuition
    to make the task easier. A computer could only consider two locations at a time,
    whereas you can look at more than two. But even for you, the problem would have
    been challenging! Even if you measured the distance between each location and
    put lines between them and drew it on the map so that you didn’t have to judge
    distances between locations in your head, it’d still be very challenging for you
    to figure out!
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: A straightforward algorithm to guarantee that you find the shortest route is
    to check *all* possible routes. This involves working out what all the possible
    routes are, and then checking each one. A possible route can be written as a list
    of the locations (i.e. the numbers on the craypots), in the order to go between
    them. This should be starting to sound familiar to you assuming you did the permutation
    sort discussed above. Just like in that activity you listed all the possible ordering
    for the values in the list to be sorted, this algorithm would require listing
    all the possible orderings of the craypots, which is equivalent (although you
    don’t need to list all the orderings for this project!).
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: How many possible routes are there for the larger example you have generated?
    How is this related to permutation sort, and factorials? How long would it take
    to calculate the shortest route in your map, assuming the computer can check 1
    billion (1,000,000,000) possible routes per second? (i.e. it can check one route
    per nanosecond) What can you conclude about the cost of this algorithm? Would
    this be a good way for the cray fisher to decide which path to take?
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you show *all* your mathematical working in your answers to the above
    questions!
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: So this algorithm is intractable, but maybe there is a more clever algorithm
    that is tractable? The answer is No.
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to tell that this problem is equivalent to the TSP, and therefore
    it is intractable. How can you tell? What is the equivalent to a town in this
    scenario? What is the equivalent to a road?
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: Since we know that this craypot problem is an example of the TSP, and that there
    is no known tractable algorithm for the TSP, we know there is no tractable algorithm
    for the craypot problem either. Although there are slightly better algorithms
    than the one we used above, they are still intractable and with enough craypots,
    it would be impossible to work out a new route before the cray fisher has to move
    the pots again!
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: Instead of wasting time on trying to invent a clever algorithm that no-one has
    been able to find, we need to rely on a algorithm that will generate an approximate
    solution. The cray fisher would be happy with an approximate solution that is
    say, 10% longer more than the best possible route, but which the computer can
    find quickly.
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways of approaching this. Some are better than others in general,
    and some are better than others with certain layouts. One of the more obvious
    approximate algorithms, is to start from the boat dock in the top left corner
    of your map and to go to the nearest craypot. From there, you should go to the
    nearest craypot from that craypot, and repeatedly go to the nearest craypot that
    hasn’t yet been checked. This approach is known as a *greedy heuristic algorithm* as
    it always makes the decision that looks the best at the current time, rather than
    making a not so good decision now to try and get a bigger pay off later. You will
    understand why this doesn’t necessarily lead to the optimal solution after completing
    the following exercises.
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: On a copy of each of your 2 maps you generated, draw lines between the craypots
    to show the route you would find following the greedy algorithm (you should have
    made more than one copy of each of the maps!)
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: For your map with the smaller number of craypots (7 or 8), compare your optimal
    solution and your approximate solution. Are they the same? Or different? If they
    are the same, would they be the same in all cases? Show a map where they would
    be different (you can choose where to place the craypots yourself, just use as
    many craypots as you need to illustrate the point).
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: For your larger map, show why you don’t have an optimal solution. The best way
    of doing this is to show a route that is similar to, but shorter than the approximate
    solution. The shorter solution you find doesn’t have to be the optimal solution,
    it just has to be shorter than the one identified by the approximate algorithm
    (Talk to your teacher if you can’t find a shorter route and they will advise on
    whether or not you should generate a new map). You will need to show a map that
    has a greedy route and a shorter route marked on it. Explain the technique you
    used to show there was a shorter solution. Remember that it doesn’t matter how
    much shorter the new solution you identify is, just as long as it is at least
    slightly shorter than the approximate solution — you are just showing that the
    approximate solution couldn’t possibly be the optimal solution by showing that
    there is a shorter solution than the approximate solution.
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: Even though the greedy algorithm only generates an approximate solution, as
    opposed to the optimal solution, explain why is it more suitable for the cray
    fisher than generating an optimal solution would be?
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: Why would it be important to the cray fisher to find a short route between the
    craypots, as opposed to just visiting them in a random order? Discuss other problems
    that are equivalent to TSP that real world companies encounter every day. Why
    is it important to these companies to find good solutions to TSP? Estimate how
    much money might a courier company be wasting over a year if their delivery routes
    were 10% worse than the optimal. How many different locations/towns/etc might
    their TSP solutions have to be able to handle?
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: Find a craypot layout that will result in the greedy algorithm finding the shortest
    route. How do you know it is the shortest route? What is a general pattern that
    seem to work well for this greedy algorithm?
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: Find a craypot layout that results in the greedy algorithm finding what seem
    to be a really inefficient route. Why is it inefficient? Don’t worry about trying
    to find an actual worst case, just find a case that seems to be quite bad. What
    is a general pattern that seems to make this greedy algorithm inefficient?
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to include an introductory paragraph in your report that outlines
    the key ideas. It should include a brief description of what an intractable problem
    is, and how a computer scientist goes about dealing with such a problem. The report
    should also describe the Travelling Salesman Problem and the craypot problem in
    your own words. Explain why the craypot problem is a realistic problem that might
    matter to someone.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: 11.5\. OTHER INTRACTABLE PROBLEMS
  id: totrans-1488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are thousands of problems like the TSP for which no tractable solution
    is known. Extra sections will eventually be added here to introduce some of them,
    but in the meantime, if you are keen you might like to explore some of these problems:'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: '[map and graph colouring](http://csunplugged.org/graph-colouring) (these can
    be reduced to a timetabling problem and vice versa, showing how NP-complete problems
    can relate to each other)'
  id: totrans-1490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[the knapsack problem](http://en.wikipedia.org/wiki/Knapsack_problem)'
  id: totrans-1491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[the bin packing problem](http://en.wikipedia.org/wiki/Bin_packing_problem)'
  id: totrans-1492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hamiltonian paths](http://en.wikipedia.org/wiki/Hamiltonian_path) (no tractable
    solution for this is known, yet the very similar Eulerian path, which is often
    presented as the seven bridges problem, has an easy tractable solution)'
  id: totrans-1493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Steiner trees](http://www.csunplugged.org/steiner-trees)'
  id: totrans-1494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dominating sets](http://www.csunplugged.org/dominating-sets)'
  id: totrans-1495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Longest path](http://en.wikipedia.org/wiki/Longest_path) (this is interesting
    because finding the longest path is intractable, yet finding the shortest path
    is tractable - the shortest path is calculated when a GPS device works out the
    shortest route to a destination. Also, a Hamiltonian problem can be reduced easily
    to longest path, showing the concept of reduction when one NP-complete problem
    is used to solve another). And here’s a song about it! [https://www.youtube.com/watch?feature=player_embedded&v=a3ww0gwEszo](https://www.youtube.com/watch?feature=player_embedded&v=a3ww0gwEszo)'
  id: totrans-1496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[the Battleship problem](http://en.wikipedia.org/wiki/Battleship_(puzzle))'
  id: totrans-1497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 11.6\. THE WHOLE STORY!
  id: totrans-1498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The question of tractability is a big one in computer science — in fact, what
    is widely regarded as the biggest unsolved problem in computer science revolves
    around it. You may recall that we mentioned that there are thousands of problems
    that are we don’t have a tractable solution for, yet a tractable solution to one
    can be adapted to all the others. This groups of problems is called “NP-complete”
    (NP stands for non-deterministic polynomial if you really want to know; complete
    just means that they can all be converted to each other!) The big question is
    whether or not there is a polynomial time algorithm for any one of them, in which
    case all NP problems will have a P (polynomial time) solution. The question is
    often referred to as whether or not P equals NP.
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, things get worse. So far we’ve talked about intractable problems
    — ones that can be solved, but might need billions of years on a computer. If
    you think it’s bad that some problems take that long to solve, that’s nothing!
    There are some well known problems that we know can *never* be solved on a computer.
    For example, writing a program that reliably tells you if another program will
    finish or not is impossible! There are other examples of such problems here: -[http://www.cs4fn.org/algorithms/tiles.php](http://www.cs4fn.org/algorithms/tiles.php) - [http://www.cs4fn.org/algorithms/uncomputable.php](http://www.cs4fn.org/algorithms/uncomputable.php) - [http://www.cs4fn.org/algorithms/haltingproblem.php](http://www.cs4fn.org/algorithms/haltingproblem.php)'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: It’s good to know about these issues, to avoid getting stuck writing impossible
    programs. It’s also a fascinating area of research with opportunities to make
    a discovery that could change the world of computing, as well as contribute to
    our understanding on what can and can’t be computed.
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: 11.7\. FURTHER READING
  id: totrans-1502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This topic is covered very thoroughly in a way that is accessible to non-specialists
    in a popular book by David Harel called “Computers Ltd.: What They Really Can’t
    Do”.'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: 11.7.1\. USEFUL LINKS
  id: totrans-1504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Computational_complexity_theory](http://en.wikipedia.org/wiki/Computational_complexity_theory)'
  id: totrans-1505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.tsp.gatech.edu/games/index.html](http://www.tsp.gatech.edu/games/index.html)'
  id: totrans-1506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://csunplugged.org/graph-colouring](http://csunplugged.org/graph-colouring)'
  id: totrans-1507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Travelling_salesman_problem](http://en.wikipedia.org/wiki/Travelling_salesman_problem)'
  id: totrans-1508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Knapsack_problem](http://en.wikipedia.org/wiki/Knapsack_problem)'
  id: totrans-1509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Bin_packing_problem](http://en.wikipedia.org/wiki/Bin_packing_problem)'
  id: totrans-1510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Hamiltonian_path](http://en.wikipedia.org/wiki/Hamiltonian_path)'
  id: totrans-1511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Brute-force_search](http://en.wikipedia.org/wiki/Brute-force_search)'
  id: totrans-1512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12\. FORMAL LANGUAGES
  id: totrans-1513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 12.1\. WHAT’S THE BIG PICTURE?
  id: totrans-1514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve ever written a text-based program, chances are that at some stage
    the system has told you there’s an error in your program even before it runs.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada52be381.png)'
  id: totrans-1516
  prefs: []
  type: TYPE_IMG
- en: 'These “syntax errors” are annoying messages that programmers become excruciatingly
    familiar with ... it means that they didn’t follow the rules somehow, even if
    it’s just a tiny mistake. For example, suppose you intended to write:'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-1518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'but you accidentally left out one of the brackets:'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-1520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When you try to compile or run the program, the computer will tell you that
    there’s an error. If it’s really helpful, it might even suggest where the error
    is, but it won’t run the program until you fix it.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: This might seem annoying, but in fact by enforcing precision and attention to
    detail it helps pinpoint mistakes before they become bugs in the program that
    go undetected until someone using it complains that it’s not working correctly.
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you get errors like this, you’re dealing with a *formal language*.
    Formal languages specify strict rules such as “all parentheses must be balanced”,
    “all commands in the program must be keywords selected from a small set”, or “the
    date must contain three numbers separated by dashes”.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: Formal languages aren’t just used for programming languages — they’re used anywhere
    the format of some input is tightly specified, such as typing an email address
    into a web form.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: In all these cases, the commands that you have typed (whether in Python, Scratch,
    Snap!, C, Pascal, Basic, C#, HTML, or XML) are being read by a computer program.
    (That’s right... Python is a program that reads in Python programs.) In fact,
    the compiler for a programming language is often written in its own language.
    Most C compilers are written in C — which begs the question, who wrote the first
    C compiler (and what if it had bugs)?! Computer Scientists have discovered good
    ways to write programs that process other programs, and a key ingredient is that
    you have to specify what is allowed in a program very precisely. That’s where
    formal languages come in.
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the concepts we’ll look at in this chapter are used in a variety of
    other situations: checking input to a web page; analysing user interfaces; searching
    text, particularly with “wild cards” strings that can match any sequence of characters;
    creating logic circuits; specifying communication protocols; and designing embedded
    systems.'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re familiar with the idea of formal languages, you’ll possess a powerful
    tool for cutting complex systems down to size using an easily specified format.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ada5242e0a.png)](http://xkcd.com/1144/)'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: 12.2\. GETTING STARTED
  id: totrans-1529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To give you a taste of what can be done, let’s try searching for words that
    fit particular patterns. Suppose you’re looking for words that contain the name
    “tim”.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the [Regex Dictionary](http://www.visca.com/regexdict/) and type into
    the “String:” box:'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-1532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: then press the “Search” button to find all words containing “tim”.
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: That’s a pretty simple search (though the results may have surprised you!).
    But now we introduce the *wildcard* code, which in this case is ”.” — a widely
    used convention. This matches any character at all. So now you can do a search
    like
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-1535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'and you will get any words that have both “tim” and “b” with a single character
    — any character — in between. Are there any words that match “tim..b”? “tim...b”?
    You can specify any number of occurrences of a symbol by putting a “*” after it
    (again a widely used convention), so:'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-1537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: will match any words where “tim” is followed by “b”, separated by any number
    of characters — including zero.
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: Try the following search. What kind of words does it find?
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-1540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Can you find words that contain your name, or your initials?
  id: totrans-1541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What about words containing the letters from your name in the correct order?
  id: totrans-1542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there any words that contain all the vowels in order (a, e, i, o, u)?
  id: totrans-1543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code you’ve used above is a part of a formal language called a “regular
    expression”. Computer programs that accept typed input use regular expressions
    for checking items like dates, credit card numbers and product codes. They’re
    used extensively by programming language compilers and interpreters to make sense
    of the text that a programmer types in. We’ll look at them in more detail in the
    section on [*Regular expressions*](http://csfieldguide.org.nz/FormalLanguages.html#fl-regex).
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: Next we examine a simple system for reading input called a [*finite state automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton),
    which — as we’ll find out later — is closely related to regular expressions. Later
    we’ll explore the idea of *grammars*, another kind of formal language that can
    deal with more complicated forms of input.
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: 12.3\. FINITE STATE AUTOMATA
  id: totrans-1546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s a map of a commuter train system for the town of Trainsylvania. The trouble
    is, it doesn’t show where the the trains go — all you know is that there are two
    trains from each station, the A-train and the B-train. The inhabitants of Trainsylvania
    don’t seem to mind this — it’s quite fun choosing trains at each station, and
    after a while you usually find yourself arriving where you intended.
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada51cba6a.png)'
  id: totrans-1548
  prefs: []
  type: TYPE_IMG
- en: You can travel around Trainsylvania yourself using the following interactive.
    You’re starting at the City Mall station, and you need to find your way to Suburbopolis.
    At each station you can choose either the A-train or the B-train — press the button
    to find out where it will take you. But, like the residents of Trainsylvania,
    you’ll probably want to start drawing a map of the railway, because later you
    might be asked to find your way somewhere else. If you want a template to draw
    on, you can[print one out from here](http://csfieldguide.org.nz/_static/formal_languages/FL-trainsylvania-blank.pdf).
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: Did you find a sequence of trains to get from City Mall to Suburbopolis? You
    can test it by typing the sequence of trains in the following interactive. For
    example, if you took the A-train, then the B-train, then an A-train, type in ABA.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: Can you find a sequence that takes you from City Mall to Suburbopolis? Can you
    find another sequence, perhaps a longer one? Suppose you wanted to take a really
    long route ... can you find a sequence of 12 hops that would get you there? 20
    hops?
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: Here’s another map. It’s for a different city, and the stations only have numbers,
    not names (but you can name them if you want).
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada512cb66.png)'
  id: totrans-1553
  prefs: []
  type: TYPE_IMG
- en: Suppose you’re starting at station 1, and need to get to station 3 (it has a
    double circle to show that’s where you’re headed.)
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: What’s the shortest way to get from station 1 to station 3?
  id: totrans-1555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where do you end up if you start at station 1 and take the trains ABAA?
  id: totrans-1556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where do you end up if your start at station 1 and take 20 train hops, always
    alternating A, B, A, B, A, B?
  id: totrans-1557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you give an easy-to-describe sequence of 100 or more hops that will get
    you to station 3?
  id: totrans-1558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The map that we use here, with circles and arrows, is actually a powerful idea
    from computer science called a [*Finite State Automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton),
    or FSA for short. Being comfortable with such structures is a useful skill for
    computer scientists.
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: The name [*Finite State Automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton) (FSA)
    might seem strange, but each word is quite simple. “Finite” just means that there
    is a limited number of states (such as train stations) in the map. The “state”
    is just as another name for the train stations we were using. “Automaton” is an
    old word meaning a machine that acts on its own, following simple rules (such
    as the cuckoo in a cuckoo clock). Sometimes an FSA is called a **Finite State
    Machine** (FSM), or even just a “state machine”. By the way, the plural of “Automaton”
    can be either “Automata” or “Automatons”. People working with formal languages
    usually use Finite State *Automata*, but “FSAs” for short.
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: An FSA isn’t all that useful for train maps, but the notation is used for many
    other purposes, from checking input to computer programs to controlling the behaviour
    of an interface. You may have come across it when you dial a telephone number
    and get a message saying “Press 1 for this … Press 2 for that … Press 3 to talk
    to a human operator.” Your key presses are inputs to a [*finite state automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton) at
    the other end of the phone line. The dialogue can be quite simple, or very complex.
    Sometimes you are taken round in circles because there is a peculiar loop in the
    finite-state automaton. If this occurs, it is an error in the design of the system
    — and it can be extremely frustrating for the caller!
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: Another example is the remote control for an air conditioning unit. It might
    have half a dozen main buttons, and pressing them changes the mode of operation
    (e.g. heating, cooling, automatic). To get to the mode you want you have to press
    just the right sequence, and if you press one too many buttons, it’s like getting
    to the train station you wanted but accidentally hopping on one more train. It
    might be a long journey back, and you may end up exploring all sorts of modes
    to get there! If there’s a manual for the controller, it may well contain a diagram
    that looks like a [*Finite State Automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton).
    If there isn’t a manual, you may find yourself wanting to draw a map, just as
    for the trains above, so that you can understand it better.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: 'The map that we used above uses a standard notation. Here’s a smaller one:'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada50151bd.png)'
  id: totrans-1565
  prefs: []
  type: TYPE_IMG
- en: Notice that this map has routes that go straight back to where they started!
    For example, if you start at 1 and take route “b”, you immediately end up back
    at 1\. This might seem pointless, but it can be quite useful. Each of the “train
    stations” is called a state, which is a general term that just represents where
    you are after some sequence of inputs or decisions. What it actually means depends
    on what the FSA is being used for. States could represent a mode of operation
    (like fast, medium, or slow when selecting a washing machine spin cycle), or the
    state of a lock or alarm (on, off, exit mode), or many other things. We’ll see
    more examples soon.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: One of the states has a double circle. By convention, this marks a “final” or
    “accepting” state, and if we end up there we’ve achieved some goal. There’s also
    a “start” state — that’s the one with an arrow coming from nowhere. Usually the
    idea is to find a sequence of inputs that gets you from the start state to a final
    state. In the example above, the shortest input to get to state 2 is “a”, but
    you can also get there with “aa”, or “aba”, or “baaaaa”. People say that these
    inputs are “accepted” because they get you from the start state to the final state
    — it doesn’t have to be the shortest route.
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: What state would you end up in if the input was the letter “a” repeated 100
    times?
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: Of course, not all inputs get you to state 2\. For example, “aab” or even just
    “b” aren’t accepted by this simple system. Can you characterise which inputs are
    accepted?
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an interactive which follows the rules of the FSA above. You can use
    it to test different inputs.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: Here’s another [*FSA*](http://csfieldguide.org.nz/appendices/Glossary.html#term-fsa),
    which looks similar to the last one but behaves quite differently. You can test
    it in the interactive below.
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4eedfc8.png)'
  id: totrans-1572
  prefs: []
  type: TYPE_IMG
- en: Work out which of the following inputs it accepts. Remember to start in state
    1 each time!
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: “aaa”
  id: totrans-1574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “abb”
  id: totrans-1575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “aaaa”
  id: totrans-1576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “bababab”
  id: totrans-1577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “babababa”
  id: totrans-1578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the letter “a” repeated 100 times
  id: totrans-1579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the letter “a” repeated 1001 times
  id: totrans-1580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the letter “b” a million times, then an “a”, then another million of the letter
    “b”
  id: totrans-1581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you state a general rule for the input to be accepted?
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: To keep things precise, we’ll define two further technical terms. One is the [*alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet),
    which is just a list of all possible inputs that might happen. In the last couple
    of examples the [*alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet) has
    consisted of the two letters “a” and “b”, but for an FSA that is processing text
    typed into a computer, the [*alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet) will
    have to include every letter on the keyboard.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: The connections between states are called *transitions*, since they are about
    changing state. The sequence of characters that we input into the FSA is often
    called a[*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) (it’s
    just a [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) of
    letters), and the set of all [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    can be accepted by a particular FSA is called its *language*. For the FSA in the
    last example, its language includes the [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) “a”,
    “aaa”, “bab”, “ababab”, and lots more, because these are accepted by it. However,
    it does not include the [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) “bb”
    or “aa”.
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: The language of many FSAs is big. In fact, the ones we’ve just looked at are
    infinite. You could go on all day listing patterns that they accept. There is
    no limit to the length of the [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) they
    can accept.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: That’s good, because many real-life FSA’s have to deal with “infinite” input.
    The diagram below shows the FSA for the spin speed on a washing machine, where
    each press of the spin button changes the setting.
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4e02ce8.png)'
  id: totrans-1587
  prefs: []
  type: TYPE_IMG
- en: It would be frustrating if you could only change the spin setting 50 times,
    and then it stopped accepting input ever again. If you want, you could switch
    from fast to slow spin by pressing the spin button 3002 times. Or 2 times would
    do. Or 2 million times (try it if you don’t believe me).
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram summarizes the terminology we have introduced. Notice
    that this FSA has two accepting states. You can have as many as you want, but
    only one start state.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4d13da0.png)'
  id: totrans-1590
  prefs: []
  type: TYPE_IMG
- en: For this FSA, the [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) “aa”
    and “aabba” would be accepted, and “aaa” and “ar” wouldn’t. By the way, notice
    that we often put inverted commas around [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) to
    make it clear where they start and stop. Of course, the inverted commas aren’t
    part of the strings.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you’ll see an FSA referred to as a Finite State Machine, or FSM, and
    there are other closely related systems with similar names. We’ll mention some
    later in the chapter.
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: 'Now there’s something we have to get out of the way before going further. If
    we’re talking about which [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) of
    inputs will get you into a particular state, and the system starts in that state,
    then the *empty string* — that is, a string without any letters at all — is one
    of the solutions! For example, here’s a simple [*finite state automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton) with
    just one input (button a) that represents a strange kind of light switch. The
    reset button isn’t part of the FSA; it’s just a way of letting you return to the
    starting state. See if you can figure out which patterns of input will turn the
    light on:'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: Have you worked out which sequences of button presses turn on the light? Now
    think about the *shortest* sequence from a reset that can turn it on.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: Since it’s already on when it has been reset, the shortest sequence is *zero* button
    presses. It’s hard to write that down (although you could use “”), so we have
    a symbol especially for it, which is the Greek letter epsilon: ϵ. You’ll come
    across ϵ quite often with formal languages.
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: It can be a bit confusing. For example, the language (that is, the list of all
    accepted inputs) of the FSA above includes “aaa”, “aaaaaa”, and ϵ. If you try
    telling someone that “nothing” will make the light come on that could be confusing
    — it might mean that you could never turn the light on — so it’s handy being able
    to say that the*empty string* (or ϵ) will turn the light on. There are different
    kinds of “nothing”, and we need to be precise about which one we mean!
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the FSA for the strange light switch. You can tell that ϵ is part of
    the language because the start state is also a final state (in fact, it’s the
    only final state). Actually, the switch isn’t all that strange — data projectors
    often require two presses of the power button, to avoid accidentally turning them
    off.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4c8ebaf.png)'
  id: totrans-1598
  prefs: []
  type: TYPE_IMG
- en: 'An important part of the culture of computer science is always to consider
    extreme cases. One kind of extreme case is where there is no input at all: what
    if a program is given an empty file, or your database has zero entries in it?
    It’s always important to make sure that these situations have been thought through.
    So it’s not surprising that we have a symbol for the empty string. Just for variety,
    you’ll occasionally find some people using the Greek letter lambda (λ) instead
    of ϵ to represent the empty string.'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: And by the way, the language of the three-state FSA above is infinitely large
    because it is the set of all [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    contain the letter “a” in multiples of 3, which is {ϵ, aaa, aaaaaa, aaaaaaaaa,
    ...}. That’s pretty impressive for such a small machine.
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: While we’re looking at extremes, here’s another FSA to consider. It uses “a”
    and “b” as its [*alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet).
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4be9118.png)'
  id: totrans-1602
  prefs: []
  type: TYPE_IMG
- en: Will it accept the [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) “aaa”?
    Or “aba”? Or anything of 3 characters or more?
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you get the third character you end up in state 4, which is called
    a *trap state* because you can’t get out. If this was the map for the commuter
    train system we had at the start of this section it would cause problems, because
    eventually everyone would end up in the trap state, and you’d have serious overcrowding.
    But it can be useful in other situations — especially if there’s an error in the
    input, so no matter what else comes up, you don’t want to go ahead.
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: 'For the example above, the language of the FSA is any mixture of “a”s and “b”s,
    but only two characters at most. Don’t forget that the empty [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) is
    also accepted. It’s a very small language; the only [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) in
    it are: {ϵ, a, b, aa, ab, ba, bb}.'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another FSA to consider:'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4b23fb5.png)'
  id: totrans-1607
  prefs: []
  type: TYPE_IMG
- en: 'It’s fairly clear what it will accept: [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) like
    “ab”, “abab”, “abababababab”, and, of course ϵ. But there are some missing transitions:
    if you are in state 1 and get a “b” there’s nowhere to go. If an input cannot
    be accepted, it will be rejected, as in this case. We could have put in a trap
    state to make this clear:'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4a999f6.png)'
  id: totrans-1609
  prefs: []
  type: TYPE_IMG
- en: 'But things can get out of hand. What if there are more letters in the [*alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet)?
    We’d need something like this:'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4a11618.png)'
  id: totrans-1611
  prefs: []
  type: TYPE_IMG
- en: So, instead, we just say that any unspecified transition causes the input to
    be rejected (that is, it behaves as though it goes into a trap state). In other
    words, it’s fine to use the simple version above, with just two transitions.
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve got the terminology sorted out, let’s explore some applications
    of this simple but powerful “machine” called the [*Finite State Automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton).
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.1\. WHO USES FINITE STATE AUTOMATA?
  id: totrans-1614
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finite state automata are used a lot in the design of digital circuits (like
    the electronics in a hard drive) and embedded systems (such as burglar alarms
    or microwave ovens). Anything that has a few buttons on it and gets into different
    states when you press those buttons (such as alarm on/off, high/med/low power)
    is effectively a kind of FSA.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: With such gadgets, FSAs can be used by designers to plan what will happen for
    every input in every situation, but they can also be used to analyse the interface
    of a device. If the FSA that describes a device is really complicated, it’s a
    warning that the interface is likely to be hard to understand. For example, here’s
    an FSA for a microwave oven. It reveals that, for example, you can’t get from
    power2 to power1 without going through timer1\. Restrictions like this will be
    very frustrating for a user. For example, if they try to set power1 it won’t work
    until they’ve set timer1 first. Once you know this sequence it’s easy, but the
    designer should think about whether it’s necessary to force the user into that
    sort of sequence. These sorts of issues become clear when you look at the FSA.
    But we’re straying into the area of Human-Computer Interaction! This isn’t surprising
    because most areas of computer science end up relating to each other — but let’s
    get back to other applications of FSAs.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada490a53e.png)'
  id: totrans-1617
  prefs: []
  type: TYPE_IMG
- en: As we shall see in the next section, one of the most valuable uses of the FSA
    in computer science is for checking input to computers, whether it’s a value typed
    into a dialogue box, a program given to a compiler, or some search text to be
    found in a large document. There are also data compression methods that use FSAs
    to capture patterns in the data being compressed, and variants of FSA are used
    to simulate large computer systems to see how best to configure it before spending
    money on actually building it.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: What’s the biggest FSA in the world, one that lots of people use every day?
    It’s the World-Wide Web. Each web page is like a state, and the links on that
    page are the transitions between them. Back in the year 2000 the web had a billion
    pages. In 2008 Google Inc. declared they had found a trillion different web page
    addresses. That’s a lot. A book with a billion pages would be 50 km thick. With
    a trillion pages, its thickness would exceed the circumference of the earth.
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: But the web is just a finite-state automaton. And in order to produce an index
    for you to use, search engine companies like Google have to examine all the pages
    to see what words they contain. They explore the web by following all the links,
    just as you did in the train travelling exercise. Only, because it’s called the
    “web,” exploring is called “crawling” — like spiders do.
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
- en: '12.3.2\. ACTIVITY: PRACTICE CREATING FSAS'
  id: totrans-1622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This activity involves constructing and testing your own FSA, using free software
    that you can download yourself. Before doing that, we’ll look at some general
    ways to create an FSA from a description. If you want to try out the examples
    here on a live FSA, read the next two sections about using Exorciser and JFLAP
    respectively, which allow you to enter FSAs and test them.
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
- en: 'A good starting point is to think of the shortest string that is needed for
    a particular description. For example, suppose you need an FSA that accepts all
    strings that contain an even number of the letter “b”. The shortest such string
    is ϵ, which means that the starting state must also be a final state, so you can
    start by drawing this:'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada48671b5.png)'
  id: totrans-1625
  prefs: []
  type: TYPE_IMG
- en: 'If instead you had to design an FSA where the shortest accepted string is “aba”,
    you would need a sequence of 4 states like this:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada47a5a7c.png)'
  id: totrans-1627
  prefs: []
  type: TYPE_IMG
- en: 'Then you need to think what happens next. For example, if we are accepting
    strings with an even number of “b”s, a single “b” would have to take you from
    the start state to a non-accepting state:'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada471e68e.png)'
  id: totrans-1629
  prefs: []
  type: TYPE_IMG
- en: 'But another “b” would make an even number, so that’s acceptable. And for any
    more input the result would be the same even if all the text to that point hadn’t
    happened, so you can return to the start state:'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada464b4be.png)'
  id: totrans-1631
  prefs: []
  type: TYPE_IMG
- en: Usually you can find a “meaning” for a state. In this example, being in state
    1 means that so far you’ve seen an even number of “b”s, and state 2 means that
    the number so far has been odd.
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to think about missing transitions from each state. So far there’s
    nothing for an “a” out of state 1\. Thinking about state 1, an “a” doesn’t affect
    the number of “b”s seen, and so we should remain in state 1:'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada45ab99d.png)'
  id: totrans-1634
  prefs: []
  type: TYPE_IMG
- en: 'The same applies to state 2:'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada4518aa4.png)'
  id: totrans-1636
  prefs: []
  type: TYPE_IMG
- en: Now every state has a transition for every input symbol, so the FSA is finished.
    You should now try some examples to check that an even number of “b”s always brings
    it to state 1.
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: Get some practice doing this yourself! Here are instructions for two different
    programs that allow you to enter and test FSAs.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.2.1\. EXORCISER
  id: totrans-1639
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section shows how to use some educational software called “Exorciser”.
    (The next section introduces an alternative called JFLAP which is a bit harder
    to use.) Exorciser has facilities for doing advanced exercises in formal languages;
    but we use just the simplest ones.
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: Exorciser can be downloaded [here](http://www.swisseduc.ch/compscience/exorciser/index.html).
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: When you run it, select “Constructing Finite Automata” (the first menu item);
    click the “Beginners” link when you want a new exercise. The challenge in each
    FSA exercise is the part after the | in the braces (i.e., curly brackets). For
    example, in the diagram below you are being asked to draw an FSA that accepts
    an input [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) w
    if “w has length at least 3”. You should draw and test your answer, although initially
    you may find it helpful to just click on “Solve exercise” to get a solution, and
    then follow strings around the solution to see how it works. That’s what we did
    to make the diagram below.
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada44407e1.png)'
  id: totrans-1643
  prefs: []
  type: TYPE_IMG
- en: To draw an FSA in the Exorciser system, right-click anywhere on the empty space
    and you’ll get a menu of options for adding and deleting states, choosing the[*alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet),
    and so on. To make a transition, drag from the outside circle of one state to
    another (or out and back to the state for a loop). You can right-click on states
    and transitions to change them. The notation “a|b” means that a transition will
    be taken on “a” or “b” (it’s equivalent to two parallel transitions).
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: 'If your FSA doesn’t solve their challenge, you’ll get a hint in the form of
    a [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) that
    your FSA deals with incorrectly, so you can gradually fix it until it works. If
    you’re stuck, click “Solve exercise”. You can also track input as you type it:
    right-click to choose that option. See the [SwissEduc website](http://www.swisseduc.ch/compscience/) for
    more instructions.'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3e01265.png)'
  id: totrans-1646
  prefs: []
  type: TYPE_IMG
- en: The section after next gives some examples to try. If you’re doing this for
    a report, keep copies of the automata and tests that you do. Right-click on the
    image for a “Save As” option, or else take screenshots of the images.
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.2.2\. JFLAP
  id: totrans-1648
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another widely used system for experimenting with FSAs is a program called JFLAP
    (download it from [http://jflap.org](http://jflap.org/)). You can use it as an
    alternative for Exorciser if necesary. You’ll need to follow instructions carefully
    as it has many more features than you’ll need, and it can be hard to get back
    to where you started.
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to build an FSA using JFLAP. As an example, we’ll use the following
    FSA:'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3d72c6f.png)'
  id: totrans-1651
  prefs: []
  type: TYPE_IMG
- en: 'To build this, run JFLAP and:'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: click on the “Finite Automaton” button in the control panel.
  id: totrans-1653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Editor window, click on the picture of a state (with a little q in it),
    and then click in the window to create states.
  id: totrans-1654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To move the states around, click on the arrow tool in the toolbar (leftmost
    icon). It doesn’t matter where the states are, but you want them to be easy to
    view.
  id: totrans-1655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To put a transition between two states, click on the transition tool (third
    icon), drag a line between two states, type the label for the transition (“a”
    or “b” for this exercise), and press return. (The system will offer the empty
    string (λ) as a label, but please don’t go there!)
  id: totrans-1656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make a transition loop back to a state, just click on the state with the
    transition tool.
  id: totrans-1657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can choose the start state by selecting the arrow tool (leftmost icon),
    right-clicking on the state, and selecting “Initial”. Only one state can be the
    start state, but you can set more than one “Final” (accepting) state in the same
    way, by right-clicking on them.
  id: totrans-1658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to change something, you can delete things with the delete tool
    (the skull icon). Alternatively, select the arrow tool and double-click on a transition
    label to edit it, or right-click on a state. You can drag states around using
    the arrow tool.
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: To watch your FSA process some input, use the “Input” menu (at the top), choose
    “Step with closure”, type in a short string such as “abaa”, and click “OK”. Then
    at the bottom of the window you can trace the [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) one
    character at a time by pressing “Step”, which highlights the current state as
    it steps through the string. If you step right through the [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) and
    end up in a final (accepting) state, the panel will come up green. To return to
    the Editor window, go to the “File” menu and select “Dismiss Tab”.
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3cb18bf.png)'
  id: totrans-1661
  prefs: []
  type: TYPE_IMG
- en: You can run multiple tests in one go. From the “Input” menu choose “Multiple
    Run”, and type your tests into the table, or load them from a text file.
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3bcf9cf.png)'
  id: totrans-1663
  prefs: []
  type: TYPE_IMG
- en: You can even do tests with the empty [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) by
    leaving a blank line in the table, which you can do by pressing the “Enter Lambda”
    button.
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: There are some FSA examples in the next section. If you’re doing this for a
    report, keep copies of the automata and tests that you do (JFLAP’s “File” menu
    has a “Save Image As...” option for taking snapshots of your work; alternatively
    you can save an FSA that you’ve created in a file to open later).
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: 12.3.2.3\. EXAMPLES TO TRY
  id: totrans-1666
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using Exorciser or JFLAP, construct an FSA that takes inputs made of the letters
    “a” and “b”, and accepts the input if it meets one of the following requirements.
    You should build a separate FSA for each of these challenges.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: '[*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    start with the letter “a” (e.g. “aa”, “abaaa”, and “abbbb”).'
  id: totrans-1668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    end with the letter “a” (e.g. “aa”, “abaaa”, and “bbbba”).'
  id: totrans-1669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    have an even number of the letter “a” (e.g. “aa”, “abaaa”, “bbbb”; and don’t forget
    the empty string ϵ).'
  id: totrans-1670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    have an odd number of the letter “a” (e.g. “a”, “baaa”, “bbbab”, but not ϵ).'
  id: totrans-1671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) where
    the number of “a”s in the input is a multiple of three (e.g. “aabaaaa”, “bababab”).'
  id: totrans-1672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) where
    every time an a appears in the input, it is followed by a b (e.g. “abb”, “bbababbbabab”,
    “bbb”).'
  id: totrans-1673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    end with “ab”'
  id: totrans-1674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    start with “ab” and end with “ba”, and only have “b” in the middle (e.g. “abba”,
    “abbbbba”)'
  id: totrans-1675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the FSA(s) that you construct, check that they accept valid input, but also
    make sure they reject invalid input.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some more sequences of characters that you can construct FSAs to detect.
    The input [*alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet) is
    more than just “a” and “b”, but you don’t need to put in a transition for every
    possible character in every state, because an FSA can automatically reject an
    input if it uses a character that you haven’t given a transition for. Try doing
    two or three of these:'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: the names for international standard paper sizes (A1 to A10, B1 to B10, and
    so on)
  id: totrans-1678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a valid three-letter month name (Jan, Feb, Mar, etc.)
  id: totrans-1679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a valid month number (1, 2, ... 12)
  id: totrans-1680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a valid weekday name (Monday, Tuesday, ...)
  id: totrans-1681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A classic example of an FSA is an old-school vending machine that only takes
    a few kinds of coins. Suppose you have a machine that only takes 5 and 10 cent
    pieces, and you need to insert 30 cents to get it to work. The [*alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet) of
    the machine is the 5 and 10 cent coin, which we call F and T for short. For example,
    TTT would be putting in 3 ten cent coins, which would be accepted. TFFT would
    also be accepted, but TFFF wouldn’t. Can you design an FSA that accepts the input
    when 30 cents or more is put into the machine? You can make up your own version
    for different denominations of coins and required total.
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve worked with binary numbers, see if you can figure out what this FSA
    does. Try each binary number as input: 0, 1, 10, 11, 100, 101, 110, etc.'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3b3c22b.png)'
  id: totrans-1684
  prefs: []
  type: TYPE_IMG
- en: Can you work out what it means if the FSA finishes in state q1? State q2?
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: '12.3.3\. ACTIVITY: FIND FINITE STATE AUTOMATA IN EVERYDAY USE'
  id: totrans-1686
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are lots of systems around that use FSAs. You could choose a system,
    explain how it can be represented with an FSA, and show examples of sequences
    of input that it deals with. Examples are:'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: Board games. Simple board games are often just an FSA, where the next move is
    determined by some input (e.g. a number given by rolling dice), and the final
    state means that you have completed the game — so the first person to the final
    state wins. Most games are too complex to draw a full FSA for, but a simple game
    like snakes and ladders could be used as an example. What are some sequences of
    dice throws that will get you to the end of the game? What are some sequences
    that don’t?!
  id: totrans-1688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple devices with a few buttons often have states that you can identify. For
    example, a remote control for a car alarm might have two buttons, and what happens
    to the car depends on the order in which you press them and the current state
    of the car (whether it is alarmed or not). For devices that automatically turn
    on or off after a period of time, you may have to include an input such as “waited
    for 30 seconds”. Other devices to consider are digital watches (with states like
    “showing time”, “showing date”, “showing stopwatch”, “stopwatch is running”),
    the power and eject buttons on a CD player, channel selection on a TV remote (just
    the numbers), setting a clock, storing presets on a car radio, and burglar alarm
    control panels.
  id: totrans-1689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.3.4\. ACTIVITY: KARA, THE LADYBUG'
  id: totrans-1690
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[SwissEduc](http://www.swisseduc.ch/compscience/) has a programming environment
    called [Kara](http://www.swisseduc.ch/compscience/karatojava/kara/) (requires
    Java to be installed), which is a programmable ladybug that (in its simplest version)
    walks around an imaginary world controlled by actions output by a [*finite state
    automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton).
    The ladybug has (simulated) detectors that sense its immediate surroundings; these
    serve as input to the FSA.'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: 12.4\. REGULAR EXPRESSIONS
  id: totrans-1692
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: For teachers
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions (regex for short) are closely related to FSAs, as we shall
    see. Much of the terminology that is needed was already covered in the previous
    section: we’ll be using languages, [*alphabets*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabets),
    strings, ϵ / λ, and eventually finite state automata. So the previous section
    on FSAs needs to be covered before embarking on regular expressions.'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: It may be that students have used regular expressions already, because they
    are built into many programming languages and are often used when writing script
    programs. We’ll be looking briefly at such applications — and they’re very relevant
    — but in formal languages we’re also interested in the limits of what can be represented,
    and how to convert a regex to an FSA. So there should be something here to get
    students thinking, even if they’re expert at programming with regexes.
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already had a taste of regular expressions in the [*Getting started*](http://csfieldguide.org.nz/FormalLanguages.html#fl-gettingstarted) section.
    They are just a simple way to search for things in the input, or to specify what
    kind of input will be accepted as legitimate. For example, many web scripting
    programs use them to check input for patterns like dates, email addresses and
    URLs. They’ve become so popular that they’re now built into most programming languages.
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: You might already have a suspicion that regular expressions are related to finite
    state automata. And you’d be right, because it turns out that every [*regular
    expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) has
    a [*finite state automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton) that
    can check for matches, and every [*finite state automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton) can
    be converted to a [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) that
    shows exactly what it does (and doesn’t) match. Regular expressions are usually
    easier for humans to read. For machines, a computer program can convert any regular
    expression to an FSA, and then the computer can follow very simple rules to check
    the input.
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest kind of matching is just entering some text to match. Open a new
    window to the “Rubular” system (a screenshot is shown below) by clicking on the
    following challenge:'
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: '[Open Rubular using this link and type the text "cat" into the box labeled
    "Your regular expression"](http://rubular.com/r/vCD1OSfjAc)'
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3a487fd.png)'
  id: totrans-1701
  prefs: []
  type: TYPE_IMG
- en: If you’ve only typed the 3 characters “cat”, then it should find 6 matches.
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try typing a dot (full stop or period) as the fourth character: “cat.”.
    In a regular expression, ”.” can match any single character. Try adding more dots
    before and after “cat”. How about “cat.s” or “cat..n”?'
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: What do you get if you search for ” ... ” (three dots with a space before and
    after)?
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: Now try searching for “ic.”. The ”.” matches any letter, but if you really wanted
    a full stop, you need to write it like this “ic.” — use this search to find “ic”
    at the end of a sentence.
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: Another special symbol is “\d”, which matches any digit. Try matching 2, 3 or
    4 digits in a row (for example, two digits in a row is “\d\d”).
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: To choose from a small set of characters, try “[ua]ff”. Either of the characters
    in the square brackets will match. Try writing a [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) that
    will match “fat”, “sat” and “mat”, but not “cat”.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: A shortcut for “[mnopqrs]” is “[m-s]”; try “[m-s]at” and “[4-6]”.
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful shortcut is being able to match repeated letters. There are
    four common rules:'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: a* matches 0 or more repetitions of a
  id: totrans-1710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a+ matches 1 or more repetitions of a
  id: totrans-1711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a? matches 0 or 1 occurrences of a (that is, a is optional)
  id: totrans-1712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a{5} matches “aaaaa” (that is, a repeated 5 times)
  id: totrans-1713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try experimenting with these. Here are some examples to try:'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-1715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you want to choose between options, the vertical bar is useful. Try the
    following, and work out what they match. You can type extra text into the test [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) area
    if you want to experiment:'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-1717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice the use of brackets to group parts of the regular expression. It’s useful
    if you want the “+” or “*” to apply to more than one character.
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: The name [*Regular Expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) is
    sometimes abbreviated to “regex”, “regexp”, or “RE”. It’s “regular” because it
    can be used to define sets of strings from a very simple class of languages called
    “regular languages”, and it’s an “expression” because it is a combination of symbols
    that follow some rules.
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: '[Click here for another challenge: you should try to write a short regular
    expression to match the first two words, but not the last three](http://rubular.com/r/AdmyZ5aPtD).'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, regular expressions are mainly used for more serious purposes. Click
    on the following challenge to get some new text to search:'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: '[Open this challenge in Rubular and try the following expressions](http://rubular.com/r/kun5ZaJqlL).'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: The following [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) will
    find comon NZ number plates in the sample text, but can you find a shorter version
    using the {n} notation?
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-1725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'How about an expression to find the dates in the text? Here’s one option, but
    it’s not perfect:'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-1727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Can you improve on it?
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: What about phone numbers? You’ll need to think about what variations of phone
    numbers are common! How about finding email addresses?
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ada38e70dc.png)](http://xkcd.com/208/)'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions are useful!
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
- en: The particular form of [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) that
    we’ve been using is for the Ruby programming language (a popular language for
    web site development), although it’s very similar to regular expressions used
    in other languages including Java, JavaScript, PHP, Python, and Microsoft’s .NET
    Framework. Even some spreadsheets have [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) matching
    facilities.
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: But regular expressions have their limits — for example, you won’t be able to
    create one that can match palindromes (words and phrases that are the same backwards
    as forwards, such as “kayak”, “rotator” and “hannah”), and you can’t use one to
    detect [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    consist of *n* repeats of the letter “a” followed by *n* repeats of the letter
    “b”. We’ll look at other systems for doing that in the section on *grammars*.
    But nevertheless, regular expressions are very useful for a lot of common [*pattern
    matching*](http://csfieldguide.org.nz/appendices/Glossary.html#term-pattern-matching) requirements.
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.1\. REGULAR EXPRESSIONS AND FSAS
  id: totrans-1734
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s a direct relationship between regular expressions and FSAs. For example,
    consider the following regex, which matches [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    begin with an even number of the letter “a” and end with an even number of the
    letter “b”:'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-1736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now look at how the following FSA works on these [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) —
    you could try “aabb”, “aaaabb”, “aaaaaabbbb”, and also see what happens for [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) like
    “aaabb”, “aa”, “aabbb”, and so on.
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3841dfd.png)'
  id: totrans-1738
  prefs: []
  type: TYPE_IMG
- en: You may have noticed that q2 is a “trap state”. We can achieve the same effect
    with the following FSA, where all the transitions to the trap state have been
    removed — the FSA can reject the input as soon as a non-existent transition is
    needed.
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada37a5880.png)'
  id: totrans-1740
  prefs: []
  type: TYPE_IMG
- en: Like an FSA, each [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) represents
    a [*language*](http://csfieldguide.org.nz/appendices/Glossary.html#term-language),
    which is just the set of all [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that
    match the regular expression. In the example above, the shortest[*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) in
    the language is “aabb”, then there’s “aaaabb” and “aabbbb”, and of course an infinite
    number more. There’s also an infinite number of [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) that *aren’t* in
    this language, like “a”, “aaa”, “aaaaaa” and so on.
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
- en: 'In the above example, the FSA is a really easy way to check for the [*regular
    expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) —
    you can write a very fast and small program to implement it (in fact, it’s a good
    exercise: you typically have an array or list with an entry for each state, and
    each entry tells you which state to go to next on each character, plus whether
    or not it’s a final state. At each step the program just looks up which state
    to go to next.)'
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, *every* [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) can
    be converted to an FSA. We won’t look at the process here, but both Exorciser
    and JFLAP can do it for you anyway (see the activities below).
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: This is also built into most programming languages. Programmers usually use
    regular expressions by calling functions or methods that are passed the regex
    and the[*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) to
    be searched. But behind the scenes, the [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) is
    converted to a finite state automaton, and then the job of checking your [*regular
    expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) is
    very easy.
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
- en: '12.4.2\. ACTIVITY: DESIGNING REGULAR EXPRESSIONS'
  id: totrans-1745
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are some ideas for regular expressions for you to try to create. You can
    check them using [Rubular](http://rubular.com/) as we did earlier, but you’ll
    need to make up your own text to check. When testing your expressions, make sure
    that they not only accept correct strings, but reject ones that don’t match, even
    if there’s just one character missing.
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: You may find it easier to have one test match [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) per
    line in “Your test string”. You can force your [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) to
    match a whole line by putting “^” (start of line) before the regular expression,
    and “$” (end of line) after it. For example, “^a+$” only matches lines that have
    nothing but “a”s on them.
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some challenges to try to create regular expressions for:'
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
- en: local forms of non-personalised number plates (e.g. AB1234 or ABC123 in New
    Zealand)
  id: totrans-1749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: any extended form of the word “hello”, e.g. “helloooooooooooo”
  id: totrans-1750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: variants of “aaaarrrrrgggggghhhh”
  id: totrans-1751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a 24-hour clock time (e.g. 23:00) or a 12-hour time (e.g. 11:55 pm)
  id: totrans-1752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a bank account or credit card number
  id: totrans-1753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a credit card expiry date (must have 4 digits e.g 01/15)
  id: totrans-1754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a password that must contain at least 2 digits
  id: totrans-1755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a date
  id: totrans-1756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a phone number (choose your format e.g. mobile only, national numbers, or international)
  id: totrans-1757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a dollar amount typed into a banking website, which should accept various formats
    like “$21.43”, “$21”, “21.43”, and “$5,000”, but not “21$”, “21.5”, “5,0000.00”,
    and “300$”.
  id: totrans-1758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: acceptable identifiers in your programming language (usually something like
    a letter followed by a combination of letters, digits and some punctuation symbols)
  id: totrans-1759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an integer in your programming language (allow for + and - at the front, and
    some languages allow suffixes like L, or prefixes like 0x)
  id: totrans-1760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an IP address (e.g. 172.16.5.2 or 172.168.10.10:8080)
  id: totrans-1761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a MAC address for a device (e.g. e1:ce:8f:2a:0a:ba)
  id: totrans-1762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'postal codes for several countries e.g. NZ: 8041, Canada: T2N 1N4, US: 90210'
  id: totrans-1763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a (limited) http URL, such as “[http://abc.xyz](http://abc.xyz/)”, “[http://abc.xyz#conclusion](http://abc.xyz/#conclusion)”,
    “[http://abc.xyz?search=fgh](http://abc.xyz/?search=fgh)”.
  id: totrans-1764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.4.3\. PROJECT: CONVERTING REGULAR EXPRESSIONS TO FSAS'
  id: totrans-1765
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this project you will make up a regular expression, convert it to an FSA,
    and demonstrate how some [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) are
    processed.
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one trick you’ll need to know: the software we’re using doesn’t have
    all the notations we’ve been using above, which are common in programming languages,
    but not used so much in pure formal language theory. In fact, the only ones available
    are:'
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
- en: a* matches 0 or more repetitions of a
  id: totrans-1768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a|b matches a or b
  id: totrans-1769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (aa|bb)* Parentheses group commands together; in this case it gives a mixture
    of pairs of “a”s and pairs of “b”s.
  id: totrans-1770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having only these three notations isn’t too much of a problem, as you can get
    all the other notations using them. For example, “a+” is the same as “aa*”, and
    “\d” is “0|1|2|3|4|5|67|8|9”. It’s a bit more tedious, but we’ll mainly use exercises
    that only use a few characters.
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.3.1\. CONVERTING WITH EXORCISER
  id: totrans-1772
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use this section if you’re using Exorciser; if you’re using JFLAP then skip
    to [`](http://csfieldguide.org.nz/FormalLanguages.html#id8)Converting with JFLAP`~.
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: 'Exorciser is very simple. In fact, unless you change the default settings,
    it can only convert regular expressions using two characters: “a” and “b”. But
    even that’s enough (in fact, in theory any input can be represented with two characters
    — that’s what binary numbers are about!)'
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
- en: On the plus side, Exorciser has the empty [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) symbol
    available — if you type “e” it will be converted to ϵ. So, for example, “(a| ϵ)”
    means an optional “a” in the input.
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: To do this project using Exorciser, go to the start (“home”) window, and select
    the second link, “Regular Expression to Finite Automata Conversion”. Now type
    your[*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) into
    the text entry box that starts with “R =”.
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
- en: 'As a warmup, try:'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-1778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: then click on “solve exercise” (this is a shortcut — the software is intended
    for students to create their own FSA, but that’s beyond what we’re doing in this
    chapter).
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
- en: You should get a very simple FSA!
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
- en: To test your FSA, right-click on the background and choose “Track input”.
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
- en: Now try some more complex regular expressions, such as the following. For each
    one, type it in, click on “solve exercise”, and then track some sample inputs
    to see how it accepts and rejects different strings.
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-1783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Your project report should show the regular expressions, explain what kind of [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) they
    match, show the corresponding FSAs, show the sequence of states that some sample
    test [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) would
    go through, and you should explain how the components of the FSA correspond the
    parts of the [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) using
    examples.
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.3.2\. CONVERTING WITH JFLAP
  id: totrans-1785
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re using [JFLAP](http://www.jflap.org/) for your project, you can have
    almost any character as input. The main exceptions are “*”, “+” (confusingly,
    the “+” is used instead of “|” for alternatives), and ”!” (which is the empty [*string*]([http://csfieldguide.org.nz/appendices/Glossary.html#term-string](http://csfieldguide.org.nz/appendices/Glossary.html#term-string)) —
    in the preferences you can choose if it is shown as λ or ϵ).
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
- en: 'So the main operators available in JFLAP are:'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
- en: a* matches 0 or more repetitions of a
  id: totrans-1788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a+b matches a or b
  id: totrans-1789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (aa+bb)* Parentheses group commands together; in this case it gives a mixture
    of pairs of “a”s and pairs of “b”s.
  id: totrans-1790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JFLAP software can work with all sorts of formal languages, so you’ll need
    to ignore a lot of the options that it offers! This section will guide you through
    exactly what to do.
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
- en: There are some details about the format that JFLAP uses for regular expressions
    in the following tutorial — just read the “Definition” and “Creating a regular
    expression” sections.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.jflap.org/tutorial/regular/index.html](http://www.jflap.org/tutorial/regular/index.html)'
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: 'As a warmup, we’ll convert this regex to an FSA:'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-1795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'On the main control window of JFLAP click on “Regular Expression”, and type
    your [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) into
    JFLAP:'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3713b5d.png)'
  id: totrans-1797
  prefs: []
  type: TYPE_IMG
- en: 'From the “Convert” menu choose “Convert to NFA”. This will only start the conversion;
    press the “Do all” button to complete it (the system is designed to show all the
    steps of the conversion, but we just want the final result). For the example,
    we get the following non-deterministic finite automaton (NFA), which isn’t quite
    what we want and probably looks rather messy:'
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada364e398.png)'
  id: totrans-1799
  prefs: []
  type: TYPE_IMG
- en: 'We need a DFA (deterministic FA), not an NFA. To convert the NFA to a DFA,
    press the “Export” button, then from the “Convert” menu, choose “Convert to DFA”,
    press the “Complete” button to complete the conversion, and then the “Done?” button,
    which will put it in a new window:'
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada35ade1e.png)'
  id: totrans-1801
  prefs: []
  type: TYPE_IMG
- en: We’re nearly there. If it’s hard to read the FSA, you can move states around
    by choosing the arrow tool (on the left of the tool bar — if the states won’t
    move when you grab them, so make sure you click on the arrow icon before trying
    to move them). The states may have some extraneous labels underneath them; you
    can hide those by selecting the arrow tool, right-click on the white part of the
    window and un-check “Display State Labels”.
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3538e8b.png)'
  id: totrans-1803
  prefs: []
  type: TYPE_IMG
- en: If the FSA is simple enough, it may be just as easy if you now copy the diagram
    by hand and try to set it out tidily yourself, otherwise you can save it as an
    image to put into your project.
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: Now try some sample inputs. The starting state is labeled q0 and will have a
    large arrow pointing at it. You can get JFLAP to run through some input for you
    by using the “Input” menu. “Step by state” will follow your input state by state,
    “Fast run” will show the sequence of states visited for your input, and “Multiple
    run” allows you to load a list of [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) to
    test.
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple runs are good for showing lots of tests on your regular expression:'
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada3483649.png)'
  id: totrans-1807
  prefs: []
  type: TYPE_IMG
- en: For example, “ab” is rejected because it would only get to state 2.
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
- en: Now you should come up with your own regular expressions that test out interesting
    patterns, and generate FSA’s for them. In JFLAP you can create FSAs for some of
    regular expressions we used earlier, such as (simple) dates, email addresses or
    URLs.
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
- en: Your project report should show the regular expressions, explain what kind of [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) they
    match, show the corresponding FSAs, show the sequence of states that some sample
    test [*strings*](http://csfieldguide.org.nz/appendices/Glossary.html#term-strings) would
    go through, and you should explain how the components of the FSA correspond to
    the parts of the [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) using
    examples.
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
- en: 12.4.4\. OTHER IDEAS FOR PROJECTS AND ACTIVITIES
  id: totrans-1811
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some more ideas that you could use to investigate regular expressions:'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
- en: 'On the [regexdict site](http://www.visca.com/regexdict/), read the instructions
    on the kinds of [*pattern matching*](http://csfieldguide.org.nz/appendices/Glossary.html#term-pattern-matching) it
    can do, and write regular expressions for finding words such as:'
  id: totrans-1813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: words that contain “aa”
  id: totrans-1814
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: all words with 3 letters
  id: totrans-1815
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: all words with 8 letters
  id: totrans-1816
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: all words with more than 8 letters
  id: totrans-1817
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: words that include the letters of your name
  id: totrans-1818
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: words that are made up *only* of the letters in your name
  id: totrans-1819
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: words that contain all the vowels in reverse order
  id: totrans-1820
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: words that you can make using only the notes on a piano (i.e the letters A to
    G and a to g)
  id: totrans-1821
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: words that are exceptions to the rule “i before e except after c” — make sure
    you find words like “forfeit” as well as “science”.
  id: totrans-1822
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Word’s *Find* command uses regular expressions if you select the “Use
    wildcards” option. For more details see [Graham Mayor](http://word.mvps.org/AboutMVPs/graham_mayor.htm)‘s [Finding
    and Replacing Characters using Wildcards](http://word.mvps.org/FAQs/General/UsingWildcards.htm).
  id: totrans-1823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore regular expressions in spreadsheets. The Google docs spreadsheet has
    a function called RegExMatch, RegExExtract and RegExReplace. In Excel they are
    available via Visual Basic.
  id: totrans-1824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knitting patterns are a form of regular expression. If you’re interested in
    knitting, you could look into how they are related through the [article about
    knitting and regular expressions at CS4FN site](http://www.cs4fn.org/regularexpressions/knitters.php).
  id: totrans-1825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chesapeake NetCraftsmen site provides [a system for practising writing regular
    expressions](http://www.netcraftsmen.net/presos/Regex_Practice/player.html).
  id: totrans-1826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “grep” command is available in many command line systems, and matches a [*regular
    expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) in
    the command with lines in an input file. (the name comes from “Global Regular
    Expression Parser”). Demonstrate the grep command for various regular expressions.
  id: totrans-1827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions for matching against regular expressions appear in most programming
    languages. If your favourite language has this feature, you could demonstrate
    how it works using sample regular expressions and strings.
  id: totrans-1828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advanced: The free tools *lex* and *flex* are able to take specifications for
    regular expressions and create programs that parse input according to the rules.
    They are commonly used as a front end to a compiler, and the input is a program
    that is being compiled. You could investigate these tools and demonstrate a simple
    implementation.'
  id: totrans-1829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.5\. GRAMMARS AND PARSING
  id: totrans-1830
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Warning
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
- en: this section hasn’t been written yet; the material below is just an introduction
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
- en: With unusual [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) Yoda
    from Star Wars speaks. Yet still understand him, people can. The flexibility of
    the rules of English [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) mean
    that you can usually be understood if you don’t get it quite right, but it also
    means that the rules get very complicated and difficult to apply.
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
- en: Grammars in formal languages are much more predictable than grammars in human
    languages — that’s why they’re called formal languages! When you’re doing English, [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) can
    be a tricky topic because not only are there are so many rules, but there are
    also so many exceptions — for example, you need an apostrophe if you write “the
    computer’s USB port”, but you have to leave it out if you say “its USB port”.
    Grammars in computer science are mainly used to specify programming languages
    and file formats, and compilers make a fuss even if you leave out just one bracket
    or comma! But at least they’re predictable.
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
- en: In this section we’ll look at the kind of grammars that are widely used in computer
    science. They are very powerful because they allow a complicated system (like
    a compiler or a format like HTML) to be specified in a very concise way, and there
    are programs that will automatically take the [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) and
    build the system for you. The grammars for conventional programming languages
    are a bit too unwieldy to use as initial examples (they usually take a few pages
    to write out), so we’re going to work with some small examples here, including
    parts of the grammars for programming languages.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: the remainder of this section will be developed during 2013.'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
- en: 12.5.1\. PROJECT IDEAS
  id: totrans-1837
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (Note that these will make more sense when the previous introduction to grammars
    has been completed!)
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrate how compilers, interpreters, parsers or validators find errors in
    formal languages e.g. introduce an error to a compiled program, XML document file
    or web page, and show the effect of the error.
  id: totrans-1839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) for
    a programming language, and show how a sample program would be parsed using the
    grammar.
  id: totrans-1840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use examples to show the [*parse tree*](http://csfieldguide.org.nz/appendices/Glossary.html#term-parse-tree) (or [*syntax*](http://csfieldguide.org.nz/appendices/Glossary.html#term-syntax) tree)
    for a correct and incorrect program fragment, or to show a sequence of [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) productions
    to construct a correct program fragment
  id: totrans-1841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore the [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) for
    balanced parentheses S -> SS, S -> (S), S -> ( )
  id: totrans-1842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) for
    a simple arithmetic expression in a programming language, and show the [*parse
    tree*](http://csfieldguide.org.nz/appendices/Glossary.html#term-parse-tree) for
    sample expressions (such as (a+b)*(c-d) ).
  id: totrans-1843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '12.5.2\. PROJECTS: GRAMMARS IN ART AND MUSIC'
  id: totrans-1844
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](563ada33db744.png)'
  id: totrans-1845
  prefs: []
  type: TYPE_IMG
- en: The *context free art* program ( [http://www.contextfreeart.org/](http://www.contextfreeart.org/) )
    enables you to specify images using a context-free grammar. For example, the following
    pictures of trees are defined by just a few rules that are based around a forest
    being made of trees, a tree being made of branches, and the branches in turn being
    made of branches themselves! These simple definitions can create images with huge
    amounts of detail because the drawing process can break down the [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) into
    as many levels as required. You can define your own grammars to generate images,
    and even make a movie of them being created, like the one below. Of course, if
    you do this as a project make sure you understand how the system works and can
    explain the formal language behind your creation.
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
- en: 'The JFLAP program that we have been using also has a feature for rendering
    “L-systems” ([http://en.wikipedia.org/wiki/L-system](http://en.wikipedia.org/wiki/L-system)),
    which are another way to use grammars to create structured images. You’ll need
    to read about how they work in the JFLAP tutorial (www.jflap.org/tutorial/index.html),
    and there’s a more detailed tutorial at [http://www.cs.duke.edu/csed/pltl/exercises/lessons/20/L-system.zip](http://www.cs.duke.edu/csed/pltl/exercises/lessons/20/L-system.zip).
    There are some sample files here to get you inspired: (the ones starting “ex10...”
    www.cs.duke.edu/csed/jflap/jflapbook/files/ ) and here’s an example of the kind
    of image that can be produced:'
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ada31b0e86.png)'
  id: totrans-1848
  prefs: []
  type: TYPE_IMG
- en: A tree drawn using L-systems in JFLAP
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
- en: There’s also an online system for generating images with L-systems: [http://www.kevs3d.co.uk/dev/lsystems/](http://www.kevs3d.co.uk/dev/lsystems/)
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
- en: 'Grammars have been used for music notation:'
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
- en: The following is the BNF [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) for
    the ABC music format: [http://www.norbeck.nu/abc/bnf/abc20bnf.htm](http://www.norbeck.nu/abc/bnf/abc20bnf.htm)
  id: totrans-1852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://abc.sourceforge.net/](http://abc.sourceforge.net/)'
  id: totrans-1853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://meta.wikimedia.org/wiki/Music_markup](https://meta.wikimedia.org/wiki/Music_markup)'
  id: totrans-1854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.emergentmusics.org/theory/15-implementation](http://www.emergentmusics.org/theory/15-implementation)'
  id: totrans-1855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: analyse a simple piece of music in terms of a formal grammar.
  id: totrans-1856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12.6\. THE WHOLE STORY!
  id: totrans-1857
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you found the material in this chapter interesting, here are some topics
    that you might want to look into further, as we’ve only just scratched the surface
    of what can be done with formal languages.
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
- en: Formal languages come up in various areas of computer science, and provide invaluable
    tools for the computer scientist to reduce incredibly complex systems to a small
    description, and conversely to create very complex systems from a few simple rules.
    They are essential for writing compilers, and so are activated every time someone
    writes a program! They are also associated with automata theory and questions
    relating to computability, and are used to some extent in natural language processing,
    where computers try to make sense of human languages.
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
- en: Technically the kind of finite state automata (FSA) that we used in [Finite
    state automata](http://csfieldguide.org.nz/FormalLanguages.html#finite-state-automata) section
    is a kind known as a *Deterministic Finite Automata* (DFA), because the decision
    about which transition to take is unambiguous at each step. Sometimes it’s referred
    to as a *Finite State Acceptor* because it accepts and rejects input depending
    on whether it gets to the final state. There are all sorts of variants that we
    didn’t mention, including the Mealy and Moore machines (which produce an output
    for each each transition taken or state reached), the nested state machine (where
    each state can be an FSA itself), the non-deterministic finite automata (which
    can have the same label on more than one transition out of a state), and the lambda-NFA
    (which can include transitions on the empty string, λ). Believe it or not, all
    these variations are essentially equivalent, and you can convert from one to the
    other. They are used in a wide range of practical situations to design systems
    for processing input.
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
- en: However, there are also more complex models of computation such as the push-down
    automaton (PDA) which is able to follow the rules of context-free grammars, and
    the most general model of computation which is called a Turing machine. These
    models are increasingly complicated and abstract, and structures like the Turing
    machine aren’t used as physical devices (except for fun), but as a tool for reasoning
    about the limits on what can be computed.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
- en: The Turing machine is named after Alan Turing, who worked on these concepts
    in the early 20th century (that’s the same person from whom we got the Turing
    test in AI, which is something quite different — Turing’s work comes up in many
    areas of computer science!) If you want to investigate the idea of a Turing machine
    and you like chocolate, there’s [an activity on the cs4fn site](http://www.cs4fn.org/turing/turingmachines.php) that
    gives examples of how it works. The Kara programming environment also has a [demonstration
    of Turing machines](http://www.swisseduc.ch/compscience/karatojava/turingkara/)
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter looked at two main kinds of formal language: the [*regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression) (RE)
    and the context-free [*grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar) (CFG).
    These typify the kinds of languages that are widely used in compilers and file
    processing systems. Regular expressions are good for finding simple patterns in
    a file, like identifiers, keywords and numbers in a program, or tags in an HTML
    file, or dates and URLs in a web form. Context-free grammars are good when you
    have nested structures, for example, when an expression is made up of other expressions,
    or when an “if” statement includes a block of statements, which in turn could
    be “if” statements, ad infinitum. There are more powerful forms of grammars that
    exist, the most common being context-sensitive grammars and unrestricted grammars,
    which allow you to have more than one non-terminal on the left hand side of a
    production; for example, you could have xAy → aBb, which is more flexible but
    a lot harder to work with. The relationships between the main kinds of grammars
    was described by the linguist Noam Chomsky, and is often called the [*Chomsky
    Hierarchy*](http://csfieldguide.org.nz/appendices/Glossary.html#term-chomsky-hierarchy) after
    him.'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
- en: There is a direct correspondence between the “machines” (such as the FSA) and
    languages (such as the Regular Expression), as each increasingly complex language
    needs the correspondingly complex machine to process it. For example, an FSA can
    be used to determine if the input matches a given Regular Expression, but a PDA
    is needed to match a [*string*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string) to
    a CFG. The study of formal languages looks at these relationships, and comes up
    with ways to create the appropriate machines for a given language and vice versa.
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
- en: There are many tools available that will read in the specification for a language
    and produce another program to parse the language; some common ones are called
    “Lex” and “Flex” (both perform lexical anaylsis of regular expressions), “Yacc”
    (“yet another compiler compiler”) and “Bison” (an improved version of Yacc). These
    systems make it relatively easy to make up your own programming language and construct
    a compiler for it, although they do demand quite a range of skills to get the
    whole thing working!
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
- en: So we’ve barely got started on what can be done with formal languages, but the
    intention of this chapter is to give you a taste of the kind of structures that
    computer scientists work with, and the powerful tools that have been created to
    make it possible to work with infinitely complex systems using small descriptions.
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
- en: 12.7\. GLOSSARY
  id: totrans-1867
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s a list of the main terms and concepts that come up in this chapter.
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
- en: '[*Alphabet*](http://csfieldguide.org.nz/appendices/Glossary.html#term-alphabet)'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
- en: '[*String*](http://csfieldguide.org.nz/appendices/Glossary.html#term-string)'
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
- en: '[*Finite state automaton*](http://csfieldguide.org.nz/appendices/Glossary.html#term-finite-state-automaton)'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
- en: '[*Regular expression*](http://csfieldguide.org.nz/appendices/Glossary.html#term-regular-expression)'
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
- en: '[*Pattern matching*](http://csfieldguide.org.nz/appendices/Glossary.html#term-pattern-matching)'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
- en: '[*Lexical analysis*](http://csfieldguide.org.nz/appendices/Glossary.html#term-lexical-analysis)'
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
- en: '[*Grammar*](http://csfieldguide.org.nz/appendices/Glossary.html#term-grammar)'
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
- en: '[*Parsing*](http://csfieldguide.org.nz/appendices/Glossary.html#term-parsing)'
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
- en: '[*Parse tree*](http://csfieldguide.org.nz/appendices/Glossary.html#term-parse-tree)'
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
- en: '[*Syntax*](http://csfieldguide.org.nz/appendices/Glossary.html#term-syntax)'
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
- en: '[*Syntax diagram*](http://csfieldguide.org.nz/appendices/Glossary.html#term-syntax-diagram)'
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
- en: '[*Syntactically correct*](http://csfieldguide.org.nz/appendices/Glossary.html#term-syntactically-correct)'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chomsky hierarchy*](http://csfieldguide.org.nz/appendices/Glossary.html#term-chomsky-hierarchy)'
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
- en: 12.8\. FURTHER READING
  id: totrans-1882
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the material in this chapter was inspired by [http://www.ccs3.lanl.gov/mega-math/workbk/machine/malearn.html](http://www.ccs3.lanl.gov/mega-math/workbk/machine/malearn.html)
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
- en: There’s a good article on finite state machines at [http://www.i-programmer.info/babbages-bag/223-finite-state-machines.html](http://www.i-programmer.info/babbages-bag/223-finite-state-machines.html)
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
- en: Textbooks on formal languages will have considerably more advanced material
    and more mathematical rigour than could be expected at High School level, but
    for students who really want to read more, a popular book is “Introduction to
    the Theory of Computation” by Michael Sipser.
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions and their relationship with FSAs is explained well in the
    book “Algorithms” by Robert Sedgewick.
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
- en: 12.8.1\. USEFUL LINKS
  id: totrans-1887
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Formal_language](http://en.wikipedia.org/wiki/Formal_language)'
  id: totrans-1888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Context-free_grammar#Examples](http://en.wikipedia.org/wiki/Context-free_grammar#Examples)'
  id: totrans-1889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Abstract_syntax_tree](http://en.wikipedia.org/wiki/Abstract_syntax_tree)'
  id: totrans-1890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Regular_expression](http://en.wikipedia.org/wiki/Regular_expression)'
  id: totrans-1891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://csunplugged.org/finite-state-automata](http://csunplugged.org/finite-state-automata)'
  id: totrans-1892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.i-programmer.info/babbages-bag/223-finite-state-machines.html](http://www.i-programmer.info/babbages-bag/223-finite-state-machines.html)'
  id: totrans-1893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.jflap.org/](http://www.jflap.org/)'
  id: totrans-1894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Deterministic_finite_automaton](http://en.wikipedia.org/wiki/Deterministic_finite_automaton)'
  id: totrans-1895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Finite-state_machine](http://en.wikipedia.org/wiki/Finite-state_machine)'
  id: totrans-1896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13\. COMPUTER GRAPHICS
  id: totrans-1897
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 13.1\. WHAT’S THE BIG PICTURE?
  id: totrans-1898
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computer graphics will be familiar from games, films and images, and there is
    amazing software available to create images, but how does the software work? The
    role of a computer scientist is not just to *use* graphics systems, but to *create* them,
    and especially invent new techniques.
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
- en: The entertainment industry is always trying to develop new graphics software
    so that they can push the boundaries and create new experiences. We’ve seen this
    in the evolution of animated films, from simple 2D films to realistic computer
    generated movies with detailed 3D images.
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
- en: Movie and gaming companies can’t always just use existing software to make the
    next great thing — they need computer scientists to come up with better graphics
    techniques to make something that’s never been seen before. The creative possibilities
    are endless!
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
- en: 'Computer graphics are used in a wide variety of situations: games and animated
    movies are common examples, but graphics techniques are also used to visualise
    large amounts of data (such as all cellphone calls being made in one day), to
    display and animate graphical user interfaces, to create virtual reality and augmented
    reality worlds, and much more.'
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll look at some of the basic techniques that are used to
    create computer graphics. These will give you an idea of the techniques that are
    used in graphics programming, although it’s just the beginning of what’s possible.
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter we are using a system called WebGL which can render 3D graphics
    in your browser. If your browser is set up correctly then you should see a teapot
    on the right, and you can click the “animate” button to make it rotate. If this
    doesn’t work, or if the performance is poor, there is [information here about
    how to get it going](http://csfieldguide.org.nz/appendices/Interactives.html) .
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
- en: 13.2\. GRAPHICS TRANSFORMS
  id: totrans-1905
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A computer graphics image is just the result of a whole lot of mathematical
    calculations. In fact, every pixel you see in an image has typically had many
    calculations made to work out what colour it should be, and there are often millions
    of pixels in a typical image.
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with some simple but common calculations that are needed for in
    graphics programming. The following image shows a cube with writing on each face.
    You can move it around using what’s called a *transform*, which simply adjusts
    where it is placed in space.
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
- en: In this example the only transforms we've supplied are to *translate* it in
    three dimensions. The dimensions are *x* (left and right), *y* (up and down) and *z* (in
    and out of the screen). Your goal is to type in how far it should be transformed
    in each of these directions so that you can see the symbol on each face, and put
    those symbols on the spinner wheels shown. (The order of the symbols doesn't matter).
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb44b57c0.png)Click to load the widget](http://csfieldguide.org.nz/ComputerGraphics.html)'
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
- en: You’ve just applied 3D *translation transforms* to the cube. Translation just
    means moving it in the three dimensions up and down, forward and back, and sideways.
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
- en: Another common transform is *rotation*, which you can use in the following image
    to find the symbols (the rotation is measured in degrees).
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb432ff18.png)Click to load the widget](http://csfieldguide.org.nz/ComputerGraphics.html)'
  id: totrans-1912
  prefs: []
  type: TYPE_NORMAL
- en: There are several transformations that are used in computer graphics, but the
    most common ones are translation (moving the object), rotation (spinning it) and
    scaling (changing its size). They come up often in graphics because they are applied
    not only to objects, but to things like the positions of the camera and lighting
    sources.
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
- en: In this section you can apply transformations to various images. We’ll start
    by making the changes manually, one point at a time, but we’ll move up to a quick
    shortcut method that uses a *matrix* to do the work for you. We’ll start by looking
    at how these work in two dimensions - it’s a bit easier to think about than three
    dimensions.
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
- en: The following interactive shows an arrow, and on the right you can see a list
    of the points that correspond to its 7 corners. The arrow is on a grid (usually
    referred to as *cartesian coordinates* ), where the centre point is the “zero”
    point. Points are specified using two numbers, *x* and *y*, usually written as
    (*x*,*y*). The *x* value is how far the point is to the right of the centre and
    the *y* value is how far above the centre it is. For example, the first point
    in the list is the tip at (0,2), which means it’s 0 units to the right of the
    centre (i.e. at the centre), and 2 units above it. Which point does the last pair
    (2,0) correspond to? What does it mean if a coordinate has a negative*x* value?
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
- en: The first list of coordinates is for the original arrow position, and in the
    second list, you can type in the transformed points to move the arrow — the original
    is shown in green and the moved one is in blue.
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb42a8311.png)Click to load the widget](http://csfieldguide.org.nz/ComputerGraphics.html)'
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
- en: Your first challenge is to add 2 to all the *x* points, and 3 to all the *y* points
    (you can either type the new number or put the calculation in the box e.g. "0.5+2".
    What effect does this have on the original arrow? (Be careful to add the negative
    numbers correctly; for example, adding 2 to -0.5 gives 1.5.) What happens if you
    subtract 3 from each of the original coordinate values?
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
- en: The above transform is called a *translation* — it translates the arrow around
    the grid. This kind of transform is used in graphics to specify where an object
    should be placed in a scene, but it has many other uses, such as making an animated
    object move along a path, or specifying the position of the imaginary camera (viewpoint).
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
- en: In this next interactive, try replacing the coordinates in the second list with
    all the original values multiplied by 2\. What is the effect of this transform?
    What would happen if you multiply each value by 10? How about 0.5? What if you
    only multiply the *x* values?
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb421efcc.png)Click to load the widget](http://csfieldguide.org.nz/ComputerGraphics.html)'
  id: totrans-1921
  prefs: []
  type: TYPE_NORMAL
- en: This transformation is called *scaling*, and although it can obviously be used
    to control the size of an object, this can in turn be used to create a visual
    effect such as making the object appear closer or further away.
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
- en: Try to get the blue arrow to match up with the red one. It will require a mixture
    of scaling and translation.
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb419514b.png)Click to load the widget](http://csfieldguide.org.nz/ComputerGraphics.html)'
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
- en: Next, see what happens if you swap the *x* and *y* value for each coordinate.
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb4128f87.png)Click to load the widget](http://csfieldguide.org.nz/ComputerGraphics.html)'
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple *rotation* transformation, also useful for positioning objects
    in a scene, but also for specifying things like camera angles.
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.1\. MATRIX TRANSFORMS
  id: totrans-1928
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s a much easier way to specify transformations than having to change
    each coordinate separately. Transformations are usually done in graphics using *matrix*arithmetic,
    which is a shorthand notation for doing lots of simple arithmetic operations in
    one go. The matrix for the two-dimensional transformations we’ve been doing above
    has four values in it. For the 2 dimensional scaling transform where we made each *x* and *y* value
    twice as large, the matrix is written as:'
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
- en: '[2002]'
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
- en: You can type this matrix into the following interactive to see what it does
    (replace the ones with twos). The top left-hand value just means multiply all
    the *x* values by 2, and the bottom right one means multiply all the *y* values
    by 2\. For the meantime, leave the other two values as 0.
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb40998c1.png)'
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
- en: (At this stage you may want to have the widget open in a separate window so
    that you can read the text below and interact with the widget at the same time.)
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
- en: Now try changing the matrix to
  id: totrans-1935
  prefs: []
  type: TYPE_NORMAL
- en: '[3003]'
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
- en: or
  id: totrans-1937
  prefs: []
  type: TYPE_NORMAL
- en: '[0.2000.2]'
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
- en: The “add translate” values in the interactive are added to each *x* and *y* coordinate;
    experiment with them to see what they do. Now try to find suitable values for
    these and the matrix to match the arrow up with the red one.
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
- en: What happens if you use the following matrix?
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
- en: '[2004]'
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try the following matrix:'
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
- en: '[0110]'
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
- en: This matrix should have rotated the arrow to the right.
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple way of looking at the matrix is that the top row determines the transformed *x* value,
    simply by saying how much of the original *x* value and *y* value contribute to
    the new *x* value. So in the matrix:'
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
- en: '[2004]'
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
- en: 'the top row just means that the new *x* value is 2 lots of the original *x*,
    and none of the original y, which is why all the *x* values double. The second
    row determines the *y*value: in the above example, it means that the new *y* value
    uses none of the original x, but 4 times the original *y* value. If you try this
    matrix, you should find that the location of all the *x* points is doubled, and
    the location of all the y points is multiplied by 4.'
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
- en: That now explains the [0110] matrix. The new *x* value has none of the original *x*,
    but exactly the original *y* value, and vice versa. This swaps all the *x* and *y*coordinates,
    which is the same as rotating the object to the right.
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
- en: 'Where it gets interesting is when you use a little of each value; try the following
    matrix:'
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
- en: '[0.7−0.70.70.7]'
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
- en: Now the *x* value of each coordinate is a mixture of 0.7 of the original *x*,
    and 0.7 of the original *y*.
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, to rotate an image by a given angle you need to use the sine (abbreviated
    sin) and cosine (abbreviated cos) functions from trigonometry. To rotate the image
    by Θ degrees, you’ll need the following values in the matrix, which rely on trig
    functions:'
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
- en: '[cos(θ)sin(θ)−sin(θ)cos(θ)]'
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
- en: You can type these calculations directly into the interactive - if you type
    cos(60) it will work out the cosine of 60 degrees for you, which happens to be
    exactly 0.5\. Or you can just type in the sin and cosine values; the 0.7 numbers
    in the matrix above are just the values for sin(45) and so on (or at least, they
    approximately the value; it's actually 0.70710678..., which happens to be the
    square root of 0.5, but 0.7 is close enough for our example).
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb4007956.png)'
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
- en: What is the matrix for rotation by 360 degrees?
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
- en: 'The general matrix for *scaling* is a bit simpler; if you want to scale by
    a factor of *s*, then you just use the matrix:'
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
- en: '[s00s]'
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
- en: A translation can’t be specified by this kind of matrix, but in the interactives
    we’ve provided an extra place to specify an *x* and *y* value to translate the
    input.
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
- en: Try translating the original arrow so that it matches up with the red arrow.
  id: totrans-1961
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3f4b0d7.png)'
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
- en: Now try to scale the original arrow in the following, and translate it to match
    the red arrow.
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3e7a0c1.png)'
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
- en: The following interactive has the translation and scaling the other way around.
    Use this one to transform the blue arrow to the red arrow. The order in which
    the operations happen makes a difference!
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3dc5719.png)'
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
- en: In the above, you’ll have noticed that scaling is affected by how far the object
    is from the centre. If you want to scale around a fixed point in the object (so
    it expands where it is), then an easy way is to translate it back to the centre
    (also called the *origin*), scale it, and then translate it back to where it was.
    The following interactive allows you to move the arrow, then scale it, and move
    it back.
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
- en: The tip is at (-8,7), so you should translate it to (0,0), scale by 2, and translate
    back to (-8, 7).
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3d00240.png)'
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
- en: The same problem comes up with rotation.
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
- en: Try rotating this image by 45 degrees.You'll need to translate the tip to the
    origin, apply the rotation, and translate it back.
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3c67015.png)'
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
- en: The following two examples combine rotation, scaling and translation. You can
    use multiple matrices (that’s the plural of matrix) to match up the target object
    — the product of each matrix becomes the input to the next one. Oh, and the arrow
    is twice as fat, but still the same hight (from base to tip).
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
- en: Try matching the blue arrow to the red one using two matrices (one to scale
    and one to rotate), and adding a vector.
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3bd2e49.png)'
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
- en: You will need to use all three operations to do this next one.
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3b4780a.png)'
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
- en: These combined transformations are common, and they might seem like a lot of
    work because each matrix has to be applied to every point in an object. Our arrows
    only had 7 points, but complex images can have thousands or even millions of points
    in them. Fortunately we can combine all the matrix operations in advance to give
    just one operation to apply to each point.
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.2\. COMBINING TRANSFORMATIONS
  id: totrans-1986
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Several transforms being applied to the same image can be made more efficient
    by creating one matrix that has the effect of all the transforms combined.The
    combination is done by “multiplying” all the matrices.
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplying two matrices can’t be done by just multiplying the corresponding
    elements; if you are multiplying two matrices with the *a* and *b* values shown
    below, the resulting values from the multiplication are calculated as follows:'
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
- en: '[a11a12a21a22]'
  id: totrans-1989
  prefs: []
  type: TYPE_NORMAL
- en: \times
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
- en: '[b11b12b21b22]'
  id: totrans-1991
  prefs: []
  type: TYPE_NORMAL
- en: '='
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
- en: '[a11b11+a21b12a12b11+a22b12a11b21+a21b22a12b21+a22b22]'
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
- en: It’s a bit complicated, but this calculation is only done once to work out the
    combined transformation, and it gives you a single matrix that will provide to
    transforms in one operations.
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
- en: 'As a simple example, consider what happens when you scale by 2 and then rotate
    by 45 degrees. The two matrices to multiply work out like this:'
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
- en: '[2002]'
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
- en: \times
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
- en: '[0.7−0.70.70.7]'
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
- en: '='
  id: totrans-1999
  prefs: []
  type: TYPE_NORMAL
- en: '[2×0.7+0×−0.70×0.7+2×−0.72×0.7+0×0.70×0.7+2×0.7]'
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
- en: '='
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
- en: '[1.4−1.41.41.4]'
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
- en: Try putting in the final matrix here and see if it does scale by 2 and rotate
    by 45 degrees.
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3ab20ff.png)'
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
- en: Now try multiplying two other transform matrices that you make up yourself,
    and see if they produce the expected result.
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3a39d3a.png)'
  id: totrans-2007
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
- en: In computer graphics systems there can be many transformations combined, and
    this is done by multiplying them all together (two at a time) to produce one matrix
    that does all the transforms in one go. That transform might then be applied to
    millions of points, so the time taken to do the matrix multiplication at the start
    will pay off well.
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
- en: The project below gives the chance to explore combining matrices, and has an
    interactive that will calculate the multiplied matrices for you.
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.3\. 3D TRANSFORMS
  id: totrans-2011
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far we’ve just done the transforms in two dimensions. To do this in 3D, we
    need a *z* coordinate as well, which is the depth of the object into the screen.
    A matrix for operating on 3D points is 3 by 3\. For example, the 3D matrix for
    doubling the size of an object is as follows; it multiplies each of the *x*, *y* and *z* values
    of a point by 2.
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
- en: ⎡⎣⎢200020002⎤⎦⎥
  id: totrans-2013
  prefs: []
  type: TYPE_NORMAL
- en: In this interactive, try changing the scaling on the image (it starts with a
    scaling factor of 10 in all three dimensions).
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb3866882.png)'
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
- en: The above image mesh has 3644 points in it, and your matrix was applied to each
    one of them to work out the new image.
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
- en: Translation requires 3 values, which are added to the *x*, *y* and *z* coordinates
    of each point in an object.
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
- en: In the following interactive, try moving the teapot left and right ( *x* ),
    up and down ( *y* ), and in and out of the screen ( *z* ) by adding a “vector”
    to the operations. Then try combining all three.
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb369b536.png)'
  id: totrans-2020
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
- en: Rotation is trickier because you can now rotate in different directions. In
    2D rotations were around the centre (origin) of the grid, but in 3D rotations
    are around a line (either the horizontal x-axis, the vertical y-axis, or the z-axis,
    which goes into the screen!)
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
- en: 'The rotation we used earlier can be applied to 3 dimensions using this matrix:'
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
- en: ⎡⎣⎢cos(θ)sin(θ)0−sin(θ)cos(θ)0001⎤⎦⎥
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
- en: Try applying that to the image above. This is rotating around the z-axis (a
    line going into the screen); that is, it’s just moving the image around in the
    2D plane. It’s really the same as the rotation we used previously, as the last
    line (0, 0, 1) just keeps the z point the same.
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following matrix, which rotates around the x-axis (notice that the
    x value always stays the same because of the 1,0,0 in the first line):'
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
- en: ⎡⎣⎢1000cos(θ)sin(θ)0−sin(θ)cos(θ)⎤⎦⎥
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
- en: 'And this one for the y-axis:'
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
- en: ⎡⎣⎢cos(θ)0−sin(θ)010sin(θ)0cos(θ)⎤⎦⎥
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
- en: The following interactive allows you to combine 3D matrices.
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
- en: You can experiment with moving the teapot around in space, changing its size,
    and angle.
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
- en: Think about the order in which you need to combine the transforms to get a particular
    image that you want.
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you translate an image and then scale it, you’ll get a different
    effect to scaling it then translating it. If you want to rotate or scale around
    a particular point, you can do this in three steps (as with the 2D case above):
    (1) translate the object so that the point you want to scale or rotate around
    is the origin (where the x, y and z axes meet), (2) do the scaling/rotation, (3)
    translate the object back to where it was. If you just scale an object where it
    is, its distance from the origin will also be scaled up.'
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb34825ff.png)'
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
- en: Click here for the interactive to combine multiple transforms into one](http://csfieldguide.org.nz/ComputerGraphics.html)
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
- en: In the above examples, when you have several matrices being applied to every
    point in the image, a lot of time can be saved by converting the series of matrices
    and transforms to just one formula that does all of the transforms in one go.
    The following interactive can do those calculations for you.
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the following interactive, type in the matrix for doubling the
    size of an object (put the number 2 instead of 1 on the main diagonal values),
    then add another matrix that triples the size of the image (3 on the main diagonal).
    The interactive shows a matrix on the right that combines the two — does it look
    right?
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
- en: Multiple transforms
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb33ec59d.png)'
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
- en: The interactive also allows you to combine in translations (just three numbers,
    for x, y and z). Try combining a scaling followed by a translation. What if you
    add a rotation — does the order matter?
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
- en: In case you’re wondering, the interactive is using the following formula to
    combine two matrices (you don’t have to understand this to use it). It is called
    matrix multiplication, and while it might be a bit tricky, it’s very useful in
    computer graphics because it reduces all the transformations you need to just
    one matrix, which is then applied to every point being transformed. This is way
    better than having to run all the matrices of every point.
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
- en: '13.2.4\. PROJECT: 3D TRANSFORMS'
  id: totrans-2043
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this project, you will demonstrate what you’ve learned in the section above
    by explaining a 3D transformation of a few objects. You should take screenshots
    of each step to illustrate the process for your report.
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
- en: The following scene-creation interactive allows you to choose objects (and their
    colours etc.), and apply one transformation to them. To position them more interestingly,
    you will need to come up with multiple transformations (e.g. scale, then rotate,
    then translate), and use the “simplifier” interactive to combine all the matrices
    into one operation.
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
- en: 'The scene-creation interactive can be run from here:'
  id: totrans-2046
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb31a48f0.png)'
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate combined transformations, you can use the following transform simplifier
    interactive:'
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb2c15684.png)'
  id: totrans-2050
  prefs: []
  type: TYPE_NORMAL
- en: Click to load the widget.](http://csfieldguide.org.nz/ComputerGraphics.html)
  id: totrans-2051
  prefs: []
  type: TYPE_NORMAL
- en: Because you can’t save your work in the interactives, keep notes and screen
    shots as you go along. These will be useful for your report, and also can be used
    if you need to start over again.
  id: totrans-2052
  prefs: []
  type: TYPE_NORMAL
- en: Introduce your project with a examples of 3D images, and how they are used (perhaps
    from movies or scenes that other people have created). Describe any innovations
    in the particular image (e.g. computer generated movies usually push the boundaries
    of what was previously possible, so discuss what boundaries were moved by a particular
    movie, and who wrote the programs to achieve the new effects).
  id: totrans-2053
  prefs: []
  type: TYPE_NORMAL
- en: For your project, try putting a few objects in a particular arrangement (e.g.
    with the teapot sitting beside some cups), and explain the transforms needed to
    achieve this, showing the matrices needed.
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
- en: Give simple examples of translation, scaling *and* rotation using your scene.
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
- en: You should include multiple transforms applied to one object, and show how they
    can be used to position an object.
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
- en: Show how the matrices for a series of transforms can be multiplied together
    to get one matrix that applies all the transforms at once.
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
- en: Discuss how the single matrix derived from all the others is more efficient,
    using your scene as an example to explain this.
  id: totrans-2058
  prefs: []
  type: TYPE_NORMAL
- en: 13.3\. DRAWING LINES AND CIRCLES
  id: totrans-2059
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A fundamental operation is computer graphics is to draw lines and circles. For
    example, these are used as the components of scalable fonts and vector graphics;
    the letter “i” is specified as a series of lines and curves, so that when you
    zoom in on it the computer can redraw it at whatever resolution is needed.
  id: totrans-2060
  prefs: []
  type: TYPE_NORMAL
- en: '![](563adb2b64b99.png)'
  id: totrans-2061
  prefs: []
  type: TYPE_IMG
- en: In 3D graphics shapes are often stored using lines and curves that mark out
    the edges of flat surfaces, each of which is so small that you can’t see them
    unless you zoom right in.
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
- en: '![](563adb2aeb693.gif)'
  id: totrans-2063
  prefs: []
  type: TYPE_IMG
- en: The lines and circles that specify an object are usually given using numbers
    (for example, a line between a given starting and finishing position or a circle
    with a given centre and radius). From this a graphics program must calculate which
    pixels on the screen should be coloured in to represent the line or circle.
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
- en: For example, here’s a grid of pixels with 5 lines shown magnified. The vertical
    line would have been specified as going from pixel (2,9) to (2,16) — that is,
    starting 2 across and 9 up, and finishing 2 across and 16 up. Of course, this
    is only a small part of a screen, as normally they are more like 1000 by 1000
    pixels or more; even a smartphone can be hundreds of pixels high and wide.
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb2a6c251.png)](http://csfieldguide.org.nz/_images/20grid_example.png)'
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
- en: These are things that are easy to do with pencil and paper using a ruler and
    compass, but on a computer the calculations need to be done for every pixel, and
    if you use the wrong method then it will take too long and the image will be displayed
    slowly or a live animation will appear jerky. In this section we will look into
    some very simple but clever algorithms that enable a computer to do these calculations
    very quickly.
  id: totrans-2067
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.1\. LINE DRAWING
  id: totrans-2068
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To draw a line, a computer must work out which pixels need to be filled so that
    the line looks straight. You can try this by colouring in squares on a grid, such
    as the one below (they are many times bigger than the pixels on a normal printer
    or screen). We’ll identify the pixels on the grid using two values, (*x*,*y*),
    where *x* is the distance across from the left, and *y* is the distance up from
    the bottom. The bottom left pixel below is (0,0), and the top right one is (19,19).
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
- en: 'On the following grid, try to draw these straight lines by filling in pixels
    in the grid:'
  id: totrans-2070
  prefs: []
  type: TYPE_NORMAL
- en: from (2, 17) to (10, 17)
  id: totrans-2071
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: from (18, 2) to (18, 14)
  id: totrans-2072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: from (1, 5) to (8, 12)
  id: totrans-2073
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![](563adb29f2de5.png)](http://csfieldguide.org.nz/_images/20grid.png)'
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a horizontal, vertical or diagonal line like the ones above is easy;
    it’s the ones at different angles that require some calculation.
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
- en: Without using a ruler, can you draw a straight line from A to B on the following
    grid by colouring in pixels?
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb2967ed3.png)](http://csfieldguide.org.nz/_images/20grid_ab.png)'
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
- en: Once you have finished drawing your line, try checking it with a ruler. Place
    the ruler so that it goes from the centre of A to the centre of B. Does it cross
    all of the pixels that you have coloured?
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.2\. USING A FORMULA TO DRAW A LINE
  id: totrans-2079
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mathematical formula for a line is y=mx+c. This gives you the *y* value
    for each *x* value across the screen, where m is the slope of the line and c is
    where it crosses the y axis. In other words, for *x* pixels across, the pixel
    to colour in would be (*x*, mx+c).
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
- en: For example, choosing m=2 and c=3 means that the line would go through the points
    (0,3), (1,5), (2,7), (3,9) and so on. This line goes up 2 pixels for every one
    across (m=2), and crosses the y axis 3 pixels up (c=3).
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
- en: You should experiment with drawing graphs for various values of m and c (for
    example, start with c=0, and try these three lines: m=1, m=0.5 and m=0) by putting
    in the values. What angle are these lines at?
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
- en: The mx+c formula can be used to work out which pixels should be coloured in
    for a line that goes between (x1,y1) and (x2,y2). What are (x1,y1) and (x2,y2) for
    the points A and B on the grid below?
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
- en: 'See if you can work out the m and b values for a line from A to B, or you can
    calculate them using the following formulas:'
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
- en: m=(y2−y1)(x2−x1)
  id: totrans-2085
  prefs: []
  type: TYPE_NORMAL
- en: b=(y1x2−y2x1)(x2−x1)
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
- en: Now draw the same line as in the previous section (between A and B) using the
    formula y=mx+c to calculate *y* for each value of *x* from x1 to x2 (you will
    need to round *y* to the nearest integer to work out which pixel to colour in).
    If the formulas have been applied correctly, the *y* value should range from y1 to y2.
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb28db89c.png)](http://csfieldguide.org.nz/_images/20grid_ab.png)'
  id: totrans-2088
  prefs: []
  type: TYPE_NORMAL
- en: Once you have completed the line, check it with a ruler. How does it compare
    to your first attempt?
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the number of calculations that are needed to work out each point.
    It won’t seem like many, but remember that a computer might be calculating hundreds
    of points on thousands of lines in a complicated image. In the next section we
    will explore a method that greatly speeds this up.
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.3\. BRESENHAM’S LINE ALGORITHM
  id: totrans-2091
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A faster way for a computer to calculate which pixels to colour in is to use
    Brensenham’s Line Algorithm. It follows these simple rules. First, calculate these
    three values:'
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
- en: A=2×(y2−y1)
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
- en: B=A−2×(x2−x1)
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
- en: P=A−(x2−x1)
  id: totrans-2095
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw the line, fill the starting pixel, and then for every position along
    the *x* axis:'
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
- en: if P is less than 0, draw the new pixel on the same line as the last pixel,
    and add A to P.
  id: totrans-2097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if P was 0 or greater, draw the new pixel one line higher than the last pixel,
    and add B to P.
  id: totrans-2098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: repeat this decision until we reach the end of the line.
  id: totrans-2099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Without using a ruler, use Bresenham’s Line Algorithm to draw a straight line
    from A to B:'
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb2356e1c.png)](http://csfieldguide.org.nz/_images/20grid_ab.png)'
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
- en: Once you have completed the line, check it with a ruler. How does it compare
    to the previous attempts?
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.4\. LINES AT OTHER ANGLES
  id: totrans-2103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far the version of Bresenham’s line drawing algorithm that you have used
    only works for lines that have a gradient (slope) between 0 and 1 (that is, from
    horizontal to 45 degrees). To make this algorithm more general, so that it can
    be used to draw any line, some additional rules are needed:'
  id: totrans-2104
  prefs: []
  type: TYPE_NORMAL
- en: If a line is sloping downward instead of sloping upward, then when P is 0 or
    greater, draw the next column’s pixel one row *below* the previous pixel, instead
    of above it.
  id: totrans-2105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the change in Y value is greater than the change in X value, then the calculations
    for A, B, and the initial value for P will need to be changed. When calculating
    A, B, and the initial P, use X where you previously would have used Y, and vice
    versa. When drawing pixels, instead of going across every column in the X axis,
    go through every row in the Y axis, drawing one pixel per row.
  id: totrans-2106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![](563adb22d7087.png)](http://csfieldguide.org.nz/_images/20grid.png)'
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
- en: In the grid above, choose two points of your own that are unique to you. Don’t
    choose points that will give horizontal, vertical or diagonal lines!
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
- en: Now use Bresenham’s algorithm to draw the line. Check that it gives the same
    points as you would have chosen using a ruler, or using the formula y=mx+b. How
    many arithmetic calculations (multiplications and additions) were needed for Bresenhams
    algorithm? How many would have been needed if you used the y=mx+b formula? Which
    is faster (bear in mind that adding is a lot faster than multiplying for most
    computers).
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
- en: You could write a program or design a spreadsheet to do these calculations for
    you — that’s what graphics programmers have to do.
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.5\. CIRCLES
  id: totrans-2111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As well as straight lines, another common shape that computers often need to
    draw are circles. An algorithm similar to Bresenham’s line drawing algorithm,
    called the Midpoint Circle Algorithm, has been developed for drawing a circle
    efficiently.
  id: totrans-2112
  prefs: []
  type: TYPE_NORMAL
- en: A circle is defined by a centre point, and a radius. Points on a circle are
    all the radius distance from the centre of the circle.
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb2219f04.png)](http://csfieldguide.org.nz/_images/20grid_cr.png)'
  id: totrans-2114
  prefs: []
  type: TYPE_NORMAL
- en: Try to draw a circle by hand by filling in pixels (without using a ruler or
    compass). Note how difficult it is to make the circle look round.
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to draw the circle using a formula based on Pythagoras’ theorem,
    but it requires calculating a square root for each pixel, which is very slow.
    The following algorithm is much faster, and only involves simple arithmetic so
    it runs quickly on a computer.
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.6\. BRESENHAM’S MIDPOINT CIRCLE ALGORITHM
  id: totrans-2117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the rules for the Midpoint Circle Algorithm for a circle around (cx, cy)
    with a radius of R:'
  id: totrans-2118
  prefs: []
  type: TYPE_NORMAL
- en: E=−R
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
- en: X=R
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
- en: Y=0
  id: totrans-2121
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat the following rules in order until *Y* becomes greater than *X*:'
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
- en: Fill the pixel at coordinate (cx+X, cy+Y)
  id: totrans-2123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase *E* by 2×Y+1
  id: totrans-2124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase *Y* by 1
  id: totrans-2125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *E* is greater than or equal to 0, subtract (2X−1) from *E*, and then subtract
    1 from *X*.
  id: totrans-2126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow the rules to draw a circle on the grid, using (cx, cy) as the centre
    of the circle, and R the radius. Notice that it will only draw the start of the
    circle and then it stops because *Y* is greater than *X*!
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563adb2190ffc.png)](http://csfieldguide.org.nz/_images/20grid_cr.png)'
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
- en: When *y* becomes greater than *x*, one eighth (an octant) of the circle is drawn.
    The remainder of the circle can be drawn by reflecting the octant that you already
    have (you can think of this as repeating the pattern of steps you just did in
    reverse). Reflect pixels along the X and Y axis, such that the line of reflection
    crosses the middle of the centre pixel of the circle. Half of the circle is now
    drawn, the left and the right half. To add the remainder of the circle, another
    line of reflection must be used. Can you work out which line of reflection is
    needed to complete the circle?
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster** : Octant'
  id: totrans-2130
  prefs: []
  type: TYPE_NORMAL
- en: A quadrant is a quarter of an area; the four quadrants that cover the whole
    area are marked off by a vertical and horizontal line that cross. An *octant* is
    one eighth of an area, and the 8 octants are marked off by 4 lines that intersect
    at one point (vertical, horizontal, and two diagonal lines).
  id: totrans-2131
  prefs: []
  type: TYPE_NORMAL
- en: To complete the circle, you need to reflect along the diagonal. The line of
    reflection should have a gradient of 1 or -1, and should cross through the middle
    of the centre pixel of the circle.
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
- en: While using a line of reflection on the octant is easier for a human to understand,
    a computer can draw all of the reflected points at the same time it draws a point
    in the first octant because when it is drawing pixel with an offset of (x,y) from
    the centre of the circle, it can also draw the pixels with offsets (x,-y), (-x,y),
    (-x,-y), (y,x), (y,-x), (-y,x) and (-y,-x), which give all eight reflections of
    the original point!
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
- en: By the way, this kind of algorithm can be adapted to draw ellipses, but it has
    to draw a whole quadrant because you don’t have octant symmetry in an ellipse.
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.7\. PRACTICAL APPLICATIONS
  id: totrans-2135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Computers need to draw lines, circles and ellipses for a wide variety of tasks,
    from game graphics to lines in an architect’s drawing, and even a tiny circle
    for the dot on the top of the letter ‘i’ in a word processor. By combining line
    and circle drawing with techniques like ‘filling’ and ‘antialiasing’, computers
    can draw smooth, clear images that are resolution independent. When an image on
    a computer is described as an outline with fill colours it is called vector graphics
    — these can be re-drawn at any resolution. This means that with a vector image,
    zooming in to the image will not cause the pixelation seen when zooming in to
    bitmap graphics, which only store the pixels and therefore make the pixels larger
    when you zoom in. However, with vector graphics the pixels are recalculated every
    time the image is redrawn, and that’s why it’s important to use a fast algorithm
    like the one above to draw the images.
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
- en: Outline fonts are one of the most common uses for vector graphics as they allow
    the text size to be increased to very large sizes, with no loss of quality to
    the letter shapes.
  id: totrans-2137
  prefs: []
  type: TYPE_NORMAL
- en: Computer scientists have found fast algorithms for drawing other shapes too,
    which means that the image appears quickly and it can be done on relatively slow
    hardware - for example, a smartphone needs to do these calculations all the time
    to display images, and reducing the amount of calculations can extend its battery
    life, as well as make it appear faster.
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
- en: As usual, things aren’t quite as simple as shown here. For example, consider
    a horizontal line that goes from (0,0) to (10,0), which has 11 pixels. Now compare
    it with a 45 degree line that goes from (0,0) to (10,10). It still has 11 pixels,
    but the line is longer (about 41% longer to be precise). This means that the line
    would appear thinner or fainter on a screen, and extra work needs to be done (mainly
    anti-aliasing) to make the line look ok. We’ve only just begun to explore how
    techniques in graphics are needed to quickly render high quality images.
  id: totrans-2139
  prefs: []
  type: TYPE_NORMAL
- en: '13.3.8\. PROJECT: LINE AND CIRCLE DRAWING'
  id: totrans-2140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To compare Bresenham’s method with using the equation of a line (y=mx+b), choose
    your own start and end point of a line (of course, make sure it’s at an interesting
    angle), and show the calculations that would be made by each method. Count up
    the number of additions, subtractions, multiplications and divisions that are
    made in each case to make the comparison. Note that addition and subtraction is
    usually a lot faster than multiplication and division.
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
- en: You can estimate how long each operation takes on your computer by running a
    program that does thousands of each operation, and timing how long it takes for
    each. From this you can estimate the total time taken by each of the two methods.
    A good measurement for these is how many lines (of your chosen length) your computer
    could calculate per second.
  id: totrans-2142
  prefs: []
  type: TYPE_NORMAL
- en: 13.4\. THE WHOLE STORY!
  id: totrans-2143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 13.5\. FURTHER READING
  id: totrans-2144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Todo
  id: totrans-2145
  prefs: []
  type: TYPE_NORMAL
- en: this section is yet to be written
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
- en: 13.5.1\. USEFUL LINKS
  id: totrans-2147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Computer_graphics](http://en.wikipedia.org/wiki/Computer_graphics)'
  id: totrans-2148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Transformation_matrix](http://en.wikipedia.org/wiki/Transformation_matrix)'
  id: totrans-2149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Bresenham](http://en.wikipedia.org/wiki/Bresenham)’s_line_algorithm'
  id: totrans-2150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Ray_trace](http://en.wikipedia.org/wiki/Ray_trace)'
  id: totrans-2151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.cosc.canterbury.ac.nz/mukundan/cogr/applcogr.html](http://www.cosc.canterbury.ac.nz/mukundan/cogr/applcogr.html)'
  id: totrans-2152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.cosc.canterbury.ac.nz/mukundan/covn/applcovn.html](http://www.cosc.canterbury.ac.nz/mukundan/covn/applcovn.html)'
  id: totrans-2153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.povray.org/resources/links/3D_Tutorials/POV-Ray_Tutorials/](http://www.povray.org/resources/links/3D_Tutorials/POV-Ray_Tutorials/)'
  id: totrans-2154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computer Graphics, Computer Vision, Bresenham’s Line Algorithm, Ray Tracing,
    Magnetic Resonance Imaging (MRI), Rendering, 3D Modeling, Animation, WebGL (Web
    Graphics Library), OpenGL (Open Graphics Library)
  id: totrans-2155
  prefs: []
  type: TYPE_NORMAL
- en: 13.5.2\. KEY CONCEPTS
  id: totrans-2156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Algorithms: Bresenham’s algorithm (line and circle drawing), colour space conversion,
    line anti-aliasing, Bézier and B-spline curves, painter’s algorithm, Z-buffer'
  id: totrans-2157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Techniques: Techniques: ray tracing, texture mapping, shading, anti-aliasing,
    volume rendering, polygonisation, constructive solid geometry, 3D modeling, hidden
    object removal'
  id: totrans-2158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Applications: drawing software, animation'
  id: totrans-2159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14\. COMPUTER VISION
  id: totrans-2160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 14.1\. WHAT’S THE BIG PICTURE?
  id: totrans-2161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When computers were first developed, the only way they could interact with the
    outside world was through the input that people wired or typed into them. Digital
    devices today often have cameras, microphones and other sensors through which
    programs can perceive the world we live in automatically. Processing images from
    a camera, and looking for interesting information in them, is what we call *computer
    vision*.
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
- en: With increases in computer power, the decrease in the size of computers and
    progressively more advanced algorithms, computer vision has a growing range of
    applications. While it is commonly used in fields like healthcare, security and
    manufacturing, we are finding more and more uses for them in our everyday life,
    too.
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a sign written in Chinese:'
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
- en: '![](563addbd743c9.jpg)'
  id: totrans-2165
  prefs: []
  type: TYPE_IMG
- en: 'If you can’t read the Chinese characters, there are apps available for smartphones
    that can help:'
  id: totrans-2166
  prefs: []
  type: TYPE_NORMAL
- en: '![](563addbb7496d.jpg)'
  id: totrans-2167
  prefs: []
  type: TYPE_IMG
- en: Having a small portable device that can “see” and translate characters makes
    a big difference for travellers. Note that the translation given is only for the
    second part of the phrase (the last two characters). The first part says “please
    don’t”, so it could be misleading if you think it’s translating the whole phrase!
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
- en: 'Recognising of Chinese characters may not work every time perfectly, though.
    Here is a warning sign:'
  id: totrans-2169
  prefs: []
  type: TYPE_NORMAL
- en: '![](563addb95808d.jpg)'
  id: totrans-2170
  prefs: []
  type: TYPE_IMG
- en: My phone has been able to translate the “careful” and “steep” characters, but
    it hasn’t recognised the last character in the line. Why do you think that might
    be?
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
- en: Giving users more information through computer vision is only one part of the
    story. Capturing information from the real world allows computers to assist us
    in other ways too. In some places, computer vision is already being used to help
    car drivers to avoid collisions on the road, warning them when other cars are
    too close or there are other hazards on the road ahead. Combining computer vision
    with map software, people have now built cars that can drive to a destination
    without needing a human driver to steer them. A wheelchair guidance system can
    take advantage of vision to avoid bumping into doors, making it much easier to
    operate for someone with limited mobility.
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
- en: 14.2\. LIGHTS, CAMERA, ACTION!
  id: totrans-2173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Digital cameras and human eyes fulfill largely the same function: images come
    in through a lens and are focused onto a light sensitive surface, which converts
    them into electrical impulses that can be processed by the brain or a computer
    respectively. There are some differences, however.'
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
- en: '**Human eyes** have a very sensitive area in the centre of their field of vision
    called the fovea. Objects that we are looking at directly are in sharp detail,
    while our peripheral vision is quite poor. We have separate sets of cone cells
    in the retina for sensing red, green and blue (RGB) light, but we also have special
    rod cells that are sensitive to light levels, allowing us to perceive a wide dynamic
    range of bright and dark colours. The retina has a blind spot (a place where all
    the nerves bundle together to send signals to the brain through the optic nerve),
    but most of the time we don’t notice it because we have two eyes with overlapping
    fields of view, and we can move them around very quickly.'
  id: totrans-2175
  prefs: []
  type: TYPE_NORMAL
- en: '**Digital cameras** have uniform sensitivity to light across their whole field
    of vision. Light intensity and colour are picked up by RGB sensor elements on
    a silicon chip, but they aren’t as good at capturing a wide range of light levels
    as our eyes are. Typically, a modern digital camera can automatically tune its
    exposure to either bright or dark scenes, but it might lose some detail (e.g.
    when it is tuned for dark exposure, any bright objects might just look like white
    blobs).'
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that neither a human eye nor a digital camera
    — even a very expensive one — can perfectly capture all of the information in
    the scene in front of it. Electronic engineers and computer scientists are constantly
    doing research to improve the quality of the images they capture, and the speed
    at which they can record and process them.
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
- en: 14.3\. NOISE
  id: totrans-2178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One challenge when using digital cameras is something called *noise*. That’s
    when individual pixels in the image appear brighter or darker than they should
    be, due to interference in the electronic circuits inside the camera. It’s more
    of a problem when light levels are dark, and the camera tries to boost the exposure
    of the image so that you can see more. You can see this if you take a digital
    photo in low light, and the camera uses a high ASA/ISO setting to capture as much
    light as possible. Because the sensor has been made very sensitive to light, it
    is also more sensitive to random interference, and gives photos a “grainy” effect.
  id: totrans-2179
  prefs: []
  type: TYPE_NORMAL
- en: Noise mainly appears as random changes to pixels. For example, the following
    image has “salt and pepper” noise.
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
- en: '![](563addb730d9f.jpg)'
  id: totrans-2181
  prefs: []
  type: TYPE_IMG
- en: Having noise in an image can make it harder to recognise what’s in the image,
    so an important step in computer vision is reducing the effect of noise in an
    image. There are well-understood techniques for this, but they have to be careful
    that they don’t discard useful information in the process. In each case, the technique
    has to make an educated guess about the image to predict which of the pixels that
    it sees are supposed to be there, and which aren’t.
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
- en: Since a camera image captures the levels of red, green and blue light separately
    for each pixel, a computer vision system can save a lot of processing time in
    some operations by combining all three channels into a single “grayscale” image,
    which just represents light intensities for each pixel.
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
- en: This helps to reduce the level of noise in the image. Can you tell why, and
    about how much less noise there might be? (As an experiment, you could take a
    photo in low light — can you see small patches on it caused by noise? Now use
    photo editing software to change it to black and white — does that reduce the
    effect of the noise?)
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
- en: Rather than just considering the red, green and blue values of each pixel individually,
    most noise-reduction techniques look at other pixels in a region, to predict what
    the value in the middle of that neighbourhood ought to be.
  id: totrans-2185
  prefs: []
  type: TYPE_NORMAL
- en: A *mean filter* assumes that pixels nearby will be similar to each other, and
    takes the average (i.e. the *mean*) of all pixels within a square around the centre
    pixel. The wider the square, the more pixels there are to choose from, so a very
    wide mean filter tends to cause a lot of blurring, especially around areas of
    fine detail and edges where bright and dark pixels are next to each other.
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
- en: A *median filter* takes a different approach. It collects all the same values
    that the mean filter does, but then sorts them and takes the middle (i.e. the *median*)
    value. This helps with the edges that the mean filter had problems with, as it
    will choose either a bright or a dark value (whichever is most common), but won’t
    give you a value between the two. In a region where pixels are mostly the same
    value, a single bright or dark pixel will be ignored. However, numerically sorting
    all of the neighbouring pixels can be quite time-consuming!
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
- en: A *Gaussian* blur is another common technique, which assumes that the closest
    pixels are going to be the most similar, and pixels that are farther away will
    be less similar. It works a lot like the mean filter above, but is statistically
    weighted according to a *normal distribution*.
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
- en: '14.3.1\. ACTIVITY: NOISE REDUCTION FILTERS'
  id: totrans-2189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Open the noise reduction filtering interactive using this link and experiment
    with settings as below. You will need a webcam, and the widget will ask you to
    allow access to it.](http://www.cosc.canterbury.ac.nz/csfieldguide/dev/dev/_static/widgets/cv-noise-filters.html)'
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
- en: Mathematically, this process is applying a special kind of matrix called a *convolution
    kernel* to the value of each pixel in the source image, averaging it with the
    values of other pixels nearby and copying that average to each pixel in the new
    image. The average is weighted, so that the values of nearby pixels are given
    more importance than ones that are far away. The stronger the blur, the wider
    the convolution kernel has to be and the more calculations take place.
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
- en: 'For your project, investigate the different kinds of noise reduction filter
    and their settings (mask size, number of iterations) and determine:'
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
- en: how well they cope with different kinds and levels of noise (you can set this
    in the interactive).
  id: totrans-2193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how much time it takes to do the necessary processing (the interactive shows
    the number of frames per second that it can process)
  id: totrans-2194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how they affect the quality of the underlying image (a variety of images + camera)
  id: totrans-2195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can take screenshots of the image to show the effects in your writeup. You
    can discuss the tradeoffs that need to be made to reduce noise.
  id: totrans-2196
  prefs: []
  type: TYPE_NORMAL
- en: 14.4\. FACE RECOGNITION
  id: totrans-2197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recognising faces has become a widely used computer vision application. These
    days photo album systems like Picasa and Facebook can try to recognise who is
    in a photo using face recognition — for example, the following photos were recognised
    in Picasa as being the same person, so to label the photos with people’s names
    you only need to click one button rather than type each one in.
  id: totrans-2198
  prefs: []
  type: TYPE_NORMAL
- en: '![](563addb624a24.jpg)'
  id: totrans-2199
  prefs: []
  type: TYPE_IMG
- en: There are lots of other applications. Security systems such as customs at country
    borders use face recognition to identify people and match them with their passport.
    It can also be useful for privacy — Google Maps streetview identifies faces and
    blurs them. Digital cameras can find faces in a scene and use them to adjust the
    focus and lighting.
  id: totrans-2200
  prefs: []
  type: TYPE_NORMAL
- en: There is some information about [How facial recognition works](http://electronics.howstuffworks.com/gadgets/high-tech-gadgets/facial-recognition.htm) that
    you can read up as background, and some more information at [i-programmer.info](http://www.i-programmer.info/babbages-bag/1091-face-recognition.html) .
  id: totrans-2201
  prefs: []
  type: TYPE_NORMAL
- en: There are some relevant [articles on the cs4fn website](http://www.cs4fn.org/vision/) that
    also provide some general material on computer vision.
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
- en: '14.4.1\. PROJECT: RECOGNISING FACES'
  id: totrans-2203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First let’s manually try some methods for recognising whether two photographs
    show the same person.
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
- en: Get about 3 photos each of 3 people
  id: totrans-2205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measure features on the faces such as distance between eyes, width of mouth,
    height of head etc. Calculate the ratios of some of these.
  id: totrans-2206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do photos of the same person show the same ratios? Do photos of different people
    show different ratios? Would these features be a reliable way to recognise two
    images as being the same person?
  id: totrans-2207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there other features you could measure that might improve the accuracy?
  id: totrans-2208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can evaluate the effectiveness of facial recognition in free software such
    as Google’s Picasa or the Facebook photo tagging system, but uploading photos
    of a variety of people and seeing if it recognises photos of the same person.
    Are there any false negatives or positives? How much can you change your face
    when the photo is being taken to not have it match your face in the system? Does
    it recognise a person as being the same in photos taken several years apart? Does
    a baby photo match of a person get matched with them when they are five years
    old? When they are an adult? Why or why not does this work?
  id: totrans-2209
  prefs: []
  type: TYPE_NORMAL
- en: Use the following face recognition interactive to see how well the Haar face
    recognition system can track a face in the image. What prevents it from tracking
    a face? Is it affected if you cover one eye or wear a hat? How much can the image
    change before it isn’t recognised as a face? Is it possible to get it to incorrectly
    recognise something that isn’t a face?
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
- en: '[Open the face recognition interactive using this link and experiment with
    the settings. You will need a webcam, and the widget will ask you to allow access
    to it.](http://inspirit.github.com/jsfeat/sample_haar_face.html)'
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
- en: 14.5\. EDGE DETECTION
  id: totrans-2212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A useful technique in computer vision is *edge detection*, where the boundaries
    between objects are automatically identified. Having these boundaries makes it
    easy to*segment* the image (break it up into separate objects or areas), which
    can then be recognised separately.
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s a photo where you might want to recognise individual objects:'
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
- en: '![](563addb4e8659.jpg)'
  id: totrans-2215
  prefs: []
  type: TYPE_IMG
- en: 'And here’s a version that has been processed by an edge detection algorithm:'
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
- en: '![](563addaf0bce5.jpg)'
  id: totrans-2217
  prefs: []
  type: TYPE_IMG
- en: Notice that the grain on the table above has affected the quality; some pre-processing
    to filter that would have helped!
  id: totrans-2218
  prefs: []
  type: TYPE_NORMAL
- en: You can experiment with edge-detection yourself. Open the following interactive,
    which provides a *Canny edge detector* (see the information about [Canny edge
    detection on Wikipedia](http://en.wikipedia.org/wiki/Canny_edge_detector) ). This
    is a widely used algorithm in computer vision, developed in 1986 by John F. Canny.
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
- en: '[Open the edge detection interactive using this link and experiment with settings
    as below. You will need a webcam, and the widget will ask you to allow access
    to it.](http://inspirit.github.com/jsfeat/sample_canny_edge.html)'
  id: totrans-2220
  prefs: []
  type: TYPE_NORMAL
- en: '14.5.1\. ACTIVITY: EDGE DETECTION EVALUATION'
  id: totrans-2221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the canny edge detection interactive above, try putting different images
    in front of the camera and determine how good the algorithm is at detecting boundaries
    in the image. Capture images to put in your report as examples to illustrate your
    experiments with the detector.
  id: totrans-2222
  prefs: []
  type: TYPE_NORMAL
- en: Can the Canny detector find all edges in the image? If there are some missing,
    why might this be?
  id: totrans-2223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there any false edge detections? Why did they system think that they were
    edges?
  id: totrans-2224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the lighting on the scene affect the quality of edge detection?
  id: totrans-2225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the system find the boundary between two colours? How similar can the colours
    be and still have the edge detected?
  id: totrans-2226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How fast can the system process the input? Does the nature of the image affect
    this?
  id: totrans-2227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How well does the system deal with a page with text on it?
  id: totrans-2228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 14.6\. THE WHOLE STORY!
  id: totrans-2229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The field of computer vision is changing rapidly at the moment because camera
    technology has been improving quickly over the last couple of decades. Not only
    is the resolution of cameras increasing, but they are more sensitive for low light
    conditions, have less noise, can operate in infra-red (useful for detecting distances),
    and are getting very cheap so that it’s reasonable to use multiple cameras, perhaps
    to give different angles or to get stereo vision.
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
- en: Despite these recent changes, many of the fundamental ideas in computer vision
    have been around for a while; for example, the “k-means” segmentation algorithm
    was first described in 1967, and the first digital camera wasn’t built until 1975
    (it was a 100 by 100 pixel Kodak prototype).
  id: totrans-2231
  prefs: []
  type: TYPE_NORMAL
- en: (More material will be added to this chapter in the near future)
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
- en: 14.7\. FURTHER READING
  id: totrans-2233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Computer_vision](http://en.wikipedia.org/wiki/Computer_vision)'
  id: totrans-2234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Mri](http://en.wikipedia.org/wiki/Mri)'
  id: totrans-2235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.cosc.canterbury.ac.nz/mukundan/cogr/applcogr.html](http://www.cosc.canterbury.ac.nz/mukundan/cogr/applcogr.html)'
  id: totrans-2236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.cosc.canterbury.ac.nz/mukundan/covn/applcovn.html](http://www.cosc.canterbury.ac.nz/mukundan/covn/applcovn.html)'
  id: totrans-2237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15\. NETWORK COMMUNICATION PROTOCOLS
  id: totrans-2238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 15.1\. WHAT’S THE BIG PICTURE?
  id: totrans-2239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Think about the last time someone sent you mail via the post. They probably
    wrote some content on some paper, put it in an envelope, wrote an address and
    put it in a postbox. From there, the letter probably went into a sorting center,
    got sorted, and was put in a bag. The bag then went into a vehicle like a truck,
    plane or boat. The vehicle either travelled through water, the air, or on the
    road. The postal system is a complicated one, designed to let individuals communicate
    easily, yet being efficient enough to group many letters into one postal delivery.
    The same ideas apply to how messages move around the internet. Whether it be a
    ‘like’ on Facebook, a video stream or an email - the internet and its various
    protocols looks after it for you so it is delivered on time and intact to the
    other person.
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
- en: Below we introduce some concepts, algorithms, techniques, applications and problems
    that relate to network protocols; it isn’t a complete list of all the ideas in
    the area, but should be enough to give you a good idea of what this area of computer
    science is about.
  id: totrans-2241
  prefs: []
  type: TYPE_NORMAL
- en: 15.2\. GETTING STARTED
  id: totrans-2242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take part in a game of Tablets of Stone in your classroom. Your teacher will
    show you how it is played. Try to think about a few things while you’re playing
    the game. What happens if one of my messages is delayed? What happens if one of
    my messages gets lost completely? Will the other governor be able to put them
    back together?
  id: totrans-2243
  prefs: []
  type: TYPE_NORMAL
- en: 15.3\. WHAT IS A PROTOCOL?
  id: totrans-2244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '‘Protocol’ is a fancy word for simply saying “an agreed way to do something”.
    You might have heard it in a cheesy cop show – “argh Jim, that’s against protocol!!!”
    – or heard it used in a procedural sense, such as how to file a tax return or
    sit a driving test. We all use protocols, every day. Think of when you’re in class.
    The *protocol*for asking a question may be as follows: raise your hand, wait for
    a nod from the teacher then begin asking your question.'
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
- en: Simple tasks require simple protocols like the one above; however more complicated
    processes may require more complicated protocols. Pilots and aviation crew have
    their own language (almost) for their tasks. A subset of normal language used
    to convey information such as altitude, heading, people on board, status and more.
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
- en: Activities on the internet vary a lot too (email, skype, video streaming, music,
    gaming, browsing, chatting), and so do the protocols used to achieve these. These
    collections of protocols form the topic of Networking Communication Protocols
    and this chapter will introduce you to some of them, what problems they solve,
    and what you can do to experience these protocols first hand. Let’s start by talking
    about the one you’re using if you’re viewing this page on the web.
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
- en: 15.4\. APPLICATION LEVEL PROTOCOLS - HTTP, IRC
  id: totrans-2248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The URL for the home site of this book is [http://csfieldguide.org](http://csfieldguide.org/).
    Ask a few friends what the “http” stands for - they have probably seen it thousands
    of times...do they know what it is? This section covers high level protocols such
    as HTTP and IRC, what they can do and how you can use them (hint: you’re already
    using HTTP right now).'
  id: totrans-2249
  prefs: []
  type: TYPE_NORMAL
- en: 15.4.1\. HYPERTEXT TRANSFER PROTOCOL (HTTP)
  id: totrans-2250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The HyperText Transfer Protocol (HTTP) is the most common protocol in use on
    the internet. The protocol’s job is to transfer *HyperText* (such as HTML) from
    a server to your computer. It’s doing that right now. You just loaded the Field
    Guide from the servers where it is hosted. Hit refresh and you’ll see it in action.
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP functions as a simple conversation between client and server. Think of
    when you’re at a shop:'
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
- en: 'You: “Can I have a can of soda please?”'
  id: totrans-2253
  prefs: []
  type: TYPE_NORMAL
- en: 'Shop Keeper: “Sure, here’s a can of soda”'
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ade320686c.png)'
  id: totrans-2255
  prefs: []
  type: TYPE_IMG
- en: HTTP uses a request/response pattern for solving the problem of reliable communication
    between client and server. The “ask for” is known as a *request* and the reply
    is known as a *response*. Both requests and responses can also have other data
    or *resources* sent along with it.
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
- en: A *resource* is any item of data on a server. For example, a blog post, a customer,
    an item of stock or a news story. As a business or a website, you would create,
    read, update and delete these as part of your daily business. HTTP is well suited
    to that. For example, if you’re a news site, every day your authors would add
    stories, you could update them, delete them if they’re old or become out of date,
    all sorts. These sorts of methods are required to manage content on a server,
    and HTTP is the way to do this.
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
- en: This is happening all the time when you’re browsing the web; every web page
    you look at is delivered using the HyperText Transfer Protocol. Going back to
    the shop analogy, consider the same example, this time with more resources shown
    in asterisk (*) characters.
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
- en: 'You: “Can I have a can of soda please?” *You hand the shop keeper $2*'
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
- en: 'Shop Keeper: “Sure, here’s a can of soda” *Also hands you a receipt and your
    change*'
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ade3151585.png)'
  id: totrans-2262
  prefs: []
  type: TYPE_IMG
- en: There are nine *types* of requests that HTTP supports, and these are outlined
    below.
  id: totrans-2263
  prefs: []
  type: TYPE_NORMAL
- en: A GET request returns some text that describes the thing you’re asking for.
    Like above, you ask for a can of soda, you get a can of soda.
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
- en: 'A HEAD request returns what you’d get if you did a GET request. It’s like this:'
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
- en: 'You: “Can I have a can of soda please?”'
  id: totrans-2266
  prefs: []
  type: TYPE_NORMAL
- en: 'Shop Keeper: “Sure, here’s the can of soda you’d get” *Holds up a can of soda*'
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
- en: What’s neat about HTTP is that it allows you to also modify the contents of
    the server. Say you’re now also a representative for the soda company, and you’d
    like to re-stock some shelves.
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
- en: 'A POST request allows you to send information in the other direction. This
    request allows you to replace a resource on the server with one you supply. These
    use what is called a Uniform Resource Identifier or URI. A URI is a unique code
    or number for a resource. Confused? Let’s go back to the shop:'
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
- en: 'Sales Rep: “I’d like to replace this dented can of soda with barcode number
    123-111-221 with this one, that isn’t dented”'
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
- en: 'Shop Keeper: “Sure, that has now been replaced”'
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
- en: A PUT request adds a new resource to a server, however, if the resource already
    exists with that URI, it is modified with the new one.
  id: totrans-2272
  prefs: []
  type: TYPE_NORMAL
- en: 'Sales Rep: “Here, have 10 more cans of lemonade for this shelf”'
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
- en: 'Shop Keeper: “Thanks, I’ve now put them on the shelf”'
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
- en: A DELETE request does what you’d think, it deletes a resource.
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
- en: 'Sales Rep: “We are no longer selling ‘Lemonade with Extra Vegetables’, no one
    likes it! Please remove them!”'
  id: totrans-2276
  prefs: []
  type: TYPE_NORMAL
- en: 'Shop Keeper: “Okay, they are gone”.'
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
- en: Some other request types (*HTTP methods*) exist too, but they are less used;
    these are TRACE, OPTIONS, CONNECT and PATCH. You can [find out more about these](http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)on
    your own if you’re interested.
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
- en: 'In HTTP, the first line of the response is called the *status* line and has
    a numeric status code such as **404** and a text-based *reason phrase* such as
    “Not Found”. The most common is 200 and this means successful or “OK”. HTTP status
    codes are primarily divided into five groups for better explanation of requests
    and responses between client and server and are named by purpose and a number:
    Informational 1XX, Successful 2XX, Redirection 3XX, Client Error 4XX and Server
    Error 5XX. There are many [status codes](http://en.wikipedia.org/wiki/List_of_HTTP_status_codes) for
    representing different cases for error or success. There’s even a nice 418: Teapot
    error on Google: [http://www.google.com/teapot](http://www.google.com/teapot)'
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
- en: So what’s actually happening? Well, let’s find out. If you’re in a Chrome or
    Safari browser, press Ctrl + Shift + I in windows or Command + Option + I on a
    mac to bring up the web inspector. Select the Network tab. Refresh the page. What
    you’re seeing now is a list of of HTTP requests your browser is making to the
    server to load the page you’re currently viewing. Near the top you’ll see a request
    to NetworkCommunicationProtocols.html. Click that and you’ll see details of the
    Headers, Preview, Response, Cookies and Timing. Ignore those last two for now.
  id: totrans-2280
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the first few lines of the headers:'
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-2282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The *Remote Address* is the address of the server of the page is hosted on.
    The *Request URL* is the original URL that you requested. The request method should
    be familiar from above. It is a GET type request, saying “can I have the web page
    please?” and the response is the HTML. Don’t believe me? Click the *Response* tab.
    Finally, the *Status Code* is a code that the page can respond with.
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the *Request Headers* now, click ‘view source’ to see the original
    request.
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-2285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see, a request message consists of the following:'
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
- en: A request line in the form of *method* *URI* *protocol*/*version*
  id: totrans-2287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request Headers (Accept, User-Agent, Accept-Language etc)
  id: totrans-2288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty line
  id: totrans-2289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional message body.
  id: totrans-2290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at the *Response Headers*:'
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-2292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As you can see, a request message consists of the following:'
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
- en: Status Line, 200 OK means everything went well.
  id: totrans-2294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Response Headers (Content-Length, Content-Type etc)
  id: totrans-2295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty line
  id: totrans-2296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional message body.
  id: totrans-2297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go ahead and try this same process on a few other pages too. For example, try
    these sites:'
  id: totrans-2298
  prefs: []
  type: TYPE_NORMAL
- en: A very busy website in terms of content, such as *Facebook.com*
  id: totrans-2299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A chapter that [doesn’t exist in the Field Guide](http://csfieldguide.org.nz/Nope.html)
  id: totrans-2300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your favourite website
  id: totrans-2301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Curiosity**'
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
- en: Tim Berners-Lee was credited for creating HTTP in 1989\. You can read more about
    him [here](http://en.wikipedia.org/wiki/Tim_Berners-Lee).
  id: totrans-2303
  prefs: []
  type: TYPE_NORMAL
- en: 15.4.2\. INTERNET RELAY CHAT (IRC)
  id: totrans-2304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Internet Relay Chat (IRC) is a system that lets you transfer messages in the
    form of text. It’s essentially a chat protocol. The system uses a client-server
    model. Clients are chat programs installed on a user’s computer that connect to
    a central server. The clients communicate the message to the central server which
    in turn relays that to other clients. The protocol was originally designed for
    group communication in a discussion forum, called *channels*. IRC also supports
    one-to-one communication via *private messages*. It is also capable of file and
    data transfer too.
  id: totrans-2305
  prefs: []
  type: TYPE_NORMAL
- en: The neat thing about IRC is that users can use commands to interact with the
    server, client or other users. For example /DIE will tell the server to shutdown
    (although it will only work if you are the administrator!) /ADMIN will tell you
    who the administrator is.
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
- en: Whilst IRC may be new to you, the concept of a group conversation online or
    a *chat room* may not be. There really isn’t any difference. Groups exist in the
    forms of*channels*. A server hosts many channels, and you can choose which one
    to join.
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
- en: 'Channels usually form around a particular topic, such as Python, Music, TV
    show fans, Gaming or Hacking. Convention dictates that channel names start with
    one or two # symbols, such as #python or ##TheBigBangTheory. *Conventions* are
    different to protocols in that they aren’t actually enforced by the protocol,
    but people choose to use it that way.'
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
- en: To get started with IRC, first you should get a client. A client is a program
    that let’s you connect Ask your teacher about which one to use. For this chapter,
    we’ll use the [freenode web client.](http://webchat.freenode.net/). Check with
    your teacher about which channel to join, as they may have set one up for you.
  id: totrans-2309
  prefs: []
  type: TYPE_NORMAL
- en: Try a few things while you’re in there. Look at this [list of commands](http://en.wikipedia.org/wiki/List_of_Internet_Relay_Chat_commands) and
    try to use some of them. What response do you get? Does this make sense?
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
- en: Try a one on one conversation with a friend. If they use commands, do you see
    them? How about the other way around?
  id: totrans-2311
  prefs: []
  type: TYPE_NORMAL
- en: 15.5\. PROJECTS - HTTP AND IRC
  id: totrans-2312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**HTTP** is the most common protocol yet. We use it every day and you’re using
    it right now if you’re viewing this on the web. Open up the web inspector (you
    might have to do this at home if your school doesn’t have it available) and have
    a look at the traffic. You might need to refresh, depending on your browser. We
    recommend Chrome, which is free to download at [https://www.google.com/chrome/browser/](https://www.google.com/chrome/browser/).'
  id: totrans-2313
  prefs: []
  type: TYPE_NORMAL
- en: Bring up the Developer Tools. Find the *Network* tab. Reload the page. You should
    now see a slew of request form. Go through and click each one. Have a look at
    the details you can see under headers.
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
- en: What is the remote address?
  id: totrans-2315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What type of method is it?
  id: totrans-2316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the status code mean?
  id: totrans-2317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the path?
  id: totrans-2318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the response?
  id: totrans-2319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is *actually happening* here? What part of the page is loading?
  id: totrans-2320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IRC** is a very primitive chat program which is fun to use with your friends.'
  id: totrans-2321
  prefs: []
  type: TYPE_NORMAL
- en: Go be a hacker, grab a friend and [visit freenode and create a channel for you.](http://webchat.freenode.net/) Now,
    look at the [list of commands you can use](http://en.wikipedia.org/wiki/List_of_Internet_Relay_Chat_commands) and
    try to use some of them. What response do you get? Does this make sense?
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
- en: Try a one on one conversation with a friend. If they use commands, do you see
    them? How about the other way around?
  id: totrans-2323
  prefs: []
  type: TYPE_NORMAL
- en: 15.6\. TRANSPORT LAYER PROTOCOLS - TCP AND UDP
  id: totrans-2324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we have talked about HTTP and IRC. These protocols are at a level that
    make sure you do not need to worry about how your data is being transported. Now
    we’ll cover how your data is transferred reliably and efficiently, regardless
    of what the data is. Below this level is an unreliable medium for transfer (such
    as wifi or cable, which are subject to interference errors) which causes a concern
    for data transportation. These protocols take different approaches to ensure data
    is delivered in an effective and/or efficient manner.
  id: totrans-2325
  prefs: []
  type: TYPE_NORMAL
- en: 15.6.1\. TCP
  id: totrans-2326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TCP (The Transmission Control Protocol) is one of the most important protocol
    on the internet. It breaks large messages up into *packets*. What is a packet?
    A packet is a segment of data that when combined with other packets, make up a
    total message (something like a HTTP request, an email, an IRC message or a file
    like a picture or song being downloaded). For the rest of the section, we’ll look
    at how these are used to load an image from a website.
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
- en: So computer A looks the file and takes it, breaks it into packets. It then sends
    the packets over the internet and computer B reassembles them and gives them back
    to you as the image, [which is demonstrated in this video.](https://www.youtube.com/watch?v=WwyJGzZmBe8)
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
- en: By now you’re probably wondering why we bother splitting up packets… wouldn’t
    it be easier to send the file as a whole? Well, it solves congestion. Imagine
    you’re in a bus, in rush hour and you have to be home by 5\. The road is jammed
    and there’s no way you and your friends are getting home on time. So you decide
    to get out of the bus and go your own separate ways. Web pages are like this too.
    They are too big to travel together so they are split up and sent in tiny pieces
    and then reassembled at the other end.
  id: totrans-2329
  prefs: []
  type: TYPE_NORMAL
- en: 'So why don’t the packets all just go from computer A to computer B just fine?
    Ha! That’d be nice. Unfortunately it’s not that simple. Through various means,
    there are some problems that can affect packets. These problems are:'
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
- en: Packet loss
  id: totrans-2331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packet delay (packets arrive out of order)
  id: totrans-2332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packet corruption (the packet gets changed on the way)
  id: totrans-2333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, if we didn’t try fix these, the image wouldn’t load, bits would be missing,
    corrupted or computer B might not even recognise what it is!
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ade2e6c678.jpg)'
  id: totrans-2335
  prefs: []
  type: TYPE_IMG
- en: So, TCP is a protocol that solves these issues. To introduce you to TCP, please
    play the game below. In the game, *you* are the problems (loss, delay, corruption)
    and as you move through the levels, pay attention to how the computer tries to
    combat them. Good luck trying to stop the messages getting through correctly!
  id: totrans-2336
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ade2d60b06.png)Click to play'
  id: totrans-2337
  prefs: []
  type: TYPE_NORMAL
- en: Packet Attack](http://csfieldguide.org.nz/_static/widgets/PacketAttack/)
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
- en: Let’s talk about what you saw in that game. What did the levels do to solve
    the issues of packet loss, delay (reordering) and corruption? TCP has several
    mechanisms for dealing with packet troubles.
  id: totrans-2339
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  id: totrans-2340
  prefs: []
  type: TYPE_NORMAL
- en: Why do packets experience delays, loss and corruption? This is because as packets
    are sent over a network, they go through various *nodes*. These nodes are effectively
    different routers or computers. One route might experience more interference than
    another (causing packet loss), one might be faster or shorter than another (causing
    order to be lost). Corruption can happen at any time through electronic interference.
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, TCP starts by doing what is known as a handshake. This basically means
    the two computers say to each other: “Hey, we’re going to use TCP for this image.
    Reconstruct it as you would”.'
  id: totrans-2342
  prefs: []
  type: TYPE_NORMAL
- en: Next is **Ordering**. Since a computer can’t look at data and order it like
    we can (like when we do a jigsaw puzzle or play Scrabble™) they need a way to
    “stitch” the packets back together. As we saw in *Packet Attack*, if you delayed
    a message that didn’t have ordering, the message may look like “HELOLWOLRD”. So,
    TCP puts a number on each packet (called a sequence number) which signifies its
    order. With this, it can put them back together again. It’s a bit like when you
    print out a few pages from a printer and you see “*Page 2 of 11*” on the bottom.
    Now, if packets do become out of order, TCP will wait for all of the packets to
    arrive and then put the message together.
  id: totrans-2343
  prefs: []
  type: TYPE_NORMAL
- en: Another concept is **checksums**. This concept of storing information about
    the data may be familiar from the [error control coding chapter](http://www.cosc.canterbury.ac.nz/csfieldguide/ErrorControlCoding.html).
    Basically, a checksum can detect errors and sometimes with coding schemes, can
    correct them. In the case of a correctable packet, it is corrected. If not, the
    packet is useless and needs to be resent. In the game, shields represent checksums.
    Corrupt a checksum once, and it can recover from the error using error correction.
    Corrupt it again and it can’t.
  id: totrans-2344
  prefs: []
  type: TYPE_NORMAL
- en: So how do packets get re-sent? TCP has a concept of *acknowledgement* and *negative
    acknowledgement* messages (ACK and NACK for short). You would have seen these
    in the higher levels of the game as the green (ACK) and red (NACK) creatures going
    back. Acks are sent to let the sender know when a packet arrives and it is usable.
    Nacks are sent back when a packet arrives and is damaged and needs resending.
    ACKs and and NACKs are useful because they provide a channel *in the opposite
    direction* for communication. If computer A receives a NACK, they can resend the
    message. If it receives an Ack, the computer can stop worrying about a resend.
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
- en: But does a computer send it again if it doesn’t hear back? Yes. It’s called
    a timeout and it’s the final line of defense in TCP. If a computer doesn’t get
    an ACK or a NACK back, after a certain time it will just resend the packet. It’s
    a bit like when you’re tuning out in class, and the teacher keeps repeating your
    name until you answer. Maybe that’s been you… woops. Sometimes, an ACK might get
    lost, so the packet is resent after a timeout, but that’s OK, as TCP can recognise
    duplicates and ignore them.
  id: totrans-2346
  prefs: []
  type: TYPE_NORMAL
- en: So that’s TCP. A protocol that puts accurate data transmission before efficiency
    and speed in a network. It uses timeouts, checksums, acks and nacks and many packets
    to deliver a message reliably. However, what if we don’t need all the packets?
    Can we get the overall picture faster? Read on…
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
- en: 15.6.2\. UDP
  id: totrans-2348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UDP (User Datagram Protocol) is a protocol for sending packets that does not
    guarantee delivery. UDP doesn’t guarantee against lost packets, duplicate packets
    or out of order packets. It just gets the bulk of the data there when it can.
    Checksums are used for data integrity though, so they have some protection. It’s
    still a protocol because it has a formal packet structure. The packets still include
    destination and origin as well as the size of the packet.
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
- en: So do we even use such an unreliable protocol? Yes, but not for anything too
    important. Files, messages, emails, web pages and other text based items use TCP,
    but things like streaming music, video, VOIP and so on use UDP. Maybe you’ve had
    a call on Skype that has been poor quality. Maybe the video flickers or the sound
    drops for a split second. That’s packets being lost. However, you of course get
    the overall picture and the conversation you’re having is successful.
  id: totrans-2350
  prefs: []
  type: TYPE_NORMAL
- en: 15.7\. PROJECTS - TCP AND UDP
  id: totrans-2351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before writing about Network Communication Protocols, think about the following
    questions:'
  id: totrans-2352
  prefs: []
  type: TYPE_NORMAL
- en: '**Tablets of Stone:**'
  id: totrans-2353
  prefs: []
  type: TYPE_NORMAL
- en: How did your messaging go when you first started?
  id: totrans-2354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you need numbers on your tablets?
  id: totrans-2355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Was it a pain to use up tablet space on numbers and other information?
  id: totrans-2356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you ever get to reliable communication?
  id: totrans-2357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packet Attack:**'
  id: totrans-2358
  prefs: []
  type: TYPE_NORMAL
- en: What happens if you add too many kills, corrupts and delays? Is there a relationship
    between this and time taken to transmit the message? Try graphing it
  id: totrans-2359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if you turn off all the defenses?
  id: totrans-2360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if you have no kills, corrupts and delays?
  id: totrans-2361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if you only have delays?
  id: totrans-2362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if you kill a packet creature when it tries to get sent the second
    time?
  id: totrans-2363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What other situations can you get the protocol in?
  id: totrans-2364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PACKET ATTACK LEVEL CREATOR
  id: totrans-2365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check any defenses you want, enter some values for the attacks and click Create
    Level
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
- en: Shields
  id: totrans-2367
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
- en: Timeouts
  id: totrans-2369
  prefs: []
  type: TYPE_NORMAL
- en: Return Packet Creatures
  id: totrans-2370
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of Delays:'
  id: totrans-2371
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of Corrupts:'
  id: totrans-2372
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of Kills:'
  id: totrans-2373
  prefs: []
  type: TYPE_NORMAL
- en: 'For a project, using the knowledge you have gained on TCP and UDP, create some
    custom levels in Packet Attack using the controls just above to create some unique
    situations that illustrate different aspects of Network Protocols. The following
    questions will help you to reflect on the issues that you could talk about:'
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
- en: What problems did you encounter when transmitting data across networks? Talk
    about problems that you encountered at the start of Tablets of Stone (photos of
    examples from various stages of the activity are a great way to illustrate it!)
  id: totrans-2375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the use of TCP and UDP in networks today, with example situations. Which
    systems use TCP? Which use UDP?
  id: totrans-2376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain at least two techniques used by TCP and UDP to address the problems
    above. Show some examples from Packet Attack (and/or Tablets of Stone) that illustrate
    the concepts.
  id: totrans-2377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For systems that require TCP, what might happen to them if TCP did not exist
    and they had to use UDP?
  id: totrans-2378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Discuss the differences between TCP and UDP, why each exists, and why you would
    choose a particular protocol for several scenarios.
  id: totrans-2379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the performance of protocols like TCP change as the reliability of
    the connection varies? You could look at how the speed of getting data through
    changes if lots of packets need to be re-sent.
  id: totrans-2380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 15.8\. THE WHOLE STORY
  id: totrans-2381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say I want to write an online music player. Okay, so I write the code
    for someone to press play on a website and the song plays. Do I now need to code
    up the protocol that streams the music? Fine, I write some UDP code. Now, do I
    need to go install the cables in your house? Sure, I jump in my van and spend
    a few weeks running cable to your house and make sure the packets can get over
    too.
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
- en: No. This sounds absurd. As a web developer, I don’t want to worry about anything
    other than making my music player easy to use and fast. I *don’t* want to worry
    about UDP and I *don’t* want to worry about ethernet or cables. It’s already done,
    I can assume it’s take care of. And it is.
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
- en: Internet protocols exist in layers. We have four such layers in the computer
    science internet model. The top two levels are discussed above in detail, the
    bottom two we won’t focus on.The first layer is the Application Layer, followed
    by the Transport, Internet and Link layers.
  id: totrans-2384
  prefs: []
  type: TYPE_NORMAL
- en: At each layer, data is made up of the previous layers’ whole unit of data, and
    then *headers* are added and passed down. At the bottom layer, the Link layer,
    a *footer* is added also. Below is an example of what a UDP packet looks like
    when it’s packaged up for transport.
  id: totrans-2385
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
- en: Footers and Headers are basically packet *meta-data*. Information about the
    information. Like a letterhead or a footnote, they’re not part of the content,
    but they are on the page. Headers and Footers exist on packets to store data.
    Headers come before the data and footers afterwards.
  id: totrans-2387
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ade27d0061.png)'
  id: totrans-2388
  prefs: []
  type: TYPE_IMG
- en: You can think of these protocols as a game of pass the parcel. When a message
    is sent in HTTP, it is wrapped in a TCP header, which is then wrapped in an IPv6
    header, which is then wrapped in a Ethernet header and footer and sent over ethernet.
    At the other end, it’s unwrapped again from an ethernet *frame*, back to a IP*packet*,
    a TCP *datagram*, to a HTTP *request*.
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
- en: '**Jargon Buster**'
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
- en: The name packet is a generic term for a unit of data. In the application layer
    units of data are called *data* or *requests*, in the transport layer, *datagram* or*segments*,
    in the Network/IP layer, *packet* and in the physical layer, a *frame*. Each level
    has its own name for a unit of data (segment, packet, frame, request etc), however
    the more generic “packet” is often used instead, regardless of layer.
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
- en: This system is neat because each layer can assume that the layer above and below
    have guaranteed something about the information, and each layer (and protocol
    in use at that layer) has a stand-alone role. So if you’re making a website you
    just have to program website code, and not worry about code to make the site work
    over wifi as well as ethernet. A similar system is in the postal system… You don’t
    put the courier’s truck number on the front of the envelope! That’s take care
    of by the post company, which then uses a system to sort the mail and assign it
    to drivers, and then drivers to trucks, and then drivers to routes… none of which
    you need to worry about when you send or receive a letter or use a courier.
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
- en: So what does a TCP segment look like?
  id: totrans-2393
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ade247f257.png)'
  id: totrans-2394
  prefs: []
  type: TYPE_IMG
- en: As you can see, a packet is divided into four main parts, addresses (source,
    destination), numbers (sequence number, ANCK number if it’s an acknowledgement),
    flags (urgent, checksum) in the header, then the actual data. At each level, a
    segment becomes the data for the next data unit, and that again gets its own header.
  id: totrans-2395
  prefs: []
  type: TYPE_NORMAL
- en: TCP and UDP packets have a number with how big they are. This number means that
    the packet can actually be as big as you like. Can you think of any advantages
    of having small packets? How about big ones? Think about the ratio of data to
    information (such as those in the header and footer).
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity**'
  id: totrans-2397
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example of a packet trace on our network…(using [tcpdump on the mac)](http://support.apple.com/kb/HT3994)
  id: totrans-2398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-2399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 15.9\. FURTHER READING
  id: totrans-2400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [`two generals problem`__](http://csfieldguide.org.nz/NetworkCommunicationProtocols.html#id6) is
    a famous problem in protocols to talk about what happens when you can’t be sure
    about communication success
  id: totrans-2401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if you were to send packets tied to birds? [IP over Avian Cariers](http://en.wikipedia.org/wiki/IP_over_Avian_Carriers)
  id: totrans-2402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocols are found in the strangest of places…. [Engine Order Telegraph](http://en.wikipedia.org/wiki/Engine_order_telegraph)
  id: totrans-2403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coursera course on [Internet History, Technology, and Security](https://www.coursera.org/learn/insidetheinternet)
  id: totrans-2404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.9.1\. EXTRA ACTIVITIES
  id: totrans-2405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CS Unplugged Routing - Why do packets get delayed? [http://csunplugged.org/routing-and-deadlock](http://csunplugged.org/routing-and-deadlock)
  id: totrans-2406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snail Mail - [http://www.cs4fn.org/internet/realsnailmail.php](http://www.cs4fn.org/internet/realsnailmail.php)
  id: totrans-2407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code.org - The Internet [https://learn.code.org/s/1/level/102](https://learn.code.org/s/1/level/102)
  id: totrans-2408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15.9.2\. USEFUL LINKS
  id: totrans-2409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[http://simple.wikipedia.org/wiki/TCP/IP](http://simple.wikipedia.org/wiki/TCP/IP)'
  id: totrans-2410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Internet_protocol_suite](http://en.wikipedia.org/wiki/Internet_protocol_suite)'
  id: totrans-2411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol](http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)'
  id: totrans-2412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Internet_Relay_Chat](http://en.wikipedia.org/wiki/Internet_Relay_Chat)'
  id: totrans-2413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Transmission_Control_Protocol](http://en.wikipedia.org/wiki/Transmission_Control_Protocol)'
  id: totrans-2414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/User_Datagram_Protocol](http://en.wikipedia.org/wiki/User_Datagram_Protocol)'
  id: totrans-2415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://csunplugged.org/routing-and-deadlock](http://csunplugged.org/routing-and-deadlock)'
  id: totrans-2416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16\. SOFTWARE ENGINEERING
  id: totrans-2417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 16.1\. WHAT’S THE BIG PICTURE?
  id: totrans-2418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software failures happen all the time. Sometimes it’s a little bug that makes
    a program difficult to use; other times an error might crash your entire computer.
    Some software failures are more spectacular than others.
  id: totrans-2419
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1996, The ARIANE 5 rocket of the European Space Agency was launched for
    its first test flight: Countdown, ignition, flame and smoke, soaring rocket...
    then BANG! Lots of little pieces scattered through the South American rainforest.
    Investigators had to piece together what happened and finally tracked down this
    tiny, irrelevant bug. A piece of software on board the rocket which was not even
    needed had reported an error and started a self-destruct sequence. Thankfully,
    no one was on board but the failure still caused about US$370m damage.'
  id: totrans-2420
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae351997df.png)'
  id: totrans-2421
  prefs: []
  type: TYPE_IMG
- en: In extreme cases, software bugs can endanger lives. This happened in the 1980s,
    for example, when a [radiation therapy machine](http://en.wikipedia.org/wiki/Therac) caused
    the deaths of 3 patients by giving 100 times the intended dose of radiation. And
    in 1979, a US army computer almost started a nuclear war, when it misinterpreted
    a simulation of the Soviet Union launching a missile as the real thing! (If you
    are interested in other software failures, [CS4FN](http://www.cs4fn.org/softwareengineering/backtodrawingboard.php) lists
    the most spectacular ones!)
  id: totrans-2422
  prefs: []
  type: TYPE_NORMAL
- en: 'Our society today is so reliant on software that we can’t even imagine life
    without it anymore. In many ways, software has made our lives easier: we write
    emails, chat with friends on Facebook, play computer games and search for information
    on Google. Heaps of software is hidden behind the scenes too so we don’t even
    know we’re using it, for example in cars, traffic lights, TVs, washing machines,
    Japanese toilets, and hearing aids. We’ve become so used to having software, we
    expect it to work at all times!'
  id: totrans-2423
  prefs: []
  type: TYPE_NORMAL
- en: So why doesn’t it? Why do we get bugs in the first place? As it turns out, writing
    software is incredibly difficult. Software isn’t a physical product, so we can’t
    just look at it to see if it’s correct. On top of that, most of the software you
    use every day is huge and extremely complex. Windows Vista is rumoured to have
    around 50 million lines of code; MacOSX even has 86 million. If we printed Vista
    out on paper, we would get a 88m high stack! That’s as high as a 22 storey building
    or the Statue of Liberty in New York! If you wanted to read through Vista and
    try to understand how it works, you can expect to get through about 120 lines
    per hour, so it would take you 417,000 hours or 47 ½ years! (And that’s just to
    read through it, not write it.)
  id: totrans-2424
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae350d2c61.png)'
  id: totrans-2425
  prefs: []
  type: TYPE_IMG
- en: Software engineering is all about how we can create software despite this enormous
    size and complexity and hopefully get a working product in the end. It was first
    introduced as a topic of computer science in the 1960s during the so-called “software
    crisis”, when people realised that the capability of hardware was increasing at
    incredible speeds while our ability to develop software is staying pretty much
    the same.
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
- en: As the name software engineering suggests, we are taking ideas and processes
    from other engineering disciplines (such as building bridges or computer hardware)
    and applying them to software. Having a structured process in place for developing
    software turns out to be hugely important because it allows us to manage the size
    and complexity of software. As a result of advances in software engineering, there
    are many success stories of large and complex software products which work well
    and contain few bugs. Think, for example, of Google who have huge projects (Google
    search, Gmail, …) and thousands of engineers working on them but somehow still
    manage to create software that does what it should.
  id: totrans-2427
  prefs: []
  type: TYPE_NORMAL
- en: Since the 1960s, software engineering has become a very important part of computer
    science, so much so that today programmers are rarely called programmers, but
    software engineers. That’s because making software is much more than just programming.
    There are a huge number of jobs for software engineers and demand for skilled
    workers continues to grow. The great thing about being a software engineer is
    that you get to work in large teams to produce products that will impact the lives
    of millions of people! Although you might think that software engineers would
    have to be very smart and a bit geeky, communication and teamwork skills are actually
    more important; software engineers have to be able to work in teams and communicate
    with their teammates. The ability to work well with humans is at least as important
    as the ability to work with computers.
  id: totrans-2428
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity: Moore’s Law**'
  id: totrans-2429
  prefs: []
  type: TYPE_NORMAL
- en: In 1965, Gordon Moore noticed that the number of transistors on integrated circuits
    was doubling about every 2 years. This means that computers’ processing power
    was doubling roughly every 2 years (sometimes this is quoted as 18 months due
    to the combination of the numbers *and* speed increasing). Moore said that he
    expected this trend to continue for at least 10 years.
  id: totrans-2430
  prefs: []
  type: TYPE_NORMAL
- en: Believe it or not, Moore’s law didn’t just last for 10 years but is still true
    nearly 50 years later (although a slowdown is predicted in the next couple of
    years). This means that computers today are over 100 million times faster than
    in 1965! (It’s been 47 years since 1965, which means that processing power has
    doubled about 24 times; 2^{24} is 16,777,216 so if computers could run one instruction
    per second in 1965, they can now run 16,777,216!) It also means that if you buy
    a computer today, you might regret it in two years time when new computers will
    be twice as fast. Moore’s law also holds for other things, such as processing
    power in cellphones and the number of pixels in digital cameras.
  id: totrans-2431
  prefs: []
  type: TYPE_NORMAL
- en: The exact numbers above will depend on exactly what you’re describing, but the
    main point is that the processing power is increasing *exponentially* — exponential
    growth doesn’t mean just getting a lot faster, but getting unbelievably faster;
    nothing in human history has ever grown this quickly! To illustrate this in reverse,
    the time taken to open an app on a smartphone might be half a second today, but
    a 1965 smartphone would have taken over a year to open the same app (and the phone
    would probably have been the size of a football field). It’s no wonder that smartphones
    weren’t popular in the 1960s.
  id: totrans-2432
  prefs: []
  type: TYPE_NORMAL
- en: Although software engineering has come a long way in the last decades, writing
    software is still difficult today. As a user, you only see the programs that were
    completed, not those that failed. In 2009, just under a third of all software
    projects succeeded, while almost a quarter failed outright or were cancelled before
    the software could be delivered. The remaining projects were either delivered
    late, were over budget or lacked functionality. A famous recent project failure
    was the software for the baggage handling system at the new airport in Denver.
    The system turned out to be more complex than engineers had expected; in the end,
    the entire airport was ready but had to wait for 16 months before it could be
    opened because the software for the baggage system was not working. Apparently,
    the airport lost $1 million every day during these 16 months!
  id: totrans-2433
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we look at some of the basics of software engineering. We’ll
    give you an introduction about *analysing* the problem so you know what kind of
    software to build in the first place; we’ll talk briefly about how to structure
    and *design* software and tell you a bit about *testing*, one of the most important
    steps for avoiding software bugs. As you’ll see below, analysis, design and testing
    are all important steps when making software. The actual programming part usually
    takes up only 20% of time on a project (and in this chapter we barely even mention
    it)! Finally, we’ll look at software processes which organise activities including
    analysis, design and testing so that we always know what we should be doing next.
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
- en: '16.2\. ANALYSIS: WHAT DO WE BUILD?'
  id: totrans-2435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to start making software, we first have to decide what we actually
    want to make. We call this part of the software project *analysis* because we
    analyse exactly what our software needs to be able to do. Although this sounds
    trivial, getting the details right is pretty tricky. If someone asked you to design
    a physical object like a chair or a toaster, you’d probably have a pretty good
    idea of what the finished product would be like. No matter how many legs you decide
    to put on your chair, they will still have to do the job of holding up a person
    against the force of gravity. When designing software, we often don’t have the
    benefit of creating familiar objects, or even known constraints like the laws
    of physics. If your software was, say, a program to help authors invent imaginary
    worlds, where would you start? What could you take for granted?
  id: totrans-2436
  prefs: []
  type: TYPE_NORMAL
- en: Analysis is extremely important. Obviously, if we make a mistake at this stage
    of the project, the software we end up building may not be what we wanted; all
    the other work to design, build and test the software could be for nothing.
  id: totrans-2437
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine your friend Anna asks you to write a program to help her
    get to school in the morning. You write a great GPS navigation system and show
    it to Anna, but it turns out that she takes to bus to school so what she really
    needed was just software showing the current bus timetable. All your hard work
    was in vain, because you didn’t get the details right in the start!
  id: totrans-2438
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we are making software for ourselves; in that case, we can just decide
    what the software should do. (But be careful: even if you think you know what
    you want the software to do when you start developing it, you will probably find
    that by the end of the project you will have a very different view of what it
    should do. The problem is that before you have the software, you can’t really
    predict how you will use it when it’s finished. For example, the people making
    smart phones and software for smart phones probably didn’t anticipate how many
    people would want to use their smart phones as torches!)'
  id: totrans-2439
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, we build software for other people. You might make a website
    for your aunt’s clothing shop or write software to help your friends with their
    maths homework. A software company might create software for a local council or
    a GP’s practice. Google and Microsoft make software used by millions of people
    around the world. Either way, whether you’re writing a program for your friends
    or for millions of people, you first have to find out from your customers what
    they actually need the software to do.
  id: totrans-2440
  prefs: []
  type: TYPE_NORMAL
- en: We call anyone who has an interest in the software a *stakeholder*. These are
    the people that you need to talk to during the analysis part of your project to
    find out what they need the software to do.
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you are making a phone app that allows students to preorder food
    from the school cafeteria. They can use the app to request the food in the morning
    and then just go a pick up the food at lunch time. The idea is that this should
    help streamline the serving of food and reduce queues in the cafeteria. Obvious
    stakeholders for your project are the students (who will be using the phone app)
    and cafeteria staff (who will be receiving requests through the app). Less obvious
    (and indirect) stakeholders include parents (“I have to buy Johnny an iPhone so
    he can use this app?”), school admin (“No phones should be used during school
    time!”) and school IT support who will have to deal with all the students who
    can’t figure out how to work the app. Different stakeholders might have very different
    ideas about what the app should do.
  id: totrans-2442
  prefs: []
  type: TYPE_NORMAL
- en: To find out what our stakeholders want the software to do, we usually interview
    them. We ask them questions to find *functional* and *non-functional* requirements
    for the software. Functional requirements are things the software needs to do.
    For example, your phone app needs to allow students to choose the food they want
    to order. It should then send the order to the cafeteria, along with the student’s
    name so that they can be easily identified when picking up the food.
  id: totrans-2443
  prefs: []
  type: TYPE_NORMAL
- en: Non-functional requirements, on the other hand, don’t tell us *what* the software
    needs to do but *how* it needs to do it. How efficient does it need to be? How
    reliable? What sort of computer (or phone) does it need to run on? How easy to
    use should it be?
  id: totrans-2444
  prefs: []
  type: TYPE_NORMAL
- en: So we first figure out who our stakeholders are and then we go to interview
    them to find the requirements for the software. That doesn’t sound too hard, right?
    Unfortunately, it’s the communication with the customer that often turns out to
    be most difficult.
  id: totrans-2445
  prefs: []
  type: TYPE_NORMAL
- en: The first problem is that customers and software engineers often don’t speak
    the same language. Of course, we don’t mean to say that they don’t both speak
    English, but software engineers tend to use technical language, while customers
    use language specific to their work. For example, doctors might use a lot of scary
    medical terms that you don’t understand.
  id: totrans-2446
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that a customer asks you to develop a scoring system for the (fictional)
    sport of Whacky-Flob. The customer tells you “It’s really simple. You just need
    to record the foo-whacks, but not the bar-whacks, unless the Flob is circulating”.
    After this description, you’re probably pretty confused because you don’t know
    anything about the sport of Whacky-Flob and don’t know the specific terms used.
    (What on earth are foo-whacks???) To get started, you should attend a few games
    of Whacky-Flob and observe how the game and the scoring works. This way, you’ll
    be able to have a much better conversation with the customer since you have some
    knowledge about the problem domain. (Incidentally, this is one of the cool things
    about being a software engineer: you get exposure to all kinds of different, exciting
    problem domains. One project might be tracking grizzly bears, the next one might
    be identifying cyber terrorists or making a car drive itself.)'
  id: totrans-2447
  prefs: []
  type: TYPE_NORMAL
- en: You should also never assume that a customer is familiar with technical terms
    that you might think everyone should know, such as JPEG, database or maybe even
    operating system. Something like “The metaclass subclass hierarchy was constrained
    to be parallel to the subclass hierarchy of the classes which are their instances”
    might make some sense to a software engineer but a customer will just look at
    you very confused! One of the authors once took part in a customer interview where
    the stakeholder was asked if they want to use the system through a browser. Unfortunately,
    the customer had no idea what a browser was. Sometimes, customers may not want
    to admit that they have no idea what you’re talking about and just say “Yes” to
    whatever you suggest. Remember, it’s up to you to make sure you and your customer
    understand each other and that you get useful responses from your customer during
    the interview!
  id: totrans-2448
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae30e196ed.png)'
  id: totrans-2449
  prefs: []
  type: TYPE_IMG
- en: Even if you manage to communicate with a customer, you might find that they
    don’t really know what they want the software to do or can’t express it. They
    might say they want “software to improve their business” or to “make their work
    more efficient” but that’s not very specific. (There’s a great cartoon of [Dilbert](http://dilbert.com/strips/comic/2006-01-29/) which
    illustrates this point!) When you show them the software you have built, they
    can usually tell you if that’s what they wanted or what they like and don’t like
    about it. For that reason, it’s a good idea to build little prototypes while you’re
    developing your system and keep showing them to customers to get feedback from
    them.
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
- en: You’ll often find that customers have a specific process that they follow already
    and want the software to fit in with that. We were once involved in a project
    being done by university students for a library. Their staff used to write down
    information about borrowed items three times on a paper form, cut up the form
    and send the pieces to different places as records. When the students interviewed
    them, they asked for a screen in the program where they could enter the information
    three times as well (even though in a computer system there really isn’t much
    point in that)!
  id: totrans-2451
  prefs: []
  type: TYPE_NORMAL
- en: Customers are usually experts in their field and are therefore likely to leave
    out information that they think is obvious, but may not be obvious to you. Other
    times, they do not really understand what can and cannot be done with computers
    and may not mention something because they do not realise that it is possible
    to do with a computer. Again, it’s up to you to get this information from them
    and make sure that they tell you what you need to know.
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple stakeholders, you can get conflicting viewpoints. For example,
    when you talk to the cafeteria people about your food-ordering app, they may suggest
    that every student should only be able to order food up to a value of $10\. In
    this way, they want to avoid prank orders. When you talk to a teacher, they agree
    with this suggestions because they are worried about bullying. They don’t want
    one student to get pressured into ordering food for lots of other students. But
    the students tell you that they want to be able to order food for their friends.
    In their view, $10 isn’t even enough for one student.
  id: totrans-2453
  prefs: []
  type: TYPE_NORMAL
- en: What do you do about these conflicting points of view? Situations like this
    can be difficult to handle, depending on the situation, the stakeholders and the
    software you are making. In this case, you need the support from the cafeteria
    and the teachers for your software to work, but maybe you could negotiate a slightly
    higher order limit of $20 to try to keep all your stakeholders happy.
  id: totrans-2454
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, even if you get everything right during the analysis stage of your
    project, talk to all the stakeholders and find all the requirements for the software,
    requirements can change while you’re making the software. Big software projects
    can take years to complete. Imagine how much changes in the technology world in
    a year! While you’re working on the project, new hardware (phones, computers,
    tablets, …) could come out or a competitor might release software very similar
    to what you’re making. Your software itself might change the situation: once the
    software is delivered, the customer will try working with it and may realise it
    isn’t what they really wanted. So you should never take the requirements for your
    software to be set in stone. Ideally, you should keep talking to customers regularly
    throughout the project and always be ready for changes in requirements!'
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
- en: '16.2.1\. PROJECT: FINDING THE REQUIREMENTS'
  id: totrans-2456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this project, you need to find someone for whom you could develop software.
    This could be someone from your family or a friend. They might, for example, need
    software to manage information about their business’ customers or their squash
    club might want software to schedule squash tournaments or help with the timetabling
    of practices. (For this project, you won’t actually be making the software, just
    looking at the requirements; if the project is small enough for you to program
    on your own, it’s probably not big enough to be a good example for software engineering!)
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve found a project, start by identifying and describing the stakeholders
    for your project. (This project will work best if you have at least two different
    stakeholders.) Try to find all the stakeholders, remembering that some of them
    might only have an indirect interest in your software. For example, if you are
    making a database to store customer information, the customers whose information
    is being stored have some interest in your software even though they never use
    it directly; for example, they will want the software to be secure so that their
    data cannot be stolen. Write up a description about each stakeholder, giving as
    much background detail as possible. Who are they? What interest do they have in
    the software? How much technical knowledge do they have? …
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
- en: Interview *one* of the stakeholders to find out what they want the software
    to do. Write up the requirements for your software, giving some detail about each
    requirement. Try to distinguish between functional and non-functional requirements.
    Make sure you find out from your stakeholder which things are most important to
    them. This way you can give each requirement a priority (for example high, medium,
    low), so that if you would actually build the software you could start with the
    most important features.
  id: totrans-2459
  prefs: []
  type: TYPE_NORMAL
- en: For the other stakeholders, try to imagine what their requirements would be.
    In particular, try to figure out how the requirements would differ from the other
    stakeholders. It’s possible that two stakeholders have the same requirements but
    in that case maybe they have different priorities? See if you can list any potential
    disagreements or conflicts between your stakeholders? If so, how would you go
    about resolving them?
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
- en: '16.3\. DESIGN: HOW DO WE BUILD IT?'
  id: totrans-2461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have decided what your software needs to be able to do, you can actually
    build it. But just blindly starting to program is likely to get you into trouble;
    remember that most software is huge and very complex. You need to somehow minimise
    the amount of complexity in software, otherwise it will become impossible to understand
    and maintain for other developers in the future.
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
- en: Software design is all about managing this complexity and making sure that the
    software we create has a good structure. Before we start writing any code, we
    design the structure of our software in the *design* phase of the project. When
    you talk about software design, many people will think that you’re talking about
    designing what the software will look like. Here, we’re actually going to look
    at designing the *internal* structure of software.
  id: totrans-2463
  prefs: []
  type: TYPE_NORMAL
- en: 'So how can we design software in a way that it doesn’t end up hugely complex
    and impossible to understand? Here, we give you an introduction to two important
    approaches: subdivision and abstraction. Those are pretty scary words, but as
    you’ll see soon, the concepts behind them are surprisingly simple.'
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
- en: 'You can probably already guess what *subdivision* means: We break the software
    into many smaller parts that can be built independently. Each smaller part may
    again be broken into even smaller parts and so on. As we saw in the introduction,
    a lot of software is so large and complex that a single person cannot understand
    it all; we can deal much more easily with smaller parts. Large software is developed
    by large teams so different people can work on different parts and develop them
    in parallel, independently of each other. For example, for your cafeteria project,
    you might work on developing the database that records what food the cafeteria
    sells and how much each item costs, while your friend works on the actual phone
    app that students will use to order food.'
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
- en: Once we have developed all the different parts, all we need to do is make them
    communicate with each other. If the different parts have been designed well, this
    is relatively easy. Each part has a so-called *interface* which other parts can
    use to communicate with it. For example, your part of the cafeteria project should
    provide a way for another part to find out what food is offered and how much each
    item costs. This way, your friend who is working on the phone app for students
    can simply send a request to your part and get this information. Your friend shouldn’t
    need to know exactly how your part of the system works; they should just be able
    to send off a request and trust that the answer they get from your part is correct.
    This way, each person working on the project only needs to understand how their
    own part of the software works.
  id: totrans-2466
  prefs: []
  type: TYPE_NORMAL
- en: Ok, so let’s talk about the second concept, *abstraction*. Have you ever thought
    about why you can drive a car without knowing how its engine works? Or how you
    can use a computer without knowing much about hardware? Maybe you know what a
    processor and a hard drive is but could you build your own computer? Could your
    parents? We don’t need to know exactly how computers or cars work internally to
    be able to use them thanks to abstraction!
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
- en: If we look more closely at a computer, we can see that it actually has a number
    of *layers* of abstraction. Right at the bottom, we have the hardware, including
    the processor, RAM, hard disk and various complicated looking circuit boards,
    cables and plugs.
  id: totrans-2468
  prefs: []
  type: TYPE_NORMAL
- en: When you boot your computer, you start running the operating system. The operating
    system is in charge of communicating with the hardware, usually through special
    driver software. Once you’ve started your computer, you can run programs, for
    example your browser. The browser actually doesn’t communicate with the hardware
    directly but always goes through the operating system.
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’re the top layer of the system. You use the program but you will
    (hopefully) never have to interact with the more complicated parts of the operating
    system such as driver software, let alone the hardware. In this way, you can use
    the computer without ever having to worry about these things.
  id: totrans-2470
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae30d55358.png)'
  id: totrans-2471
  prefs: []
  type: TYPE_IMG
- en: We call a system like this a *layered system*. You can have any number of layers
    you want but each layer can only communicate with the one directly below it. The
    operating system can directly access the hardware but a program running on the
    computer can’t. You can use programs but hopefully will never have to access the
    hardware or the more complex parts of the operating system such as drivers. This
    again reduces the complexity of the system because each layer only needs to know
    about the layer directly below it, not any others.
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
- en: Each layer in the system needs to provide an interface so that the layer above
    it can communicate with it. For example, a processor provides a set of instructions
    to the operating system; the operating system provides commands to programs to
    create or delete files on the hard drive; a program provides buttons and commands
    so that you can interact with it.
  id: totrans-2473
  prefs: []
  type: TYPE_NORMAL
- en: One layer knows nothing about the internal workings of the layer below; it only
    needs to know how to use the layer’s interface. In this way, the complexity of
    lower layers is completely hidden, or *abstracted*. Each layer represents a higher
    level of abstraction.
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
- en: So each layer hides some complexity, so that as we go up the layers things remain
    manageable. Another advantage of having layers is that we can change one layer
    without affecting the others, as long as we keep the layer’s interface the same
    of course. For example, your browser’s code might change but you might never notice
    as long as the browser still looks and works the same as before. Of course, if
    the browser stops working or new buttons appear suddenly you know that something
    has changed.
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have the same “layered” approach inside a single program. For example,
    websites are often designed as so-called *three-tier* systems with three layers:
    a database layer, a logic layer and a presentation layer. The database layer usually
    consists of a database with the data that the website needs. For example, Facebook
    has a huge database where it keeps information about its users. For each user,
    it stores information about who their friends are, what they have posted on their
    wall, what photos they have added, and so on. The logic layer processes the data
    that it gets from the database. Facebook’s logic layer, for example, will decide
    which posts to show on your “Home” feed, which people to suggest as new friends,
    etc. Finally, the presentation layer gets information from the logic layer which
    it displays. Usually, the presentation layer doesn’t do much processing on the
    information it gets but simply creates the HTML pages that you see.'
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae30c9341c.png)'
  id: totrans-2477
  prefs: []
  type: TYPE_IMG
- en: '**Curiosity: Reuse - Kangaroos and Helicopters**'
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
- en: Since building software is so difficult and time-consuming, a popular idea has
    been to reuse existing software. Not surprisingly, we call this *software reuse*.
    It’s a great idea in theory (why recreate something that already exists?) but
    turns out to be difficult to put into practice partly because existing software
    is also huge and complicated. Usually when you reuse software, you want only a
    small part of the existing software’s functionality, rather than everything.
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
- en: An interesting story that illustrates the problems with software reuse (although
    it is unfortunately not completely accurate, see[http://www.snopes.com/humor/nonsense/kangaroo.asp](http://www.snopes.com/humor/nonsense/kangaroo.asp))
    is that of helicopters and kangaroos. The Australian Air Force was developing
    a new helicopter simulator to train pilots. They wanted the simulator to be as
    realistic as possible and therefore decided to include herds of kangaroos in the
    simulation. To save time, they reused code from another simulator which included
    foot soldiers and simply changed the icons of the soldiers to kangaroos.
  id: totrans-2480
  prefs: []
  type: TYPE_NORMAL
- en: Once the program was finished, they demonstrated it to some pilots. One of the
    pilots decided to fly the helicopter close to a herd of kangaroos to see what
    would happen. The kangaroos scattered to take cover when the helicopter approached
    (so far so good) but then, to the pilot’s extreme surprise, pulled out their guns
    and missile launchers and fired at the helicopter. It seemed the programmer had
    forgotten to remove *that* part of the code from the original simulator.
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
- en: '16.3.1\. PROJECT: DESIGNING YOUR SOFTWARE'
  id: totrans-2482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Think back to the requirements you found in the analysis project described above.
    In this project, we will look at how to design the software.
  id: totrans-2483
  prefs: []
  type: TYPE_NORMAL
- en: Start by thinking about how the software you are trying to build can be broken
    up into smaller parts. Maybe there is a database or a user interface or a website?
    For example, imagine you are writing software to control a robot. The robot needs
    to use its sensors to follow a black line on the ground until it reach a target.
    The software for your robot should have a part that interacts with the sensors
    to get information about what they “see”. It should then pass this information
    to another part, which analyses the data and decides where to move next. Finally,
    you should have a part of the software which interacts with the robot’s wheels
    to make it move in a given direction.
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
- en: Try to break down your software into as many parts as possible (remember, small
    components are much easier to build!) but don’t go too far - each part should
    perform a sensible task and be relatively independent from the rest of the system.
  id: totrans-2485
  prefs: []
  type: TYPE_NORMAL
- en: For each part that you have identified, write a brief description about what
    it does. Then think about how the parts would interact. For each part, ask yourself
    which other parts it needs to communicate with directly. Maybe a diagram could
    help visualise this?
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
- en: '16.4\. TESTING: DID WE BUILD THE RIGHT THING / DOES IT WORK?'
  id: totrans-2487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve decided what our software should do (analysis) and designed its internal
    structure (design), and the system has been programmed according to the design.
    Now, of course, we have to test it to make sure it works correctly.
  id: totrans-2488
  prefs: []
  type: TYPE_NORMAL
- en: Testing is an incredibly important part of developing software. We cannot really
    release software that still has lots of bugs to our customers. (Well, we could
    but our customers wouldn’t be very happy about it.) Remember that software bugs
    can have both very small and very large effects. On the less serious end of the
    scale, they might make a program difficult to use or crash your computer. On the
    other hand, they can cost millions of dollars and even endanger human life. More
    testing might have prevented the Ariane 5 failure or might have discovered the
    Therac bug which ended up killing 3 patients.
  id: totrans-2489
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, testing is again really difficult because of the size and complexity
    of software. If a piece of software would take years to read and understand, imagine
    how long it would take to fully test it!
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
- en: When we test software, we try lots of different inputs and see what outputs
    or behaviour the software produces. If the output is incorrect, we have found
    a bug.
  id: totrans-2491
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity: Bugs and Moths**'
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae306e1fde.jpg)'
  id: totrans-2493
  prefs: []
  type: TYPE_IMG
- en: In 1947, engineers working on a computer called the *Mark II* were investigating
    a computer error and found that it was caused by a moth which had become trapped
    inside the computer! Since then, we use the word *bug* to refer to computer errors.
    Of course, today we use the word to refer to errors in programs, rather than actual
    insects trapped in the computer.
  id: totrans-2494
  prefs: []
  type: TYPE_NORMAL
- en: The problem with testing is that it can only show the presence of errors, not
    their absence! If you get an incorrect output from the program, you know that
    you have found a bug. But if you get a correct output, can you really conclude
    that the program is correct? Not really. The software might work in this particular
    case but you cannot assume that it will work in other cases. No matter how thoroughly
    you test a program, you can never really be 100% sure that it’s correct. In theory,
    you would have to test every possible input to your system, but that’s not usually
    possible. Imagine testing Google for everything that people could search for!
    But even if we can’t test everything, we can try as many different test cases
    as possible and hopefully at least decrease the probability of bugs.
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
- en: As with design, we can’t possibly deal with the entire software at once, so
    we again just look at smaller pieces, testing one of them at a time. We call this
    approach *unit testing*. A unit test is usually done by a separate program which
    runs the tests on the program that you’re writing. That way you can run the tests
    as often as you like — perhaps once a day, or even every time there is a change
    to the program. It’s not unusual to write a unit test program before you write
    the actual program. It might seem like wasted work to have to write two programs
    instead of one, but being able to have your system tested carefully any time you
    make a change greatly improves the reliability of your final product, and can
    save a lot of time trying to find bugs in the overall system, since you have some
    assurance that each unit is working correctly.
  id: totrans-2496
  prefs: []
  type: TYPE_NORMAL
- en: Once all the separate pieces have been tested thoroughly, we can test the whole
    system to check if all the different parts work together correctly. This is called*integration
    testing*. Some testing can be automated while other testing needs to be done manually
    by the software engineer.
  id: totrans-2497
  prefs: []
  type: TYPE_NORMAL
- en: If I give you a part of the software to test, how would you start? Which test
    inputs would you use? How many different test cases would you need? When would
    you feel reasonably sure that it all works correctly?
  id: totrans-2498
  prefs: []
  type: TYPE_NORMAL
- en: There are two basic approaches you can take, which we call *black-box testing* and *white-box
    testing*. With black-box testing, you simply treat the program as a black box
    and pretend you don’t know how it’s structured and how it works internally. You
    give it test inputs, get outputs and see if the program acts as you expected.
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
- en: But how do you select useful test inputs? There are usually so many different
    ones to choose from. For example, imagine you are asked to test a program that
    takes a whole number and outputs its successor, the next larger number (e.g. give
    it 3 and you get 4, give it -10 and you get -9, etc). You can’t try the program
    for *all* numbers so which ones do you try?
  id: totrans-2500
  prefs: []
  type: TYPE_NORMAL
- en: You observe that many numbers are similar and if the program works for one of
    them it’s probably safe to assume it works for other similar numbers. For example,
    if the program works as you expect when you give it the number 3, it’s probably
    a waste of time to also try 4, 5, 6 and so on; they are just so similar to 3.
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
- en: This is the concept of *equivalence classes*. Some inputs are so similar, you
    should only pick one or two and if the software works correctly for them you assume
    that it works for all other similar inputs. In the case of our successor program
    above, there are two big equivalence classes, positive numbers and negative numbers.
    You might also argue that zero is its own equivalence class, since it is neither
    positive nor negative.
  id: totrans-2502
  prefs: []
  type: TYPE_NORMAL
- en: For testing, we pick a couple of inputs from each equivalence class. The inputs
    at the boundary of equivalence classes are usually particularly interesting. Here,
    we should definitely test -1 (this should output 0), 0 (this should output 1)
    and 1 (this should output 2). We should also try another negative and positive
    number not from the boundary, such as -48 and 57\. Finally, it can be interesting
    to try some very large numbers, so maybe we’ll take -2,338,678 and 10,462,873\.
    We have only tested 7 different inputs, but these inputs will probably cover most
    of the interesting behaviour of our software and should reveal most bugs.
  id: totrans-2503
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you might also want to try some invalid inputs, for example “hello”
    (a word) or “1,234” (a number with a comma in it) or “1.234” (a number with a
    decimal point). Often, test cases like these can get programs to behave in a very
    strange way or maybe even crash because the programmer hasn’t considered that
    the program might be given invalid inputs. Remember that especially human users
    can give you all sorts of weird inputs, for example if they misunderstand how
    the program should be used. In case of an invalid input, you probably want the
    program to tell the user that the input is invalid; you definitely don’t want
    it to crash!
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
- en: Black-box testing is easy to do but not always enough because sometimes finding
    the different equivalence classes can be difficult if you don’t know the internal
    structure of the program. When we do white-box testing, we look at the code we
    are testing and come up with test cases that will execute as many different lines
    of code as possible. If we execute each line at least once, we should be able
    to discover a lot of bugs. We call this approach *code coverage* and aim for 100%
    coverage, so that each line of code is run at least once. In reality, even 100%
    code coverage won’t necessarily find all bugs though, because one line of code
    might work differently depending on inputs and values of variables in a program.
    Still, it’s a pretty good start.
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is very useful for finding bugs. It helps us find out if the program
    works as *we* intended. Another important question during testing is if the software
    does what the *customer* wanted (Did we build the right thing?). *Acceptance testing* means
    showing your program to your stakeholders and getting feedback about what they
    like or don’t like. Any mistakes that we made in the analysis stage of the project
    will probably show up during acceptance testing. If we misunderstood the customer
    during the interview, our *unit tests* might pass (i.e. the software does what
    we thought it should) but we may still have an unhappy customer.
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
- en: Different stakeholders can be very different, for example in terms of technical
    skills, or even could have given us conflicting requirements for the software.
    It’s therefore of course possible to get positive feedback from one stakeholder
    and negative feedback from another.
  id: totrans-2507
  prefs: []
  type: TYPE_NORMAL
- en: '16.4.1\. PROJECT: ACCEPTANCE TESTING'
  id: totrans-2508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this project, choose a small program such as a Windows desktop gadget or
    an Apple dashboard widget. (For example, you can find a good selection of Windows
    gadgets at [http://www.thoosje.com/desktop-gadgets-gallery.html](http://www.thoosje.com/desktop-gadgets-gallery.html))
    Pick something that you find particularly interesting or useful! Start by reading
    the description of the program to find out what it does *before* you try it out.
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
- en: Next, think about a stakeholder for this software. Who would use it and why?
    Briefly write down some background information about the stakeholder (as in the
    analysis project) and their main requirements. Note which requirements would be
    most important to them and why.
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can go ahead and install the program and play around with it. Try
    to imagine that you are the stakeholder that you described above. Put yourself
    in this person’s shoes. How would they feel about this program? Does it meet your
    requirements? What important features are missing? Try to see if you can find
    any particular problems or bugs in the program. (Tip: sometimes giving programs
    unexpected input, for example a word when they were expecting a number, can cause
    some interesting behaviour.)'
  id: totrans-2511
  prefs: []
  type: TYPE_NORMAL
- en: Write up a brief acceptance test report about what you found. Try to link back
    to the requirements that you wrote down earlier, noting which have been met (or
    maybe partially met) and which haven’t. Do you think that overall the stakeholder
    would be happy with the software? Do you think that they would be likely to use
    it? Which features would you tell the software developers to implement next?
  id: totrans-2512
  prefs: []
  type: TYPE_NORMAL
- en: 16.5\. SOFTWARE PROCESSES
  id: totrans-2513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far in this chapter, you’ve learned about different phases of software development:
    analysis, design and testing. But how do these phases fit together? At what time
    during the project do we do what activity? That’s the topic of *software processes*.'
  id: totrans-2514
  prefs: []
  type: TYPE_NORMAL
- en: The obvious answer would be to start with analysis to figure out what we want
    to build, then design the structure of the software, implement everything and
    finally test the software. This is the simplest software process called the *waterfall
    process*.
  id: totrans-2515
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae306154cf.png)'
  id: totrans-2516
  prefs: []
  type: TYPE_IMG
- en: 'The waterfall process is borrowed from other kinds of engineering. If we want
    to build a bridge, we go through the same phases of analysis, design, implementation
    and testing: we decide what sort of bridge we need (How long should it be? How
    wide? How much load should it be able to support?), design the bridge, build it
    and finally test it before we open it to the public. It’s been done that way for
    many decades and works very well, for bridges at least.'
  id: totrans-2517
  prefs: []
  type: TYPE_NORMAL
- en: We call this process the waterfall process because once you “jump” from one
    phase of the project to the next, you can’t go back up to the previous one. In
    reality, a little bit of backtracking is allowed to fix problems from previous
    project phases but such backtracking is usually the exception. If during the testing
    phase of the project you suddenly find a problem with the requirements you certainly
    won’t be allowed to go back and rewrite the requirements.
  id: totrans-2518
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae30540347.png)'
  id: totrans-2519
  prefs: []
  type: TYPE_IMG
- en: 'An advantage of the waterfall process is that it’s very simple and easy to
    follow. At any point in the project, it’s very clear what stage of the project
    you are at. This also helps with planning: if you’re in the testing stage you
    know you’re quite far into the project and should finish soon. For these reasons,
    the waterfall process is very popular with managers who like to feel in control
    of where the project is and where it’s heading.'
  id: totrans-2520
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity: Hofstadter’s law**'
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
- en: Your manager and customer will probably frequently ask you how much longer the
    project is going to take and when you will finally have the finished program.
    Unfortunately, it’s really difficult to know how much longer a project is going
    to take. According to Hofstadter’s law, “It always takes longer than you expect,
    even when you take into account Hofstadter’s Law.”
  id: totrans-2522
  prefs: []
  type: TYPE_NORMAL
- en: Because it’s just so nice and simple, the waterfall process is still in many
    software engineering textbooks and is widely used in industry. The only problem
    with this is that the waterfall process just does not work for most software projects.
  id: totrans-2523
  prefs: []
  type: TYPE_NORMAL
- en: So why does the waterfall process not work for software when it clearly works
    very well for other engineering products like bridges (after all, most bridges
    seem to hold up pretty well...)? First of all, we need to remember that software
    is very different from bridges. It is far more complex. Understanding the plans
    for a single bridge and how it works might be possible for one person but the
    same is not true for software. We cannot easily look at software as a whole (other
    than the code) to see its structure. It is not physical and thus does not follow
    the laws of physics. Since software is so different from other engineering products,
    there really is no reason why the same process should necessarily work for both.
  id: totrans-2524
  prefs: []
  type: TYPE_NORMAL
- en: To understand why the waterfall process doesn’t work, think back to our section
    about analysis and remember how hard it is to find the right requirements for
    software. Even if you manage to communicate with the customers and resolve conflicts
    between the stakeholders, the requirements could still change while you’re developing
    the software. Therefore, it is very unlikely that you will get the complete and
    correct requirements for the software at the start of your project.
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
- en: If you make mistakes during the analysis phase, most of them are usually found
    in the testing stage of the project, particularly when you show the customer your
    software during acceptance testing. At this point, the waterfall process doesn’t
    allow you to go back and fix the problems you find. Similarly, you can’t change
    the requirements halfway through the process. Once the analysis phase of the project
    is finished, the waterfall process “freezes” the requirements. In the end of your
    project, you will end up with software that hopefully fulfills *those* requirements,
    but it is unlikely that those will be the *correct* requirements. You end up having
    to tell the customer that they got what they asked for, not what they needed.
    If they’ve hired you, they’ll be annoyed; it it’s software that you’re selling
    (such as a smartphone app), people just won’t bother buying it.
  id: totrans-2526
  prefs: []
  type: TYPE_NORMAL
- en: You can also get things wrong at other points in the project. For example, you
    might realise while you’re writing the code that the design you came up with doesn’t
    really work. But the waterfall process tells you that you have to stick with it
    anyway and make it work somehow.
  id: totrans-2527
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae2e58b4b2.png)'
  id: totrans-2528
  prefs: []
  type: TYPE_IMG
- en: Design by [Paragon Innovations](http://www.paragoninnovations.com/guide.shtml) and
    drawn by [Project Cartoon](http://www.projectcartoon.com/about/)
  id: totrans-2529
  prefs: []
  type: TYPE_NORMAL
- en: So if the waterfall process doesn’t work, what can we do instead? Most modern
    software development processes are based on the concept of iteration. We do a
    bit of analysis, followed by some design, some programming and some testing. (We
    call this one iteration.) This gives us a rather rough prototype of what the system
    will look like. We can play around with the prototype, show it to customers and
    see what works and what doesn’t. Then, we do the whole thing again. We refine
    our requirements and do some more design, programming and testing to make our
    prototype better (another iteration). Over time, the prototype grows into the
    final system, getting closer and closer to what we want.
  id: totrans-2530
  prefs: []
  type: TYPE_NORMAL
- en: '![](563ae2e45b08e.png)'
  id: totrans-2531
  prefs: []
  type: TYPE_IMG
- en: The advantage with this approach is that if you make a mistake, you will find
    it soon (probably when you show the prototype to the customer the next time) and
    have the opportunity to fix it. The same is true if requirements change suddenly;
    you are flexible and can respond to changes quickly. You also get a lot of feedback
    from the customers as they slowly figures out what they need.
  id: totrans-2532
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of different software processes that use iteration (we call
    them *iterative processes*); a famous one is the *spiral model*. Although the
    details of the different processes vary, they all use the same iteration structure
    and tend to work very well for software.
  id: totrans-2533
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the question of what we do at what point of the project, another
    interesting question addressed by software processes is how much time we should
    spend on the different project phases. You might think that the biggest part of
    a software project is programming, but in a typical project, programming usually
    takes up only about 20% of the total time! 40% is spent on analysis and design
    and another 40% on testing. This shows that software engineering is so much more
    than programming.
  id: totrans-2534
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve finished developing your program and given it to the customer, the
    main part of the software project is over. Still, it’s important that you don’t
    just stop working on it. The next part of the project, which can often go on for
    years, is called *maintenance*. During this phase you fix bugs, provide customer
    support and maybe add new features that customers need.
  id: totrans-2535
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity: Brooks’s law**'
  id: totrans-2536
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that your project is running late and your customer is getting impatient.
    Your first instinct might be to ask some of your friends if they can help out
    so that you have more people working on the project. Brooks’s law, however, suggests
    that that is exactly the wrong thing to do!
  id: totrans-2537
  prefs: []
  type: TYPE_NORMAL
- en: Brooks’s law states that “adding manpower to a late software project makes it
    later.” This might seem counterintuitive at first because you would assume that
    more people would get more work done. However, the overhead of getting new people
    started on the project (getting them to understand what you are trying to build,
    your design, the existing code, and so on) and of managing and coordinating the
    larger development team actually makes things slower rather than faster in the
    short term.
  id: totrans-2538
  prefs: []
  type: TYPE_NORMAL
- en: '16.5.1\. ACTIVITY: FUN WITH THE WATERFALL PROCESS'
  id: totrans-2539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The waterfall process is simple and commonly used but doesn’t really work in
    practice. In this activity, you’ll get to see why. First, you will create a design
    which you then pass on to another group. They have to implement your design exactly
    and are not allowed to make any changes, even if it doesn’t work!
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
- en: You need a deck of cards and at least 6 people. Start by dividing up into groups
    of about 3-4 people. You need to have at least 2 groups. Each group should grab
    two chairs and put them about 30cm apart. The challenge is to build a bridge between
    the two chairs using only the deck of cards!
  id: totrans-2541
  prefs: []
  type: TYPE_NORMAL
- en: Before you get to build an actual bridge, you need to think about how you are
    going to make a bridge out of cards. Discuss with you team members how you think
    this could work and write up a short description of your idea. Include a diagram
    to make your description understandable for others.
  id: totrans-2542
  prefs: []
  type: TYPE_NORMAL
- en: Now exchange your design with another group. Use the deck of cards to try to
    build your bridge to the exact specification of the other group. You may not alter
    their design in any way (you are following the waterfall process here!). As frustrating
    as this can be (especially if you know how to fix the design), if it doesn’t work,
    it doesn’t work!
  id: totrans-2543
  prefs: []
  type: TYPE_NORMAL
- en: If you managed to build the bridge, congratulations to you and the group that
    managed to write up such a good specification! If you didn’t, you now have a chance
    to talk to the other group and give them feedback about the design. Tell them
    about what problems you had and what worked or didn’t work. The other group will
    tell you about the problems they had with your design!
  id: totrans-2544
  prefs: []
  type: TYPE_NORMAL
- en: Now, take your design back and improve it, using what you just learnt about
    building bridges out of cards and what the other group told you. You can experiment
    with cards as you go, and keep changing the design as you learn about what works
    and what doesn’t (this is an agile approach). Keep iterating (developing ideas)
    until you get something that works.
  id: totrans-2545
  prefs: []
  type: TYPE_NORMAL
- en: Which of these two approaches worked best — designing everything first, or doing
    it in the agile way?
  id: totrans-2546
  prefs: []
  type: TYPE_NORMAL
- en: '16.5.2\. ACTIVITY: A NAVIGATION LANGUAGE'
  id: totrans-2547
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this activity, you will develop a language for navigating around your school.
    Imagine that you need to describe to your friend how to get to a particular classroom.
    This language will help you give a precise description that your friend can easily
    follow.
  id: totrans-2548
  prefs: []
  type: TYPE_NORMAL
- en: First, figure out what your language has to do (i.e. find the *requirements*).
    Will your language be for the entire school or only a small part? How exact will
    the descriptions be? How long will the descriptions be? How easy will they be
    to follow for someone who does / doesn’t know your language? How easy will it
    be to learn? …
  id: totrans-2549
  prefs: []
  type: TYPE_NORMAL
- en: Now, go ahead and *design* the language. Come up with different commands (e.g.
    turn left, go forward 10, …). Make sure you have all the commands you need to
    describe how to get from one place in your school to any other!
  id: totrans-2550
  prefs: []
  type: TYPE_NORMAL
- en: Finally, *test* the language using another student. Don’t tell them where they’re
    going, just give them instructions and see if they follow them correctly. Try
    out different cases until you are sure that your language works and that you have
    all the commands that you need. If you find any problems, go back and fix them
    and try again!
  id: totrans-2551
  prefs: []
  type: TYPE_NORMAL
- en: Note down how much time each of the different phases of the project take you.
    When you have finished, discuss how much time you spent on each phase and compare
    with other students. Which phase was the hardest? Which took the longest? Do you
    think you had more time for some of the phases? What problems did you encounter?
    What would you do differently next time around?
  id: totrans-2552
  prefs: []
  type: TYPE_NORMAL
- en: '16.5.3\. ACTIVITY: BLOCK BUILDING (PRECISE COMMUNICATION)'
  id: totrans-2553
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Communicating clearly with other software engineers and customers is essential
    for software engineers. In this activity, you get to practice communicating as
    precisely as possible!
  id: totrans-2554
  prefs: []
  type: TYPE_NORMAL
- en: Divide up into pairs, with one *creator* and one *builder* in each pair. Each
    person needs a set of at least 10 coloured building blocks (e.g. lego blocks).
    Make sure that each pair has a matching set of blocks or this activity won’t work!
  id: totrans-2555
  prefs: []
  type: TYPE_NORMAL
- en: The two people in each pair should not be able to see each other but need to
    be able to hear each other to communicate. Put up a screen between the people
    in each pair or make them face in opposite directions. Now, the creator builds
    something with their blocks. The more creative you are the more interesting this
    activity will be!
  id: totrans-2556
  prefs: []
  type: TYPE_NORMAL
- en: When the creator has finished building, it’s the builders turn. His or her aim
    is to build an exact replica of the creator’s structure (but obviously without
    knowing what it looks like). The creator should describe exactly what they need
    to do with the blocks. For example, the creator could say “Put the small red block
    on the big blue block” or “Stand two long blue blocks up vertically with a one
    block spacing between them, and then balance a red block on top of them”. But
    the creator should not describe the building as a whole (“Make a doorframe.”).
  id: totrans-2557
  prefs: []
  type: TYPE_NORMAL
- en: When the builder thinks they are done, compare what you built! How precise was
    your communication? Which parts were difficult to describe for the creator / unclear
    for the builder? Switch roles so that you get to experience both sides!
  id: totrans-2558
  prefs: []
  type: TYPE_NORMAL
- en: 16.6\. AGILE SOFTWARE DEVELOPMENT
  id: totrans-2559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Agile* software development has become popular over the last 10 years; the
    two most famous agile processes are called [XP](http://en.wikipedia.org/wiki/Extreme_programming) and [Scrum](http://en.wikipedia.org/wiki/Scrum_(development)).
    Agile software development is all about being extremely flexible and adaptive
    to change. Most other software processes try to manage and control changes to
    requirements during the process; agile processes accept and expect change.'
  id: totrans-2560
  prefs: []
  type: TYPE_NORMAL
- en: Agile processes work similarly to iterative processes in that they do a number
    of iterations of analysis, design, implementation and testing. However, these
    iterations are extremely short, each usually lasting only about 2 weeks.
  id: totrans-2561
  prefs: []
  type: TYPE_NORMAL
- en: In many other processes, documentation is important. We document the requirements
    so that we can look back at them; we document our design so that we can refer
    back to it when we program the system. Agile software processes expect things
    to change all the time. Therefore, they do very little planning and documentation
    because documenting things that will change anyway is a bit of a waste of time.
  id: totrans-2562
  prefs: []
  type: TYPE_NORMAL
- en: Agile processes include lots of interesting principles that are quite different
    from standard software development. We look at the most interesting ones here.
    If you want to find out more, have a look at [Agile Academy on Youtube](http://www.youtube.com/user/AgileAcademyAus) which
    has lots of videos about interesting agile practices! There’s also [another video
    here](http://www.youtube.com/watch?v=kqz_jDS0RWY) which explains the differences
    between agile software development and the waterfall process.
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some general principles used for agile programming:'
  id: totrans-2564
  prefs: []
  type: TYPE_NORMAL
- en: '**Pair-programming**'
  id: totrans-2565
  prefs: []
  type: TYPE_NORMAL
- en: Programming is done in pairs with one person coding while the other person watches
    and looks for bugs and special cases that the other might have missed. It’s simply
    about catching small errors before they become bugs. After all, 4 eyes see more
    than 2.
  id: totrans-2566
  prefs: []
  type: TYPE_NORMAL
- en: You might think that pair-programming is not very efficient and that it would
    be more productive to have programmers working separately; that way, they can
    write more code more quickly, right? Pair-programming is about reducing errors.
    Testing, finding and fixing bugs is hard; trying not to create them in the first
    place is easier. As a result, pair-programming has actually been shown to be more
    efficient than everyone programming by themselves!
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
- en: '**YAGNI**'
  id: totrans-2568
  prefs: []
  type: TYPE_NORMAL
- en: YAGNI stands for “You ain’t gonna need it” and tells developers to keep things
    simple and only design and implement the things that you know you are really going
    to need. It can be tempting to think that in the future you might need feature
    x and so you may as well already create it now. But remember that requirements
    are likely to change so chances are that you won’t need it after all.
  id: totrans-2569
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ae2e3d146f.png)](http://xkcd.com/974/)'
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
- en: You ain’t gonna need it!
  id: totrans-2571
  prefs: []
  type: TYPE_NORMAL
- en: '**Constant testing**'
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
- en: Agile processes take testing very seriously. They usually rely on having lots
    of automated unit tests that are run at least once a day. That way, if a change
    is made (and this happens often), we can easily check if this change has introduced
    an unexpected bug.
  id: totrans-2573
  prefs: []
  type: TYPE_NORMAL
- en: '**Refactoring**'
  id: totrans-2574
  prefs: []
  type: TYPE_NORMAL
- en: There are many different ways to design and program a system. YAGNI tells you
    to start by doing the simplest thing that’s possible. As the project develops,
    you might have to change the original, simple design. This is called *refactoring*.
  id: totrans-2575
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring means to change your design or implementation without changing the
    program’s behaviour. After a refactoring, the program will work exactly the same,
    but will be better structured in some way. Unit tests really come in handy here
    because you can use them to check that the code works the same way before and
    after the refactoring.
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring only works on software because it is “soft” and flexible. The same
    concept does not really work for physical engineering products. Imagine that when
    building a bridge, for example, you started off by doing the simplest possible
    thing (putting a plank over the river) and then continually refactored the bridge
    to get the final product.
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
- en: '**Courage**'
  id: totrans-2578
  prefs: []
  type: TYPE_NORMAL
- en: '“Courage” might seem like an odd concept in the context of software development.
    In agile processes, things change all the time and therefore programmers need
    to have the courage to make changes to the code as needed, fix the problems that
    need to be fixed, correct the design where needed, throw away code that doesn’t
    work etc. This might not seem like a big deal, but it can actually be quite scary
    to change code, particularly if the code is complicated or has been written by
    a different person. Unit tests really help by giving you courage: you’ll feel
    more confident to change the code if you have tests that you can run to check
    your work later.'
  id: totrans-2579
  prefs: []
  type: TYPE_NORMAL
- en: '**Test-driven development**'
  id: totrans-2580
  prefs: []
  type: TYPE_NORMAL
- en: 'In standard software development, we first write some code and then test it.
    This makes sense: we need the code before we can test it, right? Test-driven development
    tells you to do the exact opposite!'
  id: totrans-2581
  prefs: []
  type: TYPE_NORMAL
- en: Before you write a piece of code, you should write a test for the code that
    you are about to write. This forces you to think about exactly what you’re trying
    to do and what special cases there are. Of course, if you try to run the test,
    it will fail (since the functionality it is testing does not yet exist). When
    you have a failing test, you can then write code to make the test pass.
  id: totrans-2582
  prefs: []
  type: TYPE_NORMAL
- en: '**Programmer welfare**'
  id: totrans-2583
  prefs: []
  type: TYPE_NORMAL
- en: Software developers should not work more than 40 hours per week. If they do
    overtime one week they should not do more overtime the following week. This helps
    keep software developers happy and makes sure they don’t get overworked.
  id: totrans-2584
  prefs: []
  type: TYPE_NORMAL
- en: '**Customer involvement**'
  id: totrans-2585
  prefs: []
  type: TYPE_NORMAL
- en: A customer representative should be part of the developing team (ideally spending
    full-time with the team), on hand to answer questions or give feedback at all
    times. This is important to be able to quickly change the requirements or direction
    of the project. If you have to wait 2 weeks until you can get feedback from your
    customer, you will not be able to adapt to change very quickly!
  id: totrans-2586
  prefs: []
  type: TYPE_NORMAL
- en: Although having a customer on the development team is a great idea in theory,
    it is quite hard to achieve in practice. Most customers simply want to tell you
    their requirements, pay you and then get the software delivered 5 months later.
    It’s rare to find a customer who is willing and has the time to be more involved
    in the project.
  id: totrans-2587
  prefs: []
  type: TYPE_NORMAL
- en: '**Curiosity: Christopher Alexander**'
  id: totrans-2588
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve mainly compared software development to engineering and building
    bridges, but you might have noticed that it’s also pretty similar to architecture.
    In fact, software development (in particular agile software development) has borrowed
    a lot of concepts from architecture. An architect called Christopher Alexander,
    for example, suggested involving customers in the design process. Sound familiar?
    Several other suggestions from Christopher Alexander were also picked up by the
    agile development community and as a result his thinking about architecture has
    shaped how we think about software development. This is despite the fact that
    Christopher Alexander knew nothing about software. He was apparently very surprised
    when he found out how well known he is among software developers!
  id: totrans-2589
  prefs: []
  type: TYPE_NORMAL
- en: '16.6.1\. PROJECT: SOFTWARE PROCESSES'
  id: totrans-2590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This project will provide insight into a real software engineering process,
    but you’ll need to find a software engineer who is prepared to be interviewed
    about their work. It will be ideal if the person works in a medium to large size
    company, and they need to be part of a software engineering team (i.e. not a lone
    programmer).
  id: totrans-2591
  prefs: []
  type: TYPE_NORMAL
- en: The project revolves around interviewing the person about the process they went
    through for some software development they did recently. They may be reluctant
    to talk about company processes, in which case it may help to assure them that
    you will keep their information confidential (your project should only be viewed
    by you and those involved in supervising and marking it; you should state its
    confidential nature clearly at the start so that it doesn’t later get used as
    an exemplar).
  id: totrans-2592
  prefs: []
  type: TYPE_NORMAL
- en: You need to do substantial preparation for the interview. Find out about the
    kind of software that the company makes. Read up about software engineering (in
    this chapter) so that you know the main terminology and techniques.
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
- en: Now prepare a list of questions for the interviewee. These should find out what
    kind of software development processes they use, what aspects your interviewee
    works on, and what the good and bad points are of the process, asking for examples
    to illustrate this.
  id: totrans-2594
  prefs: []
  type: TYPE_NORMAL
- en: You should take extensive notes during the interview (and record it if the person
    doesn’t mind).
  id: totrans-2595
  prefs: []
  type: TYPE_NORMAL
- en: You then need to write up what you have learned, describing the process, discussing
    the techniques used, illustrating it with examples, and evaluating how well the
    process works.
  id: totrans-2596
  prefs: []
  type: TYPE_NORMAL
- en: 16.7\. THE WHOLE STORY!
  id: totrans-2597
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ve tried to give you an introduction to the challenges of
    creating software and some techniques that software engineers use to overcome
    them. We’ve really only scratched the surface of software analysis, design, testing
    and software processes; there are entire books about each of these areas!
  id: totrans-2598
  prefs: []
  type: TYPE_NORMAL
- en: It can be difficult to understand the importance of some of the problems and
    techniques we have described here if you have never worked on a larger software
    project yourself. Some may seem blindingly obvious to you, others may seem irrelevant.
    When you work on your first large project, come back to this chapter and hopefully
    you’ll recognise some of the problems we have described here!
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
- en: 16.8\. FURTHER READING
  id: totrans-2600
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 16.8.1\. USEFUL LINKS
  id: totrans-2601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Wikipedia - Software engineering](http://en.wikipedia.org/wiki/Software_engineering)'
  id: totrans-2602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CS4FN - Software engineering](http://www.cs4fn.org/fundamentals/softwareeng.php)'
  id: totrans-2603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Teach ICT - Systems Life Cycle](http://www.teach-ict.com/as_a2_ict_new/ocr/A2_G063/331_systems_cycle/slc_stages/home_slc.html)'
  id: totrans-2604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Software crisis](http://en.wikipedia.org/wiki/Software_crisis)'
  id: totrans-2605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[IEEE - Why software fails](http://spectrum.ieee.org/computing/software/why-software-fails)'
  id: totrans-2606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Software design](http://en.wikipedia.org/wiki/Software_design)'
  id: totrans-2607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Abstraction](http://en.wikipedia.org/wiki/Abstraction_(computer_science))'
  id: totrans-2608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Software testing](http://en.wikipedia.org/wiki/Software_testing)'
  id: totrans-2609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Software development process](http://en.wikipedia.org/wiki/Software_development_process)'
  id: totrans-2610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Waterfall model](http://en.wikipedia.org/wiki/Waterfall_model)'
  id: totrans-2611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Iterative and incremental development](http://en.wikipedia.org/wiki/Iterative_and_incremental_development)'
  id: totrans-2612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Agile software development](http://en.wikipedia.org/wiki/Agile_software_development)'
  id: totrans-2613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Wikipedia - Test driven development](http://en.wikipedia.org/wiki/Test-driven_development)'
  id: totrans-2614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17\. APPENDICES
  id: totrans-2615
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[17.1\. GLOSSARY](17.1.%20GLOSSARY.html)'
  id: totrans-2616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.2\. CONTRIBUTORS](17.2.%20CONTRIBUTORS.html)'
  id: totrans-2617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.3\. INTERACTIVES](17.3.%20INTERACTIVES.html)'
  id: totrans-2618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.4\. 1.44 ASSESSMENT GUIDE](17.4.%201.44%20ASSESSMENT%20GUIDE.html)'
  id: totrans-2619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.5\. ALGORITHMS (1.44) - SEARCHING ALGORITHMS](17.5.%20ALGORITHMS%20%281.44%29%20-%20SEARCHING%20ALGORITHMS.html)'
  id: totrans-2620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.6\. ALGORITHMS (1.44) - SORTING ALGORITHMS](17.6.%20ALGORITHMS%20%281.44%29%20-%20SORTING%20ALGORITHMS.html)'
  id: totrans-2621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.7\. HUMAN COMPUTER INTERACTION (1.44)](17.7.%20HUMAN%20COMPUTER%20INTERACTION%20%281.44%29.html)'
  id: totrans-2622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.8\. PROGRAMMING LANGUAGES (1.44)](17.8.%20PROGRAMMING%20LANGUAGES%20%281.44%29.html)'
  id: totrans-2623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.9\. 2.44 ASSESSMENT GUIDE](17.9.%202.44%20ASSESSMENT%20GUIDE.html)'
  id: totrans-2624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.10\. REPRESENTING DATA USING BITS (BINARY NUMBERS) (2.44)](17.10.%20REPRESENTING%20DATA%20USING%20BITS%20%28BINARY%20NUMBERS%29%20%282.44%29.html)'
  id: totrans-2625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.11\. REPRESENTING DATA USING BITS (CHARACTERS/TEXT) (2.44)](17.11.%20REPRESENTING%20DATA%20USING%20BITS%20%28CHARACTERS-TEXT%29%20%282.44%29.html)'
  id: totrans-2626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.12\. REPRESENTING DATA USING BITS (IMAGES/COLOUR) (2.44)](17.12.%20REPRESENTING%20DATA%20USING%20BITS%20%28IMAGES-COLOUR%29%20%282.44%29.html)'
  id: totrans-2627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.13\. COMPRESSION (2.44) - RUN LENGTH ENCODING](17.13.%20COMPRESSION%20%282.44%29%20-%20RUN%20LENGTH%20ENCODING.html)'
  id: totrans-2628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.14\. ENCRYPTION (2.44) - RSA CRYPTOSYSTEM](17.14.%20ENCRYPTION%20%282.44%29%20-%20RSA%20CRYPTOSYSTEM.html)'
  id: totrans-2629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.15\. ERROR CONTROL CODING (2.44) - CHECK SUMS](17.15.%20ERROR%20CONTROL%20CODING%20%282.44%29%20-%20CHECK%20SUMS.html)'
  id: totrans-2630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.16\. ARTIFICIAL INTELLIGENCE (3.44) - TURING TEST](17.16.%20ARTIFICIAL%20INTELLIGENCE%20%283.44%29%20-%20TURING%20TEST.html)'
  id: totrans-2631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.17\. FUTURE PLANS FOR THE FIELD GUIDE](17.17.%20FUTURE%20PLANS%20FOR%20THE%20FIELD%20GUIDE.html)'
  id: totrans-2632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[17.18\. GUIDE TO SYSTEM FOR OPEN SOURCE DEVELOPERS](17.18.%20GUIDE%20TO%20SYSTEM%20FOR%20OPEN%20SOURCE%20DEVELOPERS.html)'
  id: totrans-2633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 17.1\. GLOSSARY
  id: totrans-2634
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ALC
  id: totrans-2635
  prefs: []
  type: TYPE_NORMAL
- en: Apple Lossless Coding, a lossless compression method for audio.
  id: totrans-2636
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm
  id: totrans-2637
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm a process for achieving an outcome, normally for a general problem
    such as searching, sorting, finding an optimal path through a map and so on.
  id: totrans-2638
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm analysis
  id: totrans-2639
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm analysis working out the complexity of an algorithm.
  id: totrans-2640
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm complexity
  id: totrans-2641
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm complexity how long the algorithm takes to run (or how much memory
    it uses). These are almost always specified in terms of the size of input.
  id: totrans-2642
  prefs: []
  type: TYPE_NORMAL
- en: Alphabet
  id: totrans-2643
  prefs: []
  type: TYPE_NORMAL
- en: Alphabets
  id: totrans-2644
  prefs: []
  type: TYPE_NORMAL
- en: In formal languages, this is the set of characters that might be processed.
    For many compilers and text processing systems the alphabet is the set of all
    ASCII characters, but for example, for a finite state automaton controlled by
    an “up” and “down” button, the alphabet is just the two symbols “up” and “down”.
    For systems processing binary numbers, the alphabet would usually be “0” and “1”.
    Many of the small examples just use a small alphabet of a few characters (typically
    “a”, “b”, “c” etc.) to keep things simple.
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
- en: ASCII
  id: totrans-2646
  prefs: []
  type: TYPE_NORMAL
- en: ASCII the commonly used code for representing characters as 8-bit numbers (although
    only 7 of the 8 bits are usually used).
  id: totrans-2647
  prefs: []
  type: TYPE_NORMAL
- en: Attack
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
- en: Gaining access to or decrypting a file that is using encryption, without having
    the key. There are several types of attacks, some of which are also defined in
    this list.
  id: totrans-2649
  prefs: []
  type: TYPE_NORMAL
- en: Binary Number System
  id: totrans-2650
  prefs: []
  type: TYPE_NORMAL
- en: The base 2 number system, i.e. numbers only made up of the digits “0” and “1”.
    All numbers that can be represented in the decimal number system can be uniquely
    represented in the binary number system.
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
- en: Binary search
  id: totrans-2652
  prefs: []
  type: TYPE_NORMAL
- en: Binary search searching a sorted list by looking at the middle item, and then
    searching the appropriate half recursively (used for phone books, dictionaries
    and computer algorithms).
  id: totrans-2653
  prefs: []
  type: TYPE_NORMAL
- en: Bit
  id: totrans-2654
  prefs: []
  type: TYPE_NORMAL
- en: Bit short for “binary digit” - a digit that is either 0 or 1.
  id: totrans-2655
  prefs: []
  type: TYPE_NORMAL
- en: Brute force attack
  id: totrans-2656
  prefs: []
  type: TYPE_NORMAL
- en: A type of attack that is carried out by trying every possible key.
  id: totrans-2657
  prefs: []
  type: TYPE_NORMAL
- en: Bubble sort
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
- en: Bubble sort a sorting algorithm based on swapping adjacent items that are out
    of order. It is not a good method, but serves as an example of a slow method in
    contrast to others like quicksort.
  id: totrans-2659
  prefs: []
  type: TYPE_NORMAL
- en: Byte
  id: totrans-2660
  prefs: []
  type: TYPE_NORMAL
- en: Byte a group of 8 bits, able to represent numbers from 0 to 255, can store one
    ASCII character (also known as an octet).
  id: totrans-2661
  prefs: []
  type: TYPE_NORMAL
- en: Caesar Cipher
  id: totrans-2662
  prefs: []
  type: TYPE_NORMAL
- en: A very simple cipher that offsets each letter in the alphabet by a certain amount,
    specified by the key. It is no longer used in practice due to being very easy
    to attack.
  id: totrans-2663
  prefs: []
  type: TYPE_NORMAL
- en: Chatterbot
  id: totrans-2664
  prefs: []
  type: TYPE_NORMAL
- en: An AI system that has text conversations with the user, typically based on simple
    pattern matching.
  id: totrans-2665
  prefs: []
  type: TYPE_NORMAL
- en: Check digit
  id: totrans-2666
  prefs: []
  type: TYPE_NORMAL
- en: An extra digit that is added onto the end of a number such as an ISBN, credit
    card number, or barcode number. This digit is calculated using a formula based
    on the other digits in the number. Error detection works by using the check equation
    to determine whether or not the check digit is as expected.
  id: totrans-2667
  prefs: []
  type: TYPE_NORMAL
- en: Check equation
  id: totrans-2668
  prefs: []
  type: TYPE_NORMAL
- en: An equation that is used to check whether or not the check digit for a number
    is correct.
  id: totrans-2669
  prefs: []
  type: TYPE_NORMAL
- en: Chomsky hierarchy
  id: totrans-2670
  prefs: []
  type: TYPE_NORMAL
- en: A hierarchy of types of languages ranging from the simple “regular expression”
    through to unrestricted grammars. Each level of the hierarchy can describe more
    complex rules, but is also harder to implement. It is named after the linguist
    Noam Chomsky.
  id: totrans-2671
  prefs: []
  type: TYPE_NORMAL
- en: Cipher
  id: totrans-2672
  prefs: []
  type: TYPE_NORMAL
- en: An algorithm used to encrypt a piece of plain text.
  id: totrans-2673
  prefs: []
  type: TYPE_NORMAL
- en: Cipher text
  id: totrans-2674
  prefs: []
  type: TYPE_NORMAL
- en: Text which has been encrypted.
  id: totrans-2675
  prefs: []
  type: TYPE_NORMAL
- en: Compiler
  id: totrans-2676
  prefs: []
  type: TYPE_NORMAL
- en: Compiler translates an entire program written in a high level language to machine
    language in advance before running it.
  id: totrans-2677
  prefs: []
  type: TYPE_NORMAL
- en: Complexity
  id: totrans-2678
  prefs: []
  type: TYPE_NORMAL
- en: Complexity how long it takes to solve a problem. A problem has an inherent complexity
    (minimum time needed to solve it); any algorithm to solve the problem will have
    a higher complexity (take at least that long). See also algorithm complexity.
  id: totrans-2679
  prefs: []
  type: TYPE_NORMAL
- en: Compression
  id: totrans-2680
  prefs: []
  type: TYPE_NORMAL
- en: Compression making a file smaller by removing redundant information (typically
    using standards like zip, jpeg, mpeg, mp3).
  id: totrans-2681
  prefs: []
  type: TYPE_NORMAL
- en: Decimal Number System
  id: totrans-2682
  prefs: []
  type: TYPE_NORMAL
- en: The standard base 10 number system that is used in everyday math, using the
    digits “0”, “1”, “2”, “3”, “4”, “5”, “6”, “7”, “8”, and “9”.
  id: totrans-2683
  prefs: []
  type: TYPE_NORMAL
- en: Decrypt
  id: totrans-2684
  prefs: []
  type: TYPE_NORMAL
- en: Decryption
  id: totrans-2685
  prefs: []
  type: TYPE_NORMAL
- en: Decipher
  id: totrans-2686
  prefs: []
  type: TYPE_NORMAL
- en: Getting the plain text for a piece of cipher text by either using the key or
    an attack.
  id: totrans-2687
  prefs: []
  type: TYPE_NORMAL
- en: Encryption
  id: totrans-2688
  prefs: []
  type: TYPE_NORMAL
- en: Encryption changing the representation of data so it can’t be read by an eavesdropper
    who doesn’t have the encryption key.
  id: totrans-2689
  prefs: []
  type: TYPE_NORMAL
- en: Encryption key
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
- en: Encryption key the password or secret code that will unlock an encrypted file.
  id: totrans-2691
  prefs: []
  type: TYPE_NORMAL
- en: Error correction
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
- en: Correcting an error that has been detected in some data. This can be demonstrated
    in the Parity trick, where a person is able to flip the changed bit back over
    so it is correct again (after they have “detected” which bit was incorrect). Not
    all error control schemes are able to correct errors; some are only able to detect
    them.
  id: totrans-2693
  prefs: []
  type: TYPE_NORMAL
- en: Error detection
  id: totrans-2694
  prefs: []
  type: TYPE_NORMAL
- en: Detecting when an error has occurred in some data, such as a number getting
    typed incorrectly or a bit getting flipped. Some simple examples of this are parity
    bits or a check digit.
  id: totrans-2695
  prefs: []
  type: TYPE_NORMAL
- en: Feature
  id: totrans-2696
  prefs: []
  type: TYPE_NORMAL
- en: A function available on a digital device or software, such as copy/paste, autofocus,
    voice dialling or undo. Features are often used to sell a device, but having features
    (functionality) should not be confused with people being able to use the device
    effectively (usability).
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
- en: Feedback
  id: totrans-2698
  prefs: []
  type: TYPE_NORMAL
- en: Responding to or acknowledging a user action. Users find the devices hard to
    use if the feedback is slow, confusing, or non-existent.
  id: totrans-2699
  prefs: []
  type: TYPE_NORMAL
- en: Finite state automaton
  id: totrans-2700
  prefs: []
  type: TYPE_NORMAL
- en: FSA
  id: totrans-2701
  prefs: []
  type: TYPE_NORMAL
- en: A simple notation for processing input symbols to determine if they obey some
    specified. An FSA has a starting state, transitions between states based on the
    next input symbol, and “accepting” states, which indicate that the input is accepted
    if the processing ends up in one.
  id: totrans-2702
  prefs: []
  type: TYPE_NORMAL
- en: Frequency Analysis Attack
  id: totrans-2703
  prefs: []
  type: TYPE_NORMAL
- en: An attack on substitution ciphers that takes advantage of the fact that some
    letters are generally more common than others in a piece of text (e.g. in English,
    the letter “e” is usually the most common letter) by looking at which letters
    appear the most in the cipher text and guessing that they must be the substitutions
    for the most common letters.
  id: totrans-2704
  prefs: []
  type: TYPE_NORMAL
- en: GIF
  id: totrans-2705
  prefs: []
  type: TYPE_NORMAL
- en: A lossless image compression system typically used for small images with few
    colours in them (in practice it can be lossy because it has only 256 colours,
    and if the original has more colours then some will be lost).
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
- en: Gigabyte
  id: totrans-2707
  prefs: []
  type: TYPE_NORMAL
- en: About 1000 megabytes (1,000,000 kilobytes and 1,000,000,000 bytes). This is
    8,000 million individual bits (i.e. 0’s and 1’s). [Like a kilobyte, there are
    other definitions, such as 1024x1024x1024 bytes, but usually this level of accuracy
    isn’t important]. Commonly referred to as a “GB”.
  id: totrans-2708
  prefs: []
  type: TYPE_NORMAL
- en: Grammar
  id: totrans-2709
  prefs: []
  type: TYPE_NORMAL
- en: Rules that specify a language, typically used for defining programming languages.
  id: totrans-2710
  prefs: []
  type: TYPE_NORMAL
- en: Graphics
  id: totrans-2711
  prefs: []
  type: TYPE_NORMAL
- en: Graphics in computer science, designing algorithms that can produce images on
    a computer.
  id: totrans-2712
  prefs: []
  type: TYPE_NORMAL
- en: HCI
  id: totrans-2713
  prefs: []
  type: TYPE_NORMAL
- en: HCI human computer interaction; an area of computer science looking at how people
    interact with a digital device, with an emphasis on the quality of the experience
    to complete tasks.
  id: totrans-2714
  prefs: []
  type: TYPE_NORMAL
- en: Heuristic
  id: totrans-2715
  prefs: []
  type: TYPE_NORMAL
- en: A heuristic is rule or guideline, usually devised from experience. The term
    is used in both HCI and algorithms. In **HCI**, heuristics are often used as a
    benchmark to evaluate interfaces — they aren’t strict rules, but usually highlight
    issues with designs. A very common set is given at www.useit.com . In **algorithms**,
    and heuristic is an approximate solution to a problem; it doesn’t guarantee to
    give the best possible answer (such as the shortest route on a map), but by using
    simple rules the calculation can be done quickly, and the solution is hopefully
    good enough for practical use.
  id: totrans-2716
  prefs: []
  type: TYPE_NORMAL
- en: Hexadecimal
  id: totrans-2717
  prefs: []
  type: TYPE_NORMAL
- en: The base 16 number system. Uses the digits “0”, “1”, “2”, “3”, “4”, “5”, “6”,
    “7”, “8”, “9”, “A”, “B”, “C”, “D”, “E”, and “F”. All numbers that can be represented
    in decimal can be uniquely represented in hexadecimal (just like binary). It is
    most often used as a shorthand notation for binary, by assigning 1 hexadecimal
    digit to each 4 bit pattern (the assigning is done in numeric order).
  id: totrans-2718
  prefs: []
  type: TYPE_NORMAL
- en: Hexadecimal colour codes
  id: totrans-2719
  prefs: []
  type: TYPE_NORMAL
- en: A representation for colours that tells the computer how much red, blue, and
    green light to display in a pixel (to make the desired colour). Uses 1 byte for
    each of these 3 primary colours, which is 3 bytes (24 bits) in total. These 24
    bits are often written as 6 hexadecimal digits to make them easier for humans
    to read, which is why they are called “Hexadecimal colour codes”. They are commonly
    encountered when specificying colours in HTML for web pages.
  id: totrans-2720
  prefs: []
  type: TYPE_NORMAL
- en: High level language
  id: totrans-2721
  prefs: []
  type: TYPE_NORMAL
- en: High level language a programming language that is designed for humans to read
    and write (e.g. Java, Python, C, C#, Basic, Scratch…) as opposed to machine languages.
  id: totrans-2722
  prefs: []
  type: TYPE_NORMAL
- en: Insertion sort
  id: totrans-2723
  prefs: []
  type: TYPE_NORMAL
- en: Start with an empty list, and insert each item in the correct place; this is
    a relatively slow method, usually between selection sort and quick sort in speed.
  id: totrans-2724
  prefs: []
  type: TYPE_NORMAL
- en: Intelligent Systems
  id: totrans-2725
  prefs: []
  type: TYPE_NORMAL
- en: Intelligent systems an area of computer science that investigates ways to simulate
    or approximate human intelligence on computers; often referred to as artificial
    intelligence (AI).
  id: totrans-2726
  prefs: []
  type: TYPE_NORMAL
- en: Interface
  id: totrans-2727
  prefs: []
  type: TYPE_NORMAL
- en: The part of a computer, software, or electronic device that a human interacts
    with, whether this is by sight, hearing, or touch.
  id: totrans-2728
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter
  id: totrans-2729
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter runs a programming language by translating each line of code as
    it is execute.
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
- en: ISBN
  id: totrans-2731
  prefs: []
  type: TYPE_NORMAL
- en: Stands for International Standard Book Number. Every published book has one
    of these numbers on the back of it. ISBN is significant to error control coding
    because it uses a check digit for error detection.
  id: totrans-2732
  prefs: []
  type: TYPE_NORMAL
- en: JPEG
  id: totrans-2733
  prefs: []
  type: TYPE_NORMAL
- en: A lossy image compression system typically used for photographs.
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
- en: Key (in algorithms)
  id: totrans-2735
  prefs: []
  type: TYPE_NORMAL
- en: It is an item of data that is being searched for or sorted, and therefore will
    be compared with other data.
  id: totrans-2736
  prefs: []
  type: TYPE_NORMAL
- en: Key (in cryptography)
  id: totrans-2737
  prefs: []
  type: TYPE_NORMAL
- en: The password or secret value that is used to encrypt and decrypt an encrypted
    file (without having to use an “attack”). Some widely used methods have different
    keys for encryption and decryption.
  id: totrans-2738
  prefs: []
  type: TYPE_NORMAL
- en: Kilobyte
  id: totrans-2739
  prefs: []
  type: TYPE_NORMAL
- en: About 1000 bytes. This is 8,000 individual bits (i.e. 0’s and 1’s). [We say
    “about” 1000 bytes because the term is ambiguous and it is often taken as 1024
    bytes; however, rounding it to 1000 is close enough for most calculations]. Commonly
    referred to as a “KB”.
  id: totrans-2740
  prefs: []
  type: TYPE_NORMAL
- en: Known plain-text Attack
  id: totrans-2741
  prefs: []
  type: TYPE_NORMAL
- en: Working out the key or method of encryption (cipher) based on having access
    to both the original plain-text and its encrypted form.
  id: totrans-2742
  prefs: []
  type: TYPE_NORMAL
- en: Language
  id: totrans-2743
  prefs: []
  type: TYPE_NORMAL
- en: A set of strings, typically obeying some rules defined by a regular expression
    or grammar e.g. all strings containing the letter “a” exactly twice, or all strings
    that are legal Java programs.
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
- en: Lexical analysis
  id: totrans-2745
  prefs: []
  type: TYPE_NORMAL
- en: When compiling a computer program, working out what the components of the program
    are e.g. identifiers, keywords, integers.
  id: totrans-2746
  prefs: []
  type: TYPE_NORMAL
- en: Linear Complexity
  id: totrans-2747
  prefs: []
  type: TYPE_NORMAL
- en: Linear complexity grows in proportion to the size of the problem - if the problem
    is twice as big, it will take roughly twice as long to solve.
  id: totrans-2748
  prefs: []
  type: TYPE_NORMAL
- en: Logarithm
  id: totrans-2749
  prefs: []
  type: TYPE_NORMAL
- en: Logarithm is a very slow growing mathematical function written as \log n. In
    computer science logarithms are usually in base 2, that is, \log_2 n, which is
    the inverse of the incredibly fast growing exponent function 2^n. Logarithms are
    not needed to understand the material in this book, but they are used a lot in
    computer science and are a useful concept to understand. Logarithms happen to
    come up a lot with algorithms, and the two words are often confused. The value
    \log_2 n is just the number of times you can halve n until you get down to 1;
    for example, \log_2 32`is 5, and :math:log_2 1024` is 10\. Binary search takes
    \log_2 n steps to search *n*items; storing the number *n* in binary takes \log_2
    n bits.
  id: totrans-2750
  prefs: []
  type: TYPE_NORMAL
- en: Lossless
  id: totrans-2751
  prefs: []
  type: TYPE_NORMAL
- en: A compression method that does not cause any loss of data. This means that the
    uncompressed file will be identical to the original file that was compressed (which
    is important for text). In the case of images and sound, it means they will be
    of the same quality before and after compression. For example, ZIP and ALC use
    lossless compression.
  id: totrans-2752
  prefs: []
  type: TYPE_NORMAL
- en: Lossy
  id: totrans-2753
  prefs: []
  type: TYPE_NORMAL
- en: A compression method that trades off quality for file size. Lossy compression
    methods can make files smaller than lossless compression methods can, but the
    quality of the resulting file will be lower. For example, MP3 and JPEG use lossy
    compression.
  id: totrans-2754
  prefs: []
  type: TYPE_NORMAL
- en: Machine language
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
- en: The native language for instructions for a computer, not very easy for humans
    to read and write.
  id: totrans-2756
  prefs: []
  type: TYPE_NORMAL
- en: Megabyte
  id: totrans-2757
  prefs: []
  type: TYPE_NORMAL
- en: About 1000 kilobytes (1,000,000 bytes). This is 8 million individual bits (i.e.
    0’s and 1’s). [Like a kilobyte, there are other definitions, such as 1024x1024
    bytes, but usually this level of accuracy isn’t important]. Commonly referred
    to as a “MB”.
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
- en: MP3
  id: totrans-2759
  prefs: []
  type: TYPE_NORMAL
- en: A lossy audio compression system.
  id: totrans-2760
  prefs: []
  type: TYPE_NORMAL
- en: Nibble
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
- en: 4 bits (half a byte), sometimes called a nybble.
  id: totrans-2762
  prefs: []
  type: TYPE_NORMAL
- en: Nielson’s Heuristics
  id: totrans-2763
  prefs: []
  type: TYPE_NORMAL
- en: A widely used set of heuristics for evaluating computer interfaces that was
    devised by Jakob Nielson (available from [http://useit.com](http://useit.com/)).
  id: totrans-2764
  prefs: []
  type: TYPE_NORMAL
- en: Octal
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
- en: 'The base 8 number system. Like hexadecimal, it is significant to computer scientists
    as it allows a shorthand notation for writing binary numbers. Octal assigns a
    digit to each possible 3 bit pattern. Note: You probably don’t need to know this
    for the achievement standard, although it is included here in case you come across
    the term.'
  id: totrans-2766
  prefs: []
  type: TYPE_NORMAL
- en: Parity
  id: totrans-2767
  prefs: []
  type: TYPE_NORMAL
- en: Adding an extra bit to a set of bits to make it so that there is an even number
    of 1’s. Storing the parity makes it possible to detect and correct errors later.
    [This is known as an even parity bit; an odd parity bit is also possible where
    the extra bit ensures there is an odd number of 1’s]
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
- en: Parse tree
  id: totrans-2769
  prefs: []
  type: TYPE_NORMAL
- en: The structure derived by parsing some input.
  id: totrans-2770
  prefs: []
  type: TYPE_NORMAL
- en: Parsing
  id: totrans-2771
  prefs: []
  type: TYPE_NORMAL
- en: Reading some input (typically a computer program) and making sense of it by
    breaking it into parts according to their function.
  id: totrans-2772
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  id: totrans-2773
  prefs: []
  type: TYPE_NORMAL
- en: Finding strings of characters that match simple rules, typically based on a
    regular expression.
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
- en: Plain Text
  id: totrans-2775
  prefs: []
  type: TYPE_NORMAL
- en: Text before it has been encrypted or after it has been decrypted (so essentially
    text in plain language, without any encryption).
  id: totrans-2776
  prefs: []
  type: TYPE_NORMAL
- en: PNG
  id: totrans-2777
  prefs: []
  type: TYPE_NORMAL
- en: A lossless image compression system typically used for small images with few
    colours in them.
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
- en: Quadratic complexity
  id: totrans-2779
  prefs: []
  type: TYPE_NORMAL
- en: Quadratic complexity grows with the square of the size of the problem - if the
    problem is twice as big, it will take roughly 4 times as long to solve.
  id: totrans-2780
  prefs: []
  type: TYPE_NORMAL
- en: Quick sort
  id: totrans-2781
  prefs: []
  type: TYPE_NORMAL
- en: Quick sort pick an item at random, put all the smaller items in a group on its
    left and the larger items in a group on its right. Now do quick sort on the two
    groups. This is one of the better sorting algorithms, and is good for comparing
    with others. Students don’t need to understand how it works, but some may be curious.
  id: totrans-2782
  prefs: []
  type: TYPE_NORMAL
- en: Redundant Bits
  id: totrans-2783
  prefs: []
  type: TYPE_NORMAL
- en: Extra bits that are not part of the actual data but instead have been added
    for error detection and possibly error correction.
  id: totrans-2784
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression
  id: totrans-2785
  prefs: []
  type: TYPE_NORMAL
- en: A simple expression used for pattern matching, typically using characters combined
    with “*” (repetition), “|” (selecting one or the other) and parenthesis (to group
    operations). Some systems allow more complex patterns such as ”.” (matches any
    character), “{n}” (repeated n times), and “\d” (digit).
  id: totrans-2786
  prefs: []
  type: TYPE_NORMAL
- en: Search
  id: totrans-2787
  prefs: []
  type: TYPE_NORMAL
- en: Find a key in a large amount of data.
  id: totrans-2788
  prefs: []
  type: TYPE_NORMAL
- en: Selection sort
  id: totrans-2789
  prefs: []
  type: TYPE_NORMAL
- en: Selection sort select the smallest item, then the second smallest, and so on.
    This is not a very fast algorithm, but it’s not as bad as bubble sort, and provides
    a good contrast with quick sort.
  id: totrans-2790
  prefs: []
  type: TYPE_NORMAL
- en: Sort
  id: totrans-2791
  prefs: []
  type: TYPE_NORMAL
- en: Sort puts keys (numbers, names or other values) in order from smallest to largest
    (outside computer science this is usually called ordering).
  id: totrans-2792
  prefs: []
  type: TYPE_NORMAL
- en: String
  id: totrans-2793
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  id: totrans-2794
  prefs: []
  type: TYPE_NORMAL
- en: A sequence of characters or symbols from an alphabet. For example, the two-character
    strings that can be made from the alphabet {“a”,”b”} are “aa”, “ab”, “ba” and
    “bb”.
  id: totrans-2795
  prefs: []
  type: TYPE_NORMAL
- en: Substitution Cipher
  id: totrans-2796
  prefs: []
  type: TYPE_NORMAL
- en: A type of cipher that works simply by replacing each letter or combination of
    letters in a plain text with a certain other letter or combination of letters
    to make up the cipher text. The result of this is that each unique letter combination
    of letters in the plain text (e.g. “t”) is represented by the same unique letter
    combination of letters in the cipher text (e.g. “y”) Caesar Cipher is a simple
    example of a substitution cipher. Substitution ciphers are vulnerable to Frequency
    Analysis Attacks, so are not used in practice.
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
- en: Syntactically correct
  id: totrans-2798
  prefs: []
  type: TYPE_NORMAL
- en: A string is syntactically correct if it matches the specifications for a formal
    language. For example, the string “()(())” is correct for a grammar that gives
    the rules for balanced parentheses. In a computer program, a syntax error is when
    a character occurs in the input which isn’t allowed, and the program is therefore
    not syntactically correct.
  id: totrans-2799
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  id: totrans-2800
  prefs: []
  type: TYPE_NORMAL
- en: Syntax rules about what text can appear in a programming language, used by a
    compiler or interpreter and therefore need to be followed by a programmer to avoid
    syntax errors.
  id: totrans-2801
  prefs: []
  type: TYPE_NORMAL
- en: Syntax diagram
  id: totrans-2802
  prefs: []
  type: TYPE_NORMAL
- en: Also known as railway (or railroad) diagrams, these are a graphical representation
    of a grammar using arrows (the “train tracks”) to show the options for each component
    of a language.
  id: totrans-2803
  prefs: []
  type: TYPE_NORMAL
- en: Task
  id: totrans-2804
  prefs: []
  type: TYPE_NORMAL
- en: Something a user might do with a piece of software or electronic device to achieve
    a goal. In the case of a cellphone this might be “send a text message” or in the
    case of a microwave it might be “heat up yesterday’s leftovers”. Interfaces are
    best evaluated when considering how they help a user to perform a task.
  id: totrans-2805
  prefs: []
  type: TYPE_NORMAL
- en: Time complexity
  id: totrans-2806
  prefs: []
  type: TYPE_NORMAL
- en: Time complexity the usual meaning of the complexity of an algorithm; this makes
    it clear that we’re talking about the time taken. Normally it’s expressed in terms
    of steps, not real time on a particular computer, as different computers are different
    speeds.
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
- en: Unicode
  id: totrans-2808
  prefs: []
  type: TYPE_NORMAL
- en: Unicode an extension of ASCII; it supports characters from multiple languages,
    using 16 bits per character.
  id: totrans-2809
  prefs: []
  type: TYPE_NORMAL
- en: Usability heuristic
  id: totrans-2810
  prefs: []
  type: TYPE_NORMAL
- en: See [*Heuristic*](http://csfieldguide.org.nz/appendices/Glossary.html#term-heuristic).
  id: totrans-2811
  prefs: []
  type: TYPE_NORMAL
- en: User
  id: totrans-2812
  prefs: []
  type: TYPE_NORMAL
- en: The human using the computer system or electronic device.
  id: totrans-2813
  prefs: []
  type: TYPE_NORMAL
- en: Visual computing
  id: totrans-2814
  prefs: []
  type: TYPE_NORMAL
- en: Visual computing designing systems that can perceive, process, understand and
    generate images; images typically come from scanners and cameras, and may be displayed
    on monitors, head mounted displays, or as movies.
  id: totrans-2815
  prefs: []
  type: TYPE_NORMAL
- en: 17.2\. CONTRIBUTORS
  id: totrans-2816
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note
  id: totrans-2817
  prefs: []
  type: TYPE_NORMAL
- en: If there is an error in the list, please contact [Jack Morgan](mailto:jack.morgan%40canterbury.ac.nz)
  id: totrans-2818
  prefs: []
  type: TYPE_NORMAL
- en: Tim Bell - International Field Guide, co-organiser
  id: totrans-2819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peter Denning - International Field Guide, co-organiser
  id: totrans-2820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jack Morgan - Editor and Technical Lead
  id: totrans-2821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heidi Newton - Writer for Artificial Intelligence, Complexity and Tractability
  id: totrans-2822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Janina Voigt - Writer for Software Engineering
  id: totrans-2823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ian Witten, writer and advisor
  id: totrans-2824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jon Rutherford - Writer for Software Engineering
  id: totrans-2825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wal Irwin - Advisor for Software Engineering
  id: totrans-2826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peter Andreae - Advisor for Artificial Intelligence, Complexity and Tractability
  id: totrans-2827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walter Guttmann - Advisor for Formal Languages
  id: totrans-2828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: David Thompson - Interactive games and Writer for Computer Vision
  id: totrans-2829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rhem Munro- Interactive games and Writer for Computer Graphics
  id: totrans-2830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sumant Murugesh - Research
  id: totrans-2831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ben Gibson - Interactive games and related material
  id: totrans-2832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linda Pettigrew - Formal languages material
  id: totrans-2833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Joshua Scott - Computer Graphics material: Bresenham’s methods'
  id: totrans-2834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Michael Bell (Orange Studio) - Video production
  id: totrans-2835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patrick Baker, Jenny Baker, Neil Leslie - NZ teachers providing advisory role
  id: totrans-2836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dr Mukundan - Advisor for Computer Graphics & Vision
  id: totrans-2837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Richard Green - Advisor for Computer Vision
  id: totrans-2838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DongSeong Kim - Advisor for networking/security
  id: totrans-2839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mike Fellows, co-authored CS unplugged (source material)
  id: totrans-2840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Andrea Arpaci-Dusseau, co-author of a Chinese version of “Unplugged” (source
    material)
  id: totrans-2841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renate Thies and Jan Vahrenhold (Münster University, Germany), advisors
  id: totrans-2842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anthony Robins - advisor
  id: totrans-2843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shadi Ibrahim - advisor
  id: totrans-2844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paul Curzon - CS4FN material
  id: totrans-2845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quintin Cutts - “Computing Science Inside” material
  id: totrans-2846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paul Matthews (IITP) - advisor
  id: totrans-2847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calvin Lin, Bradley Beth - The University of Texas at Austin “Thriving in our
    Digital World” project
  id: totrans-2848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brad Miller and David Ranum - advisors for authoring tools - our web system
    is based on their books at [Runestone Interactive](http://runestoneinteractive.org/).
  id: totrans-2849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.2.1\. ACKNOWLEDGEMENTS
  id: totrans-2850
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project has grown out of a partnership for an international field guide
    to computing. In the CSSE department, it grew from the CS Unplugged project (csunplugged.org)
    and the CS resource guides (nzacditt.org.nz/resources). At the at Naval Postgraduate
    School in Monterey, California, it grew from a project called “Field Guide to
    the Science of Computing” (csfieldguide.org) and the Great Principles of Computing
    project (greatprinciples.org), both led by Peter Denning.
  id: totrans-2851
  prefs: []
  type: TYPE_NORMAL
- en: Funding for this online textbook has been provided by Google Inc. In addition,
    countless hours of volunteer time have been contributed by those listed above.
    Tim Bell prepared an initial draft of this material while visiting Huazhong University
    of Science and Technology, Wuhan, China, whom we thank for providing an excellent
    environment for writing. The project is based at the University of Canterbury,
    Christchurch, New Zealand; other authors are at Victoria University of Wellington,
    New Zealand, and Cambridge University, UK.
  id: totrans-2852
  prefs: []
  type: TYPE_NORMAL
- en: Partial funding for the US field guide project was provided by the US National
    Science Foundation under Grant No. 0938809.
  id: totrans-2853
  prefs: []
  type: TYPE_NORMAL
- en: 17.3\. INTERACTIVES
  id: totrans-2854
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is for help on getting the interactives (previously referred to
    as widgets) working. The current interactives are prototypes and have not been
    heavily tested across different browsers and operating systems. Most of the interactives
    will work in the latest version of Chrome.
  id: totrans-2855
  prefs: []
  type: TYPE_NORMAL
- en: The interactives are currently not designed for mobile or touch devices, but
    are a focus when we redesign them over the coming months.
  id: totrans-2856
  prefs: []
  type: TYPE_NORMAL
- en: 17.3.1\. WEBGL ON WINDOWS, LINUX AND MAC OS X
  id: totrans-2857
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The graphics chapter makes a lot of use of the WebGL system, which can render
    3D images in a web browser. It is relatively new, so older browsers and operating
    systems may not have it setup correctly.
  id: totrans-2858
  prefs: []
  type: TYPE_NORMAL
- en: 17.3.1.1\. QUICK FIXES
  id: totrans-2859
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using an up-to-date version of Chrome or Firefox and the drivers
    for your operating system are up-to-date and the computer has a suitable GPU,
    then it should work. It won’t be possible to use it in Internet Explorer. For
    Safari you will need to adjust some settings. The details for getting WebGL set
    up are below.
  id: totrans-2860
  prefs: []
  type: TYPE_NORMAL
- en: '**Updating your operating system**'
  id: totrans-2861
  prefs: []
  type: TYPE_NORMAL
- en: If you’re on **Windows**, make sure you have [the Microsoft DirectX runtime](http://www.microsoft.com/en-us/download/details.aspx?id=35) installed
    — this is a free download from Microsoft. Once you’ve done that, make sure that
    you’ve got the very latest versions of the drivers for your graphics card. We
    recommend doing this manually, there are good tutorials on the internet. There
    is a good[video](http://www.pctecmech.com/tutorials/Video-Card-Drivers.php) here
    that explains how to do this. The easiest way is to install an free driver update
    program like [SlimDriver](http://download.cnet.com/SlimDrivers-Free/3000-18513_4-75279940.html) which
    will find missing and out-of-date drivers.
  id: totrans-2862
  prefs: []
  type: TYPE_NORMAL
- en: 'For **MacOS**: 1\. Click the Apple logo. 2\. On the “Apple” menu, click “Software
    Update.” 3\. If there is a Mac OS X update available, you can install it. If there
    is a graphics driver update, it will be included in the Mac OS X update.'
  id: totrans-2863
  prefs: []
  type: TYPE_NORMAL
- en: '**Updating your browser**'
  id: totrans-2864
  prefs: []
  type: TYPE_NORMAL
- en: This depends on which browser you are using. If you can use Chrome it can be
    a little easier to get working.
  id: totrans-2865
  prefs: []
  type: TYPE_NORMAL
- en: '[Firefox](http://www.mozilla.org/en-US/firefox/new/): just make sure you have
    version 4 or higher.'
  id: totrans-2866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chrome: all you need to do is [install it](https://www.google.com/intl/en/chrome/browser/),
    or if you’re already using it, just check whether it’s updated itself to version
    10 or later — this will almost certainly have happened automatically (it was released
    in March 2011), but you can check from the “About Google Chrome” option on the
    tools menu to confirm.'
  id: totrans-2867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Safari: on Macs, OS X 10.7 has WebGL support, but it’s switched off by default.
    To switch it on, enable the developer menu and check the “[Enable WebGL](http://www.google.com/url?q=http%3A%2F%2Fwww.ikriz.nl%2F2011%2F08%2F23%2Fenable-webgl-in-safari&sa=D&sntz=1&usg=AFQjCNFn42c02vQLy95tRoAoDxdprFGPJA)”
    option.'
  id: totrans-2868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All older version of these browsers require manual enabling of WebGL. For more
    information on getting a WebGL implementation follow this [link](http://www.google.com/url?q=http%3A%2F%2Fwww.khronos.org%2Fwebgl%2Fwiki%2FGetting_a_WebGL_Implementation&sa=D&sntz=1&usg=AFQjCNEnTnBdVMIaarDTponyCLS5rHphOA).
  id: totrans-2869
  prefs: []
  type: TYPE_NORMAL
- en: 17.3.1.2\. TROUBLE IN LINUX, WINDOWS OR MAC OS X
  id: totrans-2870
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the above doesn’t work then you may unfortunately have a blacklisted GPU
    / graphics card, or your graphics drivers may be out of date because the company
    has discontinued their support. In most cases we can get around this (see below).
  id: totrans-2871
  prefs: []
  type: TYPE_NORMAL
- en: You can find an explanation of [blacklisted](http://www.google.com/url?q=http%3A%2F%2Fwww.khronos.org%2Fwebgl%2Fwiki%2FBlacklistsAndWhitelists&sa=D&sntz=1&usg=AFQjCNFATCzIoQU6-Fo8xMSQZPPKtYktjQ) cards/GPU’s
    for Chrome. As of January 2013 the “blacklisted” Chrome GPU’s are as follows;
    some may be removed from the list later.
  id: totrans-2872
  prefs: []
  type: TYPE_NORMAL
- en: '**All operating systems**'
  id: totrans-2873
  prefs: []
  type: TYPE_NORMAL
- en: NVIDIA GeForce FX Go5200
  id: totrans-2874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows**'
  id: totrans-2875
  prefs: []
  type: TYPE_NORMAL
- en: Intel GMA 945
  id: totrans-2876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ATI FireMV 2400
  id: totrans-2877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mac**'
  id: totrans-2878
  prefs: []
  type: TYPE_NORMAL
- en: ATI Radeon HD2400
  id: totrans-2879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ATI Radeon 2600 series
  id: totrans-2880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ATI Radeon X1900
  id: totrans-2881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ATI Radeon HD 6490M on OS X 10.6
  id: totrans-2882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GeForce 7300 GT
  id: totrans-2883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux**'
  id: totrans-2884
  prefs: []
  type: TYPE_NORMAL
- en: AMD/ATI cards
  id: totrans-2885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nvidia QuadroFX 1500
  id: totrans-2886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nvidia cards with Nouveau drivers
  id: totrans-2887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nvidia cards with Nvidia drivers older than 295
  id: totrans-2888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimus dual-GPU configurations
  id: totrans-2889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intel for Mesa drivers earlier than 7.9 (just update drivers)
  id: totrans-2890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.3.1.3\. THE WORK-AROUND
  id: totrans-2891
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To work around this it is easiest done in Chrome by typing “[about:flags](about:flags)”
    in the address bar, it will open a page. On this page find “Override software
    rendering list” in the list and click ‘enable’. Then look for and click the “relaunch
    google chrome” button or close all chrome browser windows and restart/reload Chrome.
  id: totrans-2892
  prefs: []
  type: TYPE_NORMAL
- en: In Firefox type “[about:flags](about:flags)” in the address bar. (On this page
    there is a search input available) Search in this for “force-enabled”. Double
    click on both*layers.acceleration.force-enabled* and *webgl.force-enabled* which
    will set their value **true**. Then close all firefox browser windows and restart/reload
    firefox.
  id: totrans-2893
  prefs: []
  type: TYPE_NORMAL
- en: 17.3.1.4\. EXTRA TROUBLE
  id: totrans-2894
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Graphics drivers must be working, some graphics cards are not fully compatible
    with some operating systems. In the case of Linux OS make sure is fully updated
    ie. Intel Mesa drivers should be higher than 7.9 otherwise it will default to
    software rendering.
  id: totrans-2895
  prefs: []
  type: TYPE_NORMAL
- en: 17.3.1.5\. DIAGNOSE YOUR GPU IN CHROME
  id: totrans-2896
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can diagnose what’s happening by typing ‘chrome://gpu’ in the location bar.
    You can also see your driver version in here and other details.
  id: totrans-2897
  prefs: []
  type: TYPE_NORMAL
- en: 'If webgl is enabled then you should get a graphics feature status, ie. - Canvas:
    Hardware accelerated - WebGL: Hardware accelerated - WebGL multisampling: Hardware
    accelerated - Flash 3D: Hardware accelerated - Flash Stage3D: Hardware accelerated'
  id: totrans-2898
  prefs: []
  type: TYPE_NORMAL
- en: The GL_RENDERER also should have the name of your GPU, otherwise if its not
    working correctly it may have something like “Software Rasterizer” and will be
    really slow. In this case again check your drivers are up to date.
  id: totrans-2899
  prefs: []
  type: TYPE_NORMAL
- en: 17.4\. 1.44 ASSESSMENT GUIDE
  id: totrans-2900
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This document provides a brief introduction to teachers on the Computer Science
    Field Guide assessment guides for NCEA Achievement standard AS91074 (1.44).
  id: totrans-2901
  prefs: []
  type: TYPE_NORMAL
- en: 17.4.1\. TOPICS
  id: totrans-2902
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 1.44 has bullet points for the following three topics in computer science.
  id: totrans-2903
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms
  id: totrans-2904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming Languages
  id: totrans-2905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Human Computer Interaction
  id: totrans-2906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these topics has a chapter in the Computer Science Field Guide, which
    this assessment guide is based on.
  id: totrans-2907
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we provide two different assessment guides for algorithms (sorting
    and searching), and one for each of human computer interaction and programming
    languages. Note that students only need to follow one assessment guide for each
    of the three topics (i.e. they do not need to do both searching and sorting for
    the topic of algorithms).
  id: totrans-2908
  prefs: []
  type: TYPE_NORMAL
- en: 17.4.2\. SORTING VS SEARCHING FOR ALGORITHMS
  id: totrans-2909
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the topic of algorithms, students can demonstrate their understanding of
    algorithms and their costs by using either sorting algorithms or searching algorithms
    as their example.
  id: totrans-2910
  prefs: []
  type: TYPE_NORMAL
- en: For students who are weak at math, searching algorithms is probably the better
    choice. Sorting algorithms requires either being good at understanding trends
    from data in a table or understanding how to read trends from a graph in order
    to achieve merit or excellence, whereas the cost of Searching algorithms can easily
    be seen by students carrying out the algorithms themselves.
  id: totrans-2911
  prefs: []
  type: TYPE_NORMAL
- en: Sorting algorithms provide a slightly richer range of possibilities, including
    more ways to demonstrate how they work in a student’s report, and intriguing new
    approaches to a common and easily described task that may not have been obvious.
  id: totrans-2912
  prefs: []
  type: TYPE_NORMAL
- en: 17.4.3\. ORDER OF TOPICS
  id: totrans-2913
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The three topics can be completed in any order, although the first bullet point
    in each level (comparing algorithms, programs, and informal instructions) is probably
    best left until both algorithms and programming languages have been completed,
    since they can provide examples to illustrate the points in the first bullet points.
  id: totrans-2914
  prefs: []
  type: TYPE_NORMAL
- en: Covering Human Computer Interaction first may make the Algorithms topic more
    relevant to students. In many cases, a not so good algorithm will take a second
    to run, whereas a better algorithm will take less than a tenth of a second. This
    is very significant in terms of a good user interface, so covering HCI first will
    make students more aware of issues like this.
  id: totrans-2915
  prefs: []
  type: TYPE_NORMAL
- en: 17.4.4\. PERSONALISATION AND STUDENT VOICE
  id: totrans-2916
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important that students use personalised examples to base their explanations
    around, and that the explanations are in their own words, and based on their example
    (rather than being a paraphrase from wikipedia, for example).
  id: totrans-2917
  prefs: []
  type: TYPE_NORMAL
- en: Personalised means that the student’s example is different to their classmates.
    For example, they may have a program that prints their name or favourite saying,
    they may use a different number of items to sort or search through, their choice
    of the values being sorted or searched in examples is unique, and they may carry
    out their own usability exploration of a device they chose, and report on it in
    their own words.
  id: totrans-2918
  prefs: []
  type: TYPE_NORMAL
- en: If the teacher provides too many headings or leading questions for students
    to structure their work, this can reduce the opportunity for the report to reflect
    a personal understanding.
  id: totrans-2919
  prefs: []
  type: TYPE_NORMAL
- en: 17.4.5\. REPORT LENGTH
  id: totrans-2920
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note that the page limit given by NZQA is not a target. The
    markers prefer reports that are short and to the point, and the requirements of
    the standard can easily be met within the limit.
  id: totrans-2921
  prefs: []
  type: TYPE_NORMAL
- en: 'The page limit for 1.44 is now 10 pages to cover the three topics. A possible
    breakdown that leaves one additional page is:'
  id: totrans-2922
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithms: 4 pages'
  id: totrans-2923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Programming Languages: 2 pages'
  id: totrans-2924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Human Computer Interaction: 3 pages'
  id: totrans-2925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The assessment guides provide further guidance on how to stay within these limits.
    Students should be mindful of the recommended limits while they are working on
    their reports, in order to avoid having to delete work they put a lot of effort
    into.
  id: totrans-2926
  prefs: []
  type: TYPE_NORMAL
- en: Some hints to reduce total length
  id: totrans-2927
  prefs: []
  type: TYPE_NORMAL
- en: Only include what is relevant to the standard. While covering additional material
    in class is valuable for learning, additional content that doesn’t demonstrate
    understanding of the topics and bullet points in the standard is only a distraction
    in the report.
  id: totrans-2928
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resize screenshots and photos so that they are still readable, although don’t
    take up unnecessary space. Use cropping to show the relevant parts of the image.
  id: totrans-2929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t leave unnecessary space in the report. It both looks untidy and makes
    it more difficult for the marker to find what they are looking for.
  id: totrans-2930
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.4.6\. PRESENTING THE REPORT
  id: totrans-2931
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Always check your report trying to think of it from the marker’s point of view.
    A common mistake is to put in graphs without labels on the axes, so the marker
    doesn’t know what the graph is showing. Also make sure you give units for measurements
    (e.g. 5 seconds, 5 minutes?). If you refer to colour in an image don’t print the
    report in black and white!
  id: totrans-2932
  prefs: []
  type: TYPE_NORMAL
- en: If you are using examples, don’t use ones taken from the Field Guide or other
    sources - make up your own. For sorting and searching, makes up a set of numbers
    or words (perhaps about 8, but not 2 or 3) to demonstrate the algorithms. For
    HCI, use your own device. For algorithms, don’t use the “glass of water” example
    in the Field Guide - think of your own example to show that you’ve understood
    the point!
  id: totrans-2933
  prefs: []
  type: TYPE_NORMAL
- en: 17.4.7\. GENERAL ADVICE
  id: totrans-2934
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 2012 we did a study that looked over 151 student submissions for 1.44 in
    2011\. This was the first year 1.44 was offered, although the lessons learnt are
    still relevant, particularly for teachers teaching the standard for the first
    time. A WIPSCE paper was written presenting our findings of how well students
    approached the standard and our recommendations for avoiding pitfalls. Our key
    findings are reflected in the teacher guides, although reading the entire paper
    would be worthwhile.
  id: totrans-2935
  prefs: []
  type: TYPE_NORMAL
- en: The paper was Bell, T., Newton, H., Andreae, P., & Robins, A. (2012). The introduction
    of Computer Science to NZ High Schools — an analysis of student work. In M. Knobelsdorf
    & R. Romeike (Eds.), The 7th Workshop in Primary and Secondary Computing Education
    (WiPSCE 2012). Hamburg, Germany. Available from:[http://nzacditt.org.nz/system/files/Student-work-WiPCSE2012-final-submission-dl.pdf](http://nzacditt.org.nz/system/files/Student-work-WiPCSE2012-final-submission-dl.pdf)
  id: totrans-2936
  prefs: []
  type: TYPE_NORMAL
- en: 17.5\. ALGORITHMS (1.44) - SEARCHING ALGORITHMS
  id: totrans-2937
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting the *Algorithms* topic of digital technologies
    achievement standard 1.44 (AS91074).
  id: totrans-2938
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done projects
    covering the topics of *Programming Languages* and *Human Computer Interaction* in
    the standard, and included these in your report.
  id: totrans-2939
  prefs: []
  type: TYPE_NORMAL
- en: 17.5.1\. OVERVIEW
  id: totrans-2940
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The topic of *Algorithms* has the following bullet points in achievement standard
    1.44, which this guide covers. This guide separates them into two categories.
  id: totrans-2941
  prefs: []
  type: TYPE_NORMAL
- en: 17.5.1.1\. COMPARING ALGORITHMS, PROGRAMS, AND INFORMAL INSTRUCTIONS
  id: totrans-2942
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved** (A1): “describing the key characteristics, and roles of algorithms,
    programs and informal instructions”'
  id: totrans-2943
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit** (M1): “explaining how algorithms are distinct from related concepts
    such as programs and informal instructions”'
  id: totrans-2944
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence** (E1): “comparing and contrasting the concepts of algorithms,
    programs, and informal instructions”'
  id: totrans-2945
  prefs: []
  type: TYPE_NORMAL
- en: 17.5.1.2\. DETERMINING THE COST OF ALGORITHMS AND UNDERSTANDING VARIOUS KINDS
    OF STEPS IN ALGORITHMS
  id: totrans-2946
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved** (A2): “describing an algorithm for a task, showing understanding
    of the kinds of steps that can be in an algorithm, and determining the cost of
    an algorithm for a problem of a particular size”'
  id: totrans-2947
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit** (M2): “showing understanding of the way steps in an algorithm for
    a task can be combined in sequential, conditional, and iterative structures and
    determining the cost of an iterative algorithm for a problem of size *n*”'
  id: totrans-2948
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence** (E2): “determining and comparing the costs of two different
    iterative algorithms for the same problem of size *n*”'
  id: totrans-2949
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed Digital Technology reports, you should base
    your explanations around personalised examples.
  id: totrans-2950
  prefs: []
  type: TYPE_NORMAL
- en: 17.5.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  id: totrans-2951
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  id: totrans-2952
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 - What’s the bigger picture?
  id: totrans-2953
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 - Searching Algorithms
  id: totrans-2954
  prefs: []
  type: TYPE_NORMAL
- en: 17.5.3\. PROJECT
  id: totrans-2955
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project involves understanding linear search and binary search.
  id: totrans-2956
  prefs: []
  type: TYPE_NORMAL
- en: 17.5.3.1\. WRITING YOUR REPORT FOR THE MAIN BULLET POINTS THAT COVER ALGORITHMS
  id: totrans-2957
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved**'
  id: totrans-2958
  prefs: []
  type: TYPE_NORMAL
- en: Try both the box searching interactives linked to in the field guide. For one
    of them you have to use linear search, and for the other you have to use binary
    search.
  id: totrans-2959
  prefs: []
  type: TYPE_NORMAL
- en: Pick one of these algorithms to focus on for achieved. Carry out the interactive
    and then take a screenshot. Show on your screenshot which boxes you opened, and
    put how many boxes you opened. The number of boxes you opened is the *cost* of
    the algorithm in this particular case.
  id: totrans-2960
  prefs: []
  type: TYPE_NORMAL
- en: If you did the search with this same number of boxes lots of times (but with
    different numbers in the boxes), on average how many boxes would you need to check?
    This is the *cost* for a problem of this particular size (the problem size is
    the number of boxes).
  id: totrans-2961
  prefs: []
  type: TYPE_NORMAL
- en: Describe (in your own words with a few sentences) the overall process you carried
    out to search through the boxes. Try and make your explanation general, e.g. if
    you gave the instructions to somebody who needs to know how to search 100 boxes,
    or 500 boxes, the instructions would be meaningful.
  id: totrans-2962
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit/ Excellence**'
  id: totrans-2963
  prefs: []
  type: TYPE_NORMAL
- en: For merit, you need to make it clear that you understand that algorithms can
    contain iterative, conditional, and sequential steps. If you don’t know what these
    terms mean, go have another look at the field guide. Get a Scratch program (or
    another language if you are fairly confident with understanding the language)
    that implements your sorting algorithm. Take a screenshot of it, or a large part
    of it (you want to ensure that the screenshot takes up no more than half a page
    in the report, but is still readable) and open it in a drawing program such as
    paint. Add arrows and notes showing a part of the algorithm that is sequential,
    part that is conditional, and part that is iterative.
  id: totrans-2964
  prefs: []
  type: TYPE_NORMAL
- en: It should be obvious by now that binary search is far better than linear search!
    Although you still might say, why not just use a faster computer? To explore this
    possibility, you are now going to analyse what happens with a **huge** amount
    of data. Pick a really large number (e.g. in the billions, or even bigger - this
    is the amount of data that large online companies have to search). Imagine you
    have this number of boxes that you have to search. Rather than actually carrying
    out the searching, you are going to determine how long it would take if you use
    linear search, and how long it would take if you used binary search. Computer
    scientists call this*analysing* an algorithm, and often it is better to work out
    how long an algorithm can be expected to take before waiting years for it to run
    and wondering if it will ever complete.
  id: totrans-2965
  prefs: []
  type: TYPE_NORMAL
- en: '*Remember that you can use the big number calculator and the time calculator
    in the field guide.*'
  id: totrans-2966
  prefs: []
  type: TYPE_NORMAL
- en: How many boxes on average will you have to search if you use a linear search?
  id: totrans-2967
  prefs: []
  type: TYPE_NORMAL
- en: What about with binary search? If you are unsure on how to calculate this, remember
    that each box you check cuts the number of boxes you still need to consider in
    half. Therefore, you can determine approximately how many boxes you will need
    to check by continually halving the total number of boxes until it gets down to
    1\. You should include all the working (i.e. the result of each division by 2)
    in your report.
  id: totrans-2968
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if your answer isn’t perfect; it’s okay to be within 5 or so of
    the correct answer. This means that if while halving your number it never gets
    down to exactly 1 (e.g. it gets down to 1.43 and then 0.715), your answer will
    be near enough. As long as you have halved your number repeatedly until it gets
    down to a number that is less than 1, your answer will be accurate.
  id: totrans-2969
  prefs: []
  type: TYPE_NORMAL
- en: Calculate how long it would take for each algorithm, assuming you have a computer
    that can look in a million boxes per second. Don’t worry about being too accurate
    (e.g. just round to the nearest second, minute, hour, day, month, or year).
  id: totrans-2970
  prefs: []
  type: TYPE_NORMAL
- en: You should see a very big difference between the two numbers. What will happen
    if you have twice as many boxes? What about four times as many? How long will
    it take for each algorithm? You should easily be able to calculate these numbers
    based on your previous calculations.
  id: totrans-2971
  prefs: []
  type: TYPE_NORMAL
- en: Include a table in your report that shows the time it would take for your 15
    digit number of boxes using each algorithm, and then for two times, four times,
    and eight times the number of boxes. If you are keen you could look at 128 times
    as well (that is doubling the problem size 7 times).
  id: totrans-2972
  prefs: []
  type: TYPE_NORMAL
- en: Write about what you observe in the time increase when you have doubled the
    number of boxes.
  id: totrans-2973
  prefs: []
  type: TYPE_NORMAL
- en: With such a large number of boxes, how important is it to use binary search
    if you can? Imagine if you were a computer scientist with the task of searching
    these boxes, and in order to do your work you need to search for many pieces of
    data each day. What would happen if you were trying to use linear search?
  id: totrans-2974
  prefs: []
  type: TYPE_NORMAL
- en: 17.5.3.2\. WRITING THE PART OF YOUR REPORT THAT ADDRESSES “COMPARING ALGORITHMS/
    PROGRAMS/ INFORMAL INSTRUCTIONS”
  id: totrans-2975
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved/ Merit/ Excellence**'
  id: totrans-2976
  prefs: []
  type: TYPE_NORMAL
- en: We recommend doing this part after you have done programming languages.
  id: totrans-2977
  prefs: []
  type: TYPE_NORMAL
- en: All three levels (A/M/E) are subsumed by the E requirement, so you should try
    to do that i.e. “comparing and contrasting the concepts of algorithms, programs,
    and informal instructions”. You should refer to examples you used in your report
    or include additional examples (e.g. a program used as an example in the programming
    languages topic, or an algorithm describing the searching process, etc). If you
    are confused, have another look at the field guide. You should only need to write
    a few sentences to address this requirement.
  id: totrans-2978
  prefs: []
  type: TYPE_NORMAL
- en: 17.5.4\. HINTS FOR SUCCESS
  id: totrans-2979
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don’t confuse “algorithm cost” with the “algorithm length”. The number of lines
    in the algorithm or program normally unrelated to the cost. Cost is the time the
    algorithm actually takes to run, or the number of comparisons that have to be
    made. You can find more information in the Field Guide if you are not sure.
  id: totrans-2980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resize screenshots/ photos so that they are large enough to see what is on them,
    but not taking up unnecessary space.
  id: totrans-2981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.5.5\. RECOMMENDED NUMBER OF PAGES
  id: totrans-2982
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within the 4 pages recommended for algorithms, a possible breakdown is:'
  id: totrans-2983
  prefs: []
  type: TYPE_NORMAL
- en: '1 ½ pages: Screenshots and explanations of you carrying out a chosen algorithm **(Achieved)**'
  id: totrans-2984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '¼ page: General instructions for carrying out your chosen algorithm **(Achieved)**'
  id: totrans-2985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '½ page: Example of the iterative, conditional, and sequential steps that can
    be in an algorithm **(Merit)**'
  id: totrans-2986
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1 ½ pages: Your investigation and data collected for merit/ excellence. Including
    results and discussion **(Merit/ Excellence)**'
  id: totrans-2987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '¼ page: Explanation of the difference between algorithms, programs, and informal
    instructions **(Achieved/ Merit/ Excellence)**'
  id: totrans-2988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are *maximums*, not targets!
  id: totrans-2989
  prefs: []
  type: TYPE_NORMAL
- en: For the topic of searching algorithms you probably won’t need this much space
    (sorting algorithms tends to require more space). In particular, you should only
    need 1 page to introduce your chosen algorithm for achieved, and 1 page or less
    for your investigation for merit/ excellence. This might allow you to allocate
    more pages to one of the other two topics.
  id: totrans-2990
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you go over 4 pages for Algorithms, then you may have to use fewer
    pages for one of the other two topics, which could be problematic. No other material
    should be included for Algorithms.
  id: totrans-2991
  prefs: []
  type: TYPE_NORMAL
- en: 17.6\. ALGORITHMS (1.44) - SORTING ALGORITHMS
  id: totrans-2992
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting the *Algorithms* topic of digital technologies
    achievement standard 1.44 (AS91074).
  id: totrans-2993
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done projects
    covering the topics of *Programming Languages* and *Human Computer Interaction* in
    the standard, and included these in your report.
  id: totrans-2994
  prefs: []
  type: TYPE_NORMAL
- en: 17.6.1\. OVERVIEW
  id: totrans-2995
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The topic of *Algorithms* has the following bullet points in achievement standard
    1.44, which this guide covers. This guide separates them into two categories.
  id: totrans-2996
  prefs: []
  type: TYPE_NORMAL
- en: 17.6.1.1\. COMPARING ALGORITHMS, PROGRAMS, AND INFORMAL INSTRUCTIONS
  id: totrans-2997
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved** (A1): “describing the key characteristics, and roles of algorithms,
    programs and informal instructions”'
  id: totrans-2998
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit** (M1): “explaining how algorithms are distinct from related concepts
    such as programs and informal instructions”'
  id: totrans-2999
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence** (E1): “comparing and contrasting the concepts of algorithms,
    programs, and informal instructions”'
  id: totrans-3000
  prefs: []
  type: TYPE_NORMAL
- en: 17.6.1.2\. DETERMINING THE COST OF ALGORITHMS AND UNDERSTANDING VARIOUS KINDS
    OF STEPS IN ALGORITHMS
  id: totrans-3001
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved** (A2): “describing an algorithm for a task, showing understanding
    of the kinds of steps that can be in an algorithm, and determining the cost of
    an algorithm for a problem of a particular size”'
  id: totrans-3002
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit** (M2): “showing understanding of the way steps in an algorithm for
    a task can be combined in sequential, conditional, and iterative structures and
    determining the cost of an iterative algorithm for a problem of size *n*”'
  id: totrans-3003
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence** (E2): “determining and comparing the costs of two different
    iterative algorithms for the same problem of size *n*”'
  id: totrans-3004
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed Digital Technology reports, you should base
    your explanations around personalised examples.
  id: totrans-3005
  prefs: []
  type: TYPE_NORMAL
- en: 17.6.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  id: totrans-3006
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  id: totrans-3007
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 - What’s the bigger picture?
  id: totrans-3008
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 - Sorting Algorithms
  id: totrans-3009
  prefs: []
  type: TYPE_NORMAL
- en: Note that 2.2 is not necessary for this project, as 2.2 focuses on *searching* algorithms,
    whereas this project focuses on *sorting* algorithms.
  id: totrans-3010
  prefs: []
  type: TYPE_NORMAL
- en: 17.6.3\. PROJECT
  id: totrans-3011
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project involves understanding how selection sort works and the types of
    steps that can be in it and other algorithms, and then comparing the cost of selection
    sort and quicksort.
  id: totrans-3012
  prefs: []
  type: TYPE_NORMAL
- en: 17.6.3.1\. WRITING YOUR REPORT FOR THE MAIN BULLET POINTS THAT COVER ALGORITHMS
  id: totrans-3013
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved**'
  id: totrans-3014
  prefs: []
  type: TYPE_NORMAL
- en: Carry out selection sort on a small amount of data. You can do this either using
    the balance scale interactive in the field guide (recommended), a physical set
    of balance scales if your school has them (normal scales that show the exact weights
    are unsuitable), or as a trace you did using pencil and paper (not recommended).
    Count how many comparisons you made to sort the items.
  id: totrans-3015
  prefs: []
  type: TYPE_NORMAL
- en: Take screenshots/ photos of you using the interactive or balance scales to do
    the sorting. Three or four pictures would be ideal (i.e. one showing the initial
    state of the scales and weights, one or two in the middle where you are comparing
    weights, and one at the end where all the weights are sorted). Use a drawing program
    to draw on each of the pictures and show which weights have been sorted so far,
    and which have not. Put on the screenshots how many comparisons have been made
    so far in the sorting process. Write a short explanation of what is happening
    in the images. Make sure you include the total number of comparisons that was
    needed to sort the items in your report.
  id: totrans-3016
  prefs: []
  type: TYPE_NORMAL
- en: Describe (in your own words with a few sentences) the overall process you carried
    out to sort the weights or numbers. Try and make your explanation general, e.g.
    if you gave the instructions to somebody who needs to know how to sort 100 numbers,
    or 500 numbers, the instructions would be meaningful.
  id: totrans-3017
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**'
  id: totrans-3018
  prefs: []
  type: TYPE_NORMAL
- en: For merit, you need to make it clear that you understand that algorithms can
    contain iterative, conditional, and sequential steps. If you don’t know what these
    terms mean, go have another look at the field guide. Get a Scratch program (or
    another language if you are fairly confident with understanding the language)
    that implements selection sort. Take a screenshot of it, or a large part of it
    (you want to ensure that the screenshot takes up no more than half a page in the
    report, but is still readable) and open it in a drawing program such as paint.
    Add arrows and notes showing a part of the algorithm that is sequential, part
    that is conditional, and part that is iterative.
  id: totrans-3019
  prefs: []
  type: TYPE_NORMAL
- en: Remember that some algorithms are a lot faster than others, especially as the
    size of the problem gets bigger. It isn’t necessarily the case that if you try
    to sort twice as many items then it will take twice as long. As a quick warm up
    investigation to give you some idea of this, try the following.
  id: totrans-3020
  prefs: []
  type: TYPE_NORMAL
- en: Get an implementation of selection sort (there are some linked to at the end
    of the chapter in the field guide). Start by choosing a number between 10 and
    20\. How many comparisons does it take to sort that many randomly generated numbers
    with your chosen algorithm? Now, try sorting twice as many numbers. How many comparisons
    did it take now? Does it take twice as many? Now, try sorting 10 times as many
    numbers. Does it take 10 times as many comparisons? How many more times the original
    problem size’s number of comparisons does it actually take? Hopefully you are
    starting to see a trend here.
  id: totrans-3021
  prefs: []
  type: TYPE_NORMAL
- en: '*If you aren’t attempting excellence,* include the numbers you got from the
    warm up investigation, along with an explanation of the trend you found. *If you
    are attempting excellence, you should do the warm up investigation as it will
    help you (and will only take a few minutes), but you don’t need to write about
    it.*'
  id: totrans-3022
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**'
  id: totrans-3023
  prefs: []
  type: TYPE_NORMAL
- en: You probably found in the activity for merit that selection sort isn’t a very
    good algorithm. So how much better is quicksort? Does the difference become more
    noticeable as you try to sort more numbers? For your report, you are going to
    compare selection sort with quicksort. Your objective is to show how much the
    difference in comparisons between selection sort and quicksort changes as the
    number of items to be sorted is increased.
  id: totrans-3024
  prefs: []
  type: TYPE_NORMAL
- en: Choose 10 numbers in the range of 1 to 1000 (you will need a good variety of
    numbers, some high and some low. Do not pick the same numbers as your classmates!)
    For each of your 10 numbers, try sorting that many values with each of the sorting
    algorithms. Record your results in a table that has a column for the problem size,
    a column for how many comparisons selection sort used, and a column for how many
    comparisons quicksort used.
  id: totrans-3025
  prefs: []
  type: TYPE_NORMAL
- en: The best way of visualising the data you have just collected is to make a graph
    (e.g. using Excel). Your graph should have 2 lines; one for quicksort and one
    for selection sort, showing how the number of comparisons increases as the size
    of the problem goes up. Make sure you label the graph well. A simple way of making
    the graph is to use a scatter plot and put in lines connecting the dots (make
    sure the data for the graph is increasing order with the smallest problem sizes
    first and largest last so that the line gets drawn properly). Ask your teacher
    for guidance if you are having difficulty with excel.
  id: totrans-3026
  prefs: []
  type: TYPE_NORMAL
- en: Look at your graph. Does the rate of increase for the two algorithms seem to
    be quite different? Discuss what your graph shows. If you aren’t sure what to
    include in the discussion of your findings, you could consider the following questions
    (optional).
  id: totrans-3027
  prefs: []
  type: TYPE_NORMAL
- en: What happens to the number of comparisons when you double how many numbers you
    are sorting with quicksort? What about when you sort 10 times as many numbers?
    How is this different to when you used selection sort at the start?
  id: totrans-3028
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the largest problem you can solve within a few seconds using selection
    sort? What about with quicksort?
  id: totrans-3029
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you had a database with 1 million people in it and you needed to sort them
    by age, which of the two algorithms would you choose? Why? What would happen if
    you chose the other algorithm?
  id: totrans-3030
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.6.3.2\. WRITING THE PART OF YOUR REPORT THAT ADDRESSES “COMPARING ALGORITHMS/
    PROGRAMS/ INFORMAL INSTRUCTIONS”
  id: totrans-3031
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved/ Merit/ Excellence**'
  id: totrans-3032
  prefs: []
  type: TYPE_NORMAL
- en: We recommend doing this part after you have done programming languages.
  id: totrans-3033
  prefs: []
  type: TYPE_NORMAL
- en: All three levels (A/M/E) are subsumed by the E requirement, so you should try
    to do that i.e. “comparing and contrasting the concepts of algorithms, programs,
    and informal instructions”. You should refer to examples you used in your report
    or include additional examples (e.g. a program used as an example in the programming
    languages topic, or an algorithm describing the sorting process, etc). If you
    are confused, have another look at the field guide. You should only need to write
    a few sentences to address this requirement.
  id: totrans-3034
  prefs: []
  type: TYPE_NORMAL
- en: 17.6.4\. HINTS FOR SUCCESS
  id: totrans-3035
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don’t confuse “algorithm cost” with the “algorithm length”. The number of lines
    in the algorithm or program normally unrelated to the cost. Cost is the time the
    algorithm actually takes to run, or the number of comparisons that have to be
    made. You can find more information in the Field Guide if you are not sure.
  id: totrans-3036
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we recommend using the balance scales interactive, if you do include a
    pen and paper trace, don’t give yourself more than 5 or 6 values to sort, and
    use an efficient layout that ensures the entire trace takes no more than about
    half a page.
  id: totrans-3037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resize screenshots/ photos so that they are large enough to see what is on them,
    but not taking up unnecessary space.
  id: totrans-3038
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be sure to label the axis of your graph clearly so that the marker knows what
    your graph shows.
  id: totrans-3039
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.6.5\. RECOMMENDED NUMBER OF PAGES
  id: totrans-3040
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within the 4 pages we recommend for algorithms, a possible breakdown is:'
  id: totrans-3041
  prefs: []
  type: TYPE_NORMAL
- en: '1 ½ pages: Screenshots and explanations of you carrying out a chosen algorithm
    and determining the cost of it for your example problem (**Achieved**)'
  id: totrans-3042
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '¼ page: General instructions for carrying out your chosen algorithm (**Achieved**)'
  id: totrans-3043
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '½ page: Example of the iterative, conditional, and sequential steps that can
    be in an algorithm (**Merit**)'
  id: totrans-3044
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1 ½ pages: Your investigation and data collected for merit/ excellence. Including
    results and discussion (**Merit/ Excellence**)'
  id: totrans-3045
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '¼ page: Explanation of the difference between algorithms, programs, and informal
    instructions (**Achieved/ Merit/ Excellence**)'
  id: totrans-3046
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are *maximums*, not targets!
  id: totrans-3047
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you go over 4 pages for Algorithms, then you may have to use fewer
    pages for one of the other two topics, which could be problematic. No other material
    should be included for Algorithms.
  id: totrans-3048
  prefs: []
  type: TYPE_NORMAL
- en: 17.7\. HUMAN COMPUTER INTERACTION (1.44)
  id: totrans-3049
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting Human Computer Interaction in digital
    technologies achievement standard 1.44 (AS91074).
  id: totrans-3050
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done projects
    covering the topics of Algorithms and Programming Languages, and included these
    in your report.
  id: totrans-3051
  prefs: []
  type: TYPE_NORMAL
- en: 17.7.1\. OVERVIEW
  id: totrans-3052
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Human Computer Interaction has the following bullet points in achievement standard
    1.44, which this guide covers.
  id: totrans-3053
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: “describing the role of a user interface and factors that contribute
    to its usability”'
  id: totrans-3054
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “explaining how different factors of a user interface contribute
    to its usability”'
  id: totrans-3055
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**: “discussing how different factors of a user interface contribute
    to its usability by comparing and contrasting related interfaces”'
  id: totrans-3056
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed reports, you should base your explanations around
    personalised examples.
  id: totrans-3057
  prefs: []
  type: TYPE_NORMAL
- en: 17.7.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  id: totrans-3058
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  id: totrans-3059
  prefs: []
  type: TYPE_NORMAL
- en: Read all of these sections, as they give the necessary introduction of the topic
  id: totrans-3060
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 - What’s the Big Picture?
  id: totrans-3061
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 - Users and Tasks
  id: totrans-3062
  prefs: []
  type: TYPE_NORMAL
- en: Read one (or both if you are keen) of these sections as they will give you some
    ideas for evaluating an interface in your project.
  id: totrans-3063
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 - Interface Usability
  id: totrans-3064
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 - Usability Heuristics
  id: totrans-3065
  prefs: []
  type: TYPE_NORMAL
- en: 17.7.3\. PROJECT
  id: totrans-3066
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, you will carry out a usability evaluation carrying out a specific
    task with a chosen interface. Unless you are good at seeing things from other
    people’s perspectives, it is best to find a helper who will carry out the task
    with the interface with you observing them
  id: totrans-3067
  prefs: []
  type: TYPE_NORMAL
- en: 17.7.3.1\. CHOOSING AN INTERFACE
  id: totrans-3068
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The interface you choose should be one your helper is not familiar with,
  id: totrans-3069
  prefs: []
  type: TYPE_NORMAL
- en: Because you will need to compare related interfaces for excellence, make sure
    you choose an interface for which you will also be able to find a second related
    interface to compare with (e.g. two different alarm clocks). The second interface
    should also be one you are not familiar with (otherwise you will be biased).
  id: totrans-3070
  prefs: []
  type: TYPE_NORMAL
- en: Your interface should also be specific. By this we mean it should just have
    one obvious function. e.g. texting capabilities of a cellphone, file chooser on
    a computer, etc. iPhone vs Samsung Phone, or Windows vs Macintosh are too general
    as there are thousands of aspects to these interfaces! You would need to pick
    specific apps or programs within them that typically only need a few steps to
    complete a task.
  id: totrans-3071
  prefs: []
  type: TYPE_NORMAL
- en: 'Some possible pairs of interfaces you could use are:'
  id: totrans-3072
  prefs: []
  type: TYPE_NORMAL
- en: Online booking systems for two different airlines (e.g. Air NZ vs Jetstar)
  id: totrans-3073
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two different friend’s cell phones
  id: totrans-3074
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two different email clients you have never used before (don’t forget about the
    many webmail clients. Even signing up for webmail addresses could prove to be
    challenging in some cases!)
  id: totrans-3075
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try heating something in 2 different microwaves. Cheap microwaves are notorious
    for being inconsistent and illogical to use. [Note that running a microwave with
    nothing in it will damage it! You would be best to put something inside it while
    you are experimenting with its interface. Water in a microwave safe glass is fine]
  id: totrans-3076
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a couple of apps/ programs/ for setting an alarm (many exist). You could
    choose ones that go on a phone or on your computer, or one of each. A physical
    alarm clock would be good.
  id: totrans-3077
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two different drawing programs you have never used before
  id: totrans-3078
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that an interface you designed yourself is unsuitable because you will
    know how it works in great detail.
  id: totrans-3079
  prefs: []
  type: TYPE_NORMAL
- en: 17.7.3.2\. CHOOSING A TASK WITH THE INTERFACE
  id: totrans-3080
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have chosen an interface, you need to think of one or two common tasks
    that are carried out with your chosen interface. The tasks should be specific.
    Some tasks (depending on the interfaces you chose) could be:'
  id: totrans-3081
  prefs: []
  type: TYPE_NORMAL
- en: Setting an alarm that will ring at 4:25am tomorrow to catch an early flight
    (or for a more sophisticated interface, at 7:25am on Monday, Tuesday, Wednesday,
    and Friday i.e. all weekdays except Thursday)
  id: totrans-3082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a text to a friend that says “What are you doing at 3pm today? :-)”
    [Symbols are good to include in the message]
  id: totrans-3083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a phone background to a photo you found online
  id: totrans-3084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heating some food or water in a microwave for 1 minute, 20 seconds
  id: totrans-3085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Booking the cheapest flight that will arrive before 11 AM in Auckland from Christchurch,
    on the next Saturday (stop once you get to the part that asks for payment details!)
  id: totrans-3086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw a smiley face with a drawing program. Put your name below the smiley face.
  id: totrans-3087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.7.3.3\. WRITING YOUR REPORT
  id: totrans-3088
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to satisfy the requirements of the standard, you should do the following
    and include all your answers in your report. A photos and screenshots of your
    interface and various aspects of it are useful to include.
  id: totrans-3089
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**'
  id: totrans-3090
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of the interface(s) you have chosen? How will they help
    the user achieve their task?
  id: totrans-3091
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved/ Merit (Note that this is needed for achieved, but should also cover
    merit)**'
  id: totrans-3092
  prefs: []
  type: TYPE_NORMAL
- en: Try carrying out your chosen task with one of the interfaces, or observe a helper
    carrying out the task. Take notes of every time you or your helper are confused,
    select an incorrect option (or menu), something happens you didn’t expect (no
    matter how minor it is), something happens that wastes time, etc. (there is some
    more detail on doing this here: [http://www.cs4fn.org/usability/cogwalkthrough.php](http://www.cs4fn.org/usability/cogwalkthrough.php))
  id: totrans-3093
  prefs: []
  type: TYPE_NORMAL
- en: Think back to sections 3.3 and/or 3.4 of the book. Explain the characteristics
    of the interface that caused the problems you identified. Which characteristics
    of the interface made it easy for the user to figure out how to carry out the
    task?
  id: totrans-3094
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to briefly describe the context of each characteristic (e.g. what was
    the user trying to accomplish at the time? What were they expecting to see happen)?
    You should explain 2 or 3 characteristics (2 is fine if you are attempting excellence,
    as you will have 4 characteristics between the 2 interfaces which is enough!).
  id: totrans-3095
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**'
  id: totrans-3096
  prefs: []
  type: TYPE_NORMAL
- en: Carry out the chosen task with the second interface, and do the same as you
    did for Achieved/Merit with it (consider similar characteristics to before, and
    focus on seeing if the second interface has similar issues to the first interface).
    What was different between the two interfaces? Which interface did you (or your
    helper) prefer using? Why? If you were designing an interface that could be used
    for the same task, which ideas would you take from each interface?
  id: totrans-3097
  prefs: []
  type: TYPE_NORMAL
- en: 17.7.4\. HINTS FOR SUCCESS
  id: totrans-3098
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be careful to talk about interface usability rather than just features. For
    example, a cell phone might have a fancy camera able to take very high resolution
    photos (a feature), but what we’re interested in is how easy it actually is for
    somebody to take a photo with the camera (a usability factor), especially how
    easy it is to go from having the phone in your pocket to getting the photo, or
    from taking the photo to sharing or printing it.
  id: totrans-3099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your helper struggles to complete the task with the interface, it is likely
    to be because the interface was not designed well for them. This gives you great
    material for your project - look for the reasons they had trouble and don’t blame
    them, as it isn’t their fault.
  id: totrans-3100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose an interface that you or your helper rarely/ never use, otherwise you
    may be blind to usability issues because you’ve got used to working with them!
  id: totrans-3101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t evaluate an interface you designed yourself. As we said in the book, the
    designer knows the interface really well, and is the worst person to evaluate
    it!
  id: totrans-3102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The page limit given by NZQA for the length of your report includes your work
    on algorithms and programming languages. The limit provides enough space to write
    an excellent report, but to avoid blowing out the page length:'
  id: totrans-3103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to keep photos/ screenshots large enough to see, but not so large they take
    up needless amounts of space.
  id: totrans-3104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you write concisely and clearly, you may be able to cover all the requirements
    with a page or less of writing (excluding pictures). This is fine, and in fact
    desirable for the marker as long as you have covered all the requirements.
  id: totrans-3105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.7.5\. RECOMMENDED NUMBER OF PAGES
  id: totrans-3106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within the 3 pages we recommend for Human Computer Interaction, you should
    include a few images of your interface, and some explanations of the usability
    factors. For the project outlined above, a possible breakdown is:'
  id: totrans-3107
  prefs: []
  type: TYPE_NORMAL
- en: ½ page of text introducing the topic, your chosen interface, and chosen tasks.
    (**Achieved**)
  id: totrans-3108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ½ page of text explaining the usability factors identified in the first observation.
    (**Achieved/Merit**)
  id: totrans-3109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ½ page of text explaining usability factors identified in the second observation
    (**Excellence**)
  id: totrans-3110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ½ page of text discussing comparing the two interfaces (**Excellence**)
  id: totrans-3111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up to 1 page worth of images (mixed with the above); ensure they are shrunk
    down enough that they are legible but not wasting space. You may decided instead
    to do a little more writing and include a fewer images.
  id: totrans-3112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are *maximums*, not targets!
  id: totrans-3113
  prefs: []
  type: TYPE_NORMAL
- en: The key to this topic is writing succinctly. Be careful to not ramble. You might
    not be able to include everything you wanted to; this is okay. Just prioritise
    and focus on the most interesting 2 or 3 issues for each interface.
  id: totrans-3114
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you go over 3 or 4 pages for Human Computer Interaction, then you
    may have to use fewer pages for one of the other two topics, which could be problematic.
  id: totrans-3115
  prefs: []
  type: TYPE_NORMAL
- en: No other material should be included for Human Computer Interaction. For example,
    don’t include a list of heuristics explaining each one, or a list of general usability
    factors. You should only describe factors that directly relate to your chosen
    user interfaces.
  id: totrans-3116
  prefs: []
  type: TYPE_NORMAL
- en: 17.8\. PROGRAMMING LANGUAGES (1.44)
  id: totrans-3117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students writing about the topic of Programming Languages
    in Digital Technologies achievement standard 1.44 (AS91074).
  id: totrans-3118
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done projects
    covering the topics of *Algorithms* and *Human Computer Interaction*, and included
    these in your report.
  id: totrans-3119
  prefs: []
  type: TYPE_NORMAL
- en: 17.8.1\. OVERVIEW
  id: totrans-3120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programming Languages has the following bullet points in achievement standard
    1.44, which this guide covers. Note that merit is split into two bullet points.
  id: totrans-3121
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: “describing the role and characteristics of programming languages,
    including the different roles and characteristics of high level languages and
    low level (or machine) languages, and the function of a compiler”'
  id: totrans-3122
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “explaining how the characteristics of programming languages, including
    the different characteristics of high level and low level (or machine) languages,
    are important for their roles”'
  id: totrans-3123
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “explaining the need for programs to translate between high and
    low level languages”'
  id: totrans-3124
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**: “comparing and contrasting high level and low level (or machine)
    languages, and explaining different ways in which programs in a high level programming
    language are translated into a machine language'
  id: totrans-3125
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed reports, you should base your explanations around
    personalised examples.
  id: totrans-3126
  prefs: []
  type: TYPE_NORMAL
- en: 17.8.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  id: totrans-3127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives and activities in the following
    sections of the CS Field Guide in order to prepare yourself for the assessed project.
  id: totrans-3128
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 - What’s the Big Picture? (and an introduction to what programming is, intended
    for those of you with limited programming experience)
  id: totrans-3129
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 - Machine Code (Low Level Languages)
  id: totrans-3130
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 - A Babel of Programming Languages (High Level Languages)
  id: totrans-3131
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 - How does the Computer Process your Program? (Compilers and Interpreters)
  id: totrans-3132
  prefs: []
  type: TYPE_NORMAL
- en: Note that you don’t need to read about all the programming languages in 4.3\.
    It is important that you actually do the activities in 4.2 (and 4.1 if you don’t
    know much about programming).
  id: totrans-3133
  prefs: []
  type: TYPE_NORMAL
- en: 17.8.3\. PROJECT
  id: totrans-3134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project consists of two main components. The first involves making a couple
    of examples
  id: totrans-3135
  prefs: []
  type: TYPE_NORMAL
- en: 17.8.3.1\. MAKING EXAMPLES FOR YOUR REPORT
  id: totrans-3136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need two examples of programs to include in your report; one that is
    in a high level language and one that is in a low level language. For the high
    level language example, you should use a program you wrote yourself, or make a
    small modification of a high level language program from the field guide
  id: totrans-3137
  prefs: []
  type: TYPE_NORMAL
- en: Include your program examples in your report as either screenshots or plain
    text. Note that the Hints for Success section has some advice on displaying code
    in a report.
  id: totrans-3138
  prefs: []
  type: TYPE_NORMAL
- en: Briefly explain what each of the programs does (ideally you should have run
    them). e.g. does it add numbers, or does it print some output?. You do not need
    to explain how it does it (i.e. no need to explain what each statement in the
    program does). What output do your programs give? The purpose of this is to show
    the marker that you do know what your example does.
  id: totrans-3139
  prefs: []
  type: TYPE_NORMAL
- en: 17.8.3.2\. HIGH AND LOW LEVEL LANGUAGES (ACHIEVED/MERIT/ EXCELLENCE)
  id: totrans-3140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What is the main difference(s) you see between the high level language and the
    low level language? Why would a human not want to program in the language shown
    in your low level programming language example? What made modifying the low level
    programs in section 4.2 of the field guide challenging? Given that a human probably
    doesn’t want to program in a low level language, why do we need low level programming
    languages at all? What is their purpose?
  id: totrans-3141
  prefs: []
  type: TYPE_NORMAL
- en: When you wrote your high level program (or modified an existing program), what
    features of the language made this easier compared to when you attempted to modify
    a low level program? Why are there many different high level programming languages?
  id: totrans-3142
  prefs: []
  type: TYPE_NORMAL
- en: In order to make your answers really clear, you might like to quote a few lines
    of your code examples which illustrate the points you make (e.g. some code that
    is cryptic and some code that you can tell easily what it does).
  id: totrans-3143
  prefs: []
  type: TYPE_NORMAL
- en: 17.8.3.3\. COMPILERS AND INTERPRETERS (ACHIEVED/MERIT/ EXCELLENCE)
  id: totrans-3144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a compiler for the language your high level program example is written
    in, how would you use it to allow the computer to run your program? (Even if your
    language is an interpreted one, such as Python, just explain what would happen
    if you had a compiler for it, as technically a compiler could be written for any
    language).
  id: totrans-3145
  prefs: []
  type: TYPE_NORMAL
- en: If you have access to a compiler, you could explain how you have to use it,
    and show an example of its output (the compiled program)
  id: totrans-3146
  prefs: []
  type: TYPE_NORMAL
- en: What about an interpreter? How does the interpreter’s function differ from a
    compiler in the way interpreted programs and compiled programs are run? Which
    is mostly used?
  id: totrans-3147
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some more ideas for comparing compilers and interpreters: One way
    to consider the difference is to explain what happens if a program is transferred
    from one computer to another. Does it still run on the other computer? Does someone
    else need the same compiler or interpreter to run your software? Can you type
    in each line of a program and have it executed as you type it, or does the whole
    program have to be available before it can be run?'
  id: totrans-3148
  prefs: []
  type: TYPE_NORMAL
- en: 17.8.4\. HINTS FOR SUCCESS
  id: totrans-3149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should easily be able to explain the concepts in half to one page of writing
    (in addition to the program examples). Any more than this is probably unnecessary.
  id: totrans-3150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t use large programs in the examples. Keep it to 5 to 10 lines (slightly
    fewer is okay!) for the high level program, and a bit more for the low level program.
    A good trick for displaying the low level program without wasting space is to
    use 2 columns, because the low level language statements are so short ( you could
    remove the comments in the code). If using a screenshot, get 2 screenshots with
    roughly half the program each and put them side by side, and if using text directly
    in report, just format it to 2 columns.
  id: totrans-3151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If displaying the program examples as plain text in your report, then make the
    font size smaller for the code to try and prevent lines splitting (8pt or 9pt
    should be fine, as long as your explanations in the rest of your report are using
    the font size that NZQA requires!) Preferably use a fixed width font for program
    code as a variable width font can mess up the layout.
  id: totrans-3152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If displaying the program examples as screenshots and the editor background
    is darker than the text colour, invert the colours using an image editor so as
    to make it easier to read on paper, and not waste black ink/toner!
  id: totrans-3153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paraphrasing definitions of high level languages, low level languages, compilers,
    and interpreters from Wikipedia or another site is not satisfactory for the standard.
    The marker needs to see what you understand, not what Wikipedia understands! You
    can show your understanding by explaining the ideas using your own examples.
  id: totrans-3154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.8.5\. RECOMMENDED NUMBER OF PAGES
  id: totrans-3155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within the 2 pages we recommend using for programming languages, a possible
    breakdown is:'
  id: totrans-3156
  prefs: []
  type: TYPE_NORMAL
- en: '½ page: Example of low level program'
  id: totrans-3157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '½ page: Example of high level program'
  id: totrans-3158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '½ page: High Level and Low Level languages discussion'
  id: totrans-3159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '½ page: Compilers and Interpreters discussion'
  id: totrans-3160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are *maximums*, not targets!
  id: totrans-3161
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you go over 2 pages for Programming Languages, then you may have
    to use fewer pages for one of the other two topics, which could be problematic.
    No other material should be included for Programming Languages
  id: totrans-3162
  prefs: []
  type: TYPE_NORMAL
- en: 17.9\. 2.44 ASSESSMENT GUIDE
  id: totrans-3163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This document provides a brief introduction to teachers on the Computer Science
    Field Guide assessment guides for NCEA Achievement standard AS91371 (2.44).
  id: totrans-3164
  prefs: []
  type: TYPE_NORMAL
- en: 17.9.1\. TOPICS
  id: totrans-3165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 2.44 has bullet points for the following topics in computer science.
  id: totrans-3166
  prefs: []
  type: TYPE_NORMAL
- en: Representing Data using Bits
  id: totrans-3167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding (split into 3 sub topics) - Compression - Error Control Coding - Encryption
  id: totrans-3168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Human Computer Interaction (different to 1.44)
  id: totrans-3169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these topics has a chapter in the Computer Science Field Guide, which
    this assessment guide is based on.
  id: totrans-3170
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple assessment guides for representing data and the encoding
    topics, of which students need to do a subset. The following explanations outline
    what students should cover.
  id: totrans-3171
  prefs: []
  type: TYPE_NORMAL
- en: Note that the topics can be covered independently, although using a common context
    for all or most of them (such as considering an mp3 player or photo display that
    represents data using bits, uses encoding and has an interface that can be evaluated)
    can make personalisation easier.
  id: totrans-3172
  prefs: []
  type: TYPE_NORMAL
- en: 17.9.1.1\. REPRESENTING DATA USING BITS
  id: totrans-3173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Students should choose at least **two** data types and cover the “ways in which
    different types of data can be represented using bits” in order to get achieved,
    and they should choose at least two different representations for **each** of
    their chosen data types for the merit level. (While two representations of two
    types is sufficient to meet the exact requirements of the standard, it needn’t
    take a lot of space to go a little beyond this, and this can be more convincing
    for showing student understanding compared with doing the bare minimum.) The following
    table shows common types of data that students could choose (they should choose
    two rows from the table to meet the achieved requirement). For merit they should
    should choose an alternative representation with a different number of bits; examples
    are shown in the “Merit” column.
  id: totrans-3174
  prefs: []
  type: TYPE_NORMAL
- en: Data Type | Achieved | Merit |
  id: totrans-3175
  prefs: []
  type: TYPE_NORMAL
- en: '| sliderBinary Numbers (Whole numbers)slider | sliderPositive numbersslider
    | sliderNegative numbers (simple sign bit) or Floating pointslider or Twos complement
    |'
  id: totrans-3176
  prefs: []
  type: TYPE_TB
- en: '| sliderCharacters/ Textslider | sliderASCIIslider | sliderUnicodeslider |'
  id: totrans-3177
  prefs: []
  type: TYPE_TB
- en: '| sliderImages/ Coloursslider | slider24 bit colourslider | sliderColour with
    fewer bitsslider |'
  id: totrans-3178
  prefs: []
  type: TYPE_TB
- en: '| sliderSoundslider | WAV file representation (16 bit, 44KHz) | Higher or lower
    quality sound (24 bit, 8 bit) and/or different sample rates |'
  id: totrans-3179
  prefs: []
  type: TYPE_TB
- en: Note that data types and representations currently covered in the field guide
    are in italics. Binary numbers is a prerequisite for colours, and are recommended
    for all students. Students who struggle with binary numbers should just aim to
    represent a few numbers in binary (e.g. their age, birthday, etc) and then move
    onto representing text.
  id: totrans-3180
  prefs: []
  type: TYPE_NORMAL
- en: In general, we recommend choosing binary numbers for all projects.
  id: totrans-3181
  prefs: []
  type: TYPE_NORMAL
- en: If students are using a common device as an example, chances are they won’t
    be able to find out how it represents data, but they could say how they would
    represent the data if they had to write the program that is running on the device
    e.g. how they might store the name of a song, a date, the length of a file, the
    number of tracks etc. These will typically have minimum and maximum values that
    will dictate the number of bits needed to store them.
  id: totrans-3182
  prefs: []
  type: TYPE_NORMAL
- en: This topic does not have excellence requirements.
  id: totrans-3183
  prefs: []
  type: TYPE_NORMAL
- en: 17.9.1.2\. ENCODING
  id: totrans-3184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the standard, students need to describe each of the three encoding topics
    in order to get achieved, and do a more in-depth project on one in order to get
    merit or excellence.
  id: totrans-3185
  prefs: []
  type: TYPE_NORMAL
- en: Students should choose do projects that cover **one** of the following selections
    (i.e. just the shaded entries).
  id: totrans-3186
  prefs: []
  type: TYPE_NORMAL
- en: '| **Compression** | **Error Control Coding** | **Encryption** |'
  id: totrans-3187
  prefs: []
  type: TYPE_TB
- en: '| Achieved | Achieved | Achieved |'
  id: totrans-3188
  prefs: []
  type: TYPE_TB
- en: '| Merit | Merit | Merit |'
  id: totrans-3189
  prefs: []
  type: TYPE_TB
- en: '| Excellence | Excellence | Excellence |'
  id: totrans-3190
  prefs: []
  type: TYPE_TB
- en: OR
  id: totrans-3191
  prefs: []
  type: TYPE_NORMAL
- en: '| **Compression** | **Error Control Coding** | **Encryption** |'
  id: totrans-3192
  prefs: []
  type: TYPE_TB
- en: '| Achieved | Achieved | Achieved |'
  id: totrans-3193
  prefs: []
  type: TYPE_TB
- en: '| Merit | Merit | Merit |'
  id: totrans-3194
  prefs: []
  type: TYPE_TB
- en: '| Excellence | Excellence | Excellence |'
  id: totrans-3195
  prefs: []
  type: TYPE_TB
- en: OR
  id: totrans-3196
  prefs: []
  type: TYPE_NORMAL
- en: '| **Compression** | **Error Control Coding** | **Encryption** |'
  id: totrans-3197
  prefs: []
  type: TYPE_TB
- en: '| Achieved | Achieved | Achieved |'
  id: totrans-3198
  prefs: []
  type: TYPE_TB
- en: '| Merit | Merit | Merit |'
  id: totrans-3199
  prefs: []
  type: TYPE_TB
- en: '| Excellence | Excellence | Excellence |'
  id: totrans-3200
  prefs: []
  type: TYPE_TB
- en: Note that some assessment guides provide projects that cover only achieved,
    and others go to excellence. For topics that students are only covering to achieved,
    they can either follow an achieved guide, or the achieved component of an excellence
    guide.
  id: totrans-3201
  prefs: []
  type: TYPE_NORMAL
- en: At the excellence level students are required to evaluate “a widely used system
    for compression coding, error control coding, or encryption”. The guides discuss
    some widely used systems, but the thing to note is that only *one* system need
    be considered (e.g. JPEG is a widely used compression system, so evaluating JPEG
    would be sufficient; an alternative would be checksums used in bar codes). The
    evaluation would need to involve a comparison with *not* using the system, so
    for JPEG it might be with a RAW or BMP file; for bar codes, it would be to consider
    what would be different if a check digit isn’t used.
  id: totrans-3202
  prefs: []
  type: TYPE_NORMAL
- en: One issue to be aware of is that the data representation section includes reducing
    the number of bits (the “bit depth”) for images and sound to reduce the space
    that they take. This overlaps with the idea of compression, but is should *not* be
    used for the compression part of the standards, as it’s a very crude way to reduce
    file size, but not generally regarded as a compression method that takes advantage
    of the content of a file to make it smaller. For example, students could use examples
    of images with 16-bit and 24 colour to illustrate two representations of a type
    of data for data representation, but they should use an image compression method
    like JPEG, GIF and PNG to illustrate compressing image files.
  id: totrans-3203
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is that hexadecimal is not a good example for students to use
    as a different representation of data, as it is simply a shorthand for binary.
    Writing a number as 01111010 (binary) or 7A (hexadecimal) represents exactly the
    same bits stored on a computer with exactly the same meaning; the latter is easier
    for humans to read and write, but both are 8-bit representations that have the
    same range of values. It is a useful shorthand, but shouldn’t be used as a second
    representation for a type of data, or as a different type of data.
  id: totrans-3204
  prefs: []
  type: TYPE_NORMAL
- en: 17.9.1.3\. HUMAN COMPUTER INTERACTION
  id: totrans-3205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Human Computer Interaction is straightforward, and we provide one 2.44 guide
    for it. Note that the requirements for 2.44 HCI are different to 1.44 HCI.
  id: totrans-3206
  prefs: []
  type: TYPE_NORMAL
- en: 17.9.2\. ORDER OF TOPICS
  id: totrans-3207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The three topics can be completed in any order, although encoding is best covered
    after representing data.
  id: totrans-3208
  prefs: []
  type: TYPE_NORMAL
- en: It may be a good idea to cover Human Computer Interaction (HCI) first, as students
    should already have some familiarity with it if they did 1.44, and it can help
    if they are able to start work on it early, then work on the other topics, and
    come back to HCI once they’ve had a while to reflect on the issues.
  id: totrans-3209
  prefs: []
  type: TYPE_NORMAL
- en: 17.9.3\. PERSONALISATION AND STUDENT VOICE
  id: totrans-3210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important that students use personalised examples to base their explanations
    around, and that the explanations are in their own words, and based on their example
    (rather than being a paraphrase from wikipedia, for example).
  id: totrans-3211
  prefs: []
  type: TYPE_NORMAL
- en: Personalised means that the student’s example is different to their classmates.
    For example, they may represent their age or name using bits, carry out the parity
    trick (error control coding) with a friend choosing random combinations and take
    photos, and they may carry out their own usability exploration of a device they
    chose, and report on it in their own words.
  id: totrans-3212
  prefs: []
  type: TYPE_NORMAL
- en: 17.9.4\. REPORT LENGTH
  id: totrans-3213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to note that the page limit given by NZQA is not a target. The
    markers prefer reports that are short and to the point.
  id: totrans-3214
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible breakdown is:'
  id: totrans-3215
  prefs: []
  type: TYPE_NORMAL
- en: 'Representing Data using Bits: 2 pages (1 per data type)'
  id: totrans-3216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Encoding: 5 pages (1 for each achieved project and 3 for the achieved/ merit/
    excellence project)'
  id: totrans-3217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Human Computer Interaction: 3 pages'
  id: totrans-3218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The assessment guides provide further guidance on how to stay within these limits.
    With 2.44, it is particularly important to try and keep each individual project
    in the report within the recommended limit, as space is tighter than for 1.44
    and 3.44.
  id: totrans-3219
  prefs: []
  type: TYPE_NORMAL
- en: Some hints to reduce total length
  id: totrans-3220
  prefs: []
  type: TYPE_NORMAL
- en: Only include what is relevant to the standard. While covering additional material
    in class is valuable for learning, additional content that doesn’t demonstrate
    understanding of the topics in the standard is only a distraction in the report.
  id: totrans-3221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resize screenshots and photos so that they are still readable, although don’t
    take up unnecessary space. Use cropping to show the relevant parts of the image.
  id: totrans-3222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t leave unnecessary spaces in the report. It both looks untidy and makes
    it more difficult for the marker to find what they are looking for.
  id: totrans-3223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.10\. REPRESENTING DATA USING BITS (BINARY NUMBERS) (2.44)
  id: totrans-3224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting Representing Data using Bits in digital
    technologies achievement standard 1.44 (AS91074). You will need to cover **two**different
    types of data to meet the requirements of the standard (each assessment guide
    only covers one).
  id: totrans-3225
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done one more
    project for representing data using bits and projects covering the topics of *Encoding*and *Human
    Computer Interaction*, and included these in your report.
  id: totrans-3226
  prefs: []
  type: TYPE_NORMAL
- en: 17.10.1\. OVERVIEW
  id: totrans-3227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The topic of representing data using bits has the following bullet points in
    achievement standard 1.44, which this guide covers. Note that there is no excellence
    criteria for this topic. This assessment guide only covers one of the two types
    of data required for achieved.
  id: totrans-3228
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: “describing ways in which different types of data can be represented
    using bits”'
  id: totrans-3229
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “comparing and contrasting different ways in which different types
    of data can be represented using bits and discussing the implications”'
  id: totrans-3230
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed reports, you should base your explanations around
    personalised examples.
  id: totrans-3231
  prefs: []
  type: TYPE_NORMAL
- en: 17.10.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  id: totrans-3232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  id: totrans-3233
  prefs: []
  type: TYPE_NORMAL
- en: Read all of these sections, as they give the necessary introduction of the topic
  id: totrans-3234
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 - What’s the Big Picture? (General information about bits)
  id: totrans-3235
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 - Representing numbers with bits (Relevant to the achieved criteria)
  id: totrans-3236
  prefs: []
  type: TYPE_NORMAL
- en: 5.8 - Computers representing numbers in practice (Relevant to the merit criteria)
  id: totrans-3237
  prefs: []
  type: TYPE_NORMAL
- en: 17.10.3\. PROJECT
  id: totrans-3238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 17.10.3.1\. WRITING YOUR REPORT
  id: totrans-3239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved**'
  id: totrans-3240
  prefs: []
  type: TYPE_NORMAL
- en: 'For Achieved, you need to demonstrate that you know how to convert decimal
    numbers (convention notation with 10 digits) into binary numbers. You can use
    a tool to help you do this, although you need to be able to describe how the answer
    was derived. You should show the binary representation for at least three numbers.
    Some ideas of numbers you could use are:'
  id: totrans-3241
  prefs: []
  type: TYPE_NORMAL
- en: Your street number
  id: totrans-3242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The day and month of your date of birth
  id: totrans-3243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your age
  id: totrans-3244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The age(s) of your sibling(s)
  id: totrans-3245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some more challenging ones if you are keen:'
  id: totrans-3246
  prefs: []
  type: TYPE_NORMAL
- en: Your year of birth (e.g. 2002)
  id: totrans-3247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The population of a city or country
  id: totrans-3248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distance between some cities (e.g. airline flight distances)
  id: totrans-3249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Briefly describe how a number is converted to binary.
  id: totrans-3250
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**'
  id: totrans-3251
  prefs: []
  type: TYPE_NORMAL
- en: The material about representing numbers in practice may be challenging, so don’t
    worry if you need to read over it a couple of times!
  id: totrans-3252
  prefs: []
  type: TYPE_NORMAL
- en: Think of a few different examples for different sized integers (both signed
    and unsigned ones) of a piece of data that you could store in that sized integer.
    For example, the age of a person could be stored in an 8 bit unsigned integer
    (people can’t be a negative age!), and the number of students in your school could
    be stored in an 8 bit or 16 bit integer, depending on how big your school is.
    Try to include examples of signed and unsigned integers, and of at least two different
    integer sizes. This means you will need at least three examples.
  id: totrans-3253
  prefs: []
  type: TYPE_NORMAL
- en: The field guide gives some other examples (e.g. programming languages and IP
    addresses) that are affected by the number of bits used to represent a number.
  id: totrans-3254
  prefs: []
  type: TYPE_NORMAL
- en: What are the consequences of making a wrong decision about how many bits to
    use to represent a number? In practice, how much of an issue is each of the consequences?
    Relate your answer to your examples above.
  id: totrans-3255
  prefs: []
  type: TYPE_NORMAL
- en: 'Optional extra: Give an example of a situation where a 32 bit integer would
    not be suitable. What do we do in practice to address this problem?'
  id: totrans-3256
  prefs: []
  type: TYPE_NORMAL
- en: 17.10.4\. HINTS FOR SUCCESS
  id: totrans-3257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that this part of the standard only goes up to the merit level. While
    you need to do some evaluation for merit, you should be mindful that the other
    topics go up to the excellence level, so they should make up the bulk of your
    in-depth discussions.
  id: totrans-3258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember to do a second project on a different type of data for the merit level.
  id: totrans-3259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful to use personalised examples (i.e. represent different numbers to
    your classmates). It may be a good idea to pick a larger number (e.g. in the millions)
    to minimise the chance of it being the same as others.
  id: totrans-3260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.10.5\. RECOMMENDED NUMBER OF PAGES
  id: totrans-3261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We recommend that this project does not take up more than 1 page. Examples should
    be small, and discussions should be short and to the point, keeping in mind that
    there is no excellence criteria for this topic.
  id: totrans-3262
  prefs: []
  type: TYPE_NORMAL
- en: 17.11\. REPRESENTING DATA USING BITS (CHARACTERS/TEXT) (2.44)
  id: totrans-3263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting Representing Data using Bits in digital
    technologies achievement standard 1.44 (AS91074). You will need to cover **two**different
    types of data to meet the requirements of the standard (each assessment guide
    only covers one). See the introduction for the 2.44 guides for more details on
    choosing topics; this guide covers the “characters/text” type of data.
  id: totrans-3264
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done one more
    project for representing data using bits and projects covering the topics of *Encoding*and *Human
    Computer Interaction*, and included these in your report.
  id: totrans-3265
  prefs: []
  type: TYPE_NORMAL
- en: 17.11.1\. OVERVIEW
  id: totrans-3266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The topic of representing data using bits has the following bullet points in
    achievement standard 1.44, which this guide covers. Note that there is no excellence
    criteria for this topic. This assessment guide only covers one of the two types
    of data required for achieved.
  id: totrans-3267
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: “describing ways in which different types of data can be represented
    using bits”'
  id: totrans-3268
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “comparing and contrasting different ways in which different types
    of data can be represented using bits and discussing the implications”'
  id: totrans-3269
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed reports, you should base your explanations around
    personalised examples.
  id: totrans-3270
  prefs: []
  type: TYPE_NORMAL
- en: 17.11.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  id: totrans-3271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  id: totrans-3272
  prefs: []
  type: TYPE_NORMAL
- en: Read all of these sections, as they give the necessary introduction of the topic
  id: totrans-3273
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 - What’s the Big Picture? (General information about bits)
  id: totrans-3274
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 - Getting Started
  id: totrans-3275
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 - Representing text with bits
  id: totrans-3276
  prefs: []
  type: TYPE_NORMAL
- en: 5.7 - General representations of text (Required for Merit)
  id: totrans-3277
  prefs: []
  type: TYPE_NORMAL
- en: 17.11.3\. PROJECT
  id: totrans-3278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 17.11.3.1\. WRITING YOUR REPORT
  id: totrans-3279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved**'
  id: totrans-3280
  prefs: []
  type: TYPE_NORMAL
- en: For Achieved, you need to demonstrate that you know how to convert characters
    into binary numbers. ASCII, which uses 8-bit codes, is a simple system to explore
    for this. You should show the binary representation for a few characters; the
    easiest way to do this is to show the ASCII code for your name.
  id: totrans-3281
  prefs: []
  type: TYPE_NORMAL
- en: Briefly describe the relationship between characters and their ASCII code. A
    few sentences is fine.
  id: totrans-3282
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**'
  id: totrans-3283
  prefs: []
  type: TYPE_NORMAL
- en: The most common longer code for characters is Unicode, which actually covers
    multiple lengths of representations. You could show a conversion to Unicode for
    the characters in your name, but to contrast the power of Unicode, it’s ideal
    to show the representation of some characters that wouldn’t be possible in ASCII
    e.g. choose a Chinese (Simplified Chinese) or Japanese (Kanji) name for a city
    and explain how the characters would be represented. Discuss why more bits are
    needed for these character sets.
  id: totrans-3284
  prefs: []
  type: TYPE_NORMAL
- en: Use your example to discuss the tradeoffs that are made by using a 16-bit character
    representation, and to explain the limitations of the ASCII code.
  id: totrans-3285
  prefs: []
  type: TYPE_NORMAL
- en: You could also use the 5-bit Baudot code to contrast different representations
    of text, and again explain the tradeoffs between this and either ASCII or Unicode.
  id: totrans-3286
  prefs: []
  type: TYPE_NORMAL
- en: 17.11.4\. HINTS FOR SUCCESS
  id: totrans-3287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that this part of the standard only goes up to the merit level. While
    you need to do some evaluation for merit, you should be mindful that the other
    topics go up to the excellence level, so they should make up the bulk of your
    in-depth discussions.
  id: totrans-3288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember to do a second project on a different type of data for the merit level.
  id: totrans-3289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful to use personalised examples (i.e. represent words that are personal
    to you such as your name or street name).
  id: totrans-3290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.11.5\. RECOMMENDED NUMBER OF PAGES
  id: totrans-3291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We recommend that this project does not take up more than 1 page. Examples should
    be small, and discussions should be short and to the point, keeping in mind that
    there is no excellence criteria for this topic.
  id: totrans-3292
  prefs: []
  type: TYPE_NORMAL
- en: 17.12\. REPRESENTING DATA USING BITS (IMAGES/COLOUR) (2.44)
  id: totrans-3293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting Representing Data using Bits in digital
    technologies achievement standard 1.44 (AS91074). You will need to cover **two**different
    types of data to meet the requirements of the standard (each assessment guide
    only covers one). See the introduction for the 2.44 guides for more details on
    choosing topics; this guide covers the “images/colour” type of data.
  id: totrans-3294
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done one more
    project for representing data using bits and projects covering the topics of *Encoding*and *Human
    Computer Interaction*, and included these in your report.
  id: totrans-3295
  prefs: []
  type: TYPE_NORMAL
- en: 17.12.1\. OVERVIEW
  id: totrans-3296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The topic of representing data using bits has the following bullet points in
    achievement standard 1.44, which this guide covers. Note that there is no excellence
    criteria for this topic. This assessment guide only covers one of the two types
    of data required for achieved.
  id: totrans-3297
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: “describing ways in which different types of data'
  id: totrans-3298
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “comparing and contrasting different ways in which different types
    of data can be represented using bits and discussing the implications”'
  id: totrans-3299
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed reports, you should base your explanations around
    personalised examples.
  id: totrans-3300
  prefs: []
  type: TYPE_NORMAL
- en: 17.12.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  id: totrans-3301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  id: totrans-3302
  prefs: []
  type: TYPE_NORMAL
- en: Read all of these sections, as they give the necessary introduction of the topic
  id: totrans-3303
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 - What’s the Big Picture? (General information about bits)
  id: totrans-3304
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 - Representing Numbers With Bits (Relevant to the achieved criteria)
  id: totrans-3305
  prefs: []
  type: TYPE_NORMAL
- en: 5.6 - Representing Images With Bits (Relevant to the achieved criteria)
  id: totrans-3306
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.1 - Representing High Quality Images Using Bits (Relevant to the achieved
    criteria)
  id: totrans-3307
  prefs: []
  type: TYPE_NORMAL
- en: 5.6.3 - Representing colours using fewer bits (Relevant to the merit criteria)
  id: totrans-3308
  prefs: []
  type: TYPE_NORMAL
- en: 17.12.3\. PROJECT
  id: totrans-3309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 17.12.3.1\. WRITING YOUR REPORT
  id: totrans-3310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved**'
  id: totrans-3311
  prefs: []
  type: TYPE_NORMAL
- en: Using the colour matcher (note that it is at the start of section 5.6.3), choose
    a colour you like by clicking on the image. Try and match up the 24 bit colour
    hexagon to be the same colour as your selected colour. Don’t worry about the 8
    bit hexagon yet. If you have trouble, the interactive will help you.
  id: totrans-3312
  prefs: []
  type: TYPE_NORMAL
- en: Once you have matched up the colour, make a screenshot of the colour matcher
    which you can include in your report.
  id: totrans-3313
  prefs: []
  type: TYPE_NORMAL
- en: You should now have 3 numbers; one for each of red, green, and blue. Convert
    each of these numbers into 8 bit binary numbers. These 3 numbers put together
    make up the 24 bit number that represents your colour. Show your working in your
    report, and explain how you arrived at your answer.
  id: totrans-3314
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**'
  id: totrans-3315
  prefs: []
  type: TYPE_NORMAL
- en: For merit, you need to show what happens when fewer bits are used to represent
    each colour in an image. There are several ways you can go about this; we recommend
    exploring the various interactives on colour representation and experimenting
    with them.
  id: totrans-3316
  prefs: []
  type: TYPE_NORMAL
- en: Include at least one screenshot of an interactive and your personalised example
    which shows what happens when fewer bits are used to represent the colours in
    the image.
  id: totrans-3317
  prefs: []
  type: TYPE_NORMAL
- en: What is the benefit of using fewer bits? What happens to the images when fewer
    bits are used? Are there certain kinds of images where it matters a lot? Are there
    other cases where the benefits of fewer bits outweigh the downsides?
  id: totrans-3318
  prefs: []
  type: TYPE_NORMAL
- en: 17.12.4\. HINTS FOR SUCCESS
  id: totrans-3319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that this part of the standard only goes up to the merit level. While
    you need to do some evaluation for merit, you should be mindful that the other
    topics go up to the excellence level, so they should make up the bulk of your
    in depth evaluations.
  id: totrans-3320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember to do a second project on a different type of data
  id: totrans-3321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may need to reread the section on representing numbers using bits if you
    cannot remember how to convert the numbers into binary. Additionally you could
    also look at the worked example for the large block of purple in the previous
    section.
  id: totrans-3322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose a colour that has at least two of the three colour components somewhere
    in the middle of the slider. Examples such as 0, 255, and 1 are not helpful for
    showing your knowledge of binary representation.
  id: totrans-3323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure the screenshots are large enough to be seen, but no larger!
  id: totrans-3324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.12.5\. RECOMMENDED NUMBER OF PAGES
  id: totrans-3325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We recommend that this project does not take up more than 1 page. Examples should
    be small, and discussions should be short and to the point, keeping in mind that
    there is no excellence criteria for this topic.
  id: totrans-3326
  prefs: []
  type: TYPE_NORMAL
- en: 17.13\. COMPRESSION (2.44) - RUN LENGTH ENCODING
  id: totrans-3327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting compression (one of the three encoding
    subtopics) in digital technologies achievement standard 2.44 (AS91371).
  id: totrans-3328
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you only need to do one of the three encoding topics (Compression,
    Encryption, and Error Control Coding) to the excellence level. The other two only
    need to be done to the achieved level. This guide is suitable for both doing compression
    to the excellence level, but can also be used for the achieved level for compression.
  id: totrans-3329
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done projects
    covering the topics of encryption and error control coding to at least the achieved
    level, and projects covering the topics of representing data using bits and human
    computer interaction, and include these in your report.
  id: totrans-3330
  prefs: []
  type: TYPE_NORMAL
- en: 17.13.1\. OVERVIEW
  id: totrans-3331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encoding has the following bullet points in achievement standard 2.44 which
    this guide covers.
  id: totrans-3332
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: “describing the concept of encoding information using compression
    coding, error control coding, and encryption; and typical uses of encoded information”'
  id: totrans-3333
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “discussing how a widely used technology is enabled by one or more
    of compression coding, error control coding, and encryption”'
  id: totrans-3334
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**: “evaluating a widely used system for compression coding, error
    control coding, or encryption”'
  id: totrans-3335
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed reports, you should base your explanations around
    personalised examples.
  id: totrans-3336
  prefs: []
  type: TYPE_NORMAL
- en: 17.13.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  id: totrans-3337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  id: totrans-3338
  prefs: []
  type: TYPE_NORMAL
- en: Read all of these sections, as they give the necessary introduction of the topics
  id: totrans-3339
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 - What’s the Big Picture?
  id: totrans-3340
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 - Run Length Encoding
  id: totrans-3341
  prefs: []
  type: TYPE_NORMAL
- en: 17.13.3\. PROJECT
  id: totrans-3342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the achieved criteria you will show how run length encoding works to compress
    a simple image. For the merit and excellence criteria you will investigate how
    and why run length encoding is used by fax machines, and then evaluate how effective
    it is for this purpose. *If you have chosen to focus on error control coding or
    encryption for merit and excellence, then you only need to meet the achieved criteria
    for this project.*
  id: totrans-3343
  prefs: []
  type: TYPE_NORMAL
- en: 17.13.3.1\. WRITING YOUR REPORT
  id: totrans-3344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved**'
  id: totrans-3345
  prefs: []
  type: TYPE_NORMAL
- en: Make a grid of squares (any size is fine, but it should be at least 6x6) and
    draw a picture by filling some of the squares with black and leave others white.
    Underneath (or alongside each row), show how a computer could represent your image
    using run length encoding. You should not worry about how it is represented at
    the bit level. It is fine to just use normal numbers which are comma separated
  id: totrans-3346
  prefs: []
  type: TYPE_NORMAL
- en: Count how many characters are needed to represent your image in its original
    form (i.e. how many squares does it contain?). Count how many characters were
    used in your run length encoding representation. Don’t forget to include the commas!
    How well did run length encoding compress your image?
  id: totrans-3347
  prefs: []
  type: TYPE_NORMAL
- en: Explain why you would want to use run length encoding on an image. Think about
    a more typical image, such as a scan of a page of writing - what sort of runs
    of black and white pixels will that have? What is the purpose of compression?
  id: totrans-3348
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit/ Excellence**'
  id: totrans-3349
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the field guide, fax machines use run length encoding. What
    advantages does this provide to fax machines sending and receiving faxes?
  id: totrans-3350
  prefs: []
  type: TYPE_NORMAL
- en: Is run length encoding guaranteed to always make the amount of data needed to
    represent the image smaller? Try and come up with an example (to include in your
    report) where the amount of space required to store your image with run length
    encoding is more than the original representation. What about an example where
    it is a very small amount of data? You can use the following interactive (written
    by Hannah Taylor, a digital technologies teacher) to help you experiment and to
    quickly generate examples.
  id: totrans-3351
  prefs: []
  type: TYPE_NORMAL
- en: '[http://taylormade.io/run-length-encoding.html](http://taylormade.io/run-length-encoding.html)'
  id: totrans-3352
  prefs: []
  type: TYPE_NORMAL
- en: You should have found that in some cases the compression is really good, and
    in others it makes things worse! You might remember from the book that it is impossible
    to design a lossless text compression method that makes every possible input smaller.
    What matters though is how good the compression is for its intended application.
    What would you expect a typical fax message to look like? (You might like to include
    an example, although shrink the image down so that it is less than ¼ of the page
    tall.)
  id: totrans-3353
  prefs: []
  type: TYPE_NORMAL
- en: 17.13.4\. HINTS FOR SUCCESS
  id: totrans-3354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you make your image for the achieved level, make it a real image rather
    than a grid containing random black and white squares.
  id: totrans-3355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put compression in its own section (your report should have suitable headings
    and subheadings for each topic to make it clear for the marker) and ensure that
    you briefly introduce the topic. It is important that your report clearly demonstrates
    that you know the difference between encryption, error control coding, and compression,
    and what their different purposes are.
  id: totrans-3356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you did compression only to the achieved level, half to one page should be
    enough. If you did merit and excellence, a couple of pages should be enough (shrink
    down the examples as much as is reasonable, particularly if you included a lot
    of them)
  id: totrans-3357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While you could potentially go into the details of how the computer represents
    the compressed image at the bit level, this is not necessary. The purpose of the
    encoding topic in 2.44 is for you to investigate the general ideas of how encoding
    works rather than the precise details of the representation with bits (simpler
    representations with bits are already covered in the first bullet point of the
    standard).
  id: totrans-3358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.14\. ENCRYPTION (2.44) - RSA CRYPTOSYSTEM
  id: totrans-3359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting encryption (one of the three encoding
    subtopics) in digital technologies achievement standard 2.44 (AS91371).
  id: totrans-3360
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you only need to do one of the three encoding topics (Compression,
    Encryption, or Error Control Coding) to the excellence level. The other two only
    need to be done to the achieved level. This guide is suitable for both doing encryption
    to the excellence level, but can also be used for the achieved level for encryption.
  id: totrans-3361
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done projects
    covering the topics of *error control coding* and *compression* to at least the
    achieved level, and projects covering the topics of *representing data using bits* and *human
    computer interaction*, and included these in your report.
  id: totrans-3362
  prefs: []
  type: TYPE_NORMAL
- en: 17.14.1\. OVERVIEW
  id: totrans-3363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encoding has the following bullet points in achievement standard 2.44 which
    this guide covers.
  id: totrans-3364
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: “describing the concept of encoding information using compression
    coding, error control coding, and encryption; and typical uses of encoded information”'
  id: totrans-3365
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “discussing how a widely used technology is enabled by one or more
    of compression coding, error control coding, and encryption”'
  id: totrans-3366
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**: “evaluating a widely used system for compression coding, error
    control coding, or encryption”'
  id: totrans-3367
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed reports, you should base your explanations around
    personalised examples.
  id: totrans-3368
  prefs: []
  type: TYPE_NORMAL
- en: 17.14.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  id: totrans-3369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the activities in the following sections of
    the CS Field Guide in order to prepare yourself for the assessed project.
  id: totrans-3370
  prefs: []
  type: TYPE_NORMAL
- en: Read all of these sections, as they give the necessary introduction of the topics
  id: totrans-3371
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 - What’s the Big Picture?
  id: totrans-3372
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 - Substitution Ciphers
  id: totrans-3373
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 - Problems with Substitution Ciphers (Needed only for Merit/ Excellence)
  id: totrans-3374
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 - Public Key Cryptosystems (Needed only for Merit/ Excellence)
  id: totrans-3375
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 - The RSA Cryptosystem
  id: totrans-3376
  prefs: []
  type: TYPE_NORMAL
- en: Note that for this project, reading the field guide material thoroughly and
    doing all the activities is particularly important in order to understand and
    do a good project at the merit/ excellence level.
  id: totrans-3377
  prefs: []
  type: TYPE_NORMAL
- en: 17.14.3\. PROJECT
  id: totrans-3378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the achieved criteria you will show an example of the Caeser cipher and
    describe how by using a *key*, *plaintext* can be converted to *ciphertext*, and
    then the*ciphertext* can be converted back to *plaintext* by anybody who has the
    key.
  id: totrans-3379
  prefs: []
  type: TYPE_NORMAL
- en: For the merit and excellence criteria, you will show an example of the RSA cryptosystem,
    describing how its differences to Caesar cipher allow it to be used in practice,
    and then you will show the kinds of attacks and limitations that make the Caesar
    cipher unsuitable in practice, and discuss whether or not similar limitations
    exist in RSA.
  id: totrans-3380
  prefs: []
  type: TYPE_NORMAL
- en: 17.14.3.1\. WRITING YOUR REPORT
  id: totrans-3381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved**'
  id: totrans-3382
  prefs: []
  type: TYPE_NORMAL
- en: Do the following to make an example to include in your report.
  id: totrans-3383
  prefs: []
  type: TYPE_NORMAL
- en: Write a short sentence that you could send to a classmate (must be appropriate
    to include in your report). This message is your *plain text*.
  id: totrans-3384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a number between 1 and 25 that will be your encryption key.
  id: totrans-3385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a conversion table that shows how each letter in your *plain text* should
    be changed using your key.
  id: totrans-3386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Encrypt* your *plain text* message using your chosen *key* in order to obtain
    your *ciphertext*.'
  id: totrans-3387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include your plain text, key, conversion table, and ciphertext in your report.
    Be sure to clearly label each of these four parts of your example using the correct
    terminology. What will your classmate need to decrypt the message?
  id: totrans-3388
  prefs: []
  type: TYPE_NORMAL
- en: Why is encryption so important in computer science? (assuming the cipher is
    one that is a lot more difficult to break than Caesar cipher!)
  id: totrans-3389
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit/ Excellence**'
  id: totrans-3390
  prefs: []
  type: TYPE_NORMAL
- en: Generate a pair of RSA keys using the field guide interactive, and encrypt a
    message with the public key using the other field guide interactive. Then, show
    how it can be decrypted with the private key. Include the keys, plaintext, ciphertext,
    and a brief explanation of how public key cryptosystems such as RSA are used,
    and why they are so useful.
  id: totrans-3391
  prefs: []
  type: TYPE_NORMAL
- en: What kinds of systems in the world depend on RSA being able to resist attacks?
    What kinds of things would happen if somebody came up with a good way of breaking
    RSA?
  id: totrans-3392
  prefs: []
  type: TYPE_NORMAL
- en: In order to do a good evaluation of RSA cryptosystems, you will need to show
    why particular attacks will not work, and how some potential issues are addressed.
    Some of this will involve comparing to Caesar cipher. Show personalised examples
    of the following (come up with your own messages, don’t just copy the field guide
    ones!) Remember that the interactives in the field guide will help you to generate
    personalised examples.
  id: totrans-3393
  prefs: []
  type: TYPE_NORMAL
- en: Caesar cipher vs RSA on messages that are very similar (show an example for
    both algorithms so you can compare them)
  id: totrans-3394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of random padding in order to ensure that even if the same plaintext
    is encrypted more than once with the same public key, the ciphertext for each
    occurrence is different.
  id: totrans-3395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How long a typical sized RSA key might take to break (make sensible assumptions
    about the number of bits in the key, the number of computers able to work on breaking
    it, computer speed, etc). Make sure you discuss the implications, and how much
    (or little) slightly modifying your assumptions would change the overall conclusion.
  id: totrans-3396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each of your examples, explain why the issue is very important to address
    (what kinds of attacks could be carried out if the issue had been overlooked?)
  id: totrans-3397
  prefs: []
  type: TYPE_NORMAL
- en: RSA isn’t perfect, and there are a few ways to potentially break it which you
    should have read about in the field guide. What is at least one of these problems?
    How is it addressed? Is this solution guaranteed to always work?
  id: totrans-3398
  prefs: []
  type: TYPE_NORMAL
- en: 'Discuss what you have found from this evaluation: is RSA a good cryptosystem?'
  id: totrans-3399
  prefs: []
  type: TYPE_NORMAL
- en: 17.14.4\. HINTS FOR SUCCESS
  id: totrans-3400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Display your examples using the standard font size.
  id: totrans-3401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put encryption in its own section (your report should have suitable headings
    and subheadings for each topic to make it clear for the marker) and ensure that
    you briefly introduce the topic. It is important that your report clearly demonstrates
    that you know the difference between encryption, error control coding, and compression,
    and what their different purposes are.
  id: totrans-3402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should be able to discuss this material, with examples, in about 2 or 3
    pages of your report.
  id: totrans-3403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.15\. ERROR CONTROL CODING (2.44) - CHECK SUMS
  id: totrans-3404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting error control coding (one of the three
    encoding subtopics) in digital technologies achievement standard 2.44 (AS91371).
  id: totrans-3405
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you only need to do one of the three encoding topics (Compression,
    Encryption, or Error Control Coding) to the excellence level. The other two only
    need to be done to the achieved level. This guide is suitable for both doing error
    control coding to the excellence level, but can also be used for the achieved
    level for error control coding.
  id: totrans-3406
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done projects
    covering the topics of *encryption* and *compression* to at least the achieved
    level, and projects covering the topics of *representing data using bits* and *human
    computer interaction*, and included these in your report.
  id: totrans-3407
  prefs: []
  type: TYPE_NORMAL
- en: 17.15.1\. OVERVIEW
  id: totrans-3408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encoding has the following bullet points in achievement standard 2.44 which
    this guide covers.
  id: totrans-3409
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: “describing the concept of encoding information using compression
    coding, error control coding, and encryption; and typical uses of encoded information”'
  id: totrans-3410
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: “discussing how a widely used technology is enabled by one or more
    of compression coding, error control coding, and encryption”'
  id: totrans-3411
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**: “evaluating a widely used system for compression coding, error
    control coding, or encryption”'
  id: totrans-3412
  prefs: []
  type: TYPE_NORMAL
- en: As with all externally assessed reports, you should base your explanations around
    personalised examples.
  id: totrans-3413
  prefs: []
  type: TYPE_NORMAL
- en: 17.15.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  id: totrans-3414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  id: totrans-3415
  prefs: []
  type: TYPE_NORMAL
- en: Read all of these sections, as they give the necessary introduction of the topics
  id: totrans-3416
  prefs: []
  type: TYPE_NORMAL
- en: 9.1 - What’s the Big Picture?
  id: totrans-3417
  prefs: []
  type: TYPE_NORMAL
- en: 9.3 - Check digits on barcodes and other numbers
  id: totrans-3418
  prefs: []
  type: TYPE_NORMAL
- en: 17.15.3\. PROJECT
  id: totrans-3419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the achieved criteria you will show how the barcode on a product you chose
    has a check digit which helps to ensure that when a shop assistant scans or enters
    the number into a computer, that the computer is able to notify them if it was
    entered incorrectly. For the merit and excellence criteria, you will explain why
    this is so important, and evaluate how effective it is.
  id: totrans-3420
  prefs: []
  type: TYPE_NORMAL
- en: 17.15.3.1\. WRITING YOUR REPORT
  id: totrans-3421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved**'
  id: totrans-3422
  prefs: []
  type: TYPE_NORMAL
- en: Find some products with barcodes on them, and the checker will tell you whether
    or not it is a correct barcode. Try a few others. Does it ever seem to say a number
    was wrong? Now try change one digit in a barcode. Does it ever still say the barcode
    is correct? Choose one product to take a photo of the barcode, and describe how
    the last digit is a check digit that ensures the number was entered correctly
    (it’s a good idea to include the calculation that was used to calculate the check
    digit’s value). Show that when you enter the number into the barcode and change
    one of the digits, the last digit is no longer correct.
  id: totrans-3423
  prefs: []
  type: TYPE_NORMAL
- en: Explain why you would want to use a check digit on a barcode. What is the purpose
    of error control coding?
  id: totrans-3424
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit/ Excellence**'
  id: totrans-3425
  prefs: []
  type: TYPE_NORMAL
- en: What could be some of the implications of a number being entered incorrectly,
    and this not being detected? What kinds of things could happen to the shop?
  id: totrans-3426
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of what some of the common errors could be if somebody was manually entering
    the number into a computer. What mistakes are easy to make? (clue: missing a digit
    or swapping 2 adjacent digits are common mistakes, however there are others as
    well). Also think about what could cause errors if a scanner was being used to
    read the barcode.'
  id: totrans-3427
  prefs: []
  type: TYPE_NORMAL
- en: Using the barcodes you found earlier, replicate some of the common errors that
    would occur when a person manually enters the number into the computer by entering
    the mistakes into the checker. Try lots of variations of the errors, and see if
    the errors are always detected. Which errors always seem to be detected? Which
    do not? Discuss whether or not the check digits decrease the chances of errors,
    particularly common ones. Do you think that sometimes mistakes do go undetected?
    Remember that really obscure errors (such as getting 3 digits in a row incorrect)
    will probably never occur in practice, and the intention of the check digit is
    to pick up small mistakes.
  id: totrans-3428
  prefs: []
  type: TYPE_NORMAL
- en: Your discussion should include a few examples of common errors you tried replicating
    (use screenshots), and whether or not the check digit was able to detect them.
  id: totrans-3429
  prefs: []
  type: TYPE_NORMAL
- en: 17.15.4\. HINTS FOR SUCCESS
  id: totrans-3430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Put error control coding in its own section (your report should have suitable
    headings and subheadings for each topic to make it clear for the marker) and ensure
    that you briefly introduce the topic. It is important that your report clearly
    demonstrates that you know the difference between encryption, error control coding,
    and compression, and what their different purposes are.
  id: totrans-3431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be sure to shrink down examples so they do not take up too much space. A barcode
    only needs to be big enough for the numbers to be readable; it does not need to
    take up half a page!
  id: totrans-3432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For merit, you should not just paraphrase information. You need to use your
    own thinking to generate some of the answers, as your own experiences should enable
    you to come up with a lot of the answers. As an example, you should already know
    that if you bought something from the shop, and the scanner read the barcode wrong,
    and you were charged twice as much, you would not be happy about it! The implications
    of not having the technology are an important part of the discussion — what would
    happen if these systems weren’t used?
  id: totrans-3433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For excellence, don’t simply discuss whether or not the algorithm is good without
    examples. You *must* have examples so that your work is personalised. Show some
    of the errors and whether or not they generate the correct check digit. If you
    find examples with simple common errors where the error did give the correct check
    digit, this is really good to show.
  id: totrans-3434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should be able to discuss this material, with examples, in about 2 or 3
    pages of your report.
  id: totrans-3435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.16\. ARTIFICIAL INTELLIGENCE (3.44) - TURING TEST
  id: totrans-3436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a guide for students attempting Artificial Intelligence in digital technologies
    achievement standard 3.44\. This guide is not official, although we intend for
    it to be helpful, and welcome any feedback.
  id: totrans-3437
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully cover the standard, you will also need to have done a project
    in one other 3.44 topic. The other project should be in either Software Engineering,
    Complexity and Tractability, Formal Languages, Network Protocols, or Graphics
    and Visual Computing.
  id: totrans-3438
  prefs: []
  type: TYPE_NORMAL
- en: Note that the project in this guide focuses on using the Turing Test to evaluate
    Chatbots. Another guide exists which has a project that instead focusses on the
    actual algorithms and techniques used by Chatbots in an attempt to sound intelligent.
    Either of these are sufficient to cover a “key algorithm or technique” from the
    field of Artificial Intelligence.
  id: totrans-3439
  prefs: []
  type: TYPE_NORMAL
- en: 17.16.1\. OVERVIEW
  id: totrans-3440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to complete a 3.44 project in two different areas of computer
    science. Each project needs to satisfy all bullet points in the standard.
  id: totrans-3441
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: [A1]'
  id: totrans-3442
  prefs: []
  type: TYPE_NORMAL
- en: '**Achieved**: [A2] “describing examples of practical applications of selected
    areas to demonstrate the use of key algorithms and/or techniques from these areas“'
  id: totrans-3443
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: [M1] “explaining how key algorithms or techniques are applied in
    selected areas”'
  id: totrans-3444
  prefs: []
  type: TYPE_NORMAL
- en: '**Merit**: [M2] “explaining examples of practical applications of selected
    areas to demonstrate the use of key algorithms and/or techniques from these areas”'
  id: totrans-3445
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**: [E1] “discussing examples of practical applications of selected
    areas to demonstrate the use of key algorithms and/or techniques from these areas”'
  id: totrans-3446
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**: [E2] “evaluating the effectiveness of algorithms, techniques,
    or applications from selected areas”'
  id: totrans-3447
  prefs: []
  type: TYPE_NORMAL
- en: The terminology in the 3.44 standard can be challenging to understand because
    it applies to six different areas. The following list describes how the terminology
    of the standard maps onto this project.
  id: totrans-3448
  prefs: []
  type: TYPE_NORMAL
- en: '**Selected Area**: Intelligent Systems (Artificial Intelligence)'
  id: totrans-3449
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Problem**: Determining whether or not a computer program is able to have
    a conversation with a human and seem like another human.'
  id: totrans-3450
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithms/ Techniques**: Turing Test'
  id: totrans-3451
  prefs: []
  type: TYPE_NORMAL
- en: '**Practical Application**: Using the Turing Test to evaluate if a chatbot is
    able to have a human-like conversation.'
  id: totrans-3452
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, to satisfy the standard you might do the following:'
  id: totrans-3453
  prefs: []
  type: TYPE_NORMAL
- en: Describe the key problem
  id: totrans-3454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain how the Turing Test can be used to evaluate a chatbot
  id: totrans-3455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain (Describe) how you evaluated a chatbot with the Turing Test, in order
    to demonstrate the use of the Turing Test in Artificial Intelligence.
  id: totrans-3456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss other related applications of the Turing Test
  id: totrans-3457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate how effective the Turing Test is at addressing the key problem
  id: totrans-3458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.16.2\. READING FROM THE COMPUTER SCIENCE FIELD GUIDE
  id: totrans-3459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read and work through the interactives in the following sections
    of the CS Field Guide in order to prepare yourself for the assessed project.
  id: totrans-3460
  prefs: []
  type: TYPE_NORMAL
- en: 10.1 - What’s the Big Picture?
  id: totrans-3461
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 - Chatterbots and the Turing Test
  id: totrans-3462
  prefs: []
  type: TYPE_NORMAL
- en: You will be doing the activity in 10.2.6 (Run your own turing test) as the main
    part of your project.
  id: totrans-3463
  prefs: []
  type: TYPE_NORMAL
- en: 17.16.3\. PROJECT
  id: totrans-3464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Turing Test is used to evaluate computer programs that are attempting to
    have a conversation like a human. In this project, you will carry out your own
    Turing test with an online chatbot, and report on the process and your findings.
  id: totrans-3465
  prefs: []
  type: TYPE_NORMAL
- en: 17.16.3.1\. CARRYING OUT THE TURING TEST
  id: totrans-3466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Choose a chatbot and carry out the Turing test with the help of a classmate,
    as described in activity 10.2.6\. Include both the conversations that were generated
    as a result of carrying out the Turing test in your report.
  id: totrans-3467
  prefs: []
  type: TYPE_NORMAL
- en: 17.16.3.2\. WRITING YOUR REPORT
  id: totrans-3468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Achieved/ Merit**'
  id: totrans-3469
  prefs: []
  type: TYPE_NORMAL
- en: Briefly describe what the purpose of the Turing Test is. What problem in computer
    science does it address? Note that this should be at the start of your report,
    and written clearly (considering starting the sentence with “A key problem in
    Artificial Intelligence is…”), so that it is clear to the marker what problem
    the remainder of your report addresses.
  id: totrans-3470
  prefs: []
  type: TYPE_NORMAL
- en: Explain what you did to carry out your Turing Test. Which external factors did
    you have to be careful of in order to ensure that the test was “fair”? Include
    a copy of the two conversations. Is there anything you did in your turing test
    that did not work very well? Were any of the questions you asked “unfair” to the
    chatbot?
  id: totrans-3471
  prefs: []
  type: TYPE_NORMAL
- en: Which conversation do you think was the chatbot and which do you think was your
    classmate? How could you tell? Refer to some lines in your conversations (some
    which you think were definitely not a human). Were you correct?
  id: totrans-3472
  prefs: []
  type: TYPE_NORMAL
- en: '**Excellence**'
  id: totrans-3473
  prefs: []
  type: TYPE_NORMAL
- en: Discuss other possible applications of the Turing Test or similar tests for
    other programs that are supposed to be intelligent. How would you go about carrying
    out such a test? For example, what if you wanted to evaluate whether or not a
    computer played a game in a “human like” way? (As people may prefer to play against
    something that seems human).
  id: totrans-3474
  prefs: []
  type: TYPE_NORMAL
- en: Discuss whether or not the Turing test is a good test of intelligence, giving
    reasons for your answer and using examples from your chatterbot experiments. What
    parts of human intelligence would the Turing test not capture? Are there are other
    ways of testing whether or not a computer is able to have a conversation like
    a human?
  id: totrans-3475
  prefs: []
  type: TYPE_NORMAL
- en: You might like to do some additional reading for ideas for your discussion.
  id: totrans-3476
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Turing_test#Strengths_of_the_test](http://en.wikipedia.org/wiki/Turing_test#Strengths_of_the_test)'
  id: totrans-3477
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Turing_test#Weaknesses_of_the_test](http://en.wikipedia.org/wiki/Turing_test#Weaknesses_of_the_test)'
  id: totrans-3478
  prefs: []
  type: TYPE_NORMAL
- en: 17.16.4\. HINTS FOR SUCCESS
  id: totrans-3479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some students have used quiz show-like questions instead of trying to have conversations.
    It is important to try and have a conversation rather than just ask lots of unrelated
    questions. A conversation does best at revealing a Chatbot’s limitations. For
    example, this conversation isn’t very good. And infact, many of the lines could
    have been human responses.
  id: totrans-3480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What is your favourite colour?'
  id: totrans-3481
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: My favorite color is green. What is yours?'
  id: totrans-3482
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What do you do?'
  id: totrans-3483
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: judge, I talk to people on the web. What do you do?'
  id: totrans-3484
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What is your name?'
  id: totrans-3485
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: My name is ALICE.'
  id: totrans-3486
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: How long have you been alive?'
  id: totrans-3487
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: 16 years.'
  id: totrans-3488
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What is your favourite movie?'
  id: totrans-3489
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: My favorite movie is Casablanca. Have you seen it?'
  id: totrans-3490
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What is your favourite song?'
  id: totrans-3491
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: My favorite song is Imagine. Do you know it?'
  id: totrans-3492
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What is your favourite food?'
  id: totrans-3493
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: I require only electricity.'
  id: totrans-3494
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What is 10 + 20 ?'
  id: totrans-3495
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: 10 times 10 = 100.'
  id: totrans-3496
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What is 79 - 7'
  id: totrans-3497
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: I would look into the web for that knowledge.'
  id: totrans-3498
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Whereas this next conversation reveals the Chatbot’s limited ability to hold
    a conversation, as we were attempting to make it do.
  id: totrans-3499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'judge: What is your favourite colour?'
  id: totrans-3500
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: My favorite color is green. What is yours?'
  id: totrans-3501
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: Mine is Purple'
  id: totrans-3502
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: purple is a very nice color.'
  id: totrans-3503
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: Why isn’t it your favourite colour?'
  id: totrans-3504
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: My mind does not contain an explanation for it.'
  id: totrans-3505
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: What does your mind contain?'
  id: totrans-3506
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: What do you think it does?'
  id: totrans-3507
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: I would have no idea'
  id: totrans-3508
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: How much would you pay for it?'
  id: totrans-3509
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: Nothing, sorry'
  id: totrans-3510
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: Really nothing?'
  id: totrans-3511
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'judge: Yeah, you’re a worthless chatbot...'
  id: totrans-3512
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ALICE: Aha.. Yes.'
  id: totrans-3513
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You will need to base your responses on the last response you received rather
    than attempting to use a list of predefined questions.
  id: totrans-3514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You don’t need to say the same things to the chatbot and the human. Just try
    and hold a conversation with both, and mostly go with whatever direction the conversation
    is going (although do try one or two subject changes as well to see what happens!).
    Just pretend you are having a casual conversation with somebody you don’t know
    very well.
  id: totrans-3515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offensive words or topics could land you in a ton of trouble if included in
    your submitted report. If a chatbot says something inappropriate, censor it. Choose
    a classmate to work with who is likely to be sensible if you want to do well (if
    they do say anything offensive, don’t include it in your report).
  id: totrans-3516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have nobody to work with, consider doing the related project which focuses
    mostly on the chatbots and the techniques they use to try and sound intelligent.
  id: totrans-3517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should be able to write up the project in about 4 pages.
  id: totrans-3518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.17\. FUTURE PLANS FOR THE FIELD GUIDE
  id: totrans-3519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The initial version of the guide being developed in 2012/2013 is intended to
    cover the new NZ achievement standards in CS. However, there are other topics
    that aren’t covered that would be good to mention, and they are recorded here
    as possible future chapters to add.
  id: totrans-3520
  prefs: []
  type: TYPE_NORMAL
- en: 17.17.1\. COMPUTABILITY
  id: totrans-3521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[http://www.lel.ed.ac.uk/~gpullum/loopsnoop.html](http://www.lel.ed.ac.uk/~gpullum/loopsnoop.html) Ed
    Dalley’s story about the halting problem cs4fn'
  id: totrans-3522
  prefs: []
  type: TYPE_NORMAL
- en: 17.17.2\. LOGIC CIRCUITS
  id: totrans-3523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gates (see unplugged Peruvian activity) [http://www.cs4fn.org/binary/nim/nim.php](http://www.cs4fn.org/binary/nim/nim.php) uses
    xor Online logic simulator? Binary additions (see also marble and wood logic devices,
    and other non-electronic ones) Logic: [http://courses.cs.vt.edu/csonline/MachineArchitecture/Lessons/index.html](http://courses.cs.vt.edu/csonline/MachineArchitecture/Lessons/index.html)
  id: totrans-3524
  prefs: []
  type: TYPE_NORMAL
- en: 17.17.3\. BIG DATA/CLOUD COMPUTING
  id: totrans-3525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Big_data](http://en.wikipedia.org/wiki/Big_data) [http://www.nsf.gov/cise/csbytes/newsletter/vol1/vol1i11.html](http://www.nsf.gov/cise/csbytes/newsletter/vol1/vol1i11.html)'
  id: totrans-3526
  prefs: []
  type: TYPE_NORMAL
- en: There is some background at: [http://www.techamericafoundation.org/bigdata](http://www.techamericafoundation.org/bigdata)
  id: totrans-3527
  prefs: []
  type: TYPE_NORMAL
- en: The Google data center gallery has cool pictures: [http://www.google.com/about/datacenters/gallery/#/](http://www.google.com/about/datacenters/gallery/#/) or
    could tie in with Computational Science (from ACM curriculum)
  id: totrans-3528
  prefs: []
  type: TYPE_NORMAL
- en: Shadi to help Mark at Monterey interested
  id: totrans-3529
  prefs: []
  type: TYPE_NORMAL
- en: main concepts?
  id: totrans-3530
  prefs: []
  type: TYPE_NORMAL
- en: CAP theorem, mapreduce
  id: totrans-3531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: using an API e.g. google maps, twitter
  id: totrans-3532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: low level - uploading data (mashup?); higher level - APIs
  id: totrans-3533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.17.4\. PARALLEL/CONCURRENT COMPUTING
  id: totrans-3534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some people advocate teaching this first because all computers have multiprocessors
    and data centres. It might be the same chapter as “Big data”, but there are other
    approaches. For beginners, StarLogo and Scratch can be used to teach concurrent
    processes and the issues that arise. There’s bound to be an unplugged activity
    that could show issues like race conditions.
  id: totrans-3535
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.cs4fn.org/parallelcomputing/parallelrats.php](http://www.cs4fn.org/parallelcomputing/parallelrats.php)'
  id: totrans-3536
  prefs: []
  type: TYPE_NORMAL
- en: '[http://dl.acm.org/citation.cfm?id=2414446&picked=prox&CFID=269871400&CFTOKEN=70782049](http://dl.acm.org/citation.cfm?id=2414446&picked=prox&CFID=269871400&CFTOKEN=70782049)'
  id: totrans-3537
  prefs: []
  type: TYPE_NORMAL
- en: ACM curriculum has a lot of material on this
  id: totrans-3538
  prefs: []
  type: TYPE_NORMAL
- en: Teaching map-reduce: [http://dl.acm.org/citation.cfm?id=2414448](http://dl.acm.org/citation.cfm?id=2414448)
  id: totrans-3539
  prefs: []
  type: TYPE_NORMAL
- en: 17.17.5\. DATABASES (OR INFORMATION MANAGEMENT?)
  id: totrans-3540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: and other stuff from the Information branch of the DT standards?
  id: totrans-3541
  prefs: []
  type: TYPE_NORMAL
- en: 17.17.6\. OPERATING SYSTEMS
  id: totrans-3542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Or related topics? [http://www.cl.cam.ac.uk/freshers/raspberrypi/tutorials/os/](http://www.cl.cam.ac.uk/freshers/raspberrypi/tutorials/os/) From
    nand to Tetris project Architecture, memory management, security, VMs, devices,
    file systems, fault tolerance, performance evaluation Operating systems on-a-stick
    e.g. schools.pconme.com Operating systems:[http://courses.cs.vt.edu/csonline/OS/Lessons/index.html](http://courses.cs.vt.edu/csonline/OS/Lessons/index.html)
  id: totrans-3543
  prefs: []
  type: TYPE_NORMAL
- en: 17.17.7\. INFORMATION ASSURANCE AND SECURITY
  id: totrans-3544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the new ACM curriculum; could include forensics? [http://www.nsf.gov/cise/csbytes/newsletter/vol1/vol1i12.html](http://www.nsf.gov/cise/csbytes/newsletter/vol1/vol1i12.html)[http://www.nsf.gov/cise/csbytes/newsletter/vol2/vol2i3.html](http://www.nsf.gov/cise/csbytes/newsletter/vol2/vol2i3.html)
  id: totrans-3545
  prefs: []
  type: TYPE_NORMAL
- en: might use some stuff from cryptography?
  id: totrans-3546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doxd game
  id: totrans-3547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark at Monterey may contribute
  id: totrans-3548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.nsf.gov/cise/csbytes/newsletter/vol2/vol2i13.html](http://www.nsf.gov/cise/csbytes/newsletter/vol2/vol2i13.html) -
    information privacy'
  id: totrans-3549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.17.8\. MOBILE COMPUTING
  id: totrans-3550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not sure if it’s a general area, but probably a few things that could be covered
  id: totrans-3551
  prefs: []
  type: TYPE_NORMAL
- en: 17.17.9\. SOCIAL AND PROFESSIONAL ISSUES
  id: totrans-3552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ethics? Communication? Digital divide, social implications, professional communities,
    codes of conduct, intellectual property, open source movement, privacy, sustainability
    (green computing), computer crime, how companies make money (e.g. Skype p2p, Google
    and Facebook with private information)
  id: totrans-3553
  prefs: []
  type: TYPE_NORMAL
- en: 17.17.10\. QUANTUM COMPUTING
  id: totrans-3554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Quantum_computer](http://en.wikipedia.org/wiki/Quantum_computer) [http://www.howstuffworks.com/quantum-computer.htm](http://www.howstuffworks.com/quantum-computer.htm) [http://plato.stanford.edu/entries/qt-quantcomp/](http://plato.stanford.edu/entries/qt-quantcomp/)www.youtube.com/watch?v=sICXOwOwS4E'
  id: totrans-3555
  prefs: []
  type: TYPE_NORMAL
- en: 17.18\. GUIDE TO SYSTEM FOR OPEN SOURCE DEVELOPERS
  id: totrans-3556
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following guide has been written to help those wishing to adapt this system.
    Modifying the system can be quite a large task, especially in setup. We are not
    releasing the full package of files for automated generation process, as this
    includes personal login data to networks, etc. However, we do want to share this
    project as much as possible, therefore this guide has been written for those wish
    to take the time to adapt the system.
  id: totrans-3557
  prefs: []
  type: TYPE_NORMAL
- en: If you are wanting a local copy of the files to host on your local network,
    or wish to clarify or add something to the guide below, please contact [Jack Morgan](mailto:jack.morgan%40canterbury.ac.nz).
    The guide is definitely not complete in it’s current state, but is being expanded
    frequently.
  id: totrans-3558
  prefs: []
  type: TYPE_NORMAL
- en: The textbook is licensed under a Creative Commons Attribution Non-Commerical
    Share Alike license. Full details on this license, including a human readable
    summary, [can be found here](http://creativecommons.org/licenses/by-nc-sa/3.0/).
  id: totrans-3559
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-3560
  prefs: []
  type: TYPE_NORMAL
- en: Code experience recommended
  id: totrans-3561
  prefs: []
  type: TYPE_NORMAL
- en: The following guide to setup your own Sphinx system is quite code heavy, so
    moderate experience with programming is recommended. For those who get stuck with
    Sphinx creation, the Sphinx community is very active, you can [find them here](https://groups.google.com/forum/?fromgroups=#!forum/sphinx-users).
  id: totrans-3562
  prefs: []
  type: TYPE_NORMAL
- en: 17.18.1\. PROCESS OF TEXTBOOK CREATION
  id: totrans-3563
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The textbook uses a documentation generator by the name of [Sphinx](http://sphinx-doc.org/),
    orginally created to generate Python documentation.
  id: totrans-3564
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563b17495362e.png)](http://csfieldguide.org.nz/_images/A-system-process.png)'
  id: totrans-3565
  prefs: []
  type: TYPE_NORMAL
- en: The textbook is written in a notation called ReStructured Text (or ReST), which
    acts much like a relaxed version of LaTeX. Details on how to use the ReStructured
    Text markup (plus how it fits into Sphinx) can be [found here](http://sphinx-doc.org/rest.html).
    The advantages of using the ReST format, is that if we ever want to switch away
    from the Sphinx system, we can plug the source material straight into the new
    system with minimal configuration.
  id: totrans-3566
  prefs: []
  type: TYPE_NORMAL
- en: 'Most pages on the textbook website (except for a couple of special cases: homepage
    etc) are written in the ReST format, and you can view the source code by clicking
    the ‘Show Source’ link in the sidebar. For example, the source for this page can
    be found in the sidebar.'
  id: totrans-3567
  prefs: []
  type: TYPE_NORMAL
- en: 'The Sphinx system then processes these files, and generates the relevant HTML
    requires for the website. From this stage onwards, many tweaks have been made
    to the system, the source and the generation process to produce the material we
    wanted. These details are too numerous to go into detail about, however some good
    links to read for running your own Sphinx setup include:'
  id: totrans-3568
  prefs: []
  type: TYPE_NORMAL
- en: '[First Steps with Sphinx](http://sphinx-doc.org/tutorial.html)'
  id: totrans-3569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sphinx Markup Constructs](http://sphinx-doc.org/markup/index.html)'
  id: totrans-3570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sphinx Configuration File](http://sphinx-doc.org/config.html)'
  id: totrans-3571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[HTML Theming](http://sphinx-doc.org/theming.html)'
  id: totrans-3572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Build Options](http://sphinx-doc.org/invocation.html)'
  id: totrans-3573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Available Sphinx Builders](http://sphinx-doc.org/builders.html) (What is produced
    on the generation: HTML, PDF etc)'
  id: totrans-3574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Math support in Sphinx](http://sphinx-doc.org/ext/math.html)'
  id: totrans-3575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 17.18.2\. VERSIONING
  id: totrans-3576
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this textbook, several versions were created for different purposes. To
    designate content to different versions, we decided the student version would
    be the base version, as other versions *build* on top of this. Adding and designating
    content to another version (for example: a teacher’s note) is done with the [only
    command](http://sphinx-doc.org/markup/misc.html#directive-only) in the text files.'
  id: totrans-3577
  prefs: []
  type: TYPE_NORMAL
- en: 'The versions we created are as follows:'
  id: totrans-3578
  prefs: []
  type: TYPE_NORMAL
- en: Student’s version
  id: totrans-3579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teacher’s version (include comments for teachers)
  id: totrans-3580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development version (includes raw development material)
  id: totrans-3581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And each version are created in the following types:'
  id: totrans-3582
  prefs: []
  type: TYPE_NORMAL
- en: Website (HTML output)
  id: totrans-3583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paper (LaTeX/PDF output)
  id: totrans-3584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Portable (ePub/MOBI output) using an experimental builder
  id: totrans-3585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You would generally create all the versions from the same source files (ie student
    version would just not include teachers notes), however we wanted to customise
    the website even further. Our textbook is generated by *one* system, from *one* main
    source and *three* minor sources (one for each version) into *multiple* outputs.
    The minor sources include files that needed to be different for each version.
    Some of these files include the Sphinx Configuration file ([conf.py file](http://sphinx-doc.org/config.html))
    which dictated the appearance for the seperate versions (teacher version is green
    while student version is blue), and what was included in the sidebar (hiding the
    source files from students to prevent them from easily being able to access answers).
    This proved to be quite a complicated system to setup, however the system now
    has an extreme amount of power in customisation ability.
  id: totrans-3586
  prefs: []
  type: TYPE_NORMAL
- en: 17.18.3\. PDF GENERATION
  id: totrans-3587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Guide on PDF generation to be released at a later date (when it’s ready).
  id: totrans-3588
  prefs: []
  type: TYPE_NORMAL
- en: 17.18.4\. EPUB/MOBI GENERATION
  id: totrans-3589
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Guide on ePub/MOBIgeneration to be released at a later date (when it’s ready).
  id: totrans-3590
  prefs: []
  type: TYPE_NORMAL
- en: 17.18.5\. HOW TO ADD CONTENT
  id: totrans-3591
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Guide on how to add content to be released at a later date (when it’s ready).
  id: totrans-3592
  prefs: []
  type: TYPE_NORMAL
- en: 17.18.6\. UPDATE SCRIPT
  id: totrans-3593
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Guide on the update script to be released at a later date (when it’s ready).
  id: totrans-3594
  prefs: []
  type: TYPE_NORMAL
- en: 17.18.7\. VISUAL APPEARANCE/CSS
  id: totrans-3595
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Guide on editing the appearance of the site to be released at a later date (when
    it’s ready).
  id: totrans-3596
  prefs: []
  type: TYPE_NORMAL
- en: JUST BROWSING
  id: totrans-3597
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The "Computer Science Field Guide" is a online resource for teaching Computer
    Science to students. This guide is being developed as an online interactive textbook
    to support the new achievement standards in Computer Science that are being rolled
    out in New Zealand from 2011 to 2013\. Eventually it will expand to support other
    curricula, but the initial focus is to meet the urgent need of resources in NZ.
  id: totrans-3598
  prefs: []
  type: TYPE_NORMAL
- en: The [Introduction](http://csfieldguide.org.nz/Introduction.html) chapter is
    good place to start to find out the goals of the site. The chapters are in various
    stages of development, but the chapter on graphics is a good example of a fairly
    complete version, and the formal languages chapter is a good example of how we're
    taken advanced concepts and packaged them for high school students.
  id: totrans-3599
  prefs: []
  type: TYPE_NORMAL
- en: INTERACTIVES
  id: totrans-3600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following interactives are used in our online resource to teach concepts
    or particular ideas to students.
  id: totrans-3601
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ae3fa81d80.png)Click to load the'
  id: totrans-3602
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm Sorting interactive](http://csfieldguide.org.nz/_static/widgets/ALGO/ALGO-PhysicsSort_v2/public_html/index.html)
  id: totrans-3603
  prefs: []
  type: TYPE_NORMAL
- en: '[![](563ae3f9f397e.png)Click to load the'
  id: totrans-3604
  prefs: []
  type: TYPE_NORMAL
- en: binary number interactive](http://csfieldguide.org.nz/_static/widgets/DR/DR-base-conversion/public_html/index.html?base=2&columns=8&lines=A,B,C&offset=0)
  id: totrans-3605
  prefs: []
  type: TYPE_NORMAL
