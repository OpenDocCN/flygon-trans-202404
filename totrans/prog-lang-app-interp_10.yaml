- en: 10Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 对象
- en: 'When a language admits functions as values, it provides developers the most
    natural way to represent a unit of computation. Suppose a developer wants to parameterize
    some function f. Any language lets f be parameterized by passive data, such as
    numbers and strings. But it is often attractive to parameterize it over active
    data: a datum that can compute an answer, perhaps in response to some information.
    Furthermore, the function passed to f can—<wbr>assuming lexically-scoped functions—<wbr>refer
    to data from the caller without those data having to be revealed to f, thus providing
    a foundation for security and privacy. Thus, lexically-scoped functions are central
    to the design of many secure programming techniques.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当一种语言允许函数作为值时，它为开发人员提供了最自然的表示计算单元的方式。假设开发人员想要参数化某个函数 f。任何语言都可以让 f 被被动数据参数化，比如数字和字符串。但通常更吸引人的是将其参数化为活跃数据：一个可以根据一些信息计算答案的数据。此外，传递给
    f 的函数可以（假设具有词法作用域的函数）引用来自调用者的数据，而无需将这些数据透露给 f，从而为安全性和隐私性提供了基础。因此，具有词法作用域的函数对于许多安全编程技术的设计至关重要。
- en: 'While a function is a splendid thing, it suffers from excessive terseness.
    Sometimes we might want multiple functions to all close over to the same shared
    data; the sharing especially matters if some of the functions mutate it and expect
    the others to see the result of those mutations. In such cases, it becomes unwieldly
    to send just a single function as a parameter; it is more useful to send a group
    of functions. The recipient then needs a way to choose between the different functions
    in the group. This grouping of functions, and the means to select one from the
    group, is the essence of an object. We are therefore perfectly placed to study
    objects having covered functions ([Functions Anywhere](higher-order-functions.html))
    and mutation ([Mutation: Structures and Variables](mut-struct-vs-var.html))—<wbr>and,
    it will emerge, recursion ([Recursion and Cycles: Procedures and Data](recursion.html)).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数是一种绝妙的东西，但它过于简洁。有时，我们可能希望多个函数都封闭到相同的共享数据中；如果其中一些函数对其进行了变异并且期望其他函数看到这些变异的结果，则分享尤为重要。在这种情况下，仅发送一个函数作为参数变得不便；将一组函数发送更有用。接收者然后需要一种方法来在组中选择不同的函数。函数的这种分组，以及从组中选择一个的方法，是对象的本质。因此，我们在涵盖了函数（[函数随处可用](higher-order-functions.html)）和变异（[变异：结构和变量](mut-struct-vs-var.html)）之后已经完美地准备好研究对象——并且，它将会发展为递归（[递归和循环：过程和数据](recursion.html)）。
- en: 'I cannot hope to do justice to the enormous space of object systems. Please
    read [Object-Oriented Programming Languages: Application and Interpretation](http://users.dcc.uchile.cl/~etanter/ooplai/)
    by Éric Tanter, which goes into more detail and covers topics ignored here. Let’s
    add this notion of objects to our language. Then we’ll flesh it out and grow it,
    and explore the many dimensions in the design space of objects. We’ll first show
    how to add objects to the core language, but because we’ll want to prototype many
    different ideas quickly, we’ll soon shift to a desguaring-based strategy. Which
    one you use depends on whether you think understanding them is critical to understanding
    the essence of your language. One way to measure this is how complex your desguaring
    strategy becomes, and whether by adding some key core language enhancements, you
    can greatly reduce the complexity of desugaring.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法涵盖对象系统的巨大空间。请阅读 Éric Tanter 的 [面向对象的编程语言：应用与解释](http://users.dcc.uchile.cl/~etanter/ooplai/)，这本书详细介绍了并涵盖了本文所忽略的主题。让我们将这个对象的概念添加到我们的语言中。然后我们将充实它并发展它，并探索对象设计空间中的许多维度。我们首先将展示如何将对象添加到核心语言中，但因为我们希望快速原型化许多不同的想法，所以很快我们将转向基于
    desguaring 的策略。你使用哪种取决于你是否认为理解它们对于理解你的语言的本质至关重要。衡量这一点的方法之一是你的 desguaring 策略变得多么复杂，以及通过添加一些关键的核心语言增强，你是否可以大大减少
    desugaring 的复杂性。
- en: 10.1Objects Without Inheritance
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 没有继承的对象
- en: The simplest notion of an object—<wbr>pretty much the only thing everyone who
    talks about objects agrees about—<wbr>is that an object is
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的最简单概念——几乎每个谈论对象的人都同意的唯一事情——是对象是
- en: a value, that
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个值，即
- en: maps names to
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将名称映射到
- en: 'stuff: either other values or “methods”.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物品：可以是其他值或“方法”。
- en: From a minimalist perspective, methods seem to be just functions, and since
    we already have those in the language, we can put aside this distinction.We’re
    about to find out that “methods” are awfully close to functions but differ in
    important ways in how they’re called and/or what’s bound in them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从极简主义的角度看，方法似乎只是函数，而由于我们已经在语言中拥有了这些函数，我们可以把这种区别放在一边。我们将发现，“方法”与函数非常接近，但在它们被调用的方式和/或绑定在其中的内容上有重要区别。
- en: 10.1.1Objects in the Core
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1核心中的对象
- en: 'Therefore, starting from the language with first-class functions, let’s define
    this very simple notion of objects by adding it to the core language. We clearly
    have to extend our notion of values:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从具有头等函数的语言开始，让我们通过将其添加到核心语言中来定义对象的这个非常简单的概念。我们显然必须扩展我们对值的概念：
- en: '| (define-type Value |'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义类型 Value |'
- en: '|   [numV (n : number)] |'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [numV (n : number)] |'
- en: '|   [closV (arg : symbol) (body : ExprC) (env : Env)] |'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [closV (arg : symbol) (body : ExprC) (env : Env)] |'
- en: '|   [objV (ns : (listof symbol)) (vs : (listof Value))]) |'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [objV (ns : (listof symbol)) (vs : (listof Value))]) |'
- en: 'We’ll extend the expression grammar to support literal object construction
    expressions:Observe that this is already a design decision. In some languages,
    like JavaScript, a developer can write literal objects: a notion so popular that
    a subset of the syntax for it in JavaScript has become a Web standard, JSON. In
    other languages, like Java, objects can only be created by invoking a constructor
    on a class. We can simulate both by assuming that to model the latter kind of
    language, we must write object literals only in special positions following a
    stylized convention, as we do when desugaring below.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展表达式语法以支持字面对象构造表达式：请注意，这已经是一个设计决策。在某些语言中，比如JavaScript，开发人员可以编写字面对象：这个概念在JavaScript中是如此流行，以至于其一部分语法已成为Web标准，即JSON。在其他语言中，比如Java，对象只能通过在类上调用构造函数来创建。我们可以通过假设模拟后一种语言来模拟前一种语言，只能在遵循一种风格化约定的特殊位置写入对象文字，就像我们在下面展开时所做的那样。
- en: '| [objC (ns : (listof symbol)) (es : (listof ExprC))] |'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [objC (ns : (listof symbol)) (es : (listof ExprC))] |'
- en: 'Evaluating such an object expression is easy: we just evaluate each of its
    expression positions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对这样的对象表达式进行评估很容易：我们只需评估其每个表达式位置：
- en: '| [objC (ns es) (objV ns (map (lambda (e) |'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [objC (ns es) (objV ns (map (lambda (e) |'
- en: '|                               (interp e env)) |'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                               (interp e env)) |'
- en: '|                             es))] |'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                             es))] |'
- en: 'Unfortunately, we can’t actually use an object, because we have no way of obtaining
    its content. For that reason, we could add an operation to extract members:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们实际上无法使用对象，因为我们无法获得其内容。出于这个原因，我们可以添加一个操作来提取成员：
- en: '| [msgC (o : ExprC) (n : symbol)] |'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [msgC (o : ExprC) (n : symbol)] |'
- en: 'whose behavior is intuitive:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 其行为是直观的：
- en: '| [msgC (o n) (lookup-msg n (interp o env))] |'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [msgC (o n) (lookup-msg n (interp o env))] |'
- en: Exercise
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Implement
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现
- en: ''
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| ; lookup-msg : symbol * Value -> Value |'
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '| ; lookup-msg : symbol * Value -> Value |'
- en: ''
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: where the second argument is expected to be a objV.
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第二个参数预期是一个objV。
- en: 'In principle, msgC can be used to obtain any kind of member but for simplicity,
    we need only assume that we have functions. To use them, we must apply them to
    values. This is cumbersome to write in the concrete syntax, so let’s assume desugaring
    has taken care of it for us: the concrete syntax for message invocation includes
    both the name of the message to fetch and its argument expression,'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，msgC可以用于获取任何类型的成员，但为了简单起见，我们只需要假设我们有函数。要使用它们，我们必须将它们应用于值。这在具体语法中写起来很麻烦，因此让我们假设展开已经为我们解决了这个问题：消息调用的具体语法包括要提取的消息名称及其参数表达式，
- en: '| [msgS (o : ExprS) (n : symbol) (a : ExprS)] |'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [msgS (o : ExprS) (n : symbol) (a : ExprS)] |'
- en: 'and this desguars into msgC composed with application:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以看作是msgC与应用程序组合的展开：
- en: '| [msgS (o n a) (appC (msgC (desugar o) n) (desugar a))] |'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [msgS (o n a) (appC (msgC (desugar o) n) (desugar a))] |'
- en: 'With this we have a full first language with objects. For instance, here is
    an object definition and invocation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就有了一个完整的具有对象的第一语言。例如，这里是一个对象定义和调用：
- en: '| (letS ''o (objS (list ''add1 ''sub1) |'
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (letS ''o (objS (list ''add1 ''sub1) |'
- en: '|                (list (lamS ''x (plusS (idS ''x) (numS 1))) |'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                (list (lamS ''x (plusS (idS ''x) (numS 1))) |'
- en: '|                      (lamS ''x (plusS (idS ''x) (numS -1))))) |'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      (lamS ''x (plusS (idS ''x) (numS -1))))) |'
- en: '|       (msgS (idS ''o) ''add1 (numS 3))) |'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (msgS (idS ''o) ''add1 (numS 3))) |'
- en: and this evaluates to (numV 4).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这将求值为(numV 4)。
- en: 10.1.2Objects by Desugaring
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.2通过展开实现的对象
- en: While defining objects in the core language may be worthwhile, it’s an unwieldy
    way to go about studying them. Instead, we’ll use Racket to represent objects,
    sticking to the parts of the language we already know how to implement in our
    interpreter. That is, we’ll assume that we are looking at the output of desugaring.
    (For this reason, we’ll also stick to stylized code, potentially writing unnecessary
    expressions on the grounds that this is what a simple program generator would
    produce.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在核心语言中定义对象可能是值得的，但这是一种繁琐的学习方法。相反，我们将使用 Racket 来表示对象，坚持使用我们已经知道如何在解释器中实现的语言部分。也就是说，我们假设我们正在查看解糖的输出。（因此，我们也将坚持使用风格化的代码，可能会写一些不必要的表达式，因为这是一个简单程序生成器会产生的。）
- en: 'Alert: All the code that follows will be in #lang plai, not in the typed language.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '警告：接下来的所有代码将使用 #lang plai，而不是类型化语言。'
- en: Exercise
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'Why #lang plai? What problems do you encounter when you try to type the following
    code? Are some of them amenable to easy fixes, such as introducing a new datatype
    and applying it consistently? How about if we make simplifications for the purposes
    of modeling, such as assuming methods have only one argument? Or are some of them
    less tractable?'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '为什么选择 #lang plai？当您尝试输入以下代码时遇到了什么问题？有些问题是否容易修复，比如引入一个新的数据类型并一致应用它？如果我们为了建模目的进行简化，比如假设方法只有一个参数，那么有些问题是否较难解决？'
- en: 10.1.3Objects as Named Collections
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.3对象作为命名集合
- en: Let’s begin by reproducing the object language we had above. An object is just
    a value that dispatches on a given name. For simplicity, we’ll use lambda to represent
    the object and case to implement the dispatching.Observe that basic objects are
    a generalization of lambda to have multiple “entry-points”. Conversely, a lambda
    is an object with just one entry-point, so it doesn’t need a “method name” to
    disambiguate.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从复制上面的对象语言开始。对象只是一个根据给定名称分派的值。为简单起见，我们将使用 lambda 来表示对象，并使用 case 来实现分派。请注意，基本对象是
    lambda 的一种泛化，具有多个“入口点”。相反，lambda 是只有一个入口点的对象，因此不需要“方法名称”来消除歧义。
- en: '| (define o-1 |'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define o-1 |'
- en: '|   (lambda (m) |'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (lambda (m) |'
- en: '|     (case m |'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (case m |'
- en: '|       [(add1) (lambda (x) (+ x 1))] |'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       [(add1) (lambda (x) (+ x 1))] |'
- en: '|       [(sub1) (lambda (x) (- x 1))]))) |'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       [(sub1) (lambda (x) (- x 1))]))) |'
- en: 'This is the same object we defined earlier, and we use its method in the same
    way:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前定义的同一个对象，并且我们以相同的方式使用它的方法：
- en: '| (test ((o-1 ''add1) 5) 6)  ;; the test succeeds |'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test ((o-1 ''add1) 5) 6)  ;; 测试成功 |'
- en: 'Of course, writing method invocations with these nested function calls is unwieldy
    (and is about to become even more so), so we’d be best off equipping ourselves
    with a convenient syntax for invoking methods—<wbr>the same one we saw earlier
    (msgS), but here we can simply define it as a function:We’ve taken advantage of
    Racket’s variable-arity syntax: . a says “bind all the remaining—<wbr>zero or
    more—<wbr>arguments to a list named a”. apply “splices” in such lists of arguments
    to call functions.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用这些嵌套函数调用编写方法调用是不便的（而且即将变得更加不便），因此最好装备自己方便地调用方法的语法 —— 与之前看到的相同（msgS），但在这里我们可以简单地将其定义为一个函数：我们利用了
    Racket 的可变参数语法：. a 表示“将所有剩余的 —— 零个或多个 —— 参数绑定到名为 a 的列表中”。apply 会“展开”这些参数列表以调用函数。
- en: '| (define (msg o m . a) |'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (msg o m . a) |'
- en: '|   (apply (o m) a)) |'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (apply (o m) a)) |'
- en: 'This enables us to rewrite our test:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够重写我们的测试：
- en: '| (test (msg o-1 ''add1 5) 6) |'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (msg o-1 ''add1 5) 6) |'
- en: Do Now!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始！
- en: Something very important changed when we switched to the desguaring strategy.
    Do you see what it is?
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我们切换到解糖策略时，有一些非常重要的变化。你看到了吗？
- en: 'Recall the syntax definition we had earlier:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们之前的语法定义：
- en: '| [msgC (o : ExprC) (n : symbol)] |'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [msgC (o : ExprC) (n : symbol)] |'
- en: The “name” position of a message was very explicitly a symbol. That is, the
    developer had to write the literal name of the symbol there. In our desugared
    version, the name position is just an expression that must evaluate to a symbol;
    for instance, one could have written
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 消息的“名称”位置非常明确是一个符号。也就是说，开发人员必须在那里写入符号的文字名称。在我们的��糖版本中，名称位置只是一个必须求值为符号的表达式；例如，可以写成
- en: '| (test ((o-1 (string->symbol "add1")) 5) 6)  ;; this also succeeds |'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test ((o-1 (string->symbol "add1")) 5) 6)  ;; 这也成功了 |'
- en: 'This is a general problem with desugaring: the target language may allow expressions
    that have no counterpart in the source, and hence cannot be mapped back to it.
    Fortunately we don’t often need to perform this inverse mapping, though it does
    arise in some debugging and program comprehension tools. More subtly, however,
    we must ensure that the target language does not produce values that have no corresponding
    equivalent in the source.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解糖的一个普遍问题：目标语言可能允许表达式，而源语言中没有对应的表达式，因此无法映射回源语言。幸运的是，我们通常不需要执行这种逆映射，尽管在一些调试和程序理解工具中会出现。然而更微妙的是，我们必须确保目标语言不会产生在源语言中没有对应等价物的值。
- en: Now that we have basic objects, let’s start adding the kinds of features we’ve
    come to expect from most object systems.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基本对象，让我们开始添加大多数对象系统中期望的功能。
- en: 10.1.4Constructors
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.4构造函数
- en: 'A constructor is simply a function that is invoked at object construction time.
    We currently lack such a function. by turning an object from a literal into a
    function that takes constructor parameters, we achieve this effect:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数只是在对象构造时调用的函数。我们目前缺少这样一个函数。通过将对象从文字转换为接受构造函数参数的函数，我们实现了这种效果：
- en: '| (define (o-constr-1 x) |'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (o-constr-1 x) |'
- en: '|   (lambda (m) |'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (lambda (m) |'
- en: '|     (case m |'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (case m |'
- en: '|       [(addX) (lambda (y) (+ x y))]))) |'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       [(addX) (lambda (y) (+ x y))]))) |'
- en: '|   |'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '| (test (msg (o-constr-1 5) ''addX 3) 8) |'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (msg (o-constr-1 5) ''addX 3) 8) |'
- en: '| (test (msg (o-constr-1 2) ''addX 3) 5) |'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (msg (o-constr-1 2) ''addX 3) 5) |'
- en: In the first example, we pass 5 as the constructor’s argument, so adding 3 yields
    8. The second is similar, and shows that the two invocations of the constructors
    don’t interfere with one another.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们将5作为构造函数的参数传递，因此添加3得到8。第二个类似，并显示构造函数的两次调用不会相互干扰。
- en: 10.1.5State
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.5状态
- en: 'Many people believe that objects primarily exist to encapsulate state.Alan
    Kay, who won a Turing Award for inventing Smalltalk and modern object technology,
    disagrees. In [The Early History of Smalltalk](http://www.smalltalk.org/smalltalk/TheEarlyHistoryOfSmalltalk_Abstract.html),
    he says, “[t]he small scale [motivation for OOP] was to find a more flexible version
    of assignment, and then to try to eliminate it altogether”. He adds, “It is unfortunate
    that much of what is called `object-oriented programming’ today is simply old
    style programming with fancier constructs. Many programs are loaded with `assignment-style’
    operations now done by more expensive attached procedures.” We certainly haven’t
    lost that ability. If we desugar to a language with variables (we could equivalently
    use boxes, in return for a slight desugaring overhead), we can easily have multiple
    methods mutate common state, such as a constructor argument:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人认为对象主要存在于封装状态。阿兰·凯（Alan Kay）为发明Smalltalk和现代对象技术而获得图灵奖的人持不同意见。在[Smalltalk的早期历史](http://www.smalltalk.org/smalltalk/TheEarlyHistoryOfSmalltalk_Abstract.html)中，他说，“[OOP的小规模动机]是为了找到一个更灵活的赋值版本，然后尝试完全消除它”。他补充说，“不幸的是，今天被称为`面向对象编程’的许多东西只是带有更复杂结构的旧式编程。许多程序现在充斥着更昂贵的附加过程所做的`赋值式’操作。”我们当然没有失去这种能力。如果我们解糖到一个带有变量的语言（我们可以等效地使用盒子，以换取轻微的解糖开销），我们可以轻松地让多个方法改变共同状态，比如构造函数参数：
- en: '| (define (o-state-1 count) |'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (o-state-1 count) |'
- en: '|   (lambda (m) |'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (lambda (m) |'
- en: '|     (case m |'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (case m |'
- en: '|       [(inc) (lambda () (set! count (+ count 1)))] |'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       [(inc) (lambda () (set! count (+ count 1)))] |'
- en: '|       [(dec) (lambda () (set! count (- count 1)))] |'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       [(dec) (lambda () (set! count (- count 1)))] |'
- en: '|       [(get) (lambda () count)]))) |'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       [(get) (lambda () count)]))) |'
- en: 'For instance, we can test a sequence of operations:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以测试一系列操作：
- en: '| (test (let ([o (o-state-1 5)]) |'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (let ([o (o-state-1 5)]) |'
- en: '|         (begin (msg o ''inc) |'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         (begin (msg o ''inc) |'
- en: '|                (msg o ''dec) |'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                (msg o ''dec) |'
- en: '|                (msg o ''get))) |'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                (msg o ''get))) |'
- en: '|       5) |'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       5) |'
- en: 'and also notice that mutating one object doesn’t affect another:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，改变一个对象不会影响另一个：
- en: '| (test (let ([o1 (o-state-1 3)] |'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (let ([o1 (o-state-1 3)] |'
- en: '|             [o2 (o-state-1 3)]) |'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|             [o2 (o-state-1 3)]) |'
- en: '|         (begin (msg o1 ''inc) |'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         (begin (msg o1 ''inc) |'
- en: '|                (msg o1 ''inc) |'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                (msg o1 ''inc) |'
- en: '|                (+ (msg o1 ''get) |'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                (+ (msg o1 ''get) |'
- en: '|                   (msg o2 ''get)))) |'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                   (msg o2 ''get)))) |'
- en: '|       (+ 5 3)) |'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (+ 5 3)) |'
- en: 10.1.6Private Members
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.6私有成员
- en: 'Another common object language feature is private members: ones that are visible
    only inside the object, not outside it.Except that, in Java, instances of other
    classes of the same type are privy to “private” members. Otherwise, you would
    simply never be able to implement an Abstract Data Type. These may seem like an
    additional feature we need to implement, but we already have the necessary mechanism
    in the form of locally-scoped, lexically-bound variables:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的对象语言特性是私有成员：仅在对象内部可见，而在外部不可见。除了在 Java 中，相同类型的其他类的实例可以访问“私有”成员。否则，你根本无法实现抽象数据类型。这些看起来可能是我们需要实现的额外特性，但我们已经有了必要的机制，即以局部作用域、词法绑定变量的形式存在：
- en: '| (define (o-state-2 init) |'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (o-state-2 init) |'
- en: '|   (let ([count init]) |'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (let ([count init]) |'
- en: '|     (lambda (m) |'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (lambda (m) |'
- en: '|       (case m |'
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (case m |'
- en: '|         [(inc) (lambda () (set! count (+ count 1)))] |'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         [(inc) (lambda () (set! count (+ count 1)))] |'
- en: '|         [(dec) (lambda () (set! count (- count 1)))] |'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         [(dec) (lambda () (set! count (- count 1)))] |'
- en: '|         [(get) (lambda () count)])))) |'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         [(get) (lambda () count)])))) |'
- en: The desugaring above provides no means for accessing count, and lexical scoping
    ensures that it remains hidden to the world.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的展开没有提供访问 count 的方式，并且词法作用域确保它对世界保持隐藏。
- en: 10.1.7Static Members
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.7静态成员
- en: 'Another feature often valuable to users of objects is static members: those
    that are common to all instances of the “same” type of object.We use quotes because
    there are many notions of sameness for objects. And then some. This, however,
    is merely a lexically-scoped identifier (making it private) that lives outside
    the constructor (making it common to all uses of the constructor):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对象用户通常很有价值的另一个特性是静态成员：它们是所有“相同”类型对象实例的共同成员。我们使用引号是因为对象的相同性有许多概念。还有更多。然而，这仅仅是一个词法作用域的标识符（使其私有），它存在于构造函数之外（使其成为构造函数的所有用法的共同部分）：
- en: '| (define o-static-1 |'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define o-static-1 |'
- en: '|   (let ([counter 0]) |'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (let ([counter 0]) |'
- en: '|     (lambda (amount) |'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (lambda (amount) |'
- en: '|       (begin |'
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (begin |'
- en: '|         (set! counter (+ 1 counter)) |'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         (set! counter (+ 1 counter)) |'
- en: '|         (lambda (m) |'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         (lambda (m) |'
- en: '|           (case m |'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|           (case m |'
- en: '|             [(inc) (lambda (n) (set! amount (+ amount n)))] |'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|             [(inc) (lambda (n) (set! amount (+ amount n)))] |'
- en: '|             [(dec) (lambda (n) (set! amount (- amount n)))] |'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|             [(dec) (lambda (n) (set! amount (- amount n)))] |'
- en: '|             [(get) (lambda () amount)] |'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|             [(get) (lambda () amount)] |'
- en: '|             [(count) (lambda () counter)])))))) |'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|             [(count) (lambda () counter)])))))) |'
- en: 'We’ve written the counter increment where the “constructor” for this object
    would go, though it could just as well be manipulated inside the methods.To test
    it, we should make multiple objects and ensure they each affect the global count:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在这个对象的“构造函数”位置写了计数器的增量，尽管它同样可以在方法内部被操作。为了测试它，我们应该创建多个对象，并确保它们每一个都影响全局计数：
- en: '| (test (let ([o (o-static-1 1000)]) |'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (let ([o (o-static-1 1000)]) |'
- en: '|         (msg o ''count)) |'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         (msg o ''count)) |'
- en: '|       1) |'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       1) |'
- en: '|   |'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '| (test (let ([o (o-static-1 0)]) |'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (let ([o (o-static-1 0)]) |'
- en: '|         (msg o ''count)) |'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         (msg o ''count)) |'
- en: '|       2) |'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       2) |'
- en: 10.1.8Objects with Self-Reference
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.8具有自引用的对象
- en: 'Until now, our objects have simply been packages of named functions: functions
    with multiple named entry-points, if you will. We’ve seen that many of the features
    considered important in object systems are actually simple patterns over functions
    and scope, and have indeed been used—<wbr>without names assigned to them—<wbr>for
    decades by programmers armed with lambda.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们的对象只是命名函数的包装：可以理解为具有多个命名入口点的函数。我们已经看到，许多被认为在对象系统中很重要的特性实际上只是函数和作用域上的简单模式，并且的确已经被程序员使用了几十年，尽管没有给它们分配名字。
- en: One characteristic that actually distinguishes object systems is that each object
    is automatically equipped with a reference to the same object, often called self
    or this.I prefer this slightly dry way of putting it to the anthropomorphic “knows
    about itself” terminology often adopted by object advocates. Indeed, note that
    we have gotten this far into object system properties without ever needing to
    resort to anthropomorphism. Can we implement this easily?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上区分对象系统的一个特征是，每个对象都自动配备有指向同一对象的引用，通常称为 self 或 this。我更喜欢这种稍微干燥的表达方式，而不是对象倡导者经常采用的具有人工智能的“了解自己”的术语。确实，值得注意的是，我们已经在对象系统属性中深入到如此程度，而不需要借助人工智能。我们能够轻松实现这一点吗？
- en: 10.1.8.1Self-Reference Using Mutation
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.8.1使用变异进行自引用
- en: Yes, we can, because we have seen just this very pattern when we implemented
    recursion; we’ll just generalize it now to refer not just to the same box or function
    but to the same object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以，因为我们刚刚在实现递归时看到了这个模式；现在我们将其概括为不仅仅是引用相同的框或函数，而是引用相同的对象。
- en: '| (define o-self! |'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define o-self! |'
- en: '|   (let ([self ''dummy]) |'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (let ([self ''dummy]) |'
- en: '|     (begin |'
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (begin |'
- en: '|       (set! self |'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (set! self |'
- en: '|             (lambda (m) |'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|             (lambda (m) |'
- en: '|               (case m |'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|               (case m |'
- en: '|                 [(first) (lambda (x) (msg self ''second (+ x 1)))] |'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 [(first) (lambda (x) (msg self ''second (+ x 1)))] |'
- en: '|                 [(second) (lambda (x) (+ x 1))]))) |'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 [(second) (lambda (x) (+ x 1))]))) |'
- en: '|       self))) |'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       self))) |'
- en: 'Observe that this is precisely the recursion pattern ([Recursive Functions](recursion.html#(part._rec-fun))),
    adapted slightly. We’ve tested it having first send a method to its own second.
    Sure enough, this produces the expected answer:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这恰好是递归模式（[递归函数](recursion.html#(part._rec-fun)）），稍作修改。我们已经测试过了，首先将一个方法发送到其自己的第二个。不出所料，这产生了预期的答案：
- en: '| (test (msg o-self! ''first 5) 7) |'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (msg o-self! ''first 5) 7) |'
- en: 10.1.8.2Self-Reference Without Mutation
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.8.2无突变的自引用
- en: 'If you studied how to implement recursion without mutation, you’ll notice that
    the same solution applies here, too. Observe:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你学过如何在没有突变的情况下实现递归，你会注意到同样的解决方案在这里也适用。观察：
- en: '| (define o-self-no! |'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define o-self-no! |'
- en: '|   (lambda (m) |'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (lambda (m) |'
- en: '|     (case m |'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (case m |'
- en: '|       [(first) (lambda (self x) (msg/self self ''second (+ x 1)))] |'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       [(first) (lambda (self x) (msg/self self ''second (+ x 1)))] |'
- en: '|       [(second) (lambda (self x) (+ x 1))]))) |'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       [(second) (lambda (self x) (+ x 1))]))) |'
- en: 'Each method now takes self as an argument. That means method invocation must
    be modified to follow this new pattern:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法现在都将self作为参数。这意味着方法调用必须修改以遵循这种新模式：
- en: '| (define (msg/self o m . a) |'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (msg/self o m . a) |'
- en: '|   (apply (o m) o a)) |'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (apply (o m) o a)) |'
- en: That is, when invoking a method on o, we must pass o as a parameter to the method.
    Obviously, this approach is dangerous because we can potentially pass a different
    object as the “self”. Exposing this to the developer is therefore probably a bad
    idea; if this implementation technique is used, it should only be done in desugaring.
    Nevertheless, Python exposes just this in its surface syntax. While this tribute
    to the Y-combinator is touching, perhaps the resultant brittleness was unnecessary.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当在o上调用方法时，我们必须将o作为参数传递给方法。显然，这种方法是危险的，因为我们可能会传递一个不同的对象作为“self”。因此，将这一点暴露给开发人员可能是一个坏主意；如果使用这种实现技术，应该只在解糖时进行。尽管如此，Python在其表面语法中公开了这一点。虽然这是对Y组合子的致敬，但也许结果的脆弱性是不必要的。
- en: 10.1.9Dynamic Dispatch
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.9动态分派
- en: Finally, we should make sure our objects can handle a characteristic attribute
    of object systems, which is the ability to invoke a method without the caller
    having to know or decide which object will handle the invocation. Suppose we have
    a binary tree data structure, where a tree consists of either empty nodes or leaves
    that hold a value. In traditional functions, we are forced to implement the equivalent
    some form of conditional—<wbr>either a cond or a type-case or pattern-match or
    other moral equivalent—<wbr>that exhaustively lists and selects between the different
    kinds of trees. If the definition of a tree grows to include new kinds of trees,
    each of these code fragments must be modified. Dynamic dispatch solves this problem
    by making that conditional branch disappear from the user’s program and instead
    be handled by the method selection code built into the language. The key feature
    that this provides is an extensible conditional. This is one dimension of the
    extensibility that objects provide.This property—<wbr>which appears to make systems
    more black-box extensible because one part of the system can grow without the
    other part needing to be modified to accommodate those changes—<wbr>is often hailed
    as a key benefit of object-orientation. While this is indeed an advantage objects
    have over functions, there is a dual advantage that functions have over objects,
    and indeed many object programmers end up contorting their code—<wbr>using the
    Visitor pattern—<wbr>to make it look more like a function-based organization.
    Read [Synthesizing Object-Oriented and Functional Design to Promote Re-Use](http://www.cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/)
    for a running example that will lay out the problem in its full glory. Try to
    solve it in your favorite language, and see the [Racket solution](http://www.cs.utah.edu/plt/publications/icfp98-ff/paper.shtml).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now defined our two kinds of tree objects:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '| (define (mt) |'
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (let ([self ''dummy]) |'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (begin |'
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (set! self |'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|             (lambda (m) |'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|               (case m |'
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                 [(add) (lambda () 0)]))) |'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       self))) |'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   |'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (define (node v l r) |'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (let ([self ''dummy]) |'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (begin |'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (set! self |'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|             (lambda (m) |'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|               (case m |'
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                 [(add) (lambda () (+ v |'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                      (msg l ''add) |'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                      (msg r ''add)))]))) |'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       self))) |'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'With these, we can make a concrete tree:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '| (define a-tree |'
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (node 10 |'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|         (node 5 (mt) (mt)) |'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|         (node 15 (node 6 (mt) (mt)) (mt)))) |'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'And finally, test it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '| (test (msg a-tree ''add) (+ 10 5 15 6)) |'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Observe that both in the test case and in the add method of node, there is a
    reference to ’add without checking whether the recipient is a mt or node. Instead,
    the run-time system extracts the recipient’s add method and invokes it. This missing
    conditional in the user’s program is the essence of dynamic dispatch.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在测试用例和节点的添加方法中都有一个引用指向‘add’，而不检查接收者是空节点还是节点。相反，运行时系统会提取接收者的添加方法并调用它。用户程序中缺少的这个条件是动态分派的本质。
- en: 10.2Member Access Design Space
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2成员访问设计空间
- en: 'We already have two orthogonal dimensions when it comes to the treatment of
    member names. One dimension is whether the name is provided statically or computed,
    and the other is whether the set of names is fixed or variable:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及成员名称的处理时，我们已经有了两个正交维度。一个维度是名称是静态提供还是计算的，另一个维度是名称集是固定的还是可变的：
- en: '|  | Name is Static | Name is Computed |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|  | 名称是静态的 | 名称是计算的 |'
- en: '| Fixed Set of Members | As in base Java. | As in Java with reflection to compute
    the name. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 固定成员集 | 与基本 Java 相同。 | 与使用反射来计算名称的 Java 相同。 |'
- en: '| Variable Set of Members | Difficult to envision (what use would it be?).
    | Most scripting languages. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 可变成员集 | 难以设想（有什么用呢？）。 | 大多数脚本语言。 |'
- en: 'Only one case does not quite make sense: if we force the developer to specify
    the member name in the source file explicitly, then no new members would be accessible
    (and some accesses to previously-existing, but deleted, members would fail). All
    other points in this design space have, however, been explored by languages.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一一个案例有点不合理：如果我们强制开发人员在源文件中明确指定成员名称，那么就无法访问新成员（而且对先前存在但已删除的成员的某些访问将失败）。然而，此设计空间中的所有其他点都已被语言所探索。
- en: The lower-right quadrant corresponds closely with languages that use hash-tables
    to represent objects. Then the name is simply the index into the hash-table. Some
    languages carry this to an extreme and use the same representation even for numeric
    indices, thereby (for instance) conflating objects with dictionaries and even
    arrays. Even when the object only handles “member names”, this style of object
    creates significant difficulty for type-checking [REF] and is hence not automatically
    desirable.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 右下角与使用哈希表表示对象的语言密切对应。然后名称只是哈希表的索引。一些语言将此视为极端情况，并且即使对于数值索引，也使用相同的表示，从而（例如）将对象与字典甚至数组混为一谈。即使对象只处理“成员名称”，这种对象风格也会为类型检查[REF]带来重大困难，因此并不自动可取。
- en: Therefore, in the rest of this section, we will stick with “traditional” objects
    that have a fixed set of names and even static member name references (the top-left
    quadrant). Even then, we will find there is much, much more to study.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节的其余部分，我们将坚持使用具有固定名称集甚至静态成员名称引用的“传统”对象（左上角）。即使如此，我们将发现还有很多很多要研究的东西。
- en: 10.3What (Goes In) Else?
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3其他是什么？
- en: 'Until now, our case statements have not had an else clause. One reason to do
    so would be if we had a variable set of members in an object, though that is probably
    better handled through a different representation than a conditional: a hash-table,
    for instance, as we’ve discussed above. In contrast, if an object’s set of members
    is fixed, desugaring to a conditional works well for the purpose of illustration
    (because it emphasizes the fixed nature of the set of member names, which a hash
    table leaves open to interpretation—<wbr>and also error). There is, however, another
    reason for an else clause, which is to “chain” control to another, parent, object.
    This is called inheritance.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的案例语句都没有 else 子句。加入 else 子句的一个原因是如果对象中有一个可变的成员集，尽管这可能更好地通过不同的表示来处理：例如，像我们之前讨论过的那样，使用哈希表。相比之下，如果一个对象的成员集是固定的，将其解糖为条件对于说明目的很有效（因为它强调了成员名称集的固定性，而哈希表则开放了解释——<wbr>并且也会出错）。然而，有另一个
    else 子句的原因，那就是将控制“链接”到另一个、父对象。这被称为继承。
- en: Let’s return to our model of desugared objects above. To implement inheritance,
    the object must be given “something” to which it can delegate method invocations
    that it does not recognize. A great deal will depend on what that “something”
    is.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到上面解糖对象的模型。为了实现继承，必须为对象提供一个“东西”，它可以将不认识的方法调用委托给它。很大程度上将取决于那个“东西”是什么。
- en: One answer could be that it is simply another object.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个答案可能是它只是另一个对象。
- en: '| (case m |'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (case m |'
- en: '|   ... |'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   ... |'
- en: '|   [else (parent-object m)]) |'
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [else (父对象 m)]) |'
- en: Due to our representation of objects, this application effectively searches
    for the method in the parent object (and, presumably, recursively in its parents).
    If a method matching the name is found, it returns through this chain to the original
    call in msg that sought the method. If none is found, the final object presumably
    signals a “message not found” error.Exercise
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Observe that the application (parent-object m) is like “half a msg”, just like
    an l-value was “half a value lookup” [REF]. Is there any connection?
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s try this by extending our trees to implement another method, size. We’ll
    write an “extension” (you may be tempted to say “sub-class”, but hold off for
    now!) for each node and mt to implement the size method. We intend these to extend
    the existing definitions of node and mt, so we’ll use the extension pattern described
    above.We’re not editing the existing definitions because that is supposed to be
    the whole point of object inheritance: to reuse code in a black-box fashion. This
    also means different parties, who do not know one another, can each extend the
    same base code. If they had to edit the base, first they have to find out about
    each other, and in addition, one might dislike the edits of the other. Inheritance
    is meant to sidestep these issues entirely.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.1Classes
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Immediately we see a difficulty. Is this the constructor pattern?
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '| (define (node/size parent-object v l r) |'
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   ...) |'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: That suggests that the parent is at the “same level” as the object’s constructor
    fields. That seems reasonable, in that once all these parameters are given, the
    object is “fully defined”. However, we also still have
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '| (define (node v l r) |'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   ...) |'
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Are we going to write all the parameters twice? (Whenever we write something
    twice, we should worry that we may not do so consistently, thereby inducing subtle
    errors.) Here’s an alternative: node/size can construct the instance of node that
    is its parent. That is, node/size’s parent parameter is not the parent object
    but rather the parent’s object maker.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '| (define (node/size parent-maker v l r) |'
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (let ([parent-object (parent-maker v l r)] |'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|         [self ''dummy]) |'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (begin |'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (set! self |'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|             (lambda (m) |'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|               (case m |'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                 [(size) (lambda () (+ 1 |'
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                      (msg l ''size) |'
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                      (msg r ''size)))] |'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                 [else (parent-object m)]))) |'
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       self))) |'
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   |'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (define (mt/size parent-maker) |'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (let ([parent-object (parent-maker)] |'
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|         [self ''dummy]) |'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (begin |'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (set! self |'
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|             (lambda (m) |'
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|               (case m |'
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                 [(size) (lambda () 0)] |'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                 [else (parent-object m)]))) |'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       self))) |'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Then the object constructor must remember to pass the parent-object maker on
    every invocation:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '| (define a-tree/size |'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (node/size node |'
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|              10 |'
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|              (node/size node 5 (mt/size mt) (mt/size mt)) |'
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              (node/size node 5 (mt/size mt) (mt/size mt)) |'
- en: '|              (node/size node 15 |'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              (node/size node 15 |'
- en: '|                         (node/size node 6 (mt/size mt) (mt/size mt)) |'
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                         (node/size node 6 (mt/size mt) (mt/size mt)) |'
- en: '|                         (mt/size mt)))) |'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                         (mt/size mt)))) |'
- en: 'Obviously, this is something we might simplify with appropriate syntactic sugar.
    We can confirm that both the old and new tests still work:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以通过适当的语法糖来简化这个过程。我们可以确认旧测试和新测试仍然有效：
- en: '| (test (msg a-tree/size ''add) (+ 10 5 15 6)) |'
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (msg a-tree/size ''add) (+ 10 5 15 6)) |'
- en: '| (test (msg a-tree/size ''size) 4) |'
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (test (msg a-tree/size ''size) 4) |'
- en: Exercise
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Rewrite this block of code using self-application instead of mutation.
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用自我应用而不是变异来重写这个代码块。
- en: 'What we have done is capture the essence of a class. Each function parameterized
    over a parent is...well, it’s a bit tricky, really. Let’s call it a blob for now.
    A blob corresponds to what a Java programmer defines when they write a class:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是捕捉类的本质。每个参数化父类的函数...嗯，这有点棘手，实际上。现在让我们暂时称之为blob。blob对应于Java程序员在编写类时定义的内容：
- en: '| class NodeSize extends Node { ... } |'
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| class NodeSize extends Node { ... } |'
- en: Do Now!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始！
- en: So why are we going out of the way to not call it a “class”?
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 那么为什么我们要绕过不称其为“类”呢？
- en: When a developer invokes a Java class’s constructor, it in effect constructs
    objects all the way up the inheritance chain (in practice, a compiler might optimize
    this to require only one constructor invocation and one object allocation). These
    are private copies of the objects corresponding to the parent classes (private,
    that is, up to the presence of static members). There is, however, a question
    of how much of these objects is visible. Java chooses that—<wbr>unlike in our
    implementation above—<wbr>only one method of a given name (and signature) remains,
    no matter how many there might have been on the inheritance chain, whereas every
    field remains in the result, and can be accessed by casting. The latter makes
    some sense because each field presumably has invariants governing it, so keeping
    them separate (and hence all present) is wise. In contrast, it is easy to imagine
    an implementation that also makes all the methods available, not only the ones
    lowest (i.e., most refined) in the inheritance hierarchy. Many scripting languages
    take the latter approach.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员调用Java类的构造函数时，实际上会构造整个继承链上的对象（实际上，编译器可能会优化这一点，只需要一个构造函数调用和一个对象分配）。这些是对应于父类的对象的私有副本（私有，即直到静态成员的存在）。然而，有一个问题是这些对象的多少是可见的。Java选择了—<wbr>与我们上面的实现不同—<wbr>只有一个给定名称（和签名）的方法保留下来，无论继承链上可能有多少个，而每个字段都保留在结果中，并且可以通过转换访问。后者是有道理的，因为每个字段可能都有规定其内容的不变量，因此保持它们分开（因此全部存在）是明智的。相比之下，很容易想象一种实现方式，即使在继承层次结构中最低（即最精细）的方法也使所有方法都可用。许���脚本语言采用后一种方法。
- en: Exercise
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'The code above is fundamentally broken. The self reference is to the same syntactic
    object, whereas it needs to refer to the most-refined object: this is known as
    open recursion.This demonstrates the other form of extensibility we get from traditional
    objects: extensible recursion. Modify the object representations so that self
    always refers to the most refined version of the object. Hint: You will find the
    self-application method ([Self-Reference Without Mutation](#(part._self-ref-wout-mut)))
    of recursion handy.'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 上面的代码基本上是错误的。自我引用是指向相同的语法对象，而它需要引用最精细的对象：这被称为开放递归。这展示了我们从传统对象中获得的另一种可扩展性形式：可扩展递归。修改对象表示，使得self始终指向对象的最精细版本。提示：你会发现自我应用方法([无变异的自我引用](#(part._self-ref-wout-mut)))对递归很有用。
- en: 10.3.2Prototypes
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2原型
- en: 'In our description above, we’ve supplied each class with a description of its
    parent class. Object construction then makes instances of each as it goes up the
    inheritance chain. There is another way to think of the parent: not as a class
    to be instantiated but, instead, directly as an object itself. Then all children
    with the same parent would observe the very same object, which means changes to
    it from one child object would be visible to another child. The shared parent
    object is known as a prototype.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上面的描述中，我们为每个类提供了其父类的描述。然后对象构造会使每个实例沿着继承链向上走。还有另一种方式来考虑父类：不是作为一个要实例化的类，而是直接作为一个对象本身。然后所有具有相同父类的子类将观察到完全相同的对象，这意味着一个子对象对其进行的更改将对另一个子对象可见。共享的父对象被称为原型。
- en: 'The archetypal prototype-based language is [Self](http://selflanguage.org/).
    Though you may have read that languages like JavaScript are “based on” Self, there
    is value to studying the idea from its source, especially because Self presents
    these ideas in their purest form. Some language designers have argued that prototypes
    are more primitive than classes in that, with other basic mechanisms such as functions,
    one can recover classes from prototypes—<wbr>but not the other way around. That
    is essentially what we have done above: each “class” function contains inside
    it an object description, so a class is an object-returning-function. Had we exposed
    these are two different operations and chosen to inherit directly an object, we
    would have something akin to prototypes.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Modify the inheritance pattern above to implement a Self-like, prototype-based
    language, instead of a class-based language. Because classes provide each object
    with distinct copies of their parent objects, a prototype-language might provide
    a clone operation to simplify creation of the operation that simulates classes
    atop prototypes.
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 10.3.3Multiple Inheritance
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you might ask, why is there only one fall-through option? It’s easy to
    generalize this to there being many, which leads naturally to multiple inheritance.
    In effect, we have multiple objects to which we can chain the lookup, which of
    course raises the question of what order in which we should do so. It would be
    bad enough if the ascendants were arranged in a tree, because even a tree does
    not have a canonical order of traversal: take just breadth-first and depth-first
    traversal, for instance (each of which has compelling uses). Worse, suppose a
    blob A extends B and C; but now suppose B and C each extend D.This infamous situation
    is called diamond inheritance. If you choose to include multiple inheritance in
    your language you can lose yourself for days in design decisions on this. Because
    it is highly unlikely you will find a canonical answer, your pain will have only
    begun. Now we have to confront this question: will there be one or two D objects
    in the instance of A? Having only one saves space and might interact better with
    our expectations, but then, will we visit this object once or twice? Visiting
    it twice should not make any difference, so it seems unnecessary. But visiting
    it once means the behavior of one of B or C might change. And so on. As a result,
    virtually every multiple-inheritance language is accompanied by a subtle algorithm
    merely to define the lookup order.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance is only attractive until you’ve thought it through.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.4Super-Duper!
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many languages have a notion of super-invocations, i.e., the ability to invoke
    a method or access a field higher up in the inheritance chain.Note that I say
    “the” and “chain”. When we switch to multiple inheritance, these concepts are
    replaced with something much more complex. This includes doing so at the point
    of object construction, where there is often a requirement that all constructors
    be invoked, to make sure the object is properly defined.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'We have become so accustomed to thinking of these calls as going “up” the chain
    that we may have forgotten to ask whether this is the most natural direction.
    Keep in mind that constructors and methods are expected to enforce invariants.
    Whom should we trust more: the super-class or the sub-class? One argument would
    say that the sub-class is most refined, so it has the most global view of the
    object. Conversely, each super-class has a vested interest in protecting its invariants
    against violation by ignorant sub-classes.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: These are two fundamentally opposed views of what inheritance means. Going up
    the chain means we view the extension as replacing the parent. Going down the
    chain means we view the extension as refining the parent. Because we normally
    associate sub-classing with refinement, why do our languages choose the “wrong”
    order of calling? Some languages have, therefore, explored invocation in the downward
    direction by default.[gbeta](http://www.daimi.au.dk/~eernst/gbeta/) is a modern
    programming language that supports inner, as well as many other interesting features.
    It is also interesting to consider [combining both directions](http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 10.3.5Mixins and Traits
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s return to our “blobs”.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write a class in Java, what are we really defining between the opening
    and closing braces? It is not the entire class: that depends on the parent that
    it extends, and so on recursively. Rather, what we define inside the braces is
    a class extension. It only becomes a full-blown class because we also identify
    the parent class in the same place.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, we should ask: Why? Why not separate the act of defining an extension
    from applying the extension to a base class? That is, suppose instead of'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '| class C extends B { ... } |'
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'we instead write:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '| classext E { ... } |'
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: and separately
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '| class C = E(B) |'
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'where B is some already-defined class.Thusfar, it looks like we’ve just gone
    to great lengths to obtain what we had before. However, the function-application-like
    syntax is meant to be suggestive: we can “apply” this extension to several different
    base classes. Thus:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '| class C1 = E(B1); |'
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| class C2 = E(B2); |'
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'and so on. What we have done by separating the definition of E from that of
    the class it extends is to liberate class extensions from the tyranny of the fixed
    base class. We have a name for these extensions: they’re called mixins.The term
    “mixin” originated in Common Lisp, where it was a particular pattern of using
    multiple inheritance. Lipstick on a pig.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Mixins make class definition more compositional. They provide many of the benefits
    of multiple-inheritance (reusing multiple fragments of functionality) but within
    the aegis of a single-inheritance language (i.e., no complicated rules about lookup
    order). Observe that when desugaring, it’s actually quite easy to add mixins to
    the language. A mixin is primarily a “function over classes’;. Because we have
    already determined how to desugar classes, and our target language for desugaring
    also has functions, and classes desugar to expressions that can be nested inside
    functions, it becomes almost trivial to implement a simple model of mixins.This
    is a case where the greater generality of the target language of desugaring can
    lead us to a better construct, if we reflect it back into the source language.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'In a typed language, a good design for mixins can actually improve object-oriented
    programming practice. Suppose we’re defining a mixin-based version of Java. If
    a mixin is effectively a class-to-class function, what is the “type” of this “function”?
    Clearly, mixin ought to use interfaces to describe what it expects and provides.
    Java already enables (but does not require) the latter, but it does not enable
    the former: a class (extension) extends another class—<wbr>with all its members
    visible to the extension—<wbr>not its interface. That means it obtains all of
    the parent’s behavior, not a specification thereof. In turn, if the parent changes,
    the class might break.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: In a mixin language, we can instead write
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '| mixin M extends I { ... } |'
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: where I is an interface. Then M can only be applied to a class that satisfies
    the interface I, and in turn the language can ensure that only members specified
    in I are visible in M. This follows one of the important principles of good software
    design.“Program to an interface, not an implementation.” —<wbr>Design Patterns
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'A good design for mixins can go even further. A class can only be used once
    in an inheritance chain, by definition (if a class eventually referred back to
    itself, there would be a cycle in the inheritance chain, causing potential infinite
    loops). In contrast, when we compose functions, we have no qualms about using
    the same function twice (e.g.: (map ... (filter ... (map ...)))). Is there value
    to using a mixin twice?There certainly is! See sections 3 and 4 of [Classes and
    Mixins](http://www.cs.brown.edu/~sk/Publications/Papers/Published/fkf-classes-mixins/).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'Mixins solve an important problem that arises in the design of libraries. Suppose
    we have a dozen different features which can be combined in different ways. How
    many classes should we provide? Furthermore, not all of these can be combined
    with each other. It is obviously impractical to generate the entire combinatorial
    explosion of classes. It would be better if the devleoper could pick and choose
    the features they care about, with some mechanism to prevent unreasonable combinations.
    This is precisely the problem that mixins solve: they provide the class extensions,
    which the developers can combine, in an interface-preserving way, to create just
    the classes they need.Mixins are used extensively in the Racket GUI library. For
    instance, color:text-mixin consumes basic text editor interfaces and implements
    the colored text editor interface. The latter is iself a basic text editor interface,
    so additional basic text mixins can be applied to the result.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: How does your favorite object-oriented library solve this problem?
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Mixins do have one limitation: they enforce a linearity of composition. This
    strictness is sometimes misplaced, because it puts a burden on programmers that
    may not be necessary. A generalization of mixins called traits says that instead
    of extending a single mixin, we can extend a set of them. Of course, the moment
    we extend more than one, we must again contend with potential name-clashes. Thus
    traits must be equipped with mechanisms for resolving name clashes, often in the
    form of some name-combination algebra. Traits thus offer a nice complement to
    mixins, enabling programmers to choose the mechanism that best fits their needs.
    As a result, Racket provides both mixins and traits.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
