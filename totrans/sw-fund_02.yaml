- en: BasicsFunctional Programming in Coq
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Coq中的基本功能编程
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The functional programming style is founded on simple, everyday
  id: totrans-3
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 功能编程风格建立在简单的日常
- en: 'mathematical intuition: If a procedure or method has no side'
  id: totrans-4
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数学直觉：如果一个过程或方法没有副作用
- en: effects, then (ignoring efficiency) all we need to understand
  id: totrans-5
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 效果，那么（忽略效率）我们需要理解的一切
- en: about it is how it maps inputs to outputs — that is, we can think
  id: totrans-6
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它如何将输入映射到输出-也就是说，我们可以认为
- en: of it as just a concrete method for computing a mathematical
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将其视为计算数学
- en: function.  This is one sense of the word "functional" in
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: function。这是“functional”一词的一个意义
- en: '"functional programming."  The direct connection between programs'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: “功能编程”。程序之间的直接联系
- en: and simple mathematical objects supports both formal correctness
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和简单的数学对象支持形式上的正确性
- en: proofs and sound informal reasoning about program behavior.
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明和对程序行为进行合理的非正式推理。
- en: The other sense in which functional programming is "functional" is
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 功能编程是“functional”的另一种意义
- en: that it emphasizes the use of functions (or methods) as
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它强调函数（或方法）的使用
- en: '*first-class* values — i.e., values that can be passed as'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*第一类*值-即可以传递的值'
- en: arguments to other functions, returned as results, included in
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 传递给其他函数的参数，作为结果返回，包含在
- en: data structures, etc.  The recognition that functions can be
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据结构等。意识到函数可以
- en: treated as data gives rise to a host of useful and powerful
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 被视为数据会产生许多有用和强大的
- en: programming idioms.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编程习语。
- en: Other common features of functional languages include *algebraic data types*
    and *pattern matching*, which make it easy to
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 功能语言的其他常见特性包括*代数数据类型*和*模式匹配*，这使得
- en: construct and manipulate rich data structures, and sophisticated
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建和操作丰富的数据结构，以及复杂的
- en: '*polymorphic type systems* supporting abstraction and code reuse.'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*多态类型系统*支持抽象和代码重用。'
- en: Coq offers all of these features.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq提供了所有这些功能。
- en: The first half of this chapter introduces the most essential
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本章的前半部分介绍了最基本的
- en: elements of Coq's functional programming language, called
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq的功能编程语言的元素，称为
- en: '*Gallina*.  The second half introduces some basic *tactics* that'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*Gallina*。后半部分介绍了一些基本的*tactics*'
- en: can be used to prove properties of Coq programs.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可用于证明Coq程序的属性。
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Days of the Week
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一周的日子
- en: To see how this definition mechanism works, let's start with
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看看这个定义机制是如何工作的，让我们从
- en: a very simple example.  The following declaration tells Coq that
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个非常简单的例子。以下声明告诉Coq
- en: we are defining a new set of data values — a *type*.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在定义一组新的数据值-一个*类型*。
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The type is called day, and its members are monday,
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型称为day，其成员是monday，
- en: tuesday, etc.  The second and following lines of the definition
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 星期二等。定义的第二行和后续行
- en: can be read "monday is a day, tuesday is a day, etc."
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以阅读“星期一是一天，星期二是一天，等等”
- en: Having defined day, we can write functions that operate on
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义了day之后，我们可以编写操作day的函数
- en: days.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 天。
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: One thing to note is that the argument and return types of
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要注意的一点是这个函数的参数和返回类型
- en: this function are explicitly declared.  Like most functional
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数是显式声明的。像大多数功能
- en: programming languages, Coq can often figure out these types for
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编程语言，Coq通常可以为这些类型找到
- en: itself when they are not given explicitly — i.e., it can do *type inference*
    — but we'll generally include them to make reading
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当它们没有明确给出时，它可以自行推断类型-但我们通常会包括它们以便阅读
- en: easier.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更容易。
- en: Having defined a function, we should check that it works on
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义了一个函数后，我们应该检查它在
- en: some examples.  There are actually three different ways to do this
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些例子。实际上有三种不同的方法来做到这一点
- en: in Coq.  First, we can use the command Compute to evaluate a
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Coq中。首先，我们可以使用Compute命令来评估一个
- en: compound expression involving next_weekday.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包含next_weekday的复合表达式。
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: (We show Coq's responses in comments, but, if you have a
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （我们在注释中展示Coq的响应，但是，如果你有一个
- en: computer handy, this would be an excellent moment to fire up the
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 电脑方便的话，现在是启动
- en: Coq interpreter under your favorite IDE — either CoqIde or Proof
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq解释器在您喜欢的IDE��-无论是CoqIde还是Proof
- en: General — and try this for yourself.  Load this file, Basics.v,
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一般-并尝试自己做这个。加载这个文件，Basics.v，
- en: from the book's Coq sources, find the above example, submit it to
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从书中的Coq源代码中，找到上面的例子，提交给
- en: Coq, and observe the result.)
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq，并观察结果。）
- en: Second, we can record what we *expect* the result to be in the
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其次，我们可以记录我们*期望*结果是什么
- en: 'form of a Coq example:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq示例的形式：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This declaration does two things: it makes an'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个声明做了两件事：它使一个
- en: assertion (that the second weekday after saturday is tuesday),
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 断言（即周六后的第二个工作日是星期二），
- en: and it gives the assertion a name that can be used to refer to it
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并且给出了一个可以用来引用它的名称
- en: later.  Having made the assertion, we can also ask Coq to verify
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之后。做出了断言后，我们还可以要求 Coq 验证
- en: 'it, like this:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它，就像这样：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The details are not important for now (we'll come back to
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在不重要（我们会回来
- en: them in a bit), but essentially this can be read as "The assertion
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 他们稍微），但基本上可以理解为“断言
- en: we've just made can be proved by observing that both sides of the
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们刚刚做出的可以通过观察证明，两边都是
- en: equality evaluate to the same thing, after some simplification."
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相等性在一些简化后会得到相同的结果。”
- en: Third, we can ask Coq to *extract*, from our Definition, a
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第三，我们可以要求 Coq 从我们的定义中*提取*
- en: program in some other, more conventional, programming
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在其他一些更传统的编程
- en: language (OCaml, Scheme, or Haskell) with a high-performance
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 语言（OCaml、Scheme 或 Haskell）与高性能
- en: compiler.  This facility is very interesting, since it gives us a
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编译器。这个设施非常有趣，因为它给了我们
- en: way to go from proved-correct algorithms written in Gallina to
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从用 Gallina 编写的经过验证的算法到
- en: efficient machine code.  (Of course, we are trusting the
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 高效的机器代码。（当然，我们信任
- en: correctness of the OCaml/Haskell/Scheme compiler, and of Coq's
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: OCaml/Haskell/Scheme 编译器的正确性，以及 Coq 的
- en: extraction facility itself, but this is still a big step forward
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提取设施本身，但这仍然是一个重要的进步
- en: from the way most software is developed today.) Indeed, this is
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从今天大多数软件开发的方式。）实际上，这是
- en: one of the main uses for which Coq was developed.  We'll come back
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq 开发的主要用途之一。我们会回来
- en: to this topic in later chapters.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对这个主题在后面的章节中。
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Booleans
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: In a similar way, we can define the standard type bool of
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以定义标准类型 bool 的
- en: booleans, with members true and false.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 布尔值，具有成员 true 和 false。
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Although we are rolling our own booleans here for the sake
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然我们为了
- en: of building up everything from scratch, Coq does, of course,
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从头开始构建一切，当然，Coq
- en: provide a default implementation of the booleans, together with a
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提供布尔值的默认实现，以及
- en: multitude of useful functions and lemmas.  (Take a look at
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大量有用的函数和引理。（看一看
- en: Coq.Init.Datatypes in the Coq library documentation if you're
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq.Init.Datatypes，如果您感兴趣
- en: interested.)  Whenever possible, we'll name our own definitions
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 感兴趣。）在可能的情况下，我们会为我们自己的定义命名
- en: and theorems so that they exactly coincide with the ones in the
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和定理，使它们与
- en: standard library.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标准库。
- en: Functions over booleans can be defined in the same way as
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 布尔值的函数可以以与
- en: 'above:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上面：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The last two of these illustrate Coq's syntax for
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个是 Coq 用于
- en: multi-argument function definitions.  The corresponding
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多参数函数定义。相应的
- en: multi-argument application syntax is illustrated by the following
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多参数应用语法由以下示例说明
- en: '"unit tests," which constitute a complete specification — a truth'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: “单元测试”，构成一个完整的规范 — 一个真理
- en: 'table — for the orb function:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表格 — 对于 orb 函数：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can also introduce some familiar syntax for the boolean
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以为布尔值引入一些熟悉的语法
- en: operations we have just defined. The Infix command defines a new
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们刚刚定义的操作。Infix 命令定义了一个新的
- en: symbolic notation for an existing definition.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对现有定义进行符号表示。
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*A note on notation*: In .v files, we use square brackets'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*关于符号的说明*：在 .v 文件中，我们使用方括号'
- en: to delimit fragments of Coq code within comments; this convention,
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用注释来界定 Coq 代码片段；这种约定，
- en: also used by the coqdoc documentation tool, keeps them visually
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也被 coqdoc 文档工具使用，使它们在视觉上保持一致
- en: separate from the surrounding text.  In the html version of the
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与周围文本分开。在 html 版本中
- en: files, these pieces of text appear in a different font.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件，这些文本片段以不同的字体出现。
- en: The command Admitted can be used as a placeholder for an
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令 Admitted 可以用作
- en: incomplete proof.  We'll use it in exercises, to indicate the
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不完整的证明。我们将在练习中使用它，以指示
- en: parts that we're leaving for you — i.e., your job is to replace
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们留给你的部分 — 即，你的工作是替换
- en: Admitteds with real proofs.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 具有真正证明的 Admitteds。
- en: 'Exercise: 1 star (nandb)'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1 星（nandb）
- en: Remove "Admitted." and complete the definition of the following
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 删除“Admitted.” 并完成以下定义
- en: function; then make sure that the Example assertions below can
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数；然后确保下面的示例断言可以
- en: each be verified by Coq.  (Remove "Admitted." and fill in each
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个都可以由 Coq 验证。（删除“Admitted.” 并填写每个
- en: proof, following the model of the orb tests above.) The function
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明，遵循上面 orb 测试的模型。）该函数
- en: should return true if either or both of its inputs are
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果其输入的一个或两个是真，则应返回 true
- en: false.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假。
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ☐
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 1 star (andb3)'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1星（andb3）
- en: Do the same for the andb3 function below. This function should
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于下面的andb3函数做同样的事情。 这个函数应该
- en: return true when all of its inputs are true, and false
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当其所有输入都为true时返回true，否则返回false
- en: otherwise.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则。
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ☐
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Check true.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 true.
- en: (* ===> true : bool *)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> true : bool *)
- en: Check (negb true).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 (negb true).
- en: (* ===> negb true : bool *)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> negb true : bool *)
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Check negb.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 检查negb。
- en: (* ===> negb : bool -> bool *)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> negb : bool -> bool *)
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Modules
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: Coq provides a *module system*, to aid in organizing large
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq提供了一个*模块系统*，以帮助组织大型的
- en: developments.  In this course we won't need most of its features,
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 发展。 在这门课程中，我们不需要大多数的功能
- en: 'but one is useful: If we enclose a collection of declarations'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是有一个很有用的：如果我们围绕一组声明
- en: between Module X and End X markers, then, in the remainder of
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在模块X和End X标记之间，然后在剩余部分中
- en: the file after the End, these definitions are referred to by
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在End之后，这些定义被引用为
- en: names like X.foo instead of just foo.  We will use this
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 名称如 X.foo 而不仅仅是 foo。 我们将使用这个
- en: feature to introduce the definition of the type nat in an inner
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 功能，引入内部的nat类型定义
- en: module so that it does not interfere with the one from the
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模块，以便它不会干扰来自
- en: standard library (which we want to use in the rest because it
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标准库（因为它
- en: comes with a tiny bit of convenient special notation).
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 带有一点方便的特殊符号）。
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Numbers
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: The types we have defined so far are examples of "enumerated
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止我们已经定义的类型是“列举的
- en: 'types": their definitions explicitly enumerate a finite set of'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型”：它们的定义明确列举了一个有限的集合
- en: elements.  A more interesting way of defining a type is to give a
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 元素。 定义类型的更有趣的方法是给出一个
- en: collection of *inductive rules* describing its elements.  For
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一组描述其元素的*归纳规则*。对于
- en: example, we can define (a unary representation of) the natural
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，我们可以定义（一种一元表示的）自然数
- en: 'numbers as follows:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数字如下：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The clauses of this definition can be read:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个定义的子句可以被理解为：
- en: O is a natural number (note that this is the letter "O," not the numeral "0").
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O是一个自然数（请注意这是字母“O”，不是数字“0”）。
- en: S is a "constructor" that takes a natural number and yields another one — that
    is, if n is a natural number, then S n is too.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S 是一个“构造函数”，它接受一个自然数并产生另一个自然数 — 即，如果 n 是一个自然数，那么 S n 也是。
- en: Let's look at this in a little more detail.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们稍微详细地看一下这个。
- en: Every inductively defined set (day, nat, bool, etc.) is
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个归纳定义的集合（day、nat、bool等）都是
- en: actually a set of *expressions* built from *constructors*
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上是一组*从*构造函数*构建的*表达式
- en: like O, S, true, false, monday, etc.  The definition of
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 像 O、S、true、false、monday 等。 定义
- en: 'nat says how expressions in the set nat can be built:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: nat 表示集合 nat 中的表达式如何构建：
- en: O and S are constructors;
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O 和 S 是构造函数;
- en: the expression O belongs to the set nat;
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式O属于集合nat；
- en: if n is an expression belonging to the set nat, then S n is also an expression
    belonging to the set nat; and
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 n 是属于集合 nat 的表达式，则 S n 也是属于集合 nat 的表达式；以及
- en: expressions formed in these two ways are the only ones belonging to the set
    nat.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用这两种方式形成的表达式是属于集合 nat 的唯一的表达式。
- en: The same rules apply for our definitions of day and
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的day和
- en: bool. (The annotations we used for their constructors are
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: bool。 （我们用于它们的构造函数的注释是
- en: analogous to the one for the O constructor, indicating that they
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 O 构造函数的类似，指示它们
- en: don't take any arguments.)
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不带任何参数。)
- en: The above conditions are the precise force of the Inductive
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述条件是归纳的准确含义
- en: declaration.  They imply that the expression O, the expression
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明。 它们意味着表达式 O、表达式
- en: S O, the expression S (S O), the expression S (S (S O)), and
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: S O、表达式 S (S O)、表达式 S (S (S O))，以及
- en: so on all belong to the set nat, while other expressions built
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有都属于集合 nat，而其他构建的表达式
- en: from data constructors, like true, andb true false, S (S false), and O (O (O
    S)) do not.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 来自数据构造函数，如 true、andb true false、S (S false) 和 O (O (O S)) 不会。
- en: A critical point here is that what we've done so far is just to
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里的关键点是到目前为止我们所做的只是
- en: 'define a *representation* of numbers: a way of writing them down.'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义数字的 *表示*：一种书写它们的方式。
- en: The names O and S are arbitrary, and at this point they have
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 名称 O 和 S 是任意的，在这一点上它们有
- en: no special meaning — they are just two different marks that we
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有特殊的意义 —— 它们只是两种不同的标记，我们
- en: can use to write down numbers (together with a rule that says any
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以用来写下数字（连同一个规则，规定任何
- en: nat will be written as some string of S marks followed by an
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: nat 将被写成一些 S 标记的字符串，后跟一个
- en: O).  If we like, we can write essentially the same definition
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: O）。 如果愿意，我们可以写基本相同的定义
- en: 'this way:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The *interpretation* of these marks comes from how we use them to
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些标记的*解释*来自于我们如何使用它们来
- en: compute.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算。
- en: We can do this by writing functions that pattern match on
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过编写在上面的函数进行这样的操作
- en: representations of natural numbers just as we did above with
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自然数的表示法，就像我们上面所做的那样
- en: booleans and days — for example, here is the predecessor
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 布尔值和天数——例如，这是前任者
- en: 'function:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The second branch can be read: "if n has the form S n'''
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以读取第二个分支：“如果n的形式是S n'
- en: for some n', then return n'."
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于一些n'，然后返回n'。”
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Because natural numbers are such a pervasive form of data,
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为自然数是如此普遍的数据形式，
- en: Coq provides a tiny bit of built-in magic for parsing and printing
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq为解析和打印提供了一点内置的魔法
- en: 'them: ordinary arabic numerals can be used as an alternative to'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 他们之间：普通的阿拉伯数字可以用作替代
- en: the "unary" notation defined by the constructors S and O.  Coq
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由构造函数S和O定义的“一元”表示法。 Coq
- en: 'prints numbers in arabic form by default:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下以阿拉伯形式打印数字：
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The constructor S has the type nat → nat, just like the
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构造函数S的类型为nat → nat，就像
- en: 'functions minustwo and pred:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数minustwo和pred：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: These are all things that can be applied to a number to yield a
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些都是可以应用于数字的事物，以产生一个
- en: number.  However, there is a fundamental difference between the
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数字。 但是，普通的阿拉伯数字可以用作的基本区别
- en: 'first one and the other two: functions like pred and minustwo'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个和其他两个：像前任者和减去两个这样的函数
- en: come with *computation rules* — e.g., the definition of pred
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 附带*计算规则*——例如，pred的定义
- en: says that pred 2 can be simplified to 1 — while the
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示pred 2可以简化为1——而
- en: definition of S has no such behavior attached.  Although it is
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: S的定义没有附加此类行为。 虽然它是
- en: like a function in the sense that it can be applied to an
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像一个函数一样，因为它可以应用于一个
- en: argument, it does not *do* anything at all!  It is just a way of
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数，它根本不*做*任何事情！ 这只是一种
- en: 'writing down numbers.  (Think about standard arabic numerals: the'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 写下数字。（想想标准的阿拉伯数字：这个
- en: numeral 1 is not a computation; it's a piece of data.  When we
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数字1不是计算； 它是一块数据。 当我们
- en: write 111 to mean the number one hundred and eleven, we are
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 写`111`来表示数字一百十一，我们是
- en: using 1, three times, to write down a concrete representation of
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用1，三次，来写下具体的表示
- en: a number.)
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个数字。）
- en: For most function definitions over numbers, just pattern matching
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于大多数针对数字的函数定义，只是模式匹配
- en: 'is not enough: we also need recursion.  For example, to check that'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不够：我们还需要递归。 例如，要检查
- en: a number n is even, we may need to recursively check whether
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个数字n是偶数，我们可能需要递归地检查是否
- en: n-2 is even.  To write such functions, we use the keyword
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: n-2是偶数。 为了编写这样的函数，我们使用关键字
- en: Fixpoint.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不动点。
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can define oddb by a similar Fixpoint declaration, but here
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过类似的Fixpoint声明来定义oddb，但是这里
- en: 'is a simpler definition:'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是一个更简单的定义：
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: (You will notice if you step through these proofs that
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （如果您逐步执行这些证明，您会注意到
- en: simpl actually has no effect on the goal — all of the work is
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简化实际上对目标没有任何影响——所有工作都是
- en: done by reflexivity.  We'll see more about why that is shortly.)
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由反射完成。 我们很快会看到更多关于为什么的内容。）
- en: Naturally, we can also define multi-argument functions by
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，我们也可以通过
- en: recursion.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 递归。
- en: '[PRE26]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Adding three to two now gives us five, as we'd expect.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在将三加到两上给了我们五，正如我们所预期的那样。
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The simplification that Coq performs to reach this conclusion can
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq执行的简化达到这个结论可能会
- en: 'be visualized as follows:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以可视化如下：
- en: '[PRE28]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As a notational convenience, if two or more arguments have
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为一种方便的表示法，如果两个或更多个参数有
- en: the same type, they can be written together.  In the following
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相同的类型，它们可以一起写。 在下面
- en: 'definition, (n m : nat) means just the same as if we had written'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义，（n m：nat）意味着与我们写的一样
- en: '(n : nat) (m : nat).'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （n：nat）（m：nat）。
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can match two expressions at once by putting a comma
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以通过放置逗号同时匹配两个表达式
- en: 'between them:'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之间：
- en: '[PRE30]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The _ in the first line is a *wildcard pattern*.  Writing _ in a
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一行中的_是一个*通配符模式*。 在一中写入_是一个
- en: pattern is the same as writing some variable that doesn't get used
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模式与编写不使用的某个变量相同
- en: on the right-hand side.  This avoids the need to invent a variable
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在右侧。 这样可以避免发明一个变量
- en: name.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 名字。
- en: '[PRE31]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Exercise: 1 star (factorial)'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1星（阶乘）
- en: 'Recall the standard mathematical factorial function:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回忆标准数学阶乘函数：
- en: '[PRE32]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Translate this into Coq.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将此翻译为Coq。
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ☐
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: We can make numerical expressions a little easier to read and
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使数值表达式更容易阅读和
- en: write by introducing *notations* for addition, multiplication, and
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 写入引入*符号*以进行加法，乘法和
- en: subtraction.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 减法。
- en: '[PRE34]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: (The level, associativity, and nat_scope annotations
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （级别，结合性和nat_scope注释
- en: control how these notations are treated by Coq's parser.  The
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 控制这些符号是如何由Coq的解析器处理的。该
- en: details are not important for our purposes, but interested readers
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 细节对我们的目的来说并不重要，但感兴趣的读者
- en: can refer to the optional "More on Notation" section at the end of
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以参考可选的“关于符号的更多信息”部分
- en: this chapter.)
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本章。）
- en: 'Note that these do not change the definitions we''ve already made:'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，这些不会改变我们已经做出的定义：
- en: they are simply instructions to the Coq parser to accept x + y
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们只是告诉Coq解析器接受x + y
- en: in place of plus x y and, conversely, to the Coq pretty-printer
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而不是将x + y和相反的加法器
- en: to display plus x y as x + y.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以显示加法的加法x y为x + y。
- en: When we say that Coq comes with almost nothing built-in, we really
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们说Coq几乎没有内置任何内容时，我们真的是
- en: 'mean it: even equality testing for numbers is a user-defined'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 意思是：即使对数字的相等性测试也是用户定义的
- en: operation!  We now define a function beq_nat, which tests
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 操作！我们现在定义了一个函数beq_nat，用于测试
- en: natural numbers for equality, yielding a boolean.  Note the
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自然数的相等性，产生一个布尔值。 请注意
- en: use of nested matches (we could also have used a simultaneous
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用嵌套匹配（我们也可以同时使用
- en: match, as we did in minus.)
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 匹配，就像我们在减法中所做的一样。）
- en: '[PRE35]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The leb function tests whether its first argument is less than or
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数leb测试其第一个参数是否小于或
- en: equal to its second argument, yielding a boolean.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 等于它的第二个参数，产生一个布尔值。
- en: '[PRE36]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Exercise: 1 star (blt_nat)'
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1星（blt_nat）
- en: The blt_nat function tests natural numbers for less-than,
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数blt_nat用于测试自然数的大小，
- en: yielding a boolean.  Instead of making up a new Fixpoint for
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 产生一个布尔值。 不要制作新的Fixpoint
- en: this one, define it in terms of a previously defined function.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是将其定义为先前定义的函数。
- en: '[PRE37]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ☐
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE38]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Theorem plus_O_n : ∀n : nat, 0 + n = n.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 定理plus_O_n：∀n：nat，0 + n = n。
- en: Proof.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n. simpl. reflexivity. Qed.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 引入n。 简化。 一致性。 QED。
- en: '[PRE39]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Theorem plus_O_n'' : ∀n : nat, 0 + n = n.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 定理plus_O_n'：∀n：nat，0 + n = n。
- en: Proof.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n. reflexivity. Qed.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 引入n。 一致性。 QED。
- en: '[PRE40]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Theorem plus_1_l : ∀n:nat, 1 + n = S n.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 定理plus_1_l：∀n:nat，1 + n = S n。
- en: Proof.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n. reflexivity. Qed.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 引入n。 一致性。 QED。
- en: 'Theorem mult_0_l : ∀n:nat, 0 * n = 0.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 定理mult_0_l：∀n:nat，0 * n = 0。
- en: Proof.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n. reflexivity. Qed.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 引入n。 一致性。 QED。
- en: '[PRE41]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Theorem plus_n_O : ∀n, n = n + 0.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 定理plus_n_O：∀n，n = n + 0。
- en: Proof.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n. simpl. (* Doesn't do anything! *)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 引入n。 简化。 （不做任何事情！）
- en: '[PRE42]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Abort.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 中止。
- en: '[PRE43]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Proof by Rewriting
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重写证明
- en: This theorem is a bit more interesting than the others we've
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个定理比我们以前的其他定理更有趣
- en: 'seen:'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看到：
- en: '[PRE44]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Instead of making a universal claim about all numbers n and m,
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不是对所有数字n和m做出普遍断言，
- en: it talks about a more specialized property that only holds when n = m.  The
    arrow symbol is pronounced "implies."
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它谈到了一个更专业的性质，仅当n = m时才成立。箭头符号发音为“意味着”。
- en: As before, we need to be able to reason by assuming we are given such
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前所述，我们需要能够假设我们已经拥有
- en: numbers n and m.  We also need to assume the hypothesis
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数字n和m。 我们还需要假设假设
- en: n = m. The intros tactic will serve to move all three of these
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: n = m。 引入策略将用于移动所有这三个
- en: from the goal into assumptions in the current context.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从目标到当前上下文中的假设。
- en: Since n and m are arbitrary numbers, we can't just use
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于n和m是任意数字，我们不能只是使用
- en: simplification to prove this theorem.  Instead, we prove it by
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过简化来证明这个定理。 相反，我们通过
- en: observing that, if we are assuming n = m, then we can replace
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 观察到，如果我们假设n = m，那么我们可以替换
- en: n with m in the goal statement and obtain an equality with the
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: n与m在目标语句中，并获得与
- en: same expression on both sides.  The tactic that tells Coq to
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两边都是相同的表达式。 告诉Coq的策略
- en: perform this replacement is called rewrite.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行此替换称为重写。
- en: '[PRE45]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The first line of the proof moves the universally quantified
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明的第一行移动了普遍量化的
- en: variables n and m into the context.  The second moves the
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变量n和m到上下文中。 第二个移动了
- en: hypothesis n = m into the context and gives it the name H.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设n = m并将其命名为H。
- en: The third tells Coq to rewrite the current goal (n + n = m + m)
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第三个告诉Coq重写当前目标（n + n = m + m）
- en: by replacing the left side of the equality hypothesis H with the
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过用等式假设H的左侧替换。
- en: right side.
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 右侧。
- en: (The arrow symbol in the rewrite has nothing to do with
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （重写中的箭头符号与这个函数无关，
- en: 'implication: it tells Coq to apply the rewrite from left to right.'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 意味着：它告诉Coq应用从左到右的重写。
- en: To rewrite from right to left, you can use rewrite ←.  Try
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要从右到左重写，可以使用rewrite ←。 尝试
- en: making this change in the above proof and see what difference it
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 进行这种更改在上面的证明中并看看有什么不同
- en: makes.)
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使得。）
- en: 'Exercise: 1 star (plus_id_exercise)'
  id: totrans-338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1 星（plus_id_exercise）
- en: Remove "Admitted." and fill in the proof.
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 删除 "Admitted." 并填写证明。
- en: '[PRE46]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ☐
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: The Admitted command tells Coq that we want to skip trying
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Admitted 命令告诉 Coq 我们要跳过尝试
- en: to prove this theorem and just accept it as a given.  This can be
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了证明这个定理并将其接受为给定的。这可以
- en: useful for developing longer proofs, since we can state subsidiary
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于开发更长证明很有用，因为我们可以陈述附属的
- en: lemmas that we believe will be useful for making some larger
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们相信这些引理对于构建一些更大的
- en: argument, use Admitted to accept them on faith for the moment,
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数，使用 Admitted 来暂时接受它们的真实性，
- en: and continue working on the main argument until we are sure it
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并继续处理主要参数，直到我们确定它
- en: makes sense; then we can go back and fill in the proofs we
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有意义；然后我们可以回去填写我们
- en: 'skipped.  Be careful, though: every time you say Admitted you'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 跳过。但是要小心：每次说 Admitted 时，您
- en: are leaving a door open for total nonsense to enter Coq's nice,
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 留下一个门打开，让完全无意义的东西进入 Coq 的美好，
- en: rigorous, formally checked world!
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 严格的，形式上检查过的世界！
- en: We can also use the rewrite tactic with a previously proved
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以使用 rewrite 策略与先前证明的
- en: theorem instead of a hypothesis from the context. If the statement
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定理而不是上下文中的假设。如果陈述
- en: of the previously proved theorem involves quantified variables,
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 先前证明的定理涉及量化变量，
- en: as in the example below, Coq tries to instantiate them
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像下面的例子中一样，Coq 尝试实例化它们
- en: by matching with the current goal.
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过与当前目标匹配。
- en: '[PRE47]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Exercise: 2 stars (mult_S_1)'
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2 星（mult_S_1）
- en: '[PRE48]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ☐
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE49]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Theorem plus_1_neq_0_firsttry : ∀n : nat,'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 plus_1_neq_0_firsttry: ∀n：nat，'
- en: beq_nat (n + 1) 0 = false.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: beq_nat (n + 1) 0 = false。
- en: Proof.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 n。
- en: simpl. (* does nothing! *)
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。（* 什么也不做！ *）
- en: Abort.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃。
- en: '[PRE50]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Theorem plus_1_neq_0 : ∀n : nat,'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 plus_1_neq_0：∀n：nat，
- en: beq_nat (n + 1) 0 = false.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: beq_nat (n + 1) 0 = false。
- en: Proof.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n. destruct n as [| n'].
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 n。分解 n 为 [| n']。
- en: '- reflexivity.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反射性。'
- en: '- reflexivity. Qed.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反射性。证毕。'
- en: '[PRE51]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Theorem negb_involutive : ∀b : bool,'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 negb_involutive：∀b：bool，
- en: negb (negb b) = b.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: negb (negb b) = b。
- en: Proof.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros b. destruct b.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 b。分解 b。
- en: '- reflexivity.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反射性。'
- en: '- reflexivity. Qed.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反射性。证毕。'
- en: '[PRE52]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Theorem andb_commutative : ∀b c, andb b c = andb c b.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 andb_commutative: ∀b c，andb b c = andb c b。'
- en: Proof.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros b c. destruct b.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 b c。分解 b。
- en: '- destruct c.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '- 分解 c。'
- en: + reflexivity.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: + 反射性。
- en: + reflexivity.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: + 反射性。
- en: '- destruct c.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '- 分解 c。'
- en: + reflexivity.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: + 反射性。
- en: + reflexivity.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: + 反射性。
- en: Qed.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 证毕。
- en: '[PRE53]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Theorem andb_commutative'' : ∀b c, andb b c = andb c b.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 andb_commutative'：∀b c，andb b c = andb c b。
- en: Proof.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros b c. destruct b.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 b c。分解 b。
- en: '{ destruct c.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 分解 c。'
- en: '{ reflexivity. }'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 反射性。}'
- en: '{ reflexivity. } }'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 反射性。} }'
- en: '{ destruct c.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 分解 c。'
- en: '{ reflexivity. }'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 反射性。}'
- en: '{ reflexivity. } }'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 反射性。} }'
- en: Qed.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 证毕。
- en: '[PRE54]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Theorem andb3_exchange :'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 andb3_exchange：
- en: ∀b c d, andb (andb b c) d = andb (andb b d) c.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: ∀b c d，andb (andb b c) d = andb (andb b d) c。
- en: Proof.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros b c d. destruct b.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 b c d。分解 b。
- en: '- destruct c.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '- 分解 c。'
- en: '{ destruct d.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 分解 d。'
- en: '- reflexivity.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反射性。'
- en: '- reflexivity. }'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反射性。}'
- en: '{ destruct d.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 分解 d。'
- en: '- reflexivity.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反射性。'
- en: '- reflexivity. }'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反射性。}'
- en: '- destruct c.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '- 分解 c。'
- en: '{ destruct d.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 分解 d。'
- en: '- reflexivity.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反射性。'
- en: '- reflexivity. }'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反射性。}'
- en: '{ destruct d.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 分解 d。'
- en: '- reflexivity.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反射性。'
- en: '- reflexivity. }'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反射性。}'
- en: Qed.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 证毕。
- en: '[PRE55]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: intros x y. destruct y as [|y].
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 x y。分解 y 为 [|y]。
- en: 'This pattern is so common that Coq provides a shorthand for it: we'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种模式是如此常见，以至于 Coq 为其提供了一个简写：我们
- en: can perform case analysis on a variable when introducing it by
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当引入一个变量时，可以对其执行案例分析
- en: using an intro pattern instead of a variable name. For instance,
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用一个引入模式而不是一个变量名。例如，
- en: here is a shorter proof of the plus_1_neq_0 theorem above.
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是上面的 plus_1_neq_0 定理的更短证明。
- en: '[PRE56]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If there are no arguments to name, we can just write [].
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有要命名的参数，我们可以只写 []。
- en: '[PRE57]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Exercise: 2 stars (andb_true_elim2)'
  id: totrans-433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2 星（andb_true_elim2）
- en: Prove the following claim, marking cases (and subcases) with
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明以下声明，使用
- en: bullets when you use destruct.
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你使用 destruct 时，请使用项目符号。
- en: '[PRE58]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ☐
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 1 star (zero_nbeq_plus_1)'
  id: totrans-438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1 星（zero_nbeq_plus_1）
- en: '[PRE59]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ☐
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE60]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Notation "x + y" := (plus x y)
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 记号 "x + y" := (plus x y)
- en: (at level 50, left associativity)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: （在 50 级，左结合性）
- en: ': nat_scope.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: ：nat_scope。
- en: Notation "x * y" := (mult x y)
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 记号 "x * y" := (mult x y)
- en: (at level 40, left associativity)
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: （在 40 级，左结合性）
- en: ': nat_scope.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: ：nat_scope。
- en: '[PRE61]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Fixpoints and Structural Recursion (Optional)
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定点和结构递归（可选）
- en: 'Here is a copy of the definition of addition:'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是加法的定义副本：
- en: '[PRE62]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: When Coq checks this definition, it notes that plus' is
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当 Coq 检查这个定义时，它注意到 plus' 是
- en: '"decreasing on 1st argument."  What this means is that we are'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"第一个参数递减"。这意味着我们'
- en: performing a *structural recursion* over the argument n — i.e.,
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行 *结构递归* 时，i.e.，
- en: that we make recursive calls only on strictly smaller values of
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们只对严格较小的值进行递归调用
- en: n.  This implies that all calls to plus' will eventually
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: n。这意味着对 plus' 的所有调用最终将
- en: terminate.  Coq demands that some argument of *every* Fixpoint
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 终止。Coq 要求每个 Fixpoint 的某个参数
- en: definition is "decreasing."
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义是 "递减的"。
- en: 'This requirement is a fundamental feature of Coq''s design: In'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此要求是 Coq 设计的一个基本特征：在
- en: particular, it guarantees that every function that can be defined
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 特别是，它保证可以定义的每个函数
- en: in Coq will terminate on all inputs.  However, because Coq's
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Coq 中将对所有输入终止。然而，由于 Coq 的
- en: '"decreasing analysis" is not very sophisticated, it is sometimes'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"递减分析"并不是非常复杂，有时候'
- en: necessary to write functions in slightly unnatural ways.
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写函数时需要以稍微不自然的方式编写。
- en: 'Exercise: 2 stars, optional (decreasing)'
  id: totrans-464
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2 星，可选（递减）
- en: To get a concrete sense of this, find a way to write a sensible
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要具体了解这一点，找到一种合理的方式编写一个
- en: Fixpoint definition (of a simple function on numbers, say) that
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义（比如一个简单的数字函数）的参数
- en: '*does* terminate on all inputs, but that Coq will reject because'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*确实* 在所有输入上终止，但 Coq 会拒绝，因为'
- en: of this restriction.
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个限制。
- en: '[PRE63]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ☐
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE64]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Theorem identity_fn_applied_twice :'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 identity_fn_applied_twice：
- en: '∀(f : bool → bool),'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '∀(f : bool → bool)，'
- en: '(∀(x : bool), f x = x) →'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '(∀(x : bool)，f x = x) →'
- en: '∀(b : bool), f (f b) = b.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '∀(b : bool)，f (f b) = b。'
- en: Proof.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填入 *) 已被承认。
- en: '[PRE65]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: (* FILL IN HERE *)
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填入 *)
- en: '[PRE66]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Theorem andb_eq_orb :'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 andb_eq_orb：
- en: '∀(b c : bool),'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '∀(b c : bool)，'
- en: (andb b c = orb b c) →
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: （andb b c = orb b c）→
- en: b = c.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: b = c。
- en: Proof.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: Proof。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填入 *) 已被承认。
- en: '[PRE67]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Inductive nat : Type := | O : nat | S : nat → nat.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: Inductive nat：Type := | O：nat | S：nat → nat。
- en: says nothing about what O and S "mean."  It just says "O is
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对 O 和 S 的“含义”一无所知。它只是说“O 是
- en: in the set called nat, and if n is in the set then so is S n."  The interpretation
    of O as zero and S as successor/plus
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在集合中叫做 nat，并且如果 n 在集合中，则 S n 也在其中。”将 O 解释为零，S 解释为后继/加法
- en: one comes from the way that we *use* nat values, by writing
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是由于我们 *使用* nat 值的方式，
- en: functions to do things with them, proving things about them, and
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 处理它们的功能，证明与它们相关的事实，
- en: so on.  Your definition of bin should be correspondingly simple;
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等等。你的 bin 的定义应该相应地简单；
- en: it is the functions you will write next that will give it
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它是你接下来将要编写的函数
- en: mathematical meaning.)
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数学含义。）
- en: (b) Next, write an increment function incr for binary numbers,
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （b）接下来，为二进制数编写一个增量函数incr，
- en: and a function bin_to_nat to convert binary numbers to unary
  id: totrans-497
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以及一个将二进制数转换为一进制的函数 bin_to_nat
- en: numbers.
  id: totrans-498
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数字。
- en: (c) Write five unit tests test_bin_incr1, test_bin_incr2, etc.
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （c）编写五个单元测试 test_bin_incr1、test_bin_incr2 等。
- en: for your increment and binary-to-unary functions.  (A "unit
  id: totrans-500
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于您的增量和二进制到一进制函数。（一个 "单元
- en: test" in Coq is a specific Example that can be proved with
  id: totrans-501
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq 中的 "test" 是一个特定的例子，可以证明
- en: just reflexivity, as we've done for several of our
  id: totrans-502
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就是反射性，就像我们做过的一样
- en: definitions.)  Notice that incrementing a binary number and
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义。）请注意，增加一个二进制数和
- en: then converting it to unary should yield the same result as
  id: totrans-504
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后将其转换为一进制应该产生相同的结果
- en: first converting it to unary and then incrementing.
  id: totrans-505
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先将其转换为一进制，然后递增。
- en: '[PRE68]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: ☐
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE69]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
