- en: BasicsFunctional Programming in Coq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functional programming style is founded on simple, everyday
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'mathematical intuition: If a procedure or method has no side'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: effects, then (ignoring efficiency) all we need to understand
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: about it is how it maps inputs to outputs — that is, we can think
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of it as just a concrete method for computing a mathematical
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: function.  This is one sense of the word "functional" in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"functional programming."  The direct connection between programs'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and simple mathematical objects supports both formal correctness
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proofs and sound informal reasoning about program behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The other sense in which functional programming is "functional" is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that it emphasizes the use of functions (or methods) as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*first-class* values — i.e., values that can be passed as'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: arguments to other functions, returned as results, included in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: data structures, etc.  The recognition that functions can be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: treated as data gives rise to a host of useful and powerful
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: programming idioms.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Other common features of functional languages include *algebraic data types*
    and *pattern matching*, which make it easy to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: construct and manipulate rich data structures, and sophisticated
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*polymorphic type systems* supporting abstraction and code reuse.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coq offers all of these features.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first half of this chapter introduces the most essential
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: elements of Coq's functional programming language, called
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Gallina*.  The second half introduces some basic *tactics* that'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: can be used to prove properties of Coq programs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Days of the Week
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see how this definition mechanism works, let's start with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a very simple example.  The following declaration tells Coq that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we are defining a new set of data values — a *type*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The type is called day, and its members are monday,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tuesday, etc.  The second and following lines of the definition
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: can be read "monday is a day, tuesday is a day, etc."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Having defined day, we can write functions that operate on
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: days.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: One thing to note is that the argument and return types of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this function are explicitly declared.  Like most functional
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: programming languages, Coq can often figure out these types for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: itself when they are not given explicitly — i.e., it can do *type inference*
    — but we'll generally include them to make reading
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: easier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Having defined a function, we should check that it works on
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: some examples.  There are actually three different ways to do this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in Coq.  First, we can use the command Compute to evaluate a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: compound expression involving next_weekday.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: (We show Coq's responses in comments, but, if you have a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: computer handy, this would be an excellent moment to fire up the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coq interpreter under your favorite IDE — either CoqIde or Proof
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: General — and try this for yourself.  Load this file, Basics.v,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from the book's Coq sources, find the above example, submit it to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coq, and observe the result.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Second, we can record what we *expect* the result to be in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'form of a Coq example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration does two things: it makes an'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assertion (that the second weekday after saturday is tuesday),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and it gives the assertion a name that can be used to refer to it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: later.  Having made the assertion, we can also ask Coq to verify
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'it, like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The details are not important for now (we'll come back to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: them in a bit), but essentially this can be read as "The assertion
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we've just made can be proved by observing that both sides of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: equality evaluate to the same thing, after some simplification."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Third, we can ask Coq to *extract*, from our Definition, a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: program in some other, more conventional, programming
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: language (OCaml, Scheme, or Haskell) with a high-performance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: compiler.  This facility is very interesting, since it gives us a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: way to go from proved-correct algorithms written in Gallina to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: efficient machine code.  (Of course, we are trusting the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: correctness of the OCaml/Haskell/Scheme compiler, and of Coq's
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: extraction facility itself, but this is still a big step forward
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from the way most software is developed today.) Indeed, this is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: one of the main uses for which Coq was developed.  We'll come back
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to this topic in later chapters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a similar way, we can define the standard type bool of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: booleans, with members true and false.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Although we are rolling our own booleans here for the sake
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of building up everything from scratch, Coq does, of course,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: provide a default implementation of the booleans, together with a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: multitude of useful functions and lemmas.  (Take a look at
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coq.Init.Datatypes in the Coq library documentation if you're
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: interested.)  Whenever possible, we'll name our own definitions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and theorems so that they exactly coincide with the ones in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: standard library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Functions over booleans can be defined in the same way as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'above:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The last two of these illustrate Coq's syntax for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: multi-argument function definitions.  The corresponding
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: multi-argument application syntax is illustrated by the following
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"unit tests," which constitute a complete specification — a truth'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'table — for the orb function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can also introduce some familiar syntax for the boolean
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: operations we have just defined. The Infix command defines a new
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: symbolic notation for an existing definition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*A note on notation*: In .v files, we use square brackets'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to delimit fragments of Coq code within comments; this convention,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: also used by the coqdoc documentation tool, keeps them visually
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: separate from the surrounding text.  In the html version of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: files, these pieces of text appear in a different font.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The command Admitted can be used as a placeholder for an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: incomplete proof.  We'll use it in exercises, to indicate the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: parts that we're leaving for you — i.e., your job is to replace
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Admitteds with real proofs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star (nandb)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Remove "Admitted." and complete the definition of the following
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: function; then make sure that the Example assertions below can
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: each be verified by Coq.  (Remove "Admitted." and fill in each
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proof, following the model of the orb tests above.) The function
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: should return true if either or both of its inputs are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: false.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star (andb3)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Do the same for the andb3 function below. This function should
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return true when all of its inputs are true, and false
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: otherwise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Check true.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> true : bool *)
  prefs: []
  type: TYPE_NORMAL
- en: Check (negb true).
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> negb true : bool *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Check negb.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> negb : bool -> bool *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coq provides a *module system*, to aid in organizing large
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: developments.  In this course we won't need most of its features,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'but one is useful: If we enclose a collection of declarations'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: between Module X and End X markers, then, in the remainder of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the file after the End, these definitions are referred to by
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: names like X.foo instead of just foo.  We will use this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: feature to introduce the definition of the type nat in an inner
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: module so that it does not interfere with the one from the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: standard library (which we want to use in the rest because it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: comes with a tiny bit of convenient special notation).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The types we have defined so far are examples of "enumerated
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'types": their definitions explicitly enumerate a finite set of'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: elements.  A more interesting way of defining a type is to give a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: collection of *inductive rules* describing its elements.  For
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: example, we can define (a unary representation of) the natural
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'numbers as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The clauses of this definition can be read:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: O is a natural number (note that this is the letter "O," not the numeral "0").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S is a "constructor" that takes a natural number and yields another one — that
    is, if n is a natural number, then S n is too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at this in a little more detail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Every inductively defined set (day, nat, bool, etc.) is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: actually a set of *expressions* built from *constructors*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: like O, S, true, false, monday, etc.  The definition of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'nat says how expressions in the set nat can be built:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: O and S are constructors;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the expression O belongs to the set nat;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if n is an expression belonging to the set nat, then S n is also an expression
    belonging to the set nat; and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: expressions formed in these two ways are the only ones belonging to the set
    nat.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same rules apply for our definitions of day and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: bool. (The annotations we used for their constructors are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: analogous to the one for the O constructor, indicating that they
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: don't take any arguments.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The above conditions are the precise force of the Inductive
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: declaration.  They imply that the expression O, the expression
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: S O, the expression S (S O), the expression S (S (S O)), and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: so on all belong to the set nat, while other expressions built
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from data constructors, like true, andb true false, S (S false), and O (O (O
    S)) do not.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A critical point here is that what we've done so far is just to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'define a *representation* of numbers: a way of writing them down.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The names O and S are arbitrary, and at this point they have
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: no special meaning — they are just two different marks that we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: can use to write down numbers (together with a rule that says any
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: nat will be written as some string of S marks followed by an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: O).  If we like, we can write essentially the same definition
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'this way:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The *interpretation* of these marks comes from how we use them to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: compute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can do this by writing functions that pattern match on
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: representations of natural numbers just as we did above with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: booleans and days — for example, here is the predecessor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The second branch can be read: "if n has the form S n'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for some n', then return n'."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Because natural numbers are such a pervasive form of data,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coq provides a tiny bit of built-in magic for parsing and printing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'them: ordinary arabic numerals can be used as an alternative to'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the "unary" notation defined by the constructors S and O.  Coq
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'prints numbers in arabic form by default:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The constructor S has the type nat → nat, just like the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'functions minustwo and pred:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: These are all things that can be applied to a number to yield a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: number.  However, there is a fundamental difference between the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'first one and the other two: functions like pred and minustwo'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: come with *computation rules* — e.g., the definition of pred
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: says that pred 2 can be simplified to 1 — while the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definition of S has no such behavior attached.  Although it is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: like a function in the sense that it can be applied to an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: argument, it does not *do* anything at all!  It is just a way of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'writing down numbers.  (Think about standard arabic numerals: the'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: numeral 1 is not a computation; it's a piece of data.  When we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: write 111 to mean the number one hundred and eleven, we are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: using 1, three times, to write down a concrete representation of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a number.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For most function definitions over numbers, just pattern matching
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'is not enough: we also need recursion.  For example, to check that'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a number n is even, we may need to recursively check whether
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: n-2 is even.  To write such functions, we use the keyword
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fixpoint.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can define oddb by a similar Fixpoint declaration, but here
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'is a simpler definition:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: (You will notice if you step through these proofs that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simpl actually has no effect on the goal — all of the work is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: done by reflexivity.  We'll see more about why that is shortly.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Naturally, we can also define multi-argument functions by
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: recursion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Adding three to two now gives us five, as we'd expect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The simplification that Coq performs to reach this conclusion can
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'be visualized as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As a notational convenience, if two or more arguments have
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the same type, they can be written together.  In the following
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'definition, (n m : nat) means just the same as if we had written'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '(n : nat) (m : nat).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can match two expressions at once by putting a comma
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'between them:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The _ in the first line is a *wildcard pattern*.  Writing _ in a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pattern is the same as writing some variable that doesn't get used
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: on the right-hand side.  This avoids the need to invent a variable
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star (factorial)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Recall the standard mathematical factorial function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Translate this into Coq.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can make numerical expressions a little easier to read and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: write by introducing *notations* for addition, multiplication, and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: subtraction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: (The level, associativity, and nat_scope annotations
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: control how these notations are treated by Coq's parser.  The
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: details are not important for our purposes, but interested readers
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: can refer to the optional "More on Notation" section at the end of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this chapter.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that these do not change the definitions we''ve already made:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: they are simply instructions to the Coq parser to accept x + y
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in place of plus x y and, conversely, to the Coq pretty-printer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to display plus x y as x + y.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When we say that Coq comes with almost nothing built-in, we really
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'mean it: even equality testing for numbers is a user-defined'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: operation!  We now define a function beq_nat, which tests
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: natural numbers for equality, yielding a boolean.  Note the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: use of nested matches (we could also have used a simultaneous
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: match, as we did in minus.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The leb function tests whether its first argument is less than or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: equal to its second argument, yielding a boolean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star (blt_nat)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The blt_nat function tests natural numbers for less-than,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: yielding a boolean.  Instead of making up a new Fixpoint for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this one, define it in terms of a previously defined function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem plus_O_n : ∀n : nat, 0 + n = n.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n. simpl. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem plus_O_n'' : ∀n : nat, 0 + n = n.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem plus_1_l : ∀n:nat, 1 + n = S n.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem mult_0_l : ∀n:nat, 0 * n = 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem plus_n_O : ∀n, n = n + 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n. simpl. (* Doesn't do anything! *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Proof by Rewriting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This theorem is a bit more interesting than the others we've
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'seen:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Instead of making a universal claim about all numbers n and m,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it talks about a more specialized property that only holds when n = m.  The
    arrow symbol is pronounced "implies."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As before, we need to be able to reason by assuming we are given such
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: numbers n and m.  We also need to assume the hypothesis
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: n = m. The intros tactic will serve to move all three of these
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from the goal into assumptions in the current context.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since n and m are arbitrary numbers, we can't just use
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simplification to prove this theorem.  Instead, we prove it by
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: observing that, if we are assuming n = m, then we can replace
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: n with m in the goal statement and obtain an equality with the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: same expression on both sides.  The tactic that tells Coq to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: perform this replacement is called rewrite.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the proof moves the universally quantified
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variables n and m into the context.  The second moves the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hypothesis n = m into the context and gives it the name H.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The third tells Coq to rewrite the current goal (n + n = m + m)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: by replacing the left side of the equality hypothesis H with the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: right side.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (The arrow symbol in the rewrite has nothing to do with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'implication: it tells Coq to apply the rewrite from left to right.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To rewrite from right to left, you can use rewrite ←.  Try
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: making this change in the above proof and see what difference it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: makes.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star (plus_id_exercise)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Remove "Admitted." and fill in the proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Admitted command tells Coq that we want to skip trying
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to prove this theorem and just accept it as a given.  This can be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useful for developing longer proofs, since we can state subsidiary
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lemmas that we believe will be useful for making some larger
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: argument, use Admitted to accept them on faith for the moment,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and continue working on the main argument until we are sure it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: makes sense; then we can go back and fill in the proofs we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'skipped.  Be careful, though: every time you say Admitted you'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are leaving a door open for total nonsense to enter Coq's nice,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rigorous, formally checked world!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can also use the rewrite tactic with a previously proved
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: theorem instead of a hypothesis from the context. If the statement
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of the previously proved theorem involves quantified variables,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: as in the example below, Coq tries to instantiate them
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: by matching with the current goal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars (mult_S_1)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem plus_1_neq_0_firsttry : ∀n : nat,'
  prefs: []
  type: TYPE_NORMAL
- en: beq_nat (n + 1) 0 = false.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n.
  prefs: []
  type: TYPE_NORMAL
- en: simpl. (* does nothing! *)
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem plus_1_neq_0 : ∀n : nat,'
  prefs: []
  type: TYPE_NORMAL
- en: beq_nat (n + 1) 0 = false.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n. destruct n as [| n'].
  prefs: []
  type: TYPE_NORMAL
- en: '- reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- reflexivity. Qed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem negb_involutive : ∀b : bool,'
  prefs: []
  type: TYPE_NORMAL
- en: negb (negb b) = b.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros b. destruct b.
  prefs: []
  type: TYPE_NORMAL
- en: '- reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- reflexivity. Qed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem andb_commutative : ∀b c, andb b c = andb c b.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros b c. destruct b.
  prefs: []
  type: TYPE_NORMAL
- en: '- destruct c.'
  prefs: []
  type: TYPE_NORMAL
- en: + reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: + reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- destruct c.'
  prefs: []
  type: TYPE_NORMAL
- en: + reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: + reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem andb_commutative'' : ∀b c, andb b c = andb c b.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros b c. destruct b.
  prefs: []
  type: TYPE_NORMAL
- en: '{ destruct c.'
  prefs: []
  type: TYPE_NORMAL
- en: '{ reflexivity. }'
  prefs: []
  type: TYPE_NORMAL
- en: '{ reflexivity. } }'
  prefs: []
  type: TYPE_NORMAL
- en: '{ destruct c.'
  prefs: []
  type: TYPE_NORMAL
- en: '{ reflexivity. }'
  prefs: []
  type: TYPE_NORMAL
- en: '{ reflexivity. } }'
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem andb3_exchange :'
  prefs: []
  type: TYPE_NORMAL
- en: ∀b c d, andb (andb b c) d = andb (andb b d) c.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros b c d. destruct b.
  prefs: []
  type: TYPE_NORMAL
- en: '- destruct c.'
  prefs: []
  type: TYPE_NORMAL
- en: '{ destruct d.'
  prefs: []
  type: TYPE_NORMAL
- en: '- reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- reflexivity. }'
  prefs: []
  type: TYPE_NORMAL
- en: '{ destruct d.'
  prefs: []
  type: TYPE_NORMAL
- en: '- reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- reflexivity. }'
  prefs: []
  type: TYPE_NORMAL
- en: '- destruct c.'
  prefs: []
  type: TYPE_NORMAL
- en: '{ destruct d.'
  prefs: []
  type: TYPE_NORMAL
- en: '- reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- reflexivity. }'
  prefs: []
  type: TYPE_NORMAL
- en: '{ destruct d.'
  prefs: []
  type: TYPE_NORMAL
- en: '- reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- reflexivity. }'
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: intros x y. destruct y as [|y].
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is so common that Coq provides a shorthand for it: we'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: can perform case analysis on a variable when introducing it by
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: using an intro pattern instead of a variable name. For instance,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: here is a shorter proof of the plus_1_neq_0 theorem above.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If there are no arguments to name, we can just write [].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars (andb_true_elim2)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prove the following claim, marking cases (and subcases) with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: bullets when you use destruct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star (zero_nbeq_plus_1)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Notation "x + y" := (plus x y)
  prefs: []
  type: TYPE_NORMAL
- en: (at level 50, left associativity)
  prefs: []
  type: TYPE_NORMAL
- en: ': nat_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Notation "x * y" := (mult x y)
  prefs: []
  type: TYPE_NORMAL
- en: (at level 40, left associativity)
  prefs: []
  type: TYPE_NORMAL
- en: ': nat_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Fixpoints and Structural Recursion (Optional)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a copy of the definition of addition:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: When Coq checks this definition, it notes that plus' is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"decreasing on 1st argument."  What this means is that we are'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: performing a *structural recursion* over the argument n — i.e.,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that we make recursive calls only on strictly smaller values of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: n.  This implies that all calls to plus' will eventually
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: terminate.  Coq demands that some argument of *every* Fixpoint
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definition is "decreasing."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This requirement is a fundamental feature of Coq''s design: In'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: particular, it guarantees that every function that can be defined
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in Coq will terminate on all inputs.  However, because Coq's
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"decreasing analysis" is not very sophisticated, it is sometimes'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: necessary to write functions in slightly unnatural ways.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, optional (decreasing)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To get a concrete sense of this, find a way to write a sensible
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fixpoint definition (of a simple function on numbers, say) that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*does* terminate on all inputs, but that Coq will reject because'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of this restriction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem identity_fn_applied_twice :'
  prefs: []
  type: TYPE_NORMAL
- en: '∀(f : bool → bool),'
  prefs: []
  type: TYPE_NORMAL
- en: '(∀(x : bool), f x = x) →'
  prefs: []
  type: TYPE_NORMAL
- en: '∀(b : bool), f (f b) = b.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem andb_eq_orb :'
  prefs: []
  type: TYPE_NORMAL
- en: '∀(b c : bool),'
  prefs: []
  type: TYPE_NORMAL
- en: (andb b c = orb b c) →
  prefs: []
  type: TYPE_NORMAL
- en: b = c.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Inductive nat : Type := | O : nat | S : nat → nat.
  prefs: []
  type: TYPE_NORMAL
- en: says nothing about what O and S "mean."  It just says "O is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in the set called nat, and if n is in the set then so is S n."  The interpretation
    of O as zero and S as successor/plus
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: one comes from the way that we *use* nat values, by writing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: functions to do things with them, proving things about them, and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: so on.  Your definition of bin should be correspondingly simple;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it is the functions you will write next that will give it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mathematical meaning.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (b) Next, write an increment function incr for binary numbers,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and a function bin_to_nat to convert binary numbers to unary
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: numbers.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (c) Write five unit tests test_bin_incr1, test_bin_incr2, etc.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for your increment and binary-to-unary functions.  (A "unit
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: test" in Coq is a specific Example that can be proved with
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: just reflexivity, as we've done for several of our
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: definitions.)  Notice that incrementing a binary number and
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: then converting it to unary should yield the same result as
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: first converting it to unary and then incrementing.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
