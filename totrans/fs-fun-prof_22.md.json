["```\ntype Result<'TSuccess,'TFailure> = \n    | Success of 'TSuccess\n    | Failure of 'TFailure \n```", "```\ntype Request = {name:string; email:string}\n\nlet validateInput input =\n   if input.name = \"\" then Failure \"Name must not be blank\"\n   else if input.email = \"\" then Failure \"Email must not be blank\"\n   else Success input  // happy path \n```", "```\nvalidateInput : Request -> Result<Request,string> \n```", "```\nlet bind switchFunction = \n    fun twoTrackInput -> \n        match twoTrackInput with\n        | Success s -> switchFunction s\n        | Failure f -> Failure f \n```", "```\nval bind : ('a -> Result<'b,'c>) -> Result<'a,'c> -> Result<'b,'c> \n```", "```\nlet bind switchFunction twoTrackInput = \n    match twoTrackInput with\n    | Success s -> switchFunction s\n    | Failure f -> Failure f \n```", "```\nlet bind switchFunction = \n    function\n    | Success s -> switchFunction s\n    | Failure f -> Failure f \n```", "```\ntype Result<'TSuccess,'TFailure> = \n    | Success of 'TSuccess\n    | Failure of 'TFailure\n\ntype Request = {name:string; email:string}\n\nlet bind switchFunction twoTrackInput = \n    match twoTrackInput with\n    | Success s -> switchFunction s\n    | Failure f -> Failure f \n```", "```\nlet validate1 input =\n   if input.name = \"\" then Failure \"Name must not be blank\"\n   else Success input\n\nlet validate2 input =\n   if input.name.Length > 50 then Failure \"Name must not be longer than 50 chars\"\n   else Success input\n\nlet validate3 input =\n   if input.email = \"\" then Failure \"Email must not be blank\"\n   else Success input \n```", "```\n/// glue the three validation functions together\nlet combinedValidation = \n    // convert from switch to two-track input\n    let validate2' = bind validate2\n    let validate3' = bind validate3\n    // connect the two-tracks together\n    validate1 >> validate2' >> validate3' \n```", "```\nlet combinedValidation = \n    // connect the two-tracks together\n    validate1 \n    >> bind validate2 \n    >> bind validate3 \n```", "```\n// test 1\nlet input1 = {name=\"\"; email=\"\"}\ncombinedValidation input1 \n|> printfn \"Result1=%A\"\n\n// ==> Result1=Failure \"Name must not be blank\"\n\n// test 2\nlet input2 = {name=\"Alice\"; email=\"\"}\ncombinedValidation input2\n|> printfn \"Result2=%A\"\n\n// ==> Result2=Failure \"Email must not be blank\"\n\n// test 3\nlet input3 = {name=\"Alice\"; email=\"good\"}\ncombinedValidation input3\n|> printfn \"Result3=%A\"\n\n// ==> Result3=Success {name = \"Alice\"; email = \"good\";} \n```", "```\n/// create an infix operator\nlet (>>=) twoTrackInput switchFunction = \n    bind switchFunction twoTrackInput \n```", "```\nlet combinedValidation x = \n    x \n    |> validate1   // normal pipe because validate1 has a one-track input\n                   // but validate1 results in a two track output...\n    >>= validate2  // ... so use \"bind pipe\". Again the result is a two track output\n    >>= validate3   // ... so use \"bind pipe\" again. \n```", "```\nlet combinedValidation = \n    validate1 \n    >> bind validate2 \n    >> bind validate3 \n```", "```\nlet (>=>) switch1 switch2 x = \n    match switch1 x with\n    | Success s -> switch2 s\n    | Failure f -> Failure f \n```", "```\nlet combinedValidation = \n    validate1 \n    >=> validate2 \n    >=> validate3 \n```", "```\nlet (>=>) switch1 switch2 = \n    switch1 >> (bind switch2) \n```", "```\nlet canonicalizeEmail input =\n   { input with email = input.email.Trim().ToLower() } \n```", "```\n// convert a normal function into a switch\nlet switch f x = \n    f x |> Success \n```", "```\nlet usecase = \n    validate1 \n    >=> validate2 \n    >=> validate3 \n    >=> switch canonicalizeEmail \n```", "```\nlet goodInput = {name=\"Alice\"; email=\"UPPERCASE   \"}\nusecase goodInput\n|> printfn \"Canonicalize Good Result = %A\"\n\n//Canonicalize Good Result = Success {name = \"Alice\"; email = \"uppercase\";}\n\nlet badInput = {name=\"\"; email=\"UPPERCASE   \"}\nusecase badInput\n|> printfn \"Canonicalize Bad Result = %A\"\n\n//Canonicalize Bad Result = Failure \"Name must not be blank\" \n```", "```\n// convert a normal function into a two-track function\nlet map oneTrackFunction twoTrackInput = \n    match twoTrackInput with\n    | Success s -> Success (oneTrackFunction s)\n    | Failure f -> Failure f \n```", "```\nlet usecase = \n    validate1 \n    >=> validate2 \n    >=> validate3 \n    >> map canonicalizeEmail  // normal composition \n```", "```\nlet tee f x = \n    f x |> ignore\n    x \n```", "```\n// a dead-end function \nlet updateDatabase input =\n   ()   // dummy dead-end function for now\n\nlet usecase = \n    validate1 \n    >=> validate2 \n    >=> validate3 \n    >=> switch canonicalizeEmail\n    >=> switch (tee updateDatabase) \n```", "```\nlet usecase = \n    validate1 \n    >> bind validate2 \n    >> bind validate3 \n    >> map canonicalizeEmail   \n    >> map (tee updateDatabase) \n```", "```\nlet tryCatch f x =\n    try\n        f x |> Success\n    with\n    | ex -> Failure ex.Message \n```", "```\nlet usecase = \n    validate1 \n    >=> validate2 \n    >=> validate3 \n    >=> switch canonicalizeEmail\n    >=> tryCatch (tee updateDatabase) \n```", "```\nlet doubleMap successFunc failureFunc twoTrackInput =\n    match twoTrackInput with\n    | Success s -> Success (successFunc s)\n    | Failure f -> Failure (failureFunc f) \n```", "```\nlet map successFunc =\n    doubleMap successFunc id \n```", "```\nlet log twoTrackInput = \n    let success x = printfn \"DEBUG. Success so far: %A\" x; x\n    let failure x = printfn \"ERROR. %A\" x; x\n    doubleMap success failure twoTrackInput \n\nlet usecase = \n    validate1 \n    >=> validate2 \n    >=> validate3 \n    >=> switch canonicalizeEmail\n    >=> tryCatch (tee updateDatabase)\n    >> log \n```", "```\nlet goodInput = {name=\"Alice\"; email=\"good\"}\nusecase goodInput\n|> printfn \"Good Result = %A\"\n\n// DEBUG. Success so far: {name = \"Alice\"; email = \"good\";}\n// Good Result = Success {name = \"Alice\"; email = \"good\";}\n\nlet badInput = {name=\"\"; email=\"\"}\nusecase badInput \n|> printfn \"Bad Result = %A\"\n\n// ERROR. \"Name must not be blank\"\n// Bad Result = Failure \"Name must not be blank\" \n```", "```\nlet succeed x = \n    Success x\n\nlet fail x = \n    Failure x \n```", "```\nlet plus switch1 switch2 x = \n    match (switch1 x),(switch2 x) with\n    | Success s1,Success s2 -> Success (s1 + s2)\n    | Failure f1,Success _  -> Failure f1\n    | Success _ ,Failure f2 -> Failure f2\n    | Failure f1,Failure f2 -> Failure (f1 + f2) \n```", "```\nlet plus addSuccess addFailure switch1 switch2 x = \n    match (switch1 x),(switch2 x) with\n    | Success s1,Success s2 -> Success (addSuccess s1 s2)\n    | Failure f1,Success _  -> Failure f1\n    | Success _ ,Failure f2 -> Failure f2\n    | Failure f1,Failure f2 -> Failure (addFailure f1 f2) \n```", "```\n// create a \"plus\" function for validation functions\nlet (&&&) v1 v2 = \n    let addSuccess r1 r2 = r1 // return first\n    let addFailure s1 s2 = s1 + \"; \" + s2  // concat\n    plus addSuccess addFailure v1 v2 \n```", "```\nlet combinedValidation = \n    validate1 \n    &&& validate2 \n    &&& validate3 \n```", "```\n// test 1\nlet input1 = {name=\"\"; email=\"\"}\ncombinedValidation input1 \n|> printfn \"Result1=%A\"\n// ==>  Result1=Failure \"Name must not be blank; Email must not be blank\"\n\n// test 2\nlet input2 = {name=\"Alice\"; email=\"\"}\ncombinedValidation input2 \n|> printfn \"Result2=%A\"\n// ==>  Result2=Failure \"Email must not be blank\"\n\n// test 3\nlet input3 = {name=\"Alice\"; email=\"good\"}\ncombinedValidation input3 \n|> printfn \"Result3=%A\"\n// ==>  Result3=Success {name = \"Alice\"; email = \"good\";} \n```", "```\nlet usecase = \n    combinedValidation\n    >=> switch canonicalizeEmail\n    >=> tryCatch (tee updateDatabase) \n```", "```\n// test 4\nlet input4 = {name=\"Alice\"; email=\"UPPERCASE   \"}\nusecase input4\n|> printfn \"Result4=%A\"\n// ==>  Result4=Success {name = \"Alice\"; email = \"uppercase\";} \n```", "```\nlet injectableFunction = \n    if config.debug then debugLogger else id \n```", "```\ntype Config = {debug:bool}\n\nlet debugLogger twoTrackInput = \n    let success x = printfn \"DEBUG. Success so far: %A\" x; x\n    let failure = id // don't log here\n    doubleMap success failure twoTrackInput \n\nlet injectableLogger config = \n    if config.debug then debugLogger else id\n\nlet usecase config = \n    combinedValidation \n    >> map canonicalizeEmail\n    >> injectableLogger config \n```", "```\nlet input = {name=\"Alice\"; email=\"good\"}\n\nlet releaseConfig = {debug=false}\ninput \n|> usecase releaseConfig \n|> ignore\n\n// no output\n\nlet debugConfig = {debug=true}\ninput \n|> usecase debugConfig \n|> ignore\n\n// debug output\n// DEBUG. Success so far: {name = \"Alice\"; email = \"good\";} \n```", "```\n// the two-track type\ntype Result<'TSuccess,'TFailure> = \n    | Success of 'TSuccess\n    | Failure of 'TFailure\n\n// convert a single value into a two-track result\nlet succeed x = \n    Success x\n\n// convert a single value into a two-track result\nlet fail x = \n    Failure x\n\n// apply either a success function or failure function\nlet either successFunc failureFunc twoTrackInput =\n    match twoTrackInput with\n    | Success s -> successFunc s\n    | Failure f -> failureFunc f\n\n// convert a switch function into a two-track function\nlet bind f = \n    either f fail\n\n// pipe a two-track value into a switch function \nlet (>>=) x f = \n    bind f x\n\n// compose two switches into another switch\nlet (>=>) s1 s2 = \n    s1 >> bind s2\n\n// convert a one-track function into a switch\nlet switch f = \n    f >> succeed\n\n// convert a one-track function into a two-track function\nlet map f = \n    either (f >> succeed) fail\n\n// convert a dead-end function into a one-track function\nlet tee f x = \n    f x; x \n\n// convert a one-track function into a switch with exception handling\nlet tryCatch f exnHandler x =\n    try\n        f x |> succeed\n    with\n    | ex -> exnHandler ex |> fail\n\n// convert two one-track functions into a two-track function\nlet doubleMap successFunc failureFunc =\n    either (successFunc >> succeed) (failureFunc >> fail)\n\n// add two switches in parallel\nlet plus addSuccess addFailure switch1 switch2 x = \n    match (switch1 x),(switch2 x) with\n    | Success s1,Success s2 -> Success (addSuccess s1 s2)\n    | Failure f1,Success _  -> Failure f1\n    | Success _ ,Failure f2 -> Failure f2\n    | Failure f1,Failure f2 -> Failure (addFailure f1 f2) \n```", "```\nval map : ('a -> 'b) -> (Result<'a,'c> -> Result<'b,'c>) \n```", "```\nval map : (int -> int) -> (Result<int,int> -> Result<int,int>) \n```", "```\nopen RailwayCombinatorModule \n\nlet (&&&) v1 v2 = \n    let addSuccess r1 r2 = r1 // return first\n    let addFailure s1 s2 = s1 + \"; \" + s2  // concat\n    plus addSuccess addFailure v1 v2 \n\nlet combinedValidation = \n    validate1 \n    &&& validate2 \n    &&& validate3 \n\nlet canonicalizeEmail input =\n   { input with email = input.email.Trim().ToLower() }\n\nlet updateDatabase input =\n   ()   // dummy dead-end function for now\n\n// new function to handle exceptions\nlet updateDatebaseStep = \n    tryCatch (tee updateDatabase) (fun ex -> ex.Message)\n\nlet usecase = \n    combinedValidation \n    >> map canonicalizeEmail\n    >> bind updateDatebaseStep\n    >> log \n```", "```\nWrite a program that prints the numbers from 1 to 100\\. \n* For multiples of three print \"Fizz\" instead of the number.\n* For multiples of five print \"Buzz\". \n* For numbers which are multiples of both three and five print \"FizzBuzz\". \n```", "```\nmodule FizzBuzz_Match = \n\n    let fizzBuzz i = \n        match i with\n        | _ when i % 15 = 0 -> \n            printf \"FizzBuzz\"\n        | _ when i % 3 = 0 -> \n            printf \"Fizz\"\n        | _ when i % 5 = 0 -> \n            printf \"Buzz\"\n        | _ -> \n            printf \"%i\" i\n\n        printf \"; \"\n\n    // do the fizzbuzz\n    [1..100] |> List.iter fizzBuzz \n```", "```\nmodule FizzBuzz_IfPrime = \n\n    let fizzBuzz i = \n        let mutable printed = false\n\n        if i % 3 = 0 then\n            printed <- true\n            printf \"Fizz\"\n\n        if i % 5 = 0 then\n            printed <- true\n            printf \"Buzz\"\n\n        if not printed then\n            printf \"%i\" i\n\n        printf \"; \"\n\n    // do the fizzbuzz\n    [1..100] |> List.iter fizzBuzz \n```", "```\nmodule FizzBuzz_UsingFactorRules = \n\n    let fizzBuzz rules i  = \n        let mutable printed = false\n\n        for factor,label in rules do\n            if i % factor = 0 then\n                printed <- true\n                printf \"%s\" label\n\n        if not printed then\n            printf \"%i\" i\n\n        printf \"; \"\n\n    // do the fizzbuzz\n    let rules = [ (3,\"Fizz\"); (5,\"Buzz\") ]\n    [1..100] |> List.iter (fizzBuzz rules) \n```", "```\nmodule FizzBuzz_UsingFactorRules = \n\n    // existing code as above\n\n    let rules2 = [ (3,\"Fizz\"); (5,\"Buzz\"); (7,\"Baz\") ]\n    [1..105] |> List.iter (fizzBuzz rules2) \n```", "```\ndata |> handleThreeCase |> handleFiveCase |> handleAllOtherCases |> printResult \n```", "```\ntype Data = {i:int; label:string option} \n```", "```\nlet carbonate factor label data = \n    let {i=i; label=labelSoFar} = data\n    if i % factor = 0 then\n        // pass on a new data record\n        let newLabel = \n            match labelSoFar with\n            | Some s -> s + label \n            | None -> label \n        {data with label=Some newLabel}\n    else\n        // pass on the unchanged data\n        data \n```", "```\nlet labelOrDefault data = \n    let {i=i; label=labelSoFar} = data\n    match labelSoFar with\n    | Some s -> s\n    | None -> sprintf \"%i\" i \n```", "```\nlet fizzBuzz i = \n    {i=i; label=None}\n    |> carbonate 3 \"Fizz\"\n    |> carbonate 5 \"Buzz\"\n    |> labelOrDefault     // convert to string\n    |> printf \"%s; \"      // print \n```", "```\nmodule FizzBuzz_Pipeline_WithRecord = \n\n    type Data = {i:int; label:string option}\n\n    let carbonate factor label data = \n        let {i=i; label=labelSoFar} = data\n        if i % factor = 0 then\n            // pass on a new data record\n            let newLabel = \n                match labelSoFar with\n                | Some s -> s + label \n                | None -> label \n            {data with label=Some newLabel}\n        else\n            // pass on the unchanged data\n            data\n\n    let labelOrDefault data = \n        let {i=i; label=labelSoFar} = data\n        match labelSoFar with\n        | Some s -> s\n        | None -> sprintf \"%i\" i\n\n    let fizzBuzz i = \n        {i=i; label=None}\n        |> carbonate 3 \"Fizz\"\n        |> carbonate 5 \"Buzz\"\n        |> labelOrDefault     // convert to string\n        |> printf \"%s; \"      // print\n\n    [1..100] |> List.iter fizzBuzz \n```", "```\nmodule FizzBuzz_Pipeline_WithTuple = \n\n    // type Data = int * string option\n\n    let carbonate factor label data = \n        let (i,labelSoFar) = data\n        if i % factor = 0 then\n            // pass on a new data record\n            let newLabel = \n                labelSoFar \n                |> Option.map (fun s -> s + label)\n                |> defaultArg <| label \n            (i,Some newLabel)\n        else\n            // pass on the unchanged data\n            data\n\n    let labelOrDefault data = \n        let (i,labelSoFar) = data\n        labelSoFar \n        |> defaultArg <| sprintf \"%i\" i\n\n    let fizzBuzz i = \n        (i,None)   // use tuple instead of record\n        |> carbonate 3 \"Fizz\"\n        |> carbonate 5 \"Buzz\"\n        |> labelOrDefault     // convert to string\n        |> printf \"%s; \"      // print\n\n    [1..100] |> List.iter fizzBuzz \n```", "```\n// before\nlet newLabel = \n    match labelSoFar with\n    | Some s -> s + label \n    | None -> label \n\n// after\nlet newLabel = \n    labelSoFar \n    |> Option.map (fun s -> s + label)\n    |> defaultArg <| label \n```", "```\n// before\nmatch labelSoFar with\n| Some s -> s\n| None -> sprintf \"%i\" i\n\n// after\nlabelSoFar \n|> defaultArg <| sprintf \"%i\" i \n```", "```\n// OK - normal usage\ndefaultArg myOption defaultValue\n\n// ERROR: piping doesn't work\nmyOption |> defaultArg defaultValue\n\n// OK - bi-directional piping does work\nmyOption |> defaultArg <| defaultValue \n```", "```\n|> carbonate 3 \"Fizz\"\n|> carbonate 5 \"Buzz\" \n```", "```\nlet allRules = \n    rules\n    |> List.map (fun (factor,label) -> carbonate factor label)\n    |> List.reduce (>>) \n```", "```\nmodule FizzBuzz_Pipeline_WithRules = \n\n    let carbonate factor label data = \n        let (i,labelSoFar) = data\n        if i % factor = 0 then\n            // pass on a new data record\n            let newLabel = \n                labelSoFar \n                |> Option.map (fun s -> s + label)\n                |> defaultArg <| label \n            (i,Some newLabel)\n        else\n            // pass on the unchanged data\n            data\n\n    let labelOrDefault data = \n        let (i,labelSoFar) = data\n        labelSoFar \n        |> defaultArg <| sprintf \"%i\" i\n\n    let fizzBuzz rules i = \n\n        // create a single function from all the rules\n        let allRules = \n            rules\n            |> List.map (fun (factor,label) -> carbonate factor label)\n            |> List.reduce (>>)\n\n        (i,None)   \n        |> allRules\n        |> labelOrDefault     // convert to string\n        |> printf \"%s; \"      // print\n\n    // test\n    let rules = [ (3,\"Fizz\"); (5,\"Buzz\"); (7,\"Baz\") ]\n    [1..105] |> List.iter (fizzBuzz rules) \n```", "```\nmodule RailwayCombinatorModule = \n\n    let (|Success|Failure|) =\n        function \n        | Choice1Of2 s -> Success s\n        | Choice2Of2 f -> Failure f\n\n    /// convert a single value into a two-track result\n    let succeed x = Choice1Of2 x\n\n    /// convert a single value into a two-track result\n    let fail x = Choice2Of2 x\n\n    // appy either a success function or failure function\n    let either successFunc failureFunc twoTrackInput =\n        match twoTrackInput with\n        | Success s -> successFunc s\n        | Failure f -> failureFunc f\n\n    // convert a switch function into a two-track function\n    let bind f = \n        either f fail \n```", "```\nlet carbonate factor label i = \n    if i % factor = 0 then\n        succeed label\n    else\n        fail i \n```", "```\nlet connect f = \n    function\n    | Success x -> succeed x \n    | Failure i -> f i \n```", "```\nlet connect' f = \n    either succeed f \n```", "```\nlet fizzBuzz = \n    carbonate 15 \"FizzBuzz\"      // need the 15-FizzBuzz rule because of short-circuit\n    >> connect (carbonate 3 \"Fizz\")\n    >> connect (carbonate 5 \"Buzz\")\n    >> either (printf \"%s; \") (printf \"%i; \") \n```", "```\nmodule FizzBuzz_RailwayOriented_CarbonationIsSuccess = \n\n    open RailwayCombinatorModule \n\n    // carbonate a value\n    let carbonate factor label i = \n        if i % factor = 0 then\n            succeed label\n        else\n            fail i\n\n    let connect f = \n        function\n        | Success x -> succeed x \n        | Failure i -> f i\n\n    let connect' f = \n        either succeed f\n\n    let fizzBuzz = \n        carbonate 15 \"FizzBuzz\"      // need the 15-FizzBuzz rule because of short-circuit\n        >> connect (carbonate 3 \"Fizz\")\n        >> connect (carbonate 5 \"Buzz\")\n        >> either (printf \"%s; \") (printf \"%i; \")\n\n    // test\n    [1..100] |> List.iter fizzBuzz \n```", "```\nmodule FizzBuzz_RailwayOriented_CarbonationIsFailure = \n\n    open RailwayCombinatorModule \n\n    // carbonate a value\n    let carbonate factor label i = \n        if i % factor = 0 then\n            fail label\n        else\n            succeed i\n\n    let fizzBuzz = \n        carbonate 15 \"FizzBuzz\"\n        >> bind (carbonate 3 \"Fizz\")\n        >> bind (carbonate 5 \"Buzz\")\n        >> either (printf \"%i; \") (printf \"%s; \") \n\n    // test\n    [1..100] |> List.iter fizzBuzz \n```", "```\nlet (|Uncarbonated|Carbonated|) =\n    function \n    | Choice1Of2 u -> Uncarbonated u\n    | Choice2Of2 c -> Carbonated c\n\n/// convert a single value into a two-track result\nlet uncarbonated x = Choice1Of2 x\nlet carbonated x = Choice2Of2 x \n```", "```\nlet carbonate factor label i = \n    if i % factor = 0 then\n        carbonated label\n    else\n        uncarbonated i\n\nlet connect f = \n    function\n    | Uncarbonated i -> f i\n    | Carbonated x -> carbonated x \n```", "```\nlet connect' f = \n    either f carbonated \n```", "```\nmodule FizzBuzz_RailwayOriented_UsingCustomChoice = \n\n    open RailwayCombinatorModule \n\n    let (|Uncarbonated|Carbonated|) =\n        function \n        | Choice1Of2 u -> Uncarbonated u\n        | Choice2Of2 c -> Carbonated c\n\n    /// convert a single value into a two-track result\n    let uncarbonated x = Choice1Of2 x\n    let carbonated x = Choice2Of2 x\n\n    // carbonate a value\n    let carbonate factor label i = \n        if i % factor = 0 then\n            carbonated label\n        else\n            uncarbonated i\n\n    let connect f = \n        function\n        | Uncarbonated i -> f i\n        | Carbonated x -> carbonated x \n\n    let connect' f = \n        either f carbonated \n\n    let fizzBuzz = \n        carbonate 15 \"FizzBuzz\"\n        >> connect (carbonate 3 \"Fizz\")\n        >> connect (carbonate 5 \"Buzz\")\n        >> either (printf \"%i; \") (printf \"%s; \") \n\n    // test\n    [1..100] |> List.iter fizzBuzz \n```", "```\n// concat two carbonation functions\nlet (<+>) switch1 switch2 x = \n    match (switch1 x),(switch2 x) with\n    | Carbonated s1,Carbonated s2 -> carbonated (s1 + s2)\n    | Uncarbonated f1,Carbonated s2  -> carbonated s2\n    | Carbonated s1,Uncarbonated f2 -> carbonated s1\n    | Uncarbonated f1,Uncarbonated f2 -> uncarbonated f1 \n```", "```\nsomething + something = combined somethings\nzero + something = something\nsomething + zero = something\nzero + zero = zero \n```", "```\nlet fizzBuzz = \n    let carbonateAll = \n        carbonate 3 \"Fizz\" <+> carbonate 5 \"Buzz\"\n\n    carbonateAll \n    >> either (printf \"%i; \") (printf \"%s; \") \n```", "```\nmodule FizzBuzz_RailwayOriented_UsingAppend = \n\n    open RailwayCombinatorModule \n\n    let (|Uncarbonated|Carbonated|) =\n        function \n        | Choice1Of2 u -> Uncarbonated u\n        | Choice2Of2 c -> Carbonated c\n\n    /// convert a single value into a two-track result\n    let uncarbonated x = Choice1Of2 x\n    let carbonated x = Choice2Of2 x\n\n    // concat two carbonation functions\n    let (<+>) switch1 switch2 x = \n        match (switch1 x),(switch2 x) with\n        | Carbonated s1,Carbonated s2 -> carbonated (s1 + s2)\n        | Uncarbonated f1,Carbonated s2  -> carbonated s2\n        | Carbonated s1,Uncarbonated f2 -> carbonated s1\n        | Uncarbonated f1,Uncarbonated f2 -> uncarbonated f1\n\n    // carbonate a value\n    let carbonate factor label i = \n        if i % factor = 0 then\n            carbonated label\n        else\n            uncarbonated i\n\n    let fizzBuzz = \n        let carbonateAll = \n            carbonate 3 \"Fizz\" <+> carbonate 5 \"Buzz\"\n\n        carbonateAll \n        >> either (printf \"%i; \") (printf \"%s; \") \n\n    // test\n    [1..100] |> List.iter fizzBuzz \n```", "```\nmodule FizzBuzz_RailwayOriented_UsingAddition = \n\n    // code as above\n\n    let fizzBuzzPrimes rules = \n        let carbonateAll  = \n            rules\n            |> List.map (fun (factor,label) -> carbonate factor label)\n            |> List.reduce (<+>)\n\n        carbonateAll \n        >> either (printf \"%i; \") (printf \"%s; \") \n\n    // test\n    let rules = [ (3,\"Fizz\"); (5,\"Buzz\"); (7,\"Baz\") ]\n    [1..105] |> List.iter (fizzBuzzPrimes rules) \n```", "```\nmodule FizzBuzz_Pipeline_WithRules = \n\n    // code as before\n\n    // bug\n    let emptyRules = []\n    [1..105] |> List.iter (fizzBuzz emptyRules) \n```", "```\nlet allRules = \n    rules\n    |> List.map (fun (factor,label) -> carbonate factor label)\n    |> List.fold (>>) id \n```", "```\nlet allRules = \n    rules\n    |> List.map (fun (factor,label) -> carbonate factor label)\n    |> List.reduce (<+>) \n```", "```\nlet allRules = \n    rules\n    |> List.map (fun (factor,label) -> carbonate factor label)\n    |> List.fold (<+>) zero \n```"]