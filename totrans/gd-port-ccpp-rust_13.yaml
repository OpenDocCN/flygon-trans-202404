- en: Features of Rust compared with C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 与 C++ 的特点对比
- en: Features of Rust compared with C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust 与 C++ 的特点对比
- en: Rust and C++ have roughly analogous functionality although they often go about
    it in different ways.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 和 C++ 具有大致相似的功能，尽管它们经常以不同的方式实现。
- en: Rust benefits from learning what works in C / C++ and what doesn't and indeed
    has cherry-picked features from a variety of languages. It also enjoys a cleaner
    API in part because things like Unicode dictate the design.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 受益于学习 C/C++ 中有效和无效的东西，而且确实从各种语言中选择了功能。它还享有更清晰的 API，部分原因是像 Unicode 这样的东西决定了设计。
- en: This section will cover such topics as types, strings, variables, literals,
    collections, structs, loops and so on. In each case it will draw comparison between
    how things are in C/C++ and how they are in Rust.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将涵盖类型、字符串、变量、字面值、集合、结构体、循环等主题。在每种情况下，它将比较 C/C++ 中的情况与 Rust 中的情况。
- en: Also bear in mind that Rust compiles to binary code and is *designed* to use
    C binaries and be used by C binaries. Therefore the generated code is similar,
    but it is different as source.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 同样要牢记 Rust 编译成二进制代码，并且 *设计* 用于使用 C 二进制文件和被 C 二进制文件使用。因此生成的代码类似，但源代码是不同的。
- en: Types
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: Types
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: 'C/C++ compilers implement a *data model* that affects what width the standard
    types are. The general rule is that:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 编译器实现了影响标准类型宽度的 *数据模型*。一般规则是：
- en: '`1 == sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long
    long)`'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`1 == sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long
    long)`'
- en: As you can see, potentially everything all the way to `long long` could be a
    single byte, or there could be some other crazy definition. In practice however,
    data models come in four common types which will be covered in the next section.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，潜在地，一直到 `long long` 都可以是单个字节，或者可能有一些其他疯狂的定义。然而，在实践中，数据模型有四种常见类型，将在下一节中介绍。
- en: For this section, we'll cover the *most likely* analogous types between Rust
    and C/C++.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们将涵盖 Rust 和 C/C++ 之间 *最可能* 类似的类型。
- en: '| C/C++ | Rust | Notes |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| C/C++ | Rust | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `char` | `i8` (or `u8`) | The signedness of a C++ char can be signed or unsigned
    - the assumption here is signed but it varies by target system. A Rust `char`
    is not the same as a C/C++ `char` since it can hold any Unicode character. ^([1](#fn_1))
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `char` | `i8`（或 `u8`）| C++ char 的符号性可以是有符号或无符号的 - 这里的假设是有符号的，但是目标系统有所不同。Rust
    的 `char` 与 C/C++ 的 `char` 不同，因为它可以容纳任何 Unicode 字符。^([1](#fn_1)) |'
- en: '| `unsigned char` | `u8` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned char` | `u8` |'
- en: '| `signed char` | `i8` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `signed char` | `i8` |'
- en: '| `short int` | `i16` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `short int` | `i16` |'
- en: '| `unsigned short int` | `u16` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned short int` | `u16` |'
- en: '| `(signed) int` | `i32` or `i16` | In C/C++ this is data model dependent ^([2](#fn_2))
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `(signed) int` | `i32` 或 `i16` | 在 C/C++ 中，这取决于数据模型 ^([2](#fn_2)) |'
- en: '| `unsigned int` | `u32` or `u16` | In C/C++ this is data model dependent ^([2](#fn_2))
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned int` | `u32` 或 `u16` | 在 C/C++ 中，这取决于数据模型 ^([2](#fn_2)) |'
- en: '| `(signed) long int` | `i32` or `i64` | In C/C++ this is data model dependent
    ^([2](#fn_2)) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `(signed) long int` | `i32` 或 `i64` | 在 C/C++ 中，这取决于数据模型 ^([2](#fn_2)) |'
- en: '| `unsigned long int` | `u32` or `u64` | In C/C++ this is data model dependent
    ^([2](#fn_2)) |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long int` | `u32` 或 `u64` | 在 C/C++ 中，这取决于数据模型 ^([2](#fn_2)) |'
- en: '| `(signed) long long int` | `i64` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `(signed) long long int` | `i64` |'
- en: '| `unsigned long long int` | `u64` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long long int` | `u64` |'
- en: '| `size_t` | `usize` | usize holds numbers as large as the address space ^([3](#fn_3))
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `size_t` | `usize` | usize 可以容纳与地址空间一样大的数字 ^([3](#fn_3)) |'
- en: '| `float` | `f32` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `f32` |'
- en: '| `double` | `f64` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `f64` |'
- en: '| `long double` | ~~f128~~ | f128 support was present in Rust but removed due
    to issues for some platforms in implementing it. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `long double` | ~~f128~~ | Rust 中存在对 f128 的支持，但由于在某些平台上实现它存在问题而被移除。'
- en: '| `bool` | `bool` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `bool` |'
- en: '| `void` | `()` | The unit type (see below) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `void` | `()` | 单位类型（见下文） |'
- en: ^([1](#fn_1)) Rust's `char` type, is 4 bytes wide, enough to hold any Unicode
    character. This is equivalent to the belated `char32_t` that appears in C++11
    to rectify the abused C++98 `wchar_t` type which on operating systems such as
    Windows is only 2 bytes wide. When you iterate strings in Rust you may do so either
    by character or `u8`, i.e. a byte.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](#fn_1)) Rust 的 `char` 类型，宽度为 4 字节，足以容纳任何 Unicode 字符。这相当于延迟出现的 `char32_t`，它出现在
    C++11 中，以纠正滥用的 C++98 中的 `wchar_t` 类型，该类型在诸如 Windows 等操作系统上仅为 2 字节宽。在 Rust 中迭代字符串时，可以通过字符或
    `u8` 来进行。
- en: ^([2](#fn_2)) See the next section to for a discussion on data models.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](#fn_2)) 请参见下一节讨论数据模型。
- en: ^([3](#fn_3)) Rust has a specific numeric type for indexing on arrays and collections
    called `usize`. A `usize` is designed to be able to reference as many elements
    in an array as there is addressable memory. i.e. if memory is 64-bit addressable
    then usize is 64-bits in length. There is also a signed `isize` which is less
    used but also available.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](#fn_3)) Rust 有一个特定的数值类型用于数组和集合的索引称为 `usize`。`usize` 被设计为能够引用与可寻址内存一样多的元素。也就是说，如果内存是
    64 位可寻址的，那么 `usize` 的长度就是 64 位。还有一个称为 `isize` 的有符号类型，虽然不太常用，但也可以使用。
- en: Data model
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据模型
- en: 'The four common data models in C++ are:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中四种常见的数据模型是：
- en: LP32 - `int` is 16-bit, `long` and pointers are 32-bit. This is an uncommon
    model, a throw-back to DOS / Windows 3.1
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LP32 - `int` 是 16 位，`long` 和指针是 32 位。这是一个不常见的模型，是对 DOS / Windows 3.1 的一种回溯。
- en: ILP32 - `int`, `long` and pointers are 32-bit. Used by Win32, Linux, OS X
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ILP32 - `int`、`long` 和指针都是 32 位。由 Win32、Linux、OS X 使用
- en: LLP64 - `int` and `long` are 32-bit, `long long` and pointers are 64-bit. Used
    by Win64
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLP64 - `int` 和 `long` 是 32 位，`long long` 和指针是 64 位。由 Win64 使用
- en: LP64 - `int` is 32-bit, `long` / `long long` and pointers are 64-bit. Used by
    Linux, OS X
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LP64 - `int` 是 32 位，`long` / `long long` 和指针是 64 位。由 Linux、OS X 使用
- en: C/C++ types compared to Rust
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C/C++ 类型与 Rust 的比较
- en: 'C/C++ and Rust will share the same machine types for each corresponding language
    type and the same compiler / backend technology, i.e.:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 和 Rust 将共享相应语言类型的相同机器类型以及相同的编译器 / 后端技术，即：
- en: Signed types are two's complement
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有符号类型是二进制补码
- en: IEE 754-2008 binary32 and binary64 floating points for float and double precision
    types.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IEE 754-2008 二进制 32 位和 64 位浮点数类型的浮点数和双精度类型。
- en: stdint.h / cstdint
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: stdint.h / cstdint
- en: C provides a `<stdint.h>` header that provides unambigious typedefs with length
    and signedess, e.g. `uint32_t`. The equivalent in C++ is `<cstdlib>`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: C 提供了一个 `<stdint.h>` 头文件，提供了具有长度和符号的清晰 typedefs，例如 `uint32_t`。C++ 中的等效物是 `<cstdlib>`。
- en: If you use the types defined in this header file the types become directly analogous
    and unambiguous between C/C++ and Rust.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用此头文件中定义的类型，则类型在 C/C++ 和 Rust 之间变得直接类比和清晰。
- en: '| C/C++ | Rust |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| C/C++ | Rust |'
- en: '| --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `int8_t` | `i8` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `int8_t` | `i8` |'
- en: '| `uint8_t` | `u8` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `uint8_t` | `u8` |'
- en: '| `int16_t` | `i16` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `int16_t` | `i16` |'
- en: '| `uint16_t` | `u16` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `uint16_t` | `u16` |'
- en: '| `uint32_t` | `u32` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `uint32_t` | `u32` |'
- en: '| `int32_t` | `i32` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `int32_t` | `i32` |'
- en: '| `int64_t` | `i64` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `int64_t` | `i64` |'
- en: '| `uint64_t` | `u64` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `uint64_t` | `u64` |'
- en: Integer types
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数类型
- en: C++
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++
- en: C/C++ has primitive types for numeric values, floating point values and booleans.
    Strings will be dealt in a separate section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 中有用于数值、浮点数和布尔值的原始类型。字符串将在单独的部分中处理。
- en: Integer types (`char`, `short`, `int`, `long`) come in `signed` and `unsigned`
    versions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 整数类型（`char`、`short`、`int`、`long`）有 `signed` 和 `unsigned` 版本。
- en: A `char` is always 8-bits, but for historical reasons, the standards only guarantee
    the other types are "at least" a certain number of bits. So an `int` is ordinarily
    32-bits but the standard only say it should be at *least as large* as a `short`,
    so potentially it could be 16-bits!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`char` 总是 8 位，但出于历史原因，标准仅保证其他类型至少是某个位数。因此，`int` 通常是 32 位，但标准只规定它应该至少与 `short`
    一样大，因此潜在地它可能是 16 位！'
- en: More recent versions of C and C++ provide a [`<cstdint>`](http://www.cplusplus.com/reference/cstdint/)
    (or `<stdint.h>` for C) with typedefs that are unambiguous about their precision.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 较新版本的 C 和 C++ 提供了一个 [`<cstdint>`](http://www.cplusplus.com/reference/cstdint/)（或
    `<stdint.h>` 用于 C）具有清晰关于精度的 typedefs。
- en: 'Even though `<stdint.h>` can clear up the ambiguities, code frequently sacrifices
    correctness for terseness. It is not unusual to see an `int` used as a temporary
    incremental value in a loop:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `<stdint.h>` 可以消除模糊性，代码经常为简洁性而牺牲正确性。在循环中经常看到一个 `int` 用作临时增量值：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While `int` is unlikely to fail for most loops in a modern compiler supporting
    ILP32 or greater, it is still technically wrong. In a LP32 data model incrementing
    32767 by one would become -32768 so this loop would never terminate if `s.size()`
    was a value greater than that.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在大多数支持 ILP32 或更大的现代编译器中，`int` 不太可能失败，但这仍然是技术上的错误。在 LP32 数据模型中，将 32767 加一会变成
    -32768，因此如果 `s.size()` 的值大于那个值，这个循环永远不会终止。
- en: But look again at this snippet. What if the file read by `read_file()` is outside
    of our control. What if someone deliberately or accidentally feeds us a file so
    large that our loop will fail trying to iterate over it? In doing so our code
    is hopelessly broken.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但再次看这个片段。如果由 `read_file()` 读取的文件不受我们控制，会怎么样。如果有人故意或者不小心地给我们提供一个超出我们循环迭代的文件呢？这样做，我们的代码就彻底坏掉了。
- en: 'This loop should be using the same type returned from `string::size()` which
    is an opaque unsigned integer type called `size_type`. This is usually a typedef
    for `std::size_t` but not necessarily. Thus we have a type mismatch. A `string`
    has an iterator which could be used instead but perhaps you need the index for
    some reason, but it can messy:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环应该使用与 `string::size()` 返回的相同类型，这是一个称为 `size_type` 的不透明无符号整数类型。这通常是 `std::size_t`
    的 typedef，但不一定是这样。因此，我们有一个类型不匹配。一个 `string` 有一个迭代器，可以使用它，但也许你因为某种原因需要索引，但可能会很混乱：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we've swapped from one opaque type `size_type` to another called `difference_type`.
    Ugh.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从一个不透明类型 `size_type` 切换到另一个称为 `difference_type` 的类型。呃。
- en: C/C++ types can also be needlessly wordy such as `unsigned long long int`. Again,
    this sort of puffery encourages code to make bad assumptions, use a less wordy
    type, or bloat the code with typedefs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 类型也可能是不必要的冗长，例如 `unsigned long long int`。同样，这种膨胀的写法会鼓励代码做出错误的假设，使用更少字的类型，或者用
    typedefs 来膨胀代码。
- en: Rust
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust
- en: Rust benefits from integer types that unambiguously denote their signedness
    and width in their name - `i16`, `u8` etc.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 从整数类型中受益，这些整数类型在名称中明确地表示了它们的有符号性和宽度 - `i16`、`u8` 等等。
- en: They are also extremely terse making it easy to declare and use them. For example
    a `u32` is an unsigned 32-bit integer. An `i64` is a signed 64-bit integer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也非常简洁，易于声明和使用。例如，`u32` 是一个无符号的 32 位整数。`i64` 是一个有符号的 64 位整数。
- en: 'Types may be inferred or explicitly prefixed to the value:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以被推断或显式前缀到值上：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Rust also has two types called `usize` and `isize` respectively. These are equivalent
    to `size_t` in that they are as large enough to hold as many elements as there
    is addressable memory. So in a 32-bit operating system they will be 32-bits in
    size, in a 64-bit operating system they will be 64-bits in size.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 还有两种类型分别称为 `usize` 和 `isize`。它们与 `size_t` 等效，因为它们足够大以容纳地址内存中的元素数量。因此，在
    32 位操作系统中，它们的大小为 32 位，在 64 位操作系统中，它们的大小为 64 位。
- en: Rust will not implicitly coerce an integer from one size to another without
    explicit use of the `as` keyword.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 不会隐式地将一个大小的整数转换为另一个大小，除非明确使用 `as` 关键字。
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Real types
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际类型
- en: C++
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++
- en: C/C++ has float, double and long double precision floating point types and they
    suffer the same vagueness as integer types.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 中有 `float`、`double` 和 `long double` 等浮点类型，它们与整数类型一样存在模糊性。
- en: '`float`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`'
- en: '`double` - "at least as much precision as a `float`"'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double` - "至少与 `float` 一样精确"'
- en: '`long double` - "at least as much precision as a `double`"'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long double` - "至少与 `double` 一样精确"'
- en: In most compilers and architectures however a float is a 32-bit single precision
    value, and a double is an 64-bit double precision value. The most common machine
    representation is the [IEEE 754-2008 format](https://en.wikipedia.org/wiki/IEEE_floating_point).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编译器和架构中，一个 float 是一个 32 位单精度值，一个 double 是一个 64 位双精度值。最常见的机器表示形式是 [IEEE 754-2008
    格式](https://en.wikipedia.org/wiki/IEEE_floating_point)。
- en: Long double
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Long double
- en: The [`long double`](https://en.wikipedia.org/wiki/Long_double) has proven quite
    problematic for compilers. Despite expectations that it is a quadruple precision
    value it usually isn't. Some compilers such as gcc may offer 80-bit extended precision
    on x86 processors with a floating point unit but it is implementation defined
    behaviour.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[`long double`](https://en.wikipedia.org/wiki/Long_double) 对于编译器来说已经非常棘手了。尽管预期它是一个四倍精度的值，但通常并非如此。一些编译器，如
    gcc，可能在具有浮点单位的 x86 处理器上提供 80 位扩展精度，但这是实现定义的行为。'
- en: The Microsoft Visual C++ compiler treats it with the same precision as a `double`.
    Other architectures may treat it as quadruple precision. The fundamental problem
    with `long double` is that most desktop processors do not have the ability in
    hardware to perform 128-bit floating point operations so a compiler must either
    implement it in software or not bother.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 微软 Visual C++ 编译器将其视为与 `double` 相同精度的类型。其他架构可能将其视为四倍精度。`long double` 的根本问题在于，大多数桌面处理器在硬件上没有执行
    128 位浮点操作的能力，因此编译器必须在软件中实现它或者不理会。
- en: Math functions
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数学函数
- en: The `<math.h>` C header provides math functions for working with different precision
    types.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: C 头文件 `<math.h>` 提供了用于处理不同精度类型的数学函数。
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note how different calls are required according to the precision, e.g. sinf,
    sin or sinl. C99 supplies a "type-generic" set of macros in `<tgmath.h>` which
    allows sin to be used regardless of type.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不同的精度需要不同的调用，例如 sinf、sin 或 sinl。C99 在 `<tgmath.h>` 中提供了一组"类型通用"的宏，允许无论类型如何都可以使用
    sin。
- en: 'C++11 provides a `<cmath>` that uses specialised inline functions for the same
    purpose:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: C++11提供了一个`<cmath>`，使用专门的内联函数来实现相同的目的：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Rust
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rust
- en: Rust implements two floating point types - `f32` and `f64`. These would be analogous
    to a 32-bit `float` and 64-bit `double` in C/C++.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Rust实现了两种浮点数类型 - `f32`和`f64`。这些将类似于C/C++中的32位`float`和64位`double`。
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Unlike in C/C++, the math functions are directly bound to the type itself providing
    you properly qualify the type.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与C/C++不同，数学函数直接绑定到类型本身，只要你正确限定类型即可。
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Rust does not have a 128-bit double. A `f128` did exist for a period of time
    but was removed to portability, complexity and maintenance issues. Note how `long
    double` is treated (or not) according to the compiler and target platform.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Rust没有128位双精度浮点数。在某段时间内确实存在`f128`，但由于可移植性、复杂性和维护问题而被移除。注意根据编译器和目标平台处理（或不处理）`long
    double`的方式。
- en: At some point Rust might get a f128 or f80 but at this time does not have such
    a type.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，Rust可能会获得一个f128或f80，但目前还没有这样的类型。
- en: Booleans
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: A `bool` (boolean) type in C/C++ can have the value `true` or `false`, however
    it can be promoted to an integer type (0 == `false`, 1 == `true`) and a bool even
    has a ++ operator for turning false to true although it has no -- operator!?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在C/C++中，`bool`（布尔）类型可以有值`true`或`false`，但它可以提升为整数类型（0 == `false`，1 == `true`），而且布尔类型甚至有一个++运算符，用于将false转换为true，尽管它没有--运算符！？
- en: But inverting true with a ! becomes false and vice versa.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，将true反转为!false，反之亦然。
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Rust also has a `bool` type that can have the value `true` or `false`. Unlike
    C/C++ it is a true type with no promotion to integer type
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Rust也有一个`bool`类型，它的值可以是`true`或`false`。与C/C++不同，它是一个真正的类型，没有提升为整数类型
- en: void / Unit type
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: void / Unit类型
- en: C/C++ uses `void` to specify a type of nothing or an indeterminate pointer to
    something.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++使用`void`来指定无类型或不确定指针指向的内容。
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The nearest thing to `void` in Rust is the Unit type. It's called a Unit type
    because it's type is `()` and it has one value of `()`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，与`void`最接近的东西是Unit类型。它被称为Unit类型，因为它的类型是`()`，并且有一个值是`()`。
- en: Technically `void` is absolutely nothing and `()` is a single value of type
    `()` so they're not analogous but they serve a similar purpose.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`void`绝对什么也不是，`()`是一种`()`类型的单个值，因此它们不是类似的，但它们具有类似的用途。
- en: 'When a block evaluates to nothing it returns `()`. We can also use it in places
    where we don''t care about one parameter. e.g. say we have a function `do_action()`
    that succeeds or fails for various reasons. We don''t need any payload with the
    Ok response so specify `()` as the payload of success:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个块评估为无时，它返回`()`。我们也可以在我们不关心一个参数的地方使用它。例如，假设我们有一个函数`do_action()`，它因各种原因成功或失败。我们不需要Ok响应的任何有效负载，所以将`()`指定为成功的有效负载：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Empty enums
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空枚举
- en: Rust *does* have something closer (but not the same as) `void` - empty enumerations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Rust确实有与`void`更接近（但不完全相同）的东西 - 空枚举。
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Essentially this enum has no values at all so anything that assigns or matches
    this nothing-ness is unreachable and the compiler can issue warnings or errors.
    If the code had used `()` the compiler might not be able to determine this.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，此枚举根本没有任何值，因此任何分配或匹配此无值的操作都是无法到达的，编译器可以发出警告或错误。如果代码使用了`()`，编译器可能无法确定这一点。
- en: Tuples
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: A tuple is a collection of values of the same or different type passed to a
    function or returned by one as if it were a single value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是一个传递给函数或由函数返回的相同类型或不同类型值的集合，就好像它是一个单一的值一样。
- en: 'C/C++ has no concept of a tuple primitive type, however C++11 can construct
    a tuple using a template:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++没有元组原始类型的概念，但是C++11可以使用模板构造元组：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Rust supports tuples as part of its language:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Rust支持元组作为其语言的一部分：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see this is more terse and more useful. Note that the way a tuple
    is indexed is different from an array though, values are indexed via .0, .1 etc.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这更简洁更实用。请注意，元组的索引方式与数组不同，值通过`.0`，`.1`等索引。
- en: Tuples can also be returned by functions and assignment operators can ignore
    tuple members we're not interested in.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 元组也可以被函数返回，赋值运算符可以忽略我们不感兴趣的元组成员。
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, the calculate_coords() function returns a tuple containing
    three `i16` values. We assign the first two values to `x` and `y` respectively
    and ignore the third by passing an underscore. The underscore tells the compiler
    we're aware of the 3rd value but we just don't care about it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，calculate_coords()函数返回一个包含三个`i16`值的元组。我们将前两个值分别赋给`x`和`y`，并通过传递下划线来忽略第三个值。下划线告诉编译器我们知道第3个值，但我们只是不关心它。
- en: 'Tuples can be particularly useful with code blocks. For example, let''s say
    we want to get some values from a piece of code that uses a guard lock on a reference
    counted service. We can lock the service in the block and return all the values
    as a tuple to the recipients outside of the block:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 元组在代码块中可能特别有用。例如，假设我们想从一个使用引用计数服务上的保护锁的代码段中获取一些值。我们可以在块中锁定服务并将所有值作为元组返回给块外的接收者：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code is really neat - the lock allows us to obtain the values, the lock
    goes out of scope and the values are returned in one go.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码确实很简洁 - 锁允许我们获取值，锁超出范围后一次返回所有值。
- en: Arrays
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: An array is a fixed size list of elements allocated either on the stack or the
    heap.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是在堆栈或堆上分配的固定大小元素列表。
- en: 'E.g to create a 100 element array of `double` values in C++:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 C++ 中创建一个包含 100 个 `double` 值的数组：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And in Rust:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 而在 Rust 中：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note how Rust provides a shorthand to initialise the array with the same value
    or assigns the array with every value. Initialisation in C and C++ is optional
    however it is more expressive in that portions of the array can be set or not
    set using enclosed list syntax.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 Rust 提供了一种用相同值初始化数组的简写方式，或者使用封闭列表语法设置数组的每个值。在 C 和 C++ 中，初始化是可选的，但使用封闭列表语法可以更具表现力地设置或不设置数组的某些部分。
- en: Rust actually *forces* you to initialise an array to something. Attempting to
    declare an array without assigning it a value is a compiler error.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 实际上*强制*您将数组初始化为某些值。尝试声明一个数组而不为其分配值将导致编译器错误。
- en: Slices
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片
- en: A slice is a runtime view of a part of an array or string. A slice is not a
    copy of the array / string rather that it is a reference to a portion of it. The
    reference holds a pointer to the starting element and the number of elements in
    the slice.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是数组或字符串的一部分的运行时视图。切片不是数组/字符串的副本，而是对其中一部分的引用。引用保存指向起始元素的指针以及切片中的元素数。
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This slice represents the portion of array starting from index 2.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此切片表示从索引 2 开始的数组部分。
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Size of the array
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组的大小
- en: C and C++ basically give no easy way to know the length of the array unless
    you encapsulate the array with a `std::array` or happen to remember it from the
    code that declares it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 C++ 基本上没有简单的方法来知道数组的长度，除非您使用 `std::array` 封装数组或者记得从声明数组的代码中获取它。
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `std::array` wrapper is of limited use because you cannot pass arrays of
    an unknown size to a function. Therefore even with this template you may pass
    the array into a function as one argument and its size as another.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::array` 包装器的用途有限，因为您无法将未知大小的数组传递给函数。因此，即使使用此模板，您也可以将数组作为一个参数传递给函数，将其大小作为另一个参数。'
- en: 'Alternatively you might see code like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可能会看到类似这样的代码：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Or like this
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 或者像这样
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In Rust, the array has a function bound to it called `len()`. This always provides
    the length of the array. In addition if we take a slice of the array, that also
    has a `len()`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，数组有一个名为 `len()` 的函数与之绑定。这始终提供数组的长度。此外，如果我们取数组的切片，那也有一个 `len()`。
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Strings
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings in C++ are a bit messy thanks to the way languages and characters have
    been mapped onto bytes in different ways. The explanation for this requires some
    backstory...
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于语言和字符以不同的方式映射到字节上，C++ 中的字符串有点混乱。对此的解释需要一些背景知识...
- en: What is a character exactly?
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符究竟是什么？
- en: Historically in C and C++, a char type is 8-bits. Strictly speaking a char is
    signed type (usually -128 to 127), but the values essentially represent the values
    0-255.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 和 C++ 中，历史上 char 类型是 8 位。严格来说，char 是有符号类型（通常为 -128 到 127），但这些值实质上表示值 0-255。
- en: The US-ASCII standard uses the first 7-bits (0-127) to assign values to upper
    and lower case letters in the English alphabet, numbers, punctuation marks and
    certain control characters.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 美国 ASCII 标准使用前 7 位（0-127）为英文字母、数字、标点符号和某些控制字符分配值。
- en: It didn't help the rest of the world who use different character sets. And even
    ASCII was competing with another standard called EBDIC which was found on mainframe
    computers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于使用不同字符集的其他国家并没有帮助。即使 ASCII 也与另一个称为 EBDIC 的标准竞争，后者在大型计算机上找到。
- en: What about the upper values from 128-255? Some operating systems came up with
    a concept called a "code page". According to what "code page" was in effect, the
    symbol that the user would see for a character in the 128-255 range would change.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 128-255 的上限值呢？一些操作系统提出了一个称为“代码页”的概念。根据实施的“代码页”，用户在 128-255 范围内看到的字符符号将会改变。
- en: But even this is not enough. Some languages like Chinese, Japanese, Korean,
    Thai, Arabic etc. have thousands of symbols that must be encoded with more than
    one byte. So the first byte might be a modifier that combines with further bytes
    to render as a symbol. For example Microsoft's code page 932 use an encoding called
    Shift JIS (Japanese) where some symbols are two bytes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使这还不够。一些语言，如中文、日文、韩文、泰文、阿拉伯文等，有成千上万的符号，必须用多个字节进行编码。因此，第一个字节可能是一个修饰符，与后续字节组合以呈现为一个符号。例如，微软的代码页932使用了一个称为Shift
    JIS（日文）的编码，其中一些符号是两个字节。
- en: Obviously this was rapidly becoming a mess. Each code page interpretted the
    same byte array differently according to some external setting. So you could not
    send a file written in Chinese to someone with a different code page and expect
    it to render properly.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这很快变得一团糟。每个代码页根据某些外部设置以不同方式解释相同的字节数组。因此，您不能将用中文编写的文件发送给具有不同代码页的人，并期望它正确呈现。
- en: Unicode to the rescue
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unicode来拯救
- en: The Unicode standard assigns every printable symbol in existence with a unique
    32-bit value, called a code point. Most symbols fall in the first 16-bits called
    the Basic Multilingual Plane (BMP).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode标准为每个存在的可打印符号分配了一个唯一的32位值，称为代码点。大多数符号位于称为基本多语言平面（BMP）的前16位中。
- en: China has mandated all software must support all 32-bits. We'll see how this
    has become a major headache for C and C++
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 中国规定所有软件必须支持所有32位。我们将看到这对C和C++造成了重大困扰。
- en: C / C++
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C / C++
- en: There is no string primitive
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有字符串原始类型
- en: C and C++ does not have a string primitive type, instead it has `char` type,
    that is one byte. A "string" is a pointer to an array of chars that are terminated
    with a zero byte, `'\0'`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 C++ 没有字符串原始类型，而是有一个长度为一个字节的`char`类型。一个“字符串”是指一个指向以零字节`'\0'`结尾的字符数组的指针。
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In C, functions such as `strlen()`, `strcpy()`, `strdup()` etc. allow strings
    to be manipulated but they work by using the zero byte to figure out the length
    of things. So `strlen()` the number of bytes that were encountered before a `\0`
    was found. Sicne these functions run until they find a terminating character it
    is very easy to accidentally for them to overrun a buffer.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中，诸如`strlen()`、`strcpy()`、`strdup()`等函数允许对字符串进行操作，但它们通过使用零字节来计算事物的长度。因此，`strlen()`是在找到`\0`之前遇到的字节数。由于这些函数运行直到找到终止字符，很容易意外地使它们超出缓冲区。
- en: In C++ the `std::string` class wraps a char pointer and provides safe methods
    for modifying the string in a safe manner. It is a vast improvement over C but
    it is still not a primitive - it is a class defined in a header that is compiled
    and linked to the executable just like every other class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，`std::string`类包装了一个char指针，并提供了安全的方法来以安全的方式修改字符串。这比C有了很大的改进，但它仍然不是一个原始类型
    - 它是一个在头文件中定义的类，与可执行文件一样被编译和链接。
- en: In addition, a `std::string` will usually use heap to store the string's data
    which can have repercussions for memory usage and fragmentation. There is usually
    a hidden cost to assigning one string to another because memory must be allocated
    to receive a copy of the string, even if the string itself is not modified during
    the assignment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`std::string`通常会使用堆来存储字符串的数据，这可能会对内存使用和碎片化产生影响。将一个字符串分配给另一个字符串通常会有隐藏的成本，因为必须分配内存来接收字符串的副本，即使在分配过程中字符串本身没有被修改。
- en: Unicode support
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unicode支持
- en: C/C++ added Unicode support by creating a wide character called `wchar_t`. And
    C++ has an equivalent `std::wstring`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++通过创建一个称为`wchar_t`的宽字符来添加Unicode支持。C++有一个等效的`std::wstring`。
- en: We're sorted now right?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经排序好了对吧？
- en: Oops no, because `wchar_t` type can be either 2 or 4 bytes wide and is a compiler
    / platform specific decision.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕，因为`wchar_t`类型可以是2或4字节宽，这是编译器/平台特定的决定。
- en: In Microsoft Visual C++ the wide char is an `unsigned short` (corresponding
    to Win32's Unicode API), in gcc it can be 32-bits or 16-bits according to the
    compile flags.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft Visual C++中，宽字符是一个`unsigned short`（对应于Win32的Unicode API），在gcc中，根据编译标志，它可以是32位或16位。
- en: A 16-bit value will hold symbols from the Basic Multilingual Plane but not the
    full 32-bit range. This means that 16-bit wide strings should be assumed to be
    UTF-16 encoded because they cannot support Unicode properly otherwise.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 16位值将包含来自基本多语言平面的符号，但不包括完整的32位范围。这意味着应该假定16位宽的字符串是UTF-16编码的，因为否则无法正确支持Unicode。
- en: C++11 rectifies this by introducing explicit `char16_t` and `char32_t` types
    and corresponding versions of string called `std::u16string` and `std::u32string`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: C++11通过引入显式的`char16_t`和`char32_t`类型以及相应版本的字符串`std::u16string`和`std::u32string`来纠正这一点。
- en: Character types
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符类型
- en: So now C++ has 4 character types. Great huh?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在C++有4种字符类型。很棒，对吧？
- en: '| Character type | Encoding |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 字符类型 | 编码 |'
- en: '| --- | --- |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `char` | C, ASCII, EBDIC, UTF-8, ad hoc, ??? |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `char` | C，ASCII，EBDIC，UTF-8，ad hoc，??? |'
- en: '| `wchar_t` | UTF-16 or UTF-32 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `wchar_t` | UTF-16或UTF-32 |'
- en: '| `char16_t` | UTF-16 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `char16_t` | UTF-16 |'
- en: '| `char32_t` | UTF-32 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `char32_t` | UTF-32 |'
- en: Rust
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust
- en: Rust has been rather fortunate. Unicode preceded it so it makes a very simple
    design choice.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Rust非常幸运。Unicode在它之前出现，所以它做了一个非常简单的设计选择。
- en: A `char` type is a 32-bit Unicode character, always enough to hold a single
    character.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`类型是一个32位的Unicode字符，始终足以容纳一个单一字符。'
- en: A `str` type is a UTF-8 encoded string held in memory. Code tends to use &str
    which is a string slice, basically a reference to the str, or a portion of it.
    A str does not need to be terminated with a zero byte and can contain zero bytes
    if it wants.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str`类型是一个UTF-8编码的字符串，保存在内存中。代码倾向于使用`&str`，它是一个字符串切片，基本上是对str的引用，或者是其中的一部分。一个str不需要以零字节结尾，如果需要的话，可以包含零字节。'
- en: A `std::String` is a heap allocated string type use for manipulating strings,
    building them, reading them from file, cloning them etc.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`std::String`是一个堆分配的字符串类型，用于操作字符串，构建字符串，从文件中读取字符串，克隆字符串等。
- en: Note that internally UTF-8 is used for encoding yet a char is 32-bits. The length
    of a strings is considered to be its byte length. There are special iterators
    for walking the string and decoding UTF-8 into 32-bit characters.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，内部使用UTF-8进行编码，但一个字符是32位的。字符串的长度被认为是其字节长度。有特殊的迭代器用于遍历字符串并将UTF-8解码为32位字符。
- en: Finally there is a platform specific type `OSString` that handles any differences
    in how the operating system sees strings compared to Rust.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后有一个特定于平台的类型`OSString`，处理操作系统如何看待字符串与Rust的区别。
- en: Types Comparison
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型比较
- en: '| C++ | Rust |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| C++ | Rust |'
- en: '| --- | --- |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|  | `char *` or `wchar_t *` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|  | `char *`或`wchar_t *` |'
- en: '| C++11 - `char16_t *`, `char32_t *` | `str`, `&str` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| C++11 - `char16_t *`, `char32_t *` | `str`, `&str` |'
- en: '|  | `std::string`, `std::wstring` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|  | `std::string`，`std::wstring` |'
- en: '| `std::u16string` `std::u32string` | `std::String` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `std::u16string` `std::u32string` | `std::String` |'
- en: char * vs str
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: char * vs str
- en: C/C++ do not have a string primitive. A string is a pointer to some bytes in
    memory that are nul terminated. The same applies for wider chars, except of course
    they require 2 or 4 bytes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++没有字符串原语。一个字符串是指向内存中的一些字节的指针，这些字节是以空字符结尾的。对于更宽的字符，同样适用，只是它们需要2或4个字节。
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Rust would use a `str` for this purpose. A `str` is an *immutable* array of
    bytes somewhere in memory. The `str` could be on the heap when it points to a
    `String` object, or it could be in global memory if the string is static. A str
    *slice* is `&str`, is reference to a str which also contains a length value.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Rust会使用`str`来实现这个目的。`str`是一个在内存中的*不可变*字节数组。当它指向一个`String`对象时，该`str`可能在堆上，或者如果字符串是静态的，则可能在全局内存中。一个str
    *slice* 是 `&str`，是对str的引用，也包含一个长度值。
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Type inferences for these assignments will create a string slice pointing to
    the statically allocated string data. The data itself doesn't move and the `&str`
    is read-only.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些赋值，类型推断会创建一个指向静态分配的字符串数据的字符串切片。数据本身不会移动，而`&str`是只读的。
- en: We can also observe that Rust removes the mess of character width and literal
    prefixes that C and C++ have to suffer under because Unicode characters are implicitly
    supported.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以观察到，Rust消除了C和C++必须忍受的字符宽度和字面前缀的混乱，因为Unicode字符是隐式支持的。
- en: The `str` has functions for iterating over the string in bytes / characters,
    splitting, find a pattern etc.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`str`有一些函数用于按字节/字符迭代字符串，拆分字符串，查找模式等。'
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note `len()` is the length in bytes because strings are UTF-8 encoded. A single
    character may be encoded as 1, 2, 3, or 4 bytes. It may not be the number of characters
    a human would actually see.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`len()`是以字节为单位的长度，因为字符串是UTF-8编码的。一个单一字符可能被编码为1、2、3或4个字节。这可能不是一个人类实际看到的字符数。
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can split a `&str` to produce a left and a right `&str` slice like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过拆分`&str`来生成左右`&str`切片，就像这样：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: std::basic_string (C++) vs std::String (Rust)
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: std::basic_string（C++） vs std::String（Rust）
- en: The standard C++ library also has template class `std::basic_string` that acts
    as a wrapper around the various character types and can be used for manipulating
    a string of any width. This template is specialised as
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 C++ 库还有模板类 `std::basic_string`，它充当各种字符类型的包装器，并可用于操作任意宽度的字符串。这个模板被专门化为
- en: '`std::string`, `std:wstring`, `std::u16string` and `std::u32string`.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string`, `std:wstring`, `std::u16string` 和 `std::u32string`。'
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In Rust, the `std::String` type serves the same purpose:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，`std::String` 类型具有相同的作用：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using it is fairly simple
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它相当简单。
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A `String` has functions to do actions such as appending, e.g.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 有用于执行诸如追加等操作的函数，例如：'
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Strings are always valid UTF-8.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串始终是有效的 UTF-8。
- en: Internally a String has a pointer to the data, its length and a capacity (max
    size). If you intend to expand a string, then you should ensure the `String` has
    sufficient capacity to accommodate its longest value otherwise you may cause it
    to reallocate itself excessively.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串内部有指向数据的指针，它的长度和容量（最大大小）。如果你打算扩展一个字符串，那么你应该确保 `String` 有足够的容量来容纳其最长的值，否则你可能会导致它过度重新分配。
- en: Strings will never shrink their capacity unless you explicitly call `shrink_to_fit()`.
    This means if you use a temporary string in a loop, it's probably best to place
    it outside the loop and reserve space to make it efficient.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串永远不会缩小其容量，除非你显式调用 `shrink_to_fit()`。这意味着如果你在循环中使用临时字符串，最好将其放在循环外，并预留空间以使其高效。
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Strings also have all the methods of str thanks to implementing `Deref` trait.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串还具有所有 `str` 的方法，这得益于实现了 `Deref` 特性。
- en: Formatting strings
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化字符串
- en: Strings can be formatted in C with `printf` or `sprintf` or in C++ composed
    with stream operators, e.g. to a `std::stringstream`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以用 `printf` 或 `sprintf` 在 C 中格式化，或者在 C++ 中使用流运算符组合，例如，到 `std::stringstream`。
- en: Rust uses `format!` and `println!` macros that more resemble the `sprintf` model.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 使用 `format!` 和 `println!` 宏，这更类似于 `sprintf` 模型。
- en: '| C++ | Rust formatting trait | Purpose |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| C++ | Rust 格式化特性 | 用途 |'
- en: '| --- | --- | --- |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `%s`, `%u`, `%d`, `%i`, `%f`, `%c` | `{}` | C/C++ require the type of the
    parameter to be specified. In Rust the type is inferred and `{}` will invoked
    the type''s Display trait regardless of what it is. So a String outputs its text,
    numeric types return their value, boolean as returns true or false, and so on.
    |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `%s`, `%u`, `%d`, `%i`, `%f`, `%c` | `{}` | C/C++ 需要指定参数的类型。在 Rust 中，类型是推断的，而
    `{}` 会调用类型的 Display 特性，无论它是什么。因此，String 输出其文本，数值类型返回其值，布尔类型返回 true 或 false，依此类推。
    |'
- en: '| `%lld`, `%llu` | `{}` | C/C++ has extensions to deal with different size
    ints and floats, e.g. ll for long long due to the way arguments are passed to
    the function. In Rust, there is no need for that. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `%lld`, `%llu` | `{}` | C/C++ 有处理不同大小整数和浮点数的扩展，例如，由于参数传递给函数的方式，long long
    会用 ll 表示。在 Rust 中，这是不需要的。 |'
- en: '|  | `{:?}`, `{:#?}` | In Rust `{:?}` returns whatever is implemented by a
    type''s Debug trait. The `{:#?}` variant can be used to pretty-print the output
    for types that derive the Debug trait. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|  | `{:?}`, `{:#?}` | 在 Rust 中，`{:?}` 返回类型实现的 Debug 特性。`{:#?}` 变体可用于漂亮地打印实现
    Debug 特性的类型的输出。 |'
- en: '| `%-10s` | `{:<10}` | Format left aligned string padded to minimum of 10 spaces
    |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `%-10s` | `{:<10}` | 格式化为左对齐字符串，填充到至少 10 个空格。'
- en: '| `%04` | `{:04}` | Pad a number with zero''s to a width of 4 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `%04` | `{:04}` | 将数字填充到 4 位宽度的零 |'
- en: '| `%.3` | `{:.3}` | Pad a number''s precision to 3 decimal places. May also
    be zero-padded, e.g. {:.03} |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `%.3` | `{:.3}` | 将数字的精度填充到 3 位小数。也可以进行零填充，例如：{:.03} |'
- en: '| `%e`, `%E` | `{:e}`, `{:E}` | Exponent in lower or uppercase |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `%e`, `%E` | `{:e}`, `{:E}` | 指数，小写或大写 |'
- en: '| `%x`, `%X` | `{:x}`, `{:X}` | Hexadecimal in lower or uppercase. Note `{:#x}`,
    `{:#X}` prefixes the output with 0x |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `%x`, `%X` | `{:x}`, `{:X}` | 十六进制，小写或大写。请注意，`{:#x}`、`{:#X}` 会在输出前面加上 0x。
    |'
- en: '| `%o` | `{:o}` | Octal. Note `{:#o}` prefixes the output with 0o |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `%o` | `{:o}` | 八进制。请注意，`{:#o}` 会在输出前面加上 0o。'
- en: '|  | `{:b}` | Binary. Note `{:#b}` prefixes the output with 0b |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|  | `{:b}` | 二进制。请注意，`{:#b}` 会在输出前面加上 0b。'
- en: '| `%p` | `{:p}` | Presents a struct''s memory location, i.e. pointer |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `%p` | `{:p}` | 显示结构体的内存位置，即指针 |'
- en: Rust has many [more formatting traits](https://doc.rust-lang.org/std/fmt/#formatting-traits)
    than this.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 比这还有[更多的格式化特性](https://doc.rust-lang.org/std/fmt/#formatting-traits)。
- en: 'For example it allows named parameters like this example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，它允许像这个例子这样的命名参数：
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Named parameters would be particularly useful for localization where the order
    of values may be different in one language compared to another.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数在本地化中特别有用，因为一个语言中值的顺序可能与另一种语言中的不同。
- en: Display and Debug traits
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示和调试特征
- en: Rust allows types to be formatted as strings based upon the formatting traits
    they implement.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 允许根据它们实现的格式化特征将类型格式化为字符串。
- en: 'The two main implementation traits are:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 两个主要的实现特征是：
- en: '`Display` - this is for standard textual representation of a type.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Display` - 用于类型的标准文本表示。'
- en: '`Debug` - this is for the debugging textual representation of a type. It might
    present additional information or be formatted separately to the Display trait.
    It is possible to `#[derive(Debug)]` this trait which is usually enough for the
    purpose of debugging.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Debug` - 用于类型的调试文本表示。它可能提供额外信息或单独格式化以供调试。通常通过 `#[derive(Debug)]` 实现此特征，这通常足够用于调试目的。'
- en: If we look at the traits we can see they're identical
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看特征，我们会发现它们是相同的
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'All of the intrinsic types implement `Display` and `Debug`. We can explicitly
    implement Display on our own structs too:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内置类型都实现了 `Display` 和 `Debug`。我们也可以在自己的结构体上显式实现 Display：
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Implementing `Debug` is usually done by `#[derive(Debug)]` but it could also
    be implemented. The derived `Debug` will print out the struct name, and then the
    members in curly braces:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通常通过 `#[derive(Debug)]` 实现 `Debug`，但也可以手动实现。派生的 `Debug` 将打印出结构体名称，然后是花括号中的成员：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Many types process formatting traits which are values held between the `{}`
    braces in the string. These are fairly similar to the patterns used in C functions
    for printf, sprintf etc.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 许多类型处理格式化特征，这些特征是字符串中 `{}` 括号之间保存的值。这些与 C 函数中用于 printf、sprintf 等的模式非常相似。
- en: OsString / OsStr
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OsString / OsStr
- en: Rust recognises there are times when you need to pass or receive a string from
    a system API.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 认识到有时需要从系统 API 传递或接收字符串。
- en: In this case you may use `OsString` which allows interchange between Rust and
    a system dependent representations of strings. On Windows it will return UTF-16
    strings, on Linux / Unix systems it will return UTF-8.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以使用 `OsString`，它允许在 Rust 和系统相关的字符串表示之间进行交换。在 Windows 上，它将返回 UTF-16
    字符串，在 Linux / Unix 系统上，它将返回 UTF-8。
- en: An `OsStr` is a slice onto `OsString`, analogous to `str` and `String`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`OsStr` 是对 `OsString` 的切片，类似于 `str` 和 `String`。'
- en: Variables
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: Variables
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: C++
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++
- en: Type Inference
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型推断
- en: C++11 has type inference, previous versions of C++ do not. Type inference allows
    the programmer to assign a value to an `auto` typed variable and let the compiler
    infer the type based on the assignment.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 具有类型推断，之前的版本不具备。类型推断允许程序员将值赋给 `auto` 类型的变量，让编译器根据赋值推断类型。
- en: Boolean and numeric types are fairly easy to understand providing the code is
    as explicit as it needs to be.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔和数值类型相对容易理解，只要代码尽可能明确。
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Where C++ gets messy is for arrays and strings. Recall that strings are not
    primitive types in the strong sense within C or C++ so auto requires they be explicitly
    defined or the type will be wrong.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 处理数组和字符串时会变得混乱。请记住，在 C 或 C++ 中，字符串不是原始类型，因此 `auto` 需要明确定义它们，否则类型将错误。
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Strings are covered elsewhere, but essentially there are many kinds of strings
    and C++/C has grown a whole bunch of string prefixes to deal with them all.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串在其他地方有涵盖，但基本上有许多种类的字符串，C++/C 已经发展出了一大堆字符串前缀来处理它们。
- en: Arrays are a more interesting problem. The `auto` keyword has no easy way to
    infer array type so is one hack workaround to assign a templatized array to an
    `auto` and coerce it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一个更有趣的问题。`auto` 关键字没有简单的方法推断数组类型，因此将模板化数组分配给 `auto` 并强制转换是一种解决方法。
- en: '[PRE45]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Rust
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust
- en: Rust, variables are declared with a `let` command. The `let` may specify the
    variable's type, or it may also use type inference to infer it from the value
    it is assigned with.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，变量使用 `let` 命令声明。`let` 可能指定变量的类型，也可以使用类型推断从赋值的值中推断出类型。
- en: '[PRE46]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Rust has no problem with using type inference in array assignments:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 在数组赋值中使用类型推断没有问题：
- en: '[PRE47]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Note that all array elements must be the same type, inference would generate
    a compiler error for an array like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有数组元素必须是相同类型，推断会为这样的数组生成编译器错误：
- en: '[PRE48]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Scope rules
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域规则
- en: Scope rules in C, C++ and Rust are fairly similar - the scope that you declare
    the item determines its lifetime.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: C、C++ 和 Rust 中的作用域规则相当相似 - 声明项目的作用域决定了其生命周期。
- en: Shadowing variables
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量的阴影
- en: One very useful feature of Rust is that you can declare the same named variable
    more than once in the same scope or nested scopes and the compiler doesn't mind.
    In fact you'll use this feature a lot.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'This is called *shadowing* and works like this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This example uses the variable name `result` 3 times. First to store the result
    of calling `do_something()`, then to extract some value `Foo` from `Option<Foo>`
    and a third time for calling something else. We could have assigned `result` to
    `result2` and then later on assigned the value `do_something_else()` to `result3`
    but we didn't need to because of shadowing.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Pointers
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A pointer is a variable that points to an address somewhere in memory. The pointer's
    *type* indicates to the compiler what to expect at the address but there is no
    enforcement to ensure that the address actually holds that type. A pointer might
    might be assigned `NULL` (or `nullptr` in C++11) or may even be garbage if nothing
    was assigned to it.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Generally pointers are used in situations where references cannot be used, e.g.
    functions returning allocated memory or parent / child collection relationships
    where circular dependencies would prevent the use of references.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: C++11 deprecates `NULL` in favour of new keyword `nullptr` to solve a problem
    with function overloading.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Since `NULL` is essentially `#define NULL 0` and 0 is an integer, we call the
    wrong function by accident. So C++ introduces an explicit `nullptr` for this purpose.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In Rust:'
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust supports pointers, normally called *raw* pointers however you will rarely
    use them unless you need to interact with C API or similar purposes.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'A pointer looks fairly similar to that of C++:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Although you can make a pointer outside of an unsafe block, many of the functions
    you might want to perform on pointers are unsafe by definition and must be inside
    `unsafe` blocks.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: The documentation in full is [here](https://doc.rust-lang.org/std/primitive.pointer.html).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: References
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A reference is also a variable that points to an address but unlike a pointer,
    it cannot be reassigned and it cannot be `NULL`. Therefore a reference is generally
    assumed to be safer than a pointer. It is still possible for the a reference to
    become dangling, assuming the address it referenced is no longer valid.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: In Rust
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A reference is also lifetime tracked by the compiler.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tuple is list of values held in parenthesis. They're useful in cases where
    transient or ad-hoc data is being passed around and you cannot be bothered to
    write a special struct just for that case.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: In C++
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C++ does not natively support tuples, but C++11 provides a template for passing
    them around like so:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In Rust
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tuples are part of the language and therefore they're far more terse and easy
    to work with.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Literals
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Literals
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integers
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Integer numbers are a decimal value followed by an optional type suffix.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++ an [integer literal](http://en.cppreference.com/w/cpp/language/integer_literal#The_type_of_the_literal)
    can be expressed as just the number or also with a suffix. Values in hexadecimal,
    octal and binary are denoted with a prefix:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `u`, `l`, and `ll` suffixes on integers denotes if it is `unsigned`, `long`
    or a `long long` type. The `u` and `l`/`ll` can be upper or lowercase. Ordinarily
    the `u` must precede the size but C++14 allows the reverse order.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: C++14 also allows single quotes to be inserted into the number as separators
    - these quotes can appear anywhere and are ignored.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Floating point numbers
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Floating point numbers may represent whole or fractional numbers.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Boolean values
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C/C++ `bool` literals are `true` or `false`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Characters and Strings
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A character literal is enclosed by single quotes and an optional width prefix.
    The prefix `L` indicates a wide character, `u` for UTF-16 and `U` for UTF-32.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: One oddity of a `char` literal is that `sizeof('a')` yields `sizeof(int)` in
    C but `sizeof(char)` in C++. It isn't a good idea to test the size of a character
    literal.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: A `char16_t` and `char32_t` are sufficient to hold any UTF-16 and UTF-32 code
    unit respectively.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: A string is a sequence of characters enclosed by double quotes. A zero value
    terminator is always appended to the end. Prefixes work the same as for character
    literals with an additional `u8` type to indicate a UTF-8 encoded string.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: User-defined literals
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++11 introduced [user-defined literals](http://en.cppreference.com/w/cpp/language/user_literal).
    These allow integer, floats, chars and strings to have a user defined type suffix
    consisting of an underscore and a lowercase string. The prefix may act as a form
    of decorator or even a constant expression operator which modifies the value at
    compile time.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: C++14 goes further and defines user-defined literals for complex numbers and
    units of time.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: See the link for more information.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Rust
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integers
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Rust [number literals](https://doc.rust-lang.org/reference.html#integer-literals)
    can also be expressed as just the number or also with a suffix. Values in hexadecimal,
    octal and binary are also denoted with a prefix:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The underscore in Rust is a separator and functions the same way as the single
    quote in C++14.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Floating point numbers
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Floating point numbers may represent whole or fractional numbers. As with integers
    they may be suffixed to indicate their type.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'One quirk with floating point numbers is the decimal point is used for float
    assignments but it''s also used for member and function invocation. So you can''t
    say `2.f32` since it thinks you are referencing f32 on 2\. Instead syntax requires
    you to say `2.f32` or alter how you declare the type, e.g. `let v: f32 = 2.;`.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Boolean literals are simply `true` or `false`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Characters and Strings
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A character in Rust is any UTF-32 code point enclosed by single quotes. This
    value may be escaped or not since .rs files are UTF-8 encoded.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: A special prefix `b` may be used to denote a byte string, i.e. a string where
    each character is a single byte.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Strings are the string text enclosed by double quotes:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The prefix `b` denotes a byte string, i.e. single byte characters. Rust allows
    newlines, space, double quotes and backslashes to be escaped using backslash notation
    similar to C++.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Strings can also be 'raw' to avoid escaping. In this case, the string is prefixed
    r followed by zero or more hash marks, the string in double quotes and the same
    number of hash marks to close. Byte strings are uninterpretted byte values in
    a string.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Collections
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collections
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A collection is something that holds zero or more elements in some fashion that
    allows you to enumerate those elements, add or remove elements, find them and
    so forth.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Vector - a dynamic array. Appending or removing elements from the end is cheap
    (providing the array is large enough to accomodate an additional item). Inserting
    items or removing them from any other part of the array is more expensive and
    involves memory movements. Generally speaking you should always reserve enough
    space in a vector for the most elements you anticipate it will hold. Reallocating
    memory can be expensive and lead to fragmentation.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vecdeque - a ring buffer array. Items can be added or removed from either end
    relatively cheaply. Items in the array are not arranged sequentially so there
    is a little more complexity to managing wraparound and removal than a Vector.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LinkedList - a linked list individually allocates memory for each element making
    it cheap to add or remove elements from anywhere in the list. However there is
    a lot more overhead to iterating the list by index and much more heap allocation.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set - a collection that holds a unique set of items. Inserting a duplicate item
    will not succeed. Some sets maintain the order of insertion. Sets are useful where
    you want to weed out duplicates from an input.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map - a collection where each item is referenced by a unique key. Some maps
    can maintain the order of insertion.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ and Rust have have collections as part of their standard library as is common
    with modern languages.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '| C | C++ | Rust |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
- en: '| - | `std::vector` | `std::vec::Vec` or `std::collections::VecDeque` |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
- en: '| - | `std::list` | `std::collections::LinkedList` |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
- en: '| - | `std::set` | `std::collections::HashSet`, `std::collections::BTreeSet`
    |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
- en: '| - | `std::map` | `std::collections::HashMap`, `std::collections::BTreeMap`
    |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
- en: C has no standard collection classes or types. Some libraries offer collection
    APIs such as [glib](https://developer.gnome.org/glib/) or [cii](https://github.com/drh/cii).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Iterators
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Iterators are a reference to a position in a collection with the means to step
    through the collection one element at a time.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: C++
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C++11 provides a shorthand way of iterating a collection:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Iterators are more explicit in C++98 and before and the code in C++11 is basically
    equivalent to this:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This is quite verbose, but essentially each collection type defines a mutable
    `iterator` and immutable `const_iterator` type and calling `begin` returns an
    iterator to the beginning of the collection. Calling the `++` operator overload
    on the iterator causes it to advance to the next element in the collection. When
    it hits the exclusive value returned by `end` it has reached the end of the collection.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Obviously with an indexed type such as a `vector` you could also reference elements
    by index, but it is far more efficient to use iterators for other collection types.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Processing collections
  id: totrans-396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C++ provides a number of utility templates in <algorithm class="hljs-meta">for
    modifying sequences in collections on the fly.</algorithm>
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Rust
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust also has iterators which work in a similar fashion to C++ - incrementing
    their way through collections.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: TODO
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: TODO chaining iterators together
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: TODO mapping one collection to another collection
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Structs
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structs
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `class` and a `struct` in C++ are largely the same thing from an implementation
    standpoint. They both hold fields and they both can have methods attached to the
    class (`static`) or instance level.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The default access level is `public` for struct and `private` for class. Some
    rules about templates only apply to classes.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: From a psychological perspect a `struct` tends to be used to hold public data
    that is largely static and/or passed around. A `class` tends to be something more
    self contained with methods that are called to access or manage private fields.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'So these are equivalents:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Classes can also use an access specifier to inherit from a base class. So a
    class may specify `public`, `protected` or `private` when deriving from another
    class depending on whether it wants those methods to be visible to callers, or
    subclasses.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Classes and structs may have special constructor and destructor methods which
    are described in sections below.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then in the .cpp file you might implement the constructor and method:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Rust
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust only has structs. A `struct` consists of a definition which specifies the
    fields and their access level (public or not), and an `impl` section which contains
    the implementation of functions bound to the struct.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'An `impl` section follows containing the associated functions:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `new()` function here is a convenience method that returns a struct preinitialised
    with the arguments supplied. The `area()` function specifies a `&self` argument
    and returns an area calculation. Any function that supplies a `&self`, or `&mut
    self` can be called from the variable bound to the struct.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `self` keyword works in much the same way as C++ uses `this`, as a reference
    to the struct from which the function was invoked. If a function modifies the
    struct it must say `&mut self`, which indicates the function modifies the struct.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: There is no inheritance in Rust. Instead, a `struct` may implement zero or more
    traits. A trait describes some kind of behavior that can be associated with the
    struct and described further later on in this chapter.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++ all classes have implicit or explicit constructors. Either the compiler
    generates them or you do, or a mix of both.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: An implicit default constructor, copy constructor and assignment operator will
    be created when a class does not define its own. We saw on page 73 why this could
    be really bad news.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: What becomes obvious from reading there is a lot of noise and potential for
    error in C++. There would be even more if raw pointers were used instead of a
    `std::unique_ptr` here.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, things are simpler, and we'll see how it shakes out errors.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, let''s declare our equivalent struct in Rust:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Since credentials are optional, we wrap in an `Option` object, i.e. credentials
    might be None or it might be `Some(Credentials)`. Any code anywhere in the system
    can instantiate a `Person` simply be declaring an instance:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In Rust you cannot create a struct without initialising all its members so we
    cannot have a situation where we don't know what is in each field - it MUST be
    set by our code.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: But declaring the struct is a bit clumsy, especially if the struct is created
    in lots of places. So can write function that behaves like a constructor in C++.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Instead you implement a static method in the impl of the Struct which returns
    an initialised struct, e.g.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note that Rust does not support overloads. So if we had multiple "constructor"
    methods, they would each have to have unique names.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Finally what is we wanted to copy the `Person` struct?
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: By default Rust does not allow copying on user-defined structs. Assigning a
    variable to another variable moves ownership, it doesn't copy.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to make a user-defined struct copyable
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: implement the `Copy` trait which means assignment is implicit, but is what we
    want? Do we really want to make copies of a struct by accident?
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: implement `Clone` instead to add a `clone()` method and require an explicit
    call to `clone()` order to duplicate the struct a copy.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But the compiler can derive clone() providing all the members of the struct
    implement the Clone trait.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: What we can see is that Rust's construction and `clone()` behavior is basically
    declarative. We saw how C++ has all kinds of rules and nuances to construction,
    copy construction and assignment which make it complicated and prone to error.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Destructors
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A C++ destructor is a specialized method called when your object goes out of
    scope or is deleted.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In C++ you can declare a class destructor to be called when the object is about
    to be destroyed. You have to use a virtual destructor if your class inherits from
    another class in case a caller calls `delete` on the base class.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Since Rust does not do inheritance and does not have constructors, the manner
    in which you cleanup is different and simpler. Instead of a destructor you implement
    the `Drop` trait.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The compiler recognizes this trait. If you implement this trait then the compiler
    knows to call your `drop()` function prior to destroying your struct. It’s that
    simple.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'Occasionally there might be a reason to explicitly drop a struct before it
    goes out of scope. Perhaps the resources held by the variable should be freed
    as soon as possible to release a resource which is in contention. Whatever the
    reason, the answer is to call `drop` like this:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Access specifier rules
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A C++ class can hide or show methods and members to any other class, or to
    things that inherit from itself using the public, private and protected keywords:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '`public` – can be seen by any code internal or external to the class'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private` – can only be used by code internal to the class. Not even subclasses
    can access these members'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected` – can be used by code internal to the class and by subclasses.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class may designate another function or class as a friend which has access
    to the private and protected members of a class.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: Rust makes things somewhat simpler.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: If you want a struct to be visible outside your module you mark it `pub`. If
    you do not mark it `pub` then it is only visible within the module and submodules.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: If you want publicaccess a member of a struct (including modifying it if its
    mutable), then mark it `pub`.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: If you want something to be able to call a function on your struct you mark
    it `pub`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Functions
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions can be bound to a struct within an `impl` block:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Functions that start with a `&self` / `&mut self` parameter are bound to instances.
    Those without are bound to the type. So the `new()` function can be called as
    `Shape::new()`.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'Where `&self` is provided, the function is invoked on the instance. So for
    example:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Where `&mut self` is provided it signifies that the function mutates the struct.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike C++, all access to the struct has to be qualified. In C++ you don''t
    publishing_interval: Double, lifetime_count: UInt32, max_keep_alive_count: UInt32,
    max_notifications_per_publish: UInt32, priority: Bytehave to say `this->foo()`
    to call foo() from another member of the class. Rust requires code to say unambiguously
    `self.foo()`.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: Static functions
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static functions are merely functions in the `impl` block that do not have `&self`
    or `&mut self` as their first parameter, e.g.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In other words they're not bound to an instance of a type, but to the type itself.
    For example, `Circle::pi()`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Traits
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ allows one class to inherit from another. Generally this is a useful feature
    although it can get pretty complex if you implement multiple inheritance, particularly
    the dreaded diamond pattern.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve found out, Rust doesn’t have classes at all – they’re structs with
    bound functions. So how do you inherit code? The answer is you don’t.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Instead your struct may implement traits which are a bit like partial classes.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 'A trait is declared like so:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Here the trait `HasCircumference` has a function called `circumference()` whose
    signature is defined but must be implemented.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: A type can implement the trait by declaring and `impl` of it.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: A trait may supply default function implementations. For example, a `HasDimensions`
    trait might implement `area()` to spare the implementor the bother of doing it.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Lifetimes
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++ an object lives from the moment it is constructed to the moment it is
    destructed.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: That lifetime is implicit if you declare the object on the stack. The object
    will be created / destroyed as it goes in and out of scope. It is also implicit
    if your object is a member of another object - the lifetime is within the containing
    object, and the declaration order of other members in the containing object.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: However, if you allocate your object via `new` then it is up to you when to
    `delete`. If you `delete` too soon, or forget to `delete` then you may destabilize
    your program. C++ encourages using smart pointers that manage the lifetime of
    your object, tying it to the implicit lifetime of the smart pointer itself - when
    the smart pointer is destroyed, it deletes the held pointer. A more sophisticated
    kind of smart pointer allows multiple instances of the same pointer to exist at
    once, and reference counting is used so that when the last smart pointer is destroyed,
    it destroyes the pointer.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Even so, C++ itself will not care if you initialized a class with a reference
    or pointer to something that no longer lives. If you do this, your program will
    crash.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: Let's write an `Incrementor` class which increments an integer value and returns
    that value.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This seems fine, but what if we use it like this?
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This code passes a reference to an `int` into the class constructor and returns
    the `Incrementor` from the function itself. But when `increment()` is called the
    reference is dangling and anything can happen.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: Rust lifetimes
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust *does* care about the lifetime of objects and tracks them to ensure that
    you cannot reference something that no longer exists. Most of the time this is
    automatic and self-evident from the error message you get if you try something
    bad.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler also implements a *borrow checker* which tracks references to
    objects to ensure that:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: References are held no longer than the lifetime of the object they refer to.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only a single mutable reference is possible at a time and not concurrently with
    immutable references. This is to prevent data races.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The compiler will generate compile errors if it finds code in violation of its
    rules.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s write the equivalent of `Incrementor` above but in Rust. The Rust
    code will hold a reference to a integer `i32` and increment it from a bound function:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Seems fine, but the first error we get is:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We tried to create a struct that manages a reference, but the compiler doesn't
    know anything about this reference's lifetime and so it has generated a compile
    error.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: To help the compiler overcome its problem, we will annotate our struct with
    a lifetime which we will call `'a`. The label is anything you like but typically
    it'll be a letter.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 'This lifetime label is a hint on our struct that says the reference we use
    inside the struct must have a lifetime of at least as much the struct itself -
    namely that `Incrementor<''a>` and `value: &''a mut i32` share the same lifetime
    constraint and the compiler will enforce it.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'With the annotation in place, we can now use the code:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Note that the annotation `'a` could be any label we like - `'increment` would
    work if we wanted, but obviously its more longwinded.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: There is a special lifetime called `'static` that refers to things like static
    strings and functions which have a lifetime as long as the runtime and may therefore
    be assumed to always exist.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: Lifetime elision
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust allows reference lifetimes to be elided (a [fancy word](https://ericlippert.com/2013/01/24/five-dollar-words-for-programmers-elision/)
    for omit) in most function signatures.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Basically, it assumes that when passing a reference into a function, that the
    lifetime of the reference is implicitly longer than the function itself so the
    need to annotate is not necessary.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The rules for elision are described in the further reference link.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: Further reference
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lifetimes are a large subject and the documentation is [here](https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-elision).
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  id: totrans-528
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comments
  id: totrans-529
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust comments are similar to C++ except they may contain Unicode because .rs
    files are UTF-8 encoded:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'But in addition anything that uses triple slash `///` annotation can be parsed
    by a tool called `rustdoc` to produce documentation:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Runnining `cargo doc` on a project will cause HTML documentation to be produced
    from annotated comments within the file.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: Annotation is written in Markdown format. That means you have a human readable
    language for writing rich-text documentation and if it's not enough you can resort
    to HTML via tags.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: See here for [full documentation](https://doc.rust-lang.org/book/documentation.html)
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: Lifetimes, References and Borrowing
  id: totrans-537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lifetimes, References and Borrowing
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you assign an object to a variable in Rust, you are said to be binding
    it. i.e your variable "owns" the object for as long as it is in scope and when
    it goes out of scope it is destroyed.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: So variables are scoped and the scope is the constraint that affects their lifetime.
    Outside of the scope, the variable is invalid.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: In this example, it is important to remember the `Vec` is on the stack but the
    pointer it allocates to hold its elements is on the heap. The heap space will
    also be recovered when the `Vec` is dropped.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'If we assign v1 to another variable, then all the object ownership is moved
    to that other variable:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This may seem weird but it's worth remembering a serious problem we saw in C++,
    that of copy constructor errors. It is too easy to duplicate a class and inadvertantly
    share private date or state across multiple instances.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: We don't want objects v1 and v2 to share internal state and in Rust they don't.
    Rust moves the data from v1 to v2 and marks v1 as invalid. If you attempt to reference
    v1 any more in your code, it will generate a compile error. This compile error
    will indicates that ownership was moved to v2.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, if we pass the value to a function then that also moves ownership:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'When we call we_own_it() we moved ownership of the object to the function and
    it never came back. Therefore the following call using v1 is invalid. We could
    call a variation of the function called we_own_and_return_it() which does return
    ownership:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: But that's pretty messy and there is a better way described in the next section
    called borrowing.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: These move assignments look weird but it is Rust protecting you from the kinds
    of copy constructor error that is all too common in C++. If you assign a non-Copyable
    object from one variable to another you move ownership and the old variable is
    invalid.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: If you truly want to copy the object from one variable to another so that both
    hold independent objects you must make your object implement the Copy trait. Normally
    it's better to implement the Clone trait which works in a similar way but through
    an explicit clone() operation.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: Variables must be bound to something
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another point. Variables must be bound to something. You cannot use a variable
    if it hasn''t been initialized with a value of some kind:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: It is quite valid in C++ to declare variable and do nothing with it. Or conditionally
    do something to the variable which confuses the compiler so it only generates
    a warning.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The Rust compiler will throw an error, not a warning, if variables are uninitialised.
    It will also warn you if you declare a variable and end up not using it.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: References and Borrowing
  id: totrans-560
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen that ownership of an object is tracked by the compiler. If you assign
    one variable to another, ownership of the object is said to have moved to the
    assignee. The original variable is invalid and the compiler will generate errors
    if it is used.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately this extends to passing values into functions and this is a nuisance.
    But variable bindings can be borrowed. If you wish to loan a variable to a function
    for its duration, you can pass a reference to the object:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Here we create an empty vector and pass a mutable reference to it to a function
    called fill_vector(). The compiler knows that the function is borrowing v and
    then ownership is returned to v after the function returns.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  id: totrans-565
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expressions
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An expression is something that evaluates to something. Just like C++ more or
    less...
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: But blocks are expressions too
  id: totrans-569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Where it gets more interesting is that a block of code, denoted by curly braces
    also evaluates to an expression. This is legal code:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: What was assigned to x? In this case the block was empty so x was assigned with
    the value of `()`. The value `()` is a special unitary type that essentially means
    neither yes or no. It just means "value". That is the default type of any function
    or type. It works a little like `void` in C++ meaning the value is meaningless
    so don't even look at it.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This block also returns a value of `()`.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Again, that's because although the block does stuff (print Hello), it doesn't
    evaluate to anything so the compiler returns `()` for us.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: 'So far so useless. But we can change what the block expression evaluates to:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Now x assigned with the result of the last line which is an expression. Note
    how the line is not terminated with a semicolon. That becomes the result of the
    block expression. If we’d put a semicolon on the end of that line as we did with
    the println!("Hello"), the expression would evaluate to ().
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: Use in functions
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Trivial functions can just omit the return statement:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: You can use return in blocks too
  id: totrans-583
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you might explicitly need to use the return statement. The block expression
    evaluates at the end of the block so if you need to bail early you could just
    use return.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Simplifying switch statements
  id: totrans-586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In C or C++ you''ll often see code like this:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The code wants to test a value in server_state and assign a string to result.
    Aside from looking a bit clunky it introduces the possibility of error since we
    might forget to assign, or add a break, or omit one of the values.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: In Rust we can assign directly into result of from a match because each match
    condition is a block expression.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Not only is this half the length it reduces the scope for error. The compiler
    will assign the block expression's value to the variable result. It will also
    check that each match block returns the same kind of type (so you can't return
    a float from one match and strings from others). It will also generate an error
    if the ServerState enum had other values that our match didn't handle.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Ternary operator
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ternary operator in C/C++ is an abbreviated way to perform an if/else expression
    condition, usually to assign the result to a variable.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Rust has no such equivalent to a ternary operator but it can be accomplished
    using block expressions.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Unlike C/C++ you could add additiona else ifs, matches or anything else to that
    providing each branch returns the same type.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: Conditions
  id: totrans-599
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conditions
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conditional code is similar between C++ and Rust. You test the boolean truth
    of an expression and you can use boolean operators such as && and || to join expressions
    together.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'In Rust:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The most notable difference is that Rust omits the outer braces so the code
    is slightly cleaner. You don't have to omit the outer braces but the compiler
    will issue a warning if you leave them in.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: Ternary operator
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ternary operator is that special ? : shorthand notation you can use to
    in C++ for simple conditionals.'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Rust does not support this notation, however you may take advantage of how
    a block evaluates as an expression to say this instead:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'So basically you can do one line conditional assignments using if and else.
    Also note that you could even throw in an "else if" or two if that''s what you
    wanted to do:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Conditional "if let"
  id: totrans-613
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One unusual feature is the "if let" pattern. This combines a test to see if
    something matches a pattern and if it does, to automatically assign the result
    to the tuple. It would be most commonly see in code that returns an enum such
    as a `Result` or `Option`.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Switch / Match
  id: totrans-617
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Switch / Match
  id: totrans-618
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++
  id: totrans-619
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `switch` statement in C or C++ allows a condition or a variable to be compared
    to a series of values and for code associated with those values to executed as
    a result. There is also a default clause to match any value that is is not caught
    explicitly.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Switch statements can be a source of error because behaviour is undefined when
    a `default` clause is not supplied. It is also possible to inadvertently forget
    the `break` statement. In the above example, the code explicitly "drops" from
    the 404 handler into the default handler. This code would work fine providing
    someone didn't insert some extra clauses between 404 and default...
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: Additionally switch statements only work on numeric values (or `bool`).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: Rust
  id: totrans-624
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Match](https://doc.rust-lang.org/book/match.html) is like a `switch` statement
    on steroids.'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: In C++ a switch is a straight comparison of an integer value of some kind (including
    chars and enums), against a list of values. If the comparison matches, the code
    next to it executes until the bottom of the switch statement or a break is reached.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: TODO
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: Casting
  id: totrans-628
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Casting
  id: totrans-629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Casting is the act of coercing one type to be another, or dynamically producing
    the equivalent value in the other type.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: C++ has a range of cast operators that turn a pointer or value of one kind into
    a pointer or value of another kind.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '`const_cast<T>(value)` - removes the const enforcement from a value so it may
    be modified.'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static_cast<T>(value)` - attempts to convert between types using implicit
    and user defined conversions.'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reinterpret_cast<T>(value)` - a compiler directive to just treat the input
    as some other kind. It does not involve any form of conversion.'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dynamic_cast<T>(value)` - attempts to convert a class pointer / reference
    to/from other classes in its inheritance hierarchy. Involves runtime checks.'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traditional C-style cast - a C++ compiler will attempt to interpret it as a
    `const_cast`, a `static_cast` and a `reinterpret_cast` in varying combinations.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's a very brief summary of casting which probably invokes more questions
    than it answers. Casting in C++ is very complex and nuanced. Some casts merely
    instruct the compiler to ignore const or treat one type as another. A static cast
    might involve code generation to convert a type. A dynamic cast might add runtime
    checks and throw exceptions.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: Rust has nothing equivalent to this complexity. A numeric type may be converted
    to another numeric type using the [`as`](https://doc.rust-lang.org/book/casting-between-types.html#as)
    keyword.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Anything beyond this requires implementing the `Into<>` or `From<>` traits and
    making conversion an explicit action.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: The compiler also does not allow code to cast away `const`-ness or treat one
    type as another except through `unsafe` code blocks.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: Transmutation
  id: totrans-642
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust allows some types to be [transmuted](https://doc.rust-lang.org/book/casting-between-types.html#transmute)
    to others. Transmute is an `unsafe` action but it allows a memory location to
    be treated as another type, e.g. an array of bytes as an integer.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  id: totrans-644
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enumerations
  id: totrans-645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++ an `enum` is a bunch of labels assigned an `int` value. i.e. it is basically
    a bunch of constants with scalar values.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: C++11 extends this concept a little, allowing you to declare an `enum` that
    uses another kind of integral type, e.g. a `char` to hold the values.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: In Rust an [`enum`](https://doc.rust-lang.org/book/enums.html) can be a scalar
    value just like in C++.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: But an enum can also hold actual data so you can convey far more information
    than a static value could by itself.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'You can also bind functions to the enum:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'So we might have a function that makes an http request and returns a response:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Now our code is able to return a more meaningful response in an enum and the
    code is able to extract that response to print out useful information.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  id: totrans-659
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loops
  id: totrans-660
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++
  id: totrans-661
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For loops
  id: totrans-662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `for` loop in C/C++ consists of 3 expression sections housed in the `for()`
    section and a block of code to execute:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: 'The three segments of a for statement allow:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: Zero or more variables to be initialized (can be empty)
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero or more conditions to be true for the loop to continue (can be empty)
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero or more actions to perform on each iteration (can be empty).
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So this is a valid for loop:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'So is this:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This is clearly a convoluted and somewhat confusing loop because it mixes assignment
    and conditional tests into the terminating text, but it is one which is entirely
    legal.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: Iterating a range
  id: totrans-673
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A C++ loop consists of an initialising expression, a condition expression and
    a a loop expression separated by semicolons. So a loop that iterates from 0 to
    100 looks like this:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Iterating C++ collections
  id: totrans-676
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C++ introduces the concept of iterators to its collection classes. An `iterator`
    is something that can increment or decrement to traverse a collection.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: So to iterate a collection from one end to the other, an iterator is assigned
    with the collection's `begin()` iterator and incremented until it matches the
    `end()` iterator.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'C++11 provides new range based for-loop with simpler syntax when iterating
    over arrays and collections:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Infinite Loop
  id: totrans-682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An infinite loop is one that never ends. The typical way to do this in C++
    is to test against an expression that always evaluates to true or use an empty
    for loop:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: While Loop
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ has conditional `while() {}` and `do { } while()` forms. The former tests
    the expression before it even runs while the latter runs at least once before
    testing the expression.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The do-while form in C++ will execute the loop body at least once because the
    condition is only tested after each iteration instead of before.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Break and Continue
  id: totrans-690
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to exit a loop or start the next iteration early then you use the
    `break` and `continue` keywords. The break keyword terminates the loop, the continue,
    causes the loop to proceed to the next iteration.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Rust
  id: totrans-693
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For loop
  id: totrans-694
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust's `for` loop is actually sugar over the top of iterators. If a structured
    type implements the trait `IntoIterator` it can be looped over using a `for` loop.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically in pseudo code, the loop desugars to this:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Iterating a range
  id: totrans-698
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `Range` object in Rust is expressed as `from..to` where `from` and `to` are
    values or expressions that evaluate to values.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: A range is inclusive / exclusive, i.e. the minimum value is included in the
    `Range` but the maximum value is exclusive.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: Here is a simple loop that counts from 0 to 9
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: The value `0..10` is a `Range` that runs from 0 to exclusive of 10\. A range
    implements the `Iterator` trait so the for loop advances one element at a time
    until it reaches the end.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: Iterators have a lot of functions on them for doing fancy stuff, but one which
    is useful in loops is the `enumerate()` function. This transforms the iterator
    into returning a tuple containing the index and the value instead of just the
    value.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: 'So for example:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: For loop - Iterating arrays and collections
  id: totrans-709
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a loop that iterates an array:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Note you can only iterate over an array by reference because iterating it by
    value would be destructive.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: 'We can directly use the `iter()` function that arrays and collections implement
    which works by reference:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: If the collection is a map, then iterators will return a key and value tuple
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Another way to iterate is using the `for_each()` function on the iterator itself:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Break and Continue
  id: totrans-719
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust also has `break` and `continue` keywords and they operate in a similar
    fashion - they operate on the innermost loop. A `continue` will start on the next
    iteration while a `break` will terminate the loop.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Labels
  id: totrans-722
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `break` and `continue` work by default on the current loop. There will
    be occasions where you intend to break out of an enclosing loop instead. For those
    occasions you can label your loops and pass that label into the `break` or `continue:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Infinite Loop
  id: totrans-725
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rust has an explicit infinite `loop` that runs indefinitely:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Rust recommends using this form when an infinite loop is required to assist
    with code generation. Note that an infinite loop can still be broken out of using
    a `break` statement.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: While Loop
  id: totrans-729
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `while` loop in Rust looks pretty similar to one written in C/C++. The main
    difference is that parentheses are not necessary around the conditional test.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Rust has no equivalent to the do-while loop form. It can be simulated but it
    looks a bit inelegant:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: While let loop
  id: totrans-734
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as there is an `if let` which tests and assigns a value that matches a
    pattern, there is also a `while let` equivalent:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: This loop will break when the iterator returns `None`.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  id: totrans-738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions
  id: totrans-739
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++ the standard form of a function is this:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Usually you would declare the function, either as a forward reference in a source
    file, or in a header. Then you would implement the function in a source file.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: If a function does not return something, the return type is `void`. If the function
    does return something, then there should be return statements for each exiting
    branch within the function.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: 'You can forego the function declaration in two situations:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: If the function is inline, i.e. prefixed with the `inline` keyword. In which
    case the function in its entireity is declared and implemented in one place.
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the function is not inline but is declared before the code that calls it
    in the same source file. So if function `foo` above was only used by one source
    file, then just putting the implementation into the source would also act as the
    declaration
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Rust the equivalent to `foo` above is this:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The implementation *is* the declaration there is no separation between the two.
    Functions that return nothing omit the `->` return section. The function can also
    be declared before or after whatever calls it. By default the function is private
    to the model (and submodules) that implement it but making it `pub fn` exposes
    it to other modules.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: Like C++, the function must evaluate to something for each exiting branch but
    this is mandatory.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note, that the `return` keyword is not usually unecessary. Here is a function
    that adds two values together and returns them with no return:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Why is there no `return`? As we saw in the section on Expressions, a block evaluates
    to a value if we omit the semi-colon from the end so `x + y` is the result of
    evaluating the function block and becomes what we return.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: 'There are occasions were you explicitly need the return keyword. Typically
    you do that if you want to exit the function before you get to the end of the
    function block:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Variable arguments
  id: totrans-756
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ functions can take a variable number of arguments with the ... ellipsis
    pattern. This is used in functions such as print, scanf etc.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Rust does not support variadic functions (the fancy name for this ability).
    However you could pass additional arguments in an array slice if the values are
    the same, or as a dictionary or a number of other ways.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: TODO Rust example of array slice
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to write your code as a macro. Macros can take any number
    of expressions so you are able to write code that takes variable arguments. This
    is how macros such println!, format! and vec! work.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: Default arguments
  id: totrans-762
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ arguments can have default values.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: A function defines what its name is, what types it takes and what value (if
    any) it returns.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: Function overloading
  id: totrans-766
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ functions can be overloaded, e.g.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Rust does not support overloading. As an alternative, each variation of the
    function would have to be named uniquely.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: C++11 alternative syntax
  id: totrans-770
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++11 introduces a new syntax which is slightly closer to Rust's in style.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: This form was created to allow C++ function declarations to more closely to
    resemble lambda functions in some scenarios and to help with decltype return values.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  id: totrans-774
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism
  id: totrans-775
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++
  id: totrans-776
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C++ has 4 types of polymorphism:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: Function name overloading - multiple definitions of the same function taking
    different arguments.
  id: totrans-778
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Coercion - implicit type conversion, e.g. assigning a double to an int or a
    bool.
  id: totrans-779
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parametric - compile type substitution of parameters in templates
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inclusion - subtyping a class with virtual methods overloads their functionality.
    Your code can use the pointer to a base class, yet when you call the method you
    are calling the function implemented by the subtype.
  id: totrans-781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That is to say, the same named function can be overloaded with different parameters.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: Function name overloading
  id: totrans-783
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: One of the biggest issues that you might begin to see from the above example
    is that is too easy to inadvertantly call the wrong function because C++ will
    also implicitly convert types. On top of that C++ also has default parameter values
    *and* default constructors. So you might call a function using one signature and
    be calling something entirely different after the compiler resolves it.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: This example will call the integer overload because `NULL` evaluates to 0\.
    One of the changes to `C++11` was to introduce an explicit `nullptr` value and
    type to avoid this issues.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: Rust
  id: totrans-788
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust has limited support for polymorphism.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: Function name overloading - there is none. See section below for alternatives.
  id: totrans-790
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Coercion. Rust allows limited, explict coercion between numeric types using
    the `as` keyword. Otherwise see below for use on `Into` and `From` traits.
  id: totrans-791
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parameteric - similar to C++ via generics
  id: totrans-792
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inclusion - there is no inheritance in Rust. The nearest thing to a virtual
    method in rust is a trait with an implemented function that an implementation
    overrides with its own. However this override is at compile time.
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatives to function name overloading
  id: totrans-794
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a few functions you can just disambiguate them, e.g.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Use traits
  id: totrans-797
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A common way to do polymorphism is with *traits*.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two standard traits for this purpose:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: The `From<>` trait converts from some type into the our type.
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Into<>` trait converts some type (consuming it in the process) into our
    type
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You only need to implement `From` or `Into` because one implies the other.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: 'The `From` trait is easier to implement:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'But let''s say we want an explicit `new` constructor function on type `Foo`.
    In that case, we could write it using the `Into` trait:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Since `From` implies `Into` we can just call the constructor like so:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: If you prefer you could implement `Into` but it's more tricky since it consumes
    the input, which might not be what you want.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Use enums
  id: totrans-811
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Remember that an enumeration in Rust can contain actual data, so we could also
    implement a function that takes an enumeration as an argument that has values
    for each kind of value it accepts:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Error Handling
  id: totrans-814
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error Handling
  id: totrans-815
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ allows code to throw and catch exceptions. As the name suggests, exceptions
    indicate an exceptional error. An exception is thrown to interrupt the current
    flow of logic and allows something further up the stack which to catch the exception
    and recover the situation. If nothing catches the throw then the thread itself
    will exit.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Most coding guidelines would say to use exceptions sparingly for truly exceptional
    situations, and use return codes and other forms of error propagation for ordinary
    failures. However C++ has no simple way to confer error information for ordinary
    failures and exceptions can be complicated to follow and can cause their own issues.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: Rust does not support exceptions. Rust programs are expected to use a type such
    as `Option` or `Result` to propagate errors to their caller. In other words, the
    code is expected to anticipate errors and have code to deal with them.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Option` enum either returns `None` or `Some` where the `Some` is a payload
    of data. It''s a generic enum that specifies the type of what it may contain:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: For example, we might have a function that searches a database for a person's
    details, and it either finds them or it doesn't.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: The `Result` enum either returns a value of some type or an error of some type.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: So we might have a function `set_thermostat` for setting the room temperature.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: This function will return a unity `()` value for success, or a `String` for
    failure.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: The ? directive
  id: totrans-829
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say you have 2 functions `delete_user` and `find_user`. The function `delete_user`
    first calls `find_user` to see if the user even exists and then proceeds to delete
    the user or return the error code that it got from `find_user`.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'We have a lot of code in `delete_user` to handle success or failure in `find_user`
    and throw its failure code upwards. So Rust provides a convenience `?` mark on
    the end of the call to a function that instructs the compiler to generate the
    if/else branch we hand wrote above, reducing the function to this:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Providing you want to propogate errors up the call stack, this can eliminate
    a lot of messy conditional testing in the code and make it more robust.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: Older versions of Rust used a special `try!()` macro for this same purpose (not
    to be confused with `try-catch` in C++) which does the same thing. So if you see
    code like this, it would be the same as above.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Nuclear option - panic!()
  id: totrans-837
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If code really wants to do something equivalent to a throw / catch in C++ it
    may call panic!().
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: This is NOT recommended for dealing with regular errors, only irregular ones
    that the code has no way of dealing with.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: This macro will cause the thread to abort and if the thread is the main programme
    thread, the entire process will exit.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: A panic!() can be caught and should be if Rust is being invoked from another
    language. The way to catch an unwinding panic is a closure at the topmost point
    in the code where it can be handled.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Lambda Expressions / Closures
  id: totrans-843
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda Expressions / Closures
  id: totrans-844
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambdas in C++11
  id: totrans-845
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A [lambda expression](https://msdn.microsoft.com/en-us/library/dd293608.aspx),
    or lambda is an anonymous function that can be declared and passed around from
    within the scope of the call itself.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: This can be particularly useful when you want to sort, filter, search or otherwise
    do some trivial small action without the bother of declaring and maintaining a
    separate function.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++ a lambda looks like this:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: This lambda is passed to a std::sort function to sort an array of values by
    some criteria.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: A C++ lambda can (but doesn't have to) capture variables from the enclosing
    scope if it wishes and it can specify capture clauses in the `[]` section that
    define how capture is made. Captures can be by value or reference, and can explicitly
    list the variables to capture, or specify to capture everything by reference or
    assignment. A lambda that captures variables effectively becomes a closure.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'We can see from the output that `multiply()` has captured copies of the values
    in `v1` and `v2`, whereas `sum()` captures by reference and so it is sensitive
    to changes in the variables:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: A capture can also specify a default capture mode by specifying `=` in the capture
    clause or by reference `&` and then specify capture behaviour for specific variables.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: 'So our captures above could be simplified to:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Note that C++ lambdas can exhibit dangerous behaviour - if a lambda captures
    references to variables that go out of scope, the lambda's behaviour is undefined.
    In practice that could mean the application crashes.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: Closures in Rust
  id: totrans-859
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust implements closures. A closure is like a lambda except it automatically
    captures anything it references from the enclosing environment. i.e. by default
    it can access any variable that is in the enclosing scope.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: Here is the same sort snippet we saw in C++ expressed as Rust. This closure
    doesn't borrow anything from its enclosing scope but it does take a pair of arguments
    to compare two values for sorting. The `sort_by()` function repeatedly invokes
    the closure to sort the array.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'A closure that uses a variable from the enclosing scope borrows it by default.
    That means the borrowed variable can''t change while the closure is in scope.
    To change the value we must ensure the closure goes out of scope to free the borrow,
    e.g. with a block:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Alternatively you can `move` variables used by the closure so it owns them and
    they become inaccessible from the outerscope. Since our closure was accessing
    an integer, the move becomes an implicit copy. So our `square` closure has its
    own `x` assigned the value `100`. Even if we change `x` in the outer scope to
    `200`, the closure has its own independent copy.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'This is the equivalent to the C++ code above that used lambda expressions to
    bind to copies and references:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: This will yield the same results as the C++ code. The main difference here is
    that rather than binding our closure to a reference, we passed the reference values
    in as parameters to the closure.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: Templates / Generics
  id: totrans-870
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates / Generics
  id: totrans-871
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ offers templates as a way to write generic code using an abstract type and
    then specialize it by substituting one or more types into a concrete class.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'This template uses the type of the parameter (int this case 10) to create an
    inline function that prints out the value of that type:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Classes can also be made from templates:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: This class implements a simple stack using a template to indicate the type of
    object it contains.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: This is a very powerful mechanism and the C++ library makes extensive use of
    it.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: Where templates can become a bit of a mess is that the templates are inline
    and the compiler will expand out anything you call before attempting to compile
    it.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: An innocuous error such as using a type that has no default copy constructor
    in a collection can cause the compiler to go nuts and output a wall of indecipherable
    errors.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: Generic Functions
  id: totrans-882
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust's equivalent to a template is called a generic. A generic generalizes a
    function or a trait so it works with different types that match the criteria.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: So the Rust equivalent of the `debug()` function in C++ would be this.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Here we describe a function that takes a generic type `T` where the constraint
    is that `T` must implement the trait `std::fmt::Display`. Any struct that implements
    this trait can passed into the call. Since integer types implement the trait,
    we can just call it directly as `debug(10)` and the compiler is happy.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: Generic structs
  id: totrans-887
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly we can use generics on a struct. So the equivalent in Rust of the
    C++ template class `Stack` is this:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Where clause
  id: totrans-890
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `where` clause can be added to impose constraints on what generic type must
    do to be allowed to be supplied to the generic function or struct.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: For example we might have a function that takes a closure as an argument. A
    closure is a function and so we want to define the shape that the closure will
    take.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: 'So:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Here we have defined a `compare()` function that takes a couple of values of
    the same type. The `where` clause states that the function must take two values
    of the same type and return a boolean. The compiler will ensure any closure we
    pass in matches that criteria, as indeed our `comparer` closure does.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  id: totrans-896
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attributes
  id: totrans-897
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ has various ways to give compiler *directives* during compilation:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: Compile flags that control numerous behaviours
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#pragma` statements - `once`, `optimize`, `comment`, `pack` etc. Some pragmas
    such as `comment` have been wildly abused in some compilers to insert "comments"
    into object files that control the import / export of symbols, static linking
    and other functionality.'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#define` with ubquitous `#ifdef` / `#else` / `#endif` blocks'
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keywords `inline`, `const`, `volatile` etc.. These hint the code and allow the
    compiler to make decisions that might change its output or optimization. Compilers
    often have their own proprietary extensions.
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust uses a notation called *attributes* that serves a similar role to all of
    these things but in a more consistent form.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: 'An attribute `#[foo]` applies to the next item it is declared before. A common
    attribute is used to denote a unit test case with `#[test]`:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Attributes can also be expressed as `#![foo]` which affects the thing they're
    contained *by* rather the thing that follows them.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Attributes are enclosed in a `#[ ]` block and provide compiler directives that
    allow:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: Functions to be marked as unit or benchmark tests
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions to be marked for conditional compilation for a target OS. A function
    can be defined that only compiles for one target. e.g. perhaps the code that communicates
    with another process on Windows and Linux is encapsulated in the same function
    but implemented differently.
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable / disable lint rules
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable / disable compiler features. Certain features of rust may be experimental
    or deprecated and may have to be enabled to be accessed.
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the entry point function from `main` to something else
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional compilation according to target architecture, OS, family, endianess,
    pointer width
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline hinting
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deriving certain traits
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling compiler features such as plugins that implement procedural macros.
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing macros from other crates
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used by certain crates like serde and rocket to instrument code - NB Rocket
    uses unstable compiler hooks for this and in so doing limits itself to working
    in nightly builds only.
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional compilation
  id: totrans-920
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conditional compilation allows you to test the target configurations and optionally
    compile functions or modules in or not.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: 'The main configurations you will test include:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: Target architecture - "x86", "x86_64", mips", "arm" etc.
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target OS - "windows", "macos", "ios", "linux", "android", "freebsd" etc.
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target family - "unix" or "windows"
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target environment - "gnu", "msvc" etc
  id: totrans-926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target endianess
  id: totrans-927
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target pointer width
  id: totrans-928
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So if you have a function which is implemented one way for Windows and another
    for Linux you might code it like so:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Many more possibilities are listed in the [documentation](https://doc.rust-lang.org/reference/attributes.html#crate-only-attributes).
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: Linking to native libraries
  id: totrans-932
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C/C++ code is first compiled and then it is linked, either by additional
    arguments to the compiler, or by invoking a linker.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: In Rust most of your linking is taken care for you providing you use `cargo`.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: All your sources are compiled and linked together.
  id: totrans-935
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: External crates are automatically built as static libs and linked in.
  id: totrans-936
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But if you have to link against something external through FFI you have to write
    a `#link` directive in your `lib.rs` or `main.rs`. This is somewhat analogous
    to the `#pragma(comment, "somelib")` in C++.
  id: totrans-937
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| C++ | Rust |'
  id: totrans-938
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-939
  prefs: []
  type: TYPE_TB
- en: '| `#pragma (comment, "somelib")` | `#[link(name = "somelib")]` |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
- en: '| - | `#[link(name = "somelib", kind = "static")]` |'
  id: totrans-941
  prefs: []
  type: TYPE_TB
- en: The default kind for `#link` is `dynamic` library but `static` can be explicitly
    stated specified.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: Inlining code
  id: totrans-943
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inlining happens where your function logic is inserted in-place to the code
    that invokes it. It tends to happen when the function does something trivial such
    as return a value or execute a simple conditional. The overhead of duplicating
    the code is outweighed by the performance benefit.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: Inlining is achieved in C++ by declaring and implementing a function, class
    method or template method in a header or marking it with the inline keyword.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, inlining is only a hint. Rust recommends not forcing inlning, rather
    leaving it as a hint for the LLVM compiler to do with as it sees fit.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: '| C++ | Rust |'
  id: totrans-947
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-948
  prefs: []
  type: TYPE_TB
- en: '| Explicitly with `inline` or implicitly through methods implemented in class
    / struct | `#[inline]`, `#[inline(always)]`, `#[inline(never)]` |'
  id: totrans-949
  prefs: []
  type: TYPE_TB
- en: Another alternative to explicitly inlining code is to use the link-time optimisation
    in LLVM.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: Multi-threading
  id: totrans-952
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multithreading
  id: totrans-953
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multithreading allows you to run parts of your programming concurrently, performing
    tasks in parallel. Every program has a *main* thread - i.e. the one your `main()`
    started from, in addition to which are any that you create.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of reasons to use threads:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: Long running operations, e.g. zipping up a large file.
  id: totrans-956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activity that is blocking in nature, e.g. listening for connections on a socket
  id: totrans-957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing data in parallel, e.g. physics, collision detection etc.
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous activities, e.g. timers, polling operations.
  id: totrans-959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, if you use a graphical toolkit, or 3rd party libraries they may
    spawn their own threads that you do not know about.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  id: totrans-961
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One word you will hear a lot in multithreading is thread safety.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: 'By that we mean:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: Threads should not be able to modify the data at the same time. When this happens
    it is called a data race and can corrupt the data, causing a crash. e.g. two threads
    trying to append to a string at the same time.
  id: totrans-964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads must not lock resources in a way that could cause deadlock i.e. thread
    1 obtains a lock on resource B and blocks on resource A, while thread 2 obtains
    a lock on resource A and blocks on resource B. Both threads are locked forever
    waiting for a resource to release that never will be.
  id: totrans-965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Race conditions are bad, i.e. the order of thread execution produces unpredictable
    results on the output from the same input.
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs that can be called by multiple threads must either protect their data structures
    or make it an explicit problem of the client to sort out.
  id: totrans-967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open files and other resources that are accessed by multiple threads must be
    managed safely.
  id: totrans-968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting shared data
  id: totrans-969
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data should never be read at the same time it is written to in another thread.
    Nor should data be written to at the same time by two threads.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: 'The common way to prevent this is either:'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: Use a mutex to guard access to the data. A mutex is a special class that only
    one thread can lock at a time. Other threads that try to lock the mutex will wait
    until the lock held by another thread is relinquished
  id: totrans-972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a read-write lock. Similar to a mutex, it allows one thread to lock the
    thread for writing data, however it permits multiple threads to have read access,
    providing nothing is already writing to it. For data that is read more frequently
    than it is modified, this is a lot more efficient than just a mutex.
  id: totrans-973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding deadlock
  id: totrans-974
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best way to avoid deadlock is only ever obtain a lock to one thing ever
    and release it as soon as you are done. But if you have to lock more than one
    thing, ensure the locking order is consistent between all your threads. So if
    thread 1 locks A and B, then ensure that thread 2 also locks A and B in that order
    and not B then A. The latter is surely going to cause a deadlock.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: C / C++
  id: totrans-976
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C and C++ predate threading to some extent so until C++11 the languages have
    had little built-in support for multi-threading and what there was tended to be
    compiler specific extensions.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: A consequence of this is that C and C++ have ZERO ENFORCEMENT of thread safety.
    If you data race - too bad. If you forget to write a lock in one function even
    if you remembered all the others - too bad. You have to discipline yourself to
    think concurrently and apply the proper protections where it is required.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: The consequence of not doing so may not even be felt until your software is
    in production and that one customer starts complaining that their server freezes
    about once a week. Good luck finding that bug!
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading APIs
  id: totrans-980
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most common APIs would be:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: '`<thread>`, `<mutex>` - from C++11 onwards'
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POSIX threads, or pthreads. Exposed by POSIX systems such as Linux and most
    other Unix derivatives, e.g. OS X. There is also pthread-win32 support built over
    the top of Win32 threads.
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Win32 threads. Exposed by the Windows operating system.
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenMP. Supported by many C++ compilers.
  id: totrans-985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3rd party libraries like Boost and Qt provide wrappers that abstract the differences
    between thread APIs.
  id: totrans-986
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All APIs will have in common:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: Thread creation, destruction, joins (waiting on threads) and detaches (freeing
    the thread to do what it likes).
  id: totrans-988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronization between threads using locks and barriers.
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutexes - mutual exclusion locks that protect shared data.
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional variables - a means to signal and notify of conditions becoming
    true.
  id: totrans-991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::thread
  id: totrans-992
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `std::thread` represents a single thread of execution and provides an abstraction
    over platform dependent ways of threading.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: The example spawns a thread which invokes the function and passes the parameter
    into it, printing a message 100 times.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: std::mutex
  id: totrans-996
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ provides a family of various `mutex` types to protect access to shared data.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: The mutex is obtained by a `lock_guard` and other attempts to obtain the mutex
    are blocked until the lock is relinquished.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: POSIX threads
  id: totrans-1000
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The pthreads API is prefixed `pthread_` and works like so:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: This example spawns a thread which invokes DoWork with the payload of 100 which
    causes the function to print a message 100 times.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: Win32 Threads
  id: totrans-1004
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Win32 threading has functions analogous to those in POSIX. They have names such
    as `CreateThread`, `ExitThread`, `SetThreadPriority` etc.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP API
  id: totrans-1006
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open Multi-Processing (OpenMP) is an API for multi-threaded parallel processing.
    OpenMP relies on compiler support because you use special `#pragma` directives
    in your source to control thread creation and access to data.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: GCC, Clang and Visual C++ have support for OpenMP so it is an option.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP is a complex standard but the use of directives can make for cleaner
    code than invoking threading APIs directly. The downside is it is also more opaque
    hiding what the software is doing, making it considerably more difficult to debug.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP is described in detail at the OpenMP [website](http://www.openmp.org/).
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: Thread local storage
  id: totrans-1011
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thread local storage, or TLS is static or global data which is private to every
    thread. Each thread holds its own copy of this data so it can modify it without
    fear of causing a data race.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: 'Compilers also have proprietary ways to decorate types as thread local:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: C++11 has gained a `thread_local` directive to decorate variables which should
    use TLS.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Rust
  id: totrans-1017
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw with C++ that you had to be disciplined to remember to protect data from
    race conditions.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: Rust doesn't give you that luxury -
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: Any data that you share must be protected in a thread safe fashion
  id: totrans-1020
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any data that you pass between threads must be marked thread safe
  id: totrans-1021
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spawning a thread
  id: totrans-1022
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spawning a thread is easy enough by calling `spawn`, supplying the closure you
    want to run in the context of your new thread.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Alternatively you can supply a function to `spawn` which is called in the same
    manner.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: If you supply a closure then it must have a lifetime of `'static` because threads
    can outlive the thing that created them. i.e. they are detached by default.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: A closure can make use of move values that are marked `Send` so the compiler
    allows ownership to transfer between threads.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: Likewise function / closure may also return a value which is marked `Send` so
    the compiler can transfer ownership between the terminating thread and the thread
    which calls `join` to obtain the value.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: So the thread above is detached. If we wanted to wait for the thread to complete,
    the `spawn` returns a `JoinHandle` that we can call `join` to wait for termination.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: If the closure or function returns a value, we can use `join` to obtain it.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Data race protection in the compiler
  id: totrans-1034
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data races are bad news, but fortunately in Rust the compiler has your back.
    You MUST protect your shared data or it won't compile.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to protect your data is to wrap the data in a mutex and provide
    each thread instance with a reference counted copy of the mutex.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Here is a full example that spawns 10 threads that each increment the counter.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'So the basic strategy will be this:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: Every thread will get it's own atomic reference to the mutex.
  id: totrans-1041
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each thread that wishes to access the shared must obtain a lock on the mutex.
  id: totrans-1042
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the lock is released, the next waiting thread can obtain access.
  id: totrans-1043
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The compiler will enforce this and generate errors if ANYTHING is wrong.
  id: totrans-1044
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read Write Lock
  id: totrans-1045
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A read write lock works much like a mutex - we wrap the shared data in a `RwLock`,
    and then in an `Arc`.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Each thread will then either need to obtain a read lock or a write lock on the
    shared data.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: The advantage of a `RwLock` is that many threads can concurrently read the data,
    providing nothing is writing to it. This may be more efficient in many cases.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: Sending data between threads using channels
  id: totrans-1051
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO mpsc channel
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: Thread local storage
  id: totrans-1053
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with C++ you may have reason to use thread local storage
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Useful crates
  id: totrans-1056
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rayon
  id: totrans-1057
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The [rayon](https://github.com/rayon-rs/rayon) crate implements parallel iterators
    that allow your collections to be iterated in parallel. The crate utilises work
    stealing and divide and conquer algorithms couple to a thread pool to process
    collections more quickly than they could be in a sequential fashion.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking this is a drop-in replacement with the exception that you
    call `par_iter` instead of `iter`. The crate implements a `ParallelIterator` trait
    on collection classes.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: See the crate site for more information.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: Lint
  id: totrans-1062
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lint
  id: totrans-1063
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C/C++ compilers can issue many useful warnings but the amount of static analysis
    they can do is usually quite limited.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: The Rust compiler performs a far more rigorous lifecycle check on data and then
    follows up with a lint check that inspects your code for potentially bad or erroneous
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular it looks for:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: Dead / unused code
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unreachable code
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecated methods
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undocumented functions
  id: totrans-1070
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camel case / snake case violations
  id: totrans-1071
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unbounded recursion code (i.e. no conditionals to stop recursion)
  id: totrans-1072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of heap memory when stack could be used
  id: totrans-1073
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unused extern crates, imports, variables, attributes, mut, parentheses
  id: totrans-1074
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using "while true {}" instead of "loop {}"
  id: totrans-1075
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lint rules can be enforced more strictly or ignored by using attributes:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'A full list of lint rules can be found by typing "rustc -W help":'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: There are a lot checks than are listed here.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: Macros
  id: totrans-1081
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Macros
  id: totrans-1082
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C / C++ Preprocessor
  id: totrans-1083
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C languages are little unusual in that they are compiled in two phases. The
    first phase is called the preprocess. In this phase, the preprocessor looks for
    directives starting with a # symbol and runs string substitution and conditional
    inclusion / exclusion based on those directives. Only after the file has been
    preprocessed does the compiler attempt to compile it.'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: 'Preprocessor directives start with a `#` symbol. For example the `#define`
    directive creates a macro with an optional value:'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: We'll explore macros more in a moment. Another directive is the `#if\#else\#endif`
    or `#ifdef\#else\#endif` which can be used to include code from one branch or
    the other of a test according to what matches.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Another directive is `#include`. In C and C++, public functions and structures
    are typically defined and implemented in separate files. The `#include` directive
    allows a header to be pulled in to the front of any file that makes use of those
    definitions.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-1090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: The important thing to remember in all of this is ALL of these things happen
    before the compiler even starts! Your `main.c` might only be 10 lines of code
    but if you `#include` some headers the preprocessor may be feeding many thousands
    of lines of types, functions into the compiler, all of which are evaluated before
    they get to your code.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: C / C++ Macros
  id: totrans-1092
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Macros are string substitution patterns performed by the preprocessor before
    the source is compiled. As such they can be very prone to error and so have been
    deprecated in favour of constants and inline functions.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple macro that would behave in an unexpected manner:'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: The macro is very simple - multiply x by y. But it fails if either argument
    is an expression. Judicious use of parentheses might avoid the error in this case,
    but we could break it again using some pre or post increments.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: Macros in C++ are also unhygenic, i.e. the macro can inadvertently conflict
    with or capture values from outside of itself causing errors in the code.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: Here our SWAP macro uses a temporary value called `tmp` that already existed
    in the scope and so the compiler complains. A macro might avoid this by using
    shadow variables enclosed within a `do / while(0)` block to avoid conflicts but
    it is less than ideal.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'Consequently inline functions are used wherever possible. Even so macros are
    still frequently used in these roles:'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: To conditionally include for a command-line flag or directive, e.g. the compiler
    might `#define WIN32` so code can conditionally compile one way or another according
    to its presence.
  id: totrans-1102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For adding guard blocks around headers to prevent them being #include''d more
    than once. Most compilers implement a "#pragma once directive" which is an increasingly
    common alternative'
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For generating snippets of boiler plate code (e.g. namespace wrappers), or
    things that might be compiled away depending on #defines like DEBUG being set
    or not.'
  id: totrans-1104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For making strings of values and other esoteric edge cases
  id: totrans-1105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Writing a macro is easy, perhaps too easy:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: This macro would expand to printf before compilation but it would fail to compile
    or print the wrong thing if x were not an integer.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: Rust macros
  id: totrans-1109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Macros in Rust are quite a complex topic but they are more powerful and safer
    than the ones in C++.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: Rust macros are hygenic. That is to say if a macro contains variables, their
    names do not conflict with, hide, or otherwise interfere with named variables
    from the scope they're used from.
  id: totrans-1111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The pattern supplied in between the brackets of the macro are tokenized and
    designated as parts of the Rust language. identifiers, expressions etc. In C /
    C++ you can #define a macro to be anything you like whether it is garbage or syntactically
    correct. Furthermore you can call it from anywhere you like because it is preprocessed
    even before the compiler sees the code.'
  id: totrans-1112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust macros are either declarative and rule based with each rule having a left
    hand side pattern "matcher" and a right hand side "substitution". Or they're procedural
    and actualy rust code turns an input into an output (see section below).
  id: totrans-1113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros must produce syntactically correct code.
  id: totrans-1114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Declarative macros can be exported by crates and used in other code providing
    the other code elects to enable macro support from the crate. This is a little
    messy since it must be signalled with a #[macro_export] directive.'
  id: totrans-1115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all that said, macros in Rust *are* complex - perhaps too complex - and
    generally speaking should be used as sparingly as possible.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: Here is a simple declarative macro demonstrating repetition called hello_x!().
    It will take a comma separated list of expressions and say hello to each one of
    them.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Essentially the matcher matches against our comma separate list and the substitution
    generates one println!() with the message for each expression.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: What if we threw some other expressions into that array?
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'Well that works too:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'What about some illegal code:'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: We get a meaningful error originating from the macro.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Real world example - vec!()
  id: totrans-1129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust comes with a lot of macros for reducing some of the leg work of tedious
    boiler plate. For example the vec!() macro is a way to declare a std::Vec and
    prepopulate it with some values.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the actual vec! macro source code taken from the Rust source:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'It looks complex but we will break it down to see what it does. Firstly it
    has a match-like syntax with three branches that expand to anything that matches
    the left hand side:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: First branch
  id: totrans-1134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first matcher matches a pattern such as `1; 100`. The value `1` goes into
    `$elem`, the value `100` goes into `$n`:'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: The `$crate` is a special value that resolves to the module crate which happens
    to be std.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: 'So this expands to this:'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Second branch
  id: totrans-1140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second matcher contains a glob expression - zero or more expressions separated
    by comma (the last comma is optional). Each matching expression ends up in `$x`:'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'So we can write:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-1144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'The box keyword tells Rust to allocate the supplied array on the heap and moves
    the ownership by calling a helper function called into*vec() that wraps the memory
    array with a Vec instance. The <[\*]>:: at the front is a turbo-fish notation
    to make the into_vec() generic function happy.'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: Third branch
  id: totrans-1146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third branch is a little odd and almost looks the same as the second branch.
    But take at look the comma. In the last branch it was next to the asterisk, this
    time it is inside the inner $().
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-1148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'The matcher matches when the the comma is there and if so recursively calls
    vec!() again to resolve to the second branch matcher:'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: Basically it is there so that there can be a trailing comma in our declaration
    and it will still generate the same code.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Procedural Macros
  id: totrans-1152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we've talked about declarative macros that expand out to be Rust code
    based upon how they pattern match the rules defined by the macro.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: A second kind of macro is the *procedural macro*. A procedural macro is a plugin
    written in Rust that is compiled and loaded by the compiler to produce arbitrary
    Rust code as its output.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: 'A procedural macro can therefore be thought of as a code generator but one
    that forms part of the actual compiler. Procedural macros can be particularly
    useful for:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: Serialization / deserialization (e.g. the [serde](https://github.com/serde-rs/serde)
    module generates code for reading and writing structs to a variety of formats
    - JSON, YAML, TOML, XML etc.)
  id: totrans-1156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain Specific Languages (e.g. embedded SQL, regular expressions etc).
  id: totrans-1157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aspect oriented programming (e.g. extra debugging, performance metrics etc)
  id: totrans-1158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New lint and derive rules
  id: totrans-1159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information look at this section on [compiler plugins](https://doc.rust-lang.org/book/compiler-plugins.html)
    in the Rust book.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: Other forms of conditional compilation
  id: totrans-1161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw that the C / C++ preprocessor can be used for conditional compilation.
    The equivalent in Rust is attributes. See the attributes section to see how they
    may be used.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: Memory Allocation
  id: totrans-1163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory allocation
  id: totrans-1164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is concerned with memory allocation, i.e. creating objects that
    reside on the heap and not on the stack, and the manner in which they are created
    and are destroyed.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: C++
  id: totrans-1166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C and C++ have various standard ways to allocate memory:'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: '`malloc`/`calloc`/`realloc()` and `free()` functions'
  id: totrans-1168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`new` and `delete` (C++ only)'
  id: totrans-1169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`new[]` and `delete[]` for arrays (C++ only)'
  id: totrans-1170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoking `malloc()`/`free()` on a C++ class or struct is never a good idea since
    it will not call the corresponding class constructor or destructor. The `realloc()`
    function allocates a new piece of memory, copying the contents of an existing
    piece of memory before freeing the original.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'In each case the allocation must be matched by the corresponding free action
    so immediately we can see scope for error here:'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: Ownership rules can get messy, especially when a class is passed around a lot
    - who deletes the object and when?
  id: totrans-1174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Not using the correct `new` & `delete` pair, causing a memory leak. e.g. calling
    `delete` instead of `delete[]`
  id: totrans-1175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Forgetting to free memory at all causing a memory leak.
  id: totrans-1176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Freeing memory more than once.
  id: totrans-1177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling a dangling pointer, i.e. a pointer which refers to freed memory.
  id: totrans-1178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocating / freeing in a way that causes heap fragmentation. Reallocation can
    cause fragmentation to happen a lot faster.
  id: totrans-1179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'C++ has smart pointers which manage the lifetime on objects and are a good
    way to programmer error:'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-1181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: Unfortunately it is not always possible to use smart pointers but wherever possible
    they should be used.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: Other ways of allocating memory
  id: totrans-1183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Virtually every C and C++ library has solutions for managing memory. They all
    their own indivual concept of ownership which is usually different from one to
    the next. Boost and Qt have their own memory management "smart" pointers. Qt even
    requires certain objects to be deleted "later" by a message processing loop on
    the thread that created the object. Some libraries even adopt a COM-like model
    of reference counting objects with smart pointers. Most C libraries will expose
    an alloc and free function for creating and destroying context objects that callers
    pass to the API.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: Memory allocation can even be overwritten and replaced in some circumstances.
    In C, the standard malloc / free can be substituted for another memory allocator,
    e.g. TCMalloc [TCMalloc](http://goog-perftools.sourceforge.net/doc/tcmalloc.html).
    Or perhaps the code wants to use garbage collected memory in which case [Bohem
    GC](http://www.hboehm.info/gc/) is a popular library for that purpose. Boehm can
    also be used for leak detection since it can find objects which were never released.
    C++ can also [override](http://en.cppreference.com/w/cpp/memory/new/operator_new)
    the global or class specific new / delete operators. Some standard C++ template
    classes also allow memory allocation to be overridden.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: Rust
  id: totrans-1186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can guess by now Rust tends to be a lot more strict about allocation
    that C/C++. Lifetimes of objects are tracked and enforced by the compiler and
    that includes memory allocated objects.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: In normal safe programming there is no explicit new / delete so there is no
    way to forget to free an object. There are no pointers either so code cannot call
    a dangling pointer or inadvertently call a null pointer.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: A `Box` is a managed pointer that holds a heap allocated object. A box cannot
    be cloned, so there is only one owner at any time.
  id: totrans-1189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Cell` is a mutable memory location - it can hold any kind of copyable type
    and the value within it can be changed.
  id: totrans-1190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `RefCell` is a mutable memory location that can hold a reference
  id: totrans-1191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The advantage for programmers, is that once you define the lifetime of an object
    properly it just comes into existence and goes away correctly. In many cases this
    lifetime management comes with zero runtime cost, or if there is a cost it is
    no more than the same code correctly written in C/C++.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: Rust requires most heap allocated memory to be contained by one or more of the
    structs below. The struct manages the lifetime and access to the object inside
    ensuring the lifetime is managed correctly.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: Box
  id: totrans-1194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Box` is memory managed on the heap.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Whoever owns the box can access it. Essentially, that means you can pass the
    box around from one place to another and whatever binds to it last can open it.
    Everyone else’s binding becomes invalid and will generate a compile error.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: A box can be useful for abstraction since it can refer to a struct by a trait
    it implements allowing decoupling between types.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: TODO example of a struct holding a box with a trait implemented by another struct
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: It can be useful for situations where one piece of code creates an object on
    behalf of another piece of code and hands it over. The Box makes sure that the
    ownership is explicit at all times and when the box moves to its new owner, so
    does the lifetime of the object itself.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: Cell
  id: totrans-1201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Cell` is something that can copied with a `get()` or `set()` to overwrite
    its own copy. As the contents must be copyable they must implement the Copy trait.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: The `Cell` has a zero-cost at runtime because it doesn’t have to track borrows
    but the restriction is it only works on Copy types. Therefore it would not be
    suitable for large objects or deep-copy objects.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: RefCell
  id: totrans-1204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Somewhat more useful is the `RefCell<T>` but it incurs a runtime penalty to
    maintain read-write locks.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: The `RefCell` holds a reference to an object that can be borrowed either mutably
    or immutably. These references are read-write locked so there is a runtime cost
    to this since the borrow must check if something else has already borrowed the
    reference.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: Typically a piece of code might borrow the reference for a scope and then the
    borrow disappears when it goes out of scope. If a borrow happens before the last
    borrow releases, it will cause a panic.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: Reference Counting objects
  id: totrans-1208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust implements `Rc<>` and `Arc<>` for the purpose of reference counting objects
    that need to be shared and used by different parts of code. Rc<> is a single threaded
    reference counted wrapper, while `Arc<>` is atomic reference counted wrapper.
    You use one or the other depending on whether threads are sharing the object.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: A reference counted object is usually wrapping a `Box`, `Cell` or `Refcell`.
    So multiple structs can hold a reference to the same object.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: Rc
  id: totrans-1211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From `std::rc::Rc`. A reference counted object can be held by multiple owners
    at a time. Each own holds a cloned `Rc<T>` but the T contents are shared. The
    last reference to the object causes the contents to be destroyed.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: Arc
  id: totrans-1213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From `std::sync::Arc`. An atomic reference counted object that works like `Rc<T>`
    except it uses an atomically incremented counter which makes it thread safe. There
    is more overhead to maintain an atomic reference count. If multiple threads access
    the same object they are compelled to use `Arc<T>`
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: Foreign Function Interface
  id: totrans-1215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Foreign Function Interface
  id: totrans-1216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust doesn't work in a vaccum and was never intended as such. Instead it was
    always assumed that it would need to call other code and other code would need
    to call it,
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: Call other libraries via their entry points
  id: totrans-1218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Produce libraries in Rust that can be called by code written in another language.
    e.g. C, C++, Python, Ruby etc.
  id: totrans-1219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To that end it has the Foreign Function Interface, the means to define external
    functions, expose its own functions without name mangling and to invoke unsafe
    code that would otherwise be illegal in Rust.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: Calling out to C libraries
  id: totrans-1221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust supports the concept of a foreign function interface which is a definition
    of an external function or type that is resolved at link time.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: For example, we might wish to link to a library called foo.lib, and invoke a
    command foo_command().
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-1224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'To call this function we have to turn off safety checks first because we are
    stepping out of the bounds of Rust''s lifetime enforcement. To do this we wrap
    the call in an unsafe block to disable the safety checks:'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-1226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Note how we can use unsafe features like pointers inside of this unsafe block.
    This allows interaction with the outside world while still enforcing safety for
    the rest of our code.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: Making Rust code callable
  id: totrans-1228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The converse is also possible. We can produce a library from Rust that can be
    invoked by some other code.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine we have some code written in Python. The code works fine
    but it is not performant and the bottle neck is in just one portion of the code,
    e.g. some file operation like a checksum. We want our code to consist of a make_checksum()
    and a release_checksum().
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-1231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'Now in Python we can invoke the library simply:'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-1233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: The [FFI specification](https://doc.rust-lang.org/book/ffi.html) goes into a
    lot more detail than this and explains concepts such as callbacks, structure packing,
    stdcall, linking and other issues that allow full interoperability.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: libc
  id: totrans-1235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust maintains a crate called [libc](https://github.com/rust-lang/libc) which
    holds types and functions corresponding to C.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: 'A dependency to libc would be added to the `Cargo.toml` of your project:'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-1238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'And the file that uses the functions would contain a preamble such as this
    saying what types and functions it calls:'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-1240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: Other libraries
  id: totrans-1241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also crates that have the definitions of structures, types and functions.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: '[WinAPI](https://github.com/retep998/winapi-rs) bindings for Win32 programming
    APIs.'
  id: totrans-1243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OpenSSL](https://github.com/sfackler/rust-openssl) bindings for OpenSSL'
  id: totrans-1244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
