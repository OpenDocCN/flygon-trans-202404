- en: Features of Rust compared with C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Features of Rust compared with C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust and C++ have roughly analogous functionality although they often go about
    it in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Rust benefits from learning what works in C / C++ and what doesn't and indeed
    has cherry-picked features from a variety of languages. It also enjoys a cleaner
    API in part because things like Unicode dictate the design.
  prefs: []
  type: TYPE_NORMAL
- en: This section will cover such topics as types, strings, variables, literals,
    collections, structs, loops and so on. In each case it will draw comparison between
    how things are in C/C++ and how they are in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Also bear in mind that Rust compiles to binary code and is *designed* to use
    C binaries and be used by C binaries. Therefore the generated code is similar,
    but it is different as source.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C/C++ compilers implement a *data model* that affects what width the standard
    types are. The general rule is that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1 == sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long
    long)`'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, potentially everything all the way to `long long` could be a
    single byte, or there could be some other crazy definition. In practice however,
    data models come in four common types which will be covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: For this section, we'll cover the *most likely* analogous types between Rust
    and C/C++.
  prefs: []
  type: TYPE_NORMAL
- en: '| C/C++ | Rust | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | `i8` (or `u8`) | The signedness of a C++ char can be signed or unsigned
    - the assumption here is signed but it varies by target system. A Rust `char`
    is not the same as a C/C++ `char` since it can hold any Unicode character. ^([1](#fn_1))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `unsigned char` | `u8` |'
  prefs: []
  type: TYPE_TB
- en: '| `signed char` | `i8` |'
  prefs: []
  type: TYPE_TB
- en: '| `short int` | `i16` |'
  prefs: []
  type: TYPE_TB
- en: '| `unsigned short int` | `u16` |'
  prefs: []
  type: TYPE_TB
- en: '| `(signed) int` | `i32` or `i16` | In C/C++ this is data model dependent ^([2](#fn_2))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `unsigned int` | `u32` or `u16` | In C/C++ this is data model dependent ^([2](#fn_2))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `(signed) long int` | `i32` or `i64` | In C/C++ this is data model dependent
    ^([2](#fn_2)) |'
  prefs: []
  type: TYPE_TB
- en: '| `unsigned long int` | `u32` or `u64` | In C/C++ this is data model dependent
    ^([2](#fn_2)) |'
  prefs: []
  type: TYPE_TB
- en: '| `(signed) long long int` | `i64` |'
  prefs: []
  type: TYPE_TB
- en: '| `unsigned long long int` | `u64` |'
  prefs: []
  type: TYPE_TB
- en: '| `size_t` | `usize` | usize holds numbers as large as the address space ^([3](#fn_3))
    |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | `f32` |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `f64` |'
  prefs: []
  type: TYPE_TB
- en: '| `long double` | ~~f128~~ | f128 support was present in Rust but removed due
    to issues for some platforms in implementing it. |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| `void` | `()` | The unit type (see below) |'
  prefs: []
  type: TYPE_TB
- en: ^([1](#fn_1)) Rust's `char` type, is 4 bytes wide, enough to hold any Unicode
    character. This is equivalent to the belated `char32_t` that appears in C++11
    to rectify the abused C++98 `wchar_t` type which on operating systems such as
    Windows is only 2 bytes wide. When you iterate strings in Rust you may do so either
    by character or `u8`, i.e. a byte.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](#fn_2)) See the next section to for a discussion on data models.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](#fn_3)) Rust has a specific numeric type for indexing on arrays and collections
    called `usize`. A `usize` is designed to be able to reference as many elements
    in an array as there is addressable memory. i.e. if memory is 64-bit addressable
    then usize is 64-bits in length. There is also a signed `isize` which is less
    used but also available.
  prefs: []
  type: TYPE_NORMAL
- en: Data model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The four common data models in C++ are:'
  prefs: []
  type: TYPE_NORMAL
- en: LP32 - `int` is 16-bit, `long` and pointers are 32-bit. This is an uncommon
    model, a throw-back to DOS / Windows 3.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ILP32 - `int`, `long` and pointers are 32-bit. Used by Win32, Linux, OS X
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LLP64 - `int` and `long` are 32-bit, `long long` and pointers are 64-bit. Used
    by Win64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LP64 - `int` is 32-bit, `long` / `long long` and pointers are 64-bit. Used by
    Linux, OS X
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C/C++ types compared to Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C/C++ and Rust will share the same machine types for each corresponding language
    type and the same compiler / backend technology, i.e.:'
  prefs: []
  type: TYPE_NORMAL
- en: Signed types are two's complement
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IEE 754-2008 binary32 and binary64 floating points for float and double precision
    types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: stdint.h / cstdint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C provides a `<stdint.h>` header that provides unambigious typedefs with length
    and signedess, e.g. `uint32_t`. The equivalent in C++ is `<cstdlib>`.
  prefs: []
  type: TYPE_NORMAL
- en: If you use the types defined in this header file the types become directly analogous
    and unambiguous between C/C++ and Rust.
  prefs: []
  type: TYPE_NORMAL
- en: '| C/C++ | Rust |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `int8_t` | `i8` |'
  prefs: []
  type: TYPE_TB
- en: '| `uint8_t` | `u8` |'
  prefs: []
  type: TYPE_TB
- en: '| `int16_t` | `i16` |'
  prefs: []
  type: TYPE_TB
- en: '| `uint16_t` | `u16` |'
  prefs: []
  type: TYPE_TB
- en: '| `uint32_t` | `u32` |'
  prefs: []
  type: TYPE_TB
- en: '| `int32_t` | `i32` |'
  prefs: []
  type: TYPE_TB
- en: '| `int64_t` | `i64` |'
  prefs: []
  type: TYPE_TB
- en: '| `uint64_t` | `u64` |'
  prefs: []
  type: TYPE_TB
- en: Integer types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C/C++ has primitive types for numeric values, floating point values and booleans.
    Strings will be dealt in a separate section.
  prefs: []
  type: TYPE_NORMAL
- en: Integer types (`char`, `short`, `int`, `long`) come in `signed` and `unsigned`
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: A `char` is always 8-bits, but for historical reasons, the standards only guarantee
    the other types are "at least" a certain number of bits. So an `int` is ordinarily
    32-bits but the standard only say it should be at *least as large* as a `short`,
    so potentially it could be 16-bits!
  prefs: []
  type: TYPE_NORMAL
- en: More recent versions of C and C++ provide a [`<cstdint>`](http://www.cplusplus.com/reference/cstdint/)
    (or `<stdint.h>` for C) with typedefs that are unambiguous about their precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though `<stdint.h>` can clear up the ambiguities, code frequently sacrifices
    correctness for terseness. It is not unusual to see an `int` used as a temporary
    incremental value in a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: While `int` is unlikely to fail for most loops in a modern compiler supporting
    ILP32 or greater, it is still technically wrong. In a LP32 data model incrementing
    32767 by one would become -32768 so this loop would never terminate if `s.size()`
    was a value greater than that.
  prefs: []
  type: TYPE_NORMAL
- en: But look again at this snippet. What if the file read by `read_file()` is outside
    of our control. What if someone deliberately or accidentally feeds us a file so
    large that our loop will fail trying to iterate over it? In doing so our code
    is hopelessly broken.
  prefs: []
  type: TYPE_NORMAL
- en: 'This loop should be using the same type returned from `string::size()` which
    is an opaque unsigned integer type called `size_type`. This is usually a typedef
    for `std::size_t` but not necessarily. Thus we have a type mismatch. A `string`
    has an iterator which could be used instead but perhaps you need the index for
    some reason, but it can messy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we've swapped from one opaque type `size_type` to another called `difference_type`.
    Ugh.
  prefs: []
  type: TYPE_NORMAL
- en: C/C++ types can also be needlessly wordy such as `unsigned long long int`. Again,
    this sort of puffery encourages code to make bad assumptions, use a less wordy
    type, or bloat the code with typedefs.
  prefs: []
  type: TYPE_NORMAL
- en: Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust benefits from integer types that unambiguously denote their signedness
    and width in their name - `i16`, `u8` etc.
  prefs: []
  type: TYPE_NORMAL
- en: They are also extremely terse making it easy to declare and use them. For example
    a `u32` is an unsigned 32-bit integer. An `i64` is a signed 64-bit integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Types may be inferred or explicitly prefixed to the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Rust also has two types called `usize` and `isize` respectively. These are equivalent
    to `size_t` in that they are as large enough to hold as many elements as there
    is addressable memory. So in a 32-bit operating system they will be 32-bits in
    size, in a 64-bit operating system they will be 64-bits in size.
  prefs: []
  type: TYPE_NORMAL
- en: Rust will not implicitly coerce an integer from one size to another without
    explicit use of the `as` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Real types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C/C++ has float, double and long double precision floating point types and they
    suffer the same vagueness as integer types.
  prefs: []
  type: TYPE_NORMAL
- en: '`float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double` - "at least as much precision as a `float`"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long double` - "at least as much precision as a `double`"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most compilers and architectures however a float is a 32-bit single precision
    value, and a double is an 64-bit double precision value. The most common machine
    representation is the [IEEE 754-2008 format](https://en.wikipedia.org/wiki/IEEE_floating_point).
  prefs: []
  type: TYPE_NORMAL
- en: Long double
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The [`long double`](https://en.wikipedia.org/wiki/Long_double) has proven quite
    problematic for compilers. Despite expectations that it is a quadruple precision
    value it usually isn't. Some compilers such as gcc may offer 80-bit extended precision
    on x86 processors with a floating point unit but it is implementation defined
    behaviour.
  prefs: []
  type: TYPE_NORMAL
- en: The Microsoft Visual C++ compiler treats it with the same precision as a `double`.
    Other architectures may treat it as quadruple precision. The fundamental problem
    with `long double` is that most desktop processors do not have the ability in
    hardware to perform 128-bit floating point operations so a compiler must either
    implement it in software or not bother.
  prefs: []
  type: TYPE_NORMAL
- en: Math functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `<math.h>` C header provides math functions for working with different precision
    types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note how different calls are required according to the precision, e.g. sinf,
    sin or sinl. C99 supplies a "type-generic" set of macros in `<tgmath.h>` which
    allows sin to be used regardless of type.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++11 provides a `<cmath>` that uses specialised inline functions for the same
    purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Rust
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust implements two floating point types - `f32` and `f64`. These would be analogous
    to a 32-bit `float` and 64-bit `double` in C/C++.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Unlike in C/C++, the math functions are directly bound to the type itself providing
    you properly qualify the type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Rust does not have a 128-bit double. A `f128` did exist for a period of time
    but was removed to portability, complexity and maintenance issues. Note how `long
    double` is treated (or not) according to the compiler and target platform.
  prefs: []
  type: TYPE_NORMAL
- en: At some point Rust might get a f128 or f80 but at this time does not have such
    a type.
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `bool` (boolean) type in C/C++ can have the value `true` or `false`, however
    it can be promoted to an integer type (0 == `false`, 1 == `true`) and a bool even
    has a ++ operator for turning false to true although it has no -- operator!?
  prefs: []
  type: TYPE_NORMAL
- en: But inverting true with a ! becomes false and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Rust also has a `bool` type that can have the value `true` or `false`. Unlike
    C/C++ it is a true type with no promotion to integer type
  prefs: []
  type: TYPE_NORMAL
- en: void / Unit type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C/C++ uses `void` to specify a type of nothing or an indeterminate pointer to
    something.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The nearest thing to `void` in Rust is the Unit type. It's called a Unit type
    because it's type is `()` and it has one value of `()`.
  prefs: []
  type: TYPE_NORMAL
- en: Technically `void` is absolutely nothing and `()` is a single value of type
    `()` so they're not analogous but they serve a similar purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a block evaluates to nothing it returns `()`. We can also use it in places
    where we don''t care about one parameter. e.g. say we have a function `do_action()`
    that succeeds or fails for various reasons. We don''t need any payload with the
    Ok response so specify `()` as the payload of success:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Empty enums
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust *does* have something closer (but not the same as) `void` - empty enumerations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Essentially this enum has no values at all so anything that assigns or matches
    this nothing-ness is unreachable and the compiler can issue warnings or errors.
    If the code had used `()` the compiler might not be able to determine this.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tuple is a collection of values of the same or different type passed to a
    function or returned by one as if it were a single value.
  prefs: []
  type: TYPE_NORMAL
- en: 'C/C++ has no concept of a tuple primitive type, however C++11 can construct
    a tuple using a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Rust supports tuples as part of its language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see this is more terse and more useful. Note that the way a tuple
    is indexed is different from an array though, values are indexed via .0, .1 etc.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples can also be returned by functions and assignment operators can ignore
    tuple members we're not interested in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the calculate_coords() function returns a tuple containing
    three `i16` values. We assign the first two values to `x` and `y` respectively
    and ignore the third by passing an underscore. The underscore tells the compiler
    we're aware of the 3rd value but we just don't care about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples can be particularly useful with code blocks. For example, let''s say
    we want to get some values from a piece of code that uses a guard lock on a reference
    counted service. We can lock the service in the block and return all the values
    as a tuple to the recipients outside of the block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This code is really neat - the lock allows us to obtain the values, the lock
    goes out of scope and the values are returned in one go.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An array is a fixed size list of elements allocated either on the stack or the
    heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g to create a 100 element array of `double` values in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And in Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note how Rust provides a shorthand to initialise the array with the same value
    or assigns the array with every value. Initialisation in C and C++ is optional
    however it is more expressive in that portions of the array can be set or not
    set using enclosed list syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Rust actually *forces* you to initialise an array to something. Attempting to
    declare an array without assigning it a value is a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A slice is a runtime view of a part of an array or string. A slice is not a
    copy of the array / string rather that it is a reference to a portion of it. The
    reference holds a pointer to the starting element and the number of elements in
    the slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This slice represents the portion of array starting from index 2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Size of the array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C and C++ basically give no easy way to know the length of the array unless
    you encapsulate the array with a `std::array` or happen to remember it from the
    code that declares it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `std::array` wrapper is of limited use because you cannot pass arrays of
    an unknown size to a function. Therefore even with this template you may pass
    the array into a function as one argument and its size as another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively you might see code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Or like this
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In Rust, the array has a function bound to it called `len()`. This always provides
    the length of the array. In addition if we take a slice of the array, that also
    has a `len()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings in C++ are a bit messy thanks to the way languages and characters have
    been mapped onto bytes in different ways. The explanation for this requires some
    backstory...
  prefs: []
  type: TYPE_NORMAL
- en: What is a character exactly?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Historically in C and C++, a char type is 8-bits. Strictly speaking a char is
    signed type (usually -128 to 127), but the values essentially represent the values
    0-255.
  prefs: []
  type: TYPE_NORMAL
- en: The US-ASCII standard uses the first 7-bits (0-127) to assign values to upper
    and lower case letters in the English alphabet, numbers, punctuation marks and
    certain control characters.
  prefs: []
  type: TYPE_NORMAL
- en: It didn't help the rest of the world who use different character sets. And even
    ASCII was competing with another standard called EBDIC which was found on mainframe
    computers.
  prefs: []
  type: TYPE_NORMAL
- en: What about the upper values from 128-255? Some operating systems came up with
    a concept called a "code page". According to what "code page" was in effect, the
    symbol that the user would see for a character in the 128-255 range would change.
  prefs: []
  type: TYPE_NORMAL
- en: But even this is not enough. Some languages like Chinese, Japanese, Korean,
    Thai, Arabic etc. have thousands of symbols that must be encoded with more than
    one byte. So the first byte might be a modifier that combines with further bytes
    to render as a symbol. For example Microsoft's code page 932 use an encoding called
    Shift JIS (Japanese) where some symbols are two bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously this was rapidly becoming a mess. Each code page interpretted the
    same byte array differently according to some external setting. So you could not
    send a file written in Chinese to someone with a different code page and expect
    it to render properly.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode to the rescue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Unicode standard assigns every printable symbol in existence with a unique
    32-bit value, called a code point. Most symbols fall in the first 16-bits called
    the Basic Multilingual Plane (BMP).
  prefs: []
  type: TYPE_NORMAL
- en: China has mandated all software must support all 32-bits. We'll see how this
    has become a major headache for C and C++
  prefs: []
  type: TYPE_NORMAL
- en: C / C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no string primitive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C and C++ does not have a string primitive type, instead it has `char` type,
    that is one byte. A "string" is a pointer to an array of chars that are terminated
    with a zero byte, `'\0'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In C, functions such as `strlen()`, `strcpy()`, `strdup()` etc. allow strings
    to be manipulated but they work by using the zero byte to figure out the length
    of things. So `strlen()` the number of bytes that were encountered before a `\0`
    was found. Sicne these functions run until they find a terminating character it
    is very easy to accidentally for them to overrun a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: In C++ the `std::string` class wraps a char pointer and provides safe methods
    for modifying the string in a safe manner. It is a vast improvement over C but
    it is still not a primitive - it is a class defined in a header that is compiled
    and linked to the executable just like every other class.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, a `std::string` will usually use heap to store the string's data
    which can have repercussions for memory usage and fragmentation. There is usually
    a hidden cost to assigning one string to another because memory must be allocated
    to receive a copy of the string, even if the string itself is not modified during
    the assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C/C++ added Unicode support by creating a wide character called `wchar_t`. And
    C++ has an equivalent `std::wstring`.
  prefs: []
  type: TYPE_NORMAL
- en: We're sorted now right?
  prefs: []
  type: TYPE_NORMAL
- en: Oops no, because `wchar_t` type can be either 2 or 4 bytes wide and is a compiler
    / platform specific decision.
  prefs: []
  type: TYPE_NORMAL
- en: In Microsoft Visual C++ the wide char is an `unsigned short` (corresponding
    to Win32's Unicode API), in gcc it can be 32-bits or 16-bits according to the
    compile flags.
  prefs: []
  type: TYPE_NORMAL
- en: A 16-bit value will hold symbols from the Basic Multilingual Plane but not the
    full 32-bit range. This means that 16-bit wide strings should be assumed to be
    UTF-16 encoded because they cannot support Unicode properly otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: C++11 rectifies this by introducing explicit `char16_t` and `char32_t` types
    and corresponding versions of string called `std::u16string` and `std::u32string`.
  prefs: []
  type: TYPE_NORMAL
- en: Character types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So now C++ has 4 character types. Great huh?
  prefs: []
  type: TYPE_NORMAL
- en: '| Character type | Encoding |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | C, ASCII, EBDIC, UTF-8, ad hoc, ??? |'
  prefs: []
  type: TYPE_TB
- en: '| `wchar_t` | UTF-16 or UTF-32 |'
  prefs: []
  type: TYPE_TB
- en: '| `char16_t` | UTF-16 |'
  prefs: []
  type: TYPE_TB
- en: '| `char32_t` | UTF-32 |'
  prefs: []
  type: TYPE_TB
- en: Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust has been rather fortunate. Unicode preceded it so it makes a very simple
    design choice.
  prefs: []
  type: TYPE_NORMAL
- en: A `char` type is a 32-bit Unicode character, always enough to hold a single
    character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `str` type is a UTF-8 encoded string held in memory. Code tends to use &str
    which is a string slice, basically a reference to the str, or a portion of it.
    A str does not need to be terminated with a zero byte and can contain zero bytes
    if it wants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `std::String` is a heap allocated string type use for manipulating strings,
    building them, reading them from file, cloning them etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that internally UTF-8 is used for encoding yet a char is 32-bits. The length
    of a strings is considered to be its byte length. There are special iterators
    for walking the string and decoding UTF-8 into 32-bit characters.
  prefs: []
  type: TYPE_NORMAL
- en: Finally there is a platform specific type `OSString` that handles any differences
    in how the operating system sees strings compared to Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Types Comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| C++ | Rust |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|  | `char *` or `wchar_t *` |'
  prefs: []
  type: TYPE_TB
- en: '| C++11 - `char16_t *`, `char32_t *` | `str`, `&str` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `std::string`, `std::wstring` |'
  prefs: []
  type: TYPE_TB
- en: '| `std::u16string` `std::u32string` | `std::String` |'
  prefs: []
  type: TYPE_TB
- en: char * vs str
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C/C++ do not have a string primitive. A string is a pointer to some bytes in
    memory that are nul terminated. The same applies for wider chars, except of course
    they require 2 or 4 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Rust would use a `str` for this purpose. A `str` is an *immutable* array of
    bytes somewhere in memory. The `str` could be on the heap when it points to a
    `String` object, or it could be in global memory if the string is static. A str
    *slice* is `&str`, is reference to a str which also contains a length value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Type inferences for these assignments will create a string slice pointing to
    the statically allocated string data. The data itself doesn't move and the `&str`
    is read-only.
  prefs: []
  type: TYPE_NORMAL
- en: We can also observe that Rust removes the mess of character width and literal
    prefixes that C and C++ have to suffer under because Unicode characters are implicitly
    supported.
  prefs: []
  type: TYPE_NORMAL
- en: The `str` has functions for iterating over the string in bytes / characters,
    splitting, find a pattern etc.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note `len()` is the length in bytes because strings are UTF-8 encoded. A single
    character may be encoded as 1, 2, 3, or 4 bytes. It may not be the number of characters
    a human would actually see.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can split a `&str` to produce a left and a right `&str` slice like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: std::basic_string (C++) vs std::String (Rust)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard C++ library also has template class `std::basic_string` that acts
    as a wrapper around the various character types and can be used for manipulating
    a string of any width. This template is specialised as
  prefs: []
  type: TYPE_NORMAL
- en: '`std::string`, `std:wstring`, `std::u16string` and `std::u32string`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In Rust, the `std::String` type serves the same purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Using it is fairly simple
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A `String` has functions to do actions such as appending, e.g.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Strings are always valid UTF-8.
  prefs: []
  type: TYPE_NORMAL
- en: Internally a String has a pointer to the data, its length and a capacity (max
    size). If you intend to expand a string, then you should ensure the `String` has
    sufficient capacity to accommodate its longest value otherwise you may cause it
    to reallocate itself excessively.
  prefs: []
  type: TYPE_NORMAL
- en: Strings will never shrink their capacity unless you explicitly call `shrink_to_fit()`.
    This means if you use a temporary string in a loop, it's probably best to place
    it outside the loop and reserve space to make it efficient.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Strings also have all the methods of str thanks to implementing `Deref` trait.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Strings can be formatted in C with `printf` or `sprintf` or in C++ composed
    with stream operators, e.g. to a `std::stringstream`.
  prefs: []
  type: TYPE_NORMAL
- en: Rust uses `format!` and `println!` macros that more resemble the `sprintf` model.
  prefs: []
  type: TYPE_NORMAL
- en: '| C++ | Rust formatting trait | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%s`, `%u`, `%d`, `%i`, `%f`, `%c` | `{}` | C/C++ require the type of the
    parameter to be specified. In Rust the type is inferred and `{}` will invoked
    the type''s Display trait regardless of what it is. So a String outputs its text,
    numeric types return their value, boolean as returns true or false, and so on.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `%lld`, `%llu` | `{}` | C/C++ has extensions to deal with different size
    ints and floats, e.g. ll for long long due to the way arguments are passed to
    the function. In Rust, there is no need for that. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `{:?}`, `{:#?}` | In Rust `{:?}` returns whatever is implemented by a
    type''s Debug trait. The `{:#?}` variant can be used to pretty-print the output
    for types that derive the Debug trait. |'
  prefs: []
  type: TYPE_TB
- en: '| `%-10s` | `{:<10}` | Format left aligned string padded to minimum of 10 spaces
    |'
  prefs: []
  type: TYPE_TB
- en: '| `%04` | `{:04}` | Pad a number with zero''s to a width of 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `%.3` | `{:.3}` | Pad a number''s precision to 3 decimal places. May also
    be zero-padded, e.g. {:.03} |'
  prefs: []
  type: TYPE_TB
- en: '| `%e`, `%E` | `{:e}`, `{:E}` | Exponent in lower or uppercase |'
  prefs: []
  type: TYPE_TB
- en: '| `%x`, `%X` | `{:x}`, `{:X}` | Hexadecimal in lower or uppercase. Note `{:#x}`,
    `{:#X}` prefixes the output with 0x |'
  prefs: []
  type: TYPE_TB
- en: '| `%o` | `{:o}` | Octal. Note `{:#o}` prefixes the output with 0o |'
  prefs: []
  type: TYPE_TB
- en: '|  | `{:b}` | Binary. Note `{:#b}` prefixes the output with 0b |'
  prefs: []
  type: TYPE_TB
- en: '| `%p` | `{:p}` | Presents a struct''s memory location, i.e. pointer |'
  prefs: []
  type: TYPE_TB
- en: Rust has many [more formatting traits](https://doc.rust-lang.org/std/fmt/#formatting-traits)
    than this.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example it allows named parameters like this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Named parameters would be particularly useful for localization where the order
    of values may be different in one language compared to another.
  prefs: []
  type: TYPE_NORMAL
- en: Display and Debug traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust allows types to be formatted as strings based upon the formatting traits
    they implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two main implementation traits are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Display` - this is for standard textual representation of a type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Debug` - this is for the debugging textual representation of a type. It might
    present additional information or be formatted separately to the Display trait.
    It is possible to `#[derive(Debug)]` this trait which is usually enough for the
    purpose of debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we look at the traits we can see they're identical
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the intrinsic types implement `Display` and `Debug`. We can explicitly
    implement Display on our own structs too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementing `Debug` is usually done by `#[derive(Debug)]` but it could also
    be implemented. The derived `Debug` will print out the struct name, and then the
    members in curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Many types process formatting traits which are values held between the `{}`
    braces in the string. These are fairly similar to the patterns used in C functions
    for printf, sprintf etc.
  prefs: []
  type: TYPE_NORMAL
- en: OsString / OsStr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust recognises there are times when you need to pass or receive a string from
    a system API.
  prefs: []
  type: TYPE_NORMAL
- en: In this case you may use `OsString` which allows interchange between Rust and
    a system dependent representations of strings. On Windows it will return UTF-16
    strings, on Linux / Unix systems it will return UTF-8.
  prefs: []
  type: TYPE_NORMAL
- en: An `OsStr` is a slice onto `OsString`, analogous to `str` and `String`.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type Inference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++11 has type inference, previous versions of C++ do not. Type inference allows
    the programmer to assign a value to an `auto` typed variable and let the compiler
    infer the type based on the assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean and numeric types are fairly easy to understand providing the code is
    as explicit as it needs to be.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Where C++ gets messy is for arrays and strings. Recall that strings are not
    primitive types in the strong sense within C or C++ so auto requires they be explicitly
    defined or the type will be wrong.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Strings are covered elsewhere, but essentially there are many kinds of strings
    and C++/C has grown a whole bunch of string prefixes to deal with them all.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are a more interesting problem. The `auto` keyword has no easy way to
    infer array type so is one hack workaround to assign a templatized array to an
    `auto` and coerce it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust, variables are declared with a `let` command. The `let` may specify the
    variable's type, or it may also use type inference to infer it from the value
    it is assigned with.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Rust has no problem with using type inference in array assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that all array elements must be the same type, inference would generate
    a compiler error for an array like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Scope rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scope rules in C, C++ and Rust are fairly similar - the scope that you declare
    the item determines its lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: Shadowing variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One very useful feature of Rust is that you can declare the same named variable
    more than once in the same scope or nested scopes and the compiler doesn't mind.
    In fact you'll use this feature a lot.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is called *shadowing* and works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This example uses the variable name `result` 3 times. First to store the result
    of calling `do_something()`, then to extract some value `Foo` from `Option<Foo>`
    and a third time for calling something else. We could have assigned `result` to
    `result2` and then later on assigned the value `do_something_else()` to `result3`
    but we didn't need to because of shadowing.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A pointer is a variable that points to an address somewhere in memory. The pointer's
    *type* indicates to the compiler what to expect at the address but there is no
    enforcement to ensure that the address actually holds that type. A pointer might
    might be assigned `NULL` (or `nullptr` in C++11) or may even be garbage if nothing
    was assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Generally pointers are used in situations where references cannot be used, e.g.
    functions returning allocated memory or parent / child collection relationships
    where circular dependencies would prevent the use of references.
  prefs: []
  type: TYPE_NORMAL
- en: C++11 deprecates `NULL` in favour of new keyword `nullptr` to solve a problem
    with function overloading.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Since `NULL` is essentially `#define NULL 0` and 0 is an integer, we call the
    wrong function by accident. So C++ introduces an explicit `nullptr` for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In Rust:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust supports pointers, normally called *raw* pointers however you will rarely
    use them unless you need to interact with C API or similar purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pointer looks fairly similar to that of C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Although you can make a pointer outside of an unsafe block, many of the functions
    you might want to perform on pointers are unsafe by definition and must be inside
    `unsafe` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation in full is [here](https://doc.rust-lang.org/std/primitive.pointer.html).
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A reference is also a variable that points to an address but unlike a pointer,
    it cannot be reassigned and it cannot be `NULL`. Therefore a reference is generally
    assumed to be safer than a pointer. It is still possible for the a reference to
    become dangling, assuming the address it referenced is no longer valid.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A reference is also lifetime tracked by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tuple is list of values held in parenthesis. They're useful in cases where
    transient or ad-hoc data is being passed around and you cannot be bothered to
    write a special struct just for that case.
  prefs: []
  type: TYPE_NORMAL
- en: In C++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C++ does not natively support tuples, but C++11 provides a template for passing
    them around like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In Rust
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tuples are part of the language and therefore they're far more terse and easy
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Integer numbers are a decimal value followed by an optional type suffix.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++ an [integer literal](http://en.cppreference.com/w/cpp/language/integer_literal#The_type_of_the_literal)
    can be expressed as just the number or also with a suffix. Values in hexadecimal,
    octal and binary are denoted with a prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `u`, `l`, and `ll` suffixes on integers denotes if it is `unsigned`, `long`
    or a `long long` type. The `u` and `l`/`ll` can be upper or lowercase. Ordinarily
    the `u` must precede the size but C++14 allows the reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: C++14 also allows single quotes to be inserted into the number as separators
    - these quotes can appear anywhere and are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Floating point numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Floating point numbers may represent whole or fractional numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C/C++ `bool` literals are `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Characters and Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A character literal is enclosed by single quotes and an optional width prefix.
    The prefix `L` indicates a wide character, `u` for UTF-16 and `U` for UTF-32.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: One oddity of a `char` literal is that `sizeof('a')` yields `sizeof(int)` in
    C but `sizeof(char)` in C++. It isn't a good idea to test the size of a character
    literal.
  prefs: []
  type: TYPE_NORMAL
- en: A `char16_t` and `char32_t` are sufficient to hold any UTF-16 and UTF-32 code
    unit respectively.
  prefs: []
  type: TYPE_NORMAL
- en: A string is a sequence of characters enclosed by double quotes. A zero value
    terminator is always appended to the end. Prefixes work the same as for character
    literals with an additional `u8` type to indicate a UTF-8 encoded string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: User-defined literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++11 introduced [user-defined literals](http://en.cppreference.com/w/cpp/language/user_literal).
    These allow integer, floats, chars and strings to have a user defined type suffix
    consisting of an underscore and a lowercase string. The prefix may act as a form
    of decorator or even a constant expression operator which modifies the value at
    compile time.
  prefs: []
  type: TYPE_NORMAL
- en: C++14 goes further and defines user-defined literals for complex numbers and
    units of time.
  prefs: []
  type: TYPE_NORMAL
- en: See the link for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Rust [number literals](https://doc.rust-lang.org/reference.html#integer-literals)
    can also be expressed as just the number or also with a suffix. Values in hexadecimal,
    octal and binary are also denoted with a prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The underscore in Rust is a separator and functions the same way as the single
    quote in C++14.
  prefs: []
  type: TYPE_NORMAL
- en: Floating point numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Floating point numbers may represent whole or fractional numbers. As with integers
    they may be suffixed to indicate their type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'One quirk with floating point numbers is the decimal point is used for float
    assignments but it''s also used for member and function invocation. So you can''t
    say `2.f32` since it thinks you are referencing f32 on 2\. Instead syntax requires
    you to say `2.f32` or alter how you declare the type, e.g. `let v: f32 = 2.;`.'
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Boolean literals are simply `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Characters and Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A character in Rust is any UTF-32 code point enclosed by single quotes. This
    value may be escaped or not since .rs files are UTF-8 encoded.
  prefs: []
  type: TYPE_NORMAL
- en: A special prefix `b` may be used to denote a byte string, i.e. a string where
    each character is a single byte.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings are the string text enclosed by double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The prefix `b` denotes a byte string, i.e. single byte characters. Rust allows
    newlines, space, double quotes and backslashes to be escaped using backslash notation
    similar to C++.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Strings can also be 'raw' to avoid escaping. In this case, the string is prefixed
    r followed by zero or more hash marks, the string in double quotes and the same
    number of hash marks to close. Byte strings are uninterpretted byte values in
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A collection is something that holds zero or more elements in some fashion that
    allows you to enumerate those elements, add or remove elements, find them and
    so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Vector - a dynamic array. Appending or removing elements from the end is cheap
    (providing the array is large enough to accomodate an additional item). Inserting
    items or removing them from any other part of the array is more expensive and
    involves memory movements. Generally speaking you should always reserve enough
    space in a vector for the most elements you anticipate it will hold. Reallocating
    memory can be expensive and lead to fragmentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vecdeque - a ring buffer array. Items can be added or removed from either end
    relatively cheaply. Items in the array are not arranged sequentially so there
    is a little more complexity to managing wraparound and removal than a Vector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LinkedList - a linked list individually allocates memory for each element making
    it cheap to add or remove elements from anywhere in the list. However there is
    a lot more overhead to iterating the list by index and much more heap allocation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set - a collection that holds a unique set of items. Inserting a duplicate item
    will not succeed. Some sets maintain the order of insertion. Sets are useful where
    you want to weed out duplicates from an input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map - a collection where each item is referenced by a unique key. Some maps
    can maintain the order of insertion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ and Rust have have collections as part of their standard library as is common
    with modern languages.
  prefs: []
  type: TYPE_NORMAL
- en: '| C | C++ | Rust |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| - | `std::vector` | `std::vec::Vec` or `std::collections::VecDeque` |'
  prefs: []
  type: TYPE_TB
- en: '| - | `std::list` | `std::collections::LinkedList` |'
  prefs: []
  type: TYPE_TB
- en: '| - | `std::set` | `std::collections::HashSet`, `std::collections::BTreeSet`
    |'
  prefs: []
  type: TYPE_TB
- en: '| - | `std::map` | `std::collections::HashMap`, `std::collections::BTreeMap`
    |'
  prefs: []
  type: TYPE_TB
- en: C has no standard collection classes or types. Some libraries offer collection
    APIs such as [glib](https://developer.gnome.org/glib/) or [cii](https://github.com/drh/cii).
  prefs: []
  type: TYPE_NORMAL
- en: Iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Iterators are a reference to a position in a collection with the means to step
    through the collection one element at a time.
  prefs: []
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C++11 provides a shorthand way of iterating a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterators are more explicit in C++98 and before and the code in C++11 is basically
    equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This is quite verbose, but essentially each collection type defines a mutable
    `iterator` and immutable `const_iterator` type and calling `begin` returns an
    iterator to the beginning of the collection. Calling the `++` operator overload
    on the iterator causes it to advance to the next element in the collection. When
    it hits the exclusive value returned by `end` it has reached the end of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously with an indexed type such as a `vector` you could also reference elements
    by index, but it is far more efficient to use iterators for other collection types.
  prefs: []
  type: TYPE_NORMAL
- en: Processing collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C++ provides a number of utility templates in <algorithm class="hljs-meta">for
    modifying sequences in collections on the fly.</algorithm>
  prefs: []
  type: TYPE_NORMAL
- en: Rust
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust also has iterators which work in a similar fashion to C++ - incrementing
    their way through collections.
  prefs: []
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: TODO chaining iterators together
  prefs: []
  type: TYPE_NORMAL
- en: TODO mapping one collection to another collection
  prefs: []
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `class` and a `struct` in C++ are largely the same thing from an implementation
    standpoint. They both hold fields and they both can have methods attached to the
    class (`static`) or instance level.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The default access level is `public` for struct and `private` for class. Some
    rules about templates only apply to classes.
  prefs: []
  type: TYPE_NORMAL
- en: From a psychological perspect a `struct` tends to be used to hold public data
    that is largely static and/or passed around. A `class` tends to be something more
    self contained with methods that are called to access or manage private fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'So these are equivalents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Classes can also use an access specifier to inherit from a base class. So a
    class may specify `public`, `protected` or `private` when deriving from another
    class depending on whether it wants those methods to be visible to callers, or
    subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and structs may have special constructor and destructor methods which
    are described in sections below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in the .cpp file you might implement the constructor and method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust only has structs. A `struct` consists of a definition which specifies the
    fields and their access level (public or not), and an `impl` section which contains
    the implementation of functions bound to the struct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'An `impl` section follows containing the associated functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `new()` function here is a convenience method that returns a struct preinitialised
    with the arguments supplied. The `area()` function specifies a `&self` argument
    and returns an area calculation. Any function that supplies a `&self`, or `&mut
    self` can be called from the variable bound to the struct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The `self` keyword works in much the same way as C++ uses `this`, as a reference
    to the struct from which the function was invoked. If a function modifies the
    struct it must say `&mut self`, which indicates the function modifies the struct.
  prefs: []
  type: TYPE_NORMAL
- en: There is no inheritance in Rust. Instead, a `struct` may implement zero or more
    traits. A trait describes some kind of behavior that can be associated with the
    struct and described further later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++ all classes have implicit or explicit constructors. Either the compiler
    generates them or you do, or a mix of both.
  prefs: []
  type: TYPE_NORMAL
- en: An implicit default constructor, copy constructor and assignment operator will
    be created when a class does not define its own. We saw on page 73 why this could
    be really bad news.
  prefs: []
  type: TYPE_NORMAL
- en: What becomes obvious from reading there is a lot of noise and potential for
    error in C++. There would be even more if raw pointers were used instead of a
    `std::unique_ptr` here.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, things are simpler, and we'll see how it shakes out errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, let''s declare our equivalent struct in Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Since credentials are optional, we wrap in an `Option` object, i.e. credentials
    might be None or it might be `Some(Credentials)`. Any code anywhere in the system
    can instantiate a `Person` simply be declaring an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In Rust you cannot create a struct without initialising all its members so we
    cannot have a situation where we don't know what is in each field - it MUST be
    set by our code.
  prefs: []
  type: TYPE_NORMAL
- en: But declaring the struct is a bit clumsy, especially if the struct is created
    in lots of places. So can write function that behaves like a constructor in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Instead you implement a static method in the impl of the Struct which returns
    an initialised struct, e.g.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Note that Rust does not support overloads. So if we had multiple "constructor"
    methods, they would each have to have unique names.
  prefs: []
  type: TYPE_NORMAL
- en: Finally what is we wanted to copy the `Person` struct?
  prefs: []
  type: TYPE_NORMAL
- en: By default Rust does not allow copying on user-defined structs. Assigning a
    variable to another variable moves ownership, it doesn't copy.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to make a user-defined struct copyable
  prefs: []
  type: TYPE_NORMAL
- en: implement the `Copy` trait which means assignment is implicit, but is what we
    want? Do we really want to make copies of a struct by accident?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: implement `Clone` instead to add a `clone()` method and require an explicit
    call to `clone()` order to duplicate the struct a copy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But the compiler can derive clone() providing all the members of the struct
    implement the Clone trait.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: What we can see is that Rust's construction and `clone()` behavior is basically
    declarative. We saw how C++ has all kinds of rules and nuances to construction,
    copy construction and assignment which make it complicated and prone to error.
  prefs: []
  type: TYPE_NORMAL
- en: Destructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A C++ destructor is a specialized method called when your object goes out of
    scope or is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In C++ you can declare a class destructor to be called when the object is about
    to be destroyed. You have to use a virtual destructor if your class inherits from
    another class in case a caller calls `delete` on the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Since Rust does not do inheritance and does not have constructors, the manner
    in which you cleanup is different and simpler. Instead of a destructor you implement
    the `Drop` trait.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The compiler recognizes this trait. If you implement this trait then the compiler
    knows to call your `drop()` function prior to destroying your struct. Its that
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Occasionally there might be a reason to explicitly drop a struct before it
    goes out of scope. Perhaps the resources held by the variable should be freed
    as soon as possible to release a resource which is in contention. Whatever the
    reason, the answer is to call `drop` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Access specifier rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A C++ class can hide or show methods and members to any other class, or to
    things that inherit from itself using the public, private and protected keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`  can be seen by any code internal or external to the class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`  can only be used by code internal to the class. Not even subclasses
    can access these members'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected`  can be used by code internal to the class and by subclasses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class may designate another function or class as a friend which has access
    to the private and protected members of a class.
  prefs: []
  type: TYPE_NORMAL
- en: Rust makes things somewhat simpler.
  prefs: []
  type: TYPE_NORMAL
- en: If you want a struct to be visible outside your module you mark it `pub`. If
    you do not mark it `pub` then it is only visible within the module and submodules.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: If you want publicaccess a member of a struct (including modifying it if its
    mutable), then mark it `pub`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: If you want something to be able to call a function on your struct you mark
    it `pub`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions can be bound to a struct within an `impl` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Functions that start with a `&self` / `&mut self` parameter are bound to instances.
    Those without are bound to the type. So the `new()` function can be called as
    `Shape::new()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where `&self` is provided, the function is invoked on the instance. So for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Where `&mut self` is provided it signifies that the function mutates the struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike C++, all access to the struct has to be qualified. In C++ you don''t
    publishing_interval: Double, lifetime_count: UInt32, max_keep_alive_count: UInt32,
    max_notifications_per_publish: UInt32, priority: Bytehave to say `this->foo()`
    to call foo() from another member of the class. Rust requires code to say unambiguously
    `self.foo()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Static functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static functions are merely functions in the `impl` block that do not have `&self`
    or `&mut self` as their first parameter, e.g.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: In other words they're not bound to an instance of a type, but to the type itself.
    For example, `Circle::pi()`.
  prefs: []
  type: TYPE_NORMAL
- en: Traits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ allows one class to inherit from another. Generally this is a useful feature
    although it can get pretty complex if you implement multiple inheritance, particularly
    the dreaded diamond pattern.
  prefs: []
  type: TYPE_NORMAL
- en: As weve found out, Rust doesnt have classes at all  theyre structs with
    bound functions. So how do you inherit code? The answer is you dont.
  prefs: []
  type: TYPE_NORMAL
- en: Instead your struct may implement traits which are a bit like partial classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A trait is declared like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Here the trait `HasCircumference` has a function called `circumference()` whose
    signature is defined but must be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: A type can implement the trait by declaring and `impl` of it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: A trait may supply default function implementations. For example, a `HasDimensions`
    trait might implement `area()` to spare the implementor the bother of doing it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Lifetimes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++ an object lives from the moment it is constructed to the moment it is
    destructed.
  prefs: []
  type: TYPE_NORMAL
- en: That lifetime is implicit if you declare the object on the stack. The object
    will be created / destroyed as it goes in and out of scope. It is also implicit
    if your object is a member of another object - the lifetime is within the containing
    object, and the declaration order of other members in the containing object.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you allocate your object via `new` then it is up to you when to
    `delete`. If you `delete` too soon, or forget to `delete` then you may destabilize
    your program. C++ encourages using smart pointers that manage the lifetime of
    your object, tying it to the implicit lifetime of the smart pointer itself - when
    the smart pointer is destroyed, it deletes the held pointer. A more sophisticated
    kind of smart pointer allows multiple instances of the same pointer to exist at
    once, and reference counting is used so that when the last smart pointer is destroyed,
    it destroyes the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Even so, C++ itself will not care if you initialized a class with a reference
    or pointer to something that no longer lives. If you do this, your program will
    crash.
  prefs: []
  type: TYPE_NORMAL
- en: Let's write an `Incrementor` class which increments an integer value and returns
    that value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: This seems fine, but what if we use it like this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This code passes a reference to an `int` into the class constructor and returns
    the `Incrementor` from the function itself. But when `increment()` is called the
    reference is dangling and anything can happen.
  prefs: []
  type: TYPE_NORMAL
- en: Rust lifetimes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust *does* care about the lifetime of objects and tracks them to ensure that
    you cannot reference something that no longer exists. Most of the time this is
    automatic and self-evident from the error message you get if you try something
    bad.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler also implements a *borrow checker* which tracks references to
    objects to ensure that:'
  prefs: []
  type: TYPE_NORMAL
- en: References are held no longer than the lifetime of the object they refer to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only a single mutable reference is possible at a time and not concurrently with
    immutable references. This is to prevent data races.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The compiler will generate compile errors if it finds code in violation of its
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s write the equivalent of `Incrementor` above but in Rust. The Rust
    code will hold a reference to a integer `i32` and increment it from a bound function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Seems fine, but the first error we get is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We tried to create a struct that manages a reference, but the compiler doesn't
    know anything about this reference's lifetime and so it has generated a compile
    error.
  prefs: []
  type: TYPE_NORMAL
- en: To help the compiler overcome its problem, we will annotate our struct with
    a lifetime which we will call `'a`. The label is anything you like but typically
    it'll be a letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This lifetime label is a hint on our struct that says the reference we use
    inside the struct must have a lifetime of at least as much the struct itself -
    namely that `Incrementor<''a>` and `value: &''a mut i32` share the same lifetime
    constraint and the compiler will enforce it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'With the annotation in place, we can now use the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Note that the annotation `'a` could be any label we like - `'increment` would
    work if we wanted, but obviously its more longwinded.
  prefs: []
  type: TYPE_NORMAL
- en: There is a special lifetime called `'static` that refers to things like static
    strings and functions which have a lifetime as long as the runtime and may therefore
    be assumed to always exist.
  prefs: []
  type: TYPE_NORMAL
- en: Lifetime elision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust allows reference lifetimes to be elided (a [fancy word](https://ericlippert.com/2013/01/24/five-dollar-words-for-programmers-elision/)
    for omit) in most function signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, it assumes that when passing a reference into a function, that the
    lifetime of the reference is implicitly longer than the function itself so the
    need to annotate is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The rules for elision are described in the further reference link.
  prefs: []
  type: TYPE_NORMAL
- en: Further reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lifetimes are a large subject and the documentation is [here](https://doc.rust-lang.org/book/second-edition/ch10-03-lifetime-syntax.html#lifetime-elision).
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rust comments are similar to C++ except they may contain Unicode because .rs
    files are UTF-8 encoded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'But in addition anything that uses triple slash `///` annotation can be parsed
    by a tool called `rustdoc` to produce documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Runnining `cargo doc` on a project will cause HTML documentation to be produced
    from annotated comments within the file.
  prefs: []
  type: TYPE_NORMAL
- en: Annotation is written in Markdown format. That means you have a human readable
    language for writing rich-text documentation and if it's not enough you can resort
    to HTML via tags.
  prefs: []
  type: TYPE_NORMAL
- en: See here for [full documentation](https://doc.rust-lang.org/book/documentation.html)
  prefs: []
  type: TYPE_NORMAL
- en: Lifetimes, References and Borrowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lifetimes, References and Borrowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you assign an object to a variable in Rust, you are said to be binding
    it. i.e your variable "owns" the object for as long as it is in scope and when
    it goes out of scope it is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: So variables are scoped and the scope is the constraint that affects their lifetime.
    Outside of the scope, the variable is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, it is important to remember the `Vec` is on the stack but the
    pointer it allocates to hold its elements is on the heap. The heap space will
    also be recovered when the `Vec` is dropped.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we assign v1 to another variable, then all the object ownership is moved
    to that other variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This may seem weird but it's worth remembering a serious problem we saw in C++,
    that of copy constructor errors. It is too easy to duplicate a class and inadvertantly
    share private date or state across multiple instances.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want objects v1 and v2 to share internal state and in Rust they don't.
    Rust moves the data from v1 to v2 and marks v1 as invalid. If you attempt to reference
    v1 any more in your code, it will generate a compile error. This compile error
    will indicates that ownership was moved to v2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, if we pass the value to a function then that also moves ownership:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call we_own_it() we moved ownership of the object to the function and
    it never came back. Therefore the following call using v1 is invalid. We could
    call a variation of the function called we_own_and_return_it() which does return
    ownership:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: But that's pretty messy and there is a better way described in the next section
    called borrowing.
  prefs: []
  type: TYPE_NORMAL
- en: These move assignments look weird but it is Rust protecting you from the kinds
    of copy constructor error that is all too common in C++. If you assign a non-Copyable
    object from one variable to another you move ownership and the old variable is
    invalid.
  prefs: []
  type: TYPE_NORMAL
- en: If you truly want to copy the object from one variable to another so that both
    hold independent objects you must make your object implement the Copy trait. Normally
    it's better to implement the Clone trait which works in a similar way but through
    an explicit clone() operation.
  prefs: []
  type: TYPE_NORMAL
- en: Variables must be bound to something
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another point. Variables must be bound to something. You cannot use a variable
    if it hasn''t been initialized with a value of some kind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: It is quite valid in C++ to declare variable and do nothing with it. Or conditionally
    do something to the variable which confuses the compiler so it only generates
    a warning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The Rust compiler will throw an error, not a warning, if variables are uninitialised.
    It will also warn you if you declare a variable and end up not using it.
  prefs: []
  type: TYPE_NORMAL
- en: References and Borrowing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen that ownership of an object is tracked by the compiler. If you assign
    one variable to another, ownership of the object is said to have moved to the
    assignee. The original variable is invalid and the compiler will generate errors
    if it is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately this extends to passing values into functions and this is a nuisance.
    But variable bindings can be borrowed. If you wish to loan a variable to a function
    for its duration, you can pass a reference to the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Here we create an empty vector and pass a mutable reference to it to a function
    called fill_vector(). The compiler knows that the function is borrowing v and
    then ownership is returned to v after the function returns.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An expression is something that evaluates to something. Just like C++ more or
    less...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: But blocks are expressions too
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Where it gets more interesting is that a block of code, denoted by curly braces
    also evaluates to an expression. This is legal code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: What was assigned to x? In this case the block was empty so x was assigned with
    the value of `()`. The value `()` is a special unitary type that essentially means
    neither yes or no. It just means "value". That is the default type of any function
    or type. It works a little like `void` in C++ meaning the value is meaningless
    so don't even look at it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: This block also returns a value of `()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Again, that's because although the block does stuff (print Hello), it doesn't
    evaluate to anything so the compiler returns `()` for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far so useless. But we can change what the block expression evaluates to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Now x assigned with the result of the last line which is an expression. Note
    how the line is not terminated with a semicolon. That becomes the result of the
    block expression. If wed put a semicolon on the end of that line as we did with
    the println!("Hello"), the expression would evaluate to ().
  prefs: []
  type: TYPE_NORMAL
- en: Use in functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Trivial functions can just omit the return statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: You can use return in blocks too
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you might explicitly need to use the return statement. The block expression
    evaluates at the end of the block so if you need to bail early you could just
    use return.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Simplifying switch statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In C or C++ you''ll often see code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The code wants to test a value in server_state and assign a string to result.
    Aside from looking a bit clunky it introduces the possibility of error since we
    might forget to assign, or add a break, or omit one of the values.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust we can assign directly into result of from a match because each match
    condition is a block expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Not only is this half the length it reduces the scope for error. The compiler
    will assign the block expression's value to the variable result. It will also
    check that each match block returns the same kind of type (so you can't return
    a float from one match and strings from others). It will also generate an error
    if the ServerState enum had other values that our match didn't handle.
  prefs: []
  type: TYPE_NORMAL
- en: Ternary operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ternary operator in C/C++ is an abbreviated way to perform an if/else expression
    condition, usually to assign the result to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Rust has no such equivalent to a ternary operator but it can be accomplished
    using block expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Unlike C/C++ you could add additiona else ifs, matches or anything else to that
    providing each branch returns the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conditional code is similar between C++ and Rust. You test the boolean truth
    of an expression and you can use boolean operators such as && and || to join expressions
    together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'In Rust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The most notable difference is that Rust omits the outer braces so the code
    is slightly cleaner. You don't have to omit the outer braces but the compiler
    will issue a warning if you leave them in.
  prefs: []
  type: TYPE_NORMAL
- en: Ternary operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ternary operator is that special ? : shorthand notation you can use to
    in C++ for simple conditionals.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Rust does not support this notation, however you may take advantage of how
    a block evaluates as an expression to say this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'So basically you can do one line conditional assignments using if and else.
    Also note that you could even throw in an "else if" or two if that''s what you
    wanted to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Conditional "if let"
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One unusual feature is the "if let" pattern. This combines a test to see if
    something matches a pattern and if it does, to automatically assign the result
    to the tuple. It would be most commonly see in code that returns an enum such
    as a `Result` or `Option`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Switch / Match
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Switch / Match
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `switch` statement in C or C++ allows a condition or a variable to be compared
    to a series of values and for code associated with those values to executed as
    a result. There is also a default clause to match any value that is is not caught
    explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Switch statements can be a source of error because behaviour is undefined when
    a `default` clause is not supplied. It is also possible to inadvertently forget
    the `break` statement. In the above example, the code explicitly "drops" from
    the 404 handler into the default handler. This code would work fine providing
    someone didn't insert some extra clauses between 404 and default...
  prefs: []
  type: TYPE_NORMAL
- en: Additionally switch statements only work on numeric values (or `bool`).
  prefs: []
  type: TYPE_NORMAL
- en: Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Match](https://doc.rust-lang.org/book/match.html) is like a `switch` statement
    on steroids.'
  prefs: []
  type: TYPE_NORMAL
- en: In C++ a switch is a straight comparison of an integer value of some kind (including
    chars and enums), against a list of values. If the comparison matches, the code
    next to it executes until the bottom of the switch statement or a break is reached.
  prefs: []
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Casting is the act of coercing one type to be another, or dynamically producing
    the equivalent value in the other type.
  prefs: []
  type: TYPE_NORMAL
- en: C++ has a range of cast operators that turn a pointer or value of one kind into
    a pointer or value of another kind.
  prefs: []
  type: TYPE_NORMAL
- en: '`const_cast<T>(value)` - removes the const enforcement from a value so it may
    be modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static_cast<T>(value)` - attempts to convert between types using implicit
    and user defined conversions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reinterpret_cast<T>(value)` - a compiler directive to just treat the input
    as some other kind. It does not involve any form of conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dynamic_cast<T>(value)` - attempts to convert a class pointer / reference
    to/from other classes in its inheritance hierarchy. Involves runtime checks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traditional C-style cast - a C++ compiler will attempt to interpret it as a
    `const_cast`, a `static_cast` and a `reinterpret_cast` in varying combinations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's a very brief summary of casting which probably invokes more questions
    than it answers. Casting in C++ is very complex and nuanced. Some casts merely
    instruct the compiler to ignore const or treat one type as another. A static cast
    might involve code generation to convert a type. A dynamic cast might add runtime
    checks and throw exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Rust has nothing equivalent to this complexity. A numeric type may be converted
    to another numeric type using the [`as`](https://doc.rust-lang.org/book/casting-between-types.html#as)
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Anything beyond this requires implementing the `Into<>` or `From<>` traits and
    making conversion an explicit action.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler also does not allow code to cast away `const`-ness or treat one
    type as another except through `unsafe` code blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Transmutation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust allows some types to be [transmuted](https://doc.rust-lang.org/book/casting-between-types.html#transmute)
    to others. Transmute is an `unsafe` action but it allows a memory location to
    be treated as another type, e.g. an array of bytes as an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++ an `enum` is a bunch of labels assigned an `int` value. i.e. it is basically
    a bunch of constants with scalar values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: C++11 extends this concept a little, allowing you to declare an `enum` that
    uses another kind of integral type, e.g. a `char` to hold the values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: In Rust an [`enum`](https://doc.rust-lang.org/book/enums.html) can be a scalar
    value just like in C++.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: But an enum can also hold actual data so you can convey far more information
    than a static value could by itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also bind functions to the enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'So we might have a function that makes an http request and returns a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Now our code is able to return a more meaningful response in an enum and the
    code is able to extract that response to print out useful information.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `for` loop in C/C++ consists of 3 expression sections housed in the `for()`
    section and a block of code to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The three segments of a for statement allow:'
  prefs: []
  type: TYPE_NORMAL
- en: Zero or more variables to be initialized (can be empty)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero or more conditions to be true for the loop to continue (can be empty)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero or more actions to perform on each iteration (can be empty).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So this is a valid for loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'So is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: This is clearly a convoluted and somewhat confusing loop because it mixes assignment
    and conditional tests into the terminating text, but it is one which is entirely
    legal.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating a range
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A C++ loop consists of an initialising expression, a condition expression and
    a a loop expression separated by semicolons. So a loop that iterates from 0 to
    100 looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Iterating C++ collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C++ introduces the concept of iterators to its collection classes. An `iterator`
    is something that can increment or decrement to traverse a collection.
  prefs: []
  type: TYPE_NORMAL
- en: So to iterate a collection from one end to the other, an iterator is assigned
    with the collection's `begin()` iterator and incremented until it matches the
    `end()` iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'C++11 provides new range based for-loop with simpler syntax when iterating
    over arrays and collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Infinite Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An infinite loop is one that never ends. The typical way to do this in C++
    is to test against an expression that always evaluates to true or use an empty
    for loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: While Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ has conditional `while() {}` and `do { } while()` forms. The former tests
    the expression before it even runs while the latter runs at least once before
    testing the expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: The do-while form in C++ will execute the loop body at least once because the
    condition is only tested after each iteration instead of before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Break and Continue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to exit a loop or start the next iteration early then you use the
    `break` and `continue` keywords. The break keyword terminates the loop, the continue,
    causes the loop to proceed to the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust's `for` loop is actually sugar over the top of iterators. If a structured
    type implements the trait `IntoIterator` it can be looped over using a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically in pseudo code, the loop desugars to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Iterating a range
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A `Range` object in Rust is expressed as `from..to` where `from` and `to` are
    values or expressions that evaluate to values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: A range is inclusive / exclusive, i.e. the minimum value is included in the
    `Range` but the maximum value is exclusive.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a simple loop that counts from 0 to 9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: The value `0..10` is a `Range` that runs from 0 to exclusive of 10\. A range
    implements the `Iterator` trait so the for loop advances one element at a time
    until it reaches the end.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators have a lot of functions on them for doing fancy stuff, but one which
    is useful in loops is the `enumerate()` function. This transforms the iterator
    into returning a tuple containing the index and the value instead of just the
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'So for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: For loop - Iterating arrays and collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a loop that iterates an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Note you can only iterate over an array by reference because iterating it by
    value would be destructive.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can directly use the `iter()` function that arrays and collections implement
    which works by reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: If the collection is a map, then iterators will return a key and value tuple
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to iterate is using the `for_each()` function on the iterator itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Break and Continue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust also has `break` and `continue` keywords and they operate in a similar
    fashion - they operate on the innermost loop. A `continue` will start on the next
    iteration while a `break` will terminate the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Labels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `break` and `continue` work by default on the current loop. There will
    be occasions where you intend to break out of an enclosing loop instead. For those
    occasions you can label your loops and pass that label into the `break` or `continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Infinite Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rust has an explicit infinite `loop` that runs indefinitely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Rust recommends using this form when an infinite loop is required to assist
    with code generation. Note that an infinite loop can still be broken out of using
    a `break` statement.
  prefs: []
  type: TYPE_NORMAL
- en: While Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `while` loop in Rust looks pretty similar to one written in C/C++. The main
    difference is that parentheses are not necessary around the conditional test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Rust has no equivalent to the do-while loop form. It can be simulated but it
    looks a bit inelegant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: While let loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as there is an `if let` which tests and assigns a value that matches a
    pattern, there is also a `while let` equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: This loop will break when the iterator returns `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++ the standard form of a function is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Usually you would declare the function, either as a forward reference in a source
    file, or in a header. Then you would implement the function in a source file.
  prefs: []
  type: TYPE_NORMAL
- en: If a function does not return something, the return type is `void`. If the function
    does return something, then there should be return statements for each exiting
    branch within the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can forego the function declaration in two situations:'
  prefs: []
  type: TYPE_NORMAL
- en: If the function is inline, i.e. prefixed with the `inline` keyword. In which
    case the function in its entireity is declared and implemented in one place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the function is not inline but is declared before the code that calls it
    in the same source file. So if function `foo` above was only used by one source
    file, then just putting the implementation into the source would also act as the
    declaration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Rust the equivalent to `foo` above is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: The implementation *is* the declaration there is no separation between the two.
    Functions that return nothing omit the `->` return section. The function can also
    be declared before or after whatever calls it. By default the function is private
    to the model (and submodules) that implement it but making it `pub fn` exposes
    it to other modules.
  prefs: []
  type: TYPE_NORMAL
- en: Like C++, the function must evaluate to something for each exiting branch but
    this is mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note, that the `return` keyword is not usually unecessary. Here is a function
    that adds two values together and returns them with no return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Why is there no `return`? As we saw in the section on Expressions, a block evaluates
    to a value if we omit the semi-colon from the end so `x + y` is the result of
    evaluating the function block and becomes what we return.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are occasions were you explicitly need the return keyword. Typically
    you do that if you want to exit the function before you get to the end of the
    function block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Variable arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ functions can take a variable number of arguments with the ... ellipsis
    pattern. This is used in functions such as print, scanf etc.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Rust does not support variadic functions (the fancy name for this ability).
    However you could pass additional arguments in an array slice if the values are
    the same, or as a dictionary or a number of other ways.
  prefs: []
  type: TYPE_NORMAL
- en: TODO Rust example of array slice
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to write your code as a macro. Macros can take any number
    of expressions so you are able to write code that takes variable arguments. This
    is how macros such println!, format! and vec! work.
  prefs: []
  type: TYPE_NORMAL
- en: Default arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ arguments can have default values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: A function defines what its name is, what types it takes and what value (if
    any) it returns.
  prefs: []
  type: TYPE_NORMAL
- en: Function overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++ functions can be overloaded, e.g.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Rust does not support overloading. As an alternative, each variation of the
    function would have to be named uniquely.
  prefs: []
  type: TYPE_NORMAL
- en: C++11 alternative syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C++11 introduces a new syntax which is slightly closer to Rust's in style.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: This form was created to allow C++ function declarations to more closely to
    resemble lambda functions in some scenarios and to help with decltype return values.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C++ has 4 types of polymorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: Function name overloading - multiple definitions of the same function taking
    different arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Coercion - implicit type conversion, e.g. assigning a double to an int or a
    bool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parametric - compile type substitution of parameters in templates
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inclusion - subtyping a class with virtual methods overloads their functionality.
    Your code can use the pointer to a base class, yet when you call the method you
    are calling the function implemented by the subtype.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That is to say, the same named function can be overloaded with different parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Function name overloading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: One of the biggest issues that you might begin to see from the above example
    is that is too easy to inadvertantly call the wrong function because C++ will
    also implicitly convert types. On top of that C++ also has default parameter values
    *and* default constructors. So you might call a function using one signature and
    be calling something entirely different after the compiler resolves it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: This example will call the integer overload because `NULL` evaluates to 0\.
    One of the changes to `C++11` was to introduce an explicit `nullptr` value and
    type to avoid this issues.
  prefs: []
  type: TYPE_NORMAL
- en: Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust has limited support for polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Function name overloading - there is none. See section below for alternatives.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Coercion. Rust allows limited, explict coercion between numeric types using
    the `as` keyword. Otherwise see below for use on `Into` and `From` traits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parameteric - similar to C++ via generics
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inclusion - there is no inheritance in Rust. The nearest thing to a virtual
    method in rust is a trait with an implemented function that an implementation
    overrides with its own. However this override is at compile time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatives to function name overloading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a few functions you can just disambiguate them, e.g.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Use traits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A common way to do polymorphism is with *traits*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two standard traits for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: The `From<>` trait converts from some type into the our type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Into<>` trait converts some type (consuming it in the process) into our
    type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You only need to implement `From` or `Into` because one implies the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `From` trait is easier to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'But let''s say we want an explicit `new` constructor function on type `Foo`.
    In that case, we could write it using the `Into` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `From` implies `Into` we can just call the constructor like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: If you prefer you could implement `Into` but it's more tricky since it consumes
    the input, which might not be what you want.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Use enums
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Remember that an enumeration in Rust can contain actual data, so we could also
    implement a function that takes an enumeration as an argument that has values
    for each kind of value it accepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ allows code to throw and catch exceptions. As the name suggests, exceptions
    indicate an exceptional error. An exception is thrown to interrupt the current
    flow of logic and allows something further up the stack which to catch the exception
    and recover the situation. If nothing catches the throw then the thread itself
    will exit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Most coding guidelines would say to use exceptions sparingly for truly exceptional
    situations, and use return codes and other forms of error propagation for ordinary
    failures. However C++ has no simple way to confer error information for ordinary
    failures and exceptions can be complicated to follow and can cause their own issues.
  prefs: []
  type: TYPE_NORMAL
- en: Rust does not support exceptions. Rust programs are expected to use a type such
    as `Option` or `Result` to propagate errors to their caller. In other words, the
    code is expected to anticipate errors and have code to deal with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Option` enum either returns `None` or `Some` where the `Some` is a payload
    of data. It''s a generic enum that specifies the type of what it may contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: For example, we might have a function that searches a database for a person's
    details, and it either finds them or it doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: The `Result` enum either returns a value of some type or an error of some type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: So we might have a function `set_thermostat` for setting the room temperature.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: This function will return a unity `()` value for success, or a `String` for
    failure.
  prefs: []
  type: TYPE_NORMAL
- en: The ? directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say you have 2 functions `delete_user` and `find_user`. The function `delete_user`
    first calls `find_user` to see if the user even exists and then proceeds to delete
    the user or return the error code that it got from `find_user`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a lot of code in `delete_user` to handle success or failure in `find_user`
    and throw its failure code upwards. So Rust provides a convenience `?` mark on
    the end of the call to a function that instructs the compiler to generate the
    if/else branch we hand wrote above, reducing the function to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Providing you want to propogate errors up the call stack, this can eliminate
    a lot of messy conditional testing in the code and make it more robust.
  prefs: []
  type: TYPE_NORMAL
- en: Older versions of Rust used a special `try!()` macro for this same purpose (not
    to be confused with `try-catch` in C++) which does the same thing. So if you see
    code like this, it would be the same as above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Nuclear option - panic!()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If code really wants to do something equivalent to a throw / catch in C++ it
    may call panic!().
  prefs: []
  type: TYPE_NORMAL
- en: This is NOT recommended for dealing with regular errors, only irregular ones
    that the code has no way of dealing with.
  prefs: []
  type: TYPE_NORMAL
- en: This macro will cause the thread to abort and if the thread is the main programme
    thread, the entire process will exit.
  prefs: []
  type: TYPE_NORMAL
- en: A panic!() can be caught and should be if Rust is being invoked from another
    language. The way to catch an unwinding panic is a closure at the topmost point
    in the code where it can be handled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Lambda Expressions / Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda Expressions / Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambdas in C++11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A [lambda expression](https://msdn.microsoft.com/en-us/library/dd293608.aspx),
    or lambda is an anonymous function that can be declared and passed around from
    within the scope of the call itself.
  prefs: []
  type: TYPE_NORMAL
- en: This can be particularly useful when you want to sort, filter, search or otherwise
    do some trivial small action without the bother of declaring and maintaining a
    separate function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++ a lambda looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: This lambda is passed to a std::sort function to sort an array of values by
    some criteria.
  prefs: []
  type: TYPE_NORMAL
- en: A C++ lambda can (but doesn't have to) capture variables from the enclosing
    scope if it wishes and it can specify capture clauses in the `[]` section that
    define how capture is made. Captures can be by value or reference, and can explicitly
    list the variables to capture, or specify to capture everything by reference or
    assignment. A lambda that captures variables effectively becomes a closure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see from the output that `multiply()` has captured copies of the values
    in `v1` and `v2`, whereas `sum()` captures by reference and so it is sensitive
    to changes in the variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: A capture can also specify a default capture mode by specifying `=` in the capture
    clause or by reference `&` and then specify capture behaviour for specific variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'So our captures above could be simplified to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Note that C++ lambdas can exhibit dangerous behaviour - if a lambda captures
    references to variables that go out of scope, the lambda's behaviour is undefined.
    In practice that could mean the application crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Closures in Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust implements closures. A closure is like a lambda except it automatically
    captures anything it references from the enclosing environment. i.e. by default
    it can access any variable that is in the enclosing scope.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the same sort snippet we saw in C++ expressed as Rust. This closure
    doesn't borrow anything from its enclosing scope but it does take a pair of arguments
    to compare two values for sorting. The `sort_by()` function repeatedly invokes
    the closure to sort the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'A closure that uses a variable from the enclosing scope borrows it by default.
    That means the borrowed variable can''t change while the closure is in scope.
    To change the value we must ensure the closure goes out of scope to free the borrow,
    e.g. with a block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively you can `move` variables used by the closure so it owns them and
    they become inaccessible from the outerscope. Since our closure was accessing
    an integer, the move becomes an implicit copy. So our `square` closure has its
    own `x` assigned the value `100`. Even if we change `x` in the outer scope to
    `200`, the closure has its own independent copy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the equivalent to the C++ code above that used lambda expressions to
    bind to copies and references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: This will yield the same results as the C++ code. The main difference here is
    that rather than binding our closure to a reference, we passed the reference values
    in as parameters to the closure.
  prefs: []
  type: TYPE_NORMAL
- en: Templates / Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates / Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ offers templates as a way to write generic code using an abstract type and
    then specialize it by substituting one or more types into a concrete class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'This template uses the type of the parameter (int this case 10) to create an
    inline function that prints out the value of that type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'Classes can also be made from templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: This class implements a simple stack using a template to indicate the type of
    object it contains.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very powerful mechanism and the C++ library makes extensive use of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Where templates can become a bit of a mess is that the templates are inline
    and the compiler will expand out anything you call before attempting to compile
    it.
  prefs: []
  type: TYPE_NORMAL
- en: An innocuous error such as using a type that has no default copy constructor
    in a collection can cause the compiler to go nuts and output a wall of indecipherable
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust's equivalent to a template is called a generic. A generic generalizes a
    function or a trait so it works with different types that match the criteria.
  prefs: []
  type: TYPE_NORMAL
- en: So the Rust equivalent of the `debug()` function in C++ would be this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Here we describe a function that takes a generic type `T` where the constraint
    is that `T` must implement the trait `std::fmt::Display`. Any struct that implements
    this trait can passed into the call. Since integer types implement the trait,
    we can just call it directly as `debug(10)` and the compiler is happy.
  prefs: []
  type: TYPE_NORMAL
- en: Generic structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly we can use generics on a struct. So the equivalent in Rust of the
    C++ template class `Stack` is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Where clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `where` clause can be added to impose constraints on what generic type must
    do to be allowed to be supplied to the generic function or struct.
  prefs: []
  type: TYPE_NORMAL
- en: For example we might have a function that takes a closure as an argument. A
    closure is a function and so we want to define the shape that the closure will
    take.
  prefs: []
  type: TYPE_NORMAL
- en: 'So:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Here we have defined a `compare()` function that takes a couple of values of
    the same type. The `where` clause states that the function must take two values
    of the same type and return a boolean. The compiler will ensure any closure we
    pass in matches that criteria, as indeed our `comparer` closure does.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ has various ways to give compiler *directives* during compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile flags that control numerous behaviours
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#pragma` statements - `once`, `optimize`, `comment`, `pack` etc. Some pragmas
    such as `comment` have been wildly abused in some compilers to insert "comments"
    into object files that control the import / export of symbols, static linking
    and other functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#define` with ubquitous `#ifdef` / `#else` / `#endif` blocks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keywords `inline`, `const`, `volatile` etc.. These hint the code and allow the
    compiler to make decisions that might change its output or optimization. Compilers
    often have their own proprietary extensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust uses a notation called *attributes* that serves a similar role to all of
    these things but in a more consistent form.
  prefs: []
  type: TYPE_NORMAL
- en: 'An attribute `#[foo]` applies to the next item it is declared before. A common
    attribute is used to denote a unit test case with `#[test]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Attributes can also be expressed as `#![foo]` which affects the thing they're
    contained *by* rather the thing that follows them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'Attributes are enclosed in a `#[ ]` block and provide compiler directives that
    allow:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions to be marked as unit or benchmark tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions to be marked for conditional compilation for a target OS. A function
    can be defined that only compiles for one target. e.g. perhaps the code that communicates
    with another process on Windows and Linux is encapsulated in the same function
    but implemented differently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable / disable lint rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable / disable compiler features. Certain features of rust may be experimental
    or deprecated and may have to be enabled to be accessed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the entry point function from `main` to something else
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional compilation according to target architecture, OS, family, endianess,
    pointer width
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inline hinting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deriving certain traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling compiler features such as plugins that implement procedural macros.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing macros from other crates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used by certain crates like serde and rocket to instrument code - NB Rocket
    uses unstable compiler hooks for this and in so doing limits itself to working
    in nightly builds only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conditional compilation allows you to test the target configurations and optionally
    compile functions or modules in or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main configurations you will test include:'
  prefs: []
  type: TYPE_NORMAL
- en: Target architecture - "x86", "x86_64", mips", "arm" etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target OS - "windows", "macos", "ios", "linux", "android", "freebsd" etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target family - "unix" or "windows"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target environment - "gnu", "msvc" etc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target endianess
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target pointer width
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So if you have a function which is implemented one way for Windows and another
    for Linux you might code it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Many more possibilities are listed in the [documentation](https://doc.rust-lang.org/reference/attributes.html#crate-only-attributes).
  prefs: []
  type: TYPE_NORMAL
- en: Linking to native libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C/C++ code is first compiled and then it is linked, either by additional
    arguments to the compiler, or by invoking a linker.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust most of your linking is taken care for you providing you use `cargo`.
  prefs: []
  type: TYPE_NORMAL
- en: All your sources are compiled and linked together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: External crates are automatically built as static libs and linked in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But if you have to link against something external through FFI you have to write
    a `#link` directive in your `lib.rs` or `main.rs`. This is somewhat analogous
    to the `#pragma(comment, "somelib")` in C++.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| C++ | Rust |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `#pragma (comment, "somelib")` | `#[link(name = "somelib")]` |'
  prefs: []
  type: TYPE_TB
- en: '| - | `#[link(name = "somelib", kind = "static")]` |'
  prefs: []
  type: TYPE_TB
- en: The default kind for `#link` is `dynamic` library but `static` can be explicitly
    stated specified.
  prefs: []
  type: TYPE_NORMAL
- en: Inlining code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inlining happens where your function logic is inserted in-place to the code
    that invokes it. It tends to happen when the function does something trivial such
    as return a value or execute a simple conditional. The overhead of duplicating
    the code is outweighed by the performance benefit.
  prefs: []
  type: TYPE_NORMAL
- en: Inlining is achieved in C++ by declaring and implementing a function, class
    method or template method in a header or marking it with the inline keyword.
  prefs: []
  type: TYPE_NORMAL
- en: In Rust, inlining is only a hint. Rust recommends not forcing inlning, rather
    leaving it as a hint for the LLVM compiler to do with as it sees fit.
  prefs: []
  type: TYPE_NORMAL
- en: '| C++ | Rust |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Explicitly with `inline` or implicitly through methods implemented in class
    / struct | `#[inline]`, `#[inline(always)]`, `#[inline(never)]` |'
  prefs: []
  type: TYPE_TB
- en: Another alternative to explicitly inlining code is to use the link-time optimisation
    in LLVM.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Multi-threading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multithreading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multithreading allows you to run parts of your programming concurrently, performing
    tasks in parallel. Every program has a *main* thread - i.e. the one your `main()`
    started from, in addition to which are any that you create.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of reasons to use threads:'
  prefs: []
  type: TYPE_NORMAL
- en: Long running operations, e.g. zipping up a large file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activity that is blocking in nature, e.g. listening for connections on a socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing data in parallel, e.g. physics, collision detection etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous activities, e.g. timers, polling operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, if you use a graphical toolkit, or 3rd party libraries they may
    spawn their own threads that you do not know about.
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One word you will hear a lot in multithreading is thread safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'By that we mean:'
  prefs: []
  type: TYPE_NORMAL
- en: Threads should not be able to modify the data at the same time. When this happens
    it is called a data race and can corrupt the data, causing a crash. e.g. two threads
    trying to append to a string at the same time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads must not lock resources in a way that could cause deadlock i.e. thread
    1 obtains a lock on resource B and blocks on resource A, while thread 2 obtains
    a lock on resource A and blocks on resource B. Both threads are locked forever
    waiting for a resource to release that never will be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Race conditions are bad, i.e. the order of thread execution produces unpredictable
    results on the output from the same input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs that can be called by multiple threads must either protect their data structures
    or make it an explicit problem of the client to sort out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open files and other resources that are accessed by multiple threads must be
    managed safely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting shared data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data should never be read at the same time it is written to in another thread.
    Nor should data be written to at the same time by two threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common way to prevent this is either:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a mutex to guard access to the data. A mutex is a special class that only
    one thread can lock at a time. Other threads that try to lock the mutex will wait
    until the lock held by another thread is relinquished
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a read-write lock. Similar to a mutex, it allows one thread to lock the
    thread for writing data, however it permits multiple threads to have read access,
    providing nothing is already writing to it. For data that is read more frequently
    than it is modified, this is a lot more efficient than just a mutex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding deadlock
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best way to avoid deadlock is only ever obtain a lock to one thing ever
    and release it as soon as you are done. But if you have to lock more than one
    thing, ensure the locking order is consistent between all your threads. So if
    thread 1 locks A and B, then ensure that thread 2 also locks A and B in that order
    and not B then A. The latter is surely going to cause a deadlock.
  prefs: []
  type: TYPE_NORMAL
- en: C / C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C and C++ predate threading to some extent so until C++11 the languages have
    had little built-in support for multi-threading and what there was tended to be
    compiler specific extensions.
  prefs: []
  type: TYPE_NORMAL
- en: A consequence of this is that C and C++ have ZERO ENFORCEMENT of thread safety.
    If you data race - too bad. If you forget to write a lock in one function even
    if you remembered all the others - too bad. You have to discipline yourself to
    think concurrently and apply the proper protections where it is required.
  prefs: []
  type: TYPE_NORMAL
- en: The consequence of not doing so may not even be felt until your software is
    in production and that one customer starts complaining that their server freezes
    about once a week. Good luck finding that bug!
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most common APIs would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<thread>`, `<mutex>` - from C++11 onwards'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POSIX threads, or pthreads. Exposed by POSIX systems such as Linux and most
    other Unix derivatives, e.g. OS X. There is also pthread-win32 support built over
    the top of Win32 threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Win32 threads. Exposed by the Windows operating system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenMP. Supported by many C++ compilers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3rd party libraries like Boost and Qt provide wrappers that abstract the differences
    between thread APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All APIs will have in common:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread creation, destruction, joins (waiting on threads) and detaches (freeing
    the thread to do what it likes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronization between threads using locks and barriers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutexes - mutual exclusion locks that protect shared data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional variables - a means to signal and notify of conditions becoming
    true.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::thread
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `std::thread` represents a single thread of execution and provides an abstraction
    over platform dependent ways of threading.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: The example spawns a thread which invokes the function and passes the parameter
    into it, printing a message 100 times.
  prefs: []
  type: TYPE_NORMAL
- en: std::mutex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C++ provides a family of various `mutex` types to protect access to shared data.
  prefs: []
  type: TYPE_NORMAL
- en: The mutex is obtained by a `lock_guard` and other attempts to obtain the mutex
    are blocked until the lock is relinquished.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: POSIX threads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The pthreads API is prefixed `pthread_` and works like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: This example spawns a thread which invokes DoWork with the payload of 100 which
    causes the function to print a message 100 times.
  prefs: []
  type: TYPE_NORMAL
- en: Win32 Threads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Win32 threading has functions analogous to those in POSIX. They have names such
    as `CreateThread`, `ExitThread`, `SetThreadPriority` etc.
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open Multi-Processing (OpenMP) is an API for multi-threaded parallel processing.
    OpenMP relies on compiler support because you use special `#pragma` directives
    in your source to control thread creation and access to data.
  prefs: []
  type: TYPE_NORMAL
- en: GCC, Clang and Visual C++ have support for OpenMP so it is an option.
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP is a complex standard but the use of directives can make for cleaner
    code than invoking threading APIs directly. The downside is it is also more opaque
    hiding what the software is doing, making it considerably more difficult to debug.
  prefs: []
  type: TYPE_NORMAL
- en: OpenMP is described in detail at the OpenMP [website](http://www.openmp.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Thread local storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thread local storage, or TLS is static or global data which is private to every
    thread. Each thread holds its own copy of this data so it can modify it without
    fear of causing a data race.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compilers also have proprietary ways to decorate types as thread local:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: C++11 has gained a `thread_local` directive to decorate variables which should
    use TLS.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw with C++ that you had to be disciplined to remember to protect data from
    race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Rust doesn't give you that luxury -
  prefs: []
  type: TYPE_NORMAL
- en: Any data that you share must be protected in a thread safe fashion
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any data that you pass between threads must be marked thread safe
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spawning a thread
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spawning a thread is easy enough by calling `spawn`, supplying the closure you
    want to run in the context of your new thread.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively you can supply a function to `spawn` which is called in the same
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: If you supply a closure then it must have a lifetime of `'static` because threads
    can outlive the thing that created them. i.e. they are detached by default.
  prefs: []
  type: TYPE_NORMAL
- en: A closure can make use of move values that are marked `Send` so the compiler
    allows ownership to transfer between threads.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise function / closure may also return a value which is marked `Send` so
    the compiler can transfer ownership between the terminating thread and the thread
    which calls `join` to obtain the value.
  prefs: []
  type: TYPE_NORMAL
- en: So the thread above is detached. If we wanted to wait for the thread to complete,
    the `spawn` returns a `JoinHandle` that we can call `join` to wait for termination.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: If the closure or function returns a value, we can use `join` to obtain it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Data race protection in the compiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data races are bad news, but fortunately in Rust the compiler has your back.
    You MUST protect your shared data or it won't compile.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to protect your data is to wrap the data in a mutex and provide
    each thread instance with a reference counted copy of the mutex.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Here is a full example that spawns 10 threads that each increment the counter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'So the basic strategy will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: Every thread will get it's own atomic reference to the mutex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each thread that wishes to access the shared must obtain a lock on the mutex.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the lock is released, the next waiting thread can obtain access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The compiler will enforce this and generate errors if ANYTHING is wrong.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read Write Lock
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A read write lock works much like a mutex - we wrap the shared data in a `RwLock`,
    and then in an `Arc`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Each thread will then either need to obtain a read lock or a write lock on the
    shared data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of a `RwLock` is that many threads can concurrently read the data,
    providing nothing is writing to it. This may be more efficient in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: Sending data between threads using channels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO mpsc channel
  prefs: []
  type: TYPE_NORMAL
- en: Thread local storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with C++ you may have reason to use thread local storage
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Useful crates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rayon
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The [rayon](https://github.com/rayon-rs/rayon) crate implements parallel iterators
    that allow your collections to be iterated in parallel. The crate utilises work
    stealing and divide and conquer algorithms couple to a thread pool to process
    collections more quickly than they could be in a sequential fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking this is a drop-in replacement with the exception that you
    call `par_iter` instead of `iter`. The crate implements a `ParallelIterator` trait
    on collection classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: See the crate site for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Lint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C/C++ compilers can issue many useful warnings but the amount of static analysis
    they can do is usually quite limited.
  prefs: []
  type: TYPE_NORMAL
- en: The Rust compiler performs a far more rigorous lifecycle check on data and then
    follows up with a lint check that inspects your code for potentially bad or erroneous
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular it looks for:'
  prefs: []
  type: TYPE_NORMAL
- en: Dead / unused code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unreachable code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecated methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undocumented functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camel case / snake case violations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unbounded recursion code (i.e. no conditionals to stop recursion)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of heap memory when stack could be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unused extern crates, imports, variables, attributes, mut, parentheses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using "while true {}" instead of "loop {}"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lint rules can be enforced more strictly or ignored by using attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'A full list of lint rules can be found by typing "rustc -W help":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot checks than are listed here.
  prefs: []
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C / C++ Preprocessor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C languages are little unusual in that they are compiled in two phases. The
    first phase is called the preprocess. In this phase, the preprocessor looks for
    directives starting with a # symbol and runs string substitution and conditional
    inclusion / exclusion based on those directives. Only after the file has been
    preprocessed does the compiler attempt to compile it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Preprocessor directives start with a `#` symbol. For example the `#define`
    directive creates a macro with an optional value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: We'll explore macros more in a moment. Another directive is the `#if\#else\#endif`
    or `#ifdef\#else\#endif` which can be used to include code from one branch or
    the other of a test according to what matches.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Another directive is `#include`. In C and C++, public functions and structures
    are typically defined and implemented in separate files. The `#include` directive
    allows a header to be pulled in to the front of any file that makes use of those
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: The important thing to remember in all of this is ALL of these things happen
    before the compiler even starts! Your `main.c` might only be 10 lines of code
    but if you `#include` some headers the preprocessor may be feeding many thousands
    of lines of types, functions into the compiler, all of which are evaluated before
    they get to your code.
  prefs: []
  type: TYPE_NORMAL
- en: C / C++ Macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Macros are string substitution patterns performed by the preprocessor before
    the source is compiled. As such they can be very prone to error and so have been
    deprecated in favour of constants and inline functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple macro that would behave in an unexpected manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: The macro is very simple - multiply x by y. But it fails if either argument
    is an expression. Judicious use of parentheses might avoid the error in this case,
    but we could break it again using some pre or post increments.
  prefs: []
  type: TYPE_NORMAL
- en: Macros in C++ are also unhygenic, i.e. the macro can inadvertently conflict
    with or capture values from outside of itself causing errors in the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Here our SWAP macro uses a temporary value called `tmp` that already existed
    in the scope and so the compiler complains. A macro might avoid this by using
    shadow variables enclosed within a `do / while(0)` block to avoid conflicts but
    it is less than ideal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'Consequently inline functions are used wherever possible. Even so macros are
    still frequently used in these roles:'
  prefs: []
  type: TYPE_NORMAL
- en: To conditionally include for a command-line flag or directive, e.g. the compiler
    might `#define WIN32` so code can conditionally compile one way or another according
    to its presence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For adding guard blocks around headers to prevent them being #include''d more
    than once. Most compilers implement a "#pragma once directive" which is an increasingly
    common alternative'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For generating snippets of boiler plate code (e.g. namespace wrappers), or
    things that might be compiled away depending on #defines like DEBUG being set
    or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For making strings of values and other esoteric edge cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Writing a macro is easy, perhaps too easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: This macro would expand to printf before compilation but it would fail to compile
    or print the wrong thing if x were not an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Rust macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Macros in Rust are quite a complex topic but they are more powerful and safer
    than the ones in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Rust macros are hygenic. That is to say if a macro contains variables, their
    names do not conflict with, hide, or otherwise interfere with named variables
    from the scope they're used from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The pattern supplied in between the brackets of the macro are tokenized and
    designated as parts of the Rust language. identifiers, expressions etc. In C /
    C++ you can #define a macro to be anything you like whether it is garbage or syntactically
    correct. Furthermore you can call it from anywhere you like because it is preprocessed
    even before the compiler sees the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust macros are either declarative and rule based with each rule having a left
    hand side pattern "matcher" and a right hand side "substitution". Or they're procedural
    and actualy rust code turns an input into an output (see section below).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros must produce syntactically correct code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Declarative macros can be exported by crates and used in other code providing
    the other code elects to enable macro support from the crate. This is a little
    messy since it must be signalled with a #[macro_export] directive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all that said, macros in Rust *are* complex - perhaps too complex - and
    generally speaking should be used as sparingly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a simple declarative macro demonstrating repetition called hello_x!().
    It will take a comma separated list of expressions and say hello to each one of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Essentially the matcher matches against our comma separate list and the substitution
    generates one println!() with the message for each expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: What if we threw some other expressions into that array?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'Well that works too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'What about some illegal code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: We get a meaningful error originating from the macro.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: Real world example - vec!()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust comes with a lot of macros for reducing some of the leg work of tedious
    boiler plate. For example the vec!() macro is a way to declare a std::Vec and
    prepopulate it with some values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the actual vec! macro source code taken from the Rust source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks complex but we will break it down to see what it does. Firstly it
    has a match-like syntax with three branches that expand to anything that matches
    the left hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: First branch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first matcher matches a pattern such as `1; 100`. The value `1` goes into
    `$elem`, the value `100` goes into `$n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: The `$crate` is a special value that resolves to the module crate which happens
    to be std.
  prefs: []
  type: TYPE_NORMAL
- en: 'So this expands to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Second branch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second matcher contains a glob expression - zero or more expressions separated
    by comma (the last comma is optional). Each matching expression ends up in `$x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'So we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'The box keyword tells Rust to allocate the supplied array on the heap and moves
    the ownership by calling a helper function called into*vec() that wraps the memory
    array with a Vec instance. The <[\*]>:: at the front is a turbo-fish notation
    to make the into_vec() generic function happy.'
  prefs: []
  type: TYPE_NORMAL
- en: Third branch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third branch is a little odd and almost looks the same as the second branch.
    But take at look the comma. In the last branch it was next to the asterisk, this
    time it is inside the inner $().
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'The matcher matches when the the comma is there and if so recursively calls
    vec!() again to resolve to the second branch matcher:'
  prefs: []
  type: TYPE_NORMAL
- en: Basically it is there so that there can be a trailing comma in our declaration
    and it will still generate the same code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Procedural Macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we've talked about declarative macros that expand out to be Rust code
    based upon how they pattern match the rules defined by the macro.
  prefs: []
  type: TYPE_NORMAL
- en: A second kind of macro is the *procedural macro*. A procedural macro is a plugin
    written in Rust that is compiled and loaded by the compiler to produce arbitrary
    Rust code as its output.
  prefs: []
  type: TYPE_NORMAL
- en: 'A procedural macro can therefore be thought of as a code generator but one
    that forms part of the actual compiler. Procedural macros can be particularly
    useful for:'
  prefs: []
  type: TYPE_NORMAL
- en: Serialization / deserialization (e.g. the [serde](https://github.com/serde-rs/serde)
    module generates code for reading and writing structs to a variety of formats
    - JSON, YAML, TOML, XML etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain Specific Languages (e.g. embedded SQL, regular expressions etc).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aspect oriented programming (e.g. extra debugging, performance metrics etc)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New lint and derive rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information look at this section on [compiler plugins](https://doc.rust-lang.org/book/compiler-plugins.html)
    in the Rust book.
  prefs: []
  type: TYPE_NORMAL
- en: Other forms of conditional compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw that the C / C++ preprocessor can be used for conditional compilation.
    The equivalent in Rust is attributes. See the attributes section to see how they
    may be used.
  prefs: []
  type: TYPE_NORMAL
- en: Memory Allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is concerned with memory allocation, i.e. creating objects that
    reside on the heap and not on the stack, and the manner in which they are created
    and are destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C and C++ have various standard ways to allocate memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`malloc`/`calloc`/`realloc()` and `free()` functions'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`new` and `delete` (C++ only)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`new[]` and `delete[]` for arrays (C++ only)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoking `malloc()`/`free()` on a C++ class or struct is never a good idea since
    it will not call the corresponding class constructor or destructor. The `realloc()`
    function allocates a new piece of memory, copying the contents of an existing
    piece of memory before freeing the original.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'In each case the allocation must be matched by the corresponding free action
    so immediately we can see scope for error here:'
  prefs: []
  type: TYPE_NORMAL
- en: Ownership rules can get messy, especially when a class is passed around a lot
    - who deletes the object and when?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Not using the correct `new` & `delete` pair, causing a memory leak. e.g. calling
    `delete` instead of `delete[]`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Forgetting to free memory at all causing a memory leak.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Freeing memory more than once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling a dangling pointer, i.e. a pointer which refers to freed memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allocating / freeing in a way that causes heap fragmentation. Reallocation can
    cause fragmentation to happen a lot faster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'C++ has smart pointers which manage the lifetime on objects and are a good
    way to programmer error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately it is not always possible to use smart pointers but wherever possible
    they should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Other ways of allocating memory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Virtually every C and C++ library has solutions for managing memory. They all
    their own indivual concept of ownership which is usually different from one to
    the next. Boost and Qt have their own memory management "smart" pointers. Qt even
    requires certain objects to be deleted "later" by a message processing loop on
    the thread that created the object. Some libraries even adopt a COM-like model
    of reference counting objects with smart pointers. Most C libraries will expose
    an alloc and free function for creating and destroying context objects that callers
    pass to the API.
  prefs: []
  type: TYPE_NORMAL
- en: Memory allocation can even be overwritten and replaced in some circumstances.
    In C, the standard malloc / free can be substituted for another memory allocator,
    e.g. TCMalloc [TCMalloc](http://goog-perftools.sourceforge.net/doc/tcmalloc.html).
    Or perhaps the code wants to use garbage collected memory in which case [Bohem
    GC](http://www.hboehm.info/gc/) is a popular library for that purpose. Boehm can
    also be used for leak detection since it can find objects which were never released.
    C++ can also [override](http://en.cppreference.com/w/cpp/memory/new/operator_new)
    the global or class specific new / delete operators. Some standard C++ template
    classes also allow memory allocation to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: Rust
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can guess by now Rust tends to be a lot more strict about allocation
    that C/C++. Lifetimes of objects are tracked and enforced by the compiler and
    that includes memory allocated objects.
  prefs: []
  type: TYPE_NORMAL
- en: In normal safe programming there is no explicit new / delete so there is no
    way to forget to free an object. There are no pointers either so code cannot call
    a dangling pointer or inadvertently call a null pointer.
  prefs: []
  type: TYPE_NORMAL
- en: A `Box` is a managed pointer that holds a heap allocated object. A box cannot
    be cloned, so there is only one owner at any time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `Cell` is a mutable memory location - it can hold any kind of copyable type
    and the value within it can be changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `RefCell` is a mutable memory location that can hold a reference
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The advantage for programmers, is that once you define the lifetime of an object
    properly it just comes into existence and goes away correctly. In many cases this
    lifetime management comes with zero runtime cost, or if there is a cost it is
    no more than the same code correctly written in C/C++.
  prefs: []
  type: TYPE_NORMAL
- en: Rust requires most heap allocated memory to be contained by one or more of the
    structs below. The struct manages the lifetime and access to the object inside
    ensuring the lifetime is managed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Box
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Box` is memory managed on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: Whoever owns the box can access it. Essentially, that means you can pass the
    box around from one place to another and whatever binds to it last can open it.
    Everyone elses binding becomes invalid and will generate a compile error.
  prefs: []
  type: TYPE_NORMAL
- en: A box can be useful for abstraction since it can refer to a struct by a trait
    it implements allowing decoupling between types.
  prefs: []
  type: TYPE_NORMAL
- en: TODO example of a struct holding a box with a trait implemented by another struct
  prefs: []
  type: TYPE_NORMAL
- en: It can be useful for situations where one piece of code creates an object on
    behalf of another piece of code and hands it over. The Box makes sure that the
    ownership is explicit at all times and when the box moves to its new owner, so
    does the lifetime of the object itself.
  prefs: []
  type: TYPE_NORMAL
- en: Cell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Cell` is something that can copied with a `get()` or `set()` to overwrite
    its own copy. As the contents must be copyable they must implement the Copy trait.
  prefs: []
  type: TYPE_NORMAL
- en: The `Cell` has a zero-cost at runtime because it doesnt have to track borrows
    but the restriction is it only works on Copy types. Therefore it would not be
    suitable for large objects or deep-copy objects.
  prefs: []
  type: TYPE_NORMAL
- en: RefCell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Somewhat more useful is the `RefCell<T>` but it incurs a runtime penalty to
    maintain read-write locks.
  prefs: []
  type: TYPE_NORMAL
- en: The `RefCell` holds a reference to an object that can be borrowed either mutably
    or immutably. These references are read-write locked so there is a runtime cost
    to this since the borrow must check if something else has already borrowed the
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: Typically a piece of code might borrow the reference for a scope and then the
    borrow disappears when it goes out of scope. If a borrow happens before the last
    borrow releases, it will cause a panic.
  prefs: []
  type: TYPE_NORMAL
- en: Reference Counting objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust implements `Rc<>` and `Arc<>` for the purpose of reference counting objects
    that need to be shared and used by different parts of code. Rc<> is a single threaded
    reference counted wrapper, while `Arc<>` is atomic reference counted wrapper.
    You use one or the other depending on whether threads are sharing the object.
  prefs: []
  type: TYPE_NORMAL
- en: A reference counted object is usually wrapping a `Box`, `Cell` or `Refcell`.
    So multiple structs can hold a reference to the same object.
  prefs: []
  type: TYPE_NORMAL
- en: Rc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From `std::rc::Rc`. A reference counted object can be held by multiple owners
    at a time. Each own holds a cloned `Rc<T>` but the T contents are shared. The
    last reference to the object causes the contents to be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Arc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From `std::sync::Arc`. An atomic reference counted object that works like `Rc<T>`
    except it uses an atomically incremented counter which makes it thread safe. There
    is more overhead to maintain an atomic reference count. If multiple threads access
    the same object they are compelled to use `Arc<T>`
  prefs: []
  type: TYPE_NORMAL
- en: Foreign Function Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Foreign Function Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust doesn't work in a vaccum and was never intended as such. Instead it was
    always assumed that it would need to call other code and other code would need
    to call it,
  prefs: []
  type: TYPE_NORMAL
- en: Call other libraries via their entry points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Produce libraries in Rust that can be called by code written in another language.
    e.g. C, C++, Python, Ruby etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To that end it has the Foreign Function Interface, the means to define external
    functions, expose its own functions without name mangling and to invoke unsafe
    code that would otherwise be illegal in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Calling out to C libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust supports the concept of a foreign function interface which is a definition
    of an external function or type that is resolved at link time.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we might wish to link to a library called foo.lib, and invoke a
    command foo_command().
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'To call this function we have to turn off safety checks first because we are
    stepping out of the bounds of Rust''s lifetime enforcement. To do this we wrap
    the call in an unsafe block to disable the safety checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: Note how we can use unsafe features like pointers inside of this unsafe block.
    This allows interaction with the outside world while still enforcing safety for
    the rest of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Making Rust code callable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The converse is also possible. We can produce a library from Rust that can be
    invoked by some other code.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine we have some code written in Python. The code works fine
    but it is not performant and the bottle neck is in just one portion of the code,
    e.g. some file operation like a checksum. We want our code to consist of a make_checksum()
    and a release_checksum().
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in Python we can invoke the library simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: The [FFI specification](https://doc.rust-lang.org/book/ffi.html) goes into a
    lot more detail than this and explains concepts such as callbacks, structure packing,
    stdcall, linking and other issues that allow full interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: libc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust maintains a crate called [libc](https://github.com/rust-lang/libc) which
    holds types and functions corresponding to C.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dependency to libc would be added to the `Cargo.toml` of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'And the file that uses the functions would contain a preamble such as this
    saying what types and functions it calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: Other libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also crates that have the definitions of structures, types and functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[WinAPI](https://github.com/retep998/winapi-rs) bindings for Win32 programming
    APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OpenSSL](https://github.com/sfackler/rust-openssl) bindings for OpenSSL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
