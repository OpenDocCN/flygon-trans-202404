["```\n\n```", "```\n\n# The Simply Typed Lambda-Calculus\n\n    The simply typed lambda-calculus (STLC) is a tiny core\n    calculus embodying the key concept of *functional abstraction*,\n    which shows up in pretty much every real-world programming\n    language in some form (functions, procedures, methods, etc.).\n\n    We will follow exactly the same pattern as in the previous chapter\n    when formalizing this calculus (syntax, small-step semantics,\n    typing rules) and its main properties (progress and preservation).\n    The new technical challenges arise from the mechanisms of\n    *variable binding* and *substitution*.  It which will take some\n    work to deal with these.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t\u00a0::=\u00a0x\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0variable\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\\x:T[1].t2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0abstraction\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0t[1]\u00a0t[2]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0application\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0true\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0constant\u00a0true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0false\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0constant\u00a0false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0if\u00a0t[1]\u00a0then\u00a0t[2]\u00a0else\u00a0t[3]\u00a0\u00a0\u00a0conditional\n\n    The \\ symbol in a function abstraction \\x:T[1].t2 is generally\n    written as a Greek letter \"lambda\" (hence the name of the\n    calculus).  The variable x is called the *parameter* to the\n    function; the term t[2] is its *body*.  The annotation :T[1]\n    specifies the type of arguments that the function can be applied\n    to. \n\n    Some examples:\n\n*   \\x:Bool. x \n\n     The identity function for booleans. \n\n*   (\u03bbx:Bool. x) true \n\n     The identity function for booleans, applied to the boolean true. \n\n*   \\x:Bool. if x then false else true \n\n     The boolean \"not\" function. \n\n*   \\x:Bool. true \n\n     The constant function that takes every (boolean) argument to true.\n\n*   \\x:Bool. \\y:Bool. x \n\n     A two-argument function that takes two booleans and returns the first one. (As in Coq, a two-argument function is really a one-argument function whose body is also a one-argument function.) \n\n*   (\u03bbx:Bool. \\y:Bool. x) false true \n\n     A two-argument function that takes two booleans and returns the first one, applied to the booleans false and true. \n\n     As in Coq, application associates to the left \u2014 i.e., this expression is parsed as ((\u03bbx:Bool. \\y:Bool. x) false) true. \n\n*   \\f:Bool\u2192Bool. f (f true) \n\n     A higher-order function that takes a *function* f (from booleans to booleans) as an argument, applies f to true, and applies f again to the result. \n\n*   (\u03bbf:Bool\u2192Bool. f (f true)) (\u03bbx:Bool. false) \n\n     The same higher-order function, applied to the constantly false function.\n\n    As the last several examples show, the STLC is a language of\n    *higher-order* functions: we can write down functions that take\n    other functions as arguments and/or return other functions as\n    results.\n\n    The STLC doesn't provide any primitive syntax for defining *named*\n    functions \u2014 all functions are \"anonymous.\"  We'll see in chapter\n    MoreStlc that it is easy to add named functions to what we've\n    got \u2014 indeed, the fundamental naming and binding mechanisms are\n    exactly the same.\n\n    The *types* of the STLC include Bool, which classifies the\n    boolean constants true and false as well as more complex\n    computations that yield booleans, plus *arrow types* that classify\n    functions. \n\n```", "```\n\n## Syntax\n\n    We next formalize the syntax of the STLC.\n\n```", "```\n\n### Types\n\n```", "```\n\n### Terms\n\n```", "```\n\n    Note that an abstraction \\x:T.t (formally, tabs x T t) is\n    always annotated with the type T of its parameter, in contrast\n    to Coq (and other functional languages like ML, Haskell, etc.),\n    which use type inference to fill in missing annotations.  We're\n    not considering type inference here. \n\n    Some examples...\n\n```", "```\n\n    idB = \\x:Bool. x\n\n```", "```\n\n    idBB = \\x:Bool\u2192Bool. x\n\n```", "```\n\n    idBBBB = \\x:(Bool\u2192Bool) \u2192 (Bool\u2192Bool). x\n\n```", "```\n\n    k = \\x:Bool. \\y:Bool. x\n\n```", "```\n\n    notB = \\x:Bool. if x then false else true\n\n```", "```\n\n    (We write these as Notations rather than Definitions to make\n    things easier for auto.)\n\n```", "```\n\n### Values\n\n    To define the values of the STLC, we have a few cases to consider.\n\n    First, for the boolean part of the language, the situation is\n    clear: true and false are the only values.  An if\n    expression is never a value. \n\n    Second, an application is clearly not a value: It represents a\n    function being invoked on some argument, which clearly still has\n    work left to do. \n\n    Third, for abstractions, we have a choice:\n\n*   We can say that \\x:T. t[1] is a value only when t[1] is a value \u2014 i.e., only if the function's body has been reduced (as much as it can be without knowing what argument it is going to be applied to). \n\n*   Or we can say that \\x:T. t[1] is always a value, no matter whether t[1] is one or not \u2014 in other words, we can say that reduction stops at abstractions.\n\n    Our usual way of evaluating expressions in Coq makes the first\n    choice \u2014 for example,\n\n```", "```\nInductive value : tm \u2192 Prop :=\n\u00a0\u00a0| v_abs : \u2200x T t,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value (tabs x T t)\n\u00a0\u00a0| v_true :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value ttrue\n\u00a0\u00a0| v_false :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value tfalse.\n\nHint Constructors value.\n\n```", "```\n\n### Substitution\n\n    Now we come to the heart of the STLC: the operation of\n    substituting one term for a variable in another term.  This\n    operation is used below to define the operational semantics of\n    function application, where we will need to substitute the\n    argument term for the function parameter in the function's body.\n    For example, we reduce\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if\u00a0false\u00a0then\u00a0true\u00a0else\u00a0false\n\n    by substituting false for the parameter x in the body of the\n    function.\n\n    In general, we need to be able to substitute some given term s\n    for occurrences of some variable x in another term t.  In\n    informal discussions, this is usually written [x:=s]t and\n    pronounced \"substitute x with s in t.\" \n\n    Here are some examples:\n\n*   [x:=true] (if x then x else false) yields if true then true else false \n\n*   [x:=true] x yields true \n\n*   [x:=true] (if x then x else y) yields if true then true else y \n\n*   [x:=true] y yields y \n\n*   [x:=true] false yields false (vacuous substitution) \n\n*   [x:=true] (\u03bby:Bool. if y then x else false) yields \\y:Bool. if y then true else false \n\n*   [x:=true] (\u03bby:Bool. x) yields \\y:Bool. true \n\n*   [x:=true] (\u03bby:Bool. y) yields \\y:Bool. y \n\n*   [x:=true] (\u03bbx:Bool. x) yields \\x:Bool. x\n\n    The last example is very important: substituting x with true in\n    \\x:Bool. x does *not* yield \\x:Bool. true!  The reason for\n    this is that the x in the body of \\x:Bool. x is *bound* by the\n    abstraction: it is a new, local name that just happens to be\n    spelled the same as some global name x. \n\n    Here is the definition, informally...\n\n```", "```\nReserved Notation \"'[' x ':=' s ']' t\" (at level 20).\n\nFixpoint subst (x:id) (s:tm) (t:tm) : tm :=\n\u00a0\u00a0match t with\n\u00a0\u00a0| tvar x' \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if beq_id x x' then s else t\n\u00a0\u00a0| tabs x' T t[1] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tabs x' T (if beq_id x x' then t[1] else ([x:=s] t[1]))\n\u00a0\u00a0| tapp t[1] t[2] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tapp ([x:=s] t[1]) ([x:=s] t[2])\n\u00a0\u00a0| ttrue \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ttrue\n\u00a0\u00a0| tfalse \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tfalse\n\u00a0\u00a0| tif t[1] t[2] t[3] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tif ([x:=s] t[1]) ([x:=s] t[2]) ([x:=s] t[3])\n\u00a0\u00a0end\n\nwhere \"'[' x ':=' s ']' t\" := (subst x s t).\n\n```", "```\nInductive substi (s:tm) (x:id) : tm \u2192 tm \u2192 Prop :=\n\u00a0\u00a0| s_var1 :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0substi s x (tvar x) s\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n.\n\nHint Constructors substi.\n\nTheorem substi_correct : \u2200s x t t',\n\u00a0\u00a0[x:=s]t = t' \u2194 substi s x t t'.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n### Reduction\n\n    The small-step reduction relation for STLC now follows the\n    same pattern as the ones we have seen before.  Intuitively, to\n    reduce a function application, we first reduce its left-hand\n    side (the function) until it becomes an abstraction; then we\n    reduce its right-hand side (the argument) until it is also a\n    value; and finally we substitute the argument for the bound\n    variable in the body of the abstraction.  This last rule, written\n    informally as\n\n```", "```\nReserved Notation \"t1 '\u21d2' t2\" (at level 40).\n\nInductive step : tm \u2192 tm \u2192 Prop :=\n\u00a0\u00a0| ST_AppAbs : \u2200x T t[12] v[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tapp (tabs x T t[12]) v[2]) \u21d2 [x:=v[2]]t[12]\n\u00a0\u00a0| ST_App1 : \u2200t[1] t[1]' t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tapp t[1] t[2] \u21d2 tapp t[1]' t[2]\n\u00a0\u00a0| ST_App2 : \u2200v[1] t[2] t[2]',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[2] \u21d2 t[2]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tapp v[1] t[2] \u21d2 tapp v[1]  t[2]'\n\u00a0\u00a0| ST_IfTrue : \u2200t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tif ttrue t[1] t[2]) \u21d2 t[1]\n\u00a0\u00a0| ST_IfFalse : \u2200t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tif tfalse t[1] t[2]) \u21d2 t[2]\n\u00a0\u00a0| ST_If : \u2200t[1] t[1]' t[2] t[3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tif t[1] t[2] t[3]) \u21d2 (tif t[1]' t[2] t[3])\n\nwhere \"t1 '\u21d2' t2\" := (step t[1] t[2]).\n\nHint Constructors step.\n\nNotation multistep := (multi step).\nNotation \"t1 '\u21d2*' t2\" := (multistep t[1] t[2]) (at level 40).\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u03bbx:Bool\u2192Bool. x)\u00a0(\u03bbx:Bool. x)\u00a0\u21d2*\u00a0\\x:Bool. x\n\n    i.e.,\n\n```", "```\nLemma step_example1 :\n\u00a0\u00a0(tapp idBB idB) \u21d2* idB.\nProof.\n\u00a0\u00a0eapply multi_step.\n\u00a0\u00a0\u00a0\u00a0apply ST_AppAbs.\n\u00a0\u00a0\u00a0\u00a0apply v_abs.\n\u00a0\u00a0simpl.\n\u00a0\u00a0apply multi_refl. Qed.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u03bbx:Bool\u2192Bool. x)\u00a0((\u03bbx:Bool\u2192Bool. x)\u00a0(\u03bbx:Bool. x))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u21d2*\u00a0\\x:Bool. x\n\n    i.e.,\n\n```", "```\nLemma step_example2 :\n\u00a0\u00a0(tapp idBB (tapp idBB idB)) \u21d2* idB.\nProof.\n\u00a0\u00a0eapply multi_step.\n\u00a0\u00a0\u00a0\u00a0apply ST_App2. auto.\n\u00a0\u00a0\u00a0\u00a0apply ST_AppAbs. auto.\n\u00a0\u00a0eapply multi_step.\n\u00a0\u00a0\u00a0\u00a0apply ST_AppAbs. simpl. auto.\n\u00a0\u00a0simpl. apply multi_refl. Qed.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u03bbx:Bool\u2192Bool. x)\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u03bbx:Bool. if\u00a0x\u00a0then\u00a0false\u00a0else\u00a0true)\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u21d2*\u00a0false\n\n    i.e.,\n\n```", "```\nLemma step_example3 :\n\u00a0\u00a0tapp (tapp idBB notB) ttrue \u21d2* tfalse.\nProof.\n\u00a0\u00a0eapply multi_step.\n\u00a0\u00a0\u00a0\u00a0apply ST_App1. apply ST_AppAbs. auto. simpl.\n\u00a0\u00a0eapply multi_step.\n\u00a0\u00a0\u00a0\u00a0apply ST_AppAbs. auto. simpl.\n\u00a0\u00a0eapply multi_step.\n\u00a0\u00a0\u00a0\u00a0apply ST_IfTrue. apply multi_refl. Qed.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u03bbx:Bool\u00a0\u2192\u00a0Bool. x)\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0((\u03bbx:Bool. if\u00a0x\u00a0then\u00a0false\u00a0else\u00a0true)\u00a0true)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u21d2*\u00a0false\n\n    i.e.,\n\n```", "```\nLemma step_example4 :\n\u00a0\u00a0tapp idBB (tapp notB ttrue) \u21d2* tfalse.\nProof.\n\u00a0\u00a0eapply multi_step.\n\u00a0\u00a0\u00a0\u00a0apply ST_App2. auto.\n\u00a0\u00a0\u00a0\u00a0apply ST_AppAbs. auto. simpl.\n\u00a0\u00a0eapply multi_step.\n\u00a0\u00a0\u00a0\u00a0apply ST_App2. auto.\n\u00a0\u00a0\u00a0\u00a0apply ST_IfTrue.\n\u00a0\u00a0eapply multi_step.\n\u00a0\u00a0\u00a0\u00a0apply ST_AppAbs. auto. simpl.\n\u00a0\u00a0apply multi_refl. Qed.\n\n```", "```\nLemma step_example1' :\n\u00a0\u00a0(tapp idBB idB) \u21d2* idB.\nProof. normalize. Qed.\n\nLemma step_example2' :\n\u00a0\u00a0(tapp idBB (tapp idBB idB)) \u21d2* idB.\nProof. normalize. Qed.\n\nLemma step_example3' :\n\u00a0\u00a0tapp (tapp idBB notB) ttrue \u21d2* tfalse.\nProof. normalize. Qed.\n\nLemma step_example4' :\n\u00a0\u00a0tapp idBB (tapp notB ttrue) \u21d2* tfalse.\nProof. normalize. Qed.\n\n```", "```\nLemma step_example5 :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tapp (tapp idBBBB idBB) idB\n\u00a0\u00a0\u21d2* idB.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nLemma step_example5_with_normalize :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tapp (tapp idBBBB idBB) idB\n\u00a0\u00a0\u21d2* idB.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n## Typing\n\n    Next we consider the typing relation of the STLC.\n\n```", "```\nDefinition context := partial_map ty.\n\n```", "```\nReserved Notation \"Gamma '\u22a2' t '\u2208' T\" (at level 40).\n\nInductive has_type : context \u2192 tm \u2192 ty \u2192 Prop :=\n\u00a0\u00a0| T_Var : \u2200\u0393 x T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 x = Some T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 tvar x \u2208 T\n\u00a0\u00a0| T_Abs : \u2200\u0393 x T[11] T[12] t[12],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0update \u0393 x T[11] \u22a2 t[12] \u2208 T[12] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 tabs x T[11] t[12] \u2208 TArrow T[11] T[12]\n\u00a0\u00a0| T_App : \u2200T[11] T[12] \u0393 t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[1] \u2208 TArrow T[11] T[12] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[2] \u2208 T[11] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 tapp t[1] t[2] \u2208 T[12]\n\u00a0\u00a0| T_True : \u2200\u0393,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 ttrue \u2208 TBool\n\u00a0\u00a0| T_False : \u2200\u0393,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 tfalse \u2208 TBool\n\u00a0\u00a0| T_If : \u2200t[1] t[2] t[3] T \u0393,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[1] \u2208 TBool \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[2] \u2208 T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[3] \u2208 T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 tif t[1] t[2] t[3] \u2208 T\n\nwhere \"Gamma '\u22a2' t '\u2208' T\" := (has_type \u0393 t T).\n\nHint Constructors has_type.\n\n```", "```\nExample typing_example_1 :\n\u00a0\u00a0empty \u22a2 tabs x TBool (tvar x) \u2208 TArrow TBool TBool.\nProof.\n\u00a0\u00a0apply T_Abs. apply T_Var. reflexivity. Qed.\n\n```", "```\nExample typing_example_1' :\n\u00a0\u00a0empty \u22a2 tabs x TBool (tvar x) \u2208 TArrow TBool TBool.\nProof. auto. Qed.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0empty\u00a0\u22a2\u00a0\\x:A. \u03bby:A\u2192A. y\u00a0(y\u00a0x))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2208\u00a0A\u00a0\u2192\u00a0(A\u2192A)\u00a0\u2192\u00a0A.\n\n```", "```\n\n#### Exercise: 2 stars, optional (typing_example_2_full)\n\n    Prove the same result without using auto, eauto, or\n    eapply (or ...).\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 stars (typing_example_3)\n\n    Formally prove the following typing derivation holds:  \n\n```", "```\nExample typing_example_3 :\n\u00a0\u00a0\u2203T,\n\u00a0\u00a0\u00a0\u00a0empty \u22a2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tabs x (TArrow TBool TBool)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tabs y (TArrow TBool TBool)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tabs z TBool\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tapp (tvar y) (tapp (tvar x) (tvar z)))))) \u2208\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0T.\nProof with auto.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00ac\u00a0\u2203T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0empty\u00a0\u22a2\u00a0\\x:Bool. \u03bby:Bool,\u00a0x\u00a0y\u00a0:\u00a0T.\n\n```", "```\n\n#### Exercise: 3 stars, optional (typing_nonexample_3)\n\n    Another nonexample:\n\n```", "```\nExample typing_nonexample_3 :\n\u00a0\u00a0\u00ac (\u2203S, \u2203T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0empty \u22a2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tabs x S\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tapp (tvar x) (tvar x))) \u2208\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0T).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nEnd STLC.\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "``` \n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]