- en: More EncodingsTuesday, February 21st
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our choice of encoding numbers makes sense — the idea is that the main feature
    of a natural number is repeating something a number of times. For booleans, the
    main property we’re looking for is choosing between two values. So we can encode
    true and false by functions of two arguments that return either the first or the
    second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this encoding of `#f` is really the same as the encoding of `0`,
    so we have to know what type to expect an use the proper operations (this is similar
    to C, where everything is just integers). Now that we have these two, we can define
    `if`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'it expects a boolean which is a function of two arguments, and passes it the
    two expressions. The `#t` boolean will simply return the first, and the `#f` boolean
    will return the second. Strictly speaking, we don’t really need this definition,
    since instead of writing `(if c t e)`, we can simply write `(c t e)`. In any case,
    we need the language to be lazy for this to work. To demonstrate this, we’ll intentionally
    use the quote back-door to use a non-functional value, using this will normally
    result in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But testing our `if` definition, things work just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'and we see that DrRacket leaves the second addition expression in red, which
    indicates that it was not executed. We can also make sure that even when it is
    defined as a function, it is still working fine because the language is lazy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'How about `and` and `or`? Simple, `or` takes two arguments, and returns either
    true or false if one of the inputs is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'but `(if b #t #f)` is really the same as just `b` because it’s a boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'also, if `a` is true, we want to return `#t`, but that is exactly the value
    of `a`, so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'and finally, we can get rid of the `if` (which is actually breaking the `if`
    abstraction, if we encode booleans in some other way):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, convince yourself that the definition of `and` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Schlac has to-Racket conversion forms for booleans too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A `not` function is quite simple — one alternative is to choose from true and
    false in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'and another is to return a function that switches the inputs to an input boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: which is the same as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now put numbers and booleans together: we define a `zero?` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '(Good question: is this fast?)'
  prefs: []
  type: TYPE_NORMAL
- en: (Note that it is better to test that the value is explicitly `#t`, if we just
    use `(test (->bool ...))` then the test will work even if the expression in question
    evaluated to some bogus value.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is simple — if `n` is the encoding of zero, it will return it’s second
    argument which is `#t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'if `n` is an encoding of a bigger number, then it is a self-composition, and
    the function that we give it is one that always returns `#f`, no matter how many
    times it is self-composed. Try `2` for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, how about an encoding for compound values? A minimal approach is what
    we use in Racket — a way to generate pairs (`cons`), and encode lists as chains
    of pairs with a special value at the end (`null`). There is a natural encoding
    for pairs that we have previously seen — a pair is a function that expects a selector,
    and will apply that on the two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, equivalently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract the two values from a pair, we need to pass a selector that consumes
    two values and returns one of them. In our framework, this is exactly what the
    two boolean values do, so we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'or write a `list-ref` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we don’t need a recursive function for this: our encoding of natural
    numbers makes it easy to “iterate N times”. What we get with this encoding is
    essentially free natural-number recursion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need a special `null` value to mark list ends. This value should have
    the same number of arguments as a `cons` value (one: a selector/boolean function),
    and it should be possible to distinguish it from other values. We choose'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing the list encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And as with natural numbers and booleans, Schlac has built-in facility to convert
    encoded lists to Racket values, except that this requires specifying the type
    of values in a list so it’s a higher-order function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: which (“as usual”) can be written as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Defining `null?` is now relatively easy (and it’s actually already used by the
    above `->listof` conversion). The following definition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'works because if `x` is null, then it simply ignores its argument and returns
    `#t`, and if it’s a pair, then it uses the input selector, which always returns
    `#f` in its turn. Using some arbitrary `A` and `B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the Y combinator to create recursive functions — we can even use
    the rewrite rules facility that Schlac contains (the same one that we have previously
    seen):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'and using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And to complete this, um, journey — we’re still missing subtraction. There
    are many ways to solve the problem of subtraction, and for a challenge try to
    come up with a solution yourself. One of the clearer solutions uses a simple idea
    — begin with a pair of two zeroes `<0,0>`, and repeat this transformation `n`
    times: `<a,b>` -> `<b,b+1>`. After `n` steps, we will have `<n-1,n>` — so we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And from this the road is short to general subtraction, `m`-`n` is simply `n`
    applications of `sub1` on `m`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a normal-looking language, and we’re ready to do anything we want.
    Here are two popular examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To get generalized arithmetic capability, Schlac has yet another built-in facility
    for translating Racket natural numbers into Church numerals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: … and to get to that frightening expression in the beginning, all you need to
    do is replace all definitions in the `fib` definition over and over again until
    you’re left with nothing but lambda expressions and applications, then reformat
    the result into some cute shape. For extra fun, you can look for immediate applications
    of lambda expressions and reduce them manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this is in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
