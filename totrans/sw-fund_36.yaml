- en: PEPartial Evaluation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: (* Chapter written and maintained by Chung-chieh Shan *)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: X ::= ANum 3;; Y ::= APlus (AId X) (ANum 1)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: to
  id: totrans-5
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: X ::= ANum 3;; Y ::= AMinus (APlus (AId X) (ANum 1)) (AId Y)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: to
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Require Import Coq.Bool.Bool.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Arith.Arith.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Arith.EqNat.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.omega.Omega.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Logic.FunctionalExtensionality.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Lists.List.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Import ListNotations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Maps.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Imp.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Smallstep.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Definition pe_state := list (id * nat).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Fixpoint pe_lookup (pe_st : pe_state) (V:id) : option nat :='
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: match pe_st with
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '| [] ⇒ None'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '| (V'',n'')::pe_st ⇒ if beq_id V V'' then Some n'''
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: else pe_lookup pe_st V
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Definition empty_pe_state : pe_state := [].'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: compare V V'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: means to reason by cases over beq_id V V'.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the case where V = V', the tactic
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: substitutes V for V' throughout.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In what follows, we will make heavy use of the In property from
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the standard library, also defined in Logic.v:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Besides the various lemmas about In that we've already come
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: across, the following one (taken from the standard library) will
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'also be useful:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If a type A has an operator beq for testing equality of its
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: elements, we can compute a boolean inb beq a l for testing
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: whether In a l holds or not.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It is easy to relate inb to In with the reflect property:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Arithmetic Expressions
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Partial evaluation of aexp is straightforward — it is basically
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the same as constant folding, fold_constants_aexp, except that
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sometimes the partial state tells us the current value of a
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variable and we can replace it by a constant expression.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This partial evaluator folds constants but does not apply the
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: associativity of addition.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, in what sense is pe_aexp correct?  It is reasonable to
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'define the correctness of pe_aexp as follows: whenever a full'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: state st:state is *consistent* with a partial state
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pe_st:pe_state (in other words, every variable to which pe_st
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assigns a value is assigned the same value by st), evaluating
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a and evaluating pe_aexp pe_st a in st yields the same
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: result.  This statement is indeed true.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, we will soon want our partial evaluator to remove
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assignments.  For example, it will simplify
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Y ::= AMinus (ANum 3) (AId Y);; X ::= ANum 4
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: by delaying the assignment to X until the end.  To accomplish
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this simplification, we need the result of partial evaluating
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: X ::= ANum 3;; Y ::= AMinus (AId X) (AId Y);; X ::= ANum 4
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: to
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Fixpoint pe_update (st:state) (pe_st:pe_state) : state :='
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: match pe_st with
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '| [] ⇒ st'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '| (V,n)::pe_st ⇒ t_update (pe_update st pe_st) V n'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_pe_update:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: pe_update (t_update empty_state Y 1) [(X,3);(Z,2)]
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: = t_update (t_update (t_update empty_state Y 1) Z 2) X 3.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Theorem pe_update_correct: ∀st pe_st V[0],'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: pe_update st pe_st V[0] =
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: match pe_lookup pe_st V[0] with
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '| Some n ⇒ n'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '| None ⇒ st V[0]'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros. induction pe_st as [| [V n] pe_st]. reflexivity.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: simpl in *. unfold t_update.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: compare V[0] V; auto. rewrite ← beq_id_refl; auto. rewrite false_beq_id; auto.
    Qed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 比较 V[0] V;自动。重写 ← beq_id_refl;自动。重写 false_beq_id;自动。Qed。
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Theorem pe_update_consistent: ∀st pe_st,'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 pe_update_consistent: ∀st pe_st，'
- en: pe_consistent (pe_update st pe_st) pe_st.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: pe_consistent (pe_update st pe_st) pe_st。
- en: Proof. intros st pe_st V n H. rewrite pe_update_correct.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。引入 st pe_st V n H。重写 pe_update_correct。
- en: destruct (pe_lookup pe_st V); inversion H. reflexivity. Qed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 破坏（pe_lookup pe_st V）;反演 H。一致性。Qed。
- en: 'Theorem pe_consistent_update: ∀st pe_st,'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 pe_consistent_update: ∀st pe_st，'
- en: pe_consistent st pe_st → ∀V, st V = pe_update st pe_st V.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: pe_consistent st pe_st → ∀V, st V = pe_update st pe_st V。
- en: Proof. intros st pe_st H V. rewrite pe_update_correct.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。引入 st pe_st H V。重写 pe_update_correct。
- en: remember (pe_lookup pe_st V) as l. destruct l; auto. Qed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 记住（pe_lookup pe_st V）作为 l。破坏 l;自动。Qed。
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Theorem pe_aexp_correct: ∀(pe_st:pe_state) (a:aexp) (st:state),'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 pe_aexp_correct: ∀(pe_st:pe_state) (a:aexp) (st:state),'
- en: aeval (pe_update st pe_st) a = aeval st (pe_aexp pe_st a).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: aeval（pe_update st pe_st）a = aeval st（pe_aexp pe_st a）。
- en: Proof.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros pe_st a st.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 pe_st a st。
- en: induction a; simpl;
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 a;简化;
- en: try reflexivity;
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一致性;
- en: try (destruct (pe_aexp pe_st a[1]);
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（破坏（pe_aexp pe_st a[1]）;
- en: destruct (pe_aexp pe_st a[2]);
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 破坏（pe_aexp pe_st a[2]）;
- en: rewrite IHa1; rewrite IHa2; reflexivity).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 IHa1;重写 IHa2;一致性）。
- en: (* Compared to fold_constants_aexp_sound, the only      interesting case is AId. *)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: （与 fold_constants_aexp_sound 相比，唯一有趣的情况是 AId。）
- en: rewrite pe_update_correct. destruct (pe_lookup pe_st i); reflexivity.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 pe_update_correct。破坏（pe_lookup pe_st i）;一致性。
- en: Qed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Fixpoint pe_bexp (pe_st : pe_state) (b : bexp) : bexp :='
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fixpoint pe_bexp (pe_st : pe_state) (b : bexp) : bexp :='
- en: match b with
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 b 与
- en: '| BTrue        ⇒ BTrue'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '| BTrue        ⇒ BTrue'
- en: '| BFalse       ⇒ BFalse'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '| BFalse       ⇒ BFalse'
- en: '| BEq a[1] a[2] ⇒'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '| BEq a[1] a[2] ⇒'
- en: match (pe_aexp pe_st a[1], pe_aexp pe_st a[2]) with
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配（pe_aexp pe_st a[1]，pe_aexp pe_st a[2]）与
- en: '| (ANum n[1], ANum n[2]) ⇒ if beq_nat n[1] n[2] then BTrue else BFalse'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '| (ANum n[1], ANum n[2]) ⇒ if beq_nat n[1] n[2] then BTrue else BFalse'
- en: '| (a[1]'', a[2]'') ⇒ BEq a[1]'' a[2]'''
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '| (a[1]'', a[2]'') ⇒ BEq a[1]'' a[2]'''
- en: end
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 结束
- en: '| BLe a[1] a[2] ⇒'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '| BLe a[1] a[2] ⇒'
- en: match (pe_aexp pe_st a[1], pe_aexp pe_st a[2]) with
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配（pe_aexp pe_st a[1]，pe_aexp pe_st a[2]）与
- en: '| (ANum n[1], ANum n[2]) ⇒ if leb n[1] n[2] then BTrue else BFalse'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '| (ANum n[1], ANum n[2]) ⇒ if leb n[1] n[2] then BTrue else BFalse'
- en: '| (a[1]'', a[2]'') ⇒ BLe a[1]'' a[2]'''
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '| (a[1]'', a[2]'') ⇒ BLe a[1]'' a[2]'''
- en: end
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 结束
- en: '| BNot b[1] ⇒'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '| BNot b[1] ⇒'
- en: match (pe_bexp pe_st b[1]) with
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配（pe_bexp pe_st b[1]）与
- en: '| BTrue ⇒ BFalse'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '| BTrue ⇒ BFalse'
- en: '| BFalse ⇒ BTrue'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '| BFalse ⇒ BTrue'
- en: '| b[1]'' ⇒ BNot b[1]'''
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '| b[1]'' ⇒ BNot b[1]'''
- en: end
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 结束
- en: '| BAnd b[1] b[2] ⇒'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '| BAnd b[1] b[2] ⇒'
- en: match (pe_bexp pe_st b[1], pe_bexp pe_st b[2]) with
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配（pe_bexp pe_st b[1]，pe_bexp pe_st b[2]）与
- en: '| (BTrue, BTrue) ⇒ BTrue'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '| (BTrue, BTrue) ⇒ BTrue'
- en: '| (BTrue, BFalse) ⇒ BFalse'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '| (BTrue, BFalse) ⇒ BFalse'
- en: '| (BFalse, BTrue) ⇒ BFalse'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '| (BFalse, BTrue) ⇒ BFalse'
- en: '| (BFalse, BFalse) ⇒ BFalse'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '| (BFalse, BFalse) ⇒ BFalse'
- en: '| (b[1]'', b[2]'') ⇒ BAnd b[1]'' b[2]'''
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '| (b[1]'', b[2]'') ⇒ BAnd b[1]'' b[2]'''
- en: end
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 结束
- en: end.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: 'Example test_pe_bexp1:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_pe_bexp1:'
- en: pe_bexp [(X,3)] (BNot (BLe (AId X) (ANum 3)))
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: pe_bexp [(X,3)] (BNot (BLe (AId X) (ANum 3)))
- en: = BFalse.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: = BFalse。
- en: Proof. reflexivity. Qed.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。一致性。Qed。
- en: 'Example test_pe_bexp2: ∀b,'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_pe_bexp2: ∀b，'
- en: b = BNot (BLe (AId X) (APlus (AId X) (ANum 1))) →
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: b = BNot (BLe (AId X) (APlus (AId X) (ANum 1))) →
- en: pe_bexp [] b = b.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: pe_bexp [] b = b。
- en: Proof. intros b H. rewrite → H. reflexivity. Qed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。引入 b H。重写 → H。一致性。Qed。
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Theorem pe_bexp_correct: ∀(pe_st:pe_state) (b:bexp) (st:state),'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 pe_bexp_correct: ∀(pe_st:pe_state) (b:bexp) (st:state),'
- en: beval (pe_update st pe_st) b = beval st (pe_bexp pe_st b).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: beval（pe_update st pe_st）b = beval st（pe_bexp pe_st b）。
- en: Proof.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros pe_st b st.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 pe_st b st。
- en: induction b; simpl;
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 b;简化;
- en: try reflexivity;
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一致性;
- en: try (remember (pe_aexp pe_st a) as a';
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（记住（pe_aexp pe_st a）作为 a';
- en: remember (pe_aexp pe_st a[0]) as a[0]';
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 记住（pe_aexp pe_st a[0]）作为 a[0]';
- en: 'assert (Ha: aeval (pe_update st pe_st) a = aeval st a'');'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 断言（Ha：aeval（pe_update st pe_st）a = aeval st a'）;
- en: 'assert (Ha[0]: aeval (pe_update st pe_st) a[0] = aeval st a[0]'');'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 断言（Ha[0]：aeval（pe_update st pe_st）a[0] = aeval st a[0]'）;
- en: try (subst; apply pe_aexp_correct);
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（替换;应用 pe_aexp_correct）;
- en: destruct a'; destruct a[0]'; rewrite Ha; rewrite Ha[0];
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 破坏 a';破坏 a[0]';重写 Ha;重写 Ha[0];
- en: simpl; try destruct (beq_nat n n[0]);
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 简化;尝试破坏（beq_nat n n[0]）;
- en: try destruct (leb n n[0]); reflexivity);
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试破坏（leb n n[0]）;一致性）;
- en: try (destruct (pe_bexp pe_st b); rewrite IHb; reflexivity);
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（破坏（pe_bexp pe_st b）;重写 IHb;一致性）;
- en: try (destruct (pe_bexp pe_st b[1]);
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（破坏（pe_bexp pe_st b[1]）;
- en: destruct (pe_bexp pe_st b[2]);
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 破坏（pe_bexp pe_st b[2]）;
- en: rewrite IHb1; rewrite IHb2; reflexivity).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 IHb1;重写 IHb2;一致性）。
- en: Qed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: c[1] / st ⇓ c[1]' / st'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / st ⇓ c[1]' / st'
- en: to mean that partially evaluating the source command c[1] in the
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 意味着部分地评估源命令 c[1] 在
- en: initial partial state st yields the residual command c[1]' and
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始部分状态 st 产生剩余命令 c[1]' 和
- en: the final partial state st'.  For example, we want something like
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终部分状态 st'。例如，我们想要类似于
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Fixpoint pe_remove (pe_st:pe_state) (V:id) : pe_state :='
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: match pe_st with
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '| [] ⇒ []'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '| (V'',n'')::pe_st ⇒ if beq_id V V'' then pe_remove pe_st V'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'else (V'',n'') :: pe_remove pe_st V'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_remove_correct: ∀pe_st V V[0],'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: pe_lookup (pe_remove pe_st V) V[0]
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: = if beq_id V V[0] then None else pe_lookup pe_st V[0].
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros pe_st V V[0]. induction pe_st as [| [V' n'] pe_st].
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '- (*  *) destruct ([beq_id](Maps.html#beq_id) V V[0]); reflexivity.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '- (* :: *) simpl. compare V V''.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: + (* equal *) rewrite IHpe_st.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) V V[0]). reflexivity.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [false_beq_id](Maps.html#false_beq_id); auto.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: + (* not equal *) simpl. compare V[0] V'.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '* (* equal *) rewrite [false_beq_id](Maps.html#false_beq_id); auto.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '* (* not equal *) rewrite IHpe_st. reflexivity.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition pe_add (pe_st:[pe_state](PE.html#pe_state)) (V:[id](Maps.html#id))
    (n:[nat](http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat)) : [pe_state](PE.html#pe_state)
    :='
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '([V](PE.html#V),[n](PE.html#n)) :: [pe_remove](PE.html#pe_remove) [pe_st](PE.html#pe_st)
    [V](PE.html#V).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_add_correct: ∀pe_st V n V[0],'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[pe_lookup](PE.html#pe_lookup) ([pe_add](PE.html#pe_add) [pe_st](PE.html#pe_st)
    [V](PE.html#V) [n](PE.html#n)) [V[0]](PE.html#V<sub>0</sub>)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: = if [beq_id](Maps.html#beq_id) [V](PE.html#V) [V[0]](PE.html#V<sub>0</sub>)
    then [Some](http://coq.inria.fr/library/Coq.Init.Datatypes.html#Some) [n](PE.html#n)
    else [pe_lookup](PE.html#pe_lookup) [pe_st](PE.html#pe_st) [V[0]](PE.html#V<sub>0</sub>).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros pe_st V n V[0]. unfold [pe_add](PE.html#pe_add). simpl.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: compare V V[0].
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '- (* equal *) rewrite ← [beq_id_refl](Maps.html#beq_id_refl); auto.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '- (* not equal *) rewrite [pe_remove_correct](PE.html#pe_remove_correct).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite [false_beq_id](Maps.html#false_beq_id); auto.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Theorem pe_update_update_remove: ∀st pe_st V n,'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: t_update (pe_update st pe_st) V n =
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: pe_update (t_update st V n) (pe_remove pe_st V).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros st pe_st V n. apply functional_extensionality.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: intros V[0]. unfold t_update. rewrite !pe_update_correct.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: rewrite pe_remove_correct. destruct (beq_id V V[0]); reflexivity.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_update_update_add: ∀st pe_st V n,'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: t_update (pe_update st pe_st) V n =
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: pe_update st (pe_add pe_st V n).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros st pe_st V n. apply functional_extensionality. intros V[0].
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: unfold t_update. rewrite !pe_update_correct. rewrite pe_add_correct.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: destruct (beq_id V V[0]); reflexivity. Qed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: X ::= ANum 3;;
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: IFB BLe (AId Y) (ANum 4) THEN
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= ANum 4;;
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: IFB BEq (AId X) (AId Y) THEN Y ::= ANum 999 ELSE SKIP FI
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: ELSE SKIP FI
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the initial partial state is empty.  We don't know
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: statically how Y compares to 4, so we must partially evaluate
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: both branches of the (outer) conditional.  On the THEN branch,
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we know that Y is set to 4 and can even use that knowledge to
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simplify the code somewhat.  On the ELSE branch, we still don't
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: know the exact value of Y at the end.  What should the final
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: partial state and residual program be?
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One way to handle such a dynamic conditional is to take the
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intersection of the final partial states of the two branches.  In
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this example, we take the intersection of (Y,4),(X,3) and
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (X,3), so the overall final partial state is (X,3).  To
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: compensate for forgetting that Y is 4, we need to add an
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assignment Y ::= ANum 4 to the end of the THEN branch.  So,
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the residual program will be something like
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Definition pe_disagree_at (pe_st[1] pe_st[2] : pe_state) (V:id) : bool :='
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: match pe_lookup pe_st[1] V, pe_lookup pe_st[2] V with
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '| Some x, Some y ⇒ negb (beq_nat x y)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '| None, None ⇒ false'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '| _, _ ⇒ true'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_disagree_domain: ∀(pe_st[1] pe_st[2] : pe_state) (V:id),'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: true = pe_disagree_at pe_st[1] pe_st[2] V →
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: In V (map (@fst _ _) pe_st[1] ++ map (@fst _ _) pe_st[2]).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Proof. unfold pe_disagree_at. intros pe_st[1] pe_st[2] V H.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: apply in_app_iff.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: remember (pe_lookup pe_st[1] V) as lookup1.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: destruct lookup1 as [n[1]|]. left. apply pe_domain with n[1]. auto.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: remember (pe_lookup pe_st[2] V) as lookup2.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: destruct lookup2 as [n[2]|]. right. apply pe_domain with n[2]. auto.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: inversion H. Qed.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Fixpoint pe_unique (l : list id) : list id :='
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: match l with
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '| [] ⇒ []'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '| x::l ⇒'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'x :: filter (fun y ⇒ if beq_id x y then false else true) (pe_unique l)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_unique_correct: ∀l x,'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: In x l ↔ In x (pe_unique l).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros l x. induction l as [| h t]. reflexivity.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: simpl in *. split.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: intros. inversion H; clear H.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: left. assumption.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: destruct (beq_idP h x).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: left. assumption.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: right. apply filter_In. split.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: apply IHt. assumption.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: rewrite false_beq_id; auto.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: intros. inversion H; clear H.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: left. assumption.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: apply filter_In in H[0]. inversion H[0]. right. apply IHt. assumption.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition pe_compare (pe_st[1] pe_st[2] : pe_state) : list id :='
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: pe_unique (filter (pe_disagree_at pe_st[1] pe_st[2])
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: (map (@fst _ _) pe_st[1] ++ map (@fst _ _) pe_st[2])).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_compare_correct: ∀pe_st[1] pe_st[2] V,'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: pe_lookup pe_st[1] V = pe_lookup pe_st[2] V ↔
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: ¬ In V (pe_compare pe_st[1] pe_st[2]).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros pe_st[1] pe_st[2] V.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: unfold pe_compare. rewrite ← pe_unique_correct. rewrite filter_In.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: split; intros Heq.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: intro. destruct H. unfold pe_disagree_at in H[0]. rewrite Heq in H[0].
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: destruct (pe_lookup pe_st[2] V).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← beq_nat_refl in H[0]. inversion H[0].
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[0].
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (Hagree: pe_disagree_at pe_st[1] pe_st[2] V = false).'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '{ (* Proof of assertion *)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: remember (pe_disagree_at pe_st[1] pe_st[2] V) as disagree.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: destruct disagree; [| reflexivity].
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: apply  pe_disagree_domain in Heqdisagree.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: exfalso. apply Heq. split. assumption. reflexivity. }
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: unfold pe_disagree_at in Hagree.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: destruct (pe_lookup pe_st[1] V) as [n[1]|];
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: destruct (pe_lookup pe_st[2] V) as [n[2]|];
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: try reflexivity; try solve_by_invert.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: rewrite negb_false_iff in Hagree.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: apply beq_nat_true in Hagree. subst. reflexivity. Qed.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Fixpoint pe_removes (pe_st:pe_state) (ids : list id) : pe_state :='
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: match ids with
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '| [] ⇒ pe_st'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '| V::ids ⇒ pe_remove (pe_removes pe_st ids) V'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_removes_correct: ∀pe_st ids V,'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: pe_lookup (pe_removes pe_st ids) V =
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: if inb beq_id V ids then None else pe_lookup pe_st V.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros pe_st ids V. induction ids as [| V' ids]. reflexivity.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rewrite pe_remove_correct. rewrite IHids.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: compare V' V.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '- rewrite ← beq_id_refl. reflexivity.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '- rewrite false_beq_id; try congruence. reflexivity.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_compare_removes: ∀pe_st[1] pe_st[2] V,'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: pe_lookup (pe_removes pe_st[1] (pe_compare pe_st[1] pe_st[2])) V =
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: pe_lookup (pe_removes pe_st[2] (pe_compare pe_st[1] pe_st[2])) V.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: intros pe_st[1] pe_st[2] V. rewrite !pe_removes_correct.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: destruct (inbP _ _ beq_idP V (pe_compare pe_st[1] pe_st[2])).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '- reflexivity.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '- apply pe_compare_correct. auto. Qed.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_compare_update: ∀pe_st[1] pe_st[2] st,'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: pe_update st (pe_removes pe_st[1] (pe_compare pe_st[1] pe_st[2])) =
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: pe_update st (pe_removes pe_st[2] (pe_compare pe_st[1] pe_st[2])).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros. apply functional_extensionality. intros V.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: rewrite !pe_update_correct. rewrite pe_compare_removes. reflexivity.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Fixpoint assign (pe_st : pe_state) (ids : list id) : com :='
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: match ids with
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '| [] ⇒ SKIP'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '| V::ids ⇒ match pe_lookup pe_st V with'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '| Some n ⇒ (assign pe_st ids;; V ::= ANum n)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '| None ⇒ assign pe_st ids'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: end
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Definition assigned (pe_st:pe_state) (ids : list id) (st:state) : state :='
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: fun V ⇒ if inb beq_id V ids then
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: match pe_lookup pe_st V with
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '| Some n ⇒ n'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '| None ⇒ st V'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: end
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: else st V.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem assign_removes: ∀pe_st ids st,'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: pe_update st pe_st =
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: pe_update (assigned pe_st ids st) (pe_removes pe_st ids).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros pe_st ids st. apply functional_extensionality. intros V.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: rewrite !pe_update_correct. rewrite pe_removes_correct. unfold assigned.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: destruct (inbP _ _ beq_idP V ids); destruct (pe_lookup pe_st V); reflexivity.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma ceval_extensionality: ∀c st st[1] st[2],'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[1] → (∀V, st[1] V = st[2] V) → c / st ⇓ st[2].
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros c st st[1] st[2] H Heq.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: apply functional_extensionality in Heq. rewrite ← Heq. apply H. Qed.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem eval_assign: ∀pe_st ids st,'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: assign pe_st ids / st ⇓ assigned pe_st ids st.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros pe_st ids st. induction ids as [| V ids]; simpl.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '- (*  *) eapply [ceval_extensionality](PE.html#ceval_extensionality). apply
    [E_Skip](Imp.html#E_Skip). reflexivity.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '- (* V::ids *)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: remember ([pe_lookup](PE.html#pe_lookup) pe_st V) as lookup. destruct lookup.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: + (* Some *) eapply [E_Seq](Imp.html#E_Seq). apply IHids. unfold [assigned](PE.html#assigned).
    simpl.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: eapply [ceval_extensionality](PE.html#ceval_extensionality). apply [E_Ass](Imp.html#E_Ass).
    simpl. reflexivity.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: intros V[0]. unfold [t_update](Maps.html#t_update). compare V V[0].
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '* (* equal *) rewrite ← Heqlookup. rewrite ← [beq_id_refl](Maps.html#beq_id_refl).
    reflexivity.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '* (* not equal *) rewrite [false_beq_id](Maps.html#false_beq_id); simpl; congruence.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: + (* None *) eapply [ceval_extensionality](PE.html#ceval_extensionality). apply
    IHids.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: unfold [assigned](PE.html#assigned). intros V[0]. simpl. compare V V[0].
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '* (* equal *) rewrite ← Heqlookup.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← [beq_id_refl](Maps.html#beq_id_refl).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 ← [beq_id_refl](Maps.html#beq_id_refl)。
- en: destruct ([inbP](PE.html#inbP) _ _ [beq_idP](Maps.html#beq_idP) V ids); reflexivity.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: destruct ([inbP](PE.html#inbP) _ _ [beq_idP](Maps.html#beq_idP) V ids); 反射性。
- en: '* (* not equal *) rewrite [false_beq_id](Maps.html#false_beq_id); simpl; congruence.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* not equal *) 重写 [false_beq_id](Maps.html#false_beq_id)；简化；恒等。'
- en: Qed.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 证毕。
- en: '[PRE33]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Reserved Notation "c1 '/' st '⇓' c1' '/' st'"
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 保留记号 "c1 '/' st '⇓' c1' '/' st'"
- en: (at level 40, st at level 39, c[1]' at level 39).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: (at level 40, st at level 39, c[1]' at level 39)。
- en: 'Inductive pe_com : com → pe_state → com → pe_state → Prop :='
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳 pe_com : com → pe_state → com → pe_state → Prop :='
- en: '| PE_Skip : ∀pe_st,'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_Skip : ∀pe_st,'
- en: SKIP / pe_st ⇓ SKIP / pe_st
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: SKIP / pe_st ⇓ SKIP / pe_st
- en: '| PE_AssStatic : ∀pe_st a[1] n[1] l,'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_AssStatic : ∀pe_st a[1] n[1] l,'
- en: pe_aexp pe_st a[1] = ANum n[1] →
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当 pe_aexp pe_st a[1] = ANum n[1] 时 →
- en: (l ::= a[1]) / pe_st ⇓ SKIP / pe_add pe_st l n[1]
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: (l ::= a[1]) / pe_st ⇓ SKIP / pe_add pe_st l n[1]
- en: '| PE_AssDynamic : ∀pe_st a[1] a[1]'' l,'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_AssDynamic : ∀pe_st a[1] a[1]'' l,'
- en: pe_aexp pe_st a[1] = a[1]' →
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 当 pe_aexp pe_st a[1] = a[1]' 时 →
- en: (∀n, a[1]' ≠ ANum n) →
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: (∀n, a[1]' ≠ ANum n) →
- en: (l ::= a[1]) / pe_st ⇓ (l ::= a[1]') / pe_remove pe_st l
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: (l ::= a[1]) / pe_st ⇓ (l ::= a[1]') / pe_remove pe_st l
- en: '| PE_Seq : ∀pe_st pe_st'' pe_st'''' c[1] c[2] c[1]'' c[2]'','
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_Seq : ∀pe_st pe_st'' pe_st'''' c[1] c[2] c[1]'' c[2]'','
- en: c[1] / pe_st  ⇓ c[1]' / pe_st' →
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / pe_st  ⇓ c[1]' / pe_st' →
- en: c[2] / pe_st' ⇓ c[2]' / pe_st'' →
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: c[2] / pe_st' ⇓ c[2]' / pe_st'' →
- en: (c[1] ;; c[2]) / pe_st ⇓ (c[1]' ;; c[2]') / pe_st''
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: (c[1] ;; c[2]) / pe_st ⇓ (c[1]' ;; c[2]') / pe_st''
- en: '| PE_IfTrue : ∀pe_st pe_st'' b[1] c[1] c[2] c[1]'','
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_IfTrue : ∀pe_st pe_st'' b[1] c[1] c[2] c[1]'','
- en: pe_bexp pe_st b[1] = BTrue →
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 当 pe_bexp pe_st b[1] = BTrue 时 →
- en: c[1] / pe_st ⇓ c[1]' / pe_st' →
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / pe_st ⇓ c[1]' / pe_st' →
- en: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st ⇓ c[1]' / pe_st'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st ⇓ c[1]' / pe_st'
- en: '| PE_IfFalse : ∀pe_st pe_st'' b[1] c[1] c[2] c[2]'','
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_IfFalse : ∀pe_st pe_st'' b[1] c[1] c[2] c[2]'','
- en: pe_bexp pe_st b[1] = BFalse →
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 当 pe_bexp pe_st b[1] = BFalse 时 →
- en: c[2] / pe_st ⇓ c[2]' / pe_st' →
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: c[2] / pe_st ⇓ c[2]' / pe_st' →
- en: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st ⇓ c[2]' / pe_st'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st ⇓ c[2]' / pe_st'
- en: '| PE_If : ∀pe_st pe_st[1] pe_st[2] b[1] c[1] c[2] c[1]'' c[2]'','
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_If : ∀pe_st pe_st[1] pe_st[2] b[1] c[1] c[2] c[1]'' c[2]'','
- en: pe_bexp pe_st b[1] ≠ BTrue →
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当 pe_bexp pe_st b[1] ≠ BTrue 时 →
- en: pe_bexp pe_st b[1] ≠ BFalse →
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 当 pe_bexp pe_st b[1] ≠ BFalse 时 →
- en: c[1] / pe_st ⇓ c[1]' / pe_st[1] →
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / pe_st ⇓ c[1]' / pe_st[1] →
- en: c[2] / pe_st ⇓ c[2]' / pe_st[2] →
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: c[2] / pe_st ⇓ c[2]' / pe_st[2] →
- en: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st
- en: ⇓ (IFB pe_bexp pe_st b[1]
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: ⇓ (IFB pe_bexp pe_st b[1]
- en: THEN c[1]' ;; assign pe_st[1] (pe_compare pe_st[1] pe_st[2])
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 c[1]' ;; assign pe_st[1] (pe_compare pe_st[1] pe_st[2])
- en: ELSE c[2]' ;; assign pe_st[2] (pe_compare pe_st[1] pe_st[2]) FI)
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 否则 c[2]' ;; assign pe_st[2] (pe_compare pe_st[1] pe_st[2]) FI)
- en: / pe_removes pe_st[1] (pe_compare pe_st[1] pe_st[2])
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: / pe_removes pe_st[1] (pe_compare pe_st[1] pe_st[2])
- en: where "c1 '/' st '⇓' c1' '/' st'" := (pe_com c[1] st c[1]' st').
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 "c1 '/' st '⇓' c1' '/' st'" := (pe_com c[1] st c[1]' st')。
- en: Hint Constructors pe_com.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: Hint 构造函数 pe_com。
- en: Hint Constructors ceval.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: Hint 构造函数 ceval。
- en: '[PRE34]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Example pe_example1:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 pe_example1：
- en: (X ::= ANum 3 ;; Y ::= AMult (AId Z) (APlus (AId X) (AId X)))
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: (X ::= ANum 3 ;; Y ::= AMult (AId Z) (APlus (AId X) (AId X)))
- en: / [] ⇓ (SKIP;; Y ::= AMult (AId Z) (ANum 6)) / [(X,3)].
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: / [] ⇓ (SKIP;; Y ::= AMult (AId Z) (ANum 6)) / [(X,3)]。
- en: Proof. eapply PE_Seq. eapply PE_AssStatic. reflexivity.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。使用 eapply PE_Seq。使用 eapply PE_AssStatic。反射性。
- en: eapply PE_AssDynamic. reflexivity. intros n H. inversion H. Qed.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 eapply PE_AssDynamic。反射性。intros n H。反演 H。证毕。
- en: 'Example pe_example2:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 pe_example2：
- en: (X ::= ANum 3 ;; IFB BLe (AId X) (ANum 4) THEN X ::= ANum 4 ELSE SKIP FI)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: (X ::= ANum 3 ;; IFB BLe (AId X) (ANum 4) THEN X ::= ANum 4 ELSE SKIP FI)
- en: / [] ⇓ (SKIP;; SKIP) / [(X,4)].
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: / [] ⇓ (SKIP;; SKIP) / [(X,4)]。
- en: Proof. eapply PE_Seq. eapply PE_AssStatic. reflexivity.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。使用 eapply PE_Seq。使用 eapply PE_AssStatic。反射性。
- en: eapply PE_IfTrue. reflexivity.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 eapply PE_IfTrue。反射性。
- en: eapply PE_AssStatic. reflexivity. Qed.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 eapply PE_AssStatic。反射性。证毕。
- en: 'Example pe_example3:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 pe_example3：
- en: (X ::= ANum 3;;
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: (X ::= ANum 3;;
- en: IFB BLe (AId Y) (ANum 4) THEN
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: IFB BLe (AId Y) (ANum 4) THEN
- en: Y ::= ANum 4;;
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= ANum 4;;
- en: IFB BEq (AId X) (AId Y) THEN Y ::= ANum 999 ELSE SKIP FI
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: IFB BEq (AId X) (AId Y) THEN Y ::= ANum 999 ELSE SKIP FI
- en: ELSE SKIP FI) / []
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: ELSE SKIP FI) / []
- en: ⇓ (SKIP;;
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: ⇓ (SKIP;;
- en: IFB BLe (AId Y) (ANum 4) THEN
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: IFB BLe (AId Y) (ANum 4) THEN
- en: (SKIP;; SKIP);; (SKIP;; Y ::= ANum 4)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: (SKIP;; SKIP);; (SKIP;; Y ::= ANum 4)
- en: ELSE SKIP;; SKIP FI)
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: ELSE SKIP;; SKIP FI)
- en: / [(X,3)].
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: / [(X,3)]。
- en: Proof. erewrite f_equal2 with (f := fun c st ⇒ _ / _ ⇓ c / st).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 使用 erewrite f_equal2 with (f := fun c st ⇒ _ / _ ⇓ c / st)。
- en: eapply PE_Seq. eapply PE_AssStatic. reflexivity.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 eapply PE_Seq。使用 eapply PE_AssStatic。反射性。
- en: eapply PE_If; intuition eauto; try solve_by_invert.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 eapply PE_If；直觉 eauto；尝试 solve_by_invert。
- en: econstructor. eapply PE_AssStatic. reflexivity.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 eapply。使用 eapply PE_AssStatic。反射性。
- en: eapply PE_IfFalse. reflexivity. econstructor.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 eapply PE_IfFalse。反射性。应用构造函数。
- en: reflexivity. reflexivity. Qed.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 反射性。反射性。证毕。
- en: '[PRE35]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Reserved Notation "c' '/' pe_st' '/' st '⇓' st''"
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 保留记号 "c' '/' pe_st' '/' st '⇓' st''"
- en: (at level 40, pe_st' at level 39, st at level 39).
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: (at level 40, pe_st' at level 39, st at level 39)。
- en: Inductive pe_ceval
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 pe_ceval
- en: '(c'':com) (pe_st'':pe_state) (st:state) (st'''':state) : Prop :='
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: （c':com）（pe_st':pe_state）（st:state）（st'':state）：命题 :=
- en: '| pe_ceval_intro : ∀st'','
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '| pe_ceval_intro：对于所有 st''，'
- en: c' / st ⇓ st' →
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: c' / st ⇓ st' →
- en: pe_update st' pe_st' = st'' →
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: pe_update st' pe_st' = st'' →
- en: c' / pe_st' / st ⇓ st''
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: c' / pe_st' / st ⇓ st''
- en: where "c' '/' pe_st' '/' st '⇓' st''" := (pe_ceval c' pe_st' st st'').
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 "c' '/' pe_st' '/' st '⇓' st''" := (pe_ceval c' pe_st' st st'')。
- en: Hint Constructors pe_ceval.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 构造子 pe_ceval。
- en: 'Theorem pe_com_complete:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 pe_com_complete：
- en: ∀c pe_st pe_st' c', c / pe_st ⇓ c' / pe_st' →
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有 c pe_st pe_st' c'，c / pe_st ⇓ c' / pe_st' →
- en: ∀st st'',
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有 st st''，
- en: (c / pe_update st pe_st ⇓ st'') →
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: （c / pe_update st pe_st ⇓ st''）→
- en: (c' / pe_st' / st ⇓ st'').
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: （c' / pe_st' / st ⇓ st''）。
- en: Proof. intros c pe_st pe_st' c' Hpe.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。引入 c pe_st pe_st' c' Hpe。
- en: induction Hpe; intros st st'' Heval;
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Hpe 进行归纳；引入 st st'' Heval；
- en: try (inversion Heval; subst;
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（反演 Heval; 替换；
- en: try (rewrite → pe_bexp_correct, → H in *; solve_by_invert);
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（在 * 中重写 → pe_bexp_correct, → H; 通过反演解决）；
- en: '[]);'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '[]）；'
- en: eauto.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 自动。
- en: '- (* PE_AssStatic *) econstructor. econstructor.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_AssStatic *) 构造子。构造子。'
- en: rewrite → pe_aexp_correct. rewrite ← pe_update_update_add.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 → pe_aexp_correct。重写 ← pe_update_update_add。
- en: rewrite → H. reflexivity.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 → H。一致性。
- en: '- (* PE_AssDynamic *) econstructor. econstructor. reflexivity.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_AssDynamic *) 构造子。构造子。一致性。'
- en: rewrite → pe_aexp_correct. rewrite ← pe_update_update_remove.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 → pe_aexp_correct。重写 ← pe_update_update_remove。
- en: reflexivity.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性。
- en: '- (* PE_Seq *)'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_Seq *)'
- en: edestruct IHHpe1. eassumption. subst.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 对 IHHpe1 进行 edestruct。假设。替换。
- en: edestruct IHHpe2. eassumption.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 对 IHHpe2 进行 edestruct。假设。
- en: eauto.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 自动。
- en: '- (* PE_If *) inversion Heval; subst.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_If *) 反演 Heval; 替换。'
- en: + (* E'IfTrue *) edestruct IHHpe1. eassumption.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: + (* E'IfTrue *) 对 IHHpe1 进行 edestruct。假设。
- en: econstructor. apply E_IfTrue. rewrite ← pe_bexp_correct. assumption.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 构造子。应用 E_IfTrue。重写 ← pe_bexp_correct。假设。
- en: eapply E_Seq. eassumption. apply eval_assign.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 E_Seq。假设。应用 eval_assign。
- en: rewrite ← assign_removes. eassumption.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 ← assign_removes。假设。
- en: + (* E_IfFalse *) edestruct IHHpe2. eassumption.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: + (* E_IfFalse *) 对 IHHpe2 进行 edestruct。假设。
- en: econstructor. apply E_IfFalse. rewrite ← pe_bexp_correct. assumption.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 构造子。应用 E_IfFalse。重写 ← pe_bexp_correct。假设。
- en: eapply E_Seq. eassumption. apply eval_assign.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 E_Seq。假设。应用 eval_assign。
- en: rewrite → pe_compare_update.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 → pe_compare_update。
- en: rewrite ← assign_removes. eassumption.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 ← assign_removes。假设。
- en: Qed.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。
- en: 'Theorem pe_com_sound:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 pe_com_sound：
- en: ∀c pe_st pe_st' c', c / pe_st ⇓ c' / pe_st' →
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有 c pe_st pe_st' c'，c / pe_st ⇓ c' / pe_st' →
- en: ∀st st'',
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有 st st''，
- en: (c' / pe_st' / st ⇓ st'') →
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: （c' / pe_st' / st ⇓ st''）→
- en: (c / pe_update st pe_st ⇓ st'').
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: （c / pe_update st pe_st ⇓ st''）。
- en: Proof. intros c pe_st pe_st' c' Hpe.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。引入 c pe_st pe_st' c' Hpe。
- en: induction Hpe;
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Hpe 进行归纳；
- en: intros st st'' [st' Heval Heq];
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 st st'' [st' Heval Heq]；
- en: try (inversion Heval; []; subst); auto.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（反演 Heval; []; 替换）；自动。
- en: '- (* PE_AssStatic *) rewrite ← pe_update_update_add. apply E_Ass.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_AssStatic *) 重写 ← pe_update_update_add。应用 E_Ass。'
- en: rewrite → pe_aexp_correct. rewrite → H. reflexivity.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 → pe_aexp_correct。重写 → H。一致性。
- en: '- (* PE_AssDynamic *) rewrite ← pe_update_update_remove. apply E_Ass.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_AssDynamic *) 重写 ← pe_update_update_remove。应用 E_Ass。'
- en: rewrite ← pe_aexp_correct. reflexivity.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 ← pe_aexp_correct。一致性。
- en: '- (* PE_Seq *) eapply E_Seq; eauto.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_Seq *) 应用 E_Seq；自动。'
- en: '- (* PE_IfTrue *) apply E_IfTrue.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_IfTrue *) 应用 E_IfTrue。'
- en: rewrite → pe_bexp_correct. rewrite → H. reflexivity. eauto.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 → pe_bexp_correct。重写 → H。一致性。自动。
- en: '- (* PE_IfFalse *) apply E_IfFalse.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_IfFalse *) 应用 E_IfFalse。'
- en: rewrite → pe_bexp_correct. rewrite → H. reflexivity. eauto.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 → pe_bexp_correct。重写 → H。一致性。自动。
- en: '- (* PE_If *)'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_If *)'
- en: inversion Heval; subst; inversion H[7];
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Heval; 替换；反演 H[7]；
- en: (eapply ceval_deterministic in H[8]; [| apply eval_assign]); subst.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: （应用 ceval_deterministic 在 H[8] 中；[| 应用 eval_assign]）；替换。
- en: + (* E_IfTrue *)
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: + (* E_IfTrue *)
- en: apply E_IfTrue. rewrite → pe_bexp_correct. assumption.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 E_IfTrue。重写 → pe_bexp_correct。假设。
- en: rewrite ← assign_removes. eauto.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 ← assign_removes。自动。
- en: + (* E_IfFalse *)
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: + (* E_IfFalse *)
- en: rewrite → pe_compare_update.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 → pe_compare_update。
- en: apply E_IfFalse. rewrite → pe_bexp_correct. assumption.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 E_IfFalse。重写 → pe_bexp_correct。假设。
- en: rewrite ← assign_removes. eauto.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 ← assign_removes。自动。
- en: Qed.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE36]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Corollary pe_com_correct:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 推论 pe_com_correct：
- en: ∀c pe_st pe_st' c', c / pe_st ⇓ c' / pe_st' →
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有 c pe_st pe_st' c'，c / pe_st ⇓ c' / pe_st' →
- en: ∀st st'',
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有 st st''，
- en: (c / pe_update st pe_st ⇓ st'') ↔
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: （c / pe_update st pe_st ⇓ st''）↔
- en: (c' / pe_st' / st ⇓ st'').
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: （c' / pe_st' / st ⇓ st''）。
- en: Proof. intros c pe_st pe_st' c' H st st''. split.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。引入 c pe_st pe_st' c' H st st''。分割。
- en: '- (* -> *) apply pe_com_complete. apply H.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* -> *) 应用 pe_com_complete。应用 H。'
- en: '- (* <- *) apply pe_com_sound. apply H.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* <- *) 应用 pe_com_sound。应用 H。'
- en: Qed.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE37]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: WHILE BLe (ANum 1) (AId X) DO
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: WHILE BLe (ANum 1) (AId X) DO
- en: Y ::= AMult (AId Y) (AId Y);;
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= AMult (AId Y) (AId Y)；
- en: X ::= AMinus (AId X) (ANum 1)
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= AMinus (AId X) (ANum 1)
- en: END
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: END
- en: If we know neither X nor Y statically, then the entire loop is
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们静态地都不知道 X 和 Y，那么整个循环就是
- en: dynamic and the residual command should be the same.  If we know
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 动态和剩余命令应该是相同的。如果我们知道
- en: X but not Y, then the loop can be unrolled all the way and the
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X 而不是 Y，那么循环可以完全展开，而
- en: residual command should be, for example,
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 残余命令应该是，例如，
- en: '[PRE38]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: X ::= ANum 0;;
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= ANum 0;;
- en: WHILE BLe (ANum 1) (AId Y) DO
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: WHILE BLe (ANum 1) (AId Y) DO
- en: Y ::= AMinus (AId Y) (ANum 1);;
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= AMinus (AId Y) (ANum 1);;
- en: X ::= AMinus (ANum 1) (AId X)
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= AMinus (ANum 1) (AId X)
- en: END
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: END
- en: The value of X alternates between 0 and 1 during the loop.
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X 的值在循环期间在 0 和 1 之间交替。
- en: Ideally, we would like to unroll this loop, not all the way but
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望展开这个循环，但不是全部展开，而是
- en: '*two-fold*, into something like'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*两倍*，变成类似于'
- en: '[PRE39]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Module Loop.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 模块 循环。
- en: Reserved Notation "c1 '/' st '⇓' c1' '/' st' '/' c''"
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 保留记法 "c1 '/' st '⇓' c1' '/' st' '/' c''"
- en: (at level 40, st at level 39, c[1]' at level 39, st' at level 39).
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: (at level 40, st at level 39, c[1]' at level 39, st' at level 39).
- en: 'Inductive pe_com : com → pe_state → com → pe_state → com → Prop :='
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳 pe_com : com → pe_state → com → pe_state → com → Prop :='
- en: '| PE_Skip : ∀pe_st,'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_Skip : ∀pe_st,'
- en: SKIP / pe_st ⇓ SKIP / pe_st / SKIP
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: SKIP / pe_st ⇓ SKIP / pe_st / SKIP
- en: '| PE_AssStatic : ∀pe_st a[1] n[1] l,'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_AssStatic : ∀pe_st a[1] n[1] l,'
- en: pe_aexp pe_st a[1] = ANum n[1] →
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: pe_aexp pe_st a[1] = ANum n[1] →
- en: (l ::= a[1]) / pe_st ⇓ SKIP / pe_add pe_st l n[1] / SKIP
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: (l ::= a[1]) / pe_st ⇓ SKIP / pe_add pe_st l n[1] / SKIP
- en: '| PE_AssDynamic : ∀pe_st a[1] a[1]'' l,'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_AssDynamic : ∀pe_st a[1] a[1]'' l,'
- en: pe_aexp pe_st a[1] = a[1]' →
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: pe_aexp pe_st a[1] = a[1]' →
- en: (∀n, a[1]' ≠ ANum n) →
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: (∀n, a[1]' ≠ ANum n) →
- en: (l ::= a[1]) / pe_st ⇓ (l ::= a[1]') / pe_remove pe_st l / SKIP
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: (l ::= a[1]) / pe_st ⇓ (l ::= a[1]') / pe_remove pe_st l / SKIP
- en: '| PE_Seq : ∀pe_st pe_st'' pe_st'''' c[1] c[2] c[1]'' c[2]'' c'''','
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_Seq : ∀pe_st pe_st'' pe_st'''' c[1] c[2] c[1]'' c[2]'' c'''','
- en: c[1] / pe_st  ⇓ c[1]' / pe_st' / SKIP →
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / pe_st  ⇓ c[1]' / pe_st' / SKIP →
- en: c[2] / pe_st' ⇓ c[2]' / pe_st'' / c'' →
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: c[2] / pe_st' ⇓ c[2]' / pe_st'' / c'' →
- en: (c[1] ;; c[2]) / pe_st ⇓ (c[1]' ;; c[2]') / pe_st'' / c''
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: (c[1] ;; c[2]) / pe_st ⇓ (c[1]' ;; c[2]') / pe_st'' / c''
- en: '| PE_IfTrue : ∀pe_st pe_st'' b[1] c[1] c[2] c[1]'' c'''','
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_IfTrue : ∀pe_st pe_st'' b[1] c[1] c[2] c[1]'' c'''','
- en: pe_bexp pe_st b[1] = BTrue →
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: pe_bexp pe_st b[1] = BTrue →
- en: c[1] / pe_st ⇓ c[1]' / pe_st' / c'' →
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / pe_st ⇓ c[1]' / pe_st' / c'' →
- en: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st ⇓ c[1]' / pe_st' / c''
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st ⇓ c[1]' / pe_st' / c''
- en: '| PE_IfFalse : ∀pe_st pe_st'' b[1] c[1] c[2] c[2]'' c'''','
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_IfFalse : ∀pe_st pe_st'' b[1] c[1] c[2] c[2]'' c'''','
- en: pe_bexp pe_st b[1] = BFalse →
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: pe_bexp pe_st b[1] = BFalse →
- en: c[2] / pe_st ⇓ c[2]' / pe_st' / c'' →
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: c[2] / pe_st ⇓ c[2]' / pe_st' / c'' →
- en: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st ⇓ c[2]' / pe_st' / c''
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st ⇓ c[2]' / pe_st' / c''
- en: '| PE_If : ∀pe_st pe_st[1] pe_st[2] b[1] c[1] c[2] c[1]'' c[2]'' c'''','
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_If : ∀pe_st pe_st[1] pe_st[2] b[1] c[1] c[2] c[1]'' c[2]'' c'''','
- en: pe_bexp pe_st b[1] ≠ BTrue →
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: pe_bexp pe_st b[1] ≠ BTrue →
- en: pe_bexp pe_st b[1] ≠ BFalse →
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: pe_bexp pe_st b[1] ≠ BFalse →
- en: c[1] / pe_st ⇓ c[1]' / pe_st[1] / c'' →
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / pe_st ⇓ c[1]' / pe_st[1] / c'' →
- en: c[2] / pe_st ⇓ c[2]' / pe_st[2] / c'' →
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: c[2] / pe_st ⇓ c[2]' / pe_st[2] / c'' →
- en: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st
- en: ⇓ (IFB pe_bexp pe_st b[1]
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: ⇓ (IFB pe_bexp pe_st b[1]
- en: THEN c[1]' ;; assign pe_st[1] (pe_compare pe_st[1] pe_st[2])
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: THEN c[1]' ;; assign pe_st[1] (pe_compare pe_st[1] pe_st[2])
- en: ELSE c[2]' ;; assign pe_st[2] (pe_compare pe_st[1] pe_st[2]) FI)
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: ELSE c[2]' ;; assign pe_st[2] (pe_compare pe_st[1] pe_st[2]) FI)
- en: / pe_removes pe_st[1] (pe_compare pe_st[1] pe_st[2])
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: / pe_removes pe_st[1] (pe_compare pe_st[1] pe_st[2])
- en: / c''
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: / c''
- en: '| PE_WhileEnd : ∀pe_st b[1] c[1],'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_WhileEnd : ∀pe_st b[1] c[1],'
- en: pe_bexp pe_st b[1] = BFalse →
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: pe_bexp pe_st b[1] = BFalse →
- en: (WHILE b[1] DO c[1] END) / pe_st ⇓ SKIP / pe_st / SKIP
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b[1] DO c[1] END) / pe_st ⇓ SKIP / pe_st / SKIP
- en: '| PE_WhileLoop : ∀pe_st pe_st'' pe_st'''' b[1] c[1] c[1]'' c[2]'' c[2]'''','
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_WhileLoop : ∀pe_st pe_st'' pe_st'''' b[1] c[1] c[1]'' c[2]'' c[2]'''','
- en: pe_bexp pe_st b[1] = BTrue →
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: pe_bexp pe_st b[1] = BTrue →
- en: c[1] / pe_st ⇓ c[1]' / pe_st' / SKIP →
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / pe_st ⇓ c[1]' / pe_st' / SKIP →
- en: (WHILE b[1] DO c[1] END) / pe_st' ⇓ c[2]' / pe_st'' / c[2]'' →
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b[1] DO c[1] END) / pe_st' ⇓ c[2]' / pe_st'' / c[2]'' →
- en: pe_compare pe_st pe_st'' ≠ [] →
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: pe_compare pe_st pe_st'' ≠ [] →
- en: (WHILE b[1] DO c[1] END) / pe_st ⇓ (c[1]';;c[2]') / pe_st'' / c[2]''
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b[1] DO c[1] END) / pe_st ⇓ (c[1]';;c[2]') / pe_st'' / c[2]''
- en: '| PE_While : ∀pe_st pe_st'' pe_st'''' b[1] c[1] c[1]'' c[2]'' c[2]'''','
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_While : ∀pe_st pe_st'' pe_st'''' b[1] c[1] c[1]'' c[2]'' c[2]'''','
- en: pe_bexp pe_st b[1] ≠ BFalse →
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: pe_bexp pe_st b[1] ≠ BFalse →
- en: pe_bexp pe_st b[1] ≠ BTrue →
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: pe_bexp pe_st b[1] ≠ BTrue →
- en: c[1] / pe_st ⇓ c[1]' / pe_st' / SKIP →
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / pe_st ⇓ c[1]' / pe_st' / SKIP →
- en: (WHILE b[1] DO c[1] END) / pe_st' ⇓ c[2]' / pe_st'' / c[2]'' →
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b[1] DO c[1] END) / pe_st' ⇓ c[2]' / pe_st'' / c[2]'' →
- en: pe_compare pe_st pe_st'' ≠ [] →
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: pe_compare pe_st pe_st'' ≠ [] →
- en: (c[2]'' = SKIP ∨ c[2]'' = WHILE b[1] DO c[1] END) →
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: (c[2]'' = SKIP ∨ c[2]'' = WHILE b[1] DO c[1] END) →
- en: (WHILE b[1] DO c[1] END) / pe_st
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b[1] DO c[1] END) / pe_st
- en: ⇓ (IFB pe_bexp pe_st b[1]
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: ⇓ (IFB pe_bexp pe_st b[1]
- en: THEN c[1]';; c[2]';; assign pe_st'' (pe_compare pe_st pe_st'')
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: THEN c[1]';; c[2]';; assign pe_st'' (pe_compare pe_st pe_st'')
- en: ELSE assign pe_st (pe_compare pe_st pe_st'') FI)
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: ELSE assign pe_st (pe_compare pe_st pe_st'') FI)
- en: / pe_removes pe_st (pe_compare pe_st pe_st'')
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: / pe_removes pe_st (pe_compare pe_st pe_st'')
- en: / c[2]''
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: / c[2]''
- en: '| PE_WhileFixedEnd : ∀pe_st b[1] c[1],'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_WhileFixedEnd : ∀pe_st b[1] c[1],'
- en: pe_bexp pe_st b[1] ≠ BFalse →
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: pe_bexp pe_st b[1] ≠ BFalse →
- en: (WHILE b[1] DO c[1] END) / pe_st ⇓ SKIP / pe_st / (WHILE b[1] DO c[1] END)
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b[1] DO c[1] END) / pe_st ⇓ SKIP / pe_st / (WHILE b[1] DO c[1] END)
- en: '| PE_WhileFixedLoop : ∀pe_st pe_st'' pe_st'''' b[1] c[1] c[1]'' c[2]'','
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_WhileFixedLoop : ∀pe_st pe_st'' pe_st'''' b[1] c[1] c[1]'' c[2]'','
- en: pe_bexp pe_st b[1] = BTrue →
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: pe_bexp pe_st b[1] = BTrue →
- en: c[1] / pe_st ⇓ c[1]' / pe_st' / SKIP →
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / pe_st ⇓ c[1]' / pe_st' / SKIP →
- en: (WHILE b[1] DO c[1] END) / pe_st'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b[1] DO c[1] END) / pe_st'
- en: ⇓ c[2]' / pe_st'' / (WHILE b[1] DO c[1] END) →
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: ⇓ c[2]' / pe_st'' / (WHILE b[1] DO c[1] END) →
- en: pe_compare pe_st pe_st'' = [] →
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: pe_compare pe_st pe_st'' = [] →
- en: (WHILE b[1] DO c[1] END) / pe_st
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b[1] DO c[1] END) / pe_st
- en: ⇓ (WHILE BTrue DO SKIP END) / pe_st / SKIP
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: ⇓ (WHILE BTrue DO SKIP END) / pe_st / SKIP
- en: '(* Because we have an infinite loop, we should actually          start to throw away the rest of the program:
             (WHILE b[1] DO c[1] END) / pe_st          \\ SKIP / pe_st / (WHILE BTrue DO SKIP END) *)'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: (* 因为我们有一个无限循环，实际上我们应该开始抛弃程序的其余部分：(WHILE b[1] DO c[1] END) / pe_st \\ SKIP / pe_st / (WHILE BTrue DO SKIP END) *)
- en: '| PE_WhileFixed : ∀pe_st pe_st'' pe_st'''' b[1] c[1] c[1]'' c[2]'','
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '| PE_WhileFixed : ∀pe_st pe_st'' pe_st'''' b[1] c[1] c[1]'' c[2]'','
- en: pe_bexp pe_st b[1] ≠ BFalse →
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: pe_bexp pe_st b[1] ≠ BFalse →
- en: pe_bexp pe_st b[1] ≠ BTrue →
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: pe_bexp pe_st b[1] ≠ BTrue →
- en: c[1] / pe_st ⇓ c[1]' / pe_st' / SKIP →
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / pe_st ⇓ c[1]' / pe_st' / SKIP →
- en: (WHILE b[1] DO c[1] END) / pe_st'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b[1] DO c[1] END) / pe_st'
- en: ⇓ c[2]' / pe_st'' / (WHILE b[1] DO c[1] END) →
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: ⇓ c[2]' / pe_st'' / (WHILE b[1] DO c[1] END) →
- en: pe_compare pe_st pe_st'' = [] →
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: pe_compare pe_st pe_st'' = [] →
- en: (WHILE b[1] DO c[1] END) / pe_st
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b[1] DO c[1] END) / pe_st
- en: ⇓ (WHILE pe_bexp pe_st b[1] DO c[1]';; c[2]' END) / pe_st / SKIP
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: ⇓ (WHILE pe_bexp pe_st b[1] DO c[1]';; c[2]' END) / pe_st / SKIP
- en: where "c1 '/' st '⇓' c1' '/' st' '/' c''" := (pe_com c[1] st c[1]' st' c'').
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: where "c1 '/' st '⇓' c1' '/' st' '/' c''" := (pe_com c[1] st c[1]' st' c'').
- en: Hint Constructors pe_com.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: Hint Constructors pe_com.
- en: '[PRE40]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Ltac step i :=
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: Ltac step i :=
- en: (eapply i; intuition eauto; try solve_by_invert);
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: (eapply i; intuition eauto; try solve_by_invert);
- en: repeat (try eapply PE_Seq;
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: repeat (try eapply PE_Seq;
- en: try (eapply PE_AssStatic; simpl; reflexivity);
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: try (eapply PE_AssStatic; simpl; reflexivity);
- en: try (eapply PE_AssDynamic;
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: try (eapply PE_AssDynamic;
- en: '[ simpl; reflexivity'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '[ simpl; reflexivity'
- en: '| intuition eauto; solve_by_invert])).'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '| intuition eauto; solve_by_invert])).'
- en: 'Definition square_loop: com :='
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 'Definition square_loop: com :='
- en: WHILE BLe (ANum 1) (AId X) DO
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: WHILE BLe (ANum 1) (AId X) DO
- en: Y ::= AMult (AId Y) (AId Y);;
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= AMult (AId Y) (AId Y);;
- en: X ::= AMinus (AId X) (ANum 1)
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= AMinus (AId X) (ANum 1)
- en: END.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: END.
- en: 'Example pe_loop_example1:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example pe_loop_example1:'
- en: square_loop / []
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: square_loop / []
- en: ⇓ (WHILE BLe (ANum 1) (AId X) DO
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: ⇓ (WHILE BLe (ANum 1) (AId X) DO
- en: (Y ::= AMult (AId Y) (AId Y);;
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: (Y ::= AMult (AId Y) (AId Y);;
- en: X ::= AMinus (AId X) (ANum 1));; SKIP
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= AMinus (AId X) (ANum 1));; SKIP
- en: END) / [] / SKIP.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: END) / [] / SKIP.
- en: Proof. erewrite f_equal2 with (f := fun c st ⇒ _ / _ ⇓ c / st / SKIP).
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: Proof. erewrite f_equal2 with (f := fun c st ⇒ _ / _ ⇓ c / st / SKIP).
- en: step PE_WhileFixed. step PE_WhileFixedEnd. reflexivity.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: step PE_WhileFixed. step PE_WhileFixedEnd. reflexivity.
- en: reflexivity. reflexivity. Qed.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: reflexivity. reflexivity. Qed.
- en: 'Example pe_loop_example2:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example pe_loop_example2:'
- en: (X ::= ANum 3;; square_loop) / []
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: (X ::= ANum 3;; square_loop) / []
- en: ⇓ (SKIP;;
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: ⇓ (SKIP;;
- en: (Y ::= AMult (AId Y) (AId Y);; SKIP);;
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: (Y ::= AMult (AId Y) (AId Y);; SKIP);;
- en: (Y ::= AMult (AId Y) (AId Y);; SKIP);;
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: (Y ::= AMult (AId Y) (AId Y);; SKIP);;
- en: (Y ::= AMult (AId Y) (AId Y);; SKIP);;
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: (Y ::= AMult (AId Y) (AId Y);; SKIP);;
- en: SKIP) / [(X,0)] / SKIP.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: SKIP) / [(X,0)] / SKIP.
- en: Proof. erewrite f_equal2 with (f := fun c st ⇒ _ / _ ⇓ c / st / SKIP).
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: Proof. erewrite f_equal2 with (f := fun c st ⇒ _ / _ ⇓ c / st / SKIP).
- en: eapply PE_Seq. eapply PE_AssStatic. reflexivity.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: eapply PE_Seq. eapply PE_AssStatic. reflexivity.
- en: step PE_WhileLoop.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: step PE_WhileLoop.
- en: step PE_WhileLoop.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: step PE_WhileLoop.
- en: step PE_WhileLoop.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: step PE_WhileLoop.
- en: step PE_WhileEnd.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: step PE_WhileEnd.
- en: inversion H. inversion H. inversion H.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: inversion H. inversion H. inversion H.
- en: reflexivity. reflexivity. Qed.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: reflexivity. reflexivity. Qed.
- en: 'Example pe_loop_example3:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 'Example pe_loop_example3:'
- en: (Z ::= ANum 3;; subtract_slowly) / []
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: (Z ::= ANum 3;; subtract_slowly) / []
- en: ⇓ (SKIP;;
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: ⇓ (SKIP;;
- en: IFB BNot (BEq (AId X) (ANum 0)) THEN
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: IFB BNot (BEq (AId X) (ANum 0)) THEN
- en: (SKIP;; X ::= AMinus (AId X) (ANum 1));;
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: (SKIP;; X ::= AMinus (AId X) (ANum 1));;
- en: IFB BNot (BEq (AId X) (ANum 0)) THEN
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: IFB BNot (BEq (AId X) (ANum 0)) THEN
- en: (SKIP;; X ::= AMinus (AId X) (ANum 1));;
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: (SKIP;; X ::= AMinus (AId X) (ANum 1));;
- en: IFB BNot (BEq (AId X) (ANum 0)) THEN
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: IFB BNot (BEq (AId X) (ANum 0)) THEN
- en: (SKIP;; X ::= AMinus (AId X) (ANum 1));;
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: (SKIP;; X ::= AMinus (AId X) (ANum 1));;
- en: WHILE BNot (BEq (AId X) (ANum 0)) DO
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: WHILE BNot (BEq (AId X) (ANum 0)) DO
- en: (SKIP;; X ::= AMinus (AId X) (ANum 1));; SKIP
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: (SKIP;; X ::= AMinus (AId X) (ANum 1));; SKIP
- en: END;;
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: END;;
- en: SKIP;; Z ::= ANum 0
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: SKIP;; Z ::= ANum 0
- en: ELSE SKIP;; Z ::= ANum 1 FI;; SKIP
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: ELSE SKIP;; Z ::= ANum 1 FI;; SKIP
- en: ELSE SKIP;; Z ::= ANum 2 FI;; SKIP
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: ELSE SKIP;; Z ::= ANum 2 FI;; SKIP
- en: ELSE SKIP;; Z ::= ANum 3 FI) / [] / SKIP.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: ELSE SKIP;; Z ::= ANum 3 FI) / [] / SKIP.
- en: Proof. erewrite f_equal2 with (f := fun c st ⇒ _ / _ ⇓ c / st / SKIP).
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: Proof. erewrite f_equal2 with (f := fun c st ⇒ _ / _ ⇓ c / st / SKIP).
- en: eapply PE_Seq. eapply PE_AssStatic. reflexivity.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: eapply PE_Seq. eapply PE_AssStatic. reflexivity.
- en: step PE_While.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: step PE_While.
- en: step PE_While.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: step PE_While.
- en: step PE_While.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: step PE_While.
- en: step PE_WhileFixed.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: step PE_WhileFixed.
- en: step PE_WhileFixedEnd.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: step PE_WhileFixedEnd.
- en: reflexivity. inversion H. inversion H. inversion H.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性。反演 H。反演 H。反演 H。
- en: reflexivity. reflexivity. Qed.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性。一致性。Qed。
- en: 'Example pe_loop_example4:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 pe_loop_example4:'
- en: (X ::= ANum 0;;
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: (X ::= ANum 0;;
- en: WHILE BLe (AId X) (ANum 2) DO
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 当 BLe (AId X) (ANum 2) 时
- en: X ::= AMinus (ANum 1) (AId X)
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= AMinus (ANum 1) (AId X)
- en: END) / [] ⇓ (SKIP;; WHILE BTrue DO SKIP END) / [(X,0)] / SKIP.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: END) / [] ⇓ (SKIP;; WHILE BTrue DO SKIP END) / [(X,0)] / SKIP。
- en: Proof. erewrite f_equal2 with (f := fun c st ⇒ _ / _ ⇓ c / st / SKIP).
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。重写 f_equal2 为 (fun c st ⇒ _ / _ ⇓ c / st / SKIP)。
- en: eapply PE_Seq. eapply PE_AssStatic. reflexivity.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 PE_Seq。应用 PE_AssStatic。一致性。
- en: step PE_WhileFixedLoop.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 PE_WhileFixedLoop。
- en: step PE_WhileLoop.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 PE_WhileLoop。
- en: step PE_WhileFixedEnd.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 PE_WhileFixedEnd。
- en: inversion H. reflexivity. reflexivity. reflexivity. Qed.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 H。一致性。一致性。一致性。Qed。
- en: '[PRE41]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Reserved Notation "c1 '/' st '⇓' st' '#' n"
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 保留的符号 "c1 '/' st '⇓' st' '#' n"
- en: (at level 40, st at level 39, st' at level 39).
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: (在级别 40，st 在级别 39，st' 在级别 39)。
- en: 'Inductive ceval_count : com → state → state → nat → Prop :='
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳定义 ceval_count : com → state → state → nat → 属性：'
- en: '| E''Skip : ∀st,'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '| E''Skip : ∀st，'
- en: 'SKIP / st ⇓ st # 0'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 'SKIP / st ⇓ st # 0'
- en: '| E''Ass  : ∀st a[1] n l,'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '| E''Ass  : ∀st a[1] n l，'
- en: aeval st a[1] = n →
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: aeval st a[1] = n →
- en: '(l ::= a[1]) / st ⇓ (t_update st l n) # 0'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '(l ::= a[1]) / st ⇓ (t_update st l n) # 0'
- en: '| E''Seq : ∀c[1] c[2] st st'' st'''' n[1] n[2],'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '| E''Seq : ∀c[1] c[2] st st'' st'''' n[1] n[2]，'
- en: 'c[1] / st  ⇓ st''  # n[1] →'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 'c[1] / st  ⇓ st''  # n[1] →'
- en: 'c[2] / st'' ⇓ st'''' # n[2] →'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 'c[2] / st'' ⇓ st'''' # n[2] →'
- en: '(c[1] ;; c[2]) / st ⇓ st'''' # (n[1] + n[2])'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '(c[1] ;; c[2]) / st ⇓ st'''' # (n[1] + n[2])'
- en: '| E''IfTrue : ∀st st'' b[1] c[1] c[2] n,'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '| E''IfTrue : ∀st st'' b[1] c[1] c[2] n，'
- en: beval st b[1] = true →
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b[1] = true →
- en: 'c[1] / st ⇓ st'' # n →'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 'c[1] / st ⇓ st'' # n →'
- en: '(IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'' # n'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '(IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'' # n'
- en: '| E''IfFalse : ∀st st'' b[1] c[1] c[2] n,'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '| E''IfFalse : ∀st st'' b[1] c[1] c[2] n，'
- en: beval st b[1] = false →
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b[1] = false →
- en: 'c[2] / st ⇓ st'' # n →'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 'c[2] / st ⇓ st'' # n →'
- en: '(IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'' # n'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '(IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'' # n'
- en: '| E''WhileEnd : ∀b[1] st c[1],'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '| E''WhileEnd : ∀b[1] st c[1],'
- en: beval st b[1] = false →
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b[1] = false →
- en: '(WHILE b[1] DO c[1] END) / st ⇓ st # 0'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '(WHILE b[1] DO c[1] END) / st ⇓ st # 0'
- en: '| E''WhileLoop : ∀st st'' st'''' b[1] c[1] n[1] n[2],'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '| E''WhileLoop : ∀st st'' st'''' b[1] c[1] n[1] n[2]，'
- en: beval st b[1] = true →
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b[1] = true →
- en: 'c[1] / st ⇓ st'' # n[1] →'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 'c[1] / st ⇓ st'' # n[1] →'
- en: '(WHILE b[1] DO c[1] END) / st'' ⇓ st'''' # n[2] →'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '(WHILE b[1] DO c[1] END) / st'' ⇓ st'''' # n[2] →'
- en: '(WHILE b[1] DO c[1] END) / st ⇓ st'''' # S (n[1] + n[2])'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '(WHILE b[1] DO c[1] END) / st ⇓ st'''' # S (n[1] + n[2])'
- en: 'where "c1 ''/'' st ''⇓'' st'' # n" := (ceval_count c[1] st st'' n).'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '其中 "c1 ''/'' st ''⇓'' st'' # n" := (ceval_count c[1] st st'' n)。'
- en: Hint Constructors ceval_count.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 构造函数 ceval_count。
- en: 'Theorem ceval_count_complete: ∀c st st'','
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 ceval_count_complete: ∀c st st''，'
- en: 'c / st ⇓ st'' → ∃n, c / st ⇓ st'' # n.'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 'c / st ⇓ st'' → 存在 n，c / st ⇓ st'' # n。'
- en: Proof. intros c st st' Heval.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。引入 c st st' Heval。
- en: induction Heval;
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Heval 进行归纳；
- en: try inversion IHHeval1;
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试反演 IHHeval1；
- en: try inversion IHHeval2;
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试反演 IHHeval2；
- en: try inversion IHHeval;
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试反演 IHHeval；
- en: eauto. Qed.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 自动。Qed。
- en: 'Theorem ceval_count_sound: ∀c st st'' n,'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 ceval_count_sound: ∀c st st'' n，'
- en: 'c / st ⇓ st'' # n → c / st ⇓ st''.'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 'c / st ⇓ st'' # n → c / st ⇓ st''。'
- en: Proof. intros c st st' n Heval. induction Heval; eauto. Qed.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。引入 c st st' n Heval。对 Heval 进行归纳；自动。Qed。
- en: 'Theorem pe_compare_nil_lookup: ∀pe_st[1] pe_st[2],'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 pe_compare_nil_lookup: ∀pe_st[1] pe_st[2]，'
- en: pe_compare pe_st[1] pe_st[2] = [] →
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: pe_compare pe_st[1] pe_st[2] = [] →
- en: ∀V, pe_lookup pe_st[1] V = pe_lookup pe_st[2] V.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: ∀V，pe_lookup pe_st[1] V = pe_lookup pe_st[2] V。
- en: Proof. intros pe_st[1] pe_st[2] H V.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。引入 pe_st[1] pe_st[2] H V。
- en: apply (pe_compare_correct pe_st[1] pe_st[2] V).
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 在 (pe_compare_correct pe_st[1] pe_st[2] V) 中应用。
- en: rewrite H. intro. inversion H[0]. Qed.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 H。引入。反演 H[0]。Qed。
- en: 'Theorem pe_compare_nil_update: ∀pe_st[1] pe_st[2],'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 pe_compare_nil_update: ∀pe_st[1] pe_st[2]，'
- en: pe_compare pe_st[1] pe_st[2] = [] →
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: pe_compare pe_st[1] pe_st[2] = [] →
- en: ∀st, pe_update st pe_st[1] = pe_update st pe_st[2].
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: ∀st, pe_update st pe_st[1] = pe_update st pe_st[2]。
- en: Proof. intros pe_st[1] pe_st[2] H st.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。引入 pe_st[1] pe_st[2] H st。
- en: apply functional_extensionality. intros V.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 functional_extensionality。引入 V。
- en: rewrite !pe_update_correct.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 !pe_update_correct。
- en: apply pe_compare_nil_lookup with (V:=V) in H.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 在 H 中应用 pe_compare_nil_lookup (V:=V)。
- en: rewrite H. reflexivity. Qed.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 H。一致性。Qed。
- en: Reserved Notation "c' '/' pe_st' '/' c'' '/' st '⇓' st'' '#' n"
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 保留的符号 "c' '/' pe_st' '/' c'' '/' st '⇓' st'' '#' n"
- en: (at level 40, pe_st' at level 39, c'' at level 39,
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: (在级别 40，pe_st' 在级别 39，c'' 在级别 39，
- en: st at level 39, st'' at level 39).
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: st 在级别 39，st'' 在级别 39)。
- en: Inductive pe_ceval_count (c':com) (pe_st':pe_state) (c'':com)
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳定义 pe_ceval_count (c':com) (pe_st':pe_state) (c'':com)
- en: '(st:state) (st'''':state) (n:nat) : Prop :='
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '(st:state) (st'''':state) (n:nat) : 属性 :='
- en: '| pe_ceval_count_intro : ∀st'' n'','
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '| pe_ceval_count_intro : ∀st'' n''，'
- en: c' / st ⇓ st' →
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: c' / st ⇓ st' →
- en: 'c'''' / pe_update st'' pe_st'' ⇓ st'''' # n'' →'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 'c'''' / pe_update st'' pe_st'' ⇓ st'''' # n'' →'
- en: n' ≤ n →
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: n' ≤ n →
- en: 'c'' / pe_st'' / c'''' / st ⇓ st'''' # n'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 'c'' / pe_st'' / c'''' / st ⇓ st'''' # n'
- en: where "c' '/' pe_st' '/' c'' '/' st '⇓' st'' '#' n" :=
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 "c' '/' pe_st' '/' c'' '/' st '⇓' st'' '#' n" :=
- en: (pe_ceval_count c' pe_st' c'' st st'' n).
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: (pe_ceval_count c' pe_st' c'' st st'' n)。
- en: Hint Constructors pe_ceval_count.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 构造子 pe_ceval_count。
- en: 'Lemma pe_ceval_count_le: ∀c'' pe_st'' c'''' st st'''' n n'','
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 pe_ceval_count_le: ∀c'' pe_st'' c'''' st st'''' n n'','
- en: n' ≤ n →
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: n' ≤ n →
- en: 'c'' / pe_st'' / c'''' / st ⇓ st'''' # n'' →'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 'c'' / pe_st'' / c'''' / st ⇓ st'''' # n'' →'
- en: 'c'' / pe_st'' / c'''' / st ⇓ st'''' # n.'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 'c'' / pe_st'' / c'''' / st ⇓ st'''' # n。'
- en: Proof. intros c' pe_st' c'' st st'' n n' Hle H. inversion H.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。介绍 c' pe_st' c'' st st'' n n' Hle H。反演 H。
- en: econstructor; try eassumption. omega. Qed.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 构造子；尝试假设。omega。Qed。
- en: 'Theorem pe_com_complete:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 pe_com_complete:'
- en: ∀c pe_st pe_st' c' c'', c / pe_st ⇓ c' / pe_st' / c'' →
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: ∀c pe_st pe_st' c' c''，c / pe_st ⇓ c' / pe_st' / c'' →
- en: ∀st st'' n,
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: ∀st st'' n，
- en: '(c / pe_update st pe_st ⇓ st'''' # n) →'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '（c / pe_update st pe_st ⇓ st'''' # n）→'
- en: '(c'' / pe_st'' / c'''' / st ⇓ st'''' # n).'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '(c'' / pe_st'' / c'''' / st ⇓ st'''' # n)。'
- en: Proof. intros c pe_st pe_st' c' c'' Hpe.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。介绍 c pe_st pe_st' c' c'' Hpe。
- en: induction Hpe; intros st st'' n Heval;
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Hpe 进行归纳；对 st st'' n Heval；
- en: try (inversion Heval; subst;
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（反演 Heval；替换；
- en: try (rewrite → pe_bexp_correct, → H in *; solve_by_invert);
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（重写 → pe_bexp_correct，→ H 在 *；通过反演解决）；
- en: '[]);'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '[]；'
- en: eauto.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 自动。
- en: '- (* PE_AssStatic *) econstructor. econstructor.'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_AssStatic *) 构造子。构造子。'
- en: rewrite → pe_aexp_correct. rewrite ← pe_update_update_add.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 → pe_aexp_correct。重写 ← pe_update_update_add。
- en: rewrite → H. apply E'Skip. auto.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 → H。应用 E'Skip。自动。
- en: '- (* PE_AssDynamic *) econstructor. econstructor. reflexivity.'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_AssDynamic *) 构造子。构造子。一致性。'
- en: rewrite → pe_aexp_correct. rewrite ← pe_update_update_remove.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 → pe_aexp_correct。重写 ← pe_update_update_remove。
- en: apply E'Skip. auto.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 E'Skip。自动。
- en: '- (* PE_Seq *)'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_Seq *)'
- en: edestruct IHHpe1 as [? ? ? Hskip ?]. eassumption.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHHpe1 作为 [? ? ? Hskip ?]。假设。
- en: inversion Hskip. subst.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Hskip。替换。
- en: edestruct IHHpe2. eassumption.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHHpe2。假设。
- en: econstructor; eauto. omega.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 构造子；自动。omega。
- en: '- (* PE_If *) inversion Heval; subst.'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_If *) 反演 Heval；替换。'
- en: + (* E'IfTrue *) edestruct IHHpe1. eassumption.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: + (* E'IfTrue *) 应用 IHHpe1。假设。
- en: econstructor. apply E_IfTrue. rewrite ← pe_bexp_correct. assumption.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 构造子。应用 E_IfTrue。重写 ← pe_bexp_correct。假设。
- en: eapply E_Seq. eassumption. apply eval_assign.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 E_Seq。假设。应用 eval_assign。
- en: rewrite ← assign_removes. eassumption. eassumption.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 ← assign_removes。假设。假设。
- en: + (* E_IfFalse *) edestruct IHHpe2. eassumption.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: + (* E_IfFalse *) 应用 IHHpe2。假设。
- en: econstructor. apply E_IfFalse. rewrite ← pe_bexp_correct. assumption.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 构造子。应用 E_IfFalse。重写 ← pe_bexp_correct。假设。
- en: eapply E_Seq. eassumption. apply eval_assign.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 E_Seq。假设。应用 eval_assign。
- en: rewrite → pe_compare_update.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 → pe_compare_update。
- en: rewrite ← assign_removes. eassumption. eassumption.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 ← assign_removes。假设。假设。
- en: '- (* PE_WhileLoop *)'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_WhileLoop *)'
- en: edestruct IHHpe1 as [? ? ? Hskip ?]. eassumption.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHHpe1 作为 [? ? ? Hskip ?]。假设。
- en: inversion Hskip. subst.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Hskip。替换。
- en: edestruct IHHpe2. eassumption.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHHpe2。假设。
- en: econstructor; eauto. omega.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 构造子；自动。omega。
- en: '- (* PE_While *) inversion Heval; subst.'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_While *) 反演 Heval；替换。'
- en: + (* E_WhileEnd *) econstructor. apply E_IfFalse.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: + (* E_WhileEnd *) 构造子。应用 E_IfFalse。
- en: rewrite ← pe_bexp_correct. assumption.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 ← pe_bexp_correct。假设。
- en: apply eval_assign.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 eval_assign。
- en: rewrite ← assign_removes. inversion H[2]; subst; auto.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 ← assign_removes。反演 H[2]；替换；自动。
- en: auto.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 自动。
- en: + (* E_WhileLoop *)
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: + (* E_WhileLoop *)
- en: edestruct IHHpe1 as [? ? ? Hskip ?]. eassumption.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHHpe1 作为 [? ? ? Hskip ?]。假设。
- en: inversion Hskip. subst.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Hskip。替换。
- en: edestruct IHHpe2. eassumption.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHHpe2。假设。
- en: econstructor. apply E_IfTrue.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 构造子。应用 E_IfTrue。
- en: rewrite ← pe_bexp_correct. assumption.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 ← pe_bexp_correct。假设。
- en: repeat eapply E_Seq; eauto. apply eval_assign.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 重复应用 E_Seq；自动。应用 eval_assign。
- en: rewrite → pe_compare_update, ← assign_removes. eassumption.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 → pe_compare_update，← assign_removes。假设。
- en: omega.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: omega。
- en: '- (* PE_WhileFixedLoop *) exfalso.'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_WhileFixedLoop *) 矛盾。'
- en: generalize dependent (S (n[1] + n[2])). intros n.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 推广相关的 (S (n[1] + n[2]))。介绍 n。
- en: clear - H H[0] IHHpe1 IHHpe2. generalize dependent st.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 清除 - H H[0] IHHpe1 IHHpe2。推广相关的 st。
- en: induction n using lt_wf_ind; intros st Heval. inversion Heval; subst.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 lt_wf_ind 进行 n 的归纳；对 st Heval 进行介绍。反演 Heval；替换。
- en: + (* E'WhileEnd *) rewrite pe_bexp_correct, H in H[7]. inversion H[7].
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: + (* E'WhileEnd *) 重写 pe_bexp_correct，H 在 H[7] 中。反演 H[7]。
- en: + (* E'WhileLoop *)
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: + (* E'WhileLoop *)
- en: edestruct IHHpe1 as [? ? ? Hskip ?]. eassumption.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHHpe1 作为 [? ? ? Hskip ?]。假设。
- en: inversion Hskip. subst.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Hskip。替换。
- en: edestruct IHHpe2. eassumption.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHHpe2。假设。
- en: rewrite ← (pe_compare_nil_update _ _ H[0]) in H[7].
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 ← (pe_compare_nil_update _ _ H[0]) 在 H[7] 中。
- en: apply H[1] in H[7]; [| omega]. inversion H[7].
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 在 H[1] 中应用 H[7]；[| omega]。反演 H[7]。
- en: '- (* PE_WhileFixed *) generalize dependent st.'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* PE_WhileFixed *) 推广相关的 st。'
- en: induction n using lt_wf_ind; intros st Heval. inversion Heval; subst.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 lt_wf_ind 进行 n 的归纳；对 st Heval 进行介绍。反演 Heval；替换。
- en: + (* E'WhileEnd *) rewrite pe_bexp_correct in H[8]. eauto.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: + (* E'WhileEnd *) 在 H[8] 中重写 pe_bexp_correct。自动。
- en: + (* E'WhileLoop *) rewrite pe_bexp_correct in H[5].
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: + (* E'WhileLoop *) 在 H[5] 中重写 pe_bexp_correct。
- en: edestruct IHHpe1 as [? ? ? Hskip ?]. eassumption.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hskip. subst.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: edestruct IHHpe2. eassumption.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← (pe_compare_nil_update _ _ H[1]) in H[8].
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: apply H[2] in H[8]; [| omega]. inversion H[8].
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: econstructor; [ eapply E_WhileLoop; eauto | eassumption | omega].
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_com_sound:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: ∀c pe_st pe_st' c' c'', c / pe_st ⇓ c' / pe_st' / c'' →
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: ∀st st'' n,
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: '(c'' / pe_st'' / c'''' / st ⇓ st'''' # n) →'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: (c / pe_update st pe_st ⇓ st'').
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros c pe_st pe_st' c' c'' Hpe.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: induction Hpe;
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: intros st st'' n [st' n' Heval Heval' Hle];
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: try (inversion Heval; []; subst);
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: try (inversion Heval'; []; subst); eauto.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_AssStatic *) rewrite ← pe_update_update_add. apply E_Ass.'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_aexp_correct. rewrite → H. reflexivity.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_AssDynamic *) rewrite ← pe_update_update_remove. apply E_Ass.'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← pe_aexp_correct. reflexivity.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_Seq *) eapply E_Seq; eauto.'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_IfTrue *) apply E_IfTrue.'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_bexp_correct. rewrite → H. reflexivity.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: eapply IHHpe. eauto.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_IfFalse *) apply E_IfFalse.'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_bexp_correct. rewrite → H. reflexivity.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: eapply IHHpe. eauto.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_If *) inversion Heval; subst; inversion H[7]; subst; clear H[7].'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_IfTrue *)
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: eapply ceval_deterministic in H[8]; [| apply eval_assign]. subst.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← assign_removes in Heval'.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: apply E_IfTrue. rewrite → pe_bexp_correct. assumption.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: eapply IHHpe1. eauto.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_IfFalse *)
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: eapply ceval_deterministic in H[8]; [| apply eval_assign]. subst.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_compare_update in Heval'.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← assign_removes in Heval'.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: apply E_IfFalse. rewrite → pe_bexp_correct. assumption.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: eapply IHHpe2. eauto.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_WhileEnd *) apply E_WhileEnd.'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_bexp_correct. rewrite → H. reflexivity.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_WhileLoop *) eapply E_WhileLoop.'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_bexp_correct. rewrite → H. reflexivity.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: eapply IHHpe1. eauto. eapply IHHpe2. eauto.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_While *) inversion Heval; subst.'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_IfTrue *)
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[9]. subst. clear H[9].
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[10]. subst. clear H[10].
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: eapply ceval_deterministic in H[11]; [| apply eval_assign]. subst.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_compare_update in Heval'.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← assign_removes in Heval'.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: eapply E_WhileLoop. rewrite → pe_bexp_correct. assumption.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: eapply IHHpe1. eauto.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: eapply IHHpe2. eauto.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_IfFalse *) apply ceval_count_sound in Heval'.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: eapply ceval_deterministic in H[9]; [| apply eval_assign]. subst.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← assign_removes in Heval'.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[2]; subst.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: '* (* c[2]'''' = SKIP *) inversion Heval''. subst. apply E_WhileEnd.'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_bexp_correct. assumption.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '* (* c[2]'''' = WHILE b[1] DO c[1] END *) assumption.'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_WhileFixedEnd *) eapply ceval_count_sound. apply Heval''.'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_WhileFixedLoop *)'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: apply loop_never_stops in Heval. inversion Heval.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_WhileFixed *)'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: clear - H[1] IHHpe1 IHHpe2 Heval.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: remember (WHILE pe_bexp pe_st b[1] DO c[1]';; c[2]' END) as c'.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: induction Heval;
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: inversion Heqc'; subst; clear Heqc'.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_WhileEnd *) apply E_WhileEnd.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: rewrite pe_bexp_correct. assumption.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_WhileLoop *)
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: assert (IHHeval2' := IHHeval2 (refl_equal _)).
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: apply ceval_count_complete in IHHeval2'. inversion IHHeval2'.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: clear IHHeval1 IHHeval2 IHHeval2'.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: inversion Heval1. subst.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: eapply E_WhileLoop. rewrite pe_bexp_correct. assumption. eauto.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: eapply IHHpe2. econstructor. eassumption.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← (pe_compare_nil_update _ _ H[1]). eassumption. apply le_n.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: 'Corollary pe_com_correct:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: ∀c pe_st pe_st' c', c / pe_st ⇓ c' / pe_st' / SKIP →
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: ∀st st'',
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: (c / pe_update st pe_st ⇓ st'') ↔
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: (∃st', c' / st ⇓ st' ∧ pe_update st' pe_st' = st'').
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros c pe_st pe_st' c' H st st''. split.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *) intros Heval.'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: apply ceval_count_complete in Heval. inversion Heval as [n Heval'].
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: apply pe_com_complete with (st:=st) (st'':=st'') (n:=n) in H.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [? ? ? Hskip ?]. inversion Hskip. subst. eauto.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: assumption.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *) intros [st'' [Heval Heq]]. subst st''''.'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: eapply pe_com_sound in H. apply H.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: econstructor. apply Heval. apply E'Skip. apply le_n.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: End Loop.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Inductive block (Label:Type) : Type :='
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: '| Goto : Label → block Label'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: '| If : bexp → Label → Label → block Label'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: '| Assign : id → aexp → block Label → block Label.'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: Arguments Goto {Label} _.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: Arguments If   {Label} _ _ _.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: Arguments Assign {Label} _ _ _.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Inductive parity_label : Type :='
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: '| entry : parity_label'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: '| loop  : parity_label'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: '| body  : parity_label'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: '| done  : parity_label.'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Definition parity_body : block parity_label :='
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: Assign Y (AMinus (AId Y) (ANum 1))
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: (Assign X (AMinus (ANum 1) (AId X))
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: (Goto loop)).
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Fixpoint keval {L:Type} (st:state) (k : block L) : state * L :='
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: match k with
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: '| Goto l ⇒ (st, l)'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: '| If b l[1] l[2] ⇒ (st, if beval st b then l[1] else l[2])'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: '| Assign i a k ⇒ keval (t_update st i (aeval st a)) k'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: 'Example keval_example:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: keval empty_state parity_body
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: = (t_update (t_update empty_state Y 0) X 1, loop).
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  id: totrans-979
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Definition program (L:Type) : Type := L → option (block L).'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition parity : program parity_label := fun l ⇒'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: match l with
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: '| entry ⇒ Some (Assign X (ANum 0) (Goto loop))'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: '| loop ⇒ Some (If (BLe (ANum 1) (AId Y)) body done)'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: '| body ⇒ Some parity_body'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: '| done ⇒ None (* halt *)'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Inductive peval {L:Type} (p : program L)'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: ': state → L → state → L → Prop :='
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: '| E_None: ∀st l,'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: p l = None →
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: peval p st l st l
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: '| E_Some: ∀st l k st'' l'' st'''' l'''','
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: p l = Some k →
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: keval st k = (st', l') →
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: peval p st' l' st'' l'' →
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: peval p st l st'' l''.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: 'Example parity_eval: peval parity empty_state entry empty_state done.'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: Proof. erewrite f_equal with (f := fun st ⇒ peval _ _ _ st _).
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: eapply E_Some. reflexivity. reflexivity.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: eapply E_Some. reflexivity. reflexivity.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: apply E_None. reflexivity.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: apply functional_extensionality. intros i. rewrite t_update_same; auto.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Fixpoint pe_block {L:Type} (pe_st:pe_state) (k : block L)'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: ': block (pe_state * L) :='
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: match k with
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: '| Goto l ⇒ Goto (pe_st, l)'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: '| If b l[1] l[2] ⇒'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: match pe_bexp pe_st b with
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: '| BTrue  ⇒ Goto (pe_st, l[1])'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: '| BFalse ⇒ Goto (pe_st, l[2])'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: '| b''     ⇒ If b'' (pe_st, l[1]) (pe_st, l[2])'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: end
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: '| Assign i a k ⇒'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: match pe_aexp pe_st a with
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: '| ANum n ⇒ pe_block (pe_add pe_st i n) k'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: '| a'' ⇒ Assign i a'' (pe_block (pe_remove pe_st i) k)'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: end
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: 'Example pe_block_example:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: pe_block [(X,0)] parity_body
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: = Assign Y (AMinus (AId Y) (ANum 1)) (Goto ([(X,1)], loop)).
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  id: totrans-1027
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Theorem pe_block_correct: ∀(L:Type) st pe_st k st'' pe_st'' (l'':L),'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: keval st (pe_block pe_st k) = (st', (pe_st', l')) →
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: keval (pe_update st pe_st) k = (pe_update st' pe_st', l').
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros. generalize dependent pe_st. generalize dependent st.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: induction k as [l | b l[1] l[2] | i a k];
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: intros st pe_st H.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: '- (* Goto *) inversion H; reflexivity.'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: '- (* If *)'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: replace (keval st (pe_block pe_st (If b l[1] l[2])))
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: with (keval st (If (pe_bexp pe_st b) (pe_st, l[1]) (pe_st, l[2])))
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: in H by (simpl; destruct (pe_bexp pe_st b); reflexivity).
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: simpl in *. rewrite pe_bexp_correct.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: destruct (beval st (pe_bexp pe_st b)); inversion H; reflexivity.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: '- (* Assign *)'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: simpl in *. rewrite pe_aexp_correct.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: destruct (pe_aexp pe_st a); simpl;
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: try solve [rewrite pe_update_update_add; apply IHk; apply H];
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: solve [rewrite pe_update_update_remove; apply IHk; apply H].
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition pe_program {L:Type} (p : program L)'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: ': program (pe_state * L) :='
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: fun pe_l ⇒ match pe_l with | (pe_st, l) ⇒
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: option_map (pe_block pe_st) (p l)
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive pe_peval {L:Type} (p : program L)'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: '(st:state) (pe_st:pe_state) (l:L) (st''o:state) (l'':L) : Prop :='
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '| pe_peval_intro : ∀st'' pe_st'','
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: peval (pe_program p) st (pe_st, l) st' (pe_st', l') →
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: pe_update st' pe_st' = st'o →
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: pe_peval p st pe_st l st'o l'.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_program_correct:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: '∀(L:Type) (p : program L) st pe_st l st''o l'','
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: peval p (pe_update st pe_st) l st'o l' ↔
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: pe_peval p st pe_st l st'o l'.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: split.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *) intros Heval.'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: remember (pe_update st pe_st) as sto.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent pe_st. generalize dependent st.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: induction Heval as
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: '[ sto l Hlookup | sto l k st''o l'' st''''o l'''' Hlookup Hkeval Heval ];'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: intros st pe_st Heqsto; subst sto.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_None *) eapply pe_peval_intro. apply E_None.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rewrite Hlookup. reflexivity. reflexivity.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_Some *)
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: remember (keval st (pe_block pe_st k)) as x.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: destruct x as [st' [pe_st' l'_]].
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: symmetry in Heqx. erewrite pe_block_correct in Hkeval by apply Heqx.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hkeval. subst st'o l'_. clear Hkeval.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: edestruct IHHeval. reflexivity. subst st''o. clear IHHeval.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: eapply pe_peval_intro; [| reflexivity]. eapply E_Some; eauto.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rewrite Hlookup. reflexivity.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *) intros [st'' pe_st'' Heval Heqst''o].'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: remember (pe_st, l) as pe_st_l.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: remember (pe_st', l') as pe_st'_l'.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent pe_st. generalize dependent l.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: induction Heval as
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: '[ st [pe_st_ l_] Hlookup'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: '| st [pe_st_ l_] pe_k st'' [pe_st''_ l''_] st'''' [pe_st'''' l'''']'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: Hlookup Hkeval Heval ];
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: intros l pe_st Heqpe_st_l;
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: inversion Heqpe_st_l; inversion Heqpe_st'_l'; repeat subst.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_None *) apply E_None. simpl in Hlookup.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: destruct (p l'); [ solve [ inversion Hlookup ] | reflexivity ].
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_Some *)
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: simpl in Hlookup. remember (p l) as k.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: destruct k as [k|]; inversion Hlookup; subst.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: eapply E_Some; eauto. apply pe_block_correct. apply Hkeval.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
