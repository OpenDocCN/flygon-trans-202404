- en: PEPartial Evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: (* Chapter written and maintained by Chung-chieh Shan *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: X ::= ANum 3;; Y ::= APlus (AId X) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: X ::= ANum 3;; Y ::= AMinus (APlus (AId X) (ANum 1)) (AId Y)
  prefs: []
  type: TYPE_NORMAL
- en: to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Require Import Coq.Bool.Bool.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Arith.Arith.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Arith.EqNat.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.omega.Omega.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Logic.FunctionalExtensionality.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Lists.List.
  prefs: []
  type: TYPE_NORMAL
- en: Import ListNotations.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Maps.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Imp.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Smallstep.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Definition pe_state := list (id * nat).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint pe_lookup (pe_st : pe_state) (V:id) : option nat :='
  prefs: []
  type: TYPE_NORMAL
- en: match pe_st with
  prefs: []
  type: TYPE_NORMAL
- en: '| [] ⇒ None'
  prefs: []
  type: TYPE_NORMAL
- en: '| (V'',n'')::pe_st ⇒ if beq_id V V'' then Some n'''
  prefs: []
  type: TYPE_NORMAL
- en: else pe_lookup pe_st V
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition empty_pe_state : pe_state := [].'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: compare V V'
  prefs: []
  type: TYPE_NORMAL
- en: means to reason by cases over beq_id V V'.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the case where V = V', the tactic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: substitutes V for V' throughout.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In what follows, we will make heavy use of the In property from
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the standard library, also defined in Logic.v:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Besides the various lemmas about In that we've already come
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: across, the following one (taken from the standard library) will
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'also be useful:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If a type A has an operator beq for testing equality of its
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: elements, we can compute a boolean inb beq a l for testing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: whether In a l holds or not.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It is easy to relate inb to In with the reflect property:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Partial evaluation of aexp is straightforward — it is basically
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the same as constant folding, fold_constants_aexp, except that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sometimes the partial state tells us the current value of a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variable and we can replace it by a constant expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This partial evaluator folds constants but does not apply the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: associativity of addition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, in what sense is pe_aexp correct?  It is reasonable to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'define the correctness of pe_aexp as follows: whenever a full'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: state st:state is *consistent* with a partial state
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pe_st:pe_state (in other words, every variable to which pe_st
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assigns a value is assigned the same value by st), evaluating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a and evaluating pe_aexp pe_st a in st yields the same
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: result.  This statement is indeed true.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: However, we will soon want our partial evaluator to remove
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assignments.  For example, it will simplify
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Y ::= AMinus (ANum 3) (AId Y);; X ::= ANum 4
  prefs: []
  type: TYPE_NORMAL
- en: by delaying the assignment to X until the end.  To accomplish
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this simplification, we need the result of partial evaluating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: X ::= ANum 3;; Y ::= AMinus (AId X) (AId Y);; X ::= ANum 4
  prefs: []
  type: TYPE_NORMAL
- en: to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint pe_update (st:state) (pe_st:pe_state) : state :='
  prefs: []
  type: TYPE_NORMAL
- en: match pe_st with
  prefs: []
  type: TYPE_NORMAL
- en: '| [] ⇒ st'
  prefs: []
  type: TYPE_NORMAL
- en: '| (V,n)::pe_st ⇒ t_update (pe_update st pe_st) V n'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_pe_update:'
  prefs: []
  type: TYPE_NORMAL
- en: pe_update (t_update empty_state Y 1) [(X,3);(Z,2)]
  prefs: []
  type: TYPE_NORMAL
- en: = t_update (t_update (t_update empty_state Y 1) Z 2) X 3.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem pe_update_correct: ∀st pe_st V[0],'
  prefs: []
  type: TYPE_NORMAL
- en: pe_update st pe_st V[0] =
  prefs: []
  type: TYPE_NORMAL
- en: match pe_lookup pe_st V[0] with
  prefs: []
  type: TYPE_NORMAL
- en: '| Some n ⇒ n'
  prefs: []
  type: TYPE_NORMAL
- en: '| None ⇒ st V[0]'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros. induction pe_st as [| [V n] pe_st]. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: simpl in *. unfold t_update.
  prefs: []
  type: TYPE_NORMAL
- en: compare V[0] V; auto. rewrite ← beq_id_refl; auto. rewrite false_beq_id; auto.
    Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem pe_update_consistent: ∀st pe_st,'
  prefs: []
  type: TYPE_NORMAL
- en: pe_consistent (pe_update st pe_st) pe_st.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros st pe_st V n H. rewrite pe_update_correct.
  prefs: []
  type: TYPE_NORMAL
- en: destruct (pe_lookup pe_st V); inversion H. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_consistent_update: ∀st pe_st,'
  prefs: []
  type: TYPE_NORMAL
- en: pe_consistent st pe_st → ∀V, st V = pe_update st pe_st V.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros st pe_st H V. rewrite pe_update_correct.
  prefs: []
  type: TYPE_NORMAL
- en: remember (pe_lookup pe_st V) as l. destruct l; auto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem pe_aexp_correct: ∀(pe_st:pe_state) (a:aexp) (st:state),'
  prefs: []
  type: TYPE_NORMAL
- en: aeval (pe_update st pe_st) a = aeval st (pe_aexp pe_st a).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros pe_st a st.
  prefs: []
  type: TYPE_NORMAL
- en: induction a; simpl;
  prefs: []
  type: TYPE_NORMAL
- en: try reflexivity;
  prefs: []
  type: TYPE_NORMAL
- en: try (destruct (pe_aexp pe_st a[1]);
  prefs: []
  type: TYPE_NORMAL
- en: destruct (pe_aexp pe_st a[2]);
  prefs: []
  type: TYPE_NORMAL
- en: rewrite IHa1; rewrite IHa2; reflexivity).
  prefs: []
  type: TYPE_NORMAL
- en: (* Compared to fold_constants_aexp_sound, the only      interesting case is AId. *)
  prefs: []
  type: TYPE_NORMAL
- en: rewrite pe_update_correct. destruct (pe_lookup pe_st i); reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint pe_bexp (pe_st : pe_state) (b : bexp) : bexp :='
  prefs: []
  type: TYPE_NORMAL
- en: match b with
  prefs: []
  type: TYPE_NORMAL
- en: '| BTrue        ⇒ BTrue'
  prefs: []
  type: TYPE_NORMAL
- en: '| BFalse       ⇒ BFalse'
  prefs: []
  type: TYPE_NORMAL
- en: '| BEq a[1] a[2] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match (pe_aexp pe_st a[1], pe_aexp pe_st a[2]) with
  prefs: []
  type: TYPE_NORMAL
- en: '| (ANum n[1], ANum n[2]) ⇒ if beq_nat n[1] n[2] then BTrue else BFalse'
  prefs: []
  type: TYPE_NORMAL
- en: '| (a[1]'', a[2]'') ⇒ BEq a[1]'' a[2]'''
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '| BLe a[1] a[2] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match (pe_aexp pe_st a[1], pe_aexp pe_st a[2]) with
  prefs: []
  type: TYPE_NORMAL
- en: '| (ANum n[1], ANum n[2]) ⇒ if leb n[1] n[2] then BTrue else BFalse'
  prefs: []
  type: TYPE_NORMAL
- en: '| (a[1]'', a[2]'') ⇒ BLe a[1]'' a[2]'''
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '| BNot b[1] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match (pe_bexp pe_st b[1]) with
  prefs: []
  type: TYPE_NORMAL
- en: '| BTrue ⇒ BFalse'
  prefs: []
  type: TYPE_NORMAL
- en: '| BFalse ⇒ BTrue'
  prefs: []
  type: TYPE_NORMAL
- en: '| b[1]'' ⇒ BNot b[1]'''
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '| BAnd b[1] b[2] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match (pe_bexp pe_st b[1], pe_bexp pe_st b[2]) with
  prefs: []
  type: TYPE_NORMAL
- en: '| (BTrue, BTrue) ⇒ BTrue'
  prefs: []
  type: TYPE_NORMAL
- en: '| (BTrue, BFalse) ⇒ BFalse'
  prefs: []
  type: TYPE_NORMAL
- en: '| (BFalse, BTrue) ⇒ BFalse'
  prefs: []
  type: TYPE_NORMAL
- en: '| (BFalse, BFalse) ⇒ BFalse'
  prefs: []
  type: TYPE_NORMAL
- en: '| (b[1]'', b[2]'') ⇒ BAnd b[1]'' b[2]'''
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_pe_bexp1:'
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp [(X,3)] (BNot (BLe (AId X) (ANum 3)))
  prefs: []
  type: TYPE_NORMAL
- en: = BFalse.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Example test_pe_bexp2: ∀b,'
  prefs: []
  type: TYPE_NORMAL
- en: b = BNot (BLe (AId X) (APlus (AId X) (ANum 1))) →
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp [] b = b.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros b H. rewrite → H. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem pe_bexp_correct: ∀(pe_st:pe_state) (b:bexp) (st:state),'
  prefs: []
  type: TYPE_NORMAL
- en: beval (pe_update st pe_st) b = beval st (pe_bexp pe_st b).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros pe_st b st.
  prefs: []
  type: TYPE_NORMAL
- en: induction b; simpl;
  prefs: []
  type: TYPE_NORMAL
- en: try reflexivity;
  prefs: []
  type: TYPE_NORMAL
- en: try (remember (pe_aexp pe_st a) as a';
  prefs: []
  type: TYPE_NORMAL
- en: remember (pe_aexp pe_st a[0]) as a[0]';
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (Ha: aeval (pe_update st pe_st) a = aeval st a'');'
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (Ha[0]: aeval (pe_update st pe_st) a[0] = aeval st a[0]'');'
  prefs: []
  type: TYPE_NORMAL
- en: try (subst; apply pe_aexp_correct);
  prefs: []
  type: TYPE_NORMAL
- en: destruct a'; destruct a[0]'; rewrite Ha; rewrite Ha[0];
  prefs: []
  type: TYPE_NORMAL
- en: simpl; try destruct (beq_nat n n[0]);
  prefs: []
  type: TYPE_NORMAL
- en: try destruct (leb n n[0]); reflexivity);
  prefs: []
  type: TYPE_NORMAL
- en: try (destruct (pe_bexp pe_st b); rewrite IHb; reflexivity);
  prefs: []
  type: TYPE_NORMAL
- en: try (destruct (pe_bexp pe_st b[1]);
  prefs: []
  type: TYPE_NORMAL
- en: destruct (pe_bexp pe_st b[2]);
  prefs: []
  type: TYPE_NORMAL
- en: rewrite IHb1; rewrite IHb2; reflexivity).
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: c[1] / st ⇓ c[1]' / st'
  prefs: []
  type: TYPE_NORMAL
- en: to mean that partially evaluating the source command c[1] in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: initial partial state st yields the residual command c[1]' and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the final partial state st'.  For example, we want something like
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint pe_remove (pe_st:pe_state) (V:id) : pe_state :='
  prefs: []
  type: TYPE_NORMAL
- en: match pe_st with
  prefs: []
  type: TYPE_NORMAL
- en: '| [] ⇒ []'
  prefs: []
  type: TYPE_NORMAL
- en: '| (V'',n'')::pe_st ⇒ if beq_id V V'' then pe_remove pe_st V'
  prefs: []
  type: TYPE_NORMAL
- en: 'else (V'',n'') :: pe_remove pe_st V'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_remove_correct: ∀pe_st V V[0],'
  prefs: []
  type: TYPE_NORMAL
- en: pe_lookup (pe_remove pe_st V) V[0]
  prefs: []
  type: TYPE_NORMAL
- en: = if beq_id V V[0] then None else pe_lookup pe_st V[0].
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros pe_st V V[0]. induction pe_st as [| [V' n'] pe_st].
  prefs: []
  type: TYPE_NORMAL
- en: '- (*  *) destruct ([beq_id](Maps.html#beq_id) V V[0]); reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* :: *) simpl. compare V V''.'
  prefs: []
  type: TYPE_NORMAL
- en: + (* equal *) rewrite IHpe_st.
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) V V[0]). reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [false_beq_id](Maps.html#false_beq_id); auto.
  prefs: []
  type: TYPE_NORMAL
- en: + (* not equal *) simpl. compare V[0] V'.
  prefs: []
  type: TYPE_NORMAL
- en: '* (* equal *) rewrite [false_beq_id](Maps.html#false_beq_id); auto.'
  prefs: []
  type: TYPE_NORMAL
- en: '* (* not equal *) rewrite IHpe_st. reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition pe_add (pe_st:[pe_state](PE.html#pe_state)) (V:[id](Maps.html#id))
    (n:[nat](http://coq.inria.fr/library/Coq.Init.Datatypes.html#nat)) : [pe_state](PE.html#pe_state)
    :='
  prefs: []
  type: TYPE_NORMAL
- en: '([V](PE.html#V),[n](PE.html#n)) :: [pe_remove](PE.html#pe_remove) [pe_st](PE.html#pe_st)
    [V](PE.html#V).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_add_correct: ∀pe_st V n V[0],'
  prefs: []
  type: TYPE_NORMAL
- en: '[pe_lookup](PE.html#pe_lookup) ([pe_add](PE.html#pe_add) [pe_st](PE.html#pe_st)
    [V](PE.html#V) [n](PE.html#n)) [V[0]](PE.html#V<sub>0</sub>)'
  prefs: []
  type: TYPE_NORMAL
- en: = if [beq_id](Maps.html#beq_id) [V](PE.html#V) [V[0]](PE.html#V<sub>0</sub>)
    then [Some](http://coq.inria.fr/library/Coq.Init.Datatypes.html#Some) [n](PE.html#n)
    else [pe_lookup](PE.html#pe_lookup) [pe_st](PE.html#pe_st) [V[0]](PE.html#V<sub>0</sub>).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros pe_st V n V[0]. unfold [pe_add](PE.html#pe_add). simpl.
  prefs: []
  type: TYPE_NORMAL
- en: compare V V[0].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* equal *) rewrite ← [beq_id_refl](Maps.html#beq_id_refl); auto.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* not equal *) rewrite [pe_remove_correct](PE.html#pe_remove_correct).'
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite [false_beq_id](Maps.html#false_beq_id); auto.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem pe_update_update_remove: ∀st pe_st V n,'
  prefs: []
  type: TYPE_NORMAL
- en: t_update (pe_update st pe_st) V n =
  prefs: []
  type: TYPE_NORMAL
- en: pe_update (t_update st V n) (pe_remove pe_st V).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros st pe_st V n. apply functional_extensionality.
  prefs: []
  type: TYPE_NORMAL
- en: intros V[0]. unfold t_update. rewrite !pe_update_correct.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite pe_remove_correct. destruct (beq_id V V[0]); reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_update_update_add: ∀st pe_st V n,'
  prefs: []
  type: TYPE_NORMAL
- en: t_update (pe_update st pe_st) V n =
  prefs: []
  type: TYPE_NORMAL
- en: pe_update st (pe_add pe_st V n).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros st pe_st V n. apply functional_extensionality. intros V[0].
  prefs: []
  type: TYPE_NORMAL
- en: unfold t_update. rewrite !pe_update_correct. rewrite pe_add_correct.
  prefs: []
  type: TYPE_NORMAL
- en: destruct (beq_id V V[0]); reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: X ::= ANum 3;;
  prefs: []
  type: TYPE_NORMAL
- en: IFB BLe (AId Y) (ANum 4) THEN
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= ANum 4;;
  prefs: []
  type: TYPE_NORMAL
- en: IFB BEq (AId X) (AId Y) THEN Y ::= ANum 999 ELSE SKIP FI
  prefs: []
  type: TYPE_NORMAL
- en: ELSE SKIP FI
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the initial partial state is empty.  We don't know
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: statically how Y compares to 4, so we must partially evaluate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: both branches of the (outer) conditional.  On the THEN branch,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we know that Y is set to 4 and can even use that knowledge to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simplify the code somewhat.  On the ELSE branch, we still don't
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: know the exact value of Y at the end.  What should the final
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: partial state and residual program be?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One way to handle such a dynamic conditional is to take the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intersection of the final partial states of the two branches.  In
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this example, we take the intersection of (Y,4),(X,3) and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (X,3), so the overall final partial state is (X,3).  To
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: compensate for forgetting that Y is 4, we need to add an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assignment Y ::= ANum 4 to the end of the THEN branch.  So,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the residual program will be something like
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition pe_disagree_at (pe_st[1] pe_st[2] : pe_state) (V:id) : bool :='
  prefs: []
  type: TYPE_NORMAL
- en: match pe_lookup pe_st[1] V, pe_lookup pe_st[2] V with
  prefs: []
  type: TYPE_NORMAL
- en: '| Some x, Some y ⇒ negb (beq_nat x y)'
  prefs: []
  type: TYPE_NORMAL
- en: '| None, None ⇒ false'
  prefs: []
  type: TYPE_NORMAL
- en: '| _, _ ⇒ true'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_disagree_domain: ∀(pe_st[1] pe_st[2] : pe_state) (V:id),'
  prefs: []
  type: TYPE_NORMAL
- en: true = pe_disagree_at pe_st[1] pe_st[2] V →
  prefs: []
  type: TYPE_NORMAL
- en: In V (map (@fst _ _) pe_st[1] ++ map (@fst _ _) pe_st[2]).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. unfold pe_disagree_at. intros pe_st[1] pe_st[2] V H.
  prefs: []
  type: TYPE_NORMAL
- en: apply in_app_iff.
  prefs: []
  type: TYPE_NORMAL
- en: remember (pe_lookup pe_st[1] V) as lookup1.
  prefs: []
  type: TYPE_NORMAL
- en: destruct lookup1 as [n[1]|]. left. apply pe_domain with n[1]. auto.
  prefs: []
  type: TYPE_NORMAL
- en: remember (pe_lookup pe_st[2] V) as lookup2.
  prefs: []
  type: TYPE_NORMAL
- en: destruct lookup2 as [n[2]|]. right. apply pe_domain with n[2]. auto.
  prefs: []
  type: TYPE_NORMAL
- en: inversion H. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint pe_unique (l : list id) : list id :='
  prefs: []
  type: TYPE_NORMAL
- en: match l with
  prefs: []
  type: TYPE_NORMAL
- en: '| [] ⇒ []'
  prefs: []
  type: TYPE_NORMAL
- en: '| x::l ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: 'x :: filter (fun y ⇒ if beq_id x y then false else true) (pe_unique l)'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_unique_correct: ∀l x,'
  prefs: []
  type: TYPE_NORMAL
- en: In x l ↔ In x (pe_unique l).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros l x. induction l as [| h t]. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: simpl in *. split.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *)'
  prefs: []
  type: TYPE_NORMAL
- en: intros. inversion H; clear H.
  prefs: []
  type: TYPE_NORMAL
- en: left. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: destruct (beq_idP h x).
  prefs: []
  type: TYPE_NORMAL
- en: left. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: right. apply filter_In. split.
  prefs: []
  type: TYPE_NORMAL
- en: apply IHt. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite false_beq_id; auto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *)'
  prefs: []
  type: TYPE_NORMAL
- en: intros. inversion H; clear H.
  prefs: []
  type: TYPE_NORMAL
- en: left. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: apply filter_In in H[0]. inversion H[0]. right. apply IHt. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition pe_compare (pe_st[1] pe_st[2] : pe_state) : list id :='
  prefs: []
  type: TYPE_NORMAL
- en: pe_unique (filter (pe_disagree_at pe_st[1] pe_st[2])
  prefs: []
  type: TYPE_NORMAL
- en: (map (@fst _ _) pe_st[1] ++ map (@fst _ _) pe_st[2])).
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_compare_correct: ∀pe_st[1] pe_st[2] V,'
  prefs: []
  type: TYPE_NORMAL
- en: pe_lookup pe_st[1] V = pe_lookup pe_st[2] V ↔
  prefs: []
  type: TYPE_NORMAL
- en: ¬ In V (pe_compare pe_st[1] pe_st[2]).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros pe_st[1] pe_st[2] V.
  prefs: []
  type: TYPE_NORMAL
- en: unfold pe_compare. rewrite ← pe_unique_correct. rewrite filter_In.
  prefs: []
  type: TYPE_NORMAL
- en: split; intros Heq.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *)'
  prefs: []
  type: TYPE_NORMAL
- en: intro. destruct H. unfold pe_disagree_at in H[0]. rewrite Heq in H[0].
  prefs: []
  type: TYPE_NORMAL
- en: destruct (pe_lookup pe_st[2] V).
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← beq_nat_refl in H[0]. inversion H[0].
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[0].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *)'
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (Hagree: pe_disagree_at pe_st[1] pe_st[2] V = false).'
  prefs: []
  type: TYPE_NORMAL
- en: '{ (* Proof of assertion *)'
  prefs: []
  type: TYPE_NORMAL
- en: remember (pe_disagree_at pe_st[1] pe_st[2] V) as disagree.
  prefs: []
  type: TYPE_NORMAL
- en: destruct disagree; [| reflexivity].
  prefs: []
  type: TYPE_NORMAL
- en: apply  pe_disagree_domain in Heqdisagree.
  prefs: []
  type: TYPE_NORMAL
- en: exfalso. apply Heq. split. assumption. reflexivity. }
  prefs: []
  type: TYPE_NORMAL
- en: unfold pe_disagree_at in Hagree.
  prefs: []
  type: TYPE_NORMAL
- en: destruct (pe_lookup pe_st[1] V) as [n[1]|];
  prefs: []
  type: TYPE_NORMAL
- en: destruct (pe_lookup pe_st[2] V) as [n[2]|];
  prefs: []
  type: TYPE_NORMAL
- en: try reflexivity; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite negb_false_iff in Hagree.
  prefs: []
  type: TYPE_NORMAL
- en: apply beq_nat_true in Hagree. subst. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint pe_removes (pe_st:pe_state) (ids : list id) : pe_state :='
  prefs: []
  type: TYPE_NORMAL
- en: match ids with
  prefs: []
  type: TYPE_NORMAL
- en: '| [] ⇒ pe_st'
  prefs: []
  type: TYPE_NORMAL
- en: '| V::ids ⇒ pe_remove (pe_removes pe_st ids) V'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_removes_correct: ∀pe_st ids V,'
  prefs: []
  type: TYPE_NORMAL
- en: pe_lookup (pe_removes pe_st ids) V =
  prefs: []
  type: TYPE_NORMAL
- en: if inb beq_id V ids then None else pe_lookup pe_st V.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros pe_st ids V. induction ids as [| V' ids]. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rewrite pe_remove_correct. rewrite IHids.
  prefs: []
  type: TYPE_NORMAL
- en: compare V' V.
  prefs: []
  type: TYPE_NORMAL
- en: '- rewrite ← beq_id_refl. reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- rewrite false_beq_id; try congruence. reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_compare_removes: ∀pe_st[1] pe_st[2] V,'
  prefs: []
  type: TYPE_NORMAL
- en: pe_lookup (pe_removes pe_st[1] (pe_compare pe_st[1] pe_st[2])) V =
  prefs: []
  type: TYPE_NORMAL
- en: pe_lookup (pe_removes pe_st[2] (pe_compare pe_st[1] pe_st[2])) V.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros pe_st[1] pe_st[2] V. rewrite !pe_removes_correct.
  prefs: []
  type: TYPE_NORMAL
- en: destruct (inbP _ _ beq_idP V (pe_compare pe_st[1] pe_st[2])).
  prefs: []
  type: TYPE_NORMAL
- en: '- reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- apply pe_compare_correct. auto. Qed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_compare_update: ∀pe_st[1] pe_st[2] st,'
  prefs: []
  type: TYPE_NORMAL
- en: pe_update st (pe_removes pe_st[1] (pe_compare pe_st[1] pe_st[2])) =
  prefs: []
  type: TYPE_NORMAL
- en: pe_update st (pe_removes pe_st[2] (pe_compare pe_st[1] pe_st[2])).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros. apply functional_extensionality. intros V.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite !pe_update_correct. rewrite pe_compare_removes. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint assign (pe_st : pe_state) (ids : list id) : com :='
  prefs: []
  type: TYPE_NORMAL
- en: match ids with
  prefs: []
  type: TYPE_NORMAL
- en: '| [] ⇒ SKIP'
  prefs: []
  type: TYPE_NORMAL
- en: '| V::ids ⇒ match pe_lookup pe_st V with'
  prefs: []
  type: TYPE_NORMAL
- en: '| Some n ⇒ (assign pe_st ids;; V ::= ANum n)'
  prefs: []
  type: TYPE_NORMAL
- en: '| None ⇒ assign pe_st ids'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition assigned (pe_st:pe_state) (ids : list id) (st:state) : state :='
  prefs: []
  type: TYPE_NORMAL
- en: fun V ⇒ if inb beq_id V ids then
  prefs: []
  type: TYPE_NORMAL
- en: match pe_lookup pe_st V with
  prefs: []
  type: TYPE_NORMAL
- en: '| Some n ⇒ n'
  prefs: []
  type: TYPE_NORMAL
- en: '| None ⇒ st V'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: else st V.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem assign_removes: ∀pe_st ids st,'
  prefs: []
  type: TYPE_NORMAL
- en: pe_update st pe_st =
  prefs: []
  type: TYPE_NORMAL
- en: pe_update (assigned pe_st ids st) (pe_removes pe_st ids).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros pe_st ids st. apply functional_extensionality. intros V.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite !pe_update_correct. rewrite pe_removes_correct. unfold assigned.
  prefs: []
  type: TYPE_NORMAL
- en: destruct (inbP _ _ beq_idP V ids); destruct (pe_lookup pe_st V); reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma ceval_extensionality: ∀c st st[1] st[2],'
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[1] → (∀V, st[1] V = st[2] V) → c / st ⇓ st[2].
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros c st st[1] st[2] H Heq.
  prefs: []
  type: TYPE_NORMAL
- en: apply functional_extensionality in Heq. rewrite ← Heq. apply H. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem eval_assign: ∀pe_st ids st,'
  prefs: []
  type: TYPE_NORMAL
- en: assign pe_st ids / st ⇓ assigned pe_st ids st.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros pe_st ids st. induction ids as [| V ids]; simpl.
  prefs: []
  type: TYPE_NORMAL
- en: '- (*  *) eapply [ceval_extensionality](PE.html#ceval_extensionality). apply
    [E_Skip](Imp.html#E_Skip). reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* V::ids *)'
  prefs: []
  type: TYPE_NORMAL
- en: remember ([pe_lookup](PE.html#pe_lookup) pe_st V) as lookup. destruct lookup.
  prefs: []
  type: TYPE_NORMAL
- en: + (* Some *) eapply [E_Seq](Imp.html#E_Seq). apply IHids. unfold [assigned](PE.html#assigned).
    simpl.
  prefs: []
  type: TYPE_NORMAL
- en: eapply [ceval_extensionality](PE.html#ceval_extensionality). apply [E_Ass](Imp.html#E_Ass).
    simpl. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: intros V[0]. unfold [t_update](Maps.html#t_update). compare V V[0].
  prefs: []
  type: TYPE_NORMAL
- en: '* (* equal *) rewrite ← Heqlookup. rewrite ← [beq_id_refl](Maps.html#beq_id_refl).
    reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '* (* not equal *) rewrite [false_beq_id](Maps.html#false_beq_id); simpl; congruence.'
  prefs: []
  type: TYPE_NORMAL
- en: + (* None *) eapply [ceval_extensionality](PE.html#ceval_extensionality). apply
    IHids.
  prefs: []
  type: TYPE_NORMAL
- en: unfold [assigned](PE.html#assigned). intros V[0]. simpl. compare V V[0].
  prefs: []
  type: TYPE_NORMAL
- en: '* (* equal *) rewrite ← Heqlookup.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← [beq_id_refl](Maps.html#beq_id_refl).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([inbP](PE.html#inbP) _ _ [beq_idP](Maps.html#beq_idP) V ids); reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '* (* not equal *) rewrite [false_beq_id](Maps.html#false_beq_id); simpl; congruence.'
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Reserved Notation "c1 '/' st '⇓' c1' '/' st'"
  prefs: []
  type: TYPE_NORMAL
- en: (at level 40, st at level 39, c[1]' at level 39).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive pe_com : com → pe_state → com → pe_state → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_Skip : ∀pe_st,'
  prefs: []
  type: TYPE_NORMAL
- en: SKIP / pe_st ⇓ SKIP / pe_st
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_AssStatic : ∀pe_st a[1] n[1] l,'
  prefs: []
  type: TYPE_NORMAL
- en: pe_aexp pe_st a[1] = ANum n[1] →
  prefs: []
  type: TYPE_NORMAL
- en: (l ::= a[1]) / pe_st ⇓ SKIP / pe_add pe_st l n[1]
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_AssDynamic : ∀pe_st a[1] a[1]'' l,'
  prefs: []
  type: TYPE_NORMAL
- en: pe_aexp pe_st a[1] = a[1]' →
  prefs: []
  type: TYPE_NORMAL
- en: (∀n, a[1]' ≠ ANum n) →
  prefs: []
  type: TYPE_NORMAL
- en: (l ::= a[1]) / pe_st ⇓ (l ::= a[1]') / pe_remove pe_st l
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_Seq : ∀pe_st pe_st'' pe_st'''' c[1] c[2] c[1]'' c[2]'','
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / pe_st  ⇓ c[1]' / pe_st' →
  prefs: []
  type: TYPE_NORMAL
- en: c[2] / pe_st' ⇓ c[2]' / pe_st'' →
  prefs: []
  type: TYPE_NORMAL
- en: (c[1] ;; c[2]) / pe_st ⇓ (c[1]' ;; c[2]') / pe_st''
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_IfTrue : ∀pe_st pe_st'' b[1] c[1] c[2] c[1]'','
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp pe_st b[1] = BTrue →
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / pe_st ⇓ c[1]' / pe_st' →
  prefs: []
  type: TYPE_NORMAL
- en: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st ⇓ c[1]' / pe_st'
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_IfFalse : ∀pe_st pe_st'' b[1] c[1] c[2] c[2]'','
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp pe_st b[1] = BFalse →
  prefs: []
  type: TYPE_NORMAL
- en: c[2] / pe_st ⇓ c[2]' / pe_st' →
  prefs: []
  type: TYPE_NORMAL
- en: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st ⇓ c[2]' / pe_st'
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_If : ∀pe_st pe_st[1] pe_st[2] b[1] c[1] c[2] c[1]'' c[2]'','
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp pe_st b[1] ≠ BTrue →
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp pe_st b[1] ≠ BFalse →
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / pe_st ⇓ c[1]' / pe_st[1] →
  prefs: []
  type: TYPE_NORMAL
- en: c[2] / pe_st ⇓ c[2]' / pe_st[2] →
  prefs: []
  type: TYPE_NORMAL
- en: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st
  prefs: []
  type: TYPE_NORMAL
- en: ⇓ (IFB pe_bexp pe_st b[1]
  prefs: []
  type: TYPE_NORMAL
- en: THEN c[1]' ;; assign pe_st[1] (pe_compare pe_st[1] pe_st[2])
  prefs: []
  type: TYPE_NORMAL
- en: ELSE c[2]' ;; assign pe_st[2] (pe_compare pe_st[1] pe_st[2]) FI)
  prefs: []
  type: TYPE_NORMAL
- en: / pe_removes pe_st[1] (pe_compare pe_st[1] pe_st[2])
  prefs: []
  type: TYPE_NORMAL
- en: where "c1 '/' st '⇓' c1' '/' st'" := (pe_com c[1] st c[1]' st').
  prefs: []
  type: TYPE_NORMAL
- en: Hint Constructors pe_com.
  prefs: []
  type: TYPE_NORMAL
- en: Hint Constructors ceval.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Example pe_example1:'
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= ANum 3 ;; Y ::= AMult (AId Z) (APlus (AId X) (AId X)))
  prefs: []
  type: TYPE_NORMAL
- en: / [] ⇓ (SKIP;; Y ::= AMult (AId Z) (ANum 6)) / [(X,3)].
  prefs: []
  type: TYPE_NORMAL
- en: Proof. eapply PE_Seq. eapply PE_AssStatic. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: eapply PE_AssDynamic. reflexivity. intros n H. inversion H. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example pe_example2:'
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= ANum 3 ;; IFB BLe (AId X) (ANum 4) THEN X ::= ANum 4 ELSE SKIP FI)
  prefs: []
  type: TYPE_NORMAL
- en: / [] ⇓ (SKIP;; SKIP) / [(X,4)].
  prefs: []
  type: TYPE_NORMAL
- en: Proof. eapply PE_Seq. eapply PE_AssStatic. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: eapply PE_IfTrue. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: eapply PE_AssStatic. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example pe_example3:'
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= ANum 3;;
  prefs: []
  type: TYPE_NORMAL
- en: IFB BLe (AId Y) (ANum 4) THEN
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= ANum 4;;
  prefs: []
  type: TYPE_NORMAL
- en: IFB BEq (AId X) (AId Y) THEN Y ::= ANum 999 ELSE SKIP FI
  prefs: []
  type: TYPE_NORMAL
- en: ELSE SKIP FI) / []
  prefs: []
  type: TYPE_NORMAL
- en: ⇓ (SKIP;;
  prefs: []
  type: TYPE_NORMAL
- en: IFB BLe (AId Y) (ANum 4) THEN
  prefs: []
  type: TYPE_NORMAL
- en: (SKIP;; SKIP);; (SKIP;; Y ::= ANum 4)
  prefs: []
  type: TYPE_NORMAL
- en: ELSE SKIP;; SKIP FI)
  prefs: []
  type: TYPE_NORMAL
- en: / [(X,3)].
  prefs: []
  type: TYPE_NORMAL
- en: Proof. erewrite f_equal2 with (f := fun c st ⇒ _ / _ ⇓ c / st).
  prefs: []
  type: TYPE_NORMAL
- en: eapply PE_Seq. eapply PE_AssStatic. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: eapply PE_If; intuition eauto; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: econstructor. eapply PE_AssStatic. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: eapply PE_IfFalse. reflexivity. econstructor.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Reserved Notation "c' '/' pe_st' '/' st '⇓' st''"
  prefs: []
  type: TYPE_NORMAL
- en: (at level 40, pe_st' at level 39, st at level 39).
  prefs: []
  type: TYPE_NORMAL
- en: Inductive pe_ceval
  prefs: []
  type: TYPE_NORMAL
- en: '(c'':com) (pe_st'':pe_state) (st:state) (st'''':state) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| pe_ceval_intro : ∀st'','
  prefs: []
  type: TYPE_NORMAL
- en: c' / st ⇓ st' →
  prefs: []
  type: TYPE_NORMAL
- en: pe_update st' pe_st' = st'' →
  prefs: []
  type: TYPE_NORMAL
- en: c' / pe_st' / st ⇓ st''
  prefs: []
  type: TYPE_NORMAL
- en: where "c' '/' pe_st' '/' st '⇓' st''" := (pe_ceval c' pe_st' st st'').
  prefs: []
  type: TYPE_NORMAL
- en: Hint Constructors pe_ceval.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_com_complete:'
  prefs: []
  type: TYPE_NORMAL
- en: ∀c pe_st pe_st' c', c / pe_st ⇓ c' / pe_st' →
  prefs: []
  type: TYPE_NORMAL
- en: ∀st st'',
  prefs: []
  type: TYPE_NORMAL
- en: (c / pe_update st pe_st ⇓ st'') →
  prefs: []
  type: TYPE_NORMAL
- en: (c' / pe_st' / st ⇓ st'').
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros c pe_st pe_st' c' Hpe.
  prefs: []
  type: TYPE_NORMAL
- en: induction Hpe; intros st st'' Heval;
  prefs: []
  type: TYPE_NORMAL
- en: try (inversion Heval; subst;
  prefs: []
  type: TYPE_NORMAL
- en: try (rewrite → pe_bexp_correct, → H in *; solve_by_invert);
  prefs: []
  type: TYPE_NORMAL
- en: '[]);'
  prefs: []
  type: TYPE_NORMAL
- en: eauto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_AssStatic *) econstructor. econstructor.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_aexp_correct. rewrite ← pe_update_update_add.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → H. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_AssDynamic *) econstructor. econstructor. reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_aexp_correct. rewrite ← pe_update_update_remove.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_Seq *)'
  prefs: []
  type: TYPE_NORMAL
- en: edestruct IHHpe1. eassumption. subst.
  prefs: []
  type: TYPE_NORMAL
- en: edestruct IHHpe2. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: eauto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_If *) inversion Heval; subst.'
  prefs: []
  type: TYPE_NORMAL
- en: + (* E'IfTrue *) edestruct IHHpe1. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: econstructor. apply E_IfTrue. rewrite ← pe_bexp_correct. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: eapply E_Seq. eassumption. apply eval_assign.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← assign_removes. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_IfFalse *) edestruct IHHpe2. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: econstructor. apply E_IfFalse. rewrite ← pe_bexp_correct. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: eapply E_Seq. eassumption. apply eval_assign.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_compare_update.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← assign_removes. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_com_sound:'
  prefs: []
  type: TYPE_NORMAL
- en: ∀c pe_st pe_st' c', c / pe_st ⇓ c' / pe_st' →
  prefs: []
  type: TYPE_NORMAL
- en: ∀st st'',
  prefs: []
  type: TYPE_NORMAL
- en: (c' / pe_st' / st ⇓ st'') →
  prefs: []
  type: TYPE_NORMAL
- en: (c / pe_update st pe_st ⇓ st'').
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros c pe_st pe_st' c' Hpe.
  prefs: []
  type: TYPE_NORMAL
- en: induction Hpe;
  prefs: []
  type: TYPE_NORMAL
- en: intros st st'' [st' Heval Heq];
  prefs: []
  type: TYPE_NORMAL
- en: try (inversion Heval; []; subst); auto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_AssStatic *) rewrite ← pe_update_update_add. apply E_Ass.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_aexp_correct. rewrite → H. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_AssDynamic *) rewrite ← pe_update_update_remove. apply E_Ass.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← pe_aexp_correct. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_Seq *) eapply E_Seq; eauto.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_IfTrue *) apply E_IfTrue.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_bexp_correct. rewrite → H. reflexivity. eauto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_IfFalse *) apply E_IfFalse.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_bexp_correct. rewrite → H. reflexivity. eauto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_If *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion Heval; subst; inversion H[7];
  prefs: []
  type: TYPE_NORMAL
- en: (eapply ceval_deterministic in H[8]; [| apply eval_assign]); subst.
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_IfTrue *)
  prefs: []
  type: TYPE_NORMAL
- en: apply E_IfTrue. rewrite → pe_bexp_correct. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← assign_removes. eauto.
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_IfFalse *)
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_compare_update.
  prefs: []
  type: TYPE_NORMAL
- en: apply E_IfFalse. rewrite → pe_bexp_correct. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← assign_removes. eauto.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Corollary pe_com_correct:'
  prefs: []
  type: TYPE_NORMAL
- en: ∀c pe_st pe_st' c', c / pe_st ⇓ c' / pe_st' →
  prefs: []
  type: TYPE_NORMAL
- en: ∀st st'',
  prefs: []
  type: TYPE_NORMAL
- en: (c / pe_update st pe_st ⇓ st'') ↔
  prefs: []
  type: TYPE_NORMAL
- en: (c' / pe_st' / st ⇓ st'').
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros c pe_st pe_st' c' H st st''. split.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *) apply pe_com_complete. apply H.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *) apply pe_com_sound. apply H.'
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: WHILE BLe (ANum 1) (AId X) DO
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= AMult (AId Y) (AId Y);;
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (AId X) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: If we know neither X nor Y statically, then the entire loop is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: dynamic and the residual command should be the same.  If we know
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: X but not Y, then the loop can be unrolled all the way and the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: residual command should be, for example,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: X ::= ANum 0;;
  prefs: []
  type: TYPE_NORMAL
- en: WHILE BLe (ANum 1) (AId Y) DO
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= AMinus (AId Y) (ANum 1);;
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (ANum 1) (AId X)
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: The value of X alternates between 0 and 1 during the loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ideally, we would like to unroll this loop, not all the way but
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*two-fold*, into something like'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Module Loop.
  prefs: []
  type: TYPE_NORMAL
- en: Reserved Notation "c1 '/' st '⇓' c1' '/' st' '/' c''"
  prefs: []
  type: TYPE_NORMAL
- en: (at level 40, st at level 39, c[1]' at level 39, st' at level 39).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive pe_com : com → pe_state → com → pe_state → com → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_Skip : ∀pe_st,'
  prefs: []
  type: TYPE_NORMAL
- en: SKIP / pe_st ⇓ SKIP / pe_st / SKIP
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_AssStatic : ∀pe_st a[1] n[1] l,'
  prefs: []
  type: TYPE_NORMAL
- en: pe_aexp pe_st a[1] = ANum n[1] →
  prefs: []
  type: TYPE_NORMAL
- en: (l ::= a[1]) / pe_st ⇓ SKIP / pe_add pe_st l n[1] / SKIP
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_AssDynamic : ∀pe_st a[1] a[1]'' l,'
  prefs: []
  type: TYPE_NORMAL
- en: pe_aexp pe_st a[1] = a[1]' →
  prefs: []
  type: TYPE_NORMAL
- en: (∀n, a[1]' ≠ ANum n) →
  prefs: []
  type: TYPE_NORMAL
- en: (l ::= a[1]) / pe_st ⇓ (l ::= a[1]') / pe_remove pe_st l / SKIP
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_Seq : ∀pe_st pe_st'' pe_st'''' c[1] c[2] c[1]'' c[2]'' c'''','
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / pe_st  ⇓ c[1]' / pe_st' / SKIP →
  prefs: []
  type: TYPE_NORMAL
- en: c[2] / pe_st' ⇓ c[2]' / pe_st'' / c'' →
  prefs: []
  type: TYPE_NORMAL
- en: (c[1] ;; c[2]) / pe_st ⇓ (c[1]' ;; c[2]') / pe_st'' / c''
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_IfTrue : ∀pe_st pe_st'' b[1] c[1] c[2] c[1]'' c'''','
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp pe_st b[1] = BTrue →
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / pe_st ⇓ c[1]' / pe_st' / c'' →
  prefs: []
  type: TYPE_NORMAL
- en: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st ⇓ c[1]' / pe_st' / c''
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_IfFalse : ∀pe_st pe_st'' b[1] c[1] c[2] c[2]'' c'''','
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp pe_st b[1] = BFalse →
  prefs: []
  type: TYPE_NORMAL
- en: c[2] / pe_st ⇓ c[2]' / pe_st' / c'' →
  prefs: []
  type: TYPE_NORMAL
- en: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st ⇓ c[2]' / pe_st' / c''
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_If : ∀pe_st pe_st[1] pe_st[2] b[1] c[1] c[2] c[1]'' c[2]'' c'''','
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp pe_st b[1] ≠ BTrue →
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp pe_st b[1] ≠ BFalse →
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / pe_st ⇓ c[1]' / pe_st[1] / c'' →
  prefs: []
  type: TYPE_NORMAL
- en: c[2] / pe_st ⇓ c[2]' / pe_st[2] / c'' →
  prefs: []
  type: TYPE_NORMAL
- en: (IFB b[1] THEN c[1] ELSE c[2] FI) / pe_st
  prefs: []
  type: TYPE_NORMAL
- en: ⇓ (IFB pe_bexp pe_st b[1]
  prefs: []
  type: TYPE_NORMAL
- en: THEN c[1]' ;; assign pe_st[1] (pe_compare pe_st[1] pe_st[2])
  prefs: []
  type: TYPE_NORMAL
- en: ELSE c[2]' ;; assign pe_st[2] (pe_compare pe_st[1] pe_st[2]) FI)
  prefs: []
  type: TYPE_NORMAL
- en: / pe_removes pe_st[1] (pe_compare pe_st[1] pe_st[2])
  prefs: []
  type: TYPE_NORMAL
- en: / c''
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_WhileEnd : ∀pe_st b[1] c[1],'
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp pe_st b[1] = BFalse →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b[1] DO c[1] END) / pe_st ⇓ SKIP / pe_st / SKIP
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_WhileLoop : ∀pe_st pe_st'' pe_st'''' b[1] c[1] c[1]'' c[2]'' c[2]'''','
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp pe_st b[1] = BTrue →
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / pe_st ⇓ c[1]' / pe_st' / SKIP →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b[1] DO c[1] END) / pe_st' ⇓ c[2]' / pe_st'' / c[2]'' →
  prefs: []
  type: TYPE_NORMAL
- en: pe_compare pe_st pe_st'' ≠ [] →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b[1] DO c[1] END) / pe_st ⇓ (c[1]';;c[2]') / pe_st'' / c[2]''
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_While : ∀pe_st pe_st'' pe_st'''' b[1] c[1] c[1]'' c[2]'' c[2]'''','
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp pe_st b[1] ≠ BFalse →
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp pe_st b[1] ≠ BTrue →
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / pe_st ⇓ c[1]' / pe_st' / SKIP →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b[1] DO c[1] END) / pe_st' ⇓ c[2]' / pe_st'' / c[2]'' →
  prefs: []
  type: TYPE_NORMAL
- en: pe_compare pe_st pe_st'' ≠ [] →
  prefs: []
  type: TYPE_NORMAL
- en: (c[2]'' = SKIP ∨ c[2]'' = WHILE b[1] DO c[1] END) →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b[1] DO c[1] END) / pe_st
  prefs: []
  type: TYPE_NORMAL
- en: ⇓ (IFB pe_bexp pe_st b[1]
  prefs: []
  type: TYPE_NORMAL
- en: THEN c[1]';; c[2]';; assign pe_st'' (pe_compare pe_st pe_st'')
  prefs: []
  type: TYPE_NORMAL
- en: ELSE assign pe_st (pe_compare pe_st pe_st'') FI)
  prefs: []
  type: TYPE_NORMAL
- en: / pe_removes pe_st (pe_compare pe_st pe_st'')
  prefs: []
  type: TYPE_NORMAL
- en: / c[2]''
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_WhileFixedEnd : ∀pe_st b[1] c[1],'
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp pe_st b[1] ≠ BFalse →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b[1] DO c[1] END) / pe_st ⇓ SKIP / pe_st / (WHILE b[1] DO c[1] END)
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_WhileFixedLoop : ∀pe_st pe_st'' pe_st'''' b[1] c[1] c[1]'' c[2]'','
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp pe_st b[1] = BTrue →
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / pe_st ⇓ c[1]' / pe_st' / SKIP →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b[1] DO c[1] END) / pe_st'
  prefs: []
  type: TYPE_NORMAL
- en: ⇓ c[2]' / pe_st'' / (WHILE b[1] DO c[1] END) →
  prefs: []
  type: TYPE_NORMAL
- en: pe_compare pe_st pe_st'' = [] →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b[1] DO c[1] END) / pe_st
  prefs: []
  type: TYPE_NORMAL
- en: ⇓ (WHILE BTrue DO SKIP END) / pe_st / SKIP
  prefs: []
  type: TYPE_NORMAL
- en: '(* Because we have an infinite loop, we should actually          start to throw away the rest of the program:
             (WHILE b[1] DO c[1] END) / pe_st          \\ SKIP / pe_st / (WHILE BTrue DO SKIP END) *)'
  prefs: []
  type: TYPE_NORMAL
- en: '| PE_WhileFixed : ∀pe_st pe_st'' pe_st'''' b[1] c[1] c[1]'' c[2]'','
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp pe_st b[1] ≠ BFalse →
  prefs: []
  type: TYPE_NORMAL
- en: pe_bexp pe_st b[1] ≠ BTrue →
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / pe_st ⇓ c[1]' / pe_st' / SKIP →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b[1] DO c[1] END) / pe_st'
  prefs: []
  type: TYPE_NORMAL
- en: ⇓ c[2]' / pe_st'' / (WHILE b[1] DO c[1] END) →
  prefs: []
  type: TYPE_NORMAL
- en: pe_compare pe_st pe_st'' = [] →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b[1] DO c[1] END) / pe_st
  prefs: []
  type: TYPE_NORMAL
- en: ⇓ (WHILE pe_bexp pe_st b[1] DO c[1]';; c[2]' END) / pe_st / SKIP
  prefs: []
  type: TYPE_NORMAL
- en: where "c1 '/' st '⇓' c1' '/' st' '/' c''" := (pe_com c[1] st c[1]' st' c'').
  prefs: []
  type: TYPE_NORMAL
- en: Hint Constructors pe_com.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Ltac step i :=
  prefs: []
  type: TYPE_NORMAL
- en: (eapply i; intuition eauto; try solve_by_invert);
  prefs: []
  type: TYPE_NORMAL
- en: repeat (try eapply PE_Seq;
  prefs: []
  type: TYPE_NORMAL
- en: try (eapply PE_AssStatic; simpl; reflexivity);
  prefs: []
  type: TYPE_NORMAL
- en: try (eapply PE_AssDynamic;
  prefs: []
  type: TYPE_NORMAL
- en: '[ simpl; reflexivity'
  prefs: []
  type: TYPE_NORMAL
- en: '| intuition eauto; solve_by_invert])).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition square_loop: com :='
  prefs: []
  type: TYPE_NORMAL
- en: WHILE BLe (ANum 1) (AId X) DO
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= AMult (AId Y) (AId Y);;
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (AId X) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: END.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example pe_loop_example1:'
  prefs: []
  type: TYPE_NORMAL
- en: square_loop / []
  prefs: []
  type: TYPE_NORMAL
- en: ⇓ (WHILE BLe (ANum 1) (AId X) DO
  prefs: []
  type: TYPE_NORMAL
- en: (Y ::= AMult (AId Y) (AId Y);;
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (AId X) (ANum 1));; SKIP
  prefs: []
  type: TYPE_NORMAL
- en: END) / [] / SKIP.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. erewrite f_equal2 with (f := fun c st ⇒ _ / _ ⇓ c / st / SKIP).
  prefs: []
  type: TYPE_NORMAL
- en: step PE_WhileFixed. step PE_WhileFixedEnd. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example pe_loop_example2:'
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= ANum 3;; square_loop) / []
  prefs: []
  type: TYPE_NORMAL
- en: ⇓ (SKIP;;
  prefs: []
  type: TYPE_NORMAL
- en: (Y ::= AMult (AId Y) (AId Y);; SKIP);;
  prefs: []
  type: TYPE_NORMAL
- en: (Y ::= AMult (AId Y) (AId Y);; SKIP);;
  prefs: []
  type: TYPE_NORMAL
- en: (Y ::= AMult (AId Y) (AId Y);; SKIP);;
  prefs: []
  type: TYPE_NORMAL
- en: SKIP) / [(X,0)] / SKIP.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. erewrite f_equal2 with (f := fun c st ⇒ _ / _ ⇓ c / st / SKIP).
  prefs: []
  type: TYPE_NORMAL
- en: eapply PE_Seq. eapply PE_AssStatic. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: step PE_WhileLoop.
  prefs: []
  type: TYPE_NORMAL
- en: step PE_WhileLoop.
  prefs: []
  type: TYPE_NORMAL
- en: step PE_WhileLoop.
  prefs: []
  type: TYPE_NORMAL
- en: step PE_WhileEnd.
  prefs: []
  type: TYPE_NORMAL
- en: inversion H. inversion H. inversion H.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example pe_loop_example3:'
  prefs: []
  type: TYPE_NORMAL
- en: (Z ::= ANum 3;; subtract_slowly) / []
  prefs: []
  type: TYPE_NORMAL
- en: ⇓ (SKIP;;
  prefs: []
  type: TYPE_NORMAL
- en: IFB BNot (BEq (AId X) (ANum 0)) THEN
  prefs: []
  type: TYPE_NORMAL
- en: (SKIP;; X ::= AMinus (AId X) (ANum 1));;
  prefs: []
  type: TYPE_NORMAL
- en: IFB BNot (BEq (AId X) (ANum 0)) THEN
  prefs: []
  type: TYPE_NORMAL
- en: (SKIP;; X ::= AMinus (AId X) (ANum 1));;
  prefs: []
  type: TYPE_NORMAL
- en: IFB BNot (BEq (AId X) (ANum 0)) THEN
  prefs: []
  type: TYPE_NORMAL
- en: (SKIP;; X ::= AMinus (AId X) (ANum 1));;
  prefs: []
  type: TYPE_NORMAL
- en: WHILE BNot (BEq (AId X) (ANum 0)) DO
  prefs: []
  type: TYPE_NORMAL
- en: (SKIP;; X ::= AMinus (AId X) (ANum 1));; SKIP
  prefs: []
  type: TYPE_NORMAL
- en: END;;
  prefs: []
  type: TYPE_NORMAL
- en: SKIP;; Z ::= ANum 0
  prefs: []
  type: TYPE_NORMAL
- en: ELSE SKIP;; Z ::= ANum 1 FI;; SKIP
  prefs: []
  type: TYPE_NORMAL
- en: ELSE SKIP;; Z ::= ANum 2 FI;; SKIP
  prefs: []
  type: TYPE_NORMAL
- en: ELSE SKIP;; Z ::= ANum 3 FI) / [] / SKIP.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. erewrite f_equal2 with (f := fun c st ⇒ _ / _ ⇓ c / st / SKIP).
  prefs: []
  type: TYPE_NORMAL
- en: eapply PE_Seq. eapply PE_AssStatic. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: step PE_While.
  prefs: []
  type: TYPE_NORMAL
- en: step PE_While.
  prefs: []
  type: TYPE_NORMAL
- en: step PE_While.
  prefs: []
  type: TYPE_NORMAL
- en: step PE_WhileFixed.
  prefs: []
  type: TYPE_NORMAL
- en: step PE_WhileFixedEnd.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity. inversion H. inversion H. inversion H.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example pe_loop_example4:'
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= ANum 0;;
  prefs: []
  type: TYPE_NORMAL
- en: WHILE BLe (AId X) (ANum 2) DO
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (ANum 1) (AId X)
  prefs: []
  type: TYPE_NORMAL
- en: END) / [] ⇓ (SKIP;; WHILE BTrue DO SKIP END) / [(X,0)] / SKIP.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. erewrite f_equal2 with (f := fun c st ⇒ _ / _ ⇓ c / st / SKIP).
  prefs: []
  type: TYPE_NORMAL
- en: eapply PE_Seq. eapply PE_AssStatic. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: step PE_WhileFixedLoop.
  prefs: []
  type: TYPE_NORMAL
- en: step PE_WhileLoop.
  prefs: []
  type: TYPE_NORMAL
- en: step PE_WhileFixedEnd.
  prefs: []
  type: TYPE_NORMAL
- en: inversion H. reflexivity. reflexivity. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Reserved Notation "c1 '/' st '⇓' st' '#' n"
  prefs: []
  type: TYPE_NORMAL
- en: (at level 40, st at level 39, st' at level 39).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive ceval_count : com → state → state → nat → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| E''Skip : ∀st,'
  prefs: []
  type: TYPE_NORMAL
- en: 'SKIP / st ⇓ st # 0'
  prefs: []
  type: TYPE_NORMAL
- en: '| E''Ass  : ∀st a[1] n l,'
  prefs: []
  type: TYPE_NORMAL
- en: aeval st a[1] = n →
  prefs: []
  type: TYPE_NORMAL
- en: '(l ::= a[1]) / st ⇓ (t_update st l n) # 0'
  prefs: []
  type: TYPE_NORMAL
- en: '| E''Seq : ∀c[1] c[2] st st'' st'''' n[1] n[2],'
  prefs: []
  type: TYPE_NORMAL
- en: 'c[1] / st  ⇓ st''  # n[1] →'
  prefs: []
  type: TYPE_NORMAL
- en: 'c[2] / st'' ⇓ st'''' # n[2] →'
  prefs: []
  type: TYPE_NORMAL
- en: '(c[1] ;; c[2]) / st ⇓ st'''' # (n[1] + n[2])'
  prefs: []
  type: TYPE_NORMAL
- en: '| E''IfTrue : ∀st st'' b[1] c[1] c[2] n,'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = true →
  prefs: []
  type: TYPE_NORMAL
- en: 'c[1] / st ⇓ st'' # n →'
  prefs: []
  type: TYPE_NORMAL
- en: '(IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'' # n'
  prefs: []
  type: TYPE_NORMAL
- en: '| E''IfFalse : ∀st st'' b[1] c[1] c[2] n,'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = false →
  prefs: []
  type: TYPE_NORMAL
- en: 'c[2] / st ⇓ st'' # n →'
  prefs: []
  type: TYPE_NORMAL
- en: '(IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'' # n'
  prefs: []
  type: TYPE_NORMAL
- en: '| E''WhileEnd : ∀b[1] st c[1],'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = false →
  prefs: []
  type: TYPE_NORMAL
- en: '(WHILE b[1] DO c[1] END) / st ⇓ st # 0'
  prefs: []
  type: TYPE_NORMAL
- en: '| E''WhileLoop : ∀st st'' st'''' b[1] c[1] n[1] n[2],'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = true →
  prefs: []
  type: TYPE_NORMAL
- en: 'c[1] / st ⇓ st'' # n[1] →'
  prefs: []
  type: TYPE_NORMAL
- en: '(WHILE b[1] DO c[1] END) / st'' ⇓ st'''' # n[2] →'
  prefs: []
  type: TYPE_NORMAL
- en: '(WHILE b[1] DO c[1] END) / st ⇓ st'''' # S (n[1] + n[2])'
  prefs: []
  type: TYPE_NORMAL
- en: 'where "c1 ''/'' st ''⇓'' st'' # n" := (ceval_count c[1] st st'' n).'
  prefs: []
  type: TYPE_NORMAL
- en: Hint Constructors ceval_count.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem ceval_count_complete: ∀c st st'','
  prefs: []
  type: TYPE_NORMAL
- en: 'c / st ⇓ st'' → ∃n, c / st ⇓ st'' # n.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros c st st' Heval.
  prefs: []
  type: TYPE_NORMAL
- en: induction Heval;
  prefs: []
  type: TYPE_NORMAL
- en: try inversion IHHeval1;
  prefs: []
  type: TYPE_NORMAL
- en: try inversion IHHeval2;
  prefs: []
  type: TYPE_NORMAL
- en: try inversion IHHeval;
  prefs: []
  type: TYPE_NORMAL
- en: eauto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem ceval_count_sound: ∀c st st'' n,'
  prefs: []
  type: TYPE_NORMAL
- en: 'c / st ⇓ st'' # n → c / st ⇓ st''.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros c st st' n Heval. induction Heval; eauto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_compare_nil_lookup: ∀pe_st[1] pe_st[2],'
  prefs: []
  type: TYPE_NORMAL
- en: pe_compare pe_st[1] pe_st[2] = [] →
  prefs: []
  type: TYPE_NORMAL
- en: ∀V, pe_lookup pe_st[1] V = pe_lookup pe_st[2] V.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros pe_st[1] pe_st[2] H V.
  prefs: []
  type: TYPE_NORMAL
- en: apply (pe_compare_correct pe_st[1] pe_st[2] V).
  prefs: []
  type: TYPE_NORMAL
- en: rewrite H. intro. inversion H[0]. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_compare_nil_update: ∀pe_st[1] pe_st[2],'
  prefs: []
  type: TYPE_NORMAL
- en: pe_compare pe_st[1] pe_st[2] = [] →
  prefs: []
  type: TYPE_NORMAL
- en: ∀st, pe_update st pe_st[1] = pe_update st pe_st[2].
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros pe_st[1] pe_st[2] H st.
  prefs: []
  type: TYPE_NORMAL
- en: apply functional_extensionality. intros V.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite !pe_update_correct.
  prefs: []
  type: TYPE_NORMAL
- en: apply pe_compare_nil_lookup with (V:=V) in H.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite H. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Reserved Notation "c' '/' pe_st' '/' c'' '/' st '⇓' st'' '#' n"
  prefs: []
  type: TYPE_NORMAL
- en: (at level 40, pe_st' at level 39, c'' at level 39,
  prefs: []
  type: TYPE_NORMAL
- en: st at level 39, st'' at level 39).
  prefs: []
  type: TYPE_NORMAL
- en: Inductive pe_ceval_count (c':com) (pe_st':pe_state) (c'':com)
  prefs: []
  type: TYPE_NORMAL
- en: '(st:state) (st'''':state) (n:nat) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| pe_ceval_count_intro : ∀st'' n'','
  prefs: []
  type: TYPE_NORMAL
- en: c' / st ⇓ st' →
  prefs: []
  type: TYPE_NORMAL
- en: 'c'''' / pe_update st'' pe_st'' ⇓ st'''' # n'' →'
  prefs: []
  type: TYPE_NORMAL
- en: n' ≤ n →
  prefs: []
  type: TYPE_NORMAL
- en: 'c'' / pe_st'' / c'''' / st ⇓ st'''' # n'
  prefs: []
  type: TYPE_NORMAL
- en: where "c' '/' pe_st' '/' c'' '/' st '⇓' st'' '#' n" :=
  prefs: []
  type: TYPE_NORMAL
- en: (pe_ceval_count c' pe_st' c'' st st'' n).
  prefs: []
  type: TYPE_NORMAL
- en: Hint Constructors pe_ceval_count.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma pe_ceval_count_le: ∀c'' pe_st'' c'''' st st'''' n n'','
  prefs: []
  type: TYPE_NORMAL
- en: n' ≤ n →
  prefs: []
  type: TYPE_NORMAL
- en: 'c'' / pe_st'' / c'''' / st ⇓ st'''' # n'' →'
  prefs: []
  type: TYPE_NORMAL
- en: 'c'' / pe_st'' / c'''' / st ⇓ st'''' # n.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros c' pe_st' c'' st st'' n n' Hle H. inversion H.
  prefs: []
  type: TYPE_NORMAL
- en: econstructor; try eassumption. omega. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_com_complete:'
  prefs: []
  type: TYPE_NORMAL
- en: ∀c pe_st pe_st' c' c'', c / pe_st ⇓ c' / pe_st' / c'' →
  prefs: []
  type: TYPE_NORMAL
- en: ∀st st'' n,
  prefs: []
  type: TYPE_NORMAL
- en: '(c / pe_update st pe_st ⇓ st'''' # n) →'
  prefs: []
  type: TYPE_NORMAL
- en: '(c'' / pe_st'' / c'''' / st ⇓ st'''' # n).'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros c pe_st pe_st' c' c'' Hpe.
  prefs: []
  type: TYPE_NORMAL
- en: induction Hpe; intros st st'' n Heval;
  prefs: []
  type: TYPE_NORMAL
- en: try (inversion Heval; subst;
  prefs: []
  type: TYPE_NORMAL
- en: try (rewrite → pe_bexp_correct, → H in *; solve_by_invert);
  prefs: []
  type: TYPE_NORMAL
- en: '[]);'
  prefs: []
  type: TYPE_NORMAL
- en: eauto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_AssStatic *) econstructor. econstructor.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_aexp_correct. rewrite ← pe_update_update_add.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → H. apply E'Skip. auto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_AssDynamic *) econstructor. econstructor. reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_aexp_correct. rewrite ← pe_update_update_remove.
  prefs: []
  type: TYPE_NORMAL
- en: apply E'Skip. auto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_Seq *)'
  prefs: []
  type: TYPE_NORMAL
- en: edestruct IHHpe1 as [? ? ? Hskip ?]. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hskip. subst.
  prefs: []
  type: TYPE_NORMAL
- en: edestruct IHHpe2. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: econstructor; eauto. omega.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_If *) inversion Heval; subst.'
  prefs: []
  type: TYPE_NORMAL
- en: + (* E'IfTrue *) edestruct IHHpe1. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: econstructor. apply E_IfTrue. rewrite ← pe_bexp_correct. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: eapply E_Seq. eassumption. apply eval_assign.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← assign_removes. eassumption. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_IfFalse *) edestruct IHHpe2. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: econstructor. apply E_IfFalse. rewrite ← pe_bexp_correct. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: eapply E_Seq. eassumption. apply eval_assign.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_compare_update.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← assign_removes. eassumption. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_WhileLoop *)'
  prefs: []
  type: TYPE_NORMAL
- en: edestruct IHHpe1 as [? ? ? Hskip ?]. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hskip. subst.
  prefs: []
  type: TYPE_NORMAL
- en: edestruct IHHpe2. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: econstructor; eauto. omega.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_While *) inversion Heval; subst.'
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_WhileEnd *) econstructor. apply E_IfFalse.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← pe_bexp_correct. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: apply eval_assign.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← assign_removes. inversion H[2]; subst; auto.
  prefs: []
  type: TYPE_NORMAL
- en: auto.
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_WhileLoop *)
  prefs: []
  type: TYPE_NORMAL
- en: edestruct IHHpe1 as [? ? ? Hskip ?]. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hskip. subst.
  prefs: []
  type: TYPE_NORMAL
- en: edestruct IHHpe2. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: econstructor. apply E_IfTrue.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← pe_bexp_correct. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: repeat eapply E_Seq; eauto. apply eval_assign.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_compare_update, ← assign_removes. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: omega.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_WhileFixedLoop *) exfalso.'
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent (S (n[1] + n[2])). intros n.
  prefs: []
  type: TYPE_NORMAL
- en: clear - H H[0] IHHpe1 IHHpe2. generalize dependent st.
  prefs: []
  type: TYPE_NORMAL
- en: induction n using lt_wf_ind; intros st Heval. inversion Heval; subst.
  prefs: []
  type: TYPE_NORMAL
- en: + (* E'WhileEnd *) rewrite pe_bexp_correct, H in H[7]. inversion H[7].
  prefs: []
  type: TYPE_NORMAL
- en: + (* E'WhileLoop *)
  prefs: []
  type: TYPE_NORMAL
- en: edestruct IHHpe1 as [? ? ? Hskip ?]. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hskip. subst.
  prefs: []
  type: TYPE_NORMAL
- en: edestruct IHHpe2. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← (pe_compare_nil_update _ _ H[0]) in H[7].
  prefs: []
  type: TYPE_NORMAL
- en: apply H[1] in H[7]; [| omega]. inversion H[7].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_WhileFixed *) generalize dependent st.'
  prefs: []
  type: TYPE_NORMAL
- en: induction n using lt_wf_ind; intros st Heval. inversion Heval; subst.
  prefs: []
  type: TYPE_NORMAL
- en: + (* E'WhileEnd *) rewrite pe_bexp_correct in H[8]. eauto.
  prefs: []
  type: TYPE_NORMAL
- en: + (* E'WhileLoop *) rewrite pe_bexp_correct in H[5].
  prefs: []
  type: TYPE_NORMAL
- en: edestruct IHHpe1 as [? ? ? Hskip ?]. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hskip. subst.
  prefs: []
  type: TYPE_NORMAL
- en: edestruct IHHpe2. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← (pe_compare_nil_update _ _ H[1]) in H[8].
  prefs: []
  type: TYPE_NORMAL
- en: apply H[2] in H[8]; [| omega]. inversion H[8].
  prefs: []
  type: TYPE_NORMAL
- en: econstructor; [ eapply E_WhileLoop; eauto | eassumption | omega].
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_com_sound:'
  prefs: []
  type: TYPE_NORMAL
- en: ∀c pe_st pe_st' c' c'', c / pe_st ⇓ c' / pe_st' / c'' →
  prefs: []
  type: TYPE_NORMAL
- en: ∀st st'' n,
  prefs: []
  type: TYPE_NORMAL
- en: '(c'' / pe_st'' / c'''' / st ⇓ st'''' # n) →'
  prefs: []
  type: TYPE_NORMAL
- en: (c / pe_update st pe_st ⇓ st'').
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros c pe_st pe_st' c' c'' Hpe.
  prefs: []
  type: TYPE_NORMAL
- en: induction Hpe;
  prefs: []
  type: TYPE_NORMAL
- en: intros st st'' n [st' n' Heval Heval' Hle];
  prefs: []
  type: TYPE_NORMAL
- en: try (inversion Heval; []; subst);
  prefs: []
  type: TYPE_NORMAL
- en: try (inversion Heval'; []; subst); eauto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_AssStatic *) rewrite ← pe_update_update_add. apply E_Ass.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_aexp_correct. rewrite → H. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_AssDynamic *) rewrite ← pe_update_update_remove. apply E_Ass.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← pe_aexp_correct. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_Seq *) eapply E_Seq; eauto.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_IfTrue *) apply E_IfTrue.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_bexp_correct. rewrite → H. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: eapply IHHpe. eauto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_IfFalse *) apply E_IfFalse.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_bexp_correct. rewrite → H. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: eapply IHHpe. eauto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_If *) inversion Heval; subst; inversion H[7]; subst; clear H[7].'
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_IfTrue *)
  prefs: []
  type: TYPE_NORMAL
- en: eapply ceval_deterministic in H[8]; [| apply eval_assign]. subst.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← assign_removes in Heval'.
  prefs: []
  type: TYPE_NORMAL
- en: apply E_IfTrue. rewrite → pe_bexp_correct. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: eapply IHHpe1. eauto.
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_IfFalse *)
  prefs: []
  type: TYPE_NORMAL
- en: eapply ceval_deterministic in H[8]; [| apply eval_assign]. subst.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_compare_update in Heval'.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← assign_removes in Heval'.
  prefs: []
  type: TYPE_NORMAL
- en: apply E_IfFalse. rewrite → pe_bexp_correct. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: eapply IHHpe2. eauto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_WhileEnd *) apply E_WhileEnd.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_bexp_correct. rewrite → H. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_WhileLoop *) eapply E_WhileLoop.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_bexp_correct. rewrite → H. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: eapply IHHpe1. eauto. eapply IHHpe2. eauto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_While *) inversion Heval; subst.'
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_IfTrue *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[9]. subst. clear H[9].
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[10]. subst. clear H[10].
  prefs: []
  type: TYPE_NORMAL
- en: eapply ceval_deterministic in H[11]; [| apply eval_assign]. subst.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_compare_update in Heval'.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← assign_removes in Heval'.
  prefs: []
  type: TYPE_NORMAL
- en: eapply E_WhileLoop. rewrite → pe_bexp_correct. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: eapply IHHpe1. eauto.
  prefs: []
  type: TYPE_NORMAL
- en: eapply IHHpe2. eauto.
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_IfFalse *) apply ceval_count_sound in Heval'.
  prefs: []
  type: TYPE_NORMAL
- en: eapply ceval_deterministic in H[9]; [| apply eval_assign]. subst.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← assign_removes in Heval'.
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[2]; subst.
  prefs: []
  type: TYPE_NORMAL
- en: '* (* c[2]'''' = SKIP *) inversion Heval''. subst. apply E_WhileEnd.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → pe_bexp_correct. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: '* (* c[2]'''' = WHILE b[1] DO c[1] END *) assumption.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_WhileFixedEnd *) eapply ceval_count_sound. apply Heval''.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_WhileFixedLoop *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply loop_never_stops in Heval. inversion Heval.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* PE_WhileFixed *)'
  prefs: []
  type: TYPE_NORMAL
- en: clear - H[1] IHHpe1 IHHpe2 Heval.
  prefs: []
  type: TYPE_NORMAL
- en: remember (WHILE pe_bexp pe_st b[1] DO c[1]';; c[2]' END) as c'.
  prefs: []
  type: TYPE_NORMAL
- en: induction Heval;
  prefs: []
  type: TYPE_NORMAL
- en: inversion Heqc'; subst; clear Heqc'.
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_WhileEnd *) apply E_WhileEnd.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite pe_bexp_correct. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_WhileLoop *)
  prefs: []
  type: TYPE_NORMAL
- en: assert (IHHeval2' := IHHeval2 (refl_equal _)).
  prefs: []
  type: TYPE_NORMAL
- en: apply ceval_count_complete in IHHeval2'. inversion IHHeval2'.
  prefs: []
  type: TYPE_NORMAL
- en: clear IHHeval1 IHHeval2 IHHeval2'.
  prefs: []
  type: TYPE_NORMAL
- en: inversion Heval1. subst.
  prefs: []
  type: TYPE_NORMAL
- en: eapply E_WhileLoop. rewrite pe_bexp_correct. assumption. eauto.
  prefs: []
  type: TYPE_NORMAL
- en: eapply IHHpe2. econstructor. eassumption.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← (pe_compare_nil_update _ _ H[1]). eassumption. apply le_n.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Corollary pe_com_correct:'
  prefs: []
  type: TYPE_NORMAL
- en: ∀c pe_st pe_st' c', c / pe_st ⇓ c' / pe_st' / SKIP →
  prefs: []
  type: TYPE_NORMAL
- en: ∀st st'',
  prefs: []
  type: TYPE_NORMAL
- en: (c / pe_update st pe_st ⇓ st'') ↔
  prefs: []
  type: TYPE_NORMAL
- en: (∃st', c' / st ⇓ st' ∧ pe_update st' pe_st' = st'').
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros c pe_st pe_st' c' H st st''. split.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *) intros Heval.'
  prefs: []
  type: TYPE_NORMAL
- en: apply ceval_count_complete in Heval. inversion Heval as [n Heval'].
  prefs: []
  type: TYPE_NORMAL
- en: apply pe_com_complete with (st:=st) (st'':=st'') (n:=n) in H.
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [? ? ? Hskip ?]. inversion Hskip. subst. eauto.
  prefs: []
  type: TYPE_NORMAL
- en: assumption.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *) intros [st'' [Heval Heq]]. subst st''''.'
  prefs: []
  type: TYPE_NORMAL
- en: eapply pe_com_sound in H. apply H.
  prefs: []
  type: TYPE_NORMAL
- en: econstructor. apply Heval. apply E'Skip. apply le_n.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: End Loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive block (Label:Type) : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| Goto : Label → block Label'
  prefs: []
  type: TYPE_NORMAL
- en: '| If : bexp → Label → Label → block Label'
  prefs: []
  type: TYPE_NORMAL
- en: '| Assign : id → aexp → block Label → block Label.'
  prefs: []
  type: TYPE_NORMAL
- en: Arguments Goto {Label} _.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments If   {Label} _ _ _.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments Assign {Label} _ _ _.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive parity_label : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| entry : parity_label'
  prefs: []
  type: TYPE_NORMAL
- en: '| loop  : parity_label'
  prefs: []
  type: TYPE_NORMAL
- en: '| body  : parity_label'
  prefs: []
  type: TYPE_NORMAL
- en: '| done  : parity_label.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition parity_body : block parity_label :='
  prefs: []
  type: TYPE_NORMAL
- en: Assign Y (AMinus (AId Y) (ANum 1))
  prefs: []
  type: TYPE_NORMAL
- en: (Assign X (AMinus (ANum 1) (AId X))
  prefs: []
  type: TYPE_NORMAL
- en: (Goto loop)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint keval {L:Type} (st:state) (k : block L) : state * L :='
  prefs: []
  type: TYPE_NORMAL
- en: match k with
  prefs: []
  type: TYPE_NORMAL
- en: '| Goto l ⇒ (st, l)'
  prefs: []
  type: TYPE_NORMAL
- en: '| If b l[1] l[2] ⇒ (st, if beval st b then l[1] else l[2])'
  prefs: []
  type: TYPE_NORMAL
- en: '| Assign i a k ⇒ keval (t_update st i (aeval st a)) k'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example keval_example:'
  prefs: []
  type: TYPE_NORMAL
- en: keval empty_state parity_body
  prefs: []
  type: TYPE_NORMAL
- en: = (t_update (t_update empty_state Y 0) X 1, loop).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition program (L:Type) : Type := L → option (block L).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition parity : program parity_label := fun l ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match l with
  prefs: []
  type: TYPE_NORMAL
- en: '| entry ⇒ Some (Assign X (ANum 0) (Goto loop))'
  prefs: []
  type: TYPE_NORMAL
- en: '| loop ⇒ Some (If (BLe (ANum 1) (AId Y)) body done)'
  prefs: []
  type: TYPE_NORMAL
- en: '| body ⇒ Some parity_body'
  prefs: []
  type: TYPE_NORMAL
- en: '| done ⇒ None (* halt *)'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive peval {L:Type} (p : program L)'
  prefs: []
  type: TYPE_NORMAL
- en: ': state → L → state → L → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| E_None: ∀st l,'
  prefs: []
  type: TYPE_NORMAL
- en: p l = None →
  prefs: []
  type: TYPE_NORMAL
- en: peval p st l st l
  prefs: []
  type: TYPE_NORMAL
- en: '| E_Some: ∀st l k st'' l'' st'''' l'''','
  prefs: []
  type: TYPE_NORMAL
- en: p l = Some k →
  prefs: []
  type: TYPE_NORMAL
- en: keval st k = (st', l') →
  prefs: []
  type: TYPE_NORMAL
- en: peval p st' l' st'' l'' →
  prefs: []
  type: TYPE_NORMAL
- en: peval p st l st'' l''.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example parity_eval: peval parity empty_state entry empty_state done.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. erewrite f_equal with (f := fun st ⇒ peval _ _ _ st _).
  prefs: []
  type: TYPE_NORMAL
- en: eapply E_Some. reflexivity. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: eapply E_Some. reflexivity. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: apply E_None. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: apply functional_extensionality. intros i. rewrite t_update_same; auto.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint pe_block {L:Type} (pe_st:pe_state) (k : block L)'
  prefs: []
  type: TYPE_NORMAL
- en: ': block (pe_state * L) :='
  prefs: []
  type: TYPE_NORMAL
- en: match k with
  prefs: []
  type: TYPE_NORMAL
- en: '| Goto l ⇒ Goto (pe_st, l)'
  prefs: []
  type: TYPE_NORMAL
- en: '| If b l[1] l[2] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match pe_bexp pe_st b with
  prefs: []
  type: TYPE_NORMAL
- en: '| BTrue  ⇒ Goto (pe_st, l[1])'
  prefs: []
  type: TYPE_NORMAL
- en: '| BFalse ⇒ Goto (pe_st, l[2])'
  prefs: []
  type: TYPE_NORMAL
- en: '| b''     ⇒ If b'' (pe_st, l[1]) (pe_st, l[2])'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '| Assign i a k ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match pe_aexp pe_st a with
  prefs: []
  type: TYPE_NORMAL
- en: '| ANum n ⇒ pe_block (pe_add pe_st i n) k'
  prefs: []
  type: TYPE_NORMAL
- en: '| a'' ⇒ Assign i a'' (pe_block (pe_remove pe_st i) k)'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example pe_block_example:'
  prefs: []
  type: TYPE_NORMAL
- en: pe_block [(X,0)] parity_body
  prefs: []
  type: TYPE_NORMAL
- en: = Assign Y (AMinus (AId Y) (ANum 1)) (Goto ([(X,1)], loop)).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Theorem pe_block_correct: ∀(L:Type) st pe_st k st'' pe_st'' (l'':L),'
  prefs: []
  type: TYPE_NORMAL
- en: keval st (pe_block pe_st k) = (st', (pe_st', l')) →
  prefs: []
  type: TYPE_NORMAL
- en: keval (pe_update st pe_st) k = (pe_update st' pe_st', l').
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros. generalize dependent pe_st. generalize dependent st.
  prefs: []
  type: TYPE_NORMAL
- en: induction k as [l | b l[1] l[2] | i a k];
  prefs: []
  type: TYPE_NORMAL
- en: intros st pe_st H.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* Goto *) inversion H; reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* If *)'
  prefs: []
  type: TYPE_NORMAL
- en: replace (keval st (pe_block pe_st (If b l[1] l[2])))
  prefs: []
  type: TYPE_NORMAL
- en: with (keval st (If (pe_bexp pe_st b) (pe_st, l[1]) (pe_st, l[2])))
  prefs: []
  type: TYPE_NORMAL
- en: in H by (simpl; destruct (pe_bexp pe_st b); reflexivity).
  prefs: []
  type: TYPE_NORMAL
- en: simpl in *. rewrite pe_bexp_correct.
  prefs: []
  type: TYPE_NORMAL
- en: destruct (beval st (pe_bexp pe_st b)); inversion H; reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* Assign *)'
  prefs: []
  type: TYPE_NORMAL
- en: simpl in *. rewrite pe_aexp_correct.
  prefs: []
  type: TYPE_NORMAL
- en: destruct (pe_aexp pe_st a); simpl;
  prefs: []
  type: TYPE_NORMAL
- en: try solve [rewrite pe_update_update_add; apply IHk; apply H];
  prefs: []
  type: TYPE_NORMAL
- en: solve [rewrite pe_update_update_remove; apply IHk; apply H].
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition pe_program {L:Type} (p : program L)'
  prefs: []
  type: TYPE_NORMAL
- en: ': program (pe_state * L) :='
  prefs: []
  type: TYPE_NORMAL
- en: fun pe_l ⇒ match pe_l with | (pe_st, l) ⇒
  prefs: []
  type: TYPE_NORMAL
- en: option_map (pe_block pe_st) (p l)
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive pe_peval {L:Type} (p : program L)'
  prefs: []
  type: TYPE_NORMAL
- en: '(st:state) (pe_st:pe_state) (l:L) (st''o:state) (l'':L) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| pe_peval_intro : ∀st'' pe_st'','
  prefs: []
  type: TYPE_NORMAL
- en: peval (pe_program p) st (pe_st, l) st' (pe_st', l') →
  prefs: []
  type: TYPE_NORMAL
- en: pe_update st' pe_st' = st'o →
  prefs: []
  type: TYPE_NORMAL
- en: pe_peval p st pe_st l st'o l'.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pe_program_correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '∀(L:Type) (p : program L) st pe_st l st''o l'','
  prefs: []
  type: TYPE_NORMAL
- en: peval p (pe_update st pe_st) l st'o l' ↔
  prefs: []
  type: TYPE_NORMAL
- en: pe_peval p st pe_st l st'o l'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros.
  prefs: []
  type: TYPE_NORMAL
- en: split.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* -> *) intros Heval.'
  prefs: []
  type: TYPE_NORMAL
- en: remember (pe_update st pe_st) as sto.
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent pe_st. generalize dependent st.
  prefs: []
  type: TYPE_NORMAL
- en: induction Heval as
  prefs: []
  type: TYPE_NORMAL
- en: '[ sto l Hlookup | sto l k st''o l'' st''''o l'''' Hlookup Hkeval Heval ];'
  prefs: []
  type: TYPE_NORMAL
- en: intros st pe_st Heqsto; subst sto.
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_None *) eapply pe_peval_intro. apply E_None.
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rewrite Hlookup. reflexivity. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_Some *)
  prefs: []
  type: TYPE_NORMAL
- en: remember (keval st (pe_block pe_st k)) as x.
  prefs: []
  type: TYPE_NORMAL
- en: destruct x as [st' [pe_st' l'_]].
  prefs: []
  type: TYPE_NORMAL
- en: symmetry in Heqx. erewrite pe_block_correct in Hkeval by apply Heqx.
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hkeval. subst st'o l'_. clear Hkeval.
  prefs: []
  type: TYPE_NORMAL
- en: edestruct IHHeval. reflexivity. subst st''o. clear IHHeval.
  prefs: []
  type: TYPE_NORMAL
- en: eapply pe_peval_intro; [| reflexivity]. eapply E_Some; eauto.
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rewrite Hlookup. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* <- *) intros [st'' pe_st'' Heval Heqst''o].'
  prefs: []
  type: TYPE_NORMAL
- en: remember (pe_st, l) as pe_st_l.
  prefs: []
  type: TYPE_NORMAL
- en: remember (pe_st', l') as pe_st'_l'.
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent pe_st. generalize dependent l.
  prefs: []
  type: TYPE_NORMAL
- en: induction Heval as
  prefs: []
  type: TYPE_NORMAL
- en: '[ st [pe_st_ l_] Hlookup'
  prefs: []
  type: TYPE_NORMAL
- en: '| st [pe_st_ l_] pe_k st'' [pe_st''_ l''_] st'''' [pe_st'''' l'''']'
  prefs: []
  type: TYPE_NORMAL
- en: Hlookup Hkeval Heval ];
  prefs: []
  type: TYPE_NORMAL
- en: intros l pe_st Heqpe_st_l;
  prefs: []
  type: TYPE_NORMAL
- en: inversion Heqpe_st_l; inversion Heqpe_st'_l'; repeat subst.
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_None *) apply E_None. simpl in Hlookup.
  prefs: []
  type: TYPE_NORMAL
- en: destruct (p l'); [ solve [ inversion Hlookup ] | reflexivity ].
  prefs: []
  type: TYPE_NORMAL
- en: + (* E_Some *)
  prefs: []
  type: TYPE_NORMAL
- en: simpl in Hlookup. remember (p l) as k.
  prefs: []
  type: TYPE_NORMAL
- en: destruct k as [k|]; inversion Hlookup; subst.
  prefs: []
  type: TYPE_NORMAL
- en: eapply E_Some; eauto. apply pe_block_correct. apply Hkeval.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
