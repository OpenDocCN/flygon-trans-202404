- en: 'Chapter 3: Functional Programming, Part Deux'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Whoever said that pleasure wasn’t functional?*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Charles Eames
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3.1 Cryptography and Prime Numbers
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![../Images/Alien4.PNG](../Images/Alien4.PNG)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
- en: '*I’m headed home soon, but there’s just a bit more shopping to be done first!*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that our alien is sitting at a cafe, surfing the Internet, sipping a
    triple mochaccino, and is now about to purchase the Harry Potter Complete DVD
    Collection (movies 1 through 17) from the massive online store, Nile.com. As it
    types in its credit card number to make its purchase, it suddenly pauses to wonder
    how its financial details will be kept secure as they are transmitted over the
    cafe’s Wi-Fi and then over the vast reaches of the Internet. That’s a valid concern.
    The good news is that many online stores use cryptography to keep such transactions
    secure.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[![../Images/Alien4.PNG](../Images/Alien4.PNG)](../Images/Alien4.PNG)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '*Rivest, Shamir, and Adleman received the Turing Award—the computer science
    equivalent of the Noble Prize.*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most famous and widely-used cryptography schemes is called RSA,
    after the three computer scientists who invented it: Ron Rivest, Adi Shamir, and
    Leonard Adleman. Here’s how it works: The online store has its own mathematical
    function that all customers use to encrypt their data before transmitting it over
    the network. This mathematical function is made publicly available. The hope is
    that while anyone can easily use this function to encrypt data, only the online
    store can “undo” (or, more technically, “invert”) the function to decrypt the
    data and recover the original number.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine that Nile.com tells customers to use the function \(f(x)=2x\).
    It’s certainly easy to encrypt any number we wish to send—we simply double it.
    Unfortunately, any first grader with a calculator can decrypt the message by simply
    dividing it by 2, so that encryption function is not secure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The RSA scheme uses a slightly more complicated function. If \(x\) is our credit-card
    number, we encrypt it using the function \(f(x) = x^e \text{ mod } n\), where
    \(e\) and \(n\) are carefully chosen numbers. (Remember from the previous chapter
    that \(x^e \text{ mod } n\) means the remainder when \(x^e\) is divided by \(n\);
    it can be easily computed in Python using the expression `(x**e) % n`.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that if \(e\) and \(n\) are chosen appropriately, the online store
    will be able to decrypt the number to retrieve the credit card number \(x\) but
    it will be nearly impossible for anyone else to do so—even though everyone knows
    \(e\) and \(n\).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s pretty interesting, but how do we choose \(e\) and \(n\) and how will
    the store later decrypt the number that it receives? Well, we first choose two
    different large prime numbers \(p\) and \(q\) at random. Next, \(n\) is just \(pq\).
    Now, to get the number \(e\), we have to perform two steps: first we let \(m =
    (p−1)(q−1)\), and then we choose our exponent \(e\) to be a random prime number
    less than \(m\) that is also not a divisor of \(m\). That’s it!'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣，但我们如何选择\(e\)和\(n\)，以及商店如何解密后收到的数字呢？首先，我们随机选择两个不同的大素数\(p\)和\(q\)。接下来，\(n\)就是\(pq\)。现在，要得到数字\(e\)，我们需要执行两个步骤：首先让\(m
    = (p−1)(q−1)\)，然后我们选择我们的指数\(e\)为小于\(m\)的随机素数，同时也不是\(m\)的除数。就是这样！
- en: Now, any number \(x\) less than \(n\) can be encrypted by computing \(x^e \text{
    mod } n\). Once we have selected \(e\) and \(n\), we can share those values with
    anyone wishing to send us encrypted information. In a typical Internet shopping
    transaction, your web browser would get the publicly available values of \(e\)
    and \(n\) from the online store and use them to encrypt your credit card number,
    \(x\). Together, the values \(e\) and \(n\) are called the *public key* for this
    store. (In cryptology, a public key is simply a key that can be safely published
    without giving away the corresponding *secret key*.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何小于\(n\)的数字\(x\)都可以通过计算\(x^e \text{ mod } n\)来加密。一旦我们选择了\(e\)和\(n\)，我们可以与任何希望向我们发送加密信息的人分享这些值。在典型的互联网购物交易中，您的网络浏览器会从在线商店获取公开可用的\(e\)和\(n\)值，并用它们来加密您的信用卡号\(x\)。这些值\(e\)和\(n\)一起被称为这家商店的*公钥*。（在密码学中，公钥只是一个可以安全发布而不泄露相应*私钥*的密钥。）
- en: For example, let \(p=3\) and \(q=5\). They’re certainly prime (although they
    are way too small to be secure in practice). Now, \(n=3 \times 5=15\) and \(m
    = (3−1) \times (5−1) = 8\). For our encryption exponent \(e\), we could choose
    the prime number 3 because it’s less than 8 and also doesn’t divide 8\. Now, we
    can encrypt any number less than n. Let’s encrypt the number 13, for example.
    We can compute \(13^3 \text{ mod } 15\) in Python as `(13**3) % 15`; the result
    is 7\. So 7 is our encrypted number, which we send over the Internet to the online
    store.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让\(p=3\)和\(q=5\)。它们肯定是素数（尽管它们在实践中太小而不安全）。现在，\(n=3 \times 5=15\)，\(m = (3−1)
    \times (5−1) = 8\)。对于我们的加密指数\(e\)，我们可以选择素数3，因为它小于8，也不是8的除数。现在，我们可以加密任何小于n的数字。比如，让我们加密数字13。我们可以在Python中计算\(13^3
    \text{ mod } 15\)为`(13**3) % 15`；结果是7。所以7就是我们加密的数字，我们将其发送到互联网上的在线商店。
- en: '![../Images/Alien4.PNG](../Images/Alien4.PNG)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien4.PNG](../Images/Alien4.PNG)'
- en: '*I think the mathematics of cryptography should be called “discreet” math.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*我认为密码学的数学应该被称为“离散”数学。*'
- en: 'How does the store decrypt that 7 and discover that the original number was
    actually 13? At the same time that the encryption exponent e was computed, we
    should have also computed a decryption exponent \(d\), which has two properties:
    it is between 1 and \(m − 1\), and \(ed \text{ mod } m = 1\). It’s not hard to
    show that, because of the way \(e\) and \(m\) were chosen, there is exactly one
    value that has these properties; we call d the *multiplicative inverse of e modulo
    m*. In our example, \(e = 3\) and \(m = 8\), and \(d\) is also 3 (it’s a coincidence
    that \(e\) and \(d\) are equal; that’s not normally the case—if it were, the decryption
    key wouldn’t exactly be a secret!). Notice that \(ed \text{ mod } 8 = 9 \text{
    mod } 8 = 1\). Now, the online store can decrypt any number \(y\) that it receives
    by simply computing \(y^d \text{ mod } n\). In our case, we received the encrypted
    number \(y = 7\). We compute \(7^3 \text{ mod } 15\) using Python `((7**3) % 15)`
    and get the answer 13\. Indeed, that’s the value that we encrypted a moment ago!
    Keep in mind that while the encryption key \(e\) and \(n\) are public, the online
    store must keep the *decryption key* \(d\) private. Anyone with access to \(d\)
    can decrypt any message sent with the encryption key.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Exactly *why* this works is not too hard to show and is often taught in an introductory
    discrete math or algorithms course. But you may be wondering why we are so confident
    that the scheme is secure. This, too, requires a bit more time to explain than
    we have here. We will point out, however, that since the the values \(e\) and
    \(n\) are public, if a malicious person could find the two primes \(p\) and \(q\)
    that we originally selected, then they could figure out \(m\) and then \(d\) and
    they could crack the code. The good news is that “factoring” a number \(n\) into
    its prime divisors is known to be a “computationally hard” problem—*very* hard.
    (*Computationally hard* means a problem that takes a long time to compute the
    answer for.) For example, the U.S. National Institutes of Standards and Technology
    estimates that if we encrypt a message today using public keys that are about
    600 digits long, it would take until about the year 2030 to crack the code—even
    if a very large number of very fast computers were used for the attack.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 First-Class Functions
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![../Images/Alien4.PNG](../Images/Alien4.PNG)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: '*I prefer to do everything first-class.*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Recall that in the previous chapter we learned about Python functions and explored
    the power of recursion. The style of programming that we examined—programs constructed
    from functions that call one another (and possibly themselves)—is called *functional
    programming*. Interestingly, in functional programming languages like Python,
    functions are actually data just like numbers, lists, and strings. We say that
    functions are “first-class citizens” of the language. In particular, we can write
    functions that take *other functions* as arguments and return *other functions*
    as results! In this chapter we’ll explore these ideas, first using them to write
    a short program that efficiently generates long lists of primes, and ultimately
    writing a function that generates both the encryption and decryption functions
    for RSA cryptography. By the end of this chapter, we’ll have written Python programs
    that will allow you to securely send data to your friends.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Generating Primes
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Motivated by RSA cryptography, our first mission is to find a way to generate
    a list of primes. One reasonable way to do this is to first write a function that
    determines whether or not its argument is prime. Once we have such a function,
    we could use it to test a sequence of consecutive numbers for primality, keeping
    those that are prime in a list.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: But how do we test if a single positive integer \(n\) is prime? One idea is
    to simply test whether any number between 2 and \(n − 1\) divides it. If so, the
    number is not prime. Otherwise the number is prime. (In fact, it suffices to test
    just the numbers between 2 and \(\sqrt{n}\), since if \(n\) is not prime, at least
    one of its divisors must be less than or equal to \(\sqrt{n}\). But for now, let’s
    simply test all the possible divisors between 2 and \(n−1\).)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: To that end, it would be useful to have a function `divisors(n)` that accepts
    our number `n` (which we wish to test for primality) and returns `True` if `n`
    has any divisors (other than 1 and itself), and `False` otherwise. Actually, it
    will turn out to be handy if `divisors` accepts two additional numbers, `low`
    and `high`, that give a range of divisors to test. That will let us reduce the
    amount of work that has to be done.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: For example, `divisors(15, 2, 14)` should return `True` because 15 has a divisor
    between 2 and 14 (and therefore is not prime), but `divisors(11, 2, 10)` should
    return `False` because 11 has no divisors between 2 and 10 (and therefore is prime).
    Also, note that `divisors(35, 2, 4)` should return `False` even though 35 is *not*
    prime.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: We can write the `divisors(n, low, high)` function using recursion! To simplify
    matters, we’ll assume that the arguments are all positive integers. If `low` is
    higher than `high`, then the answer is `False` because `n` cannot have any divisors
    in the specified range (since there are no numbers in increasing order between
    `low` and `high`). So, if `low > high` we must return `False`—which is a base
    case.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if `low` is less than or equal to `high`? In this case, we can test
    whether `n` has a divisor between `low` and `high` like this: If `n` is divisible
    by `low`, then we’ve found a divisor in that range and we must return `True`.
    Otherwise, the answer to the question: “Does `n` have a divisor between `low`
    and `high`?” now becomes the same as the answer to the question “Does `n` have
    a divisor between `low+1` and `high`?” But that’s a version of the original question,
    and thus one that we can solve recursively! Here’s our solution:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果`low`小于或等于`high`呢？在这种情况下，我们可以测试`n`是否在`low`和`high`之间有一个除数，就像这样：如果`n`可以被`low`整除，那么我们在这个范围内找到了一个除数，我们必须返回`True`。否则，对于问题：“`n`是否在`low`和`high`之间有一个除数？”的答案现在变成了对问题“`n`是否在`low+1`和`high`之间有一个除数？”的答案。但这是原始问题的一个版本，因此我们可以递归解决！这是我们的解决方案：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we can test if n is prime by checking whether it has any divisors between
    `2` and `n-1`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过检查`2`和`n-1`之间是否有任何除数来测试n是否为素数：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can do this even more elegantly this way:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更加优雅地这样做：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Recall from Chapter 2, that `not` “negates” a Boolean, so if `divisors(n, 2,
    n-1)` is `True` then `not divisors(n, 2, n-1)` is `False`, and if `divisors(n,
    2, n-1)` is `False` then `not divisors(n, 2, n-1)` is `True`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下第2章，`not`“否定”一个布尔值，因此如果`divisors(n, 2, n-1)`为`True`，那么`not divisors(n, 2,
    n-1)`为`False`，如果`divisors(n, 2, n-1)`为`False`，那么`not divisors(n, 2, n-1)`为`True`。
- en: Now we can use `isPrime` to generate lists of primes, again using recursion.
    Imagine that we want to know all of the primes from 2 to some limit, for example
    100\. For each number in that range, we could test if it’s prime and, if so, add
    it to our growing list of primes. Before you look at the code below, see if you
    can determine the base case and the recursive step for such a function.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`isPrime`来再次使用递归生成素数列表。想象一下，我们想知道从2到某个限制（例如100）的所有素数。对于该范围内的每个数字，我们可以测试它是否是素数，如果是，就将其添加到我们不断增长的素数列表中。在查看下面的代码之前，请看看您是否可以确定这样一个函数的基本情况和递归步骤。
- en: 'Now, here is the Python implementation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里是 Python 的实现：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that in the second return statement, we returned `[n] + listPrimes(n+1,
    limit)` rather than `n + listPrimes(n+1, limit)`. Why? Well, in this case the
    plus sign means that two lists should be concatenated, so the expressions on its
    left and right have to be lists. Indeed, the result of calling `listPrimes` will
    be a list, since by definition a list is what this function returns (and notice
    that in the base case it returns the empty list). However, `n` is a number, not
    a list! To make it a list, we place it inside square brackets. That way, we are
    concatenating two lists and life is good.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第二个返回语句中，我们返回了`[n] + listPrimes(n+1, limit)`而不是`n + listPrimes(n+1, limit)`。为什么？嗯，在这种情况下，加号表示应该连接两个列表，因此其左右的表达式必须是列表。实际上，调用`listPrimes`的结果将是一个列表，因为根据定义，列表是这个函数返回的内容（请注意，在基本情况下，它返回空列表）。然而，`n`是一个数字，不是一个列表！为了使其成为一个列表，我们将其放在方括号内。这样，我们就可以连接两个列表，生活就美好了。
- en: The above strategy for generating primes works, but it’s quite slow—particularly
    when attempting to generate large primes. The problem is that it repeats a lot
    of work. For example, if you call `listPrimes(51, 2, 50)` it will test 2 as a
    divisor and fail—but it will still insist on testing 4,6,8,...,50 even though
    we’ve already proven that 51 isn’t even!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 生成素数的上述策略有效，但速度相当慢，特别是在尝试生成大素数时。问题在于它重复了很多工作。例如，如果你调用`listPrimes(51, 2, 50)`，它将测试2作为除数并失败，但它仍然会坚持测试4,6,8,...,50，即使我们已经证明51不是偶数！
- en: '[![../Images/Alien4.PNG](../Images/Alien4.PNG)](../Images/Alien4.PNG)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien4.PNG](../Images/Alien4.PNG)](../Images/Alien4.PNG)'
- en: '*It’s not entirely clear that Eratosthenes actually discovered this idea.*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*埃拉托斯特尼实际上发现这个想法并不完全清楚。*'
- en: 'A much faster algorithm for generating primes is the so-called *sieve of Eratosthenes*.
    This method is named after Eratosthenes, an ancient Greek mathematician who lived
    around 2200 years ago. Here’s the idea: To find all of the primes from 2 to 1000,
    for example, we first write down all of the integers in that range. Then we start
    with 2; it’s the first prime. Now, we remove (or “sift”) all multiples of 2 from
    this list since they are definitely not prime. When we’re done, we come *back*
    to the beginning of our remaining list. The number 3 survived the sifting of numbers
    that was performed by 2, so 3 is prime. We now cancel out all remaining numbers
    that are multiples of 3, since they too cannot be prime. When we’re done, we look
    at the first number in the remaining list. It’s not 4 (it got sifted out earlier
    when we looked at 2), but 5 is there. So 5 is prime and we let it sift all of
    its multiples that remain in the list. We continue this process until every remaining
    number has had a chance to sift the numbers above it.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![../Images/Sieve_of_Eratosthenes_animation.gif](../Images/Sieve_of_Eratosthenes_animation.gif)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Sieve of Eratosthenes'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '*(http://commons.wikimedia.org/wiki/File:Sieve_of_Eratosthenes_animation.gif)*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll implement a recursive algorithm motivated by Eratosthenes’ algorithm
    as a Python function called... `primeSieve`. (In the spirit of full disclosure,
    our implementation will take a few liberties with Eratosthenes’ algorithm.) It
    will take a list of numbers 2,3,... up to the largest number that we’re interested
    in, and will return a list of all the primes in the original list. Fortunately,
    Python has a built-in function that allows us to obtain the list of all integers
    from a starting point to an ending point. It’s called `range`, and in Python 2
    it works like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In Python 3 `range` works almost the same, but it needs a little nudge to turn
    the result into a list:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice that the list that we get back from `range` seems to stop one number
    too soon. That may seem weird, but as we’ll see later, it turns out to be useful.
    So getting *all* the integers from 2 to 1000, for example, is easy: `range(2,
    1001)`. We can then pass that list into the `primeSieve` function.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Before writing primeSieve let’s just do a small thought experiment to better
    understand how it will work. Imagine that we start it with the list `range(2,
    11)`, which is:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '`[2, 3, 4, 5, 6, 7, 8, 9, 10]`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing this list to `primeSieve` is basically saying “Could you please find
    me all of the primes in this list?” To accommodate your polite request, the `primeSieve`
    function should grab the 2 and hold on to it because it’s a prime. It should then
    sift all of the multiples of 2 from this list, resulting in a new list:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '`[3, 5, 7, 9]`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Now what? Well, `primeSieve` would like to do as little work as possible and
    instead send that list to some function and ask it, “Could you please find me
    all of the primes in *this* list?” Aha! We can send that list *back* to `primeSieve`
    because its job is to find the primes in a given list. That’s just recursion!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: So, continuing with our example, the first time we called `primeSieve` it found
    the 2, sifted out the multiples of 2 to get the list `[3, 5, 7, 9]`, and called
    `primeSieve` on that list. Whatever comes back from the recursive call will be
    tacked on to the 2 that we’re currently holding—and then we’ll have the whole
    list of primes from 2 to 10.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The recursive call to primeSieve with the argument list `[3, 5, 7, 9]` will
    similarly grab the 3 from the front of that list, sift out all of the multiples
    of 3 to get list `[5, 7]`, and will ask for help finding the primes in that list.
    Whatever primes are returned will be tacked on to the 3 that we’re holding, and
    that will be all of the primes in the list `[3, 5, 7, 9]`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![../Images/Alien4.PNG](../Images/Alien4.PNG)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: '*I think that this approach should be called the “wishful thinking” method
    because we just wish for a helper function whenever we need one.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: In the next recursive call, we’ll grab 5 and recur on the list `[7]`. *That*
    recursive call will grab the 7 and recur on the empty list. We see here that since
    the list is getting shorter each time, the base case arises when we have an empty
    list. In that case, `primeSieve` must report that “the list of all the primes
    in my argument is empty”—that is, it should return the empty list.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: We still need a function that will do the actual sifting. We can imagine a function
    called `sift` that takes two arguments—a number `toRemove` and a list of numbers
    `numList`—and returns all of the numbers in `numList` that are *not* multiples
    of `toRemove`. Let’s come back to that in a moment, and write our `primeSieve`
    under the assumption that we have `sift`. This approach for writing programs is
    called *top-down design* because we start at the “top” (what we want) and then
    work our way down to the details that we need.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we need to sift. The next section will introduce a tool that will help
    us do exactly that, so read on...
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 Filtering
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fortunately for us, Python (like most functional programming languages) has
    a built-in function named `filter` that does (almost) exactly the sifting that
    we would like to do.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll eventually get back to the problem of general list sifting that we started
    above, but for the moment let’s just focus on the problem of sifting a list by
    removing numbers divisible by two. To demonstrate `filter` in action, let’s first
    define a function called `isNotDivisibleBy2` that takes a number `n` as an argument
    and returns a Boolean value: `True` if the number is not divisible by 2 (i.e.,
    it is odd) and `False` otherwise (i.e. it is even).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now back to filtering. Having `isNotDivisibleBy2`, here’s how we can use it
    with Python’s `filter` function. In Python 2 it looks like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到过滤。有了 `isNotDivisibleBy2`，下面是我们如何在 Python 的 `filter` 函数中使用它。在 Python 2 中看起来是这样的：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In Python 3, `filter` doesn’t eagerly produce a list, so we need to send its
    result to the `list` function, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3 中，`filter` 不会立即生成一个列表，因此我们需要将其结果发送给 `list` 函数，如下所示：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![../Images/Alien4.PNG](../Images/Alien4.PNG)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien4.PNG](../Images/Alien4.PNG)'
- en: '*I couldn’t function without a filter to remove the noxious oxygen from Earth’s
    air!*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*没有过滤器来将地球大气中有毒的氧气去除，我将无法正常工作！*'
- en: 'You may have inferred what `filter` is doing: its first argument is a *function*
    and its second argument is a list. The function is a special one that takes a
    single argument and returns a Boolean result. A function that returns a Boolean
    is called a *predicate*; you can think of the predicate as telling us whether
    or not it “likes” its argument. Then, `filter` gives us back all of the elements
    in the list that the predicate likes. In our example, `isNotDivisibleBy2` is a
    predicate that likes odd numbers. So we got back the list of all the odd numbers
    in the original list.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经推断出 `filter` 在做什么：它的第一个参数是一个*函数*，第二个参数是一个列表。这个函数是一个特殊的函数，它接受一个参数并返回一个布尔结果。返回布尔值的函数称为*谓词*；你可以将谓词看作告诉我们它是否“喜欢”其参数的函数。然后，`filter`
    给我们返回谓词喜欢的列表中的所有元素。在我们的例子中，`isNotDivisibleBy2` 是一个喜欢奇数的谓词。因此，我们得到了原始列表中所有奇数的列表。
- en: 'A function that takes other functions as arguments?! Strange, but definitely
    allowed, and even encouraged! This idea is central to functional programming:
    functions can be passed into and returned from other functions just like any other
    kind of data. In fact, Chapter 4 will explain why this idea is not so strange
    after all.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接受其他函数作为参数的函数？！奇怪，但绝对是允许的，甚至是鼓励的！这个想法是函数式编程的核心：函数可以像任何其他类型的数据一样传递到其他函数中并从中返回。事实上，第四章将解释为什么这个想法并不那么奇怪。
- en: '![../Images/Alien4.PNG](../Images/Alien4.PNG)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien4.PNG](../Images/Alien4.PNG)'
- en: '*Four letr wrds rock!*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*四个字母的单词很棒！*'
- en: Lists of numbers are not all we can filter. Here’s another example of `filter`,
    this time using lists of strings. In preparation for its next visit to Earth,
    our alien is attempting to master English and a number of other languages. The
    alien has a list of words to learn, but it’s particularly keen on learning the
    four-letter words first. For example, if it’s given the list of words `['aardvark',
    'darn', 'heck', 'spam', 'zyzzyva']` it would like to have a way of filtering that
    list to just be the “bad” words `['darn', 'heck', 'spam']`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以过滤的不仅仅是数字列表。这里是另一个 `filter` 的例子，这次使用字符串列表。为了准备下一次访问地球，我们的外星人正试图掌握英语和其他几种语言。外星人有一个要学习的单词列表，但特别喜欢先学习四个字母的单词。例如，如果给出单词列表
    `['aardvark', 'darn', 'heck', 'spam', 'zyzzyva']`，它希望有一种方法将该列表过滤为只包含“坏”单词 `['darn',
    'heck', 'spam']`。
- en: 'Again, we define a predicate function first: a function called `isBad` that
    takes a string named `word` as an argument and returns a Boolean value: `True`
    if the word is of length four and `False` otherwise.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们首先定义一个谓词函数：一个名为 `isBad` 的函数，它以一个名为 `word` 的字符串作为参数，并返回一个布尔值：如果单词长度为四则返回
    `True`，否则返回 `False`。
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![../Images/Alien4.PNG](../Images/Alien4.PNG)](../Images/Alien4.PNG)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien4.PNG](../Images/Alien4.PNG)](../Images/Alien4.PNG)'
- en: '[*](#id1)In Python 2, we can omit the call to `list`, so we simply have `filter(isBad,
    ...`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[*](#id1)在 Python 2 中，我们可以省略对 `list` 的调用，因此我们只需 `filter(isBad, ...`'
- en: 'Now that we have `isBad`, here’s how we can use it with Python’s `filter` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `isBad`，下面是我们如何在 Python 的 `filter` 函数中使用它：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 3.5 Lambda
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 Lambda
- en: '`Filter` helps us sift lists of numbers, but so far all we’ve seen how to do
    is to sift them to remove even numbers. If we wanted to remove multiples of 3
    we would need another helper function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Filter` 帮助我们筛选数字列表，但到目前为止我们只看到如何筛选以去除偶数。如果我们想要去除 3 的倍数，我们将需要另一个辅助函数：'
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And then we’d need another to remove multiples of 5, and one for 7, and 11,
    and so on. Obviously this is not going to work.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要另一个来去除 5 的倍数，一个去除 7 的倍数，11 的倍数，等等。显然这样是行不通的。
- en: 'The idea behind our `primeSieve` function is that we want to change what we
    are filtering for “on the fly,” depending on which number is currently first in
    the list. You might imagine that we could add a second argument to our predicate
    function, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `primeSieve` 函���背后的思想是，我们希望根据当前列表中的第一个数字来“即时”更改我们要过滤的内容。你可以想象我们可以向我们的谓词函数添加第二个参数，如下所示：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Generally, this would solve the problem, but in this case we have a problem:
    `filter` *requires* that the predicate function we pass it takes only one argument.
    So this new definition will not work either.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![../Images/Alien4.PNG](../Images/Alien4.PNG)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: '*Is a disposable function environmentally friendly?!*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: What we really need is a sort of “disposable” function that we can define just
    when we need it—using the number we currently care about sifting—and then immediately
    throw it away after we are done using it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this function will be so temporary that we won’t even bother to give
    it a name! Such a function is called an anonymous function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what an anonymous function definition looks like for our `isNotDivisibleBy2`
    example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![../Images/Alien4.PNG](../Images/Alien4.PNG)](../Images/Alien4.PNG)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '*“Lambda” derives from a branch of mathematics called the* lambda calculus
    (see section 3.7), *which influenced the first functional language, LISP.*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'The word “lambda” indicates that we are defining an anonymous function—a short-lived
    function that we need right here and nowhere else. Then comes the names of the
    arguments to the function (in this case, one argument named `n`), then a colon,
    and then the value that this function should return. So, this anonymous function
    `lambda n: n % 2 != 0` is exactly equivalent to our `isNotDivisibleBy2` function
    above.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The anonymous function syntax in Python is odd; in particular, we don’t put
    parentheses around the function’s arguments, and there is no `return` statement.
    Instead, anonymous functions in Python implicitly return whatever value comes
    after the colon.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to make the point that anonymous functions really are full-fledged functions,
    take a look at this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '<textarea class="vizTitleText" id="vizTitleEditor" cols="60" rows="1" style="display:
    none;"><div class="vizTitleText" id="vizTitleViewer"/> <textarea class="vizDescriptionText"
    id="vizDescriptionEditor" cols="75" rows="2" style="display: none;"/> <div class="vizDescriptionText"
    id="vizDescriptionViewer"/> </div> <table border="0" class="visualizer"><tbody><tr><td
    class="vizLayoutTd" id="vizLayoutTdFirst"><div id="codeDisplayDiv" style="max-width:
    500px;"> <div id="pyCodeOutputDiv" style="max-width: 500px; max-height: 400px;"><table
    id="pyCodeOutput"><tbody><tr><td id="gutterTD" valign="top" rowspan="2"><svg id="leftCodeGutterSVG"
    style="height: 45px;"><polygon id="prevLineArrow" points="0,3 12,3 12,0 18,5 12,10
    12,7 0,7" fill="#c9e6ca" style="display: none;"/><polygon id="curLineArrow" points="0,3
    12,3 12,0 18,5 12,10 12,7 0,7" fill="#e93f34" transform="translate(0, 4.72021484375)"/></svg>
    </td> <td class="lineNo" id="lineNo1">1</td> <td class="cod" id="v1__cod1">double = lambda x: 2 * x</td>
    </tr> <tr><td class="lineNo" id="lineNo2">2</td> <td class="cod" id="v1__cod2">print (double(21))</td>
    </tr> </tbody> </table> </div> <div id="editCodeLinkDiv" style="display: none;"><a
    id="editBtn" href="#">Edit code</a></div> <div id="executionSlider" class="ui-slider
    ui-slider-horizontal ui-widget ui-widget-content ui-corner-all" style="width:
    480px; font-size: 0.9em;"></div> <div id="vcrControls"> <button id="jmpFirstInstr"
    type="button" disabled="disabled"><< First</button> <button id="jmpStepBack" type="button"
    disabled="disabled">< Back</button> <span id="curInstr">Step 1 of 4</span> <button
    id="jmpStepFwd" type="button">Forward ></button> <button id="jmpLastInstr" type="button">Last
    >></button> </div> <div id="errorOutput" style="display: none;"/> <div id="legendDiv"><svg
    id="prevLegendArrowSVG"><polygon points="0,3 12,3 12,0 18,5 12,10 12,7 0,7" fill="#c9e6ca"/></svg>
    line that has just executed<p style="margin-top: 4px"><svg id="curLegendArrowSVG"><polygon
    points="0,3 12,3 12,0 18,5 12,10 12,7 0,7" fill="#e93f34"/></svg> next line to
    execute</p> </div> <div id="stepAnnotationDiv"> <textarea class="annotationText"
    id="stepAnnotationEditor" cols="60" rows="3" style="display: none;"/> <div class="annotationText"
    id="stepAnnotationViewer"/> </div> <div id="annotateLinkDiv"><button id="annotateBtn"
    type="button" style="display: none;">Annotate this step</button></div> </div>
    <div id="htmlOutputDiv"/> <div id="progOutputs" style="display: none;"> Program
    output:<br/> <textarea id="pyStdout" cols="50" rows="10" wrap="off" readonly=""
    style="max-width: 500px;"/> </div> </td> </tr> <tr><td class="vizLayoutTd" id="vizLayoutTdSecond"><div
    id="dataViz"> <table id="stackHeapTable"> <tbody><tr> <td id="stack_td"> <div
    id="globals_area"> <div id="stackHeader">Frames</div> <div class="stackFrame highlightedStackFrame"
    id="v1__globals" style="display: none;"><div id="v1__globals_header" class="stackFrameHeader">Global
    variables</div> <table class="stackFrameVarTable" id="v1__global_table"/> </div>
    </div> <div id="stack"/> </td> <td id="heap_td"> <div id="heap"> <div id="heapHeader">Objects</div>
    </div> </td> </tr> </tbody> </table> </div> </td> </tr> </tbody> </table> </div>
    </div> <p class="cl_caption"><span class="cl_caption_text"> (ch03_lambda)</span>
    </p> <script type="text/javascript"> var ch03_lambda_trace = {"code": "double
    = lambda x: 2 * x\nprint (double(21))", "trace": [{"ordered_globals": [], "stdout":
    "", "func_name": "<module>", "stack_to_render": [], "globals": {}, "heap": {},
    "line": 1, "event": "step_line"}, {"ordered_globals": ["double"], "stdout": "",
    "func_name": "<module>", "stack_to_render": [], "globals": {"double": ["REF",
    1]}, "heap": {"1": ["FUNCTION", "<lambda>(x)", null]}, "line": 2, "event": "step_line"},
    {"ordered_globals": ["double"], "stdout": "", "func_name": "<lambda>", "stack_to_render":
    [{"frame_id": 1, "encoded_locals": {"x": 21}, "is_highlighted": true, "is_parent":
    false, "func_name": "<lambda>", "is_zombie": false, "parent_frame_id_list": [],
    "unique_hash": "<lambda>_f1", "ordered_varnames": ["x"]}], "globals": {"double":
    ["REF", 1]}, "heap": {"1": ["FUNCTION", "<lambda>(x)", null]}, "line": 1, "event":
    "call"}, {"ordered_globals": ["double"], "stdout": "", "func_name": "<lambda>",
    "stack_to_render": [{"frame_id": 1, "encoded_locals": {"x": 21}, "is_highlighted":
    true, "is_parent": false, "func_name": "<lambda>", "is_zombie": false, "parent_frame_id_list":
    [], "unique_hash": "<lambda>_f1", "ordered_varnames": ["x"]}], "globals": {"double":
    ["REF", 1]}, "heap": {"1": ["FUNCTION", "<lambda>(x)", null]}, "line": 1, "event":
    "step_line"}, {"ordered_globals": ["double"], "stdout": "", "func_name": "<lambda>",
    "stack_to_render": [{"frame_id": 1, "encoded_locals": {"__return__": 42, "x":
    21}, "is_highlighted": true, "is_parent": false, "func_name": "<lambda>", "is_zombie":
    false, "parent_frame_id_list": [], "unique_hash": "<lambda>_f1", "ordered_varnames":
    ["x", "__return__"]}], "globals": {"double": ["REF", 1]}, "heap": {"1": ["FUNCTION",
    "<lambda>(x)", null]}, "line": 1, "event": "return"}, {"ordered_globals": ["double"],
    "stdout": "42\n", "func_name": "<module>", "stack_to_render": [], "globals": {"double":
    ["REF", 1]}, "heap": {"1": ["FUNCTION", "<lambda>(x)", null]}, "line": 2, "event":
    "return"}]}; var ch03_lambda_vis; $(document).ready(function() { ch03_lambda_vis
    = new ExecutionVisualizer(''ch03_lambda'',ch03_lambda_trace, {embeddedMode: true,
    verticalStack: true, heightChangeCallback: redrawAllVisualizerArrows, codeDivWidth:
    500 }); attachLoggers(ch03_lambda_vis,''ch03_lambda''); allVisualizers.push(ch03_lambda_vis);
    }); $(document).ready(function() { $("#ch03_lambda_tracecheck").click(function()
    { logBookEvent({''event'':''codelens'', ''act'': ''check'', ''div_id'':''ch03_lambda''});
    }); }); if (allVisualizers === undefined) { var allVisualizers = []; } $(window).resize(function()
    { ch03_lambda_vis.redrawConnectors(); }); </script> <p>Whoa—that’s really weird!
    In the first line, we’re defining a variable named <tt class="docutils literal"><span
    class="pre">double</span></tt> and giving it the value <tt class="docutils literal"><span
    class="pre">lambda</span> <span class="pre">x:</span> <span class="pre">2</span>
    <span class="pre">*</span> <span class="pre">x</span></tt>. But in a functional
    programming language functions are truly <em>first-class citizens</em>; they are
    data just like numbers, strings, and lists. So <tt class="docutils literal"><span
    class="pre">double</span></tt> is a function with one argument, and if we want
    to use it we need to pass it a value. In the second line, that’s exactly what
    we’re doing. In fact, when we define a function in the “normal” way, that is by
    starting with the line <tt class="docutils literal"><span class="pre">def</span>
    <span class="pre">double(n)</span></tt>, we are <em>really</em> just saying <tt
    class="docutils literal"><span class="pre">double</span></tt> is a variable whose
    value is the function that I’m going to define in the lines following the <tt
    class="docutils literal"><span class="pre">def</span></tt> statement.”</p> <div
    class="figure align-right" style="width: 150px"> <a class="reference internal
    image-reference" href="../Images/Alien4.PNG"><img alt="../Images/Alien4.PNG" src="../Images/Alien4.PNG"
    style="width: 0px;"/></a> <p class="caption"><a href="#id3"><span class="problematic"
    id="id4">*</span></a>If using Python 2, we can omit the call to <cite>list</cite>.</p>
    <div class="legend"> </div> </div> <p>Finally, we can use anonymous functions
    to finish writing <tt class="docutils literal"><span class="pre">sift</span></tt>,
    as follows:</p> <div class="highlight-python"><div class="highlight"><pre><span
    class="k">def</span> <span class="nf">sift</span><span class="p">(</span><span
    class="n">toRemove</span><span class="p">,</span> <span class="n">numList</span><span
    class="p">):</span> <span class="sd">''''''Takes a number, toRemove, and a list
    of numbers, numList.</span> <span class="sd"> Returns the list of those numbers
    in numList that are not multiples of toRemove.''''''</span> <span class="k">return</span>
    <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span
    class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span
    class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="n">toRemove</span>
    <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span
    class="n">numList</span><span class="p">))</span> </pre> </div> </div> <p>The
    anonymous function we pass into <tt class="docutils literal"><span class="pre">filter</span></tt>
    uses <tt class="docutils literal"><span class="pre">toRemove</span></tt> in its
    body without having to pass it in as an argument. It can do this because this
    function is defined in an environment where <tt class="docutils literal"><span
    class="pre">toRemove</span></tt> <em>already exists</em> and has a value.</p>
    <p>Of course we could also write <tt class="docutils literal"><span class="pre">sift</span></tt>
    using the list-comprehension syntax (see the sidebar in section 3.6.2); then it
    would look like this:</p> <div class="highlight-python"><div class="highlight"><pre><span
    class="k">def</span> <span class="nf">sift</span><span class="p">(</span><span
    class="n">toRemove</span><span class="p">,</span> <span class="n">numList</span><span
    class="p">):</span> <span class="k">return</span> <span class="p">[</span><span
    class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>
    <span class="n">numList</span> <span class="k">if</span> <span class="n">x</span>
    <span class="o">%</span> <span class="n">toRemove</span> <span class="o">!=</span>
    <span class="mi">0</span><span class="p">]</span> </pre> </div> </div> <p>Finally,
    as a reminder, here is our <tt class="docutils literal"><span class="pre">primeSieve</span></tt>
    function again, using <tt class="docutils literal"><span class="pre">sift</span></tt>:</p>
    <div class="highlight-python"><div class="highlight"><pre><span class="k">def</span>
    <span class="nf">primeSieve</span><span class="p">(</span><span class="n">numberList</span><span
    class="p">):</span> <span class="sd">''''''Returns the list of all primes in numberList
    using a prime sieve algorithm.''''''</span> <span class="k">if</span> <span class="n">numberList</span>
    <span class="o">==</span> <span class="p">[]:</span> <span class="c"># if the
    list is empty,</span> <span class="k">return</span> <span class="p">[]</span>
    <span class="c"># ...we''re done</span> <span class="k">else</span><span class="p">:</span>
    <span class="n">prime</span> <span class="o">=</span> <span class="n">numberList</span><span
    class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c">#
    The first element is prime!</span> <span class="k">return</span> <span class="p">[</span><span
    class="n">prime</span><span class="p">]</span> <span class="o">+</span> <span
    class="n">primeSieve</span><span class="p">(</span><span class="n">sift</span><span
    class="p">(</span><span class="n">prime</span><span class="p">,</span> <span class="n">numberList</span><span
    class="p">[</span><span class="mi">1</span><span class="p">:]))</span> </pre>
    </div> </div> <p>It’s surprising how much entertainment value there is in running
    <tt class="docutils literal"><span class="pre">primeSieve</span></tt> to generate
    long lists of primes. However, Python got angry with us when we tried something
    like this:</p> <div class="figure align-right" style="width: 150px"> <a class="reference
    internal image-reference" href="../Images/Alien4.PNG"><img alt="../Images/Alien4.PNG"
    src="../Images/Alien4.PNG" style="width: 0px;"/></a> <p class="caption"><a href="#id5"><span
    class="problematic" id="id6">*</span></a>If using Python 2, we don’t need to call
    <tt class="docutils literal"><span class="pre">list</span></tt>.</p> <div class="legend">
    </div> </div> <div class="highlight-python"><div class="highlight"><pre><span
    class="gp">>>> </span><span class="n">primeSieve</span><span class="p">(</span><span
    class="nb">list</span><span class="p">(</span><span class="nb">range</span><span
    class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10000</span><span
    class="p">)))</span> </pre> </div> </div> <p>We got a long and unfriendly error
    message. The reason is that this created a lot of recursion, and Python is trained
    to believe that if there is a lot of recursion going on, there must be an error
    in your program (usually because you forgot to put in a base case). Exactly how
    much recursion Python thinks is too much depends on the Python version and your
    computer’s operating system. However, you can ask Python to allow you more recursion
    by including the following two lines at the top of your file:</p> <div class="highlight-python"><div
    class="highlight"><pre><span class="kn">import</span> <span class="nn">sys</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span
    class="p">(</span><span class="mi">20000</span><span class="p">)</span> <span
    class="c"># Allow 20000 levels of recursion</span> </pre> </div> </div> <p>We
    asked for <span class="math">\(20,000\)</span> levels of recursion here. Some
    operating systems may allow you more or less than this. (Most modern machines
    will allow much, much more.)</p> <div class="figure align-right" style="width:
    150px"> <img alt="../Images/Alien4.PNG" src="../Images/Alien4.PNG"/> <p class="caption"><em>Shameless
    sales pitch!</em></p> </div> <p>This brings us to one last point: while the prime
    sieve is quite efficient, most good implementations of the RSA scheme use even
    more efficient methods to generate large prime numbers. In practice, the primes
    used by RSA when encoding Internet transactions are generally a few hundred digits
    long! A CS course on algorithms or cryptography may well show you some of the
    more sophisticated and efficient algorithms for generating primes.</p> </div>
    <div class="section" id="putting-google-on-the-map"> <h2 id="sigil_toc_id_40">3.6
    Putting Google on the Map!</h2> <p>In the rest of this chapter we will continue
    to build on the idea of functions as first-class citizens that can be passed into
    or returned from other functions. We’ll look at two more examples: Google’s MapReduce
    approach to processing data, and taking derivatives of functions.</p> <p>Imagine
    that you work for Nile.com. Your company maintains a list of product prices, and
    periodically the prices are systematically increased. Your boss comes into your
    office one morning and asks you to write a function called <tt class="docutils
    literal"><span class="pre">increment</span></tt> that takes a list of numbers
    as an argument and returns a new list in which each number is replaced by a value
    one greater. So, with the argument <tt class="docutils literal"><span class="pre">[10,</span>
    <span class="pre">20,</span> <span class="pre">30]</span></tt>, the result should
    be <tt class="docutils literal"><span class="pre">[11,</span> <span class="pre">21,</span>
    <span class="pre">31]</span></tt>.</p> <p>No problem! We can write <tt class="docutils
    literal"><span class="pre">increment</span></tt> recursively. For the base case,
    if the argument is an empty list, we’ll also return an empty list. (Remember,
    the result is always a list of the same length as the argument, so returning anything
    other than the empty list in this case would be violating our contract!). For
    the recursive case, we observe that we can easily increment the first number in
    the list: We simply find that element and add one to it. We can then slice that
    first element off the list and increment the remainder. The phrase “increment
    the remainder” is essentially saying “use recursion on the remaining list.” In
    other words, <tt class="docutils literal"><span class="pre">increment([10,</span>
    <span class="pre">20,</span> <span class="pre">30])</span></tt> will first find
    the 10, add one to make it 11, and then recursively call <tt class="docutils literal"><span
    class="pre">increment([20,</span> <span class="pre">30])</span></tt> to get the
    result <tt class="docutils literal"><span class="pre">[21,</span> <span class="pre">31]</span></tt>.
    Once we have that, we just concatenate the 11 to the front of that list, resulting
    in <tt class="docutils literal"><span class="pre">[11,</span> <span class="pre">21,</span>
    <span class="pre">31]</span></tt>. Here’s the Python program:</p> <div class="highlight-python"><div
    class="highlight"><pre><span class="k">def</span> <span class="nf">incrementList</span><span
    class="p">(</span><span class="n">numberList</span><span class="p">):</span> <span
    class="sd">''''''Takes a list of numbers as an argument and returns</span> <span
    class="sd"> a new list with each number incremented by one.''''''</span> <span
    class="k">if</span> <span class="n">numberList</span> <span class="o">==</span>
    <span class="p">[]:</span> <span class="k">return</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">newFirst</span>
    <span class="o">=</span> <span class="n">numberList</span><span class="p">[</span><span
    class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c"># increment 1st element</span> <span class="c"># Next, increment
    the remaining list</span> <span class="n">incrementedList</span> <span class="o">=</span>
    <span class="n">incrementList</span><span class="p">(</span><span class="n">numberList</span><span
    class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="c">#
    Now return the new first element and the</span> <span class="c"># incremented
    remaining list</span> <span class="k">return</span> <span class="p">[</span><span
    class="n">newFirst</span><span class="p">]</span> <span class="o">+</span> <span
    class="n">incrementedList</span> </pre> </div> </div> <div class="section" id="map">
    <h3 id="sigil_toc_id_41">3.6.1 Map</h3> <div class="figure align-right" style="width:
    150px"> <img alt="../Images/Alien4.PNG" src="../Images/Alien4.PNG"/> <p class="caption"><em>This
    boss is straight out of Dilbert!</em></p> </div> <p>Your boss is pleased, but
    now tells you “I need a very similar function that takes a list as an argument
    and adds 2 to each element in that list.” Obviously, we could modify <tt class="docutils
    literal"><span class="pre">increment</span></tt> very slightly to do this. Then
    your boss tells you, “I need yet another function that takes a list as an argument
    and triples each element.” We can do that too, but this is getting old.</p> <p>We
    see that your boss frequently needs us to write functions that take a list of
    numbers as an argument and return a new list in which <em>some function</em> is
    applied to every element in that list.</p> <div class="figure align-right" style="width:
    150px"> <a class="reference internal image-reference" href="../Images/Alien4.PNG"><img
    alt="../Images/Alien4.PNG" src="../Images/Alien4.PNG" style="width: 0px;"/></a>
    <p class="caption"><em>This is known more succinctly as the principle of</em>
    generalization. <em>We’re trying to make our function more general and less specific.</em></p>
    </div> <p>An important principle in computer science is “if you are building lots
    of very similar things, try instead to build one thing that can do it all.”</p>
    <p>We’ve seen this principle before when we started writing functions, but here
    we’ll take it one step further. The “do it all” thing in this case is a function
    called <tt class="docutils literal"><span class="pre">map</span></tt>, which is
    built in to Python and many other functional programming languages. We’ll show
    it to you and then explain. But first, it will be handy to have two simple functions
    to help with our example. One function, called <tt class="docutils literal"><span
    class="pre">increment</span></tt>, takes a number as an argument and returns that
    number plus 1\. The second, called <tt class="docutils literal"><span class="pre">triple</span></tt>,
    takes a number as an argument and returns three times that number:</p> <div class="highlight-python"><div
    class="highlight"><pre><span class="k">def</span> <span class="nf">increment</span><span
    class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="sd">''''''Takes
    a number x as an argument and returns x + 1.''''''</span> <span class="k">return</span>
    <span class="n">x</span><span class="o">+</span><span class="mi">1</span> </pre>
    </div> </div> <div class="highlight-python"><div class="highlight"><pre><span
    class="k">def</span> <span class="nf">triple</span><span class="p">(</span><span
    class="n">x</span><span class="p">):</span> <span class="sd">''''''Takes a number
    x as an argument and returns 3 * x.''''''</span> <span class="k">return</span>
    <span class="mi">3</span> <span class="o">*</span> <span class="n">x</span> </pre>
    </div> </div> <p>If you’re using Python 2, you can now do the following:</p> <div
    class="highlight-python"><div class="highlight"><pre><span class="gp">>>> </span><span
    class="nb">map</span><span class="p">(</span><span class="n">increment</span><span
    class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span>
    <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span
    class="p">])</span> <span class="go">[11, 21, 31]</span> <span class="gp">>>>
    </span><span class="nb">map</span><span class="p">(</span><span class="n">triple</span><span
    class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span>
    <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span
    class="p">,</span> <span class="mi">4</span><span class="p">])</span> <span class="go">[3,
    6, 9, 12]</span> </pre> </div> </div> <p>If you’re using Python 3, <tt class="docutils
    literal"><span class="pre">map</span></tt> is a bit lazy and requires some cajoling
    to produce the list, just like <tt class="docutils literal"><span class="pre">filter</span></tt>
    did. The magic incantation required in Python 3 looks like this:</p> <div class="highlight-python"><div
    class="highlight"><pre><span class="gp">>>> </span><span class="nb">list</span><span
    class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">increment</span><span
    class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span>
    <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span
    class="p">]))</span> <span class="go">[11, 21, 31]</span> <span class="gp">>>>
    </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span
    class="p">(</span><span class="n">triple</span><span class="p">,</span> <span
    class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span
    class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span
    class="p">]))</span> <span class="go">[3, 6, 9, 12]</span> </pre> </div> </div>
    <p>This is passing the result of <tt class="docutils literal"><span class="pre">map</span></tt>
    to a built-in function called <tt class="docutils literal"><span class="pre">list</span></tt>,
    which forces Python 3 to actually produce the list.</p> <p>Notice that <tt class="docutils
    literal"><span class="pre">map</span></tt> takes two arguments. The first is a
    function; the second is a list. The function that is given to <tt class="docutils
    literal"><span class="pre">map</span></tt> (e.g., <tt class="docutils literal"><span
    class="pre">increment</span></tt> and <tt class="docutils literal"><span class="pre">triple</span></tt>
    in our examples) <strong>must</strong> be a function that takes one argument and
    produces a single result. Then, <tt class="docutils literal"><span class="pre">map</span></tt>
    applies that function one-by-one to each element in the list to build a new list
    of elements.</p> <p>Sometimes, we don’t need to create our own functions to give
    to <tt class="docutils literal"><span class="pre">map</span></tt>. For example,
    take a look at this example:</p> <div class="highlight-python"><div class="highlight"><pre><span
    class="gp">>>> </span><span class="nb">map</span><span class="p">(</span><span
    class="nb">len</span><span class="p">,</span> <span class="p">[</span><span class="s">''I''</span><span
    class="p">,</span> <span class="s">''like''</span><span class="p">,</span> <span
    class="s">''spam''</span><span class="p">])</span> <span class="go">[1, 4, 4]</span>
    </pre> </div> </div> <p>In Python 3, this would be</p> <div class="highlight-python"><div
    class="highlight"><pre><span class="gp">>>> </span><span class="nb">list</span><span
    class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span
    class="p">,</span> <span class="p">[</span><span class="s">''I''</span><span class="p">,</span>
    <span class="s">''like''</span><span class="p">,</span> <span class="s">''spam''</span><span
    class="p">]))</span> <span class="go">[1, 4, 4]</span> </pre> </div> </div> <p>In
    this case, the built-in function <tt class="docutils literal"><span class="pre">len</span></tt>
    is applied to each of the strings in the given list. First, <tt class="docutils
    literal"><span class="pre">len</span></tt> is applied to the string <tt class="docutils
    literal"><span class="pre">''I''</span></tt>. The length of the string is 1 and
    that’s the first thing to go in the result list. Then the <tt class="docutils
    literal"><span class="pre">len</span></tt> function is applied to the string <tt
    class="docutils literal"><span class="pre">''like''</span></tt>; the result is
    4, which is the next thing to go in the result. Finally, the length of <tt class="docutils
    literal"><span class="pre">''spam''</span></tt> is 4, which is the last value
    placed in the result list.</p> <p>Notice how our abstraction theme comes into
    play with <tt class="docutils literal"><span class="pre">map</span></tt>. The
    details of how the function we pass to <tt class="docutils literal"><span class="pre">map</span></tt>
    is applied to the list are hidden away. We no longer have to worry specifically
    about how to step through the list to modify each element: <tt class="docutils
    literal"><span class="pre">map</span></tt> does this for us.</p> <div class="admonition
    note" id="index-7"> <p class="first admonition-title">Note</p> <dl class="last
    docutils"> <dt><strong>List Comprehensions</strong></dt> <dd><p class="first">The
    <tt class="docutils literal"><span class="pre">map</span></tt>, <tt class="docutils
    literal"><span class="pre">reduce</span></tt>, and <tt class="docutils literal"><span
    class="pre">filter</span></tt> functions, and the <tt class="docutils literal"><span
    class="pre">lambda</span></tt> notation for anonymous functions, are not unique
    to Python; they are found in most functional programming languages. However, Python
    offers an alternative syntax to <tt class="docutils literal"><span class="pre">map</span></tt>
    and <tt class="docutils literal"><span class="pre">filter</span></tt> called <em>list
    comprehensions</em>, which allow us to avoid using <tt class="docutils literal"><span
    class="pre">lambda</span></tt>. Sometimes that’s both conceptually easier and
    faster to type!</p> <p>Let’s start with the example from Section 3.6.1, where
    we wanted to increment every element in the list <tt class="docutils literal"><span
    class="pre">[10,</span> <span class="pre">20,</span> <span class="pre">30]</span></tt>.
    Whereas earlier we used <tt class="docutils literal"><span class="pre">map</span></tt>
    and an <tt class="docutils literal"><span class="pre">increment</span></tt> function
    to do this, the list comprehension syntax looks like this:</p> <div class="highlight-python"><div
    class="highlight"><pre><span class="gp">>>> </span><span class="p">[</span><span
    class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span>
    <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span
    class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>
    <span class="mi">30</span><span class="p">]]</span> <span class="go">[11, 21,
    31]</span> </pre> </div> </div> <p>Similarly, we can triple every element in the
    list <tt class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span>
    <span class="pre">3,</span> <span class="pre">4]</span></tt> using the syntax:</p>
    <div class="highlight-python"><div class="highlight"><pre><span class="gp">>>>
    </span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span>
    <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span
    class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span>
    <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span
    class="p">,</span> <span class="mi">4</span><span class="p">]]</span> <span class="go">[3,
    6, 9, 12]</span> </pre> </div> </div> <p>In general, the syntax is:</p> <p><tt
    class="docutils literal"><span class="pre">[f(x)</span> <span class="pre">for</span>
    <span class="pre">x</span> <span class="pre">in</span> <span class="pre">L]</span></tt></p>
    <p>...where <tt class="docutils literal"><span class="pre">f</span></tt> is some
    function and <tt class="docutils literal"><span class="pre">L</span></tt> is some
    list. Notice that this is really just like <tt class="docutils literal"><span
    class="pre">map</span></tt> in that we are mapping the function <tt class="docutils
    literal"><span class="pre">f</span></tt> to every element <tt class="docutils
    literal"><span class="pre">x</span></tt> in the list <tt class="docutils literal"><span
    class="pre">L</span></tt>. By the way, there’s nothing special about the name
    <tt class="docutils literal"><span class="pre">x</span></tt> for the variable;
    we could use a different variable name as in:</p> <div class="highlight-python"><div
    class="highlight"><pre><span class="gp">>>> </span><span class="p">[</span><span
    class="nb">len</span><span class="p">(</span><span class="n">myString</span><span
    class="p">)</span> <span class="k">for</span> <span class="n">myString</span>
    <span class="ow">in</span> <span class="p">[</span><span class="s">''I''</span><span
    class="p">,</span> <span class="s">''like''</span><span class="p">,</span> <span
    class="s">''spam''</span><span class="p">]]</span> <span class="go">[1, 4, 4]</span>
    </pre> </div> </div> <p>A very similar syntax can be used to do the job of <tt
    class="docutils literal"><span class="pre">filter</span></tt>. Rather than using
    <tt class="docutils literal"><span class="pre">filter</span></tt> to obtain the
    four-letter words in a list as we saw earlier, we can use list comprehensions
    this way:</p> <div class="highlight-python"><div class="highlight"><pre><span
    class="gp">>>> </span><span class="n">words</span> <span class="o">=</span> <span
    class="p">[</span><span class="s">''aardvark''</span><span class="p">,</span>
    <span class="s">''darn''</span><span class="p">,</span> <span class="s">''heck''</span><span
    class="p">,</span> <span class="s">''spam''</span><span class="p">,</span> <span
    class="s">''zyzzyva''</span><span class="p">]</span> <span class="gp">>>> </span><span
    class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span>
    <span class="ow">in</span> <span class="n">words</span> <span class="k">if</span>
    <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span
    class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">]</span>
    <span class="go">[''darn'', ''heck'', ''spam'']</span> </pre> </div> </div> <p>In
    this case, we defined the list <tt class="docutils literal"><span class="pre">words</span></tt>
    before using the list comprehension, just to make the point that we can do that.
    Of course, we could have also done this as:</p> <div class="highlight-python"><div
    class="highlight"><pre><span class="gp">>>> </span><span class="p">[</span><span
    class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>
    <span class="p">[</span><span class="s">''aardvark''</span><span class="p">,</span>
    <span class="s">''darn''</span><span class="p">,</span> <span class="s">''heck''</span><span
    class="p">,</span> <span class="s">''spam''</span><span class="p">,</span> <span
    class="s">''zyzzyva''</span><span class="p">]</span> <span class="gp">... </span><span
    class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span
    class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">]</span>
    </pre> </div> </div> <p>Similarly, we could get the multiples of 42 between 0
    and 1 million (another example where we used <tt class="docutils literal"><span
    class="pre">filter</span></tt>) this way:</p> <div class="highlight-python"><div
    class="highlight"><pre><span class="gp">>>> </span><span class="p">[</span><span
    class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>
    <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span
    class="p">,</span> <span class="mi">1000000</span><span class="p">)</span> <span
    class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">42</span>
    <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> </pre>
    </div> </div> <p>In general, the format for using list comprehensions to filter
    looks like this:</p> <p><tt class="docutils literal"><span class="pre">[x</span>
    <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span>
    <span class="pre">L</span> <span class="pre">if</span> <span class="pre">...]</span></tt></p>
    <p>...where <tt class="docutils literal"><span class="pre">L</span></tt> is a
    list and the ... represents some Boolean expression; that is, an expression that
    evaluates to either <tt class="docutils literal"><span class="pre">True</span></tt>
    or <tt class="docutils literal"><span class="pre">False</span></tt>. We get back
    the list of all values of <tt class="docutils literal"><span class="pre">x</span></tt>
    in the list <tt class="docutils literal"><span class="pre">L</span></tt> for which
    that Boolean expression (recall that it’s called a predicate) is <tt class="docutils
    literal"><span class="pre">True</span></tt>. That is, we get all of the values
    of <tt class="docutils literal"><span class="pre">x</span></tt> that the predicate
    “likes.” Finally, we can write list comprehensions that combine both <tt class="docutils
    literal"><span class="pre">map</span></tt> and <tt class="docutils literal"><span
    class="pre">filter</span></tt> into one. Here’s an example where we produce the
    square of every even number between 0 and 10:</p> <div class="highlight-python"><div
    class="highlight"><pre><span class="gp">>>> </span><span class="p">[</span><span
    class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span>
    <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span
    class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span
    class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span>
    <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span
    class="p">]</span> <span class="go">[0, 4, 16, 36, 64, 100]</span> </pre> </div>
    </div> <p>This list comprehension is mapping the function <span class="math">\(f(x)
    = x^2\)</span> to every value of <tt class="docutils literal"><span class="pre">x</span></tt>
    in the list of integers from 0 to 10 subject to filtering that list through a
    predicate that only likes even numbers. Thus, we get the squares of even numbers.
    In general, the syntax is:</p> <p><tt class="docutils literal"><span class="pre">[f(x)</span>
    <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span>
    <span class="pre">L</span> <span class="pre">if</span> <span class="pre">...]</span></tt></p>
    <p>where <tt class="docutils literal"><span class="pre">f</span></tt> is a function,
    <tt class="docutils literal"><span class="pre">L</span></tt> is a list, and what
    comes after the <span class="math">\(\dots\)</span> is a predicate. We get back
    the list of <span class="math">\(f(x)\)</span> values for those values of <tt
    class="docutils literal"><span class="pre">x</span></tt> for which the predicate
    is <tt class="docutils literal"><span class="pre">True</span></tt>.</p> <p class="last">By
    the way, this syntax works just the same in Python 2 and 3\. Python 3 doesn’t
    require any special prodding to produce a list when list comprehensions are used.</p>
    </dd> </dl> </div> </div> <div class="section" id="reduce"> <h3 id="sigil_toc_id_42">3.6.2
    Reduce</h3> <div class="figure align-right" style="width: 150px"> <img alt="../Images/Alien4.PNG"
    src="../Images/Alien4.PNG"/> <p class="caption"><em>Ten mochaccinos, a laptop,
    the Harry Potter DVD collection,...</em></p> </div> <p>Our alien has just learned
    about <tt class="docutils literal"><span class="pre">map</span></tt> and is quite
    excited. During its visit to Earth, the alien purchased a number of items and
    it plans to request reimbursement from its employer.</p> <p>For example, here
    is a list of the costs, in U.S. dollars, of several items purchased by the alien:
    <tt class="docutils literal"><span class="pre">[14,</span> <span class="pre">10,</span>
    <span class="pre">12,</span> <span class="pre">5]</span></tt>. The alien would
    like to convert these costs to its own currency and then add up the total. The
    exchange rate is 1 U.S. dollar equals 3 alien dollars. So, the values of the four
    items in alien dollars are <tt class="docutils literal"><span class="pre">[42,</span>
    <span class="pre">30,</span> <span class="pre">36,</span> <span class="pre">15]</span></tt>
    and the total request for reimbursement in alien dollars will be <span class="math">\(42
    + 30 + 36 + 15 =123\)</span>.</p> <p>Converting a list from U.S. dollars to alien
    dollars is no problem—we did that above using <tt class="docutils literal"><span
    class="pre">map</span></tt> and our <tt class="docutils literal"><span class="pre">triple</span></tt>
    function. Now, though, we want to add up the elements in the resulting list. We
    could write a recursive function for that task. However, it turns out that there
    are many very similar tasks that the alien needs to perform as well.</p> <p>Here’s
    one: Imagine that the alien converted between a variety of currencies while shopping
    on Earth. For example, the alien first got some dollars, then changed dollars
    into Euros, then changed Euros into rubles, and then rubles into yen. If the alien
    started with 1 U.S. dollar, how many yen is that? This is a matter of computing
    the products of exchange rates. If one dollar is 0.7 Euros, one Euro is 42 rubles,
    and one ruble is 3 yen, then one dollar is <span class="math">\(0.7 \times 42
    \times 3 = 88.2\)</span> yen. So now the alien needs to compute the <em>product</em>
    of a list of numbers.</p> <p>Again, rather than writing a separate function to
    add up the numbers in a list and another to multiply the numbers in a list (and
    possibly others to do other things to elements in a list), Python provides a general-purpose
    function called <tt class="docutils literal"><span class="pre">reduce</span></tt>
    that reduces all of the elements in a list to a single element (e.g., their sum
    or product or something else).</p> <p>Let’s first define a function called <tt
    class="docutils literal"><span class="pre">add</span></tt> that takes <em>two</em>
    arguments and returns their sum, and another called <tt class="docutils literal"><span
    class="pre">multiply</span></tt> that takes <em>two</em> arguments and returns
    their product.</p> <div class="highlight-python"><div class="highlight"><pre><span
    class="k">def</span> <span class="nf">add</span><span class="p">(</span><span
    class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">''''''Returns the sum of the two arguments.''''''</span> <span
    class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span
    class="n">y</span> <span class="k">def</span> <span class="nf">multiply</span><span
    class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span
    class="p">):</span> <span class="sd">''''''Takes two numbers and returns their
    product.''''''</span> <span class="k">return</span> <span class="n">x</span> <span
    class="o">*</span> <span class="n">y</span> </pre> </div> </div> <p>Now, here’s
    <tt class="docutils literal"><span class="pre">reduce</span></tt> in action:</p>
    <div class="highlight-python"><div class="highlight"><pre><span class="gp">>>>
    </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span>
    <span class="o">*</span> <span class="gp">>>> </span><span class="nb">reduce</span><span
    class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">[</span><span
    class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span
    class="p">])</span> <span class="go">10</span> <span class="gp">>>> </span><span
    class="nb">reduce</span><span class="p">(</span><span class="n">multiply</span><span
    class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span>
    <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span
    class="p">,</span> <span class="mi">4</span><span class="p">])</span> <span class="go">24</span>
    </pre> </div> </div> <p>In the first case <tt class="docutils literal"><span class="pre">reduce</span></tt>
    reduced our list to the sum of its elements, and in the second case to the product
    of its elements. Notice that the first argument to <tt class="docutils literal"><span
    class="pre">reduce</span></tt> is a function and the second is a list. A subtle
    point here is that the function that we give as an argument to <tt class="docutils
    literal"><span class="pre">reduce</span></tt> must take <em>two</em> arguments
    and return a single result. Then, <tt class="docutils literal"><span class="pre">reduce</span></tt>
    takes the first two elements from the list and applies the given function to reduce
    them to one element, takes that result and the next element from the list and
    applies the function to them, and repeats that process until all of the elements
    are reduced to a single value.</p> <div class="figure align-right" style="width:
    150px"> <a class="reference internal image-reference" href="../Images/Alien4.PNG"><img
    alt="../Images/Alien4.PNG" src="../Images/Alien4.PNG" style="width: 0px;"/></a>
    <p class="caption"><em>While</em> <tt class="docutils literal"><span class="pre">reduce</span></tt>
    <em>is built in to Python 2, in Python 3 you’ll need to include the line</em>
    <tt class="docutils literal"><span class="pre">from</span> <span class="pre">functools</span>
    <span class="pre">import</span> <span class="pre">*</span></tt> <em>before using</em>
    <tt class="docutils literal"><span class="pre">reduce</span></tt>. <em>You can
    include that line at the Python prompt or at the top of any file that uses</em>
    <tt class="docutils literal"><span class="pre">reduce</span></tt>.</p> </div>
    </div> <div class="section" id="composition-and-mapreduce"> <h3 id="sigil_toc_id_43">3.6.3
    Composition and MapReduce</h3> <div class="figure align-right" style="width: 150px">
    <a class="reference internal image-reference" href="../Images/Alien4.PNG"><img
    alt="../Images/Alien4.PNG" src="../Images/Alien4.PNG" style="width: 0px;"/></a>
    <p class="caption"><em>Remember that in Python 3 you’ll need to include the line</em>
    <tt class="docutils literal"><span class="pre">from</span> <span class="pre">functools</span>
    <span class="pre">import</span> <span class="pre">*</span></tt> <em>since we’re
    using</em> <tt class="docutils literal"><span class="pre">reduce</span></tt> <em>here</em>.</p>
    </div> <p id="index-8">Finally, imagine that we plan to frequently take a list,
    map some function (e.g., <tt class="docutils literal"><span class="pre">triple</span></tt>)
    to each element in that list to produce a new list (e.g., the list of 3 times
    each element), and then apply some other function to reduce that new list to a
    single value (e.g., using <tt class="docutils literal"><span class="pre">add</span></tt>
    to get the sum of these values). This is a combination of <tt class="docutils
    literal"><span class="pre">map</span></tt> and <tt class="docutils literal"><span
    class="pre">reduce</span></tt>, or more accurately the <em>composition</em> of
    <tt class="docutils literal"><span class="pre">map</span></tt> and <tt class="docutils
    literal"><span class="pre">reduce</span></tt>. Let’s write such a function and
    call it <tt class="docutils literal"><span class="pre">mapReduce</span></tt>.
    It will take two functions and a list as arguments—the first function for <tt
    class="docutils literal"><span class="pre">map</span></tt> and the second for
    <tt class="docutils literal"><span class="pre">reduce</span></tt>:</p> <div id="ch03_mapreduce"><div
    class="ExecutionVisualizer"><div id="vizHeader" style="display: none;"> <textarea
    class="vizTitleText" id="vizTitleEditor" cols="60" rows="1" style="display: none;"/>
    <div class="vizTitleText" id="vizTitleViewer"/> <textarea class="vizDescriptionText"
    id="vizDescriptionEditor" cols="75" rows="2" style="display: none;"/> <div class="vizDescriptionText"
    id="vizDescriptionViewer"/> </div> <table border="0" class="visualizer"><tbody><tr><td
    class="vizLayoutTd" id="vizLayoutTdFirst"><div id="codeDisplayDiv" style="max-width:
    500px;"> <div id="pyCodeOutputDiv" style="max-width: 500px; max-height: 400px;"><table
    id="pyCodeOutput"><tbody><tr><td id="gutterTD" valign="top" rowspan="22"><svg
    id="leftCodeGutterSVG" style="height: 519px;"><polygon id="prevLineArrow" points="0,3
    12,3 12,0 18,5 12,10 12,7 0,7" fill="#c9e6ca" style="display: none;"/><polygon
    id="curLineArrow" points="0,3 12,3 12,0 18,5 12,10 12,7 0,7" fill="#e93f34" transform="translate(0,
    5.3603515625)"/></svg> </td> <td class="lineNo" id="lineNo1">1</td> <td class="cod"
    id="v2__cod1">def add(x, y):</td> </tr> <tr><td class="lineNo" id="lineNo2">2</td>
    <td class="cod" id="v2__cod2">    ''''''Returns the sum of the two</td> </tr>
    <tr><td class="lineNo" id="lineNo3">3</td> <td class="cod" id="v2__cod3">            arguments.''''''</td>
    </tr> <tr><td class="lineNo" id="lineNo4">4</td> <td class="cod" id="v2__cod4">    return x + y</td>
    </tr> <tr><td class="lineNo" id="lineNo5">5</td> <td class="cod" id="v2__cod5"/>
    </tr> <tr><td class="lineNo" id="lineNo6">6</td> <td class="cod" id="v2__cod6">def triple(x):</td>
    </tr> <tr><td class="lineNo" id="lineNo7">7</td> <td class="cod" id="v2__cod7">    ''''''Takes a number x as an argument</td>
    </tr> <tr><td class="lineNo" id="lineNo8">8</td> <td class="cod" id="v2__cod8">            and returns 3 * x.''''''</td>
    </tr> <tr><td class="lineNo" id="lineNo9">9</td> <td class="cod" id="v2__cod9">    return 3 * x</td>
    </tr> <tr><td class="lineNo" id="lineNo10">10</td> <td class="cod" id="v2__cod10"/>
    </tr> <tr><td class="lineNo" id="lineNo11">11</td> <td class="cod" id="v2__cod11">def mapReduce(mapFunction, reduceFunction, myList):</td>
    </tr> <tr><td class="lineNo" id="lineNo12">12</td> <td class="cod" id="v2__cod12">    ''''''Applies mapFunction to myList to</td>
    </tr> <tr><td class="lineNo" id="lineNo13">13</td> <td class="cod" id="v2__cod13">            construct a new list and then</td>
    </tr> <tr><td class="lineNo" id="lineNo14">14</td> <td class="cod" id="v2__cod14">            applies reduceFunction to the</td>
    </tr> <tr><td class="lineNo" id="lineNo15">15</td> <td class="cod" id="v2__cod15">            new list and returns</td>
    </tr> <tr><td class="lineNo" id="lineNo16">16</td> <td class="cod" id="v2__cod16">            reduceFunction''s result.''''''</td>
    </tr> <tr><td class="lineNo" id="lineNo17">17</td> <td class="cod" id="v2__cod17"/>
    </tr> <tr><td class="lineNo" id="lineNo18">18</td> <td class="cod" id="v2__cod18">    newList = map(mapFunction, myList)</td>
    </tr> <tr><td class="lineNo" id="lineNo19">19</td> <td class="cod" id="v2__cod19">    value = reduce(reduceFunction, newList)</td>
    </tr> <tr><td class="lineNo" id="lineNo20">20</td> <td class="cod" id="v2__cod20">    return value</td>
    </tr> <tr><td class="lineNo" id="lineNo21">21</td> <td class="cod" id="v2__cod21"/>
    </tr> <tr><td class="lineNo" id="lineNo22">22</td> <td class="cod" id="v2__cod22">print (mapReduce(triple, add, [14, 10, 12, 5]))</td>
    </tr> </tbody> </table> </div> <div id="editCodeLinkDiv" style="display: none;"><a
    id="editBtn" href="#">Edit code</a></div> <div id="executionSlider" class="ui-slider
    ui-slider-horizontal ui-widget ui-widget-content ui-corner-all" style="width:
    480px; font-size: 0.9em;"></div> <div id="vcrControls"> <button id="jmpFirstInstr"
    type="button" disabled="disabled"><< First</button> <button id="jmpStepBack" type="button"
    disabled="disabled">< Back</button> <span id="curInstr">Step 1 of 22</span> <button
    id="jmpStepFwd" type="button">Forward ></button> <button id="jmpLastInstr" type="button">Last
    >></button> </div> <div id="errorOutput" style="display: none;"/> <div id="legendDiv"><svg
    id="prevLegendArrowSVG"><polygon points="0,3 12,3 12,0 18,5 12,10 12,7 0,7" fill="#c9e6ca"/></svg>
    line that has just executed<p style="margin-top: 4px"><svg id="curLegendArrowSVG"><polygon
    points="0,3 12,3 12,0 18,5 12,10 12,7 0,7" fill="#e93f34"/></svg> next line to
    execute</p> </div> <div id="stepAnnotationDiv"> <textarea class="annotationText"
    id="stepAnnotationEditor" cols="60" rows="3" style="display: none;"/> <div class="annotationText"
    id="stepAnnotationViewer"/> </div> <div id="annotateLinkDiv"><button id="annotateBtn"
    type="button" style="display: none;">Annotate this step</button></div> </div>
    <div id="htmlOutputDiv"/> <div id="progOutputs" style="display: none;"> Program
    output:<br/> <textarea id="pyStdout" cols="50" rows="10" wrap="off" readonly=""
    style="max-width: 500px;"/> </div> </td> </tr> <tr><td class="vizLayoutTd" id="vizLayoutTdSecond"><div
    id="dataViz"> <table id="stackHeapTable"> <tbody><tr> <td id="stack_td"> <div
    id="globals_area"> <div id="stackHeader">Frames</div> <div class="stackFrame highlightedStackFrame"
    id="v2__globals" style="display: none;"><div id="v2__globals_header" class="stackFrameHeader">Global
    variables</div> <table class="stackFrameVarTable" id="v2__global_table"/> </div>
    </div> <div id="stack"/> </td> <td id="heap_td"> <div id="heap"> <div id="heapHeader">Objects</div>
    </div> </td> </tr> </tbody> </table> </div> </td> </tr> </tbody> </table> </div>
    </div> <p class="cl_caption"><span class="cl_caption_text"> (ch03_mapreduce)</span>
    </p> <script type="text/javascript"> var ch03_mapreduce_trace = {"code": "def
    add(x, y):\n ''''''Returns the sum of the two\n arguments.''''''\n return x +
    y\n\ndef triple(x):\n ''''''Takes a number x as an argument\n and returns 3 *
    x.''''''\n return 3 * x\n\ndef mapReduce(mapFunction, reduceFunction, myList):\n
    ''''''Applies mapFunction to myList to\n construct a new list and then\n applies
    reduceFunction to the\n new list and returns\n reduceFunction''s result.''''''\n\n
    newList = map(mapFunction, myList)\n value = reduce(reduceFunction, newList)\n
    return value\n\nprint (mapReduce(triple, add, [14, 10, 12, 5]))", "trace": [{"ordered_globals":
    [], "stdout": "", "func_name": "<module>", "stack_to_render": [], "globals": {},
    "heap": {}, "line": 1, "event": "step_line"}, {"ordered_globals": ["add"], "stdout":
    "", "func_name": "<module>", "stack_to_render": [], "globals": {"add": ["REF",
    1]}, "heap": {"1": ["FUNCTION", "add(x, y)", null]}, "line": 6, "event": "step_line"},
    {"ordered_globals": ["add", "triple"], "stdout": "", "func_name": "<module>",
    "stack_to_render": [], "globals": {"add": ["REF", 1], "triple": ["REF", 2]}, "heap":
    {"1": ["FUNCTION", "add(x, y)", null], "2": ["FUNCTION", "triple(x)", null]},
    "line": 11, "event": "step_line"}, {"ordered_globals": ["add", "triple", "mapReduce"],
    "stdout": "", "func_name": "<module>", "stack_to_render": [], "globals": {"add":
    ["REF", 1], "mapReduce": ["REF", 3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION",
    "add(x, y)", null], "2": ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction,
    reduceFunction, myList)", null]}, "line": 22, "event": "step_line"}, {"ordered_globals":
    ["add", "triple", "mapReduce"], "stdout": "", "func_name": "mapReduce", "stack_to_render":
    [{"frame_id": 1, "encoded_locals": {"reduceFunction": ["REF", 1], "myList": ["REF",
    4], "mapFunction": ["REF", 2]}, "is_highlighted": true, "is_parent": false, "func_name":
    "mapReduce", "is_zombie": false, "parent_frame_id_list": [], "unique_hash": "mapReduce_f1",
    "ordered_varnames": ["mapFunction", "reduceFunction", "myList"]}], "globals":
    {"add": ["REF", 1], "mapReduce": ["REF", 3], "triple": ["REF", 2]}, "heap": {"1":
    ["FUNCTION", "add(x, y)", null], "2": ["FUNCTION", "triple(x)", null], "3": ["FUNCTION",
    "mapReduce(mapFunction, reduceFunction, myList)", null], "4": ["LIST", 14, 10,
    12, 5]}, "line": 11, "event": "call"}, {"ordered_globals": ["add", "triple", "mapReduce"],
    "stdout": "", "func_name": "mapReduce", "stack_to_render": [{"frame_id": 1, "encoded_locals":
    {"reduceFunction": ["REF", 1], "myList": ["REF", 4], "mapFunction": ["REF", 2]},
    "is_highlighted": true, "is_parent": false, "func_name": "mapReduce", "is_zombie":
    false, "parent_frame_id_list": [], "unique_hash": "mapReduce_f1", "ordered_varnames":
    ["mapFunction", "reduceFunction", "myList"]}], "globals": {"add": ["REF", 1],
    "mapReduce": ["REF", 3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(x,
    y)", null], "2": ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction,
    reduceFunction, myList)", null], "4": ["LIST", 14, 10, 12, 5]}, "line": 18, "event":
    "step_line"}, {"ordered_globals": ["add", "triple", "mapReduce"], "stdout": "",
    "func_name": "triple", "stack_to_render": [{"frame_id": 1, "encoded_locals": {"reduceFunction":
    ["REF", 1], "myList": ["REF", 4], "mapFunction": ["REF", 2]}, "is_highlighted":
    false, "is_parent": false, "func_name": "mapReduce", "is_zombie": false, "parent_frame_id_list":
    [], "unique_hash": "mapReduce_f1", "ordered_varnames": ["mapFunction", "reduceFunction",
    "myList"]}, {"frame_id": 2, "encoded_locals": {"x": 14}, "is_highlighted": true,
    "is_parent": false, "func_name": "triple", "is_zombie": false, "parent_frame_id_list":
    [], "unique_hash": "triple_f2", "ordered_varnames": ["x"]}], "globals": {"add":
    ["REF", 1], "mapReduce": ["REF", 3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION",
    "add(x, y)", null], "2": ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction,
    reduceFunction, myList)", null], "4": ["LIST", 14, 10, 12, 5]}, "line": 6, "event":
    "call"}, {"ordered_globals": ["add", "triple", "mapReduce"], "stdout": "", "func_name":
    "triple", "stack_to_render": [{"frame_id": 1, "encoded_locals": {"reduceFunction":
    ["REF", 1], "myList": ["REF", 4], "mapFunction": ["REF", 2]}, "is_highlighted":
    false, "is_parent": false, "func_name": "mapReduce", "is_zombie": false, "parent_frame_id_list":
    [], "unique_hash": "mapReduce_f1", "ordered_varnames": ["mapFunction", "reduceFunction",
    "myList"]}, {"frame_id": 2, "encoded_locals": {"x": 14}, "is_highlighted": true,
    "is_parent": false, "func_name": "triple", "is_zombie": false, "parent_frame_id_list":
    [], "unique_hash": "triple_f2", "ordered_varnames": ["x"]}], "globals": {"add":
    ["REF", 1], "mapReduce": ["REF", 3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION",
    "add(x, y)", null], "2": ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction,
    reduceFunction, myList)", null], "4": ["LIST", 14, 10, 12, 5]}, "line": 9, "event":
    "step_line"}, {"ordered_globals": ["add", "triple", "mapReduce"], "stdout": "",
    "func_name": "triple", "stack_to_render": [{"frame_id": 1, "encoded_locals": {"reduceFunction":
    ["REF", 1], "myList": ["REF", 4], "mapFunction": ["REF", 2]}, "is_highlighted":
    false, "is_parent": false, "func_name": "mapReduce", "is_zombie": false, "parent_frame_id_list":
    [], "unique_hash": "mapReduce_f1", "ordered_varnames": ["mapFunction", "reduceFunction",
    "myList"]}, {"frame_id": 2, "encoded_locals": {"__return__": 42, "x": 14}, "is_highlighted":
    true, "is_parent": false, "func_name": "triple", "is_zombie": false, "parent_frame_id_list":
    [], "unique_hash": "triple_f2", "ordered_varnames": ["x", "__return__"]}], "globals":
    {"add": ["REF", 1], "mapReduce": ["REF", 3], "triple": ["REF", 2]}, "heap": {"1":
    ["FUNCTION", "add(x, y)", null], "2": ["FUNCTION", "triple(x)", null], "3": ["FUNCTION",
    "mapReduce(mapFunction, reduceFunction, myList)", null], "4": ["LIST", 14, 10,
    12, 5]}, "line": 9, "event": "return"}, {"ordered_globals": ["add", "triple",
    "mapReduce"], "stdout": "", "func_name": "triple", "stack_to_render": [{"frame_id":
    1, "encoded_locals": {"reduceFunction": ["REF", 1], "myList": ["REF", 4], "mapFunction":
    ["REF", 2]}, "is_highlighted": false, "is_parent": false, "func_name": "mapReduce",
    "is_zombie": false, "parent_frame_id_list": [], "unique_hash": "mapReduce_f1",
    "ordered_varnames": ["mapFunction", "reduceFunction", "myList"]}, {"frame_id":
    3, "encoded_locals": {"x": 10}, "is_highlighted": true, "is_parent": false, "func_name":
    "triple", "is_zombie": false, "parent_frame_id_list": [], "unique_hash": "triple_f3",
    "ordered_varnames": ["x"]}], "globals": {"add": ["REF", 1], "mapReduce": ["REF",
    3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(x, y)", null], "2":
    ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction, reduceFunction,
    myList)", null], "4": ["LIST", 14, 10, 12, 5]}, "line": 6, "event": "call"}, {"ordered_globals":
    ["add", "triple", "mapReduce"], "stdout": "", "func_name": "triple", "stack_to_render":
    [{"frame_id": 1, "encoded_locals": {"reduceFunction": ["REF", 1], "myList": ["REF",
    4], "mapFunction": ["REF", 2]}, "is_highlighted": false, "is_parent": false, "func_name":
    "mapReduce", "is_zombie": false, "parent_frame_id_list": [], "unique_hash": "mapReduce_f1",
    "ordered_varnames": ["mapFunction", "reduceFunction", "myList"]}, {"frame_id":
    3, "encoded_locals": {"x": 10}, "is_highlighted": true, "is_parent": false, "func_name":
    "triple", "is_zombie": false, "parent_frame_id_list": [], "unique_hash": "triple_f3",
    "ordered_varnames": ["x"]}], "globals": {"add": ["REF", 1], "mapReduce": ["REF",
    3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(x, y)", null], "2":
    ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction, reduceFunction,
    myList)", null], "4": ["LIST", 14, 10, 12, 5]}, "line": 9, "event": "step_line"},
    {"ordered_globals": ["add", "triple", "mapReduce"], "stdout": "", "func_name":
    "triple", "stack_to_render": [{"frame_id": 1, "encoded_locals": {"reduceFunction":
    ["REF", 1], "myList": ["REF", 4], "mapFunction": ["REF", 2]}, "is_highlighted":
    false, "is_parent": false, "func_name": "mapReduce", "is_zombie": false, "parent_frame_id_list":
    [], "unique_hash": "mapReduce_f1", "ordered_varnames": ["mapFunction", "reduceFunction",
    "myList"]}, {"frame_id": 3, "encoded_locals": {"__return__": 30, "x": 10}, "is_highlighted":
    true, "is_parent": false, "func_name": "triple", "is_zombie": false, "parent_frame_id_list":
    [], "unique_hash": "triple_f3", "ordered_varnames": ["x", "__return__"]}], "globals":
    {"add": ["REF", 1], "mapReduce": ["REF", 3], "triple": ["REF", 2]}, "heap": {"1":
    ["FUNCTION", "add(x, y)", null], "2": ["FUNCTION", "triple(x)", null], "3": ["FUNCTION",
    "mapReduce(mapFunction, reduceFunction, myList)", null], "4": ["LIST", 14, 10,
    12, 5]}, "line": 9, "event": "return"}, {"ordered_globals": ["add", "triple",
    "mapReduce"], "stdout": "", "func_name": "triple", "stack_to_render": [{"frame_id":
    1, "encoded_locals": {"reduceFunction": ["REF", 1], "myList": ["REF", 4], "mapFunction":
    ["REF", 2]}, "is_highlighted": false, "is_parent": false, "func_name": "mapReduce",
    "is_zombie": false, "parent_frame_id_list": [], "unique_hash": "mapReduce_f1",
    "ordered_varnames": ["mapFunction", "reduceFunction", "myList"]}, {"frame_id":
    4, "encoded_locals": {"x": 12}, "is_highlighted": true, "is_parent": false, "func_name":
    "triple", "is_zombie": false, "parent_frame_id_list": [], "unique_hash": "triple_f4",
    "ordered_varnames": ["x"]}], "globals": {"add": ["REF", 1], "mapReduce": ["REF",
    3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(x, y)", null], "2":
    ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction, reduceFunction,
    myList)", null], "4": ["LIST", 14, 10, 12, 5]}, "line": 6, "event": "call"}, {"ordered_globals":
    ["add", "triple", "mapReduce"], "stdout": "", "func_name": "triple", "stack_to_render":
    [{"frame_id": 1, "encoded_locals": {"reduceFunction": ["REF", 1], "myList": ["REF",
    4], "mapFunction": ["REF", 2]}, "is_highlighted": false, "is_parent": false, "func_name":
    "mapReduce", "is_zombie": false, "parent_frame_id_list": [], "unique_hash": "mapReduce_f1",
    "ordered_varnames": ["mapFunction", "reduceFunction", "myList"]}, {"frame_id":
    4, "encoded_locals": {"x": 12}, "is_highlighted": true, "is_parent": false, "func_name":
    "triple", "is_zombie": false, "parent_frame_id_list": [], "unique_hash": "triple_f4",
    "ordered_varnames": ["x"]}], "globals": {"add": ["REF", 1], "mapReduce": ["REF",
    3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(x, y)", null], "2":
    ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction, reduceFunction,
    myList)", null], "4": ["LIST", 14, 10, 12, 5]}, "line": 9, "event": "step_line"},
    {"ordered_globals": ["add", "triple", "mapReduce"], "stdout": "", "func_name":
    "triple", "stack_to_render": [{"frame_id": 1, "encoded_locals": {"reduceFunction":
    ["REF", 1], "myList": ["REF", 4], "mapFunction": ["REF", 2]}, "is_highlighted":
    false, "is_parent": false, "func_name": "mapReduce", "is_zombie": false, "parent_frame_id_list":
    [], "unique_hash": "mapReduce_f1", "ordered_varnames": ["mapFunction", "reduceFunction",
    "myList"]}, {"frame_id": 4, "encoded_locals": {"__return__": 36, "x": 12}, "is_highlighted":
    true, "is_parent": false, "func_name": "triple", "is_zombie": false, "parent_frame_id_list":
    [], "unique_hash": "triple_f4", "ordered_varnames": ["x", "__return__"]}], "globals":
    {"add": ["REF", 1], "mapReduce": ["REF", 3], "triple": ["REF", 2]}, "heap": {"1":
    ["FUNCTION", "add(x, y)", null], "2": ["FUNCTION", "triple(x)", null], "3": ["FUNCTION",
    "mapReduce(mapFunction, reduceFunction, myList)", null], "4": ["LIST", 14, 10,
    12, 5]}, "line": 9, "event": "return"}, {"ordered_globals": ["add", "triple",
    "mapReduce"], "stdout": "", "func_name": "triple", "stack_to_render": [{"frame_id":
    1, "encoded_locals": {"reduceFunction": ["REF", 1], "myList": ["REF", 4], "mapFunction":
    ["REF", 2]}, "is_highlighted": false, "is_parent": false, "func_name": "mapReduce",
    "is_zombie": false, "parent_frame_id_list": [], "unique_hash": "mapReduce_f1",
    "ordered_varnames": ["mapFunction", "reduceFunction", "myList"]}, {"frame_id":
    5, "encoded_locals": {"x": 5}, "is_highlighted": true, "is_parent": false, "func_name":
    "triple", "is_zombie": false, "parent_frame_id_list": [], "unique_hash": "triple_f5",
    "ordered_varnames": ["x"]}], "globals": {"add": ["REF", 1], "mapReduce": ["REF",
    3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(x, y)", null], "2":
    ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction, reduceFunction,
    myList)", null], "4": ["LIST", 14, 10, 12, 5]}, "line": 6, "event": "call"}, {"ordered_globals":
    ["add", "triple", "mapReduce"], "stdout": "", "func_name": "triple", "stack_to_render":
    [{"frame_id": 1, "encoded_locals": {"reduceFunction": ["REF", 1], "myList": ["REF",
    4], "mapFunction": ["REF", 2]}, "is_highlighted": false, "is_parent": false, "func_name":
    "mapReduce", "is_zombie": false, "parent_frame_id_list": [], "unique_hash": "mapReduce_f1",
    "ordered_varnames": ["mapFunction", "reduceFunction", "myList"]}, {"frame_id":
    5, "encoded_locals": {"x": 5}, "is_highlighted": true, "is_parent": false, "func_name":
    "triple", "is_zombie": false, "parent_frame_id_list": [], "unique_hash": "triple_f5",
    "ordered_varnames": ["x"]}], "globals": {"add": ["REF", 1], "mapReduce": ["REF",
    3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(x, y)", null], "2":
    ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction, reduceFunction,
    myList)", null], "4": ["LIST", 14, 10, 12, 5]}, "line": 9, "event": "step_line"},
    {"ordered_globals": ["add", "triple", "mapReduce"], "stdout": "", "func_name":
    "triple", "stack_to_render": [{"frame_id": 1, "encoded_locals": {"reduceFunction":
    ["REF", 1], "myList": ["REF", 4], "mapFunction": ["REF", 2]}, "is_highlighted":
    false, "is_parent": false, "func_name": "mapReduce", "is_zombie": false, "parent_frame_id_list":
    [], "unique_hash": "mapReduce_f1", "ordered_varnames": ["mapFunction", "reduceFunction",
    "myList"]}, {"frame_id": 5, "encoded_locals": {"__return__": 15, "x": 5}, "is_highlighted":
    true, "is_parent": false, "func_name": "triple", "is_zombie": false, "parent_frame_id_list":
    [], "unique_hash": "triple_f5", "ordered_varnames": ["x", "__return__"]}], "globals":
    {"add": ["REF", 1], "mapReduce": ["REF", 3], "triple": ["REF", 2]}, "heap": {"1":
    ["FUNCTION", "add(x, y)", null], "2": ["FUNCTION", "triple(x)", null], "3": ["FUNCTION",
    "mapReduce(mapFunction, reduceFunction, myList)", null], "4": ["LIST", 14, 10,
    12, 5]}, "line": 9, "event": "return"}, {"ordered_globals": ["add", "triple",
    "mapReduce"], "stdout": "", "func_name": "mapReduce", "stack_to_render": [{"frame_id":
    1, "encoded_locals": {"reduceFunction": ["REF", 1], "newList": ["REF", 5], "myList":
    ["REF", 4], "mapFunction": ["REF", 2]}, "is_highlighted": true, "is_parent": false,
    "func_name": "mapReduce", "is_zombie": false, "parent_frame_id_list": [], "unique_hash":
    "mapReduce_f1", "ordered_varnames": ["mapFunction", "reduceFunction", "myList",
    "newList"]}], "globals": {"add": ["REF", 1], "mapReduce": ["REF", 3], "triple":
    ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(x, y)", null], "2": ["FUNCTION",
    "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction, reduceFunction,
    myList)", null], "4": ["LIST", 14, 10, 12, 5], "5": ["LIST", 42, 30, 36, 15]},
    "line": 19, "event": "step_line"}, {"ordered_globals": ["add", "triple", "mapReduce"],
    "stdout": "", "func_name": "add", "stack_to_render": [{"frame_id": 1, "encoded_locals":
    {"reduceFunction": ["REF", 1], "newList": ["REF", 5], "myList": ["REF", 4], "mapFunction":
    ["REF", 2]}, "is_highlighted": false, "is_parent": false, "func_name": "mapReduce",
    "is_zombie": false, "parent_frame_id_list": [], "unique_hash": "mapReduce_f1",
    "ordered_varnames": ["mapFunction", "reduceFunction", "myList", "newList"]}, {"frame_id":
    6, "encoded_locals": {"y": 30, "x": 42}, "is_highlighted": true, "is_parent":
    false, "func_name": "add", "is_zombie": false, "parent_frame_id_list": [], "unique_hash":
    "add_f6", "ordered_varnames": ["x", "y"]}], "globals": {"add": ["REF", 1], "mapReduce":
    ["REF", 3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(x, y)", null],
    "2": ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction,
    reduceFunction, myList)", null], "4": ["LIST", 14, 10, 12, 5], "5": ["LIST", 42,
    30, 36, 15]}, "line": 1, "event": "call"}, {"ordered_globals": ["add", "triple",
    "mapReduce"], "stdout": "", "func_name": "add", "stack_to_render": [{"frame_id":
    1, "encoded_locals": {"reduceFunction": ["REF", 1], "newList": ["REF", 5], "myList":
    ["REF", 4], "mapFunction": ["REF", 2]}, "is_highlighted": false, "is_parent":
    false, "func_name": "mapReduce", "is_zombie": false, "parent_frame_id_list": [],
    "unique_hash": "mapReduce_f1", "ordered_varnames": ["mapFunction", "reduceFunction",
    "myList", "newList"]}, {"frame_id": 6, "encoded_locals": {"y": 30, "x": 42}, "is_highlighted":
    true, "is_parent": false, "func_name": "add", "is_zombie": false, "parent_frame_id_list":
    [], "unique_hash": "add_f6", "ordered_varnames": ["x", "y"]}], "globals": {"add":
    ["REF", 1], "mapReduce": ["REF", 3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION",
    "add(x, y)", null], "2": ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction,
    reduceFunction, myList)", null], "4": ["LIST", 14, 10, 12, 5], "5": ["LIST", 42,
    30, 36, 15]}, "line": 4, "event": "step_line"}, {"ordered_globals": ["add", "triple",
    "mapReduce"], "stdout": "", "func_name": "add", "stack_to_render": [{"frame_id":
    1, "encoded_locals": {"reduceFunction": ["REF", 1], "newList": ["REF", 5], "myList":
    ["REF", 4], "mapFunction": ["REF", 2]}, "is_highlighted": false, "is_parent":
    false, "func_name": "mapReduce", "is_zombie": false, "parent_frame_id_list": [],
    "unique_hash": "mapReduce_f1", "ordered_varnames": ["mapFunction", "reduceFunction",
    "myList", "newList"]}, {"frame_id": 6, "encoded_locals": {"y": 30, "x": 42, "__return__":
    72}, "is_highlighted": true, "is_parent": false, "func_name": "add", "is_zombie":
    false, "parent_frame_id_list": [], "unique_hash": "add_f6", "ordered_varnames":
    ["x", "y", "__return__"]}], "globals": {"add": ["REF", 1], "mapReduce": ["REF",
    3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(x, y)", null], "2":
    ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction, reduceFunction,
    myList)", null], "4": ["LIST", 14, 10, 12, 5], "5": ["LIST", 42, 30, 36, 15]},
    "line": 4, "event": "return"}, {"ordered_globals": ["add", "triple", "mapReduce"],
    "stdout": "", "func_name": "add", "stack_to_render": [{"frame_id": 1, "encoded_locals":
    {"reduceFunction": ["REF", 1], "newList": ["REF", 5], "myList": ["REF", 4], "mapFunction":
    ["REF", 2]}, "is_highlighted": false, "is_parent": false, "func_name": "mapReduce",
    "is_zombie": false, "parent_frame_id_list": [], "unique_hash": "mapReduce_f1",
    "ordered_varnames": ["mapFunction", "reduceFunction", "myList", "newList"]}, {"frame_id":
    7, "encoded_locals": {"y": 36, "x": 72}, "is_highlighted": true, "is_parent":
    false, "func_name": "add", "is_zombie": false, "parent_frame_id_list": [], "unique_hash":
    "add_f7", "ordered_varnames": ["x", "y"]}], "globals": {"add": ["REF", 1], "mapReduce":
    ["REF", 3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(x, y)", null],
    "2": ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction,
    reduceFunction, myList)", null], "4": ["LIST", 14, 10, 12, 5], "5": ["LIST", 42,
    30, 36, 15]}, "line": 1, "event": "call"}, {"ordered_globals": ["add", "triple",
    "mapReduce"], "stdout": "", "func_name": "add", "stack_to_render": [{"frame_id":
    1, "encoded_locals": {"reduceFunction": ["REF", 1], "newList": ["REF", 5], "myList":
    ["REF", 4], "mapFunction": ["REF", 2]}, "is_highlighted": false, "is_parent":
    false, "func_name": "mapReduce", "is_zombie": false, "parent_frame_id_list": [],
    "unique_hash": "mapReduce_f1", "ordered_varnames": ["mapFunction", "reduceFunction",
    "myList", "newList"]}, {"frame_id": 7, "encoded_locals": {"y": 36, "x": 72}, "is_highlighted":
    true, "is_parent": false, "func_name": "add", "is_zombie": false, "parent_frame_id_list":
    [], "unique_hash": "add_f7", "ordered_varnames": ["x", "y"]}], "globals": {"add":
    ["REF", 1], "mapReduce": ["REF", 3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION",
    "add(x, y)", null], "2": ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction,
    reduceFunction, myList)", null], "4": ["LIST", 14, 10, 12, 5], "5": ["LIST", 42,
    30, 36, 15]}, "line": 4, "event": "step_line"}, {"ordered_globals": ["add", "triple",
    "mapReduce"], "stdout": "", "func_name": "add", "stack_to_render": [{"frame_id":
    1, "encoded_locals": {"reduceFunction": ["REF", 1], "newList": ["REF", 5], "myList":
    ["REF", 4], "mapFunction": ["REF", 2]}, "is_highlighted": false, "is_parent":
    false, "func_name": "mapReduce", "is_zombie": false, "parent_frame_id_list": [],
    "unique_hash": "mapReduce_f1", "ordered_varnames": ["mapFunction", "reduceFunction",
    "myList", "newList"]}, {"frame_id": 7, "encoded_locals": {"y": 36, "x": 72, "__return__":
    108}, "is_highlighted": true, "is_parent": false, "func_name": "add", "is_zombie":
    false, "parent_frame_id_list": [], "unique_hash": "add_f7", "ordered_varnames":
    ["x", "y", "__return__"]}], "globals": {"add": ["REF", 1], "mapReduce": ["REF",
    3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(x, y)", null], "2":
    ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction, reduceFunction,
    myList)", null], "4": ["LIST", 14, 10, 12, 5], "5": ["LIST", 42, 30, 36, 15]},
    "line": 4, "event": "return"}, {"ordered_globals": ["add", "triple", "mapReduce"],
    "stdout": "", "func_name": "add", "stack_to_render": [{"frame_id": 1, "encoded_locals":
    {"reduceFunction": ["REF", 1], "newList": ["REF", 5], "myList": ["REF", 4], "mapFunction":
    ["REF", 2]}, "is_highlighted": false, "is_parent": false, "func_name": "mapReduce",
    "is_zombie": false, "parent_frame_id_list": [], "unique_hash": "mapReduce_f1",
    "ordered_varnames": ["mapFunction", "reduceFunction", "myList", "newList"]}, {"frame_id":
    8, "encoded_locals": {"y": 15, "x": 108}, "is_highlighted": true, "is_parent":
    false, "func_name": "add", "is_zombie": false, "parent_frame_id_list": [], "unique_hash":
    "add_f8", "ordered_varnames": ["x", "y"]}], "globals": {"add": ["REF", 1], "mapReduce":
    ["REF", 3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(x, y)", null],
    "2": ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction,
    reduceFunction, myList)", null], "4": ["LIST", 14, 10, 12, 5], "5": ["LIST", 42,
    30, 36, 15]}, "line": 1, "event": "call"}, {"ordered_globals": ["add", "triple",
    "mapReduce"], "stdout": "", "func_name": "add", "stack_to_render": [{"frame_id":
    1, "encoded_locals": {"reduceFunction": ["REF", 1], "newList": ["REF", 5], "myList":
    ["REF", 4], "mapFunction": ["REF", 2]}, "is_highlighted": false, "is_parent":
    false, "func_name": "mapReduce", "is_zombie": false, "parent_frame_id_list": [],
    "unique_hash": "mapReduce_f1", "ordered_varnames": ["mapFunction", "reduceFunction",
    "myList", "newList"]}, {"frame_id": 8, "encoded_locals": {"y": 15, "x": 108},
    "is_highlighted": true, "is_parent": false, "func_name": "add", "is_zombie": false,
    "parent_frame_id_list": [], "unique_hash": "add_f8", "ordered_varnames": ["x",
    "y"]}], "globals": {"add": ["REF", 1], "mapReduce": ["REF", 3], "triple": ["REF",
    2]}, "heap": {"1": ["FUNCTION", "add(x, y)", null], "2": ["FUNCTION", "triple(x)",
    null], "3": ["FUNCTION", "mapReduce(mapFunction, reduceFunction, myList)", null],
    "4": ["LIST", 14, 10, 12, 5], "5": ["LIST", 42, 30, 36, 15]}, "line": 4, "event":
    "step_line"}, {"ordered_globals": ["add", "triple", "mapReduce"], "stdout": "",
    "func_name": "add", "stack_to_render": [{"frame_id": 1, "encoded_locals": {"reduceFunction":
    ["REF", 1], "newList": ["REF", 5], "myList": ["REF", 4], "mapFunction": ["REF",
    2]}, "is_highlighted": false, "is_parent": false, "func_name": "mapReduce", "is_zombie":
    false, "parent_frame_id_list": [], "unique_hash": "mapReduce_f1", "ordered_varnames":
    ["mapFunction", "reduceFunction", "myList", "newList"]}, {"frame_id": 8, "encoded_locals":
    {"y": 15, "x": 108, "__return__": 123}, "is_highlighted": true, "is_parent": false,
    "func_name": "add", "is_zombie": false, "parent_frame_id_list": [], "unique_hash":
    "add_f8", "ordered_varnames": ["x", "y", "__return__"]}], "globals": {"add": ["REF",
    1], "mapReduce": ["REF", 3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION",
    "add(x, y)", null], "2": ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction,
    reduceFunction, myList)", null], "4": ["LIST", 14, 10, 12, 5], "5": ["LIST", 42,
    30, 36, 15]}, "line": 4, "event": "return"}, {"ordered_globals": ["add", "triple",
    "mapReduce"], "stdout": "", "func_name": "mapReduce", "stack_to_render": [{"frame_id":
    1, "encoded_locals": {"reduceFunction": ["REF", 1], "newList": ["REF", 5], "myList":
    ["REF", 4], "mapFunction": ["REF", 2], "value": 123}, "is_highlighted": true,
    "is_parent": false, "func_name": "mapReduce", "is_zombie": false, "parent_frame_id_list":
    [], "unique_hash": "mapReduce_f1", "ordered_varnames": ["mapFunction", "reduceFunction",
    "myList", "newList", "value"]}], "globals": {"add": ["REF", 1], "mapReduce": ["REF",
    3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(x, y)", null], "2":
    ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction, reduceFunction,
    myList)", null], "4": ["LIST", 14, 10, 12, 5], "5": ["LIST", 42, 30, 36, 15]},
    "line": 20, "event": "step_line"}, {"ordered_globals": ["add", "triple", "mapReduce"],
    "stdout": "", "func_name": "mapReduce", "stack_to_render": [{"frame_id": 1, "encoded_locals":
    {"myList": ["REF", 4], "mapFunction": ["REF", 2], "newList": ["REF", 5], "value":
    123, "__return__": 123, "reduceFunction": ["REF", 1]}, "is_highlighted": true,
    "is_parent": false, "func_name": "mapReduce", "is_zombie": false, "parent_frame_id_list":
    [], "unique_hash": "mapReduce_f1", "ordered_varnames": ["mapFunction", "reduceFunction",
    "myList", "newList", "value", "__return__"]}], "globals": {"add": ["REF", 1],
    "mapReduce": ["REF", 3], "triple": ["REF", 2]}, "heap": {"1": ["FUNCTION", "add(x,
    y)", null], "2": ["FUNCTION", "triple(x)", null], "3": ["FUNCTION", "mapReduce(mapFunction,
    reduceFunction, myList)", null], "4": ["LIST", 14, 10, 12, 5], "5": ["LIST", 42,
    30, 36, 15]}, "line": 20, "event": "return"}, {"ordered_globals": ["add", "triple",
    "mapReduce"], "stdout": "123\n", "func_name": "<module>", "stack_to_render": [],
    "globals": {"add": ["REF", 1], "mapReduce": ["REF", 3], "triple": ["REF", 2]},
    "heap": {"1": ["FUNCTION", "add(x, y)", null], "2": ["FUNCTION", "triple(x)",
    null], "3": ["FUNCTION", "mapReduce(mapFunction, reduceFunction, myList)", null]},
    "line": 22, "event": "return"}]}; var ch03_mapreduce_vis; $(document).ready(function()
    { ch03_mapreduce_vis = new ExecutionVisualizer(''ch03_mapreduce'',ch03_mapreduce_trace,
    {embeddedMode: true, verticalStack: true, heightChangeCallback: redrawAllVisualizerArrows,
    codeDivWidth: 500 }); attachLoggers(ch03_mapreduce_vis,''ch03_mapreduce''); allVisualizers.push(ch03_mapreduce_vis);
    }); $(document).ready(function() { $("#ch03_mapreduce_tracecheck").click(function()
    { logBookEvent({''event'':''codelens'', ''act'': ''check'', ''div_id'':''ch03_mapreduce''});
    }); }); if (allVisualizers === undefined) { var allVisualizers = []; } $(window).resize(function()
    { ch03_mapreduce_vis.redrawConnectors(); }); </script> <p>Alternatively, this
    can be done more succinctly in one line as follows:</p> <div class="highlight-python"><div
    class="highlight"><pre><span class="k">def</span> <span class="nf">mapReduce</span><span
    class="p">(</span><span class="n">mapFunction</span><span class="p">,</span> <span
    class="n">reduceFunction</span><span class="p">,</span> <span class="n">myList</span><span
    class="p">):</span> <span class="sd">''''''Applies mapFunction to myList to construct
    a new list</span> <span class="sd"> and then applies reduceFunction to the new
    list</span> <span class="sd"> and returns that value.''''''</span> <span class="k">return</span>
    <span class="nb">reduce</span><span class="p">(</span><span class="n">reduceFunction</span><span
    class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">mapFunction</span><span
    class="p">,</span> <span class="n">myList</span><span class="p">))</span> </pre>
    </div> </div> <p>Now, for example, we can use <tt class="docutils literal"><span
    class="pre">mapReduce</span></tt> to convert prices from U.S. dollars to alien
    dollars and add up the total, like this:</p> <div class="highlight-python"><div
    class="highlight"><pre><span class="gp">>>> </span><span class="n">mapReduce</span><span
    class="p">(</span><span class="n">triple</span><span class="p">,</span> <span
    class="n">add</span><span class="p">,</span> <span class="p">[</span><span class="mi">14</span><span
    class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span
    class="p">,</span> <span class="mi">5</span><span class="p">])</span> <span class="go">123</span>
    </pre> </div> </div> <p>The second version of <tt class="docutils literal"><span
    class="pre">mapReduce</span></tt> above is particularly elegant in the way that
    <tt class="docutils literal"><span class="pre">map</span></tt> and <tt class="docutils
    literal"><span class="pre">reduce</span></tt> are composed or “glued” in one line.
    Notice that in order for Python to evaluate the expression <tt class="docutils
    literal"><span class="pre">reduce(reduceFunction,</span> <span class="pre">map(mapFunction,</span>
    <span class="pre">myList))</span></tt> it must first evaluate <tt class="docutils
    literal"><span class="pre">map(mapFunction,</span> <span class="pre">myList)</span></tt>,
    since that is one of the arguments to <tt class="docutils literal"><span class="pre">reduce</span></tt>.
    So, the <tt class="docutils literal"><span class="pre">map</span></tt> function
    is applied to <tt class="docutils literal"><span class="pre">mapFunction</span></tt>
    and list <tt class="docutils literal"><span class="pre">myList</span></tt> to
    get the resulting list. Now, <tt class="docutils literal"><span class="pre">reduce</span></tt>
    has both the function and the list that it needs to do its thing.</p> <p>The <tt
    class="docutils literal"><span class="pre">mapReduce</span></tt> function is so
    broadly useful that it inspired a major part of Google’s internal software design!
    To read more about it, you can (of course) just Google “mapReduce.”</p> <div class="admonition
    note" id="index-9"> <p class="first admonition-title">Note</p> <p><strong>Functional
    Programming Meets Psychotherapy</strong></p> <p>The ideas behind functional programming
    actually predate the computer. A mathematical framework called the <em>lambda
    calculus</em> was developed by the logician Alonzo Church in the 1930’s to examine
    the limits of what is theoretically computable. (We address some of these issues
    in Chapter 7.) The lambda calculus served as the basis of actual programming languages,
    such as the early language LISP developed at MIT in the 1950’s. The “lambda” in
    lambda calculus is the reason for its appearance in Python’s anonymous functions.</p>
    <p>LISP and related functional programming languages have been of particular interest
    to researchers in Artificial Intelligence (AI) because they are well suited for
    analyzing text. We can take a human’s typed input and write functions that process
    the words as strings and sentences as lists of strings. This is called <em>natural
    language processing</em>. (The “natural” here refers to human languages in contrast
    to programming languages.)</p> <p>One of the early and controversial examples
    of natural language processing and artificial intelligence was the ELIZA program,
    first written by Professor Joseph Weizenbaum at MIT in the mid-1960’s. Eliza impersonated
    a psychologist and allowed the human user to enter text that ELIZA would process
    and return a simple response that—while not actually aware of the user’s emotions—seemed
    generally appropriate. Eliza was first written by Weizenbaum in a language called
    SLIP, but was later reprogrammed in LISP.</p> <p>Here’s the beginning of an actual
    transcript of an interaction with ELIZA from an online version of the program
    (available <a class="reference external" href="http://www-ai.ijs.si/eliza/eliza.html">here</a>).</p>
    <p><tt class="docutils literal"><span class="pre">Eliza:</span> <span class="pre">Hello.</span>
    <span class="pre">I</span> <span class="pre">am</span> <span class="pre">ELIZA.</span>
    <span class="pre">How</span> <span class="pre">can</span> <span class="pre">I</span>
    <span class="pre">help</span> <span class="pre">you?</span></tt></p> <p><tt class="docutils
    literal"><span class="pre">You:</span>  <span class="pre">I</span> <span class="pre">am</span>
    <span class="pre">learning</span> <span class="pre">about</span> <span class="pre">functional</span>
    <span class="pre">programming.</span></tt></p> <p><tt class="docutils literal"><span
    class="pre">Eliza:</span>  <span class="pre">How</span> <span class="pre">long</span>
    <span class="pre">have</span> <span class="pre">you</span> <span class="pre">been</span>
    <span class="pre">learning</span> <span class="pre">about</span> <span class="pre">functional</span>
    <span class="pre">programming?</span></tt></p> <p><tt class="docutils literal"><span
    class="pre">You:</span>  <span class="pre">I</span> <span class="pre">guess</span>
    <span class="pre">it</span> <span class="pre">has</span> <span class="pre">been</span>
    <span class="pre">a</span> <span class="pre">few</span> <span class="pre">weeks</span>
    <span class="pre">now.</span></tt></p> <p><tt class="docutils literal"><span class="pre">Eliza:</span>
    <span class="pre">Can</span> <span class="pre">you</span> <span class="pre">elaborate</span>
    <span class="pre">on</span> <span class="pre">that?</span></tt></p> <p class="last">Responses
    such as “Can you elaborate on that?” or even “Tell me about your mother” are commonly
    used and quickly reveal that ELIZA is actually rather clueless. While Weizenbaum
    evidently only intended ELIZA to serve as a demonstration of the power of natural
    language processing, some people actually took an interest in using ELIZA as their
    therapist! A book and a documentary have been made about Weizenbaum and ELIZA,
    and a number of free and commercial versions of the program are available, including
    some that have a very bad attitude and deliberately berate their “patient.”</p>
    </div> </div> </div> <div class="section" id="functions-as-results"> <h2 id="sigil_toc_id_44">3.7:
    Functions as Results</h2> <p>If functions can be the arguments to other functions,
    it must also be possible for them to be the results of functions, right? Take
    a look at this <tt class="docutils literal"><span class="pre">scale</span></tt>
    function and try to figure out what it does:</p> <br/><br/><a href="ch03_scale.html">ch03_scale.html</a><br/><br/>
    <p>The <tt class="docutils literal"><span class="pre">scale</span></tt> function
    takes the number 42 as an argument and returns a function (the <tt class="docutils
    literal"><span class="pre">lambda</span></tt> indicates that we’re giving back
    a function) that we are then assigning to the variable <tt class="docutils literal"><span
    class="pre">f</span></tt>. So <tt class="docutils literal"><span class="pre">f</span></tt>
    is a function, but what does that function do? Well, for any argument <tt class="docutils
    literal"><span class="pre">x</span></tt> it returns <tt class="docutils literal"><span
    class="pre">42</span> <span class="pre">*</span> <span class="pre">x</span></tt>—as
    we see here:</p> <div class="highlight-python"><div class="highlight"><pre><span
    class="gp">>>> </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span
    class="p">)</span> <span class="go">84</span> <span class="gp">>>> </span><span
    class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="go">420</span> </pre> </div> </div> <p>There’s something odd here!
    In the definition of the <tt class="docutils literal"><span class="pre">scale</span></tt>
    function, the line:</p> <p><tt class="docutils literal"><span class="pre">return</span>
    <span class="pre">lambda</span> <span class="pre">x:</span> <span class="pre">n</span>
    <span class="pre">*</span> <span class="pre">x</span></tt></p> <p>makes it look
    like the function that we’re returning has <em>two variables</em>, <tt class="docutils
    literal"><span class="pre">n</span></tt> and <tt class="docutils literal"><span
    class="pre">x</span></tt>, whereas the <tt class="docutils literal"><span class="pre">lambda</span>
    <span class="pre">x</span></tt> indicates that this a function of just <em>one</em>
    variable, <tt class="docutils literal"><span class="pre">x</span></tt>. Indeed,
    in the examples above, we defined <tt class="docutils literal"><span class="pre">f</span>
    <span class="pre">=</span> <span class="pre">scale(42)</span></tt> and then we
    gave <tt class="docutils literal"><span class="pre">f</span></tt> just <em>one</em>
    argument as in <tt class="docutils literal"><span class="pre">f(2)</span></tt>
    and <tt class="docutils literal"><span class="pre">f(10)</span></tt>.</p> <p>When
    we said <tt class="docutils literal"><span class="pre">f</span> <span class="pre">=</span>
    <span class="pre">scale(42)</span></tt>, the 42 was passed into <tt class="docutils
    literal"><span class="pre">scale</span></tt>‘s argument <tt class="docutils literal"><span
    class="pre">n</span></tt>, and <tt class="docutils literal"><span class="pre">n</span></tt>
    was replaced with 42\. Therefore, <tt class="docutils literal"><span class="pre">scale(42)</span></tt>
    actually returned</p> <div class="figure align-right" style="width: 150px"> <img
    alt="../Images/Alien4.PNG" src="../Images/Alien4.PNG"/> <p class="caption"><em>Maybe
    I can write a program that will write all my future CS programming assignments
    for me!</em></p> </div> <p><tt class="docutils literal"><span class="pre">lambda</span>
    <span class="pre">x:</span> <span class="pre">42</span> <span class="pre">*</span>
    <span class="pre">x</span></tt></p> <p>That’s clearly a function of just <em>one</em>
    variable and that is the function that we then assigned to our variable <tt class="docutils
    literal"><span class="pre">f</span></tt>.</p> <p>Although the <tt class="docutils
    literal"><span class="pre">scale</span></tt> function is admittedly not super-useful,
    the amazing thing here is that we wrote a program that can write other programs—a
    powerful concept that is widely used by computer scientists. Indeed, many complex
    programs are, at least in part, written by other programs.</p> <p>By the way,
    rather than using an anonymous function inside our <tt class="docutils literal"><span
    class="pre">scale</span></tt> function, we could have given the function a name
    and returned that function. We do this as follows:</p> <div class="highlight-python"><div
    class="highlight"><pre><span class="k">def</span> <span class="nf">scale</span><span
    class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="k">def</span>
    <span class="nf">multiply</span><span class="p">(</span><span class="n">x</span><span
    class="p">):</span> <span class="c"># Here we are defining a new function,</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span>
    <span class="n">x</span> <span class="c"># but it''s INSIDE scale!</span> <span
    class="k">return</span> <span class="n">multiply</span> <span class="c"># Here
    we are returning that function</span> </pre> </div> </div> <p>Notice that the
    indented <tt class="docutils literal"><span class="pre">def</span> <span class="pre">multiply(x)</span></tt>
    indicates that <tt class="docutils literal"><span class="pre">multiply</span></tt>
    is being defined inside <tt class="docutils literal"><span class="pre">scale</span></tt>,
    so this is defining <tt class="docutils literal"><span class="pre">multiply</span></tt>
    to be one of <tt class="docutils literal"><span class="pre">scale</span></tt>‘s
    own variables, just like defining any variable within a function. The only difference
    is that <tt class="docutils literal"><span class="pre">multiply</span></tt> is
    a <em>function</em> rather than a number, list, or string. Then, once we’ve defined
    that variable, we return it. Now, calling <tt class="docutils literal"><span class="pre">scale(42)</span></tt>,
    for example, gives us back a function and we can do exactly what we did a moment
    ago with the first version of <tt class="docutils literal"><span class="pre">scale</span></tt>:</p>
    <div class="highlight-python"><div class="highlight"><pre><span class="gp">>>>
    </span><span class="n">f</span> <span class="o">=</span> <span class="n">scale</span><span
    class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="gp">>>>
    </span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span
    class="p">)</span> <span class="go">84</span> <span class="gp">>>> </span><span
    class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="go">420</span> </pre> </div> </div> <p>Functions that take other
    functions as arguments or return a function as a result are called <em class="dfn">higher-order
    functions</em>.</p> <div class="section" id="python-does-calculus"> <h3 id="sigil_toc_id_45">3.7.1:
    Python Does Calculus!</h3> <div class="figure align-right" style="width: 150px">
    <img alt="../Images/Alien4.PNG" src="../Images/Alien4.PNG"/> <p class="caption"><em>I’d
    rather impersonate them and alienate them!</em></p> </div> <p>In addition to learning
    English and other languages, our alien has been advised to study calculus before
    returning to Earth, so that it can better impersonate a college student.</p> <p>You
    probably recall the idea of taking the derivative of a function. For example,
    the derivative of <span class="math">\(f(x) = x^2\)</span> is a new function <span
    class="math">\(f''(x) = 2x\)</span>. For our purposes, the key observation is
    that the derivative of a function is another function. You may also recall that
    there are many rules for computing derivatives, and yet some functions are very
    hard to differentiate and others are downright impossible. So in some cases we
    may want to approximate the derivative—and we can do this computationally! In
    fact, let’s write a Python function that differentiates <em>any</em> function
    (approximately).</p> <p>We looked back at our own calculus notes and found that
    the derivative of a function <span class="math">\(f(x)\)</span> is a function
    <span class="math">\(f''(x)\)</span> defined as follows:</p> <p class="centered">
    <strong><span class="math">\(\displaystyle{f''(x) = \lim_{h \rightarrow 0} \frac{f(x+h)
    - f(x)}{h}}\)</span></strong></p> <p>The derivative is defined as “the limit as
    <span class="math">\(h\)</span> goes to zero.” However, for small positive values
    of <span class="math">\(h\)</span>, like <span class="math">\(h = 0.0001\)</span>,
    we get a good approximation of the limit. We can make the approximation as good
    as we want by making <span class="math">\(h\)</span> as small as we want. Our
    objective, then, is to write a function called <tt class="docutils literal"><span
    class="pre">derivative</span></tt> that takes a function and a value of <span
    class="math">\(h\)</span> as an argument, and returns another function that is
    the approximation of the derivative for that value of <span class="math">\(h\)</span>.
    Here we go:</p> <div class="highlight-python"><div class="highlight"><pre><span
    class="k">def</span> <span class="nf">derivative</span><span class="p">(</span><span
    class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="sd">''''''Returns a new function that is the approximation of</span>
    <span class="sd"> the derivative of f with respect to h.''''''</span> <span class="k">return</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>
    <span class="p">(</span><span class="n">f</span><span class="p">(</span><span
    class="n">x</span><span class="o">+</span><span class="n">h</span><span class="p">)</span>
    <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span
    class="n">x</span><span class="p">))</span> <span class="o">/</span> <span class="n">h</span>
    </pre> </div> </div> <p>Notice that we’re returning a function, as we’re supposed
    to. That function takes an argument <tt class="docutils literal"><span class="pre">x</span></tt>
    and returns the approximate value of the derivative at that value <tt class="docutils
    literal"><span class="pre">x</span></tt> for the given <tt class="docutils literal"><span
    class="pre">h</span></tt>.</p> <p>Wait a second! It seems that the function that
    we’re returning is using a function <tt class="docutils literal"><span class="pre">f</span></tt>
    and two numeric variables, <tt class="docutils literal"><span class="pre">x</span></tt>
    and <tt class="docutils literal"><span class="pre">h</span></tt>—so why do we
    see just the variable <tt class="docutils literal"><span class="pre">x</span></tt>
    after the <tt class="docutils literal"><span class="pre">lambda</span></tt>? This
    is the same issue that we saw earlier with the <tt class="docutils literal"><span
    class="pre">scale</span></tt> function. Remember that when we call the <tt class="docutils
    literal"><span class="pre">derivative</span></tt> function, we pass it both a
    function <tt class="docutils literal"><span class="pre">f</span></tt> and a number
    <tt class="docutils literal"><span class="pre">h</span></tt>. Then, that function
    and that number are “plugged in” wherever we see a <tt class="docutils literal"><span
    class="pre">f</span></tt> and a <tt class="docutils literal"><span class="pre">h</span></tt>
    in the program. In the expression <tt class="docutils literal"><span class="pre">lambda</span>
    <span class="pre">x:</span> <span class="pre">(f(x+h)</span> <span class="pre">-</span>
    <span class="pre">f(x))</span> <span class="pre">/</span> <span class="pre">h</span></tt>,
    both the <tt class="docutils literal"><span class="pre">f</span></tt> and the
    <tt class="docutils literal"><span class="pre">h</span></tt> are no longer variables—they
    are actual values (albeit the <tt class="docutils literal"><span class="pre">f</span></tt>
    is a value that happens to be a function). So, the <tt class="docutils literal"><span
    class="pre">lambda</span></tt> anonymous function truly only has one argument,
    and that’s <tt class="docutils literal"><span class="pre">x</span></tt>.</p> <p>Let’s
    try it out. First, let’s define a function <span class="math">\(x^2\)</span> and
    name it <tt class="docutils literal"><span class="pre">square</span></tt>.</p>
    <div class="highlight-python"><div class="highlight"><pre><span class="k">def</span>
    <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span
    class="p">):</span> <span class="k">return</span> <span class="n">x</span><span
    class="o">**</span><span class="mi">2</span> </pre> </div> </div> <p>Now, let’s
    use our <tt class="docutils literal"><span class="pre">derivative</span></tt>
    function:</p> <div class="highlight-python"><div class="highlight"><pre><span
    class="gp">>>> </span><span class="n">g</span> <span class="o">=</span> <span
    class="n">derivative</span><span class="p">(</span><span class="n">square</span><span
    class="p">,</span> <span class="mf">0.0001</span><span class="p">)</span> <span
    class="gp">>>> </span><span class="n">g</span><span class="p">(</span><span class="mi">10</span><span
    class="p">)</span> <span class="go">20.000099999890608</span> </pre> </div> </div>
    <div class="figure align-right" style="width: 150px"> <img alt="../Images/Alien4.PNG"
    src="../Images/Alien4.PNG"/> <p class="caption"><em>The second derivative is “accelerated”
    material!</em></p> </div> <p>The actual derivative of <span class="math">\(x^2\)</span>
    is <span class="math">\(2x\)</span>, so the derivative at <span class="math">\(x=10\)</span>
    is actually <span class="math">\(20\)</span>. We’re getting a pretty good approximation.
    That’s good, but here’s something better: if we now want to find the second derivative
    of <span class="math">\(x^2\)</span>, we can differentiate our first derivative.
    The actual second second derivative of <span class="math">\(x^2\)</span> is simply
    <span class="math">\(2\)</span> (for all values of <span class="math">\(x\)</span>).
    Let’s see what our <tt class="docutils literal"><span class="pre">derivative</span></tt>
    function says.</p> <div class="highlight-python"><div class="highlight"><pre><span
    class="gp">>>> </span><span class="n">h</span> <span class="o">=</span> <span
    class="n">derivative</span><span class="p">(</span><span class="n">g</span><span
    class="p">,</span> <span class="mf">0.0001</span><span class="p">)</span> <span
    class="gp">>>> </span><span class="n">h</span><span class="p">(</span><span class="mi">10</span><span
    class="p">)</span> <span class="go">2.0000015865662135</span> </pre> </div> </div>
    </div> <div class="section" id="higher-derivatives"> <h3 id="sigil_toc_id_46">3.7.2:
    Higher Derivatives</h3> <p>Speaking of second derivatives, it sure would be handy
    to have a more general function that could find us the first, second, third, or
    generally, the <span class="math">\(k^{th}\)</span> derivative of a function.
    Let’s write a function called <tt class="docutils literal"><span class="pre">kthDerivative(f,</span>
    <span class="pre">h,</span> <span class="pre">k)</span></tt> to do this. It will
    take arguments that include a function <tt class="docutils literal"><span class="pre">f</span></tt>,
    a small number <tt class="docutils literal"><span class="pre">h</span></tt>, and
    a positive integer <tt class="docutils literal"><span class="pre">k</span></tt>
    and will return an approximation of the <span class="math">\(k^{th}\)</span> derivative
    of <span class="math">\(f\)</span>. We could do this “from scratch”, not relying
    on the existing <tt class="docutils literal"><span class="pre">derivative</span></tt>
    function that we just wrote, but since we have it already let’s use <tt class="docutils
    literal"><span class="pre">derivative</span></tt>.</p> <p>What’s the base case?
    The simplest case appears to be when <span class="math">\(k=1\)</span>, in which
    case we just return the derivative of the given function. (Although it would be
    equally defensible to have a base case at <span class="math">\(k=0\)</span>, in
    which case we would just return <span class="math">\(f\)</span> itself.) Otherwise,
    <span class="math">\(k > 1\)</span> and we need to find the recursive substructure.
    Well, the <span class="math">\(k^{th}\)</span> derivative of <span class="math">\(f\)</span>
    is, by definition, just the derivative of the <span class="math">\((k-1)^{st}\)</span>
    derivative of <span class="math">\(f\)</span>. So we can ask the <tt class="docutils
    literal"><span class="pre">kthDerivative</span></tt> function to find the <span
    class="math">\((k-1)^{st}\)</span> derivative of <tt class="docutils literal"><span
    class="pre">f</span></tt> and then apply our <tt class="docutils literal"><span
    class="pre">derivative</span></tt> function to it. This should be fun and easy.</p>
    <div class="figure align-right" style="width: 150px"> <img alt="../Images/Alien4.PNG"
    src="../Images/Alien4.PNG"/> <p class="caption"><em>A function of degree 4 is
    “quartic”, one of degree 9 is “nonic”. Believe it or not, one of degree 100 is
    called “hectic.”</em></p> </div> <div class="highlight-python"><div class="highlight"><pre><span
    class="k">def</span> <span class="nf">kthDerivative</span><span class="p">(</span><span
    class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span>
    <span class="n">k</span><span class="p">):</span> <span class="sd">''''''Returns
    a new function that is the approximation of</span> <span class="sd"> the kth derivative
    of f with respect to h.''''''</span> <span class="k">if</span> <span class="n">k</span>
    <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span
    class="k">return</span> <span class="n">derivative</span><span class="p">(</span><span
    class="n">f</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span>
    <span class="n">derivative</span><span class="p">(</span><span class="n">kthDerivative</span><span
    class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">h</span><span
    class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span
    class="p">),</span> <span class="n">h</span><span class="p">)</span> </pre> </div>
    </div> <p>Let’s take this out for a spin by defining the “quartic” function <span
    class="math">\(x^4\)</span> and then taking the third derivative, which we know
    to be <span class="math">\(24x\)</span>.</p> <div class="highlight-python"><div
    class="highlight"><pre><span class="k">def</span> <span class="nf">quartic</span><span
    class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="sd">''''''Returns
    x**4.''''''</span> <span class="k">return</span> <span class="n">x</span><span
    class="o">**</span><span class="mi">4</span> </pre> </div> </div> <div class="figure
    align-right" style="width: 150px"> <img alt="../Images/Alien4.PNG" src="../Images/Alien4.PNG"/>
    <p class="caption"><em>Please! Let’s not go any further down the slippery</em>
    slope <em>of bad math puns.</em></p> </div> <div class="highlight-python"><div
    class="highlight"><pre><span class="gp">>>> </span><span class="n">g</span> <span
    class="o">=</span> <span class="n">kthDerivative</span><span class="p">(</span><span
    class="n">quartic</span><span class="p">,</span> <span class="mf">0.0001</span><span
    class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="gp">>>>
    </span><span class="n">g</span><span class="p">(</span><span class="mi">10</span><span
    class="p">)</span> <span class="go">241.9255906715989</span> </pre> </div> </div>
    <p>The actual answer should have been 240; we got an approximation due to the
    value we used for <span class="math">\(h\)</span>.</p> <p>That was a high-velocity
    discussion of derivatives, but it demonstrated some of the integral features of
    functional programming.</p> </div> </div> <div class="section" id="rsa-cryptography-revisited">
    <h2 id="sigil_toc_id_47">3.8: RSA Cryptography Revisited</h2> <p>We began this
    chapter with a discussion of RSA cryptography. Recall that if Alice wants to be
    able to receive secure messages, then she can use the RSA algorithm to generate
    a public and a private key. The public key is entirely public—anyone can use it
    to encrypt a message to Alice. The private key, however, belongs exclusively to
    her; she uses it to decrypt messages encrypted using her public key. Of course,
    if Alice’s friend, Bob, wants to receive encrypted messages too, he can use RSA
    to generate his own public and private keys. He then shares his public key and
    keeps his private key secure. When you want to send an encrypted message to Alice,
    you use her public key to encrypt the message. When you want to send a message
    to Bob, you use his public key.</p> <p>Our objective is to write a function called
    <tt class="docutils literal"><span class="pre">makeEncoderDecoder()</span></tt>,
    which takes no arguments, constructs the RSA encryption and decryption keys, and
    returns <em>two</em> functions: The first encrypts data using the encryption key
    (which is built into the function, so we don’t need to keep track of it—convenient
    when a key is hundreds of digits long!) The second function decrypts encrypted
    data using the decryption key (again built-in). Alice, Bob, you, and your friends
    will all be able to use the <tt class="docutils literal"><span class="pre">makeEncoderDecoder()</span></tt>
    function to construct encryption and decryption functions; each encryption function
    will be made public and each decryption function will be kept by its owner. Here’s
    an example of Alice using <tt class="docutils literal"><span class="pre">makeEncoderDecoder</span></tt>.</p>
    <div class="highlight-python"><div class="highlight"><pre><span class="gp">>>>
    </span><span class="n">AliceEncrypt</span><span class="p">,</span> <span class="n">AliceDecrypt</span>
    <span class="o">=</span> <span class="n">makeEncoderDecoder</span><span class="p">()</span>
    <span class="go">Maximum number that can be encrypted is 34</span> <span class="gp">>>>
    </span><span class="n">AliceEncrypt</span><span class="p">(</span><span class="mi">5</span><span
    class="p">)</span> <span class="go">10</span> <span class="gp">>>> </span><span
    class="n">AliceDecrypt</span><span class="p">(</span><span class="mi">10</span><span
    class="p">)</span> <span class="go">5</span> <span class="gp">>>> </span><span
    class="n">AliceEncrypt</span><span class="p">(</span><span class="mi">31</span><span
    class="p">)</span> <span class="go">26</span> <span class="gp">>>> </span><span
    class="n">AliceDecrypt</span><span class="p">(</span><span class="mi">26</span><span
    class="p">)</span> <span class="go">31</span> </pre> </div> </div> <p>Notice here
    that <tt class="docutils literal"><span class="pre">makeEncoderDecoder</span></tt>
    returned two functions (we’ll see in a moment how we can return two things), which
    we’ve named <tt class="docutils literal"><span class="pre">AliceEncrypt</span></tt>
    and <tt class="docutils literal"><span class="pre">AliceDecrypt</span></tt>. Then,
    we tested those two functions by encrypting them using Alice’s encryption function
    (which contains the encryption key inside of it) and then decrypting them with
    Alice’s decryption function (which incorporates the decryption key).</p> <p>Let’s
    first remind ourselves how the RSA scheme works. We begin by choosing two different
    random prime numbers <span class="math">\(p\)</span> and <span class="math">\(q\)</span>
    (preferably large, but we’ll be able to decide how large later). We compute <span
    class="math">\(n = pq\)</span> and <span class="math">\(m = (p-1)(q-1)\)</span>.
    We then choose the public encryption key <span class="math">\(e\)</span> to be
    a random prime number between 2 and <span class="math">\(m-1\)</span> such that
    <span class="math">\(e\)</span> does not divide <span class="math">\(m\)</span>.
    Next, we construct the decryption key <span class="math">\(d\)</span> to be the
    multiplicative inverse of <span class="math">\(e\)</span> modulo <span class="math">\(m\)</span>—that
    is, the unique number <span class="math">\(d\)</span> such that <span class="math">\(d
    \leq m-1\)</span> and <span class="math">\(ed \mod m == 1\)</span>. Now, we can
    encrypt a number <span class="math">\(x\)</span> between 1 and <span class="math">\(n-1\)</span>
    by computing <span class="math">\(y = x^e \mod n\)</span>. The value <span class="math">\(y\)</span>
    is the encrypted message. We can decrypt <span class="math">\(y\)</span> by computing
    <span class="math">\(y^d\mod n\)</span>.</p> <p>We’ve already written functions
    that produce lists of prime numbers. We’ll use our efficient <tt class="docutils
    literal"><span class="pre">primeSieve</span></tt> function for that purpose. Recall
    that this function takes a list of consecutive integers from 2 to some largest
    value and returns the list of all primes in that range. Our first task will be
    to call the <tt class="docutils literal"><span class="pre">primeSieve</span></tt>
    function and choose two different prime numbers from that list. For now, let’s
    restrict the range of the prime numbers to be between 2 and 10\. This will be
    useful for testing purposes, and later you can change the maximum value from 10
    to something much larger.</p> <p>To choose items at random, we can use Python’s
    <tt class="docutils literal"><span class="pre">random</span></tt> package. We
    tell Python that we want to use that package by including the line <tt class="docutils
    literal"><span class="pre">import</span> <span class="pre">random</span></tt>
    at the top of the file. Now, we have access to a variety of functions in that
    package. You can find out what’s in the package by looking at the <a class="reference
    external" href="http://docs.python.org/library/random.html">Python documentation
    Web site</a> or by typing <tt class="docutils literal"><span class="pre">import</span>
    <span class="pre">random</span></tt> at the Python prompt and then typing <tt
    class="docutils literal"><span class="pre">help(random)</span></tt>, which will
    describe all of the functions in that package.</p> <p>One of the most useful functions
    in the <tt class="docutils literal"><span class="pre">random</span></tt> package
    is <tt class="docutils literal"><span class="pre">random.choice</span></tt>. It
    takes a list as an argument and returns a randomly selected element of that list.
    Here’s an example of that function in action:</p> <div class="highlight-python"><div
    class="highlight"><pre><span class="gp">>>> </span><span class="kn">import</span>
    <span class="nn">random</span> <span class="gp">>>> </span><span class="n">random</span><span
    class="o">.</span><span class="n">choice</span><span class="p">([</span><span
    class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span
    class="p">])</span> <span class="go">3</span> <span class="gp">>>> </span><span
    class="n">random</span><span class="o">.</span><span class="n">choice</span><span
    class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span
    class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span
    class="p">])</span> <span class="go">2</span> </pre> </div> </div> <p>We need
    to choose two different prime numbers in the range from 2 to 10\. We could use
    <tt class="docutils literal"><span class="pre">random.choice</span></tt> twice,
    one to choose each of the two prime numbers, but there is a chance that we’ll
    get the same prime number twice, which doesn’t work for RSA. So, we can use another
    function in the <tt class="docutils literal"><span class="pre">random</span></tt>
    package, <tt class="docutils literal"><span class="pre">random.sample</span></tt>.
    It takes two arguments: a list and the number of items that we want to choose
    randomly—but uniquely—from that list. The function returns a list of the randomly
    selected items. Here’s an example of <tt class="docutils literal"><span class="pre">random.sample</span></tt>
    in action:</p> <div class="highlight-python"><div class="highlight"><pre><span
    class="gp">>>> </span><span class="kn">import</span> <span class="nn">random</span>
    <span class="gp">>>> </span><span class="n">random</span><span class="o">.</span><span
    class="n">sample</span><span class="p">([</span><span class="mi">1</span><span
    class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span
    class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span
    class="p">)</span> <span class="c"># Pick 2 items at random</span> <span class="go">[4,
    3]</span> <span class="gp">>>> </span><span class="n">random</span><span class="o">.</span><span
    class="n">sample</span><span class="p">(</span><span class="nb">range</span><span
    class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span
    class="p">),</span> <span class="mi">3</span><span class="p">)</span> <span class="c">#
    Pick 3 different items</span> <span class="go">[17, 42, 23]</span> </pre> </div>
    </div> <p>When a function returns a list of several items and we know how many
    items will be in that list, we can give names to those items like this:</p> <div
    class="highlight-python"><div class="highlight"><pre><span class="gp">>>> </span><span
    class="kn">import</span> <span class="nn">random</span> <span class="gp">>>> </span><span
    class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span>
    <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span
    class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span
    class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span
    class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="gp">>>>
    </span><span class="n">a</span> <span class="go">4</span> <span class="gp">>>>
    </span><span class="n">b</span> <span class="go">3</span> </pre> </div> </div>
    <p id="index-10">In this case, we knew that the <tt class="docutils literal"><span
    class="pre">random.sample</span></tt> function was going to return a list of two
    items (since we asked it to!) and we assigned the first of those items to the
    variable <span class="math">\(a\)</span> and the second to <span class="math">\(b\)</span>.
    This technique is called <em>multiple assignment</em>.</p> <p>Now let’s assume
    that we’ve already written a function called <tt class="docutils literal"><span
    class="pre">inverse(e,</span> <span class="pre">m)</span></tt> that returns the
    multiplicative inverse of <span class="math">\(e\)</span> modulo <span class="math">\(m\)</span>—that
    is, the unique number <span class="math">\(d < m\)</span> such that <span class="math">\(ed
    \mod m = 1\)</span>. We’ll write that function in a moment, but assuming it exists,
    we have the ingredients for the <tt class="docutils literal"><span class="pre">makeEncoderDecoder</span></tt>
    function:</p> <div class="highlight-python"><div class="highlight"><pre><span
    class="k">def</span> <span class="nf">makeEncoderDecoder</span><span class="p">():</span>
    <span class="sd">''''''Returns two functions: An RSA encryption function</span>
    <span class="sd"> and an RSA decryption function.''''''</span> <span class="c">#</span>
    <span class="c"># Choose 2 primes:</span> <span class="c">#</span> <span class="n">p</span><span
    class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">random</span><span
    class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">primeSieve</span><span
    class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span
    class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span
    class="p">))),</span> <span class="mi">2</span><span class="p">)</span> <span
    class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span
    class="n">q</span> <span class="c"># compute n</span> <span class="n">m</span>
    <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span
    class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span
    class="p">(</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span
    class="p">)</span> <span class="c"># compute m</span> <span class="k">print</span>
    <span class="p">(</span><span class="s">"Maximum number that can be encrypted
    is "</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span
    class="mi">1</span><span class="p">)</span> <span class="c">#</span> <span class="c">#
    Choose a random prime for e:</span> <span class="c">#</span> <span class="n">e</span>
    <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span
    class="n">choice</span><span class="p">(</span><span class="n">primeSieve</span><span
    class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span
    class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">m</span><span
    class="p">))))</span> <span class="k">if</span> <span class="n">m</span> <span
    class="o">%</span> <span class="n">e</span> <span class="o">==</span> <span class="mi">0</span><span
    class="p">:</span> <span class="c"># If e divides m, it won''t work!</span> <span
    class="k">print</span> <span class="p">(</span><span class="s">"Please try again"</span><span
    class="p">)</span> <span class="k">return</span> <span class="k">else</span><span
    class="p">:</span> <span class="n">d</span> <span class="o">=</span> <span class="n">inverse</span><span
    class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">m</span><span
    class="p">)</span> <span class="c"># compute d</span> <span class="n">encoder</span>
    <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span
    class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span
    class="n">e</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span>
    <span class="c"># encryption function</span> <span class="n">decoder</span> <span
    class="o">=</span> <span class="k">lambda</span> <span class="n">y</span><span
    class="p">:</span> <span class="p">(</span><span class="n">y</span><span class="o">**</span><span
    class="n">d</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span>
    <span class="c"># decryption function</span> <span class="k">return</span> <span
    class="p">[</span><span class="n">encoder</span><span class="p">,</span> <span
    class="n">decoder</span><span class="p">]</span> </pre> </div> </div> <div class="figure
    align-right" style="width: 150px"> <a class="reference internal image-reference"
    href="../Images/Alien4.PNG"><img alt="../Images/Alien4.PNG" src="../Images/Alien4.PNG"
    style="width: 0px;"/></a> </div> <p>Notice that this function is returning a list
    of two functions: the encryption and decryption functions! The encryption and
    decryption keys <span class="math">\(e\)</span> and <span class="math">\(d\)</span>
    are actual numbers that are embedded in those two functions, but <span class="math">\(x\)</span>
    and <span class="math">\(y\)</span> are the names of variables—the arguments that
    the user will ask to have encrypted or decrypted.</p> <p>Finally, we need the
    <tt class="docutils literal"><span class="pre">inverse(e,</span> <span class="pre">m)</span></tt>
    function. We can implement it very simply by using <tt class="docutils literal"><span
    class="pre">filter</span></tt>, which we saw in Section 3.4\. We’re looking for
    the single number <span class="math">\(d\)</span> such that <span class="math">\(d
    < m\)</span> and <span class="math">\(ed \mod m = 1\)</span>. So we can generate
    all of the integers between 1 and <span class="math">\(m-1\)</span> (which is
    done with <tt class="docutils literal"><span class="pre">range(1,</span> <span
    class="pre">m)</span></tt>) and then filter all of the values <span class="math">\(d\)</span>
    such that <span class="math">\(ed \mod m == 1\)</span>. Mathematicians tell us
    that there will be exactly one value of those. The <tt class="docutils literal"><span
    class="pre">filter</span></tt> function returns a list, so we use a sneaky Python
    trick and treat the call as if it were itself a list: we put <tt class="docutils
    literal"><span class="pre">[0]</span></tt> after it to pull out the first element
    and return it.</p> <div class="highlight-python"><div class="highlight"><pre><span
    class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span>
    <span class="o">*</span> <span class="k">def</span> <span class="nf">inverse</span><span
    class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">m</span><span
    class="p">):</span> <span class="sd">''''''Returns the inverse of e mod m''''''</span>
    <span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span
    class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span
    class="n">e</span><span class="o">*</span><span class="n">d</span> <span class="o">%</span>
    <span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span
    class="p">,</span> <span class="nb">range</span><span class="p">(</span><span
    class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">))[</span><span
    class="mi">0</span><span class="p">]</span> </pre> </div> </div> <p>You have to
    admit that this is amazing! However, <em>we</em> must admit that there are a few
    places where this function could be improved and extended. First, the prime numbers
    that we’re choosing from for <span class="math">\(p\)</span> and <span class="math">\(q\)</span>
    are in the range from 2 to 10\. We could easily change the 10 to something much
    larger, but we almost certainly don’t want primes as small as 2\. On the other
    hand, the <tt class="docutils literal"><span class="pre">primeSieve</span></tt>
    function expects to get a list of numbers that begins with 2 (do you see why?).
    To limit it to large prime numbers, we’d first need to generate primes beginning
    from 2 and then slice off the small ones. In addition, currently the <tt class="docutils
    literal"><span class="pre">makeEncoderDecoder</span></tt> might choose an encryption
    key <span class="math">\(e\)</span> that is a divisor of <span class="math">\(m\)</span>.
    In this case, we’re told to try running the function again. That’s not a very
    nice solution. You might try to think of ways to fix this so that <tt class="docutils
    literal"><span class="pre">makeEncoderDecoder</span></tt> would keep choosing
    values of <span class="math">\(e\)</span> until it finds one that is not a divisor
    of <span class="math">\(m\)</span>. You can do this with recursion, or you can
    do it with something called a <tt class="docutils literal"><span class="pre">while</span></tt>
    loop which we’ll see in Chapter 5.</p> <p>You might also rightfully object that
    encrypting numbers is not as interesting as encrypting strings (i.e., text). We’d
    agree. The good news is that strings can be converted into numbers and vice versa,
    as we’ll see in the next chapter. Thus, it would not be difficult to encrypt strings
    by first converting them to numbers and then encrypting those numbers as we’ve
    done here. Decryption would first decrypt the number and then convert that back
    into the original string. In fact, that’s <em>exactly</em> how real encryption
    programs work!</p> </div> <div class="section" id="conclusion"> <h2 id="sigil_toc_id_48">3.9:
    Conclusion</h2> <div class="figure align-right" style="width: 150px"> <img alt="../Images/Alien4.PNG"
    src="../Images/Alien4.PNG"/> <p class="caption"><em>I’ve been wondering what’s
    going on inside my laptop.</em></p> </div> <p>In this chapter we’ve seen a beautiful
    idea: Functions are “first-class citizens” of the language, allowing us to treat
    them just like any other kind of data. In particular, functions can be the arguments
    and results of other functions. As a result, it’s possible to have general-purpose
    higher-order functions like <tt class="docutils literal"><span class="pre">map</span></tt>,
    <tt class="docutils literal"><span class="pre">reduce</span></tt>, and <tt class="docutils
    literal"><span class="pre">filter</span></tt> that can be used in many different
    ways by simply providing them with appropriate functions of their own. Moreover,
    we can write other higher-order functions that produce functions as results, allowing
    us to easily write programs that write other programs.</p> <p>Now that we have
    explored the foundations of programming, we will turn our attention to a new question:
    “How exactly does a computer actually manage to do all of this amazing stuff?”
    To answer that question, in the next chapter we’re going to open the hood of a
    computer and see just how it works.</p> </div> </div> </div> </body></html></textarea>'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
