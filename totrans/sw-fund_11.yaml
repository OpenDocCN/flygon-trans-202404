- en: IndPrinciplesInduction Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Export ProofObjects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Check nat_ind.
  prefs: []
  type: TYPE_NORMAL
- en: '(*  ===> nat_ind :            forall P : nat -> Prop,               P 0  ->
                  (forall n : nat, P n -> P (S n))  ->               forall n : nat, P n  *)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem mult_0_r'' : ∀n:nat,'
  prefs: []
  type: TYPE_NORMAL
- en: n * 0 = 0.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: apply nat_ind.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* n = O *) reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* n = S n'' *) simpl. intros n'' IHn''. rewrite → IHn''.'
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem plus_one_r'' : ∀n:nat,'
  prefs: []
  type: TYPE_NORMAL
- en: n + 1 = S n.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: t_ind : ∀P : t → Prop,
  prefs: []
  type: TYPE_NORMAL
- en: '... case for c[1] ... →'
  prefs: []
  type: TYPE_NORMAL
- en: '... case for c[2] ... → ...'
  prefs: []
  type: TYPE_NORMAL
- en: '... case for cn ... →'
  prefs: []
  type: TYPE_NORMAL
- en: ∀n : t, P n
  prefs: []
  type: TYPE_NORMAL
- en: The specific shape of each case depends on the arguments to the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: corresponding constructor.  Before trying to write down a general
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rule, let's look at some more examples. First, an example where
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the constructors take no arguments:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star, optional (rgb)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write out the induction principle that Coq will generate for the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: following datatype.  Write down your answer on paper or type it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: into a comment, and then compare it with what Coq prints.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here's another example, this time with one of the constructors
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: taking some arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star, optional (natlist1)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Suppose we had written the above definition a little
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now what will the induction principle look like?  ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'From these examples, we can extract this general rule:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The type declaration gives several constructors; each corresponds to one clause
    of the induction principle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each constructor c takes argument types a[1] ... an.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each ai can be either t (the datatype we are defining) or some other type s.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The corresponding case of the induction principle says:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"For all values x[1]...xn of types a[1]...an, if P holds for each of the inductive
    arguments (each xi of type t), then P holds for c x[1] ... xn".'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise: 1 star, optional (byntree_ind)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write out the induction principle that Coq will generate for the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: following datatype.  (Again, write down your answer on paper or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: type it into a comment, and then compare it with what Coq
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: prints.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star, optional (ex_set)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here is an induction principle for an inductively defined
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive ExSet : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Inductive list (X:Type) : Type :=
  prefs: []
  type: TYPE_NORMAL
- en: '| nil : list X'
  prefs: []
  type: TYPE_NORMAL
- en: '| cons : X → list X → list X.'
  prefs: []
  type: TYPE_NORMAL
- en: is very similar to that of natlist.  The main difference is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'that, here, the whole definition is *parameterized* on a set X:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that is, we are defining a *family* of inductive types list X,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: one for each X.  (Note that, wherever list appears in the body
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of the declaration, it is always applied to the parameter X.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The induction principle is likewise parameterized on X:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive tree (X:Type) : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| leaf : X → tree X'
  prefs: []
  type: TYPE_NORMAL
- en: '| node : tree X → tree X → tree X.'
  prefs: []
  type: TYPE_NORMAL
- en: Check tree_ind.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'mytype_ind :'
  prefs: []
  type: TYPE_NORMAL
- en: ∀(X : Type) (P : mytype X → Prop),
  prefs: []
  type: TYPE_NORMAL
- en: (∀x : X, P (constr1 X x)) →
  prefs: []
  type: TYPE_NORMAL
- en: (∀n : nat, P (constr2 X n)) →
  prefs: []
  type: TYPE_NORMAL
- en: (∀m : mytype X, P m →
  prefs: []
  type: TYPE_NORMAL
- en: ∀n : nat, P (constr3 X m n)) →
  prefs: []
  type: TYPE_NORMAL
- en: ∀m : mytype X, P m
  prefs: []
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star, optional (foo)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Find an inductive definition that gives rise to the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'following induction principle:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive foo'' (X:Type) : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| C[1] : list X → foo'' X → foo'' X'
  prefs: []
  type: TYPE_NORMAL
- en: '| C[2] : foo'' X.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'foo''_ind :'
  prefs: []
  type: TYPE_NORMAL
- en: ∀(X : Type) (P : foo' X → Prop),
  prefs: []
  type: TYPE_NORMAL
- en: (∀(l : list X) (f : foo' X),
  prefs: []
  type: TYPE_NORMAL
- en: _______________________ →
  prefs: []
  type: TYPE_NORMAL
- en: _______________________   ) →
  prefs: []
  type: TYPE_NORMAL
- en: ___________________________________________ →
  prefs: []
  type: TYPE_NORMAL
- en: ∀f : foo' X, ________________________
  prefs: []
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: ∀P : nat → Prop,
  prefs: []
  type: TYPE_NORMAL
- en: P 0  →
  prefs: []
  type: TYPE_NORMAL
- en: (∀n : nat, P n → P (S n))  →
  prefs: []
  type: TYPE_NORMAL
- en: ∀n : nat, P n
  prefs: []
  type: TYPE_NORMAL
- en: is a generic statement that holds for all propositions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: P (or rather, strictly speaking, for all families of
  prefs: []
  type: TYPE_NORMAL
- en: propositions P indexed by a number n).  Each time we
  prefs: []
  type: TYPE_NORMAL
- en: use this principle, we are choosing P to be a particular
  prefs: []
  type: TYPE_NORMAL
- en: expression of type nat→Prop.
  prefs: []
  type: TYPE_NORMAL
- en: We can make proofs by induction more explicit by giving
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this expression a name.  For example, instead of stating
  prefs: []
  type: TYPE_NORMAL
- en: the theorem mult_0_r as "∀ n, n * 0 = 0," we can
  prefs: []
  type: TYPE_NORMAL
- en: write it as "∀ n, P_m0r n", where P_m0r is defined
  prefs: []
  type: TYPE_NORMAL
- en: as...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '... or equivalently:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now it is easier to see where P_m0r appears in the proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This extra naming step isn't something that we do in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: normal proofs, but it is useful to do it explicitly for an example
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: or two, because it allows us to see exactly what the induction
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hypothesis is.  If we prove ∀ n, P_m0r n by induction on
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: n (using either induction or apply nat_ind), we see that the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: first subgoal requires us to prove P_m0r 0 ("P holds for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: zero"), while the second subgoal requires us to prove ∀ n', P_m0r n' → P_m0r
    (S n') (that is "P holds of S n' if it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: holds of n'" or, more elegantly, "P is preserved by S").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The *induction hypothesis* is the premise of this latter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: implication — the assumption that P holds of n', which we are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: allowed to use in proving that P holds for S n'.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem plus_assoc'' : ∀n m p : nat,'
  prefs: []
  type: TYPE_NORMAL
- en: n + (m + p) = (n + m) + p.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* ...we first introduce all 3 variables into the context,      which amounts to saying "Consider an arbitrary n, m, and
         p..." *)
  prefs: []
  type: TYPE_NORMAL
- en: intros n m p.
  prefs: []
  type: TYPE_NORMAL
- en: (* ...We now use the induction tactic to prove P n (that      is, n + (m + p)
    = (n + m) + p) for _all_ n,      and hence also for the particular n that is in the context
         at the moment. *)
  prefs: []
  type: TYPE_NORMAL
- en: induction n as [| n'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* n = O *) reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* n = S n'' *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* In the second subgoal generated by induction -- the        "inductive step" -- we must prove that P
    n' implies        P (S n') for all n'.  The induction tactic        automatically introduces n' and P
    n' into the context        for us, leaving just P (S n') as the goal. *)
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rewrite → IHn'. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem plus_comm'' : ∀n m : nat,'
  prefs: []
  type: TYPE_NORMAL
- en: n + m = m + n.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: induction n as [| n'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* n = O *) intros m. rewrite ← plus_n_O. reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* n = S n'' *) intros m. simpl. rewrite → IHn''.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← plus_n_Sm. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem plus_comm'''' : ∀n m : nat,'
  prefs: []
  type: TYPE_NORMAL
- en: n + m = m + n.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* Let's do induction on m this time, instead of n... *)
  prefs: []
  type: TYPE_NORMAL
- en: induction m as [| m'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* m = O *) simpl. rewrite ← plus_n_O. reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* m = S m'' *) simpl. rewrite ← IHm''.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← plus_n_Sm. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Induction Principles in Prop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we looked in detail at the induction principles that Coq
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: generates for inductively defined *sets*.  The induction
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: principles for inductively defined *propositions* like ev are a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tiny bit more complicated.  As with all induction principles, we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: want to use the induction principle on ev to prove things by
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: inductively considering the possible shapes that something in ev
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: can have.  Intuitively speaking, however, what we want to prove
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are not statements about *evidence* but statements about
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*numbers*: accordingly, we want an induction principle that lets'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: us prove properties of numbers by induction on evidence.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, from what we've said so far, you might expect the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: inductive definition of ev...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: ev_ind_max : ∀P : (∀n : nat, ev n → Prop),
  prefs: []
  type: TYPE_NORMAL
- en: P O ev_0 →
  prefs: []
  type: TYPE_NORMAL
- en: (∀(m : nat) (E : ev m),
  prefs: []
  type: TYPE_NORMAL
- en: P m E →
  prefs: []
  type: TYPE_NORMAL
- en: P (S (S m)) (ev_SS m E)) →
  prefs: []
  type: TYPE_NORMAL
- en: ∀(n : nat) (E : ev n),
  prefs: []
  type: TYPE_NORMAL
- en: P n E
  prefs: []
  type: TYPE_NORMAL
- en: '... because:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since ev is indexed by a number n (every ev object E is a piece of evidence
    that some particular number n is even), the proposition P is parameterized by
    both n and E — that is, the induction principle can be used to prove assertions
    involving both an even number and the evidence that it is even.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since there are two ways of giving evidence of evenness (ev has two constructors),
    applying the induction principle generates two subgoals:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must prove that P holds for O and ev_0.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We must prove that, whenever n is an even number and E is an evidence of its
    evenness, if P holds of n and E, then it also holds of S (S n) and ev_SS n E.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If these subgoals can be proved, then the induction principle tells us that
    P is true for *all* even numbers n and evidence E of their evenness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is more flexibility than we normally need or want: it is'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: giving us a way to prove logical assertions where the assertion
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: involves properties of some piece of *evidence* of evenness, while
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: all we really care about is proving properties of *numbers* that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are even — we are interested in assertions about numbers, not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: about evidence.  It would therefore be more convenient to have an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: induction principle for proving propositions P that are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: parameterized just by n and whose conclusion establishes P for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'all even numbers n:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Check ev_ind.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> ev_ind         : forall P : nat -> Prop,           P 0 ->           (forall n : nat, ev n -> P n -> P (S (S n))) ->
              forall n : nat,           ev n -> P n *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem ev_ev'' : ∀n, ev n → ev'' n.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: apply ev_ind.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* ev_0 *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply ev'_0.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* ev_SS *)'
  prefs: []
  type: TYPE_NORMAL
- en: intros m Hm IH.
  prefs: []
  type: TYPE_NORMAL
- en: apply (ev'_sum 2 m).
  prefs: []
  type: TYPE_NORMAL
- en: + apply ev'_2.
  prefs: []
  type: TYPE_NORMAL
- en: + apply IH.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: (* Inductive le : nat -> nat -> Prop :=      | le_n : forall n, le n n      | le_S : forall n m, (le n m) -> (le n (S m)). *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive le (n:nat) : nat → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| le_n : le n n'
  prefs: []
  type: TYPE_NORMAL
- en: '| le_S : ∀m, (le n m) → (le n (S m)).'
  prefs: []
  type: TYPE_NORMAL
- en: Notation "m ≤ n" := (le m n).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Check le_ind.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===>  forall (n : nat) (P : nat -> Prop),            P n ->            (forall m : nat, n <= m -> P m -> P (S m)) ->
               forall n[0] : nat, n <= n[0] -> P n[0] *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: length l = length (x::l') = S (length l'),
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: it suffices to show that
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
