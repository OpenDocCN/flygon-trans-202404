["```\ntype Book = {title: string; price: decimal}\n\ntype ChocolateType = Dark | Milk | SeventyPercent\ntype Chocolate = {chocType: ChocolateType ; price: decimal}\n\ntype WrappingPaperStyle = \n    | HappyBirthday\n    | HappyHolidays\n    | SolidColor\n\ntype Gift =\n    | Book of Book\n    | Chocolate of Chocolate \n    | Wrapped of Gift * WrappingPaperStyle\n    | Boxed of Gift \n    | WithACard of Gift * message:string \n```", "```\n// a Book\nlet wolfHall = {title=\"Wolf Hall\"; price=20m}\n\n// a Chocolate\nlet yummyChoc = {chocType=SeventyPercent; price=5m}\n\n// A Gift\nlet birthdayPresent = WithACard (Wrapped (Book wolfHall, HappyBirthday), \"Happy Birthday\")\n//  WithACard (\n//    Wrapped (\n//      Book {title = \"Wolf Hall\"; price = 20M},\n//      HappyBirthday),\n//    \"Happy Birthday\")\n\n// A Gift\nlet christmasPresent = Wrapped (Boxed (Chocolate yummyChoc), HappyHolidays)\n//  Wrapped (\n//    Boxed (\n//      Chocolate {chocType = SeventyPercent; price = 5M}),\n//    HappyHolidays) \n```", "```\ntype ImpossibleGift =\n    | Boxed of ImpossibleGift \n    | WithACard of ImpossibleGift * message:string \n```", "```\nlet rec description gift =\n    match gift with \n    | Book book -> \n        sprintf \"'%s'\" book.title \n    | Chocolate choc -> \n        sprintf \"%A chocolate\" choc.chocType\n    | Wrapped (innerGift,style) -> \n        sprintf \"%s wrapped in %A paper\" (description innerGift) style\n    | Boxed innerGift -> \n        sprintf \"%s in a box\" (description innerGift) \n    | WithACard (innerGift,message) -> \n        sprintf \"%s with a card saying '%s'\" (description innerGift) message \n```", "```\n | Boxed innerGift -> \n        sprintf \"%s in a box\" (description innerGift) \n                               ~~~~~~~~~~~ <= recursive call \n```", "```\nbirthdayPresent |> description  \n// \"'Wolf Hall' wrapped in HappyBirthday paper with a card saying 'Happy Birthday'\"\n\nchristmasPresent |> description  \n// \"SeventyPercent chocolate in a box wrapped in HappyHolidays paper\" \n```", "```\nlet rec totalCost gift =\n    match gift with \n    | Book book -> \n        book.price\n    | Chocolate choc -> \n        choc.price\n    | Wrapped (innerGift,style) -> \n        (totalCost innerGift) + 0.5m\n    | Boxed innerGift -> \n        (totalCost innerGift) + 1.0m\n    | WithACard (innerGift,message) -> \n        (totalCost innerGift) + 2.0m \n```", "```\nbirthdayPresent |> totalCost \n// 22.5m\n\nchristmasPresent |> totalCost \n// 6.5m \n```", "```\nlet rec whatsInside gift =\n    match gift with \n    | Book book -> \n        \"A book\"\n    | Chocolate choc -> \n        \"Some chocolate\"\n    | Wrapped (innerGift,style) -> \n        whatsInside innerGift\n    | Boxed innerGift -> \n        whatsInside innerGift\n    | WithACard (innerGift,message) -> \n        whatsInside innerGift \n```", "```\nbirthdayPresent |> whatsInside \n// \"A book\"\n\nchristmasPresent |> whatsInside \n// \"Some chocolate\" \n```", "```\nlet rec cataGift fBook fChocolate fWrapped fBox fCard gift =\n    match gift with \n    | Book book -> \n        fBook book\n    | Chocolate choc -> \n        fChocolate choc\n    | Wrapped (innerGift,style) -> \n        let innerGiftResult = cataGift fBook fChocolate fWrapped fBox fCard innerGift\n        fWrapped (innerGiftResult,style)\n    | Boxed innerGift -> \n        let innerGiftResult = cataGift fBook fChocolate fWrapped fBox fCard innerGift\n        fBox innerGiftResult \n    | WithACard (innerGift,message) -> \n        let innerGiftResult = cataGift fBook fChocolate fWrapped fBox fCard innerGift\n        fCard (innerGiftResult,message) \n```", "```\nlet totalCostUsingCata gift =\n    let fBook (book:Book) = \n        book.price\n    let fChocolate (choc:Chocolate) = \n        choc.price\n    let fWrapped  (innerCost,style) = \n        innerCost + 0.5m\n    let fBox innerCost = \n        innerCost + 1.0m\n    let fCard (innerCost,message) = \n        innerCost + 2.0m\n    // call the catamorphism\n    cataGift fBook fChocolate fWrapped fBox fCard gift \n```", "```\nbirthdayPresent |> totalCostUsingCata \n// 22.5m \n```", "```\nlet descriptionUsingCata gift =\n    let fBook (book:Book) = \n        sprintf \"'%s'\" book.title \n    let fChocolate (choc:Chocolate) = \n        sprintf \"%A chocolate\" choc.chocType\n    let fWrapped (innerText,style) = \n        sprintf \"%s wrapped in %A paper\" innerText style\n    let fBox innerText = \n        sprintf \"%s in a box\" innerText\n    let fCard (innerText,message) = \n        sprintf \"%s with a card saying '%s'\" innerText message\n    // call the catamorphism\n    cataGift fBook fChocolate fWrapped fBox fCard gift \n```", "```\nbirthdayPresent |> descriptionUsingCata  \n// \"'Wolf Hall' wrapped in HappyBirthday paper with a card saying 'Happy Birthday'\"\n\nchristmasPresent |> descriptionUsingCata  \n// \"SeventyPercent chocolate in a box wrapped in HappyHolidays paper\" \n```", "```\nlet rec cataGift fBook fChocolate fWrapped fBox fCard gift =\n    let recurse = cataGift fBook fChocolate fWrapped fBox fCard\n    match gift with \n    | Book book -> \n        fBook book\n    | Chocolate choc -> \n        fChocolate choc\n    | Wrapped (innerGift,style) -> \n        let innerGiftResult = recurse innerGift\n        fWrapped (innerGiftResult,style)\n    | Boxed innerGift -> \n        let innerGiftResult = recurse innerGift\n        fBox innerGiftResult \n    | WithACard (innerGift,message) -> \n        let innerGiftResult = recurse innerGift\n        fCard (innerGiftResult,message) \n```", "```\nlet rec cataGift fBook fChocolate fWrapped fBox fCard gift =\n    let recurse = cataGift fBook fChocolate fWrapped fBox fCard\n    match gift with \n    | Book book -> \n        fBook book\n    | Chocolate choc -> \n        fChocolate choc\n    | Wrapped (gift,style) -> \n        fWrapped (recurse gift,style)\n    | Boxed gift -> \n        fBox (recurse gift)\n    | WithACard (gift,message) -> \n        fCard (recurse gift,message) \n```", "```\nlet rec cataGift fBook fChocolate fWrapped fBox fCard gift :'r =\n//                                name the return type =>  ~~~~ \n```", "```\nlet rec cataGift fBook fChocolate fWrapped fBox fCard gift :'r =\n    let recurse = cataGift fBook fChocolate fWrapped fBox fCard\n    match gift with \n    | Book book -> \n        fBook book\n    | Chocolate choc -> \n        fChocolate choc\n    | Wrapped (gift,style) -> \n        fWrapped (recurse gift,style)\n    | Boxed gift -> \n        fBox (recurse gift)\n    | WithACard (gift,message) -> \n        fCard (recurse gift,message) \n```", "```\nval cataGift :\n  fBook:(Book -> 'r) ->\n  fChocolate:(Chocolate -> 'r) ->\n  fWrapped:('r * WrappingPaperStyle -> 'r) ->\n  fBox:('r -> 'r) ->\n  fCard:('r * string -> 'r) -> \n  // input value\n  gift:Gift -> \n  // return value\n  'r \n```", "```\n// The Gift.Book constructor \nBook -> Gift\n\n// The fBook handler\nBook -> 'r\n\n// The Gift.Wrapped constructor \nGift * WrappingPaperStyle -> Gift\n\n// The fWrapped handler\n'r   * WrappingPaperStyle -> 'r\n\n// The Gift.Boxed constructor \nGift -> Gift\n\n// The fBox handler\n'r   -> 'r \n```", "```\ntype Gift =\n    | Book of Book\n    | Chocolate of Chocolate \n    | Wrapped of Gift * WrappingPaperStyle\n    | Boxed of Gift \n```", "```\nlet rec cataGift fBook fChocolate fWrapped fBox gift :'r =\n    let recurse = cataGift fBook fChocolate fWrapped fBox \n    match gift with \n    | Book book -> \n        fBook book\n    | Chocolate choc -> \n        fChocolate choc\n    | Wrapped (gift,style) -> \n        fWrapped (recurse gift,style)\n    | Boxed gift -> \n        fBox (recurse gift) \n```", "```\ntype Gift =\n    | Book of Book\n    | Chocolate of Chocolate \n    | Wrapped of Gift * WrappingPaperStyle\n    | Boxed of Gift \n    | WithACard of Gift * message:string \n```", "```\n/// Uses Gift_V2 but is still backwards compatible with the earlier \"cataGift\".\nlet rec cataGift fBook fChocolate fWrapped fBox gift :'r =\n    let recurse = cataGift fBook fChocolate fWrapped fBox \n    match gift with \n    | Book book -> \n        fBook book\n    | Chocolate choc -> \n        fChocolate choc\n    | Wrapped (gift,style) -> \n        fWrapped (recurse gift,style)\n    | Boxed gift -> \n        fBox (recurse gift)\n    // pass through the new case silently \n    | WithACard (gift,message) -> \n        recurse gift \n```", "```\nlet rec (|Book|Chocolate|Wrapped|Boxed|) gift =\n    match gift with \n    | Gift.Book book -> \n        Book book\n    | Gift.Chocolate choc -> \n        Chocolate choc\n    | Gift.Wrapped (gift,style) -> \n        Wrapped (gift,style)\n    | Gift.Boxed gift -> \n        Boxed gift\n    | Gift.WithACard (gift,message) -> \n        // ignore the message and recurse into the gift\n        (|Book|Chocolate|Wrapped|Boxed|) gift \n```", "```\nlet rec whatsInside gift =\n    match gift with \n    | Book book -> \n        \"A book\"\n    | Chocolate choc -> \n        \"Some chocolate\"\n    | Wrapped (gift,style) -> \n        whatsInside gift\n    | Boxed gift -> \n        whatsInside gift \n```", "```\nlet handleContents fBook fChocolate gift =\n    let fWrapped (innerGiftResult,style) =   \n        innerGiftResult\n    let fBox innerGiftResult = \n        innerGiftResult\n    let fCard (innerGiftResult,message) = \n        innerGiftResult\n\n    // call the catamorphism\n    cataGift fBook fChocolate fWrapped fBox fCard gift \n```", "```\nbirthdayPresent \n|> handleContents \n    (fun book -> \"The book you wanted for your birthday\") \n    (fun choc -> \"Your fave chocolate\")\n// Result => \"The book you wanted for your birthday\"\n\nchristmasPresent \n|> handleContents \n    (fun book -> \"The book you wanted for Christmas\") \n    (fun choc -> \"Don't eat too much over the holidays!\")\n// Result => \"Don't eat too much over the holidays!\" \n```", "```\ntype GiftMinusChocolate =\n    | Book of Book\n    | Apology of string\n    | Wrapped of GiftMinusChocolate * WrappingPaperStyle \n```", "```\nlet removeChocolate gift =\n    let fBook (book:Book) = \n        Book book\n    let fChocolate (choc:Chocolate) = \n        Apology \"sorry I ate your chocolate\"\n    let fWrapped (innerGiftResult,style) = \n        Wrapped (innerGiftResult,style) \n    let fBox innerGiftResult = \n        innerGiftResult\n    let fCard (innerGiftResult,message) = \n        innerGiftResult\n    // call the catamorphism\n    cataGift fBook fChocolate fWrapped fBox fCard gift \n```", "```\nbirthdayPresent |> removeChocolate\n// GiftMinusChocolate = \n//     Wrapped (Book {title = \"Wolf Hall\"; price = 20M}, HappyBirthday)\n\nchristmasPresent |> removeChocolate\n// GiftMinusChocolate = \n//     Wrapped (Apology \"sorry I ate your chocolate\", HappyHolidays) \n```", "```\nlet deepCopy gift =\n    let fBook book = \n        Book book \n    let fChocolate (choc:Chocolate) = \n        Chocolate choc\n    let fWrapped (innerGiftResult,style) = \n        Wrapped (innerGiftResult,style) \n    let fBox innerGiftResult = \n        Boxed innerGiftResult\n    let fCard (innerGiftResult,message) = \n        WithACard (innerGiftResult,message) \n    // call the catamorphism\n    cataGift fBook fChocolate fWrapped fBox fCard gift \n```", "```\nlet deepCopy gift =\n    let fBook = Book \n    let fChocolate = Chocolate \n    let fWrapped = Wrapped \n    let fBox = Boxed \n    let fCard = WithACard \n    // call the catamorphism\n    cataGift fBook fChocolate fWrapped fBox fCard gift \n```", "```\nchristmasPresent |> deepCopy\n// Result => \n//   Wrapped ( \n//    Boxed (Chocolate {chocType = SeventyPercent; price = 5M;}),\n//    HappyHolidays) \n```", "```\nlet upgradeChocolate gift =\n    let fBook = Book \n    let fChocolate (choc:Chocolate) = \n        Chocolate {choc with chocType = SeventyPercent}\n    let fWrapped = Wrapped \n    let fBox = Boxed \n    let fCard = WithACard \n    // call the catamorphism\n    cataGift fBook fChocolate fWrapped fBox fCard gift \n```", "```\n// create some chocolate I don't like\nlet cheapChoc = Boxed (Chocolate {chocType=Milk; price=5m})\n\n// upgrade it!\ncheapChoc |> upgradeChocolate\n// Result =>\n//   Boxed (Chocolate {chocType = SeventyPercent; price = 5M}) \n```", "```\ntype FileSystemItem =\n    | File of File\n    | Directory of Directory\nand File = {name:string; fileSize:int}\nand Directory = {name:string; dirSize:int; subitems:FileSystemItem list} \n```", "```\nlet readme = File {name=\"readme.txt\"; fileSize=1}\nlet config = File {name=\"config.xml\"; fileSize=2}\nlet build  = File {name=\"build.bat\"; fileSize=3}\nlet src = Directory {name=\"src\"; dirSize=10; subitems=[readme; config; build]}\nlet bin = Directory {name=\"bin\"; dirSize=10; subitems=[]}\nlet root = Directory {name=\"root\"; dirSize=5; subitems=[src; bin]} \n```", "```\n// case constructor\nFile  : File -> FileSystemItem\n\n// function parameter to handle File case \nfFile : File -> 'r \n```", "```\nlet rec cataFS fFile fDir item :'r = \n    let recurse = cataFS fFile fDir \n    match item with\n    | File file -> \n        fFile file\n    | Directory dir -> \n        // to do \n```", "```\n// case constructor (Directory as record)\nDirectory : Directory -> FileSystemItem\n\n// case constructor (Directory unpacked as tuple)\nDirectory : (string, int, FileSystemItem list) -> FileSystemItem\n//   replace with 'r ===> ~~~~~~~~~~~~~~          ~~~~~~~~~~~~~~\n\n// function parameter to handle Directory case \nfDir :      (string, int, 'r list)             -> 'r \n```", "```\nlet rec cataFS fFile fDir item :'r = \n    let recurse = cataFS fFile fDir \n    match item with\n    | File file -> \n        fFile file\n    | Directory dir -> \n        let listOfRs = dir.subitems |> List.map recurse \n        fDir (dir.name,dir.dirSize,listOfRs) \n```", "```\nval cataFS :\n    fFile : (File -> 'r) ->\n    fDir  : (string * int * 'r list -> 'r) -> \n    // input value\n    FileSystemItem -> \n    // return value\n    'r \n```", "```\nlet totalSize fileSystemItem =\n    let fFile (file:File) = \n        file.fileSize\n    let fDir (name,size,subsizes) = \n        (List.sum subsizes) + size\n    cataFS fFile fDir fileSystemItem \n```", "```\nreadme |> totalSize  // 1\nsrc |> totalSize     // 16 = 10 + (1 + 2 + 3)\nroot |> totalSize    // 31 = 5 + 16 + 10 \n```", "```\nlet fFile (file:File) = \n    Some file \n```", "```\nlet fDir (name,size,subfiles) = \n    match subfiles with\n    | [] -> \n        None  // empty directory\n    | subfiles -> \n        // return largest one \n```", "```\n// helper to provide a default if missing\nlet ifNone deflt opt =\n    defaultArg opt deflt \n\n// get the file size of an option \nlet fileSize fileOpt = \n    fileOpt \n    |> Option.map (fun file -> file.fileSize)\n    |> ifNone 0 \n```", "```\nlet largestFile fileSystemItem =\n\n    // helper to provide a default if missing\n    let ifNone deflt opt =\n        defaultArg opt deflt \n\n    // helper to get the size of a File option\n    let fileSize fileOpt = \n        fileOpt \n        |> Option.map (fun file -> file.fileSize)\n        |> ifNone 0\n\n    // handle File case \n    let fFile (file:File) = \n        Some file\n\n    // handle Directory case \n    let fDir (name,size,subfiles) = \n        match subfiles with\n        | [] -> \n            None  // empty directory\n        | subfiles -> \n            // find the biggest File option using the helper\n            subfiles \n            |> List.maxBy fileSize  \n\n    // call the catamorphism\n    cataFS fFile fDir fileSystemItem \n```", "```\nreadme |> largestFile  \n// Some {name = \"readme.txt\"; fileSize = 1}\n\nsrc |> largestFile     \n// Some {name = \"build.bat\"; fileSize = 3}\n\nbin |> largestFile     \n// None\n\nroot |> largestFile    \n// Some {name = \"build.bat\"; fileSize = 3} \n```", "```\ntype Product =\n    | Bought of BoughtProduct \n    | Made of MadeProduct \nand BoughtProduct = {\n    name : string \n    weight : int \n    vendor : string option }\nand MadeProduct = {\n    name : string \n    weight : int \n    components:Component list }\nand Component = {\n    qty : int\n    product : Product } \n```", "```\nlet label = \n    Bought {name=\"label\"; weight=1; vendor=Some \"ACME\"}\nlet bottle = \n    Bought {name=\"bottle\"; weight=2; vendor=Some \"ACME\"}\nlet formulation = \n    Bought {name=\"formulation\"; weight=3; vendor=None}\n\nlet shampoo = \n    Made {name=\"shampoo\"; weight=10; components=\n    [\n    {qty=1; product=formulation}\n    {qty=1; product=bottle}\n    {qty=2; product=label}\n    ]}\n\nlet twoPack = \n    Made {name=\"twoPack\"; weight=5; components=\n    [\n    {qty=2; product=shampoo}\n    ]} \n```", "```\n// case constructor\nBought  : BoughtProduct -> Product\n\n// function parameter to handle Bought case \nfBought : BoughtProduct -> 'r \n```", "```\n// case constructor\nMade  : MadeProduct -> Product\n\n// case constructor (MadeProduct unpacked as tuple)\nMade  : (string,int,Component list) -> Product\n\n// case constructor (Component unpacked as tuple)\nMade  : (string,int,(int,Product) list) -> Product\n//  replace with 'r ===> ~~~~~~~           ~~~~~~~\n\n// function parameter to handle Made case \nfMade : (string,int,(int,'r) list)      -> 'r \n```", "```\n// Converts a Component into a (int * 'r) tuple\nlet convertComponentToTuple comp =\n    (comp.qty,recurse comp.product) \n```", "```\nlet componentTuples = \n    made.components \n    |> List.map convertComponentToTuple \n```", "```\nlet rec cataProduct fBought fMade product :'r = \n    let recurse = cataProduct fBought fMade \n\n    // Converts a Component into a (int * 'r) tuple\n    let convertComponentToTuple comp =\n        (comp.qty,recurse comp.product)\n\n    match product with\n    | Bought bought -> \n        fBought bought \n    | Made made -> \n        let componentTuples =  // (int * 'r) list\n            made.components \n            |> List.map convertComponentToTuple \n        fMade (made.name,made.weight,componentTuples) \n```", "```\nlet productWeight product =\n\n    // handle Bought case\n    let fBought (bought:BoughtProduct) = \n        bought.weight\n\n    // handle Made case\n    let fMade (name,weight,componentTuples) = \n        // helper to calculate weight of one component tuple\n        let componentWeight (qty,weight) =\n            qty * weight\n        // add up the weights of all component tuples\n        let totalComponentWeight = \n            componentTuples \n            |> List.sumBy componentWeight \n        // and add the weight of the Made case too\n        totalComponentWeight + weight\n\n    // call the catamorphism\n    cataProduct fBought fMade product \n```", "```\nlabel |> productWeight    // 1\nshampoo |> productWeight  // 17 = 10 + (2x1 + 1x2 + 1x3)\ntwoPack |> productWeight  // 39 = 5  + (2x17) \n```", "```\ntype VendorScore = {vendor:string; score:int} \n```", "```\nlet vendor vs = vs.vendor\nlet score vs = vs.score \n```", "```\nlet fBought (bought:BoughtProduct) = \n    // set score = 1 if there is a vendor\n    bought.vendor\n    |> Option.map (fun vendor -> {vendor = vendor; score = 1} )\n    // => a VendorScore option\n    |> Option.toList\n    // => a VendorScore list \n```", "```\nlet mostUsedVendor product =\n\n    let fBought (bought:BoughtProduct) = \n        // set score = 1 if there is a vendor\n        bought.vendor\n        |> Option.map (fun vendor -> {vendor = vendor; score = 1} )\n        // => a VendorScore option\n        |> Option.toList\n        // => a VendorScore list\n\n    let fMade (name,weight,subresults) = \n        // subresults are a list of (qty * VendorScore list)\n\n        // helper to get sum of scores\n        let totalScore (vendor,vendorScores) =\n            let totalScore = vendorScores |> List.sumBy score\n            {vendor=vendor; score=totalScore}\n\n        subresults \n        // => a list of (qty * VendorScore list)\n        |> List.collect snd  // ignore qty part of subresult\n        // => a list of VendorScore \n        |> List.groupBy vendor \n        // second item is list of VendorScore, reduce to sum\n        |> List.map totalScore \n        // => list of VendorScores \n\n    // call the catamorphism\n    cataProduct fBought fMade product\n    |> List.sortByDescending score  // find highest score\n    // return first, or None if list is empty\n    |> List.tryHead \n```", "```\nlabel |> mostUsedVendor    \n// Some {vendor = \"ACME\"; score = 1}\n\nformulation |> mostUsedVendor  \n// None\n\nshampoo |> mostUsedVendor  \n// Some {vendor = \"ACME\"; score = 2}\n\ntwoPack |> mostUsedVendor  \n// Some {vendor = \"ACME\"; score = 2} \n```", "```\ntype Book = {title: string; price: decimal}\n\ntype ChocolateType = Dark | Milk | SeventyPercent\ntype Chocolate = {chocType: ChocolateType ; price: decimal}\n\ntype WrappingPaperStyle = \n    | HappyBirthday\n    | HappyHolidays\n    | SolidColor\n\ntype Gift =\n    | Book of Book\n    | Chocolate of Chocolate \n    | Wrapped of Gift * WrappingPaperStyle\n    | Boxed of Gift \n    | WithACard of Gift * message:string \n```", "```\n// A Book\nlet wolfHall = {title=\"Wolf Hall\"; price=20m}\n// A Chocolate\nlet yummyChoc = {chocType=SeventyPercent; price=5m}\n// A Gift\nlet birthdayPresent = WithACard (Wrapped (Book wolfHall, HappyBirthday), \"Happy Birthday\")\n// A Gift\nlet christmasPresent = Wrapped (Boxed (Chocolate yummyChoc), HappyHolidays) \n```", "```\nlet rec cataGift fBook fChocolate fWrapped fBox fCard gift :'r =\n    let recurse = cataGift fBook fChocolate fWrapped fBox fCard\n    match gift with \n    | Book book -> \n        fBook book\n    | Chocolate choc -> \n        fChocolate choc\n    | Wrapped (gift,style) -> \n        fWrapped (recurse gift,style)\n    | Boxed gift -> \n        fBox (recurse gift)\n    | WithACard (gift,message) -> \n        fCard (recurse gift,message) \n```", "```\nlet totalCostUsingCata gift =\n    let fBook (book:Book) = \n        book.price\n    let fChocolate (choc:Chocolate) = \n        choc.price\n    let fWrapped  (innerCost,style) = \n        innerCost + 0.5m\n    let fBox innerCost = \n        innerCost + 1.0m\n    let fCard (innerCost,message) = \n        innerCost + 2.0m\n    // call the catamorphism\n    cataGift fBook fChocolate fWrapped fBox fCard gift \n```", "```\nlet deeplyNestedBox depth =\n    let rec loop depth boxSoFar =\n        match depth with\n        | 0 -> boxSoFar \n        | n -> loop (n-1) (Boxed boxSoFar)\n    loop depth (Book wolfHall) \n```", "```\ndeeplyNestedBox 5\n// Boxed (Boxed (Boxed (Boxed (Boxed (Book {title = \"Wolf Hall\"; price = 20M})))))\n\ndeeplyNestedBox 10\n//  Boxed(Boxed(Boxed(Boxed(Boxed\n//   (Boxed(Boxed(Boxed(Boxed(Boxed(Book {title = \"Wolf Hall\";price = 20M})))))))))) \n```", "```\ndeeplyNestedBox 10 |> totalCostUsingCata       // OK     30.0M\ndeeplyNestedBox 100 |> totalCostUsingCata      // OK    120.0M\ndeeplyNestedBox 1000 |> totalCostUsingCata     // OK   1020.0M \n```", "```\ndeeplyNestedBox 10000 |> totalCostUsingCata  // Stack overflow?\ndeeplyNestedBox 100000 |> totalCostUsingCata // Stack overflow? \n```", "```\ninnerCost + 1.0m where innerCost = \n  innerCost2 + 1.0m where innerCost2 = \n    innerCost3 + 1.0m where innerCost3 = \n      innerCost4 + 1.0m where innerCost4 = \n        ...\n        innerCost999 + 1.0m where innerCost999 = \n          innerCost1000 + 1.0m where innerCost1000 = \n            book.price \n```", "```\ncostSoFar = 1.0m; evaluate calcInnerCost with costSoFar: \n  costSoFar = costSoFar + 1.0m; evaluate calcInnerCost with costSoFar: \n    costSoFar = costSoFar + 1.0m; evaluate calcInnerCost with costSoFar: \n      costSoFar = costSoFar + 1.0m; evaluate calcInnerCost with costSoFar: \n        ...\n        costSoFar = costSoFar + 1.0m; evaluate calcInnerCost with costSoFar: \n          costSoFar = costSoFar + 1.0m; evaluate calcInnerCost with costSoFar: \n            finalCost = costSoFar + book.price   // final answer \n```", "```\nlet rec totalCostUsingAcc costSoFar gift =\n    match gift with \n    | Book book -> \n        costSoFar + book.price  // final result\n    | Chocolate choc -> \n        costSoFar + choc.price  // final result\n    | Wrapped (innerGift,style) -> \n        let newCostSoFar = costSoFar + 0.5m\n        totalCostUsingAcc newCostSoFar innerGift \n    | Boxed innerGift -> \n        let newCostSoFar = costSoFar + 1.0m\n        totalCostUsingAcc newCostSoFar innerGift \n    | WithACard (innerGift,message) -> \n        let newCostSoFar = costSoFar + 2.0m\n        totalCostUsingAcc newCostSoFar innerGift \n```", "```\ndeeplyNestedBox 1000 |> totalCostUsingAcc 0.0m     // OK    1020.0M\ndeeplyNestedBox 10000 |> totalCostUsingAcc 0.0m    // OK   10020.0M\ndeeplyNestedBox 100000 |> totalCostUsingAcc 0.0m   // OK  100020.0M\ndeeplyNestedBox 1000000 |> totalCostUsingAcc 0.0m  // OK 1000020.0M \n```", "```\nlet rec foldGift fBook fChocolate fWrapped fBox fCard acc gift :'r =\n    let recurse = foldGift fBook fChocolate fWrapped fBox fCard \n    match gift with \n    | Book book -> \n        let finalAcc = fBook acc book\n        finalAcc     // final result\n    | Chocolate choc -> \n        let finalAcc = fChocolate acc choc\n        finalAcc     // final result\n    | Wrapped (innerGift,style) -> \n        let newAcc = fWrapped acc style\n        recurse newAcc innerGift \n    | Boxed innerGift -> \n        let newAcc = fBox acc \n        recurse newAcc innerGift \n    | WithACard (innerGift,message) -> \n        let newAcc = fCard acc message \n        recurse newAcc innerGift \n```", "```\nval foldGift :\n  fBook:('a -> Book -> 'r) ->\n  fChocolate:('a -> Chocolate -> 'r) ->\n  fWrapped:('a -> WrappingPaperStyle -> 'a) ->\n  fBox:('a -> 'a) ->\n  fCard:('a -> string -> 'a) -> \n  // accumulator\n  acc:'a -> \n  // input value\n  gift:Gift -> \n  // return value\n  'r \n```", "```\n// original catamorphism\nfBook:(Book -> 'r)\nfChocolate:(Chocolate -> 'r)\n\n// fold\nfBook:('a -> Book -> 'r)\nfChocolate:('a -> Chocolate -> 'r) \n```", "```\n// original catamorphism\nfWrapped:('r -> WrappingPaperStyle -> 'r) \nfBox:('r -> 'r) \n\n// fold\nfWrapped:('a -> WrappingPaperStyle -> 'a)\nfBox:('a -> 'a) \n```", "```\nlet totalCostUsingFold gift =  \n\n    let fBook costSoFar (book:Book) = \n        costSoFar + book.price\n    let fChocolate costSoFar (choc:Chocolate) = \n        costSoFar + choc.price\n    let fWrapped costSoFar style = \n        costSoFar + 0.5m\n    let fBox costSoFar = \n        costSoFar + 1.0m\n    let fCard costSoFar message = \n        costSoFar + 2.0m\n\n    // initial accumulator\n    let initialAcc = 0m\n\n    // call the fold\n    foldGift fBook fChocolate fWrapped fBox fCard initialAcc gift \n```", "```\ndeeplyNestedBox 100000 |> totalCostUsingFold  // no problem   100020.0M\ndeeplyNestedBox 1000000 |> totalCostUsingFold // no problem  1000020.0M \n```", "```\nlet descriptionUsingFold gift =\n    let fBook descriptionSoFar (book:Book) = \n        sprintf \"'%s' %s\" book.title descriptionSoFar\n\n    let fChocolate descriptionSoFar (choc:Chocolate) = \n        sprintf \"%A chocolate %s\" choc.chocType descriptionSoFar\n\n    let fWrapped descriptionSoFar style = \n        sprintf \"%s wrapped in %A paper\" descriptionSoFar style\n\n    let fBox descriptionSoFar = \n        sprintf \"%s in a box\" descriptionSoFar \n\n    let fCard descriptionSoFar message = \n        sprintf \"%s with a card saying '%s'\" descriptionSoFar message\n\n    // initial accumulator\n    let initialAcc = \"\"\n\n    // main call\n    foldGift fBook fChocolate fWrapped fBox fCard initialAcc gift \n```", "```\nbirthdayPresent |> descriptionUsingFold  \n// \"'Wolf Hall'  with a card saying 'Happy Birthday' wrapped in HappyBirthday paper\"\n\nchristmasPresent |> descriptionUsingFold  \n// \"SeventyPercent chocolate  wrapped in HappyHolidays paper in a box\" \n```", "```\n// OUTPUT: \"'Wolf Hall'  with a card saying 'Happy Birthday' wrapped in HappyBirthday paper\"\n// CORRECT \"'Wolf Hall' wrapped in HappyBirthday paper with a card saying 'Happy Birthday'\"\n\n// OUTPUT: \"SeventyPercent chocolate  wrapped in HappyHolidays paper in a box\"\n// CORRECT \"SeventyPercent chocolate in a box wrapped in HappyHolidays paper\" \n```", "```\nlet fBook descriptionGenerator (book:Book) = \n    descriptionGenerator (sprintf \"'%s'\" book.title)\n//  ~~~~~~~~~~~~~~~~~~~~  <= a function as an accumulator!\n\nlet fChocolate descriptionGenerator (choc:Chocolate) = \n    descriptionGenerator (sprintf \"%A chocolate\" choc.chocType) \n```", "```\nlet fWrapped descriptionGenerator style = \n    let newDescriptionGenerator innerText =\n        let newInnerText = sprintf \"%s wrapped in %A paper\" innerText style\n        descriptionGenerator newInnerText \n    newDescriptionGenerator \n\nlet fBox descriptionGenerator = \n    let newDescriptionGenerator innerText =\n        let newInnerText = sprintf \"%s in a box\" innerText \n        descriptionGenerator newInnerText \n    newDescriptionGenerator \n```", "```\nlet fWrapped descriptionGenerator style = \n    fun innerText ->\n        let newInnerText = sprintf \"%s wrapped in %A paper\" innerText style\n        descriptionGenerator newInnerText \n\nlet fBox descriptionGenerator = \n    fun innerText ->\n        let newInnerText = sprintf \"%s in a box\" innerText \n        descriptionGenerator newInnerText \n```", "```\nlet descriptionUsingFoldWithGenerator gift =\n\n    let fBook descriptionGenerator (book:Book) = \n        descriptionGenerator (sprintf \"'%s'\" book.title)\n\n    let fChocolate descriptionGenerator (choc:Chocolate) = \n        descriptionGenerator (sprintf \"%A chocolate\" choc.chocType)\n\n    let fWrapped descriptionGenerator style = \n        fun innerText ->\n            let newInnerText = sprintf \"%s wrapped in %A paper\" innerText style\n            descriptionGenerator newInnerText \n\n    let fBox descriptionGenerator = \n        fun innerText ->\n            let newInnerText = sprintf \"%s in a box\" innerText \n            descriptionGenerator newInnerText \n\n    let fCard descriptionGenerator message = \n        fun innerText ->\n            let newInnerText = sprintf \"%s with a card saying '%s'\" innerText message \n            descriptionGenerator newInnerText \n\n    // initial DescriptionGenerator\n    let initialAcc = fun innerText -> innerText \n\n    // main call\n    foldGift fBook fChocolate fWrapped fBox fCard initialAcc gift \n```", "```\nbirthdayPresent |> descriptionUsingFoldWithGenerator  \n// CORRECT \"'Wolf Hall' wrapped in HappyBirthday paper with a card saying 'Happy Birthday'\"\n\nchristmasPresent |> descriptionUsingFoldWithGenerator  \n// CORRECT \"SeventyPercent chocolate in a box wrapped in HappyHolidays paper\" \n```", "```\nlet rec foldbackGift fBook fChocolate fWrapped fBox fCard generator gift :'r =\n    let recurse = foldbackGift fBook fChocolate fWrapped fBox fCard \n    match gift with \n    | Book book -> \n        generator (fBook book)\n    | Chocolate choc -> \n        generator (fChocolate choc)\n    | Wrapped (innerGift,style) -> \n        let newGenerator innerVal =\n            let newInnerVal = fWrapped innerVal style\n            generator newInnerVal \n        recurse newGenerator innerGift \n    | Boxed innerGift -> \n        let newGenerator innerVal =\n            let newInnerVal = fBox innerVal \n            generator newInnerVal \n        recurse newGenerator innerGift \n    | WithACard (innerGift,message) -> \n        let newGenerator innerVal =\n            let newInnerVal = fCard innerVal message \n            generator newInnerVal \n        recurse newGenerator innerGift \n```", "```\nval foldbackGift :\n  fBook:(Book -> 'a) ->\n  fChocolate:(Chocolate -> 'a) ->\n  fWrapped:('a -> WrappingPaperStyle -> 'a) ->\n  fBox:('a -> 'a) ->\n  fCard:('a -> string -> 'a) ->\n  // accumulator\n  generator:('a -> 'r) -> \n  // input value\n  gift:Gift -> \n  // return value\n  'r \n```", "```\nlet descriptionUsingFoldBack gift =\n    let fBook (book:Book) = \n        sprintf \"'%s'\" book.title \n    let fChocolate (choc:Chocolate) = \n        sprintf \"%A chocolate\" choc.chocType\n    let fWrapped innerText style = \n        sprintf \"%s wrapped in %A paper\" innerText style\n    let fBox innerText = \n        sprintf \"%s in a box\" innerText \n    let fCard innerText message = \n        sprintf \"%s with a card saying '%s'\" innerText message \n    // initial DescriptionGenerator\n    let initialAcc = fun innerText -> innerText \n    // main call\n    foldbackGift fBook fChocolate fWrapped fBox fCard initialAcc gift \n```", "```\nbirthdayPresent |> descriptionUsingFoldBack\n// CORRECT \"'Wolf Hall' wrapped in HappyBirthday paper with a card saying 'Happy Birthday'\"\n\nchristmasPresent |> descriptionUsingFoldBack\n// CORRECT \"SeventyPercent chocolate in a box wrapped in HappyHolidays paper\" \n```", "```\nlet descriptionUsingCata gift =\n    let fBook (book:Book) = \n        sprintf \"'%s'\" book.title \n    let fChocolate (choc:Chocolate) = \n        sprintf \"%A chocolate\" choc.chocType\n    let fWrapped (innerText,style) = \n        sprintf \"%s wrapped in %A paper\" innerText style\n    let fBox innerText = \n        sprintf \"%s in a box\" innerText\n    let fCard (innerText,message) = \n        sprintf \"%s with a card saying '%s'\" innerText message\n    // call the catamorphism\n    cataGift fBook fChocolate fWrapped fBox fCard gift \n```", "```\nlet descriptionUsingFoldBack gift =\n    let fBook (book:Book) = \n        sprintf \"'%s'\" book.title \n    let fChocolate (choc:Chocolate) = \n        sprintf \"%A chocolate\" choc.chocType\n    let fWrapped innerText style = \n        sprintf \"%s wrapped in %A paper\" innerText style\n    let fBox innerText = \n        sprintf \"%s in a box\" innerText \n    let fCard innerText message = \n        sprintf \"%s with a card saying '%s'\" innerText message \n    // initial DescriptionGenerator\n    let initialAcc = fun innerText -> innerText    // could be replaced with id\n    // main call\n    foldbackGift fBook fChocolate fWrapped fBox fCard initialAcc gift \n```", "```\nfWrapped:('a -> WrappingPaperStyle -> 'a) \n```", "```\nfWrapped:('a -> WrappingPaperStyle -> 'a) \n```", "```\nlet rec foldbackGift fBook fChocolate fWrapped fBox fCard gift generator :'r =\n//swapped =>                                              ~~~~~~~~~~~~~~ \n\n    let recurse = foldbackGiftWithAccLast fBook fChocolate fWrapped fBox fCard \n\n    match gift with \n    | Book book -> \n        generator (fBook book)\n    | Chocolate choc -> \n        generator (fChocolate choc)\n\n    | Wrapped (innerGift,style) -> \n        let newGenerator innerVal =\n            let newInnerVal = fWrapped style innerVal \n//swapped =>                           ~~~~~~~~~~~~~~ \n            generator newInnerVal \n        recurse innerGift newGenerator  \n//swapped =>    ~~~~~~~~~~~~~~~~~~~~~~ \n\n    | Boxed innerGift -> \n        let newGenerator innerVal =\n            let newInnerVal = fBox innerVal \n            generator newInnerVal \n        recurse innerGift newGenerator  \n//swapped =>    ~~~~~~~~~~~~~~~~~~~~~~ \n\n    | WithACard (innerGift,message) -> \n        let newGenerator innerVal =\n            let newInnerVal = fCard message innerVal \n//swapped =>                        ~~~~~~~~~~~~~~~~ \n            generator newInnerVal \n        recurse innerGift newGenerator \n//swapped =>    ~~~~~~~~~~~~~~~~~~~~~~ \n```", "```\nval foldbackGift :\n  fBook:(Book -> 'a) ->\n  fChocolate:(Chocolate -> 'a) ->\n  fWrapped:(WrappingPaperStyle -> 'a -> 'a) ->\n  fBox:('a -> 'a) ->\n  fCard:(string -> 'a -> 'a) ->\n  // input value\n  gift:Gift -> \n  // accumulator\n  generator:('a -> 'r) -> \n  // return value\n  'r \n```", "```\n// fold\nfWrapped:('a -> WrappingPaperStyle -> 'a) \n\n// foldback\nfWrapped:(WrappingPaperStyle -> 'a -> 'a) \n```", "```\naccumulatorFromHigherLevel, combined with \n  stuffFromThisLevel \n    => stuffToSendDownToNextLowerLevel \n```", "```\nvar accumulator = initialValue\nforeach level in levels do\n{\n  accumulator, combined with \n    stuffFromThisLevel \n      => update accumulator\n} \n```", "```\naccumulatorFromLowerLevel, combined with \n  stuffFromThisLevel \n    => stuffToSendUpToNextHigherLevel \n```", "```\nlet recurse (head::tail) =\n    if atBottomLevel then\n       return something\n    else    // if not at bottom level\n       let accumulatorFromLowerLevel = recurse tail\n       return stuffFromThisLevel, combined with \n          accumulatorFromLowerLevel \n```", "```\ntype FileSystemItem =\n    | File of File\n    | Directory of Directory\nand File = {name:string; fileSize:int}\nand Directory = {name:string; dirSize:int; subitems:FileSystemItem list} \n```", "```\nlet readme = File {name=\"readme.txt\"; fileSize=1}\nlet config = File {name=\"config.xml\"; fileSize=2}\nlet build  = File {name=\"build.bat\"; fileSize=3}\nlet src = Directory {name=\"src\"; dirSize=10; subitems=[readme; config; build]}\nlet bin = Directory {name=\"bin\"; dirSize=10; subitems=[]}\nlet root = Directory {name=\"root\"; dirSize=5; subitems=[src; bin]} \n```", "```\nlet rec foldFS fFile fDir acc item :'r = \n    let recurse = foldFS fFile fDir \n    match item with\n    | File file -> \n        fFile acc file\n    | Directory dir -> \n        // to do \n```", "```\n| Directory dir -> \n    let newAcc = fDir acc (dir.name,dir.dirSize) \n    // to do \n```", "```\n| Directory dir -> \n    let newAcc = fDir acc (dir.name,dir.dirSize) \n    dir.subitems |> List.fold recurse newAcc \n```", "```\nlet rec foldFS fFile fDir acc item :'r = \n    let recurse = foldFS fFile fDir \n    match item with\n    | File file -> \n        fFile acc file\n    | Directory dir -> \n        let newAcc = fDir acc (dir.name,dir.dirSize) \n        dir.subitems |> List.fold recurse newAcc \n```", "```\nlet totalSize fileSystemItem =\n    let fFile acc (file:File) = \n        acc + file.fileSize\n    let fDir acc (name,size) = \n        acc + size\n    foldFS fFile fDir 0 fileSystemItem \n```", "```\nreadme |> totalSize  // 1\nsrc |> totalSize     // 16 = 10 + (1 + 2 + 3)\nroot |> totalSize    // 31 = 5 + 16 + 10 \n```", "```\nlet fFile (largestSoFarOpt:File option) (file:File) = \n    match largestSoFarOpt with\n    | None -> \n        Some file                \n    | Some largestSoFar -> \n        if largestSoFar.fileSize > file.fileSize then\n            Some largestSoFar\n        else\n            Some file \n```", "```\nlet fDir largestSoFarOpt (name,size) = \n    largestSoFarOpt \n```", "```\nlet largestFile fileSystemItem =\n    let fFile (largestSoFarOpt:File option) (file:File) = \n        match largestSoFarOpt with\n        | None -> \n            Some file                \n        | Some largestSoFar -> \n            if largestSoFar.fileSize > file.fileSize then\n                Some largestSoFar\n            else\n                Some file\n\n    let fDir largestSoFarOpt (name,size) = \n        largestSoFarOpt\n\n    // call the fold\n    foldFS fFile fDir None fileSystemItem \n```", "```\nreadme |> largestFile  \n// Some {name = \"readme.txt\"; fileSize = 1}\n\nsrc |> largestFile     \n// Some {name = \"build.bat\"; fileSize = 3}\n\nbin |> largestFile     \n// None\n\nroot |> largestFile    \n// Some {name = \"build.bat\"; fileSize = 3} \n```", "```\nlevel1 data [combined with] level2 data [combined with] level3 data [combined with] level4 data \n```", "```\n(((level1 combineWith level2) combineWith level3) combineWith level4) \n```", "```\n(level1 combineWith (level2 combineWith (level3 combineWith level4))) \n```", "```\n| WithACard (gift,message) -> \n    fCard (recurse gift,message) \n//         ~~~~~~~  <= Call to recurse is not last expression.\n//                     Tail-recursive? No! \n```", "```\n| WithACard (innerGift,message) -> \n    let newAcc = fCard acc message \n    recurse newAcc innerGift\n//  ~~~~~~~  <= Call to recurse is last expression.\n//              Tail-recursive? Yes! \n```", "```\n| WithACard (innerGift,message) -> \n    let newGenerator innerVal =\n        let newInnerVal = fCard innerVal message \n        generator newInnerVal \n    recurse newGenerator innerGift \n//  ~~~~~~~  <= Call to recurse is last expression.\n//              Tail-recursive? Yes! \n```", "```\nforeach (var elem in collection)\n{\n    // do something\n\n    if ( x == \"error\")\n    {\n        break;\n    }\n} \n```", "```\nlet rec firstSumBiggerThan100 sumSoFar listOfInts =\n    match listOfInts with\n    | [] -> \n        sumSoFar // exhausted all the ints!\n    | head::tail -> \n        let newSumSoFar = head + sumSoFar \n        if newSumSoFar > 100 then\n            newSumSoFar \n        else\n            firstSumBiggerThan100 newSumSoFar tail\n\n// test\n[30;40;50;60] |> firstSumBiggerThan100 0  // 120\n[1..3..100] |> firstSumBiggerThan100 0  // 117 \n```", "```\nlet firstSumBiggerThan100 listOfInts =\n\n    let folder accumulator i =\n        let (ignoreFlag,sumSoFar) = accumulator\n        if not ignoreFlag then\n            let newSumSoFar = i + sumSoFar \n            let newIgnoreFlag  = newSumSoFar > 100 \n            (newIgnoreFlag, newSumSoFar)\n        else\n            // pass the accumulator along\n            accumulator \n\n    let initialAcc = (false,0)\n\n    listOfInts \n    |> List.fold folder initialAcc  // use fold\n    |> snd // get the sumSoFar\n\n/// test \n[30;40;50;60] |> firstSumBiggerThan100  // 120\n[1..3..100] |> firstSumBiggerThan100  // 117 \n```", "```\nlet firstSumBiggerThan100 listOfInts =\n    let mutable sumSoFar = 0\n    imperative { \n        for x in listOfInts do \n            sumSoFar <- x + sumSoFar \n            if sumSoFar > 100 then do! break\n    }\n    sumSoFar \n```", "```\ntype LinkedList<'a> = \n    | Empty\n    | Cons of head:'a * tail:LinkedList<'a> \n```", "```\nlet linkedList = Cons (1, Cons (2, Cons(3, Empty))) \n```", "```\nlet linkedList = 1 :: 2 :: 3 :: [] \n```", "```\nmodule LinkedList = \n\n    let rec cata fCons fEmpty list :'r=\n        let recurse = cata fCons fEmpty \n        match list with\n        | Empty -> \n            fEmpty\n        | Cons (element,list) -> \n            fCons element (recurse list) \n```", "```\nval cata : \n    fCons:('a -> 'r -> 'r) ->   \n    fEmpty:'r ->                \n    list:LinkedList<'a> \n    -> 'r \n```", "```\nmodule LinkedList = \n\n    let rec cata ...\n\n    let rec foldWithEmpty fCons fEmpty acc list :'r=\n        let recurse = foldWithEmpty fCons fEmpty \n        match list with\n        | Empty -> \n            fEmpty acc \n        | Cons (element,list) -> \n            let newAcc = fCons acc element \n            recurse newAcc list \n```", "```\nmodule LinkedList = \n\n    let rec fold fCons acc list :'r=\n        let recurse = fold fCons \n        match list with\n        | Empty -> \n            acc \n        | Cons (element,list) -> \n            let newAcc = fCons acc element \n            recurse newAcc list \n```", "```\nLinkedList.fold : ('r     -> 'a -> 'r    ) -> 'r      -> LinkedList<'a> -> 'r\nList.fold       : ('State -> 'T -> 'State) -> 'State -> 'T list         -> 'State \n```", "```\nlet linkedList = Cons (1, Cons (2, Cons(3, Empty)))  \nlinkedList |> LinkedList.fold (+) 0\n// Result => 6 \n```", "```\nmodule LinkedList = \n\n    let rec cata ...\n\n    let rec fold ...\n\n    let foldBack fCons list acc :'r=\n        let fEmpty' generator = \n            generator acc \n        let fCons' generator element= \n            fun innerResult -> \n                let newResult = fCons element innerResult \n                generator newResult \n        let initialGenerator = id\n        foldWithEmpty fCons' fEmpty' initialGenerator  list \n```", "```\nLinkedList.foldBack : ('a -> 'r     -> 'r    ) -> LinkedList<'a> -> 'r     -> 'r\nList.foldBack       : ('T -> 'State -> 'State) -> 'T list        -> 'State -> 'State \n```", "```\nmodule LinkedList = \n\n    let toList linkedList = \n        let fCons head tail = head::tail\n        let initialState = [] \n        foldBack fCons linkedList initialState \n```", "```\nmodule LinkedList = \n\n    let ofList list = \n        let fCons head tail = Cons(head,tail)\n        let initialState = Empty\n        List.foldBack fCons list initialState \n```", "```\nlet linkedList = Cons (1, Cons (2, Cons(3, Empty)))  \nlinkedList |> LinkedList.toList       \n// Result => [1; 2; 3] \n```", "```\nlet list = [1;2;3]\nlist |> LinkedList.ofList       \n// Result => Cons (1,Cons (2,Cons (3,Empty))) \n```", "```\nmodule LinkedList = \n\n    /// map a function \"f\" over all elements\n    let map f list = \n        // helper function \n        let folder head tail =\n            Cons(f head,tail)\n\n        foldBack folder list Empty \n```", "```\nlet linkedList = Cons (1, Cons (2, Cons(3, Empty)))  \n\nlinkedList |> LinkedList.map (fun i -> i+10)\n// Result => Cons (11,Cons (12,Cons (13,Empty))) \n```", "```\nmodule LinkedList = \n\n    /// return a new list of elements for which \"pred\" is true\n    let filter pred list = \n        // helper function\n        let folder head tail =\n            if pred head then \n                Cons(head,tail)\n            else\n                tail\n\n        foldBack folder list Empty \n```", "```\nlet isOdd n = (n%2=1)\nlet linkedList = Cons (1, Cons (2, Cons(3, Empty)))  \n\nlinkedList |> LinkedList.filter isOdd\n// Result => Cons (1,Cons (3,Empty)) \n```", "```\n/// reverse the elements of the list\nlet rev list = \n    // helper function\n    let folder tail head =\n        Cons(head,tail)\n\n    fold folder Empty list \n```", "```\nlet linkedList = Cons (1, Cons (2, Cons(3, Empty)))  \nlinkedList |> LinkedList.rev\n// Result => Cons (3,Cons (2,Cons (1,Empty))) \n```", "```\nlet foldBack_ViaRev fCons list acc :'r=\n    let fCons' acc element = \n        // just swap the params!\n        fCons element acc \n    list\n    |> rev\n    |> fold fCons' acc \n```", "```\ntype Gift =\n    | Book of Book\n    | Chocolate of Chocolate \n    | Wrapped of Gift * WrappingPaperStyle\n    | Boxed of Gift \n    | WithACard of Gift * message:string \n```", "```\n// unified data for non-recursive cases\ntype GiftContents = \n    | Book of Book\n    | Chocolate of Chocolate \n\n// unified data for recursive cases\ntype GiftDecoration = \n    | Wrapped of WrappingPaperStyle\n    | Boxed \n    | WithACard of string\n\ntype Gift =\n    // non-recursive case\n    | Contents of GiftContents\n    // recursive case\n    | Decoration of Gift * GiftDecoration \n```", "```\ntype Container<'ContentData,'DecorationData> =\n    | Contents of 'ContentData\n    | Decoration of 'DecorationData * Container<'ContentData,'DecorationData> \n```", "```\nmodule Container = \n\n    let rec cata fContents fDecoration (container:Container<'ContentData,'DecorationData>) :'r = \n        let recurse = cata fContents fDecoration \n        match container with\n        | Contents contentData -> \n            fContents contentData \n        | Decoration (decorationData,subContainer) -> \n            fDecoration decorationData (recurse subContainer)\n\n    (*\n    val cata :\n        // function parameters\n        fContents:('ContentData -> 'r) ->\n        fDecoration:('DecorationData -> 'r -> 'r) ->\n        // input\n        container:Container<'ContentData,'DecorationData> -> \n        // return value\n        'r\n    *)\n\n    let rec fold fContents fDecoration acc (container:Container<'ContentData,'DecorationData>) :'r = \n        let recurse = fold fContents fDecoration \n        match container with\n        | Contents contentData -> \n            fContents acc contentData \n        | Decoration (decorationData,subContainer) -> \n            let newAcc = fDecoration acc decorationData\n            recurse newAcc subContainer\n\n    (*\n    val fold :\n        // function parameters\n        fContents:('a -> 'ContentData -> 'r) ->\n        fDecoration:('a -> 'DecorationData -> 'a) ->\n        // accumulator\n        acc:'a -> \n        // input\n        container:Container<'ContentData,'DecorationData> -> \n        // return value\n        'r\n    *)\n\n    let foldBack fContents fDecoration (container:Container<'ContentData,'DecorationData>) :'r = \n        let fContents' generator contentData =\n            generator (fContents contentData)\n        let fDecoration' generator decorationData =\n            let newGenerator innerValue =\n                let newInnerValue = fDecoration decorationData innerValue \n                generator newInnerValue \n            newGenerator \n        fold fContents' fDecoration' id container\n\n    (*\n    val foldBack :\n        // function parameters\n        fContents:('ContentData -> 'r) ->\n        fDecoration:('DecorationData -> 'r -> 'r) ->\n        // input\n        container:Container<'ContentData,'DecorationData> -> \n        // return value\n        'r\n    *) \n```", "```\ntype Gift = Container<GiftContents,GiftDecoration> \n```", "```\nlet fromBook book = \n    Contents (Book book)\n\nlet fromChoc choc = \n    Contents (Chocolate choc)\n\nlet wrapInPaper paperStyle innerGift = \n    let container = Wrapped paperStyle \n    Decoration (container, innerGift)\n\nlet putInBox innerGift = \n    let container = Boxed\n    Decoration (container, innerGift)\n\nlet withCard message innerGift = \n    let container = WithACard message\n    Decoration (container, innerGift) \n```", "```\nlet wolfHall = {title=\"Wolf Hall\"; price=20m}\nlet yummyChoc = {chocType=SeventyPercent; price=5m}\n\nlet birthdayPresent = \n    wolfHall \n    |> fromBook\n    |> wrapInPaper HappyBirthday\n    |> withCard \"Happy Birthday\"\n\nlet christmasPresent = \n    yummyChoc\n    |> fromChoc\n    |> putInBox\n    |> wrapInPaper HappyHolidays \n```", "```\nlet totalCost gift =  \n\n    let fContents costSoFar contentData = \n        match contentData with\n        | Book book ->\n            costSoFar + book.price\n        | Chocolate choc ->\n            costSoFar + choc.price\n\n    let fDecoration costSoFar decorationInfo = \n        match decorationInfo with\n        | Wrapped style ->\n            costSoFar + 0.5m\n        | Boxed ->\n            costSoFar + 1.0m\n        | WithACard message ->\n            costSoFar + 2.0m\n\n    // initial accumulator\n    let initialAcc = 0m\n\n    // call the fold\n    Container.fold fContents fDecoration initialAcc gift \n```", "```\nbirthdayPresent |> totalCost \n// 22.5m\n\nchristmasPresent |> totalCost \n// 6.5m \n```", "```\nlet description gift =\n\n    let fContents contentData = \n        match contentData with\n        | Book book ->\n            sprintf \"'%s'\" book.title\n        | Chocolate choc ->\n            sprintf \"%A chocolate\" choc.chocType\n\n    let fDecoration decorationInfo innerText = \n        match decorationInfo with\n        | Wrapped style ->\n            sprintf \"%s wrapped in %A paper\" innerText style\n        | Boxed ->\n            sprintf \"%s in a box\" innerText \n        | WithACard message ->\n            sprintf \"%s with a card saying '%s'\" innerText message \n\n    // main call\n    Container.foldBack fContents fDecoration gift \n```", "```\nbirthdayPresent |> description\n// CORRECT \"'Wolf Hall' wrapped in HappyBirthday paper with a card saying 'Happy Birthday'\"\n\nchristmasPresent |> description\n// CORRECT \"SeventyPercent chocolate in a box wrapped in HappyHolidays paper\" \n```", "```\ntype Gift = {contents: GiftContents; decorations: GiftDecoration list} \n```", "```\nlet fromBook book = \n    { contents = (Book book); decorations = [] }\n\nlet fromChoc choc = \n    { contents = (Chocolate choc); decorations = [] }\n\nlet wrapInPaper paperStyle innerGift = \n    let decoration = Wrapped paperStyle \n    { innerGift with decorations = decoration::innerGift.decorations }\n\nlet putInBox innerGift = \n    let decoration = Boxed\n    { innerGift with decorations = decoration::innerGift.decorations }\n\nlet withCard message innerGift = \n    let decoration = WithACard message\n    { innerGift with decorations = decoration::innerGift.decorations } \n```", "```\nlet wolfHall = {title=\"Wolf Hall\"; price=20m}\nlet yummyChoc = {chocType=SeventyPercent; price=5m}\n\nlet birthdayPresent = \n    wolfHall \n    |> fromBook\n    |> wrapInPaper HappyBirthday\n    |> withCard \"Happy Birthday\"\n\nlet christmasPresent = \n    yummyChoc\n    |> fromChoc\n    |> putInBox\n    |> wrapInPaper HappyHolidays \n```", "```\nlet totalCost gift =  \n\n    let contentCost = \n        match gift.contents with\n        | Book book ->\n            book.price\n        | Chocolate choc ->\n            choc.price\n\n    let decorationFolder costSoFar decorationInfo = \n        match decorationInfo with\n        | Wrapped style ->\n            costSoFar + 0.5m\n        | Boxed ->\n            costSoFar + 1.0m\n        | WithACard message ->\n            costSoFar + 2.0m\n\n    let decorationCost = \n        gift.decorations |> List.fold decorationFolder 0m\n\n    // total cost\n    contentCost + decorationCost \n```", "```\nlet description gift =\n\n    let contentDescription = \n        match gift.contents with\n        | Book book ->\n            sprintf \"'%s'\" book.title\n        | Chocolate choc ->\n            sprintf \"%A chocolate\" choc.chocType\n\n    let decorationFolder decorationInfo innerText = \n        match decorationInfo with\n        | Wrapped style ->\n            sprintf \"%s wrapped in %A paper\" innerText style\n        | Boxed ->\n            sprintf \"%s in a box\" innerText \n        | WithACard message ->\n            sprintf \"%s with a card saying '%s'\" innerText message \n\n    List.foldBack decorationFolder gift.decorations contentDescription \n```", "```\ntype Gift =\n    | Book of Book\n    | Chocolate of Chocolate \n    | Wrapped of Gift * WrappingPaperStyle\n    | Boxed of Gift \n    | WithACard of Gift * message:string \n```", "```\ntype Container<'ContentData,'DecorationData> =\n    | Contents of 'ContentData\n    | Decoration of 'DecorationData * Container<'ContentData,'DecorationData> \n\ntype GiftContents = \n    | Book of Book\n    | Chocolate of Chocolate \n\ntype GiftDecoration = \n    | Wrapped of WrappingPaperStyle\n    | Boxed \n    | WithACard of string\n\ntype Gift = Container<GiftContents,GiftDecoration> \n```", "```\ntype GiftContents = \n    | Book of Book\n    | Chocolate of Chocolate \n\ntype GiftDecoration = \n    | Wrapped of WrappingPaperStyle\n    | Boxed \n    | WithACard of string\n\ntype Gift = {contents: GiftContents; decorations: GiftDecoration list} \n```", "```\ntype FileSystemItem =\n    | File of FileInfo\n    | Directory of DirectoryInfo\nand FileInfo = {name:string; fileSize:int}\nand DirectoryInfo = {name:string; dirSize:int; subitems:FileSystemItem list} \n```", "```\ntype Tree<'LeafData,'INodeData> =\n    | LeafNode of 'LeafData\n    | InternalNode of 'INodeData * Tree<'LeafData,'INodeData> seq \n```", "```\ntype FileInfo = {name:string; fileSize:int}\ntype DirectoryInfo = {name:string; dirSize:int}\n\ntype FileSystemItem = Tree<FileInfo,DirectoryInfo> \n```", "```\nmodule Tree = \n\n    let rec cata fLeaf fNode (tree:Tree<'LeafData,'INodeData>) :'r = \n        let recurse = cata fLeaf fNode  \n        match tree with\n        | LeafNode leafInfo -> \n            fLeaf leafInfo \n        | InternalNode (nodeInfo,subtrees) -> \n            fNode nodeInfo (subtrees |> Seq.map recurse)\n\n    let rec fold fLeaf fNode acc (tree:Tree<'LeafData,'INodeData>) :'r = \n        let recurse = fold fLeaf fNode  \n        match tree with\n        | LeafNode leafInfo -> \n            fLeaf acc leafInfo \n        | InternalNode (nodeInfo,subtrees) -> \n            // determine the local accumulator at this level\n            let localAccum = fNode acc nodeInfo\n            // thread the local accumulator through all the subitems using Seq.fold\n            let finalAccum = subtrees |> Seq.fold recurse localAccum \n            // ... and return it\n            finalAccum \n```", "```\nlet fromFile (fileInfo:FileInfo) = \n    LeafNode fileInfo \n\nlet fromDir (dirInfo:DirectoryInfo) subitems = \n    InternalNode (dirInfo,subitems)\n\nlet readme = fromFile {name=\"readme.txt\"; fileSize=1}\nlet config = fromFile {name=\"config.xml\"; fileSize=2}\nlet build  = fromFile {name=\"build.bat\"; fileSize=3}\nlet src = fromDir {name=\"src\"; dirSize=10} [readme; config; build]\nlet bin = fromDir {name=\"bin\"; dirSize=10} []\nlet root = fromDir {name=\"root\"; dirSize=5} [src; bin] \n```", "```\nlet totalSize fileSystemItem =\n    let fFile acc (file:FileInfo) = \n        acc + file.fileSize\n    let fDir acc (dir:DirectoryInfo)= \n        acc + dir.dirSize\n    Tree.fold fFile fDir 0 fileSystemItem \n\nreadme |> totalSize  // 1\nsrc |> totalSize     // 16 = 10 + (1 + 2 + 3)\nroot |> totalSize    // 31 = 5 + 16 + 10 \n```", "```\nlet largestFile fileSystemItem =\n    let fFile (largestSoFarOpt:FileInfo option) (file:FileInfo) = \n        match largestSoFarOpt with\n        | None -> \n            Some file                \n        | Some largestSoFar -> \n            if largestSoFar.fileSize > file.fileSize then\n                Some largestSoFar\n            else\n                Some file\n\n    let fDir largestSoFarOpt dirInfo = \n        largestSoFarOpt\n\n    // call the fold\n    Tree.fold fFile fDir None fileSystemItem\n\nreadme |> largestFile  \n// Some {name = \"readme.txt\"; fileSize = 1}\n\nsrc |> largestFile     \n// Some {name = \"build.bat\"; fileSize = 3}\n\nbin |> largestFile     \n// None\n\nroot |> largestFile    \n// Some {name = \"build.bat\"; fileSize = 3} \n```", "```\nopen System\nopen System.IO\n\ntype FileSystemTree = Tree<IO.FileInfo,IO.DirectoryInfo> \n```", "```\nlet fromFile (fileInfo:FileInfo) = \n    LeafNode fileInfo \n\nlet rec fromDir (dirInfo:DirectoryInfo) = \n    let subItems = seq{\n        yield! dirInfo.EnumerateFiles() |> Seq.map fromFile\n        yield! dirInfo.EnumerateDirectories() |> Seq.map fromDir\n        }\n    InternalNode (dirInfo,subItems) \n```", "```\nlet totalSize fileSystemItem =\n    let fFile acc (file:FileInfo) = \n        acc + file.Length\n    let fDir acc (dir:DirectoryInfo)= \n        acc \n    Tree.fold fFile fDir 0L fileSystemItem \n```", "```\n// set the current directory to the current source directory\nDirectory.SetCurrentDirectory __SOURCE_DIRECTORY__\n\n// get the current directory as a Tree\nlet currentDir = fromDir (DirectoryInfo(\".\"))\n\n// get the size of the current directory \ncurrentDir  |> totalSize \n```", "```\nlet largestFile fileSystemItem =\n    let fFile (largestSoFarOpt:FileInfo option) (file:FileInfo) = \n        match largestSoFarOpt with\n        | None -> \n            Some file                \n        | Some largestSoFar -> \n            if largestSoFar.Length > file.Length then\n                Some largestSoFar\n            else\n                Some file\n\n    let fDir largestSoFarOpt dirInfo = \n        largestSoFarOpt\n\n    // call the fold\n    Tree.fold fFile fDir None fileSystemItem\n\ncurrentDir |> largestFile \n```", "```\nmodule Tree = \n\n    let rec cata ...\n\n    let rec fold ...\n\n    let rec map fLeaf fNode (tree:Tree<'LeafData,'INodeData>) = \n        let recurse = map fLeaf fNode  \n        match tree with\n        | LeafNode leafInfo -> \n            let newLeafInfo = fLeaf leafInfo\n            LeafNode newLeafInfo \n        | InternalNode (nodeInfo,subtrees) -> \n            let newNodeInfo = fNode nodeInfo\n            let newSubtrees = subtrees |> Seq.map recurse \n            InternalNode (newNodeInfo, newSubtrees) \n```", "```\nval map :\n  fLeaf:('LeafData -> 'a) ->\n  fNode:('INodeData -> 'b) ->\n  tree:Tree<'LeafData,'INodeData> -> \n  Tree<'a,'b> \n```", "```\nmodule Tree = \n\n    let rec map ...\n\n    let rec iter fLeaf fNode (tree:Tree<'LeafData,'INodeData>) = \n        let recurse = iter fLeaf fNode  \n        match tree with\n        | LeafNode leafInfo -> \n            fLeaf leafInfo\n        | InternalNode (nodeInfo,subtrees) -> \n            subtrees |> Seq.iter recurse \n            fNode nodeInfo \n```", "```\nlet dirListing fileSystemItem =\n    let printDate (d:DateTime) = d.ToString()\n    let mapFile (fi:FileInfo) = \n        sprintf \"%10i  %s  %-s\"  fi.Length (printDate fi.LastWriteTime) fi.Name\n    let mapDir (di:DirectoryInfo) = \n        di.FullName \n    Tree.map mapFile mapDir fileSystemItem \n```", "```\ncurrentDir \n|> dirListing \n|> Tree.iter (printfn \"%s\") (printfn \"\\n%s\") \n```", "```\n 8315  10/08/2015 23:37:41  Fold.fsx\n  3680  11/08/2015 23:59:01  FoldAndRecursiveTypes.fsproj\n  1010  11/08/2015 01:19:07  FoldAndRecursiveTypes.sln\n  1107  11/08/2015 23:59:01  HtmlDom.fsx\n    79  11/08/2015 01:21:54  LinkedList.fsx \n```", "```\n/// Fold over the lines in a file asynchronously\n/// passing in the current line and line number tothe folder function.\n///\n/// Signature:\n///   folder:('a -> int -> string -> 'a) -> \n///   acc:'a -> \n///   fi:FileInfo -> \n///   Async<'a>\nlet foldLinesAsync folder acc (fi:FileInfo) = \n    async {\n        let mutable acc = acc\n        let mutable lineNo = 1\n        use sr = new StreamReader(path=fi.FullName)\n        while not sr.EndOfStream do\n            let! lineText = sr.ReadLineAsync() |> Async.AwaitTask\n            acc <- folder acc lineNo lineText \n            lineNo <- lineNo + 1\n        return acc\n    } \n```", "```\nlet asyncMap f asyncX = async { \n    let! x = asyncX\n    return (f x)  } \n```", "```\n/// return the matching lines in a file, as an async<string list>\nlet matchPattern textPattern (fi:FileInfo) = \n    // set up the regex\n    let regex = Text.RegularExpressions.Regex(pattern=textPattern)\n\n    // set up the function to use with \"fold\"\n    let folder results lineNo lineText =\n        if regex.IsMatch lineText then\n            let result = sprintf \"%40s:%-5i   %s\" fi.Name lineNo lineText\n            result :: results\n        else\n            // pass through\n            results\n\n    // main flow\n    fi\n    |> foldLinesAsync folder []\n    // the fold output is in reverse order, so reverse it\n    |> asyncMap List.rev \n```", "```\nlet grep filePattern textPattern fileSystemItem =\n    let regex = Text.RegularExpressions.Regex(pattern=filePattern)\n\n    /// if the file matches the pattern\n    /// do the matching and return Some async, else None\n    let matchFile (fi:FileInfo) =\n        if regex.IsMatch fi.Name then\n            Some (matchPattern textPattern fi)\n        else\n            None\n\n    /// process a file by adding its async to the list\n    let fFile asyncs (fi:FileInfo) = \n        // add to the list of asyncs\n        (matchFile fi) :: asyncs \n\n    // for directories, just pass through the list of asyncs\n    let fDir asyncs (di:DirectoryInfo)  = \n        asyncs \n\n    fileSystemItem\n    |> Tree.fold fFile fDir []    // get the list of asyncs\n    |> Seq.choose id              // choose the Somes (where a file was processed)\n    |> Async.Parallel             // merge all asyncs into a single async\n    |> asyncMap (Array.toList >> List.collect id)  // flatten array of lists into a single list \n```", "```\ncurrentDir \n|> grep \"fsx\" \"LinkedList\" \n|> Async.RunSynchronously \n```", "```\n\"                  SizeOfTypes.fsx:120     type LinkedList<'a> = \";\n\"                  SizeOfTypes.fsx:122         | Cell of head:'a * tail:LinkedList<'a>\";\n\"                  SizeOfTypes.fsx:125     let S = size(LinkedList<'a>)\";\n\"      RecursiveTypesAndFold-3.fsx:15      // LinkedList\";\n\"      RecursiveTypesAndFold-3.fsx:18      type LinkedList<'a> = \";\n\"      RecursiveTypesAndFold-3.fsx:20          | Cons of head:'a * tail:LinkedList<'a>\";\n\"      RecursiveTypesAndFold-3.fsx:26      module LinkedList = \";\n\"      RecursiveTypesAndFold-3.fsx:39              list:LinkedList<'a> \";\n\"      RecursiveTypesAndFold-3.fsx:64              list:LinkedList<'a> -> \"; \n```", "```\nCREATE TABLE DbDir (\n    DirId int IDENTITY NOT NULL,\n    Name nvarchar(50) NOT NULL\n)\n\nCREATE TABLE DbFile (\n    FileId int IDENTITY NOT NULL,\n    Name nvarchar(50) NOT NULL,\n    FileSize int NOT NULL\n)\n\nCREATE TABLE DbDir_File (\n    DirId int NOT NULL,\n    FileId int NOT NULL\n)\n\nCREATE TABLE DbDir_Dir (\n    ParentDirId int NOT NULL,\n    ChildDirId int NOT NULL\n) \n```", "```\n/// Insert a DbFile record \nlet insertDbFile name (fileSize:int64) =\n    let id = nextIdentity()\n    printfn \"%10s: inserting id:%i name:%s size:%i\" \"DbFile\" id name fileSize \n```", "```\nlet nextIdentity =\n    let id = ref 0\n    fun () -> \n        id := !id + 1\n        !id\n\n// test\nnextIdentity() // 1\nnextIdentity() // 2\nnextIdentity() // 3 \n```", "```\n/// Insert a DbFile record and return the new file id\nlet insertDbFile name (fileSize:int64) =\n    let id = nextIdentity()\n    printfn \"%10s: inserting id:%i name:%s size:%i\" \"DbFile\" id name fileSize\n    id \n```", "```\n/// Insert a DbDir record and return the new directory id\nlet insertDbDir name =\n    let id = nextIdentity()\n    printfn \"%10s: inserting id:%i name:%s\" \"DbDir\" id name\n    id \n```", "```\ntype PrimaryKey =\n    | FileId of int\n    | DirId of int \n```", "```\n/// Insert a DbFile record and return the new PrimaryKey\nlet insertDbFile name (fileSize:int64) =\n    let id = nextIdentity()\n    printfn \"%10s: inserting id:%i name:%s size:%i\" \"DbFile\" id name fileSize\n    FileId id\n\n/// Insert a DbDir record and return the new PrimaryKey\nlet insertDbDir name =\n    let id = nextIdentity()\n    printfn \"%10s: inserting id:%i name:%s\" \"DbDir\" id name\n    DirId id\n\n/// Insert a DbDir_File record\nlet insertDbDir_File dirId fileId =\n    printfn \"%10s: inserting parentDir:%i childFile:%i\" \"DbDir_File\" dirId fileId \n\n/// Insert a DbDir_Dir record\nlet insertDbDir_Dir parentDirId childDirId =\n    printfn \"%10s: inserting parentDir:%i childDir:%i\" \"DbDir_Dir\" parentDirId childDirId \n```", "```\nlet fFile (fi:FileInfo) = \n    insertDbFile fi.Name fi.Length \n```", "```\nlet fDir (di:DirectoryInfo) childIds  = \n    let dirId = insertDbDir di.Name\n    // insert the children\n    // return the id to the parent\n    dirId \n```", "```\nlet fDir (di:DirectoryInfo) childIds  = \n    let dirId = insertDbDir di.Name\n    let parentPK = pkToInt dirId \n    childIds |> Seq.iter (fun childId ->\n        match childId with\n        | FileId fileId -> insertDbDir_File parentPK fileId \n        | DirId childDirId -> insertDbDir_Dir parentPK childDirId \n    )\n    // return the id to the parent\n    dirId \n```", "```\nopen System\nopen System.IO\n\nlet nextIdentity =\n    let id = ref 0\n    fun () -> \n        id := !id + 1\n        !id\n\ntype PrimaryKey =\n    | FileId of int\n    | DirId of int\n\n/// Insert a DbFile record and return the new PrimaryKey\nlet insertDbFile name (fileSize:int64) =\n    let id = nextIdentity()\n    printfn \"%10s: inserting id:%i name:%s size:%i\" \"DbFile\" id name fileSize\n    FileId id\n\n/// Insert a DbDir record and return the new PrimaryKey\nlet insertDbDir name =\n    let id = nextIdentity()\n    printfn \"%10s: inserting id:%i name:%s\" \"DbDir\" id name\n    DirId id\n\n/// Insert a DbDir_File record\nlet insertDbDir_File dirId fileId =\n    printfn \"%10s: inserting parentDir:%i childFile:%i\" \"DbDir_File\" dirId fileId \n\n/// Insert a DbDir_Dir record\nlet insertDbDir_Dir parentDirId childDirId =\n    printfn \"%10s: inserting parentDir:%i childDir:%i\" \"DbDir_Dir\" parentDirId childDirId\n\nlet pkToInt primaryKey = \n    match primaryKey with\n    | FileId fileId -> fileId \n    | DirId dirId -> dirId \n\nlet insertFileSystemTree fileSystemItem =\n\n    let fFile (fi:FileInfo) = \n        insertDbFile fi.Name fi.Length\n\n    let fDir (di:DirectoryInfo) childIds  = \n        let dirId = insertDbDir di.Name\n        let parentPK = pkToInt dirId \n        childIds |> Seq.iter (fun childId ->\n            match childId with\n            | FileId fileId -> insertDbDir_File parentPK fileId \n            | DirId childDirId -> insertDbDir_Dir parentPK childDirId \n        )\n        // return the id to the parent\n        dirId\n\n    fileSystemItem\n    |> Tree.cata fFile fDir \n```", "```\n// get the current directory as a Tree\nlet currentDir = fromDir (DirectoryInfo(\".\"))\n\n// insert into the database\ncurrentDir \n|> insertFileSystemTree \n```", "```\n DbDir: inserting id:41 name:FoldAndRecursiveTypes\n    DbFile: inserting id:42 name:Fold.fsx size:8315\nDbDir_File: inserting parentDir:41 childFile:42\n    DbFile: inserting id:43 name:FoldAndRecursiveTypes.fsproj size:3680\nDbDir_File: inserting parentDir:41 childFile:43\n    DbFile: inserting id:44 name:FoldAndRecursiveTypes.sln size:1010\nDbDir_File: inserting parentDir:41 childFile:44\n...\n     DbDir: inserting id:57 name:bin\n     DbDir: inserting id:58 name:Debug\n DbDir_Dir: inserting parentDir:57 childDir:58\n DbDir_Dir: inserting parentDir:41 childDir:57 \n```", "```\ntype Book = {title: string; price: decimal}\ntype ChocolateType = Dark | Milk | SeventyPercent\ntype Chocolate = {chocType: ChocolateType ; price: decimal}\n\ntype WrappingPaperStyle = \n    | HappyBirthday\n    | HappyHolidays\n    | SolidColor\n\n// unified data for non-recursive cases\ntype GiftContents = \n    | Book of Book\n    | Chocolate of Chocolate \n\n// unified data for recursive cases\ntype GiftDecoration = \n    | Wrapped of WrappingPaperStyle\n    | Boxed \n    | WithACard of string\n\ntype Gift = Tree<GiftContents,GiftDecoration> \n```", "```\nlet fromBook book = \n    LeafNode (Book book)\n\nlet fromChoc choc = \n    LeafNode (Chocolate choc)\n\nlet wrapInPaper paperStyle innerGift = \n    let container = Wrapped paperStyle \n    InternalNode (container, [innerGift])\n\nlet putInBox innerGift = \n    let container = Boxed\n    InternalNode (container, [innerGift])\n\nlet withCard message innerGift = \n    let container = WithACard message\n    InternalNode (container, [innerGift])\n\nlet putTwoThingsInBox innerGift innerGift2 = \n    let container = Boxed\n    InternalNode (container, [innerGift;innerGift2]) \n```", "```\nlet wolfHall = {title=\"Wolf Hall\"; price=20m}\nlet yummyChoc = {chocType=SeventyPercent; price=5m}\n\nlet birthdayPresent = \n    wolfHall \n    |> fromBook\n    |> wrapInPaper HappyBirthday\n    |> withCard \"Happy Birthday\"\n\nlet christmasPresent = \n    yummyChoc\n    |> fromChoc\n    |> putInBox\n    |> wrapInPaper HappyHolidays\n\nlet twoBirthdayPresents = \n    let thing1 = wolfHall |> fromBook \n    let thing2 = yummyChoc |> fromChoc\n    putTwoThingsInBox thing1 thing2 \n    |> wrapInPaper HappyBirthday\n\nlet twoWrappedPresentsInBox = \n    let thing1 = wolfHall |> fromBook |> wrapInPaper HappyHolidays\n    let thing2 = yummyChoc |> fromChoc  |> wrapInPaper HappyBirthday\n    putTwoThingsInBox thing1 thing2 \n```", "```\nlet description gift =\n\n    let fLeaf leafData = \n        match leafData with\n        | Book book ->\n            sprintf \"'%s'\" book.title\n        | Chocolate choc ->\n            sprintf \"%A chocolate\" choc.chocType\n\n    let fNode nodeData innerTexts = \n        let innerText = String.concat \" & \" innerTexts \n        match nodeData with\n        | Wrapped style ->\n            sprintf \"%s wrapped in %A paper\" innerText style\n        | Boxed ->\n            sprintf \"%s in a box\" innerText\n        | WithACard message ->\n            sprintf \"%s with a card saying '%s'\" innerText message \n\n    // main call\n    Tree.cata fLeaf fNode gift \n```", "```\nbirthdayPresent |> description\n// \"'Wolf Hall' wrapped in HappyBirthday paper with a card saying 'Happy Birthday'\"\n\nchristmasPresent |> description\n// \"SeventyPercent chocolate in a box wrapped in HappyHolidays paper\"\n\ntwoBirthdayPresents |> description\n// \"'Wolf Hall' & SeventyPercent chocolate in a box \n//   wrapped in HappyBirthday paper\"\n\ntwoWrappedPresentsInBox |> description\n// \"'Wolf Hall' wrapped in HappyHolidays paper \n//   & SeventyPercent chocolate wrapped in HappyBirthday paper \n//   in a box\" \n```", "```\n[<CLIMutableAttribute>]\ntype GiftContentsDto = {\n    discriminator : string // \"Book\" or \"Chocolate\"\n    // for \"Book\" case only\n    bookTitle: string    \n    // for \"Chocolate\" case only\n    chocolateType : string // one of \"Dark\" \"Milk\" \"SeventyPercent\"\n    // for all cases\n    price: decimal\n    } \n```", "```\n[<CLIMutableAttribute>]\ntype GiftDecorationDto = {\n    discriminator: string // \"Wrapped\" or \"Boxed\" or \"WithACard\"\n    // for \"Wrapped\" case only\n    wrappingPaperStyle: string  // \"HappyBirthday\" or \"HappyHolidays\" or \"SolidColor\" \n    // for \"WithACard\" case only\n    message: string  \n    } \n```", "```\ntype GiftDto = Tree<GiftContentsDto,GiftDecorationDto> \n```", "```\nlet giftToDto (gift:Gift) :GiftDto =\n\n    let fLeaf leafData :GiftContentsDto = \n        match leafData with\n        | Book book ->\n            {discriminator= \"Book\"; bookTitle=book.title; chocolateType=null; price=book.price}\n        | Chocolate choc ->\n            let chocolateType = sprintf \"%A\" choc.chocType\n            {discriminator= \"Chocolate\"; bookTitle=null; chocolateType=chocolateType; price=choc.price}\n\n    let fNode nodeData :GiftDecorationDto = \n        match nodeData with\n        | Wrapped style ->\n            let wrappingPaperStyle = sprintf \"%A\" style\n            {discriminator= \"Wrapped\"; wrappingPaperStyle=wrappingPaperStyle; message=null}\n        | Boxed ->\n            {discriminator= \"Boxed\"; wrappingPaperStyle=null; message=null}\n        | WithACard message ->\n            {discriminator= \"WithACard\"; wrappingPaperStyle=null; message=message}\n\n    // main call\n    Tree.map fLeaf fNode gift \n```", "```\n/// A DTO that represents a Tree\n/// The Leaf/Node choice is turned into a record\n[<CLIMutableAttribute>]\ntype TreeDto<'LeafData,'NodeData> = {\n    leafData : 'LeafData\n    nodeData : 'NodeData\n    subtrees : TreeDto<'LeafData,'NodeData>[] } \n```", "```\n/// Transform a Tree into a TreeDto\nlet treeToDto tree : TreeDto<'LeafData,'NodeData> =\n\n    let fLeaf leafData  = \n        let nodeData = Unchecked.defaultof<'NodeData>\n        let subtrees = [||]\n        {leafData=leafData; nodeData=nodeData; subtrees=subtrees}\n\n    let fNode nodeData subtrees = \n        let leafData = Unchecked.defaultof<'NodeData>\n        let subtrees = subtrees |> Seq.toArray \n        {leafData=leafData; nodeData=nodeData; subtrees=subtrees}\n\n    // recurse to build up the TreeDto\n    Tree.cata fLeaf fNode tree \n```", "```\n#r \"System.Runtime.Serialization.dll\"\n\nopen System.Runtime.Serialization\nopen System.Runtime.Serialization.Json\n\nlet toJson (o:'a) = \n    let serializer = new DataContractJsonSerializer(typeof<'a>)\n    let encoding = System.Text.UTF8Encoding()\n    use stream = new System.IO.MemoryStream()\n    serializer.WriteObject(stream,o) \n    stream.Close()\n    encoding.GetString(stream.ToArray()) \n```", "```\nlet goodJson = christmasPresent |> giftToDto |> treeToDto |> toJson \n```", "```\n{\n  \"leafData@\": null,\n  \"nodeData@\": {\n    \"discriminator@\": \"Wrapped\",\n    \"message@\": null,\n    \"wrappingPaperStyle@\": \"HappyHolidays\"\n  },\n  \"subtrees@\": [\n    {\n      \"leafData@\": null,\n      \"nodeData@\": {\n        \"discriminator@\": \"Boxed\",\n        \"message@\": null,\n        \"wrappingPaperStyle@\": null\n      },\n      \"subtrees@\": [\n        {\n          \"leafData@\": {\n            \"bookTitle@\": null,\n            \"chocolateType@\": \"SeventyPercent\",\n            \"discriminator@\": \"Chocolate\",\n            \"price@\": 5\n          },\n          \"nodeData@\": null,\n          \"subtrees@\": []\n        }\n      ]\n    }\n  ]\n} \n```", "```\nlet fromJson<'a> str = \n    let serializer = new DataContractJsonSerializer(typeof<'a>)\n    let encoding = System.Text.UTF8Encoding()\n    use stream = new System.IO.MemoryStream(encoding.GetBytes(s=str))\n    let obj = serializer.ReadObject(stream) \n    obj :?> 'a \n```", "```\nlet rec dtoToTree (treeDto:TreeDto<'Leaf,'Node>) :Tree<'Leaf,'Node> =\n    let nullLeaf = Unchecked.defaultof<'Leaf>\n    let nullNode = Unchecked.defaultof<'Node>\n\n    // check if there is nodeData present\n    if treeDto.nodeData <> nullNode then\n        if treeDto.subtrees = null then\n            failwith \"subtrees must not be null if node data present\"\n        else\n            let subtrees = treeDto.subtrees |> Array.map dtoToTree \n            InternalNode (treeDto.nodeData,subtrees)\n    // check if there is leafData present\n    elif treeDto.leafData <> nullLeaf then\n        LeafNode (treeDto.leafData) \n    // if both missing then fail\n    else\n        failwith \"expecting leaf or node data\" \n```", "```\nlet strToBookTitle str =\n    match str with\n    | null -> failwith \"BookTitle must not be null\" \n    | _ -> str\n\nlet strToChocolateType str =\n    match str with\n    | \"Dark\" -> Dark\n    | \"Milk\" -> Milk\n    | \"SeventyPercent\" -> SeventyPercent\n    | _ -> failwithf \"ChocolateType %s not recognized\" str\n\nlet strToWrappingPaperStyle str =\n    match str with\n    | \"HappyBirthday\" -> HappyBirthday\n    | \"HappyHolidays\" -> HappyHolidays\n    | \"SolidColor\" -> SolidColor\n    | _ -> failwithf \"WrappingPaperStyle %s not recognized\" str\n\nlet strToCardMessage str =\n    match str with\n    | null -> failwith \"CardMessage must not be null\" \n    | _ -> str\n\nlet bookFromDto (dto:GiftContentsDto) =\n    let bookTitle = strToBookTitle dto.bookTitle\n    Book {title=bookTitle; price=dto.price}\n\nlet chocolateFromDto (dto:GiftContentsDto) =\n    let chocType = strToChocolateType dto.chocolateType \n    Chocolate {chocType=chocType; price=dto.price}\n\nlet wrappedFromDto (dto:GiftDecorationDto) =\n    let wrappingPaperStyle = strToWrappingPaperStyle dto.wrappingPaperStyle\n    Wrapped wrappingPaperStyle \n\nlet boxedFromDto (dto:GiftDecorationDto) =\n    Boxed\n\nlet withACardFromDto (dto:GiftDecorationDto) =\n    let message = strToCardMessage dto.message\n    WithACard message \n\n/// Transform a GiftDto to a Gift\nlet dtoToGift (giftDto:GiftDto) :Gift=\n\n    let fLeaf (leafDto:GiftContentsDto) = \n        match leafDto.discriminator with\n        | \"Book\" -> bookFromDto leafDto\n        | \"Chocolate\" -> chocolateFromDto leafDto\n        | _ -> failwithf \"Unknown leaf discriminator '%s'\" leafDto.discriminator \n\n    let fNode (nodeDto:GiftDecorationDto)  = \n        match nodeDto.discriminator with\n        | \"Wrapped\" -> wrappedFromDto nodeDto\n        | \"Boxed\" -> boxedFromDto nodeDto\n        | \"WithACard\" -> withACardFromDto nodeDto\n        | _ -> failwithf \"Unknown node discriminator '%s'\" nodeDto.discriminator \n\n    // map the tree\n    Tree.map fLeaf fNode giftDto \n```", "```\nlet goodGift = goodJson |> fromJson |> dtoToTree |> dtoToGift\n\n// check that the description is unchanged\ngoodGift |> description\n// \"SeventyPercent chocolate in a box wrapped in HappyHolidays paper\" \n```", "```\nlet badJson1 = goodJson.Replace(\"leafData\",\"leafDataXX\")\n\nlet badJson1_result = badJson1 |> fromJson |> dtoToTree |> dtoToGift\n// Exception \"The data contract type 'TreeDto' cannot be deserialized because the required data member 'leafData@' was not found.\" \n```", "```\nlet badJson2 = goodJson.Replace(\"Wrapped\",\"Wrapped2\")\n\nlet badJson2_result = badJson2 |> fromJson |> dtoToTree |> dtoToGift\n// Exception \"Unknown node discriminator 'Wrapped2'\" \n```", "```\nlet badJson3 = goodJson.Replace(\"HappyHolidays\",\"HappyHolidays2\")\nlet badJson3_result = badJson3 |> fromJson |> dtoToTree |> dtoToGift\n// Exception \"WrappingPaperStyle HappyHolidays2 not recognized\" \n```", "```\ntype Result<'a> = \n    | Success of 'a\n    | Failure of string list \n```", "```\nlet fromJson<'a> str = \n    try\n        let serializer = new DataContractJsonSerializer(typeof<'a>)\n        let encoding = System.Text.UTF8Encoding()\n        use stream = new System.IO.MemoryStream(encoding.GetBytes(s=str))\n        let obj = serializer.ReadObject(stream) \n        obj :?> 'a \n        |> Result.retn\n    with\n    | ex -> \n        Result.failWithMsg ex.Message \n```", "```\nlet rec dtoToTreeOfResults (treeDto:TreeDto<'Leaf,'Node>) :Tree<Result<'Leaf>,Result<'Node>> =\n    let nullLeaf = Unchecked.defaultof<'Leaf>\n    let nullNode = Unchecked.defaultof<'Node>\n\n    // check if there is nodeData present\n    if treeDto.nodeData <> nullNode then\n        if treeDto.subtrees = null then\n            LeafNode <| Result.failWithMsg \"subtrees must not be null if node data present\"\n        else\n            let subtrees = treeDto.subtrees |> Array.map dtoToTreeOfResults \n            InternalNode (Result.retn treeDto.nodeData,subtrees) \n    // check if there is leafData present\n    elif treeDto.leafData <> nullLeaf then\n        LeafNode <| Result.retn (treeDto.leafData) \n    // if both missing then fail\n    else\n        LeafNode <| Result.failWithMsg \"expecting leaf or node data\"\n\n// val dtoToTreeOfResults : \n//   treeDto:TreeDto<'Leaf,'Node> -> Tree<Result<'Leaf>,Result<'Node>> \n```", "```\n/// Convert a tree of Results into a Result of tree\nlet sequenceTreeOfResult tree =\n    // from the lower level\n    let (<*>) = Result.apply \n    let retn = Result.retn\n\n    // from the traversable level\n    let fLeaf data = \n        retn LeafNode <*> data\n\n    let fNode data subitems = \n        let makeNode data items = InternalNode(data,items)\n        let subItems = Result.sequenceSeq subitems \n        retn makeNode <*> data <*> subItems\n\n    // do the traverse\n    Tree.cata fLeaf fNode tree\n\n// val sequenceTreeOfResult :\n//    tree:Tree<Result<'a>,Result<'b>> -> Result<Tree<'a,'b>> \n```", "```\nlet dtoToTree treeDto =\n    treeDto |> dtoToTreeOfResults |> sequenceTreeOfResult \n\n// val dtoToTree : treeDto:TreeDto<'a,'b> -> Result<Tree<'a,'b>> \n```", "```\nlet strToBookTitle str =\n    match str with\n    | null -> Result.failWithMsg \"BookTitle must not be null\"\n    | _ -> Result.retn str\n\nlet strToChocolateType str =\n    match str with\n    | \"Dark\" -> Result.retn Dark\n    | \"Milk\" -> Result.retn Milk\n    | \"SeventyPercent\" -> Result.retn SeventyPercent\n    | _ -> Result.failWithMsg (sprintf \"ChocolateType %s not recognized\" str)\n\nlet strToWrappingPaperStyle str =\n    match str with\n    | \"HappyBirthday\" -> Result.retn HappyBirthday\n    | \"HappyHolidays\" -> Result.retn HappyHolidays\n    | \"SolidColor\" -> Result.retn SolidColor\n    | _ -> Result.failWithMsg (sprintf \"WrappingPaperStyle %s not recognized\" str)\n\nlet strToCardMessage str =\n    match str with\n    | null -> Result.failWithMsg \"CardMessage must not be null\" \n    | _ -> Result.retn str \n```", "```\nlet bookFromDto (dto:GiftContentsDto) =\n    let book bookTitle price = \n        Book {title=bookTitle; price=price}\n\n    let bookTitle = strToBookTitle dto.bookTitle\n    let price = Result.retn dto.price\n    Result.lift2 book bookTitle price \n\nlet chocolateFromDto (dto:GiftContentsDto) =\n    let choc chocType price = \n        Chocolate {chocType=chocType; price=price}\n\n    let chocType = strToChocolateType dto.chocolateType \n    let price = Result.retn dto.price\n    Result.lift2 choc chocType price \n\nlet wrappedFromDto (dto:GiftDecorationDto) =\n    let wrappingPaperStyle = strToWrappingPaperStyle dto.wrappingPaperStyle\n    Result.map Wrapped wrappingPaperStyle \n\nlet boxedFromDto (dto:GiftDecorationDto) =\n    Result.retn Boxed\n\nlet withACardFromDto (dto:GiftDecorationDto) =\n    let message = strToCardMessage dto.message\n    Result.map WithACard message \n```", "```\n`Tree.map fLeaf fNode giftDto |> sequenceTreeOfResult` \n```", "```\nopen TreeDto_WithErrorHandling\n\n/// Transform a GiftDto to a Result<Gift>\nlet dtoToGift (giftDto:GiftDto) :Result<Gift>=\n\n    let fLeaf (leafDto:GiftContentsDto) = \n        match leafDto.discriminator with\n        | \"Book\" -> bookFromDto leafDto\n        | \"Chocolate\" -> chocolateFromDto leafDto\n        | _ -> Result.failWithMsg (sprintf \"Unknown leaf discriminator '%s'\" leafDto.discriminator) \n\n    let fNode (nodeDto:GiftDecorationDto)  = \n        match nodeDto.discriminator with\n        | \"Wrapped\" -> wrappedFromDto nodeDto\n        | \"Boxed\" -> boxedFromDto nodeDto\n        | \"WithACard\" -> withACardFromDto nodeDto\n        | _ -> Result.failWithMsg (sprintf \"Unknown node discriminator '%s'\" nodeDto.discriminator)\n\n    // map the tree\n    Tree.map fLeaf fNode giftDto |> sequenceTreeOfResult \n```", "```\n// val dtoToGift : GiftDto -> Result<GiftUsingTree.Gift> \n```", "```\nlet goodGift = goodJson |> fromJson |> Result.bind dtoToTree |> Result.bind dtoToGift\n\n// check that the description is unchanged\ngoodGift |> description\n// Success \"SeventyPercent chocolate in a box wrapped in HappyHolidays paper\" \n```", "```\nlet badJson1 = goodJson.Replace(\"leafData\",\"leafDataXX\")\n\nlet badJson1_result = badJson1 |> fromJson |> Result.bind dtoToTree |> Result.bind dtoToGift\n// Failure [\"The data contract type 'TreeDto' cannot be deserialized because the required data member 'leafData@' was not found.\"] \n```", "```\nlet badJson2 = goodJson.Replace(\"Wrapped\",\"Wrapped2\")\nlet badJson2_result = badJson2 |> fromJson |> Result.bind dtoToTree |> Result.bind dtoToGift\n// Failure [\"Unknown node discriminator 'Wrapped2'\"] \n```", "```\nlet badJson3 = goodJson.Replace(\"HappyHolidays\",\"HappyHolidays2\")\nlet badJson3_result = badJson3 |> fromJson |> Result.bind dtoToTree |> Result.bind dtoToGift\n// Failure [\"WrappingPaperStyle HappyHolidays2 not recognized\"] \n```", "```\n// create two errors\nlet badJson4 = goodJson.Replace(\"HappyHolidays\",\"HappyHolidays2\")\n                       .Replace(\"SeventyPercent\",\"SeventyPercent2\")\nlet badJson4_result = badJson4 |> fromJson |> Result.bind dtoToTree |> Result.bind dtoToGift\n// Failure [\"WrappingPaperStyle HappyHolidays2 not recognized\"; \n//          \"ChocolateType SeventyPercent2 not recognized\"] \n```"]