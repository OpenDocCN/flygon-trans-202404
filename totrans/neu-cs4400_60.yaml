- en: '`Boxof`’s Lack of SubtypingTuesday, February 21st'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The lack of any subtype relations between `(Boxof T)` and `(Boxof S)` regardless
    of `S` and `T` can roughly be explained as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a box is a container that you can pull a value out of — which makes
    it similar to lists. In the case of lists, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is true for all such containers that you can pull a value out of: if you
    expect to pull a `T` but is given a container of a subtype `S` , then things are
    still fine. Such “containers” include functions that produce a value — for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, functions also have the other side, where things are different — instead
    of a side of some *produced* value, it’s the side of the *consumed* value. We
    get the opposite rule there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To see why this is right, use `Number` and `Integer` for `S` and `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: so — if you expect a function that takes a number is a *subtype* of one that
    takes an integer; in other words, every function that takes a number is also a
    function that takes an integer, but not the other way.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize all of this, when you make the output type of a function “smaller”
    (more constrained), the resulting type is smaller, but on the input side things
    are flipped — a bigger input type means a more constrained function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, a `(Boxof T)` is a producer of `T` when you pull a value out of the box,
    but it’s also a consumer of `T` when you put such a value in it. This means that
    — using the above analogy — the `T` is on both sides of the arrow. This means
    that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'which is actually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A different way to look at this conclusion is to consider the function type
    of `(A -> A)`: when is it a subtype of some other `(B -> B)`? Only when `A` is
    a subtype of `B` and `B` is a subtype of `A`, which means that this happens only
    when `A` and `B` are the same type.'
  prefs: []
  type: TYPE_NORMAL
- en: '(Side note: this is related to the fact that in logic, `P => Q` is roughly
    equivalent to `not(P) or Q` — the left side, `P`, is inside a negation. It also
    explains why in `((S -> T) -> Q)` the `S` obeys the first rule, as if it was on
    the right side — because it’s negated twice.)'
  prefs: []
  type: TYPE_NORMAL
- en: The following piece of code makes the analogy to function types more formally.
    Boxes behave as if their contents is on both sides of a function arrow — on the
    right because they’re readable, and on the left because they’re writable, which
    the conclusion that a `(Boxof A)` type is a subtype of itself and no other `(Boxof
    B)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
