["```\nroot ::= html;\nhtml ::= ( italic | normal ) *;\nitalic ::= '<i>' html '</i>';\nnormal ::= text; \ntext ::= [^<>]+;  /* represents a string of one or more characters that are not < or > */\n```", "```\nroot ::= html;\n```", "```\nhtml ::= ( normal | italic ) *;\n```", "```\nitalic ::= '<i>' html '</i>';\nnormal ::= text; \ntext ::= [^<>]+;\n```", "```\nidentifier ::= [a-z]+;\ninteger ::= [0-9]+;\n```", "```\nroot ::= sum;\nsum ::= primitive ('+' primitive)*;\nprimitive ::= number | '(' sum ')';\nnumber ::= [0-9]+;\n```", "```\nsum ::= primitive (whitespace* '+' whitespace* primitive)*;\nwhitespace ::= [ \\t\\r\\n];\n```", "```\n//The IntegerExpression grammar\n@skip whitespace{\n    root ::= sum;\n    sum ::= primitive ('+' primitive)*;\n    primitive ::= number | '(' sum ')';\n}\nwhitespace ::= [ \\t\\r\\n];\nnumber ::= [0-9]+;\n```", "```\nimport lib6005.parser;\n```", "```\nenum IntegerGrammar {ROOT, SUM, PRIMITIVE, NUMBER, WHITESPACE};\n```", "```\n...\nParser<IntegerGrammar> parser = GrammarCompiler.compile(new File(\"IntegerExpression.g\"), IntegerGrammar.ROOT);\n```", "```\nParseTree<IntegerGrammar> tree = parser.parse(\"5+2+3+21\");\n```", "```\nSystem.out.println(tree.toString());\n```", "```\n/**\n * Returns the substring of the original string that corresponds to this parse tree.\n * @return String containing the contents of this parse tree.\n */\npublic String getContents()\n\n/**\n * Ordered list of all the children nodes of this ParseTree node.\n * @return a List of all children of this ParseTree node, ordered by position in input\n */\npublic List<ParseTree<Symbols>> children()\n\n/**\n * Tells you whether a node corresponds to a terminal or a non-terminal. \n * If it is terminal, it won't have any children.\n * @return true if it is a terminal value.\n */\npublic boolean isTerminal()\n\n/**\n * Get the symbol for the terminal or non-terminal corresponding to this parse tree.\n * @return T will generally be an Enum representing the different symbols \n *  in the grammar, so the return value will be one of those.\n */\npublic Symbols getName() \n```", "```\n/**\n * Get all the children of this PareseTree node corresponding to a particular production rule \n * @param name \n * Name of the non-terminal corresponding to the desired production rule.\n * @return \n * List of children ParseTree objects that match that name.\n */\npublic List <ParseTree<Symbols>> childrenByName(Symbols name);\n```", "```\n/**\n * Traverse a parse tree, indenting to make it easier to read.\n * @param node\n * Parse tree to print.\n * @param indent\n * Indentation to use.\n */\nvoid visitAll(ParseTree<IntegerGrammar> node, String indent){\n    if(node.isTerminal()){\n        System.out.println(indent + node.getName() + \":\" + node.getContents());\n    }else{\n        System.out.println(indent + node.getName());\n        for(ParseTree<IntegerGrammar> child: node){\n            visitAll(child, indent + \"   \");\n        }\n    }\n}\n```", "```\nIntegerExpression = Number(n:int)\n                    + Plus(left:IntegerExpression, right:IntegerExpression)\n```", "```\n/**\n     * Function converts a ParseTree to an IntegerExpression. \n     * @param p\n     *  ParseTree<IntegerGrammar> that is assumed to have been constructed by the grammar in IntegerExpression.g\n     * @return\n     */\n    IntegerExpression buildAST(ParseTree<IntegerGrammar> p){\n\n        switch(p.getName()){\n        /*\n         * Since p is a ParseTree parameterized by the type IntegerGrammar, p.getName() \n         * returns an instance of the IntegerGrammar enum. This allows the compiler to check\n         * that we have covered all the cases.\n         */\n        case NUMBER:\n            /*\n             * A number will be a terminal containing a number.\n             */\n            return new Number(Integer.parseInt(p.getContents()));\n        case PRIMITIVE:\n            /*\n             * A primitive will have either a number or a sum as child (in addition to some whitespace)\n             * By checking which one, we can determine which case we are in.\n             */             \n\n            if(p.childrenByName(IntegerGrammar.number).isEmpty()){\n                return buildAST(p.childrenByName(IntegerGrammar.sum).get(0));\n            }else{\n                return buildAST(p.childrenByName(IntegerGrammar.number).get(0));\n            }\n\n        case SUM:\n            /*\n             * A sum will have one or more children that need to be summed together.\n             * Note that we only care about the children that are primitive. There may also be \n             * some whitespace children which we want to ignore.\n             */\n            boolean first = true;\n            IntegerExpression result = null;\n            for(ParseTree<IntegerGrammar> child : p.childrenByName(IntegerGrammar.PRIMITIVE)){                \n                if(first){\n                    result = buildAST(child);\n                    first = false;\n                }else{\n                    result = new Plus(result, buildAST(child));\n                }\n            }\n            if(first){ throw new RuntimeException(\"sum must have a non whitespace child:\" + p); }\n            return result;\n        case ROOT:\n            /*\n             * The root has a single sum child, in addition to having potentially some whitespace.\n             */\n            return buildAST(p.childrenByName(IntegerGrammar.sum).get(0));\n        case WHITESPACE:\n            /*\n             * Since we are always avoiding calling buildAST with whitespace, \n             * the code should never make it here. \n             */\n            throw new RuntimeException(\"You should never reach here:\" + p);\n        }   \n        /*\n         * The compiler should be smart enough to tell that this code is unreachable, but it isn't.\n         */\n        throw new RuntimeException(\"You should never reach here:\" + p);\n    }\n```", "```\nPlus(Plus(Number(1), Number(2)), \n     Plus(Number(3), Number(4)))\n```", "```\n//The IntegerExpression grammar\n@skip whitespace{\n    root ::= sum;\n    sum ::=  number | sum '+' number;\n}\nwhitespace ::= [ \\t\\r\\n];\nnumber ::= [0-9]+;\n```", "```\n//The IntegerExpression grammar\n@skip whitespace{\n    root ::= sum;\n    sum ::=  number | thing  number;\n    thing ::= sum '+';\n}\nwhitespace ::= [ \\t\\r\\n];\nnumber ::= [0-9]+;\n```", "```\n//The IntegerExpression grammar\n@skip whitespace{\n    root ::= sum;\n    sum ::=  (number '+')* number;\n}\nwhitespace ::= [ \\t\\r\\n];\nnumber ::= [0-9]+;\n```", "```\nroot ::= ab threeb;\nab ::= 'a'*'b'*\nthreeb ::= 'bbb';\n```"]