- en: ProofObjectsThe Curry-Howard Correspondence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Export IndProp.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Print ev.
  prefs: []
  type: TYPE_NORMAL
- en: (* ==>   Inductive ev : nat -> Prop :=     | ev_0 : ev 0     | ev_SS : forall n, ev n -> ev (S (S n)).
    *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: propositions  ~  types
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: proofs        ~  data values
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Check ev_SS.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> ev_SS : forall n,                   ev n ->                   ev (S (S n)) *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem ev_4 : ev 4.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: apply ev_SS. apply ev_SS. apply ev_0. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Print ev_4.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> ev_4 = ev_SS 2 (ev_SS 0 ev_0)      : ev 4  *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Check (ev_SS 2 (ev_SS 0 ev_0)).
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> ev 4 *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: ∀n, ev n → ev (S (S n)),
  prefs: []
  type: TYPE_NORMAL
- en: expresses this functionality, in the same way that the polymorphic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: type ∀ X, list X expresses the fact that the constructor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: nil can be thought of as a function from types to empty lists
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: with elements of that type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We saw in the [Logic](Logic.html) chapter that we can use function
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: application syntax to instantiate universally quantified variables
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in lemmas, as well as to supply evidence for assumptions that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'these lemmas impose.  For instance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can now see that this feature is a trivial consequence of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'status the Coq grants to proofs and propositions: Lemmas and'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hypotheses can be combined in expressions (i.e., proof objects)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: according to the same basic rules used for programs in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: language.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem ev_4'''' : ev 4.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: Show Proof.
  prefs: []
  type: TYPE_NORMAL
- en: apply ev_SS.
  prefs: []
  type: TYPE_NORMAL
- en: Show Proof.
  prefs: []
  type: TYPE_NORMAL
- en: apply ev_SS.
  prefs: []
  type: TYPE_NORMAL
- en: Show Proof.
  prefs: []
  type: TYPE_NORMAL
- en: apply ev_0.
  prefs: []
  type: TYPE_NORMAL
- en: Show Proof.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition ev_4'''''' : ev 4 :='
  prefs: []
  type: TYPE_NORMAL
- en: ev_SS 2 (ev_SS 0 ev_0).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Print ev_4.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> ev_4    =   ev_SS 2 (ev_SS 0 ev_0) : ev 4 *)
  prefs: []
  type: TYPE_NORMAL
- en: Print ev_4'.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> ev_4'   =   ev_SS 2 (ev_SS 0 ev_0) : ev 4 *)
  prefs: []
  type: TYPE_NORMAL
- en: Print ev_4''.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> ev_4''  =   ev_SS 2 (ev_SS 0 ev_0) : ev 4 *)
  prefs: []
  type: TYPE_NORMAL
- en: Print ev_4'''.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> ev_4''' =   ev_SS 2 (ev_SS 0 ev_0) : ev 4 *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem ev_8 : ev 8.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition ev_8'' : ev 8'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Quantifiers, Implications, Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Coq's computational universe (where data structures and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: programs live), there are two sorts of values with arrows in their
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'types: *constructors* introduced by Inductive-ly defined data'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: types, and *functions*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similarly, in Coq's logical universe (where we carry out proofs),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'there are two ways of giving evidence for an implication:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: constructors introduced by Inductive-ly defined propositions,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and... functions!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, consider this statement:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What is the proof object corresponding to ev_plus4?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We're looking for an expression whose *type* is ∀ n, ev n → ev (4 + n) — that
    is, a *function* that takes two arguments (one
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: number and a piece of evidence) and returns a piece of evidence!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here it is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Recall that fun n ⇒ blah means "the function that, given n,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: yields blah," and that Coq treats 4 + n and S (S (S (S n)))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'as synonyms. Another equivalent way to write this definition is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When we view the proposition being proved by ev_plus4 as a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: function type, one aspect of it may seem a little unusual. The
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: second argument's type, ev n, mentions the *value* of the first
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: argument, n.  While such *dependent types* are not found in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: conventional programming languages, they can be useful in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: programming too, as the recent flurry of activity in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: functional programming community demonstrates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice that both implication (→) and quantification (∀)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: correspond to functions on evidence.  In fact, they are really the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'same thing: → is just a shorthand for a degenerate use of'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ∀ where there is no dependency, i.e., no need to give a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: name to the type on the left-hand side of the arrow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, consider this proposition:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A proof term inhabiting this proposition would be a function
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'with two arguments: a number n and some evidence E that n is'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: even.  But the name E for this evidence is not used in the rest
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of the statement of ev_plus2, so it's a bit silly to bother
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: making up a name for it.  We could write it like this instead,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'using the dummy identifier _ in place of a real name:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, equivalently, we can write it in more familiar notation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In general, "P → Q" is just syntactic sugar for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"∀ (_:P), Q".'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition add1 : nat → nat.'
  prefs: []
  type: TYPE_NORMAL
- en: intro n.
  prefs: []
  type: TYPE_NORMAL
- en: Show Proof.
  prefs: []
  type: TYPE_NORMAL
- en: apply S.
  prefs: []
  type: TYPE_NORMAL
- en: Show Proof.
  prefs: []
  type: TYPE_NORMAL
- en: apply n. Defined.
  prefs: []
  type: TYPE_NORMAL
- en: Print add1.
  prefs: []
  type: TYPE_NORMAL
- en: (* ==>     add1 = fun n : nat => S n          : nat -> nat *)
  prefs: []
  type: TYPE_NORMAL
- en: Compute add1 2.
  prefs: []
  type: TYPE_NORMAL
- en: (* ==> 3 : nat *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Logical Connectives as Inductive Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inductive definitions are powerful enough to express most of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: connectives and quantifiers we have seen so far.  Indeed, only
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: universal quantification (and thus implication) is built into Coq;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: all the others are defined inductively.  We'll see these
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definitions in this section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Conjunction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prove that P ∧ Q holds, we must present evidence for both
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'P and Q.  Thus, it makes sense to define a proof object for P ∧ Q as consisting
    of a pair of two proofs: one for P and'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: another one for Q. This leads to the following definition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice the similarity with the definition of the prod type,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: given in chapter [Poly](Poly.html); the only difference is that prod takes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Type arguments, whereas and takes Prop arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This should clarify why destruct and intros patterns can be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: used on a conjunctive hypothesis.  Case analysis allows us to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: consider all possible ways in which P ∧ Q was proved — here
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: just one (the conj constructor).  Similarly, the split tactic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: actually works for any inductively defined proposition with only
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'one constructor.  In particular, it works for and:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This shows why the inductive definition of and can be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: manipulated by tactics as we've been doing.  We can also use it to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'build proofs directly, using pattern-matching.  For instance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars, optional (conj_fact)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Construct a proof object demonstrating the following proposition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Disjunction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The inductive definition of disjunction uses two constructors, one
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for each side of the disjunct:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This declaration explains the behavior of the destruct tactic on
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a disjunctive hypothesis, since the generated subgoals match the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: shape of the or_introl and or_intror constructors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once again, we can also directly write proof objects for theorems
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: involving or, without resorting to tactics.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, optional (or_commut'''')'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Try to write down an explicit proof object for or_commut (without
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: using Print to peek at the ones we already defined!).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Existential Quantification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To give evidence for an existential quantifier, we package a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: witness x together with a proof that x satisfies the property
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'P:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This may benefit from a little unpacking.  The core definition is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for a type former ex that can be used to build propositions of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the form ex P, where P itself is a *function* from witness
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: values in the type A to propositions.  The ex_intro
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: constructor then offers a way of constructing evidence for ex P,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: given a witness x and a proof of P x.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The more familiar form ∃ x, P x desugars to an expression
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'involving ex:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how to define an explicit proof object involving ex:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars, optional (ex_ev_Sn)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Complete the definition of the following proof object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: True and False
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The inductive definition of the True proposition is simple:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It has one constructor (so every proof of True is the same, so
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: being given a proof of True is not informative.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: False is equally simple — indeed, so simple it may look
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: syntactically wrong at first glance!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: That is, False is an inductive type with *no* constructors —
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: i.e., no way to build evidence for it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Equality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even Coq's equality relation is not built in.  It has the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: following inductive definition.  (Actually, the definition in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: standard library is a small variant of this, which gives an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: induction principle that is slightly easier to use.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The way to think about this definition is that, given a set X,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it defines a *family* of propositions "x is equal to y,"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: indexed by pairs of values (x and y) from X.  There is just
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'one way of constructing evidence for each member of this family:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'applying the constructor eq_refl to a type X and a value x : X yields evidence
    that x is equal to x.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars (leibniz_equality)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The inductive definition of equality corresponds to *Leibniz equality*: what
    we mean when we say "x and y are equal" is'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that every property on P that is true of x is also true of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: y.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can use eq_refl to construct evidence that, for example, 2 = 2.  Can we also
    use it to construct evidence that 1 + 1 = 2?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Yes, we can.  Indeed, it is the very same piece of evidence!  The
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reason is that Coq treats as "the same" any two terms that are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*convertible* according to a simple set of computation rules.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These rules, which are similar to those used by Compute, include
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: evaluation of function application, inlining of definitions, and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simplification of matches.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The reflexivity tactic that we have used to prove equalities up
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to now is essentially just short-hand for apply refl_equal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In tactic-based proofs of equality, the conversion rules are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: normally hidden in uses of simpl (either explicit or implicit in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: other tactics such as reflexivity).  But you can see them
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'directly at work in the following explicit proof objects:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Inversion, Again
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen inversion used with both equality hypotheses and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hypotheses about inductively defined propositions.  Now that we've
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: seen that these are actually the same thing, we're in a position
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to take a closer look at how inversion behaves.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In general, the inversion tactic...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: takes a hypothesis H whose type P is inductively defined, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for each constructor C in P's definition,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: generates a new subgoal in which we assume H was built with C,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: adds the arguments (premises) of C to the context of the subgoal as extra hypotheses,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: matches the conclusion (result type) of C against the current goal and calculates
    a set of equalities that must hold in order for C to be applicable,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: adds these equalities to the context (and, for convenience, rewrites them in
    the goal), and
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: if the equalities are not satisfiable (e.g., they involve things like S n =
    O), immediately solves the subgoal.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example*: If we invert a hypothesis built with or, there are two'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: constructors, so two subgoals get generated.  The
  prefs: []
  type: TYPE_NORMAL
- en: conclusion (result type) of the constructor (P ∨ Q) doesn't
  prefs: []
  type: TYPE_NORMAL
- en: place any restrictions on the form of P or Q, so we don't get
  prefs: []
  type: TYPE_NORMAL
- en: any extra equalities in the context of the subgoal.
  prefs: []
  type: TYPE_NORMAL
- en: '*Example*: If we invert a hypothesis built with and, there is'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: only one constructor, so only one subgoal gets generated.  Again,
  prefs: []
  type: TYPE_NORMAL
- en: the conclusion (result type) of the constructor (P ∧ Q) doesn't
  prefs: []
  type: TYPE_NORMAL
- en: place any restrictions on the form of P or Q, so we don't get
  prefs: []
  type: TYPE_NORMAL
- en: any extra equalities in the context of the subgoal.  The
  prefs: []
  type: TYPE_NORMAL
- en: constructor does have two arguments, though, and these can be seen
  prefs: []
  type: TYPE_NORMAL
- en: in the context in the subgoal.
  prefs: []
  type: TYPE_NORMAL
- en: '*Example*: If we invert a hypothesis built with eq, there is'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: again only one constructor, so only one subgoal gets generated.
  prefs: []
  type: TYPE_NORMAL
- en: Now, though, the form of the refl_equal constructor does give us
  prefs: []
  type: TYPE_NORMAL
- en: 'some extra information: it tells us that the two arguments to eq'
  prefs: []
  type: TYPE_NORMAL
- en: must be the same!  The inversion tactic adds this fact to the
  prefs: []
  type: TYPE_NORMAL
- en: context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
