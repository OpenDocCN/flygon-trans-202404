- en: Apply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`apply`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Apply` takes two arguments, a procedure and a list of arguments to which the
    procedure should be applied. `Apply` classifies procedures into two kinds: It
    calls `apply-primitive-procedure` to apply primitives; it applies compound procedures
    by sequentially evaluating the expressions that make up the body of the procedure.
    The environment for the evaluation of the body of a compound procedure is constructed
    by extending the base environment carried by the procedure to include a frame
    that binds the parameters of the procedure to the arguments to which the procedure
    is to be applied. Here is the definition of `apply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will go through the procedures used in the definition, one-by-one.
  prefs: []
  type: TYPE_NORMAL
- en: Representing Procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To handle primitives, we assume that we have available the following procedures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(apply-primitive-procedure proc args)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: applies the given primitive procedure to the argument values in the list 'args'
    and returns the result of the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(primitive-procedure? proc)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tests whether `proc` is a primitive procedure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Compound procedures are constructed from parameters, procedure bodies, and
    environments using the constructor `make-procedure`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Primitive Procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, or maybe for a long time, you may wonder how primitive procedures
    are represented in Scheme. There is actually no right way to represent the primitive
    procedures, as long as `apply` can identify and apply them by using the procedures
    `primitive-procedure?` and `apply-primitive- procedure`.
  prefs: []
  type: TYPE_NORMAL
- en: People who created Scheme decided to represent a primitive procedure as a list
    which begins with the symbol `primitive` and contains a procedure in the underlying
    Lisp that implements that primitive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply a primitive procedure, we simply apply the implementation procedure
    to the arguments, using the underlying Lisp system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Operations on Environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For sure, the evaluator needs operations for manipulating environments. What
    is an environment again? It is a sequence of frames, where each frame is a table
    of bindings that associate variables with their corresponding values. We use the
    following operations for manipulating environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(lookup-variable-value <var> <env>)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: returns the value that is bound to the symbol `in the environment <env>, or
    signals an error if the variable is unbound.</env>`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(extend-environment <variables> <values> <base-env>)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: returns a new environment, consisting of a new frame in which the symbols in
    the list <variables>are bound to the corresponding elements in the list <values>,
    where the enclosing environment is the environment <base-env>.</base-env></values></variables>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(define-variable! <var> <value> <env>)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: adds to the first frame in the environment <env>a new binding that associates
    the variable `with the value <value>.</value>`</env>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`(set-variable-value! <var> <value> <env>)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: changes the binding of the variable `in the environment <env>so that the variable
    is now bound to the value <value>, or signals an error if the variable is unbound.</value></env>`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To implement these operations we represent an environment as a list of frames.
    The enclosing environment of an environment is the `cdr` of the list. The empty
    environment is simply the empty list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Each frame of an environment is represented as a pair of lists: a list of the
    variables bound in that frame and a list of the associated values.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To extend an environment by a new frame that associates variables with values,
    we make a frame consisting of the list of variables and the list of values, and
    we adjoin this to the environment. We signal an error if the number of variables
    does not match the number of values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To look up a variable in an environment, we scan the list of variables in the
    first frame. If we find the desired variable, we return the corresponding element
    in the list of values. If we do not find the variable in the current frame, we
    search the enclosing environment, and so on. If we reach the empty environment,
    we signal an "unbound variable" error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To set a variable to a new value in a specified environment, we scan for the
    variable, just as in `lookup-variable-value`, and change the corresponding value
    when we find it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To define a variable, we search the first frame for a binding for the variable,
    and change the binding if it exists (just as in `set-va``riable- value!`). If
    no such binding exists, we adjoin one to the first frame.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`apply` Revisited'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at the definition of `apply` again. Does it make sense this time?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Takeaways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this subsection, you learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How `apply` is defined
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How primitive procedures are defined and applied
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How the operations on environments are defined
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to learn how the evaluator runs as a program.
  prefs: []
  type: TYPE_NORMAL
