- en: libcurl basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: libcurl basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The engine in the curl command-line tool is libcurl. libcurl is also the engine
    in thousands of tools, services and applications out there today, performing their
    Internet data transfers.
  prefs: []
  type: TYPE_NORMAL
- en: C API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: libcurl is a library of functions that are provided with a C API, for applications
    written in C. You can easily use it from C++ too, with only a few considerations
    (see [libcurl for C++ programmers](libcurl-cplusplus.html). For other languages,
    there exist "bindings" that work as intermediate layers between libcurl the library
    and corresponding functions for the particular language you like.
  prefs: []
  type: TYPE_NORMAL
- en: Transfer oriented
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have designed libcurl to be transfer oriented usually without forcing users
    to be protocol experts or in fact know much at all about networking or the protocols
    involved. You setup a transfer with as many details and specific information as
    you can and want, and then you tell libcurl to perform that transfer.
  prefs: []
  type: TYPE_NORMAL
- en: That said, networking and protocols are areas with lots of pitfalls and special
    cases so the more you know about these things, the more you will be able to understand
    about libcurl's options and ways of working. Not to mention, such knowledge is
    invaluable when you are debugging and need to understand what to do next when
    things don't go as you intended.
  prefs: []
  type: TYPE_NORMAL
- en: The most basic libcurl using application can be as small as just a couple of
    lines of code, but most applications will, of course, need more code than that.
  prefs: []
  type: TYPE_NORMAL
- en: Simple by default, more on demand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: libcurl generally does the simple and basic transfer by default, and if you
    want to add more advanced features, you add that by setting the correct options.
    For example, libcurl doesn't support HTTP cookies by default but it does once
    you tell it.
  prefs: []
  type: TYPE_NORMAL
- en: This makes libcurl's behaviors easier to guess and depend on, and also it makes
    it easier to maintain old behavior and add new features. Only applications that
    actually ask for and use the new features will get that behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Easy handle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Easy handle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The fundamentals you need to learn with libcurl:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First you create an "easy handle", which is your handle to a transfer, really:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you set various options in that handle to control the upcoming transfer.
    Like, this example sets the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating the easy handle and setting options on it doesn't make any transfer
    happen, and usually don't even make much more happen other than libcurl storing
    your wish to be used later when the transfer actually occurs. Lots of syntax checking
    and validation of the input may also be postponed, so just because `curl_easy_setopt`
    didn't complain, it doesn't mean that the input was correct and valid; you may
    get an error returned later.
  prefs: []
  type: TYPE_NORMAL
- en: Read more on [easy options](libcurl-options.html) in its separate section.
  prefs: []
  type: TYPE_NORMAL
- en: All options are "sticky". They remain set in the handle until you change them
    again, or call `curl_easy_reset()` on the handle.
  prefs: []
  type: TYPE_NORMAL
- en: When you are done setting options to your easy handle, you can fire off the
    actual transfer.
  prefs: []
  type: TYPE_NORMAL
- en: The actual "perform the transfer phase" can be done using different means and
    function calls, depending on what kind of behavior you want in your application
    and how libcurl is best integrated into your architecture. Those are further described
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After the transfer has completed, you can figure out if it succeeded or not
    and you can extract stats and various information that libcurl gathered during
    the transfer from the easy handle. See [Post transfer information](libcurl-getinfo.html).
  prefs: []
  type: TYPE_NORMAL
- en: While the transfer is ongoing, libcurl calls your specified functions—known
    as *[callbacks](libcurl-callbacks.md])*—to deliver data, to read data or to do
    a wide variety of things.
  prefs: []
  type: TYPE_NORMAL
- en: Reuse!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Easy handles are meant and designed to be reused. When you have done a single
    transfer with the easy handle, you can immediately use it again for your next
    transfer. There are lots of gains to be had by this.
  prefs: []
  type: TYPE_NORMAL
- en: Drive transfers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Drive" transfers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: libcurl provides three different ways to perform the transfer. Which way to
    use in your case is entirely up to you and what you need.
  prefs: []
  type: TYPE_NORMAL
- en: The 'easy' interface lets you do a single transfer in a synchronous fashion.
    libcurl will do the entire transfer and return control back to your application
    when it is completed—successful or failed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The 'multi' interface is for when you want to do more than one transfer at the
    same time, or you just want a non-blocking transfer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The 'multi_socket' interface is a slight variation of the regular multi one,
    but is event-based and is really the suggested API to use if you intend to scale
    up the number of simultaneous transfers to hundreds or thousands or so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's look at each one a little closer…
  prefs: []
  type: TYPE_NORMAL
- en: Drive with easy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Driving with the easy interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The name ''easy'' was picked simply because this is really the easy way to
    use libcurl, and with easy, of course, comes a few limitations. Like, for example,
    that it can only do one transfer at a time and that it does the entire transfer
    in a single function call and returns once it is completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the server is slow, if the transfer is large or if you have some unpleasant
    timeouts in the network or similar, this function call can end up taking a very
    long time. You can, of course, set timeouts to not allow it to spend more than
    N seconds, but it could still mean a substantial amount of time depending on the
    particular conditions.
  prefs: []
  type: TYPE_NORMAL
- en: If you want your application to do something else while libcurl is transferring
    with the easy interface, you need to use multiple threads. If you want to do multiple
    simultaneous transfers when using the easy interface, you need to perform each
    of the transfers in its own thread.
  prefs: []
  type: TYPE_NORMAL
- en: Drive with multi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Driving with the multi interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The name 'multi' is for multiple, as in multiple parallel transfers, all done
    in the same single thread. The multi API is non-blocking so it can also make sense
    to use it for single transfers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transfer is still set in an "easy" `CURL *` handle as described [above](libcurl-easyhandle.html),
    but with the multi interface you also need a multi `CURLM *` handle created and
    use that to drive all the individual transfers. The multi handle can "hold" one
    or many easy handles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A multi handle can also get certain options set, which you do with `curl_multi_setopt()`,
    but in the simplest case you might not have anything to set there.
  prefs: []
  type: TYPE_NORMAL
- en: To drive a multi interface transfer, you first need to add all the individual
    easy handles that should be transferred to the multi handle. You can add them
    to the multi handle at any point and you can remove them again whenever you like.
    Removing an easy handle from a multi handle will, of course, remove the association
    and that particular transfer would stop immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding an easy handle to the multi handle is very easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing one is just as easily done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Having added the easy handles representing the transfers you want to perform,
    you write the transfer loop. With the multi interface, you do the looping so you
    can ask libcurl for a set of file descriptors and a timeout value and do the `select()`
    call yourself, or you can use the slightly simplified version which does that
    for us, with `curl_multi_wait`. The simplest loop would basically be this: (*note
    that a real application would check return codes*)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The fourth argument to `curl_multi_wait`, set to 1000 in the example above,
    is a timeout in milliseconds. It is the longest time the function will wait for
    any activity before it returns anyway. You don't want to lock up for too long
    before calling `curl_multi_perform` again as there are timeouts, progress callbacks
    and more that may loose precision if you do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'To instead do select() on our own, we extract the file descriptors and timeout
    value from libcurl like this (*note that a real application would check return
    codes*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Both these loops let you use one or more file descriptors of your own on which
    to wait, like if you read from your own sockets or a pipe or similar.
  prefs: []
  type: TYPE_NORMAL
- en: And again, you can add and remove easy handles to the multi handle at any point
    during the looping. Removing a handle mid-transfer will, of course, abort that
    transfer.
  prefs: []
  type: TYPE_NORMAL
- en: When is a single transfer done?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the examples above show, a program can detect when an individual transfer
    completes by seeing that the `transfers_running` variable decreases.
  prefs: []
  type: TYPE_NORMAL
- en: It can also call `curl_multi_info_read()`, which will return a pointer to a
    struct (a "message") if a transfer has ended and you can then find out the result
    of that transfer using that struct.
  prefs: []
  type: TYPE_NORMAL
- en: When you do multiple parallel transfers, more than one transfer can of course
    complete in the same `curl_multi_perform` invocation and then you might need more
    than one call to `curl_multi_info_read` to get info about each completed transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Drive with multi_socket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Driving with the "multi_socket" interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: multi_socket is the extra spicy version of the regular multi interface and is
    designed for event-driven applications. Make sure you read the [Drive with multi
    interface](libcurl-drive-multi.html) section first.
  prefs: []
  type: TYPE_NORMAL
- en: multi_socket supports multiple parallel transfers—all done in the same single
    thread—and have been used to run several tens of thousands of transfers in a single
    application. It is usually the API that makes the most sense if you do a large
    number (>100 or so) of parallel transfers.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven in this case means that your application uses a system level library
    or setup that "subscribes" to a number of sockets and it lets your application
    know when one of those sockets are readable or writable and it tells you exactly
    which one.
  prefs: []
  type: TYPE_NORMAL
- en: This setup allows clients to scale up the number of simultaneous transfers much
    higher than with other systems, and still maintain good performance. The "regular"
    APIs otherwise waste far too much time scanning through lists of all the sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Pick one
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are numerous event based systems to select from out there, and libcurl
    is completely agnostic to which one you use. libevent, libev are libuv three popular
    ones but you can also go directly to your operating system's native solutions
    such as epoll, kqueue, /dev/poll, pollset, Event Completion or I/O Completion
    Ports.
  prefs: []
  type: TYPE_NORMAL
- en: Many easy handles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like with the regular multi interface, you add easy handles to a multi
    handle with `curl_multi_add_handle()`. One easy handle for each transfer you want
    to perform.
  prefs: []
  type: TYPE_NORMAL
- en: You can add them at any time while the transfers are running and you can also
    similarly remove easy handles at any time using the `curl_multi_remove_handle`
    call. Typically though, you remove a handle only after its transfer is completed.
  prefs: []
  type: TYPE_NORMAL
- en: multi_socket callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As explained above, this event-based mechanism relies on the application to
    know which sockets are used by libcurl and what libcurl waits for on those sockets:
    if it waits for the socket to become readable, writable or both!'
  prefs: []
  type: TYPE_NORMAL
- en: It also needs to tell libcurl when its timeout time has expired, as it is control
    of driving everything libcurl can't do it itself. So libcurl must tell the application
    an updated timeout value, too.
  prefs: []
  type: TYPE_NORMAL
- en: socket_callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'libcurl informs the application about socket activity to wait for with a callback
    called [CURLMOPT_SOCKETFUNCTION](https://curl.haxx.se/libcurl/c/CURLMOPT_SOCKETFUNCTION.html).
    Your application needs to implement such a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using this, libcurl will set and remove sockets your application should monitor.
    Your application tells the underlying event-based system to wait for the sockets.
    This callback will be called multiple times if there are multiple sockets to wait
    for, and it will be called again when the status changes and perhaps you should
    switch from waiting for a writable socket to instead wait for it to become readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'When one of the sockets that the application is monitoring on libcurl''s behalf
    registers that it becomes readable or writable, as requested, you tell libcurl
    about it by calling `curl_multi_socket_action()` and passing in the affected socket
    and an associated bitmask specifying which socket activity that was registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: timer_callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The application is in control and will wait for socket activity. But even without
    socket activity there will be things libcurl needs to do. Timeout things, calling
    the progress callback, starting over a retry or failing a transfer that takes
    too long, etc. To make that work, the application must also make sure to handle
    a single-shot timeout that libcurl sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'libcurl sets the timeout with the timer_callback [CURLMOPT_TIMERFUNCTION](https://curl.haxx.se/libcurl/c/CURLMOPT_TIMERFUNCTION.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is only one timeout for the application to handle for the entire multi
    handle, no matter how many individual easy handles that have been added or transfers
    that are in progress. The timer callback will be updated with the current nearest-in-time
    period to wait. If libcurl gets called before the timeout expiry time because
    of socket activity, it may very well update the timeout value again before it
    expires.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the event system of your choice eventually tells you that the timer has
    expired, you need to tell libcurl about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: …in many cases, this will make libcurl call the timer_callback again and set
    a new timeout for the next expiry period.
  prefs: []
  type: TYPE_NORMAL
- en: How to start everything
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you have added one or more easy handles to the multi handle and set the
    socket and timer callbacks in the multi handle, you are ready to start the transfer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To kick it all off, you tell libcurl it timed out (because all easy handles
    start out with a very, very short timeout) which will make libcurl call the callbacks
    to set things up and from then on you can can just let your event system drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When is it done?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The 'running_handles' counter returned by `curl_multi_socket_action` holds the
    number of current transfers not completed. When that number reaches zero, we know
    there are no transfers going on.
  prefs: []
  type: TYPE_NORMAL
- en: Each time the 'running_handles' counter changes, `curl_multi_info_read()` will
    return info about the specific transfers that completed.
  prefs: []
  type: TYPE_NORMAL
- en: Connection reuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connection reuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: libcurl keeps a pool of old connections alive. When one transfer has completed
    it will keep N connections alive in a "connection pool" (sometimes also called
    connection cache) so that a subsequent transfer that happens to be able to reuse
    one of the existing connections can use it instead of creating a new one. Reusing
    a connection instead of creating a new one offers significant benefits in speed
    and required resources.
  prefs: []
  type: TYPE_NORMAL
- en: When libcurl is about to make a new connection for the purposes of doing a transfer,
    it will first check to see if there's an existing connection in the pool that
    it can reuse instead. The connection re-use check is done before any DNS or other
    name resolving mechanism is used, so it is purely host name based. If there's
    an existing live connection to the right host name, a lot of other properties
    (port number, protocol, etc) are also checked to see that it can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Easy API pool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are using the easy API, or, more specifically, `curl_easy_perform()`,
    libcurl will keep the pool associated with the specific easy handle. Then reusing
    the same easy handle will ensure it can reuse its connection.
  prefs: []
  type: TYPE_NORMAL
- en: Multi API pool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are using the multi API, the connection pool is instead kept associated
    with the multi handle. This allows you to cleanup and re-create easy handles freely
    without risking losing the connection pool, and it allows the connection used
    by one easy handle to get reused by a separate one in a later transfer. Just reuse
    the multi handle!
  prefs: []
  type: TYPE_NORMAL
- en: Sharing the "connection cache"
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since libcurl 7.57.0, applications can use the [share interface](libcurl-sharing.html)
    to have otherwise independent transfers share the same connection pool.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lots of operations within libcurl are controlled with the use of *callbacks*.
    A callback is a function pointer provided to libcurl that libcurl then calls at
    some point in time to get a particular job done.
  prefs: []
  type: TYPE_NORMAL
- en: Each callback has its specific documented purpose and it requires that you write
    it with the exact function prototype to accept the correct arguments and return
    the documented return code and return value so that libcurl will perform the way
    you want it to.
  prefs: []
  type: TYPE_NORMAL
- en: Each callback option also has a companion option that sets the associated "user
    pointer". This user pointer is a pointer that libcurl doesn't touch or care about,
    but just passes on as an argument to the callback. This allows you to, for example,
    pass in pointers to local data all the way through to your callback function.
  prefs: []
  type: TYPE_NORMAL
- en: Unless explicitely stated in a libcurl function documentation, it is not legal
    to invoke libcurl functions from within a libcurl callback.
  prefs: []
  type: TYPE_NORMAL
- en: Write data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The write callback is set with `CURLOPT_WRITEFUNCTION`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `write_callback` function must match this prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This callback function gets called by libcurl as soon as there is data received
    that needs to be saved. *ptr* points to the delivered data, and the size of that
    data is *size* multiplied with *nmemb*.
  prefs: []
  type: TYPE_NORMAL
- en: If this callback isn't set, libcurl instead uses 'fwrite' by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The write callback will be passed as much data as possible in all invokes,
    but it must not make any assumptions. It may be one byte, it may be thousands.
    The maximum amount of body data that will be passed to the write callback is defined
    in the curl.h header file: `CURL_MAX_WRITE_SIZE` (the usual default is 16KB).
    If `CURLOPT_HEADER` is enabled for this transfer, which makes header data get
    passed to the write callback, you can get up to `CURL_MAX_HTTP_HEADER` bytes of
    header data passed into it. This usually means 100KB.'
  prefs: []
  type: TYPE_NORMAL
- en: This function may be called with zero bytes data if the transferred file is
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The data passed to this function will not be zero terminated! You cannot, for
    example, use printf's "%s" operator to display the contents nor strcpy to copy
    it.
  prefs: []
  type: TYPE_NORMAL
- en: This callback should return the number of bytes actually taken care of. If that
    number differs from the number passed to your callback function, it will signal
    an error condition to the library. This will cause the transfer to get aborted
    and the libcurl function used will return `CURLE_WRITE_ERROR`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user pointer passed in to the callback in the *userdata* argument is set
    with `CURLOPT_WRITEDATA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Read data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The read callback is set with `CURLOPT_READFUNCTION`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `read_callback` function must match this prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This callback function gets called by libcurl when it wants to send data to
    the server. This is a transfer that you have set up to upload data or otherwise
    send it off to the server. This callback will be called over and over until all
    data has been delivered or the transfer failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **stream** pointer points to the private data set with `CURLOPT_READDATA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If this callback isn't set, libcurl instead uses 'fread' by default.
  prefs: []
  type: TYPE_NORMAL
- en: The data area pointed at by the pointer **buffer** should be filled up with
    at most **size** multiplied with **nitems** number of bytes by your function.
    The callback should then return the number of bytes that it stored in that memory
    area, or 0 if we have reached the end of the data. The callback can also return
    a few "magic" return codes to cause libcurl to return failure immediately or to
    pause the particular transfer. See the [CURLOPT_READFUNCTION man page](https://curl.haxx.se/libcurl/c/CURLOPT_READFUNCTION.html)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Progress information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Progress callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The progress callback is what gets called regularly and repeatedly for each
    transfer during the entire lifetime of the transfer. The old callback was set
    with `CURLOPT_PROGRESSFUNCTION` but the modern and preferred callback is set with
    `CURLOPT_XFERINFOFUNCTION`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `xfer_callback` function must match this prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If this option is set and `CURLOPT_NOPROGRESS` is set to 0 (zero), this callback
    function gets called by libcurl with a frequent interval. While data is being
    transferred it will be called very frequently, and during slow periods like when
    nothing is being transferred it can slow down to about one call per second.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **clientp** pointer points to the private data set with `CURLOPT_XFERINFODATA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback gets told how much data libcurl will transfer and has transferred,
    in number of bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dltotal** is the total number of bytes libcurl expects to download in this
    transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dlnow** is the number of bytes downloaded so far.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ultotal** is the total number of bytes libcurl expects to upload in this
    transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ulnow** is the number of bytes uploaded so far.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unknown/unused argument values passed to the callback will be set to zero (like
    if you only download data, the upload size will remain 0). Many times the callback
    will be called one or more times first, before it knows the data sizes, so a program
    must be made to handle that.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a non-zero value from this callback will cause libcurl to abort the
    transfer and return `CURLE_ABORTED_BY_CALLBACK`.
  prefs: []
  type: TYPE_NORMAL
- en: If you transfer data with the multi interface, this function will not be called
    during periods of idleness unless you call the appropriate libcurl function that
    performs transfers.
  prefs: []
  type: TYPE_NORMAL
- en: (The deprecated callback `CURLOPT_PROGRESSFUNCTION` worked identically but instead
    of taking arguments of type `curl_off_t`, it used `double`.)
  prefs: []
  type: TYPE_NORMAL
- en: Header data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Header callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The header callback is set with `CURLOPT_HEADERFUNCTION`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `header_callback` function must match this prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This callback function gets called by libcurl as soon as a header has been received.
    *ptr* points to the delivered data, and the size of that data is *size* multiplied
    with *nmemb*. libcurl buffers headers and delivers only "full" headers, one by
    one, to this callback.
  prefs: []
  type: TYPE_NORMAL
- en: The data passed to this function will not be zero terminated! You cannot, for
    example, use printf's "%s" operator to display the contents nor strcpy to copy
    it.
  prefs: []
  type: TYPE_NORMAL
- en: This callback should return the number of bytes actually taken care of. If that
    number differs from the number passed to your callback function, it signals an
    error condition to the library. This will cause the transfer to abort and the
    libcurl function used will return `CURLE_WRITE_ERROR`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user pointer passed in to the callback in the *userdata* argument is set
    with `CURLOPT_HEADERDATA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Debug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debug callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The debug callback is set with `CURLOPT_DEBUGFUNCTION`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `debug_callback` function must match this prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This callback function replaces the default verbose output function in the
    library and will get called for all debug and trace messages to aid applications
    to understand what''s going on. The *type* argument explains what sort of data
    that is provided: header, data or SSL data and in which direction it flows.'
  prefs: []
  type: TYPE_NORMAL
- en: A common use for this callback is to get a full trace of all data that libcurl
    sends and receives. The data sent to this callback is always the unencrypted version,
    even when, for example, HTTPS or other encrypted protocols are used.
  prefs: []
  type: TYPE_NORMAL
- en: This callback must return zero or cause the transfer to stop with an error code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user pointer passed in to the callback in the *userdata* argument is set
    with `CURLOPT_DEBUGDATA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: sockopt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: sockopt callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The sockopt callback is set with `CURLOPT_SOCKOPTFUNCTION`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sockopt_callback` function must match this prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This callback function gets called by libcurl when a new socket has been created
    but before the connect call, to allow applications to change specific socket options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **clientp** pointer points to the private data set with `CURLOPT_SOCKOPTDATA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This callback should return:'
  prefs: []
  type: TYPE_NORMAL
- en: CURL_SOCKOPT_OK on success
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CURL_SOCKOPT_ERROR to signal an unrecoverable error to libcurl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CURL_SOCKOPT_ALREADY_CONNECTED to signal success but also that the socket is
    in fact already connected to the destination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSL context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSL context callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Seek and ioctl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: seek and ioctl callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Network data conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Convert to and from network callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Convert from UTF-8 callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Opensocket and closesocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Opensocket and closesocket callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Occasionally you end up in a situation where you want your application to control
    with more precision exactly what socket libcurl will use for its operations. libcurl
    offers this pair of callbacks that replaces libcurl's own call to `socket()` and
    the subsequent `close()` of the same file descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Provide a file descriptor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By setting the `CURLOPT_OPENSOCKETFUNCTION` callback, you can provide a custom
    function to return a file descriptor for libcurl to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `opensocket_callback` function must match this prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The callback gets the *clientp* as first argument, which is simply an opaque
    pointer you set with `CURLOPT_OPENSOCKETDATA`.
  prefs: []
  type: TYPE_NORMAL
- en: The other two arguments pass in data that identifies for what *purpose* and
    *address* the socket is to be used. The *purpose* is a typedef with a value of
    `CURLSOCKTYPE_IPCXN` or `CURLSOCKTYPE_ACCEPT`, basically idenfying in which circumstance
    the socket is created. The "accept" case being when libcurl is used to accept
    an incoming FTP connection for when FTP active mode is used, and all other cases
    when libcurl creates a socket for its own outgoing connections the *IPCXN* value
    is passed in.
  prefs: []
  type: TYPE_NORMAL
- en: The *address* pointer points to a `struct curl_sockaddr` that describes the
    IP address of the network destination for which this socket is created. Your callback
    can for example use this information to whitelist or blacklist specific addresses
    or address ranges.
  prefs: []
  type: TYPE_NORMAL
- en: The socketopen callback is also explicitly allowed to modify the target address
    in that struct, if you would like to offer some sort of network filter or translation
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: The callback should return a file descriptor or `CURL_SOCKET_BAD`, which then
    will cause an unrecoverable error within libcurl and it will eventually return
    `CURLE_COULDNT_CONNECT` from its perform function.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to return a file descriptor that is *already connected* to a server,
    then you must also set the [sockopt callback](callback-sockopt.html) and make
    sure that returns the correct return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `curl_sockaddress` struct looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Socket close callback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The corresponding callback to the open socket is of course the close socket.
    Usually when you provide a custom way to provide a file descriptor you want to
    provide your own cleanup version as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `closesocket_callback` function must match this prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: SSH key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSH key callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: RTSP interleaved data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RTSP interleave callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: FTP matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FTP chunk callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: FTP matching callback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Cleanup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cleanup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous sections we have discussed how to setup handles and how to drive
    the transfers. All transfers will, of course, end up at some point, either successfully
    or with a failure.
  prefs: []
  type: TYPE_NORMAL
- en: Multi API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you have finished a single transfer with the multi API, you use `curl_multi_info_read()`
    to identify exactly which easy handle was completed and you remove that easy handle
    from the multi handle with `curl_multi_remove_handle()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remove the last easy handle from the multi handle so there are no more
    transfers going on, you can close the multi handle like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: easy handle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the easy handle is done serving its purpose, you can close it. If you intend
    to do another transfer, you are however advised to rather reuse the handle rather
    than to close it and create a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t intend to do another transfer with the easy handle, you simply
    ask libcurl to cleanup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Name resolving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Name resolving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most transfers libcurl can do involves a name that first needs to be translated
    to an internet address. That's "name resolving". Using a numerical IP address
    directly in the URL usually avoids the name resolve phase, but in many cases it
    isn't easy to manully replace the name with the IP address.
  prefs: []
  type: TYPE_NORMAL
- en: libcurl tries very hard to [re-use an existing connection](libcurl-connectionreuse.html)
    rather than to create and connection a new one. The function that checks for an
    exsting connection to use is based purely on the name and is performed before
    any name resolving is attempted. That's one of the reasons the re-use is so much
    faster. A transfer using a reused connection will not resolve the host name again.
  prefs: []
  type: TYPE_NORMAL
- en: If no connection can be reused, libcurl resolves the host name to the set of
    addresses it resolves to. Typically this means asking for both IPv4 and IPv6 adddresses
    and there may be a whole set of those returned to libcurl. That set of addresses
    is then tried until one works, or it returns failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'An application can force libcurl to use only an IPv4 or IPv6 resolved address
    by setting `CURLOPT_IPRESOLVE` to the preferred value. For example, ask to only
    use IPv6 addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Name resolver backends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: libcurl can be built to do name resolves in at least three different ways and
    depending on which backend way that was used, it gets a slightly different feature
    set and sometimes modified behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The default backend is invoking the "normal" libc resolver functions in a new
    helper-thread, so that it can still do fine-grained timeouts if wanted and there
    will be no blocking calls involved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On older systems, libcurl uses the standard synchronous name resolver functions.
    They unfortunately make all transfers within a multi handle block during its operation
    and it is much harder to time out nicely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's also support for resolving with the c-ares third party library, which
    supports asynchronous name resolving without the use of threads. This scales better
    to huge number of parallel transfers but it isn't always 100% compatible with
    the native name resolver funtionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a name has been resolved, the result will be put in libcurl's in-memory
    cache so that subsequent resolves of the same name will be near instant for as
    long the name is kept in the DNS cache. By default, each entry is kept in the
    cache for 60 seconds, but that value can be changed with `CURLOPT_DNS_CACHE_TIMEOUT`.
  prefs: []
  type: TYPE_NORMAL
- en: The DNS cache is kept within the easy handle when `curl_easy_perform` is used,
    or within the multi handle when the multi inteface is used. It can also be made
    shared between multiple easy handles using the [share interface](libcurl-sharing.html).
  prefs: []
  type: TYPE_NORMAL
- en: Custom addresses for hosts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes it is handy to provide "fake" addresses to real host names so that
    libcurl will connect to a different address instead of one an actual name resolve
    would suggest.
  prefs: []
  type: TYPE_NORMAL
- en: With the help of the [CURLOPT_RESOLVE](https://curl.haxx.se/libcurl/c/CURLOPT_RESOLVE.html)
    option, an application can pre-populate libcurl's DNS cache with a custom address
    for a given host name and port number.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make libcurl connect to 127.0.0.1 when example.com on port 443 is requested,
    an application can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Since this puts the "fake" address into the DNS cache, it will work even when
    following redirects etc.
  prefs: []
  type: TYPE_NORMAL
- en: Name server options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For libcurl built to use c-ares, there's a few options available that offer
    fine-grained control of what DNS servers to use and how. This is limited to c-ares
    build purely because these are powers that are not available when the standard
    system calls for name name resolving are used.
  prefs: []
  type: TYPE_NORMAL
- en: With `CURLOPT_DNS_SERVERS`, the application can select to use a set of dedicated
    DNS servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `CURLOPT_DNS_INTERFACE` it can tell libcurl which network interface to
    speak DNS over instead of the default one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `CURLOPT_DNS_LOCAL_IP4` and `CURLOPT_DNS_LOCAL_IP6`, the application can
    specify which specific network addresses to bind DNS resolves to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global DNS cache is bad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The is a *deprecated* option called `CURLOPT_DNS_USE_GLOBAL_CACHE` that when
    enabled tells curl to use a global DNS cache. This cache has no locks and stores
    data in a global context that then can be shared by all other easy handles that
    also is set to use the global cache.
  prefs: []
  type: TYPE_NORMAL
- en: This option should only be used by legacy applications and you *should* work
    on converting this over to using the share interface for sharing DNS cache the
    "proper" way. This option will be removed in a future version.
  prefs: []
  type: TYPE_NORMAL
- en: Proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A proxy in a network context is a sort of middle man, a server in between you
    as a client and the remote server you want to communicate with. The client contacts
    the middle man which then goes on to contact the remote server for you.
  prefs: []
  type: TYPE_NORMAL
- en: This sort of proxy use is sometimes used by companies and organizations, in
    which case you are usually required to use them to reach the target server.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different kinds of proxies and different protocols to use
    when communicating with a proxy, and libcurl supports a few of the most common
    proxy protocols. It is important to realize that the protocol used to the proxy
    isn't necessarily the same protocol used to the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: When setting up a transfer with libcurl you need to point out the server name
    and port number of the proxy. You may find that your favorite browsers can do
    this in slightly more advanced ways than libcurl can, and we will get into such
    details in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'libcurl supports the two major proxy types: SOCKS and HTTP proxies. More specifically,
    it supports both SOCKS4 and SOCKS5 with or without remote name lookup, as well
    as both HTTP and HTTPS to the local proxy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to specify which kind of proxy you are talking to is to set
    the scheme part of the proxy host name string (`CURLOPT_PROXY`) to match it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`socks4` - means SOCKS4 with local name resolving'
  prefs: []
  type: TYPE_NORMAL
- en: '`socks4a` - means SOCKS4 with proxy''s name resolving'
  prefs: []
  type: TYPE_NORMAL
- en: '`socks5` - means SOCKS5 with local name resolving'
  prefs: []
  type: TYPE_NORMAL
- en: '`socks5h` - means SOCKS5 with proxy''s name resolving'
  prefs: []
  type: TYPE_NORMAL
- en: '`http` - means HTTP, which always lets the proxy resolve names'
  prefs: []
  type: TYPE_NORMAL
- en: '`https` - means HTTPS **to the proxy**, which always lets the proxy resolve
    names (Note that HTTPS proxy support was added recently, in curl 7.52.0, and it
    still only works with a subset of the TLS libraries: OpenSSL, GnuTLS and NSS.)'
  prefs: []
  type: TYPE_NORMAL
- en: You can also opt to set the type of the proxy with a separate option if you
    prefer to only set the host name, using `CURLOPT_PROXYTYPE`. Similarly, you can
    set the proxy port number to use with `CURLOPT_PROXYPORT`.
  prefs: []
  type: TYPE_NORMAL
- en: Local or proxy name lookup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a section above you can see that different proxy setups allow the name resolving
    to be done by different parties involved in the transfer. You can in several cases
    either have the client resolve the server host name and pass on the IP address
    to the proxy to connect to - which of course assumes that the name lookup works
    accurately on the client system - or you can hand over the name to the proxy to
    have the proxy resolve the name; converting it to an IP address to connect to.
  prefs: []
  type: TYPE_NORMAL
- en: When you are using an HTTP or HTTPS proxy, you always give the name to the proxy
    to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: Which proxy?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Using proxies for various protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: HTTP proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Proxy authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Post transfer info
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Post transfer info
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember how libcurl transfers are associated with an "easy handle"! Each transfer
    has such a handle and when a transfer is completed, before the handle is cleaned
    or reused for another transfer, it can be used to extract information from the
    previous operation.
  prefs: []
  type: TYPE_NORMAL
- en: Your friend for doing this is called `curl_easy_getinfo()` and you tell it which
    specific information you're interested in and it will return that to you if it
    can.
  prefs: []
  type: TYPE_NORMAL
- en: When you use this function, you pass in the easy handle, which information you
    want and a pointer to a variable to hold the answer. You must pass in a pointer
    to a variable of the correct type or you risk that things will go side-ways. These
    information values are designed to be provided *after* the transfer is completed.
  prefs: []
  type: TYPE_NORMAL
- en: The data you receive can be a long, a 'char *', a 'struct curl_slist* ', a double
    or a socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you extract the `Content-Type:` value from the previous HTTP transfer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'but if you want to extract the local port number that was used in that connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Available information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Getinfo option | Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_ACTIVESOCKET | curl_socket_t | The session''s active socket |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_APPCONNECT_TIME | double | Time from start until SSL/SSH handshake
    completed. |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_CERTINFO | struct curl_slist * | Certificate chain |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_CONDITION_UNMET | long | Whether or not a time conditional was met
    |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_CONNECT_TIME | double | Time from start until remote host or proxy
    completed |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_CONTENT_LENGTH_DOWNLOAD | double | Content length from the Content-Length
    header |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_CONTENT_LENGTH_UPLOAD | double | Upload size |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_CONTENT_TYPE | char * | Content type from the Content-Type header
    |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_COOKIELIST | struct curl_slist * | List of all known cookies |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_EFFECTIVE_URL | char * | Last used URL |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_FILETIME | long | Remote time of the retrieved document |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_FTP_ENTRY_PATH | char * | The entry path after logging in to an
    FTP server |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_HEADER_SIZE | long | Number of bytes of all headers received |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_HTTPAUTH_AVAIL | long | Available HTTP authentication methods (bitmask)
    |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_HTTP_CONNECTCODE | long | Last proxy CONNECT response code |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_HTTP_VERSION | long | The http version used in the connection |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_LASTSOCKET | long | Last socket used |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_LOCAL_IP | char * | Local-end IP address of last connection |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_LOCAL_PORT | long | Local-end port of last connection |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_NAMELOOKUP_TIME | double | Time from start until name resolving
    completed |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_NUM_CONNECTS | long | Number of new successful connections used
    for previous transfer |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_OS_ERRNO | long | The errno from the last failure to connect |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_PRETRANSFER_TIME | double | Time from start until just before the
    transfer begins |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_PRIMARY_IP | char * | IP address of the last connection |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_PRIMARY_PORT | long | Port of the last connection |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_PRIVATE | char * | User''s private data pointer |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_PROTOCOL | long | The protocol used for the connection |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_PROXYAUTH_AVAIL | long | Available HTTP proxy authentication methods
    |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_PROXY_SSL_VERIFYRESULT | long | Proxy certificate verification result
    |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_REDIRECT_COUNT | long | Total number of redirects that were followed
    |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_REDIRECT_TIME | double | Time taken for all redirect steps before
    the final transfer |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_REDIRECT_URL | char * | URL a redirect would take you to, had you
    enabled redirects |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_REQUEST_SIZE | long | Number of bytes sent in the issued HTTP requests
    |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_RESPONSE_CODE | long | Last received response code |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_RTSP_CLIENT_CSEQ | long | RTSP CSeq that will next be used |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_RTSP_CSEQ_RECV | long | RTSP CSeq last received |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_RTSP_SERVER_CSEQ | long | RTSP CSeq that will next be expected |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_RTSP_SESSION_ID | char * | RTSP session ID |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_SCHEME | char * | The scheme used for the connection |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_SIZE_DOWNLOAD | double | Number of bytes downloaded |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_SIZE_UPLOAD | double | Number of bytes uploaded |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_SPEED_DOWNLOAD | double | Average download speed |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_SPEED_UPLOAD | double | Average upload speed |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_SSL_ENGINES | struct curl_slist * | A list of OpenSSL crypto engines
    |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_SSL_VERIFYRESULT | long | Certificate verification result |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_STARTTRANSFER_TIME | double | Time from start until just when the
    first byte is received |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_TLS_SESSION | struct curl_slist * | TLS session info that can be
    used for further processing. (**Deprecated option, use CURLINFO_TLS_SSL_PTR instead!**)
    |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_TLS_SSL_PTR | struct curl_slist * | TLS session info that can be
    used for further processing |'
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_TOTAL_TIME | double | Total time of previous transfer |'
  prefs: []
  type: TYPE_TB
- en: Share data between handles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Share data between handles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes applications need to share data between transfers. All easy handles
    added to the same multi handle automatically get a lot of sharing done between
    the handles in that same multi handle, but sometimes that's not exactly what you
    want.
  prefs: []
  type: TYPE_NORMAL
- en: Multi handle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All easy handles added to the same multi handle automatically share [cookies](libcurl-http-cookies.html),
    [connection cache](libcurl-connectionreuse), [dns cache](libcurl-names.html) and
    SSL sessiond id cache.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing between easy handles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: libcurl has a generic "sharing interface", where the application creates a "share
    object" that then holds data that can be shared by any number of easy handles.
    The data is then stored and read from the shared object instead of kept witihn
    the handles that are sharing it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The shared object can be set to share all or any of cookies, conection cache,
    dns cache and SSL sessiond id cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, setting up the share to hold cookies and dns cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '... and then you setup the corresponding transfer to use this share object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Transgers done with this `curl` handle will thus use and store its cookie and
    dns information in the `share` handle. You can set several easy handles to share
    the same share object.
  prefs: []
  type: TYPE_NORMAL
- en: What to share
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`CURL_LOCK_DATA_COOKIE` - set this bit to share cookie jar. Note that each
    easy handle still needs to get its cookie "engine" started properly to start using
    cookies.'
  prefs: []
  type: TYPE_NORMAL
- en: '`CURL_LOCK_DATA_DNS` - the DNS cache is where libcurl stores addresses for
    resolved host names for a while to make subsequent lookups faster.'
  prefs: []
  type: TYPE_NORMAL
- en: '`CURL_LOCK_DATA_SSL_SESSION` - the SSL session ID cache is where libcurl store
    resume information for SSL connections to be able to resume a previous connection
    faster.'
  prefs: []
  type: TYPE_NORMAL
- en: '`CURL_LOCK_DATA_CONNECT` - when set, this handle will use a shared connection
    cache and thus will probably be more likely to find existing connections to re-use
    etc, which may result in faster performance when doing multiple transfers to the
    same host in a serial manner.'
  prefs: []
  type: TYPE_NORMAL
- en: Locking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want have the share object shared by transfers in a multi-threaded environment.
    Perhaps you have a CPU with many cores and you want each core to run its own thread
    and transfer data, but you still want the different transfers to shara data. Then
    you need to set the mutex callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't use threading and you *know* you access the shared object in a
    serial one-at-a-time manner you don't need to set any locks. But if there is ever
    more than one tranfser that access share object at a time, it needs to get mutex
    callbacks setup to prevent data destruction and possibly even crashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since libcurl itself doesn''t know how to lock things or even what threading
    model you''re using, you must make sure to do mutex locks that only allows one
    access at a time. A lock callback for a pthreads-using application could look
    similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'With the corresponding unlock callback could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Unshare
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: API compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API compatibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: libcurl promises API stability and guarantees that your program written today
    will remain working in the future. We don't break compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, we add features, new options and new functions to the APIs but we
    do not change behavior in a non-compatible way or remove functions.
  prefs: []
  type: TYPE_NORMAL
- en: The last time we changed the API in an non-compatible way was for 7.16.0 in
    2006 and we plan to never do it again.
  prefs: []
  type: TYPE_NORMAL
- en: Version numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Curl and libcurl are individually versioned, but they mostly follow each other
    rather closely.
  prefs: []
  type: TYPE_NORMAL
- en: 'The version numbering is always built up using the same system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: X is main version number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Y is release number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Z is patch number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bumping numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of these X.Y.Z numbers will get bumped in every new release. The numbers
    to the right of a bumped number will be reset to zero.
  prefs: []
  type: TYPE_NORMAL
- en: The main version number X is bumped when *really* big, world colliding changes
    are made. The release number Y is bumped when changes are performed or things/features
    are added. The patch number Z is bumped when the changes are mere bugfixes.
  prefs: []
  type: TYPE_NORMAL
- en: It means that after a release 1.2.3, we can release 2.0.0 if something really
    big has been made, 1.3.0 if not that big changes were made or 1.2.4 if mostly
    bugs were fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Bumping, as in increasing the number with 1, is unconditionally only affecting
    one of the numbers (and the ones to the right of it are set to zero). 1 becomes
    2, 3 becomes 4, 9 becomes 10, 88 becomes 89 and 99 becomes 100\. So, after 1.2.9
    comes 1.2.10\. After 3.99.3, 3.100.0 might come.
  prefs: []
  type: TYPE_NORMAL
- en: All original curl source release archives are named according to the libcurl
    version (not according to the curl client version that, as said before, might
    differ).
  prefs: []
  type: TYPE_NORMAL
- en: Which libcurl version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a service to any application that might want to support new libcurl features
    while still being able to build with older versions, all releases have the libcurl
    version stored in the `curl/curlver.h` file using a static numbering scheme that
    can be used for comparison. The version number is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Where XX, YY and ZZ are the main version, release and patch numbers in hexadecimal.
    All three number fields are always represented using two digits (eight bits each).
    1.2.0 would appear as "0x010200" while version 9.11.7 appears as "0x090b07".
  prefs: []
  type: TYPE_NORMAL
- en: This 6-digit hexadecimal number is always a greater number in a more recent
    release. It makes comparisons with greater than and less than work.
  prefs: []
  type: TYPE_NORMAL
- en: 'This number is also available as three separate defines: `LIBCURL_VERSION_MAJOR`,
    `LIBCURL_VERSION_MINOR` and `LIBCURL_VERSION_PATCH`.'
  prefs: []
  type: TYPE_NORMAL
- en: These defines are, of course, only suitable to figure out the version number
    built *just now* and they won't help you figuring out which libcurl version that
    is used at run-time three years from now.
  prefs: []
  type: TYPE_NORMAL
- en: Which libcurl version runs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To figure out which libcurl version that your application is using *right now*,
    `curl_version_info()` is there for you.
  prefs: []
  type: TYPE_NORMAL
- en: Applications should use this function to judge if things are possible to do
    or not, instead of using compile-time checks, as dynamic/DLL libraries can be
    changed independent of applications.
  prefs: []
  type: TYPE_NORMAL
- en: curl_version_info() returns a pointer to a struct with information about version
    numbers and various features and in the running version of libcurl. You call it
    by giving it a special age counter so that libcurl knows the "age" of the libcurl
    that calls it. The age is a define called `CURLVERSION_NOW` and is a counter that
    is increased at irregular intervals throughout the curl development. The age number
    tells libcurl what struct set it can return.
  prefs: []
  type: TYPE_NORMAL
- en: 'You call the function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: curl_version_info_data *ver = curl_version_info( CURLVERSION_NOW );
  prefs: []
  type: TYPE_NORMAL
- en: 'The data will then be pointing at struct that has or at least can have the
    following layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: --libcurl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: curl --libcurl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We actively encourage users to first try out the transfer they want to do with
    the curl command-line tool, and once it works roughly the way you want it to,
    you append the `--libcurl [filename]` option to the command line and run it again.
  prefs: []
  type: TYPE_NORMAL
- en: The `--libcurl` command-line option will create a C program in the provided
    file name. That C program is an application that uses libcurl to run the transfer
    you just had the curl command-line tool do. There are some exceptions and it isn't
    always a 100% match, but you will find that it can serve as an excellent inspiration
    source for what libcurl options you want or can use and what additional arguments
    to provide to them.
  prefs: []
  type: TYPE_NORMAL
- en: If you specify the filename as a single dash, as in `--libcurl -` you will get
    the program written to stdout instead of a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we run a command to just get [http://example.com](http://example.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates `example.c` in the current directory, looking similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Header files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Header files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is only ever one header your libcurl using application needs to include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: That file in turn includes a few other public header files but you can basically
    pretend they don't exist. (Historically speaking, we started out slightly different
    but over time we have stabilized around this form of only using a single one for
    includes.)
  prefs: []
  type: TYPE_NORMAL
- en: Global initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Global initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you do anything libcurl related in your program, you should do a global
    libcurl initialize call with `curl_global_init()`. This is necessary because some
    underlying libraries that libcurl might be using need a call ahead to get setup
    and initialized properly.
  prefs: []
  type: TYPE_NORMAL
- en: curl_global_init() is, unfortunately, not thread safe, so you must ensure that
    you only do it once and never simultaneously with another call. It initializes
    global state so you should only call it once, and once your program is completely
    done using libcurl you can call `curl_global_cleanup()` to free and clean up the
    associated global resources the init call allocated.
  prefs: []
  type: TYPE_NORMAL
- en: libcurl is built to handle the situation where you skip the `curl_global_init()`
    call, but it does so by calling it itself instead (if you didn't do it before
    any actual file transfer starts) and it then uses its own defaults. But beware
    that it is still not thread safe even then, so it might cause some "interesting"
    side effects for you. It is much better to call curl_global_init() yourself in
    a controlled manner.
  prefs: []
  type: TYPE_NORMAL
- en: multi-threading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: libcurl multi-threading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: libcurl is thread safe but has no internal thread synchronization. You may have
    to provide your own locking or change options to properly use libcurl threaded.
    Exactly what is required depends on how libcurl was built. Please refer to the
    [libcurl thread safety](https://curl.haxx.se/libcurl/c/threadsafe.html) webpage,
    which contains the latest information.
  prefs: []
  type: TYPE_NORMAL
- en: curl easy options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Set handle options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You set options in the easy handle to control how that transfer is going to
    be done, or in some cases you can actually set options and modify the transfer's
    behavior while it is in progress. You set options with `curl_easy_setopt()` and
    you provide the handle, the option you want to set and the argument to the option.
    All options take exactly one argument and you must always pass exactly three parameters
    to the curl_easy_setopt() calls.
  prefs: []
  type: TYPE_NORMAL
- en: Since the curl_easy_setopt() call accepts several hundred different options
    and the various options accept a variety of different types of arguments, it is
    very important to read up on the specifics and provide exactly the argument type
    the specific option supports and expects. Passing in the wrong type can lead to
    unexpected side-effects or hard to understand hiccups.
  prefs: []
  type: TYPE_NORMAL
- en: 'The perhaps most important option that every transfer needs, is the URL. libcurl
    cannot perform a transfer without knowing which URL it concerns so you must tell
    it. The URL option name is `CURLOPT_URL` as all options are prefixed with `CURLOPT_`
    and then the descriptive name—all using uppercase letters. An example line setting
    the URL to get the "[http://example.com](http://example.com)" HTTP contents could
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Again: this only sets the option in the handle. It will not do the actual transfer
    or anything. It will basically just tell libcurl to copy the string and if that
    works it returns OK.'
  prefs: []
  type: TYPE_NORMAL
- en: It is, of course, good form to check the return code to see that nothing went
    wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Setting numerical options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since curl_easy_setopt() is a vararg function where the 3rd argument can use
    different types depending on the situation, normal C language type conversion
    cannot be done. So you **must** make sure that you truly pass a 'long' and not
    an 'int' if the documentation tells you so. On architectures where they are the
    same size, you may not get any problems but not all work like that. Similarly,
    for options that accept a 'curl_off_t' type, it is **crucial** that you pass in
    an argument using that type and no other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enforce a long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Enforce a curl_off_t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Get handle options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No, there's no general method to extract the same information you previously
    set with `curl_easy_setopt()`! If you need to be able to extract the information
    again that you set earlier, then we encourage you to keep track of that data yourself
    in your application.
  prefs: []
  type: TYPE_NORMAL
- en: CURLcode return codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CURLcode return code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many libcurl functions return a CURLcode. That's a special libcurl typedefed
    variable for error codes. It returns `CURLE_OK` (which has the value zero) if
    everything is fine and dandy and it returns a non-zero number if a problem was
    detected. There are almost one hundred `CURLcode` errors in use, and you can find
    them all in the `curl/curl.h` header file and documented in the libcurl-errors
    man page.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can convert a CURLcode into a human readable string with the `curl_easy_strerror()`
    function—but be aware that these errors are rarely phrased in a way that is suitable
    for anyone to expose in a UI or to an end user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to get a slightly better error text in case of errors is to set
    the `CURLOPT_ERRORBUFFER` option to point out a buffer in your program and then
    libcurl will store a related error message there before it returns an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Verbose operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verbose operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, we just showed how to get the error as a human readable text as that is
    an excellent help to figure out what went wrong in a particular transfer and often
    explains why it can be done like that or what the problem is for the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next lifesaver when writing libcurl applications that everyone needs to
    know about and needs to use extensively, at least while developing libcurl applications
    or debugging libcurl itself, is to enable "verbose mode" with `CURLOPT_VERBOSE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: When libcurl is told to be verbose it will mention transfer-related details
    and information to stderr while the transfer is ongoing. This is awesome to figure
    out why things fail and to learn exactly what libcurl does when you ask it different
    things. You can redirect the output elsewhere by changing stderr with `CURLOPT_STDERR`
    or you can get even more info in a fancier way with the debug callback (explained
    further in a later section).
  prefs: []
  type: TYPE_NORMAL
- en: Trace everything
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Verbose is certainly fine, but sometimes you need more. libcurl also offers
    a trace callback that in addition to showing you all the stuff the verbose mode
    does, it also passes on *all* data sent and received so that your application
    gets a full trace of everything.
  prefs: []
  type: TYPE_NORMAL
- en: The sent and received data passed to the trace callback is given to the callback
    in its unencrypted form, which can be very handy when working with TLS or SSH
    based protocols when capturing the data off the network for debugging isn't very
    practical.
  prefs: []
  type: TYPE_NORMAL
- en: When you set the `CURLOPT_DEBUGFUNCTION` option, you still need to have `CURLOPT_VERBOSE`
    enabled but with the trace callback set libcurl will use that callback instead
    of its internal handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The trace callback should match a prototype like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**handle** is the easy handle it concerns, **type** describes the particular
    data passed to the callback (data in/out, header in/out, TLS data in/out and "text"),
    **ptr** points to the data being **size** number of bytes. **userp** is the custom
    pointer you set with `CURLOPT_DEBUGDATA`.'
  prefs: []
  type: TYPE_NORMAL
- en: The data pointed to by **ptr** *will not* be zero terminated, but will be exactly
    of the size as told by the **size** argument.
  prefs: []
  type: TYPE_NORMAL
- en: The callback must return 0 or libcurl will consider it an error and abort the
    transfer.
  prefs: []
  type: TYPE_NORMAL
- en: On the curl web site, we host an example called [debug.c](https://curl.haxx.se/libcurl/c/debug.html)
    that includes a simple trace function to get inspiration from.
  prefs: []
  type: TYPE_NORMAL
- en: There are also additional details in the [CURLOPT_DEBUGFUNCTION man page](https://curl.haxx.se/libcurl/c/CURLOPT_DEBUGFUNCTION.html).
  prefs: []
  type: TYPE_NORMAL
- en: libcurl examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: libcurl examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The native API for libcurl is in C so this chapter is focussed on examples written
    in C. But since many language bindings for libcurl are thin, they usually expose
    more or less the same functions and thus they can still be interesting and educational
    for users of other languages, too.
  prefs: []
  type: TYPE_NORMAL
- en: Get a simple HTML page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example just fetches the HTML and sends it to stdout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Get a HTML page in memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example is a variation of the former that instead of sending the data to
    stdout (which often is not what you want), this stores the received data in a
    memory buffer that is made larger as the incoming data grows.
  prefs: []
  type: TYPE_NORMAL
- en: It accomplishes this by usuing the write callback to receive the data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Submit a login form over HTTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Get an FTP directory listing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Download an HTTPS page straight into memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: Upload data to an HTTP site without blocking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: for C++ programmers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: libcurl for C++ programmers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: strings are C strings, not C++ string objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: callback considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
