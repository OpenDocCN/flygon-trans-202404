- en: libcurl basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: libcurl basics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The engine in the curl command-line tool is libcurl. libcurl is also the engine
    in thousands of tools, services and applications out there today, performing their
    Internet data transfers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: C API
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: libcurl is a library of functions that are provided with a C API, for applications
    written in C. You can easily use it from C++ too, with only a few considerations
    (see [libcurl for C++ programmers](libcurl-cplusplus.html). For other languages,
    there exist "bindings" that work as intermediate layers between libcurl the library
    and corresponding functions for the particular language you like.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Transfer oriented
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have designed libcurl to be transfer oriented usually without forcing users
    to be protocol experts or in fact know much at all about networking or the protocols
    involved. You setup a transfer with as many details and specific information as
    you can and want, and then you tell libcurl to perform that transfer.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: That said, networking and protocols are areas with lots of pitfalls and special
    cases so the more you know about these things, the more you will be able to understand
    about libcurl's options and ways of working. Not to mention, such knowledge is
    invaluable when you are debugging and need to understand what to do next when
    things don't go as you intended.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The most basic libcurl using application can be as small as just a couple of
    lines of code, but most applications will, of course, need more code than that.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Simple by default, more on demand
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: libcurl generally does the simple and basic transfer by default, and if you
    want to add more advanced features, you add that by setting the correct options.
    For example, libcurl doesn't support HTTP cookies by default but it does once
    you tell it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: This makes libcurl's behaviors easier to guess and depend on, and also it makes
    it easier to maintain old behavior and add new features. Only applications that
    actually ask for and use the new features will get that behavior.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Easy handle
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Easy handle
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The fundamentals you need to learn with libcurl:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'First you create an "easy handle", which is your handle to a transfer, really:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then you set various options in that handle to control the upcoming transfer.
    Like, this example sets the URL:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating the easy handle and setting options on it doesn't make any transfer
    happen, and usually don't even make much more happen other than libcurl storing
    your wish to be used later when the transfer actually occurs. Lots of syntax checking
    and validation of the input may also be postponed, so just because `curl_easy_setopt`
    didn't complain, it doesn't mean that the input was correct and valid; you may
    get an error returned later.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Read more on [easy options](libcurl-options.html) in its separate section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: All options are "sticky". They remain set in the handle until you change them
    again, or call `curl_easy_reset()` on the handle.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: When you are done setting options to your easy handle, you can fire off the
    actual transfer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The actual "perform the transfer phase" can be done using different means and
    function calls, depending on what kind of behavior you want in your application
    and how libcurl is best integrated into your architecture. Those are further described
    later in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的"执行传输阶段"可以通过不同的方式和函数调用来完成，具体取决于您的应用程序中需要的行为以及libcurl如何最好地集成到您的架构中。这些稍后在本章中进一步描述。
- en: After the transfer has completed, you can figure out if it succeeded or not
    and you can extract stats and various information that libcurl gathered during
    the transfer from the easy handle. See [Post transfer information](libcurl-getinfo.html).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 传输完成后，您可以确定是否成功，还可以从easy句柄中提取libcurl在传输过程中收集的统计信息和各种信息。请参阅[传输后信息](libcurl-getinfo.html)。
- en: While the transfer is ongoing, libcurl calls your specified functions—known
    as *[callbacks](libcurl-callbacks.md])*—to deliver data, to read data or to do
    a wide variety of things.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输进行时，libcurl会调用您指定的函数—称为*[回调](libcurl-callbacks.md)*—来传递数据，读取数据或执行各种操作。
- en: Reuse!
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复用！
- en: Easy handles are meant and designed to be reused. When you have done a single
    transfer with the easy handle, you can immediately use it again for your next
    transfer. There are lots of gains to be had by this.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: easy句柄旨在被重复使用和设计。当您使用easy句柄进行单个传输后，您可以立即再次使用它进行下一次传输。这样做可以获得很多好处。
- en: Drive transfers
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动传输
- en: '"Drive" transfers'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '"驱动"传输'
- en: libcurl provides three different ways to perform the transfer. Which way to
    use in your case is entirely up to you and what you need.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl提供三种不同的传输方式。在您的情况下使用哪种方式完全取决于您的需求。
- en: The 'easy' interface lets you do a single transfer in a synchronous fashion.
    libcurl will do the entire transfer and return control back to your application
    when it is completed—successful or failed.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '''easy''接口允许您以同步方式进行单个传输。当传输完成时，libcurl将完成整个传输并将控制权返回给您的应用程序—无论成功与否。'
- en: The 'multi' interface is for when you want to do more than one transfer at the
    same time, or you just want a non-blocking transfer.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '''multi''接口用于同时进行多个传输，或者您只想要一个非阻塞传输。'
- en: The 'multi_socket' interface is a slight variation of the regular multi one,
    but is event-based and is really the suggested API to use if you intend to scale
    up the number of simultaneous transfers to hundreds or thousands or so.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '''multi_socket''接口是常规multi接口的轻微变体，但是基于事件，并且如果您打算将同时传输的数量扩展到数百或数千个，这确实是建议使用的API。'
- en: Let's look at each one a little closer…
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看每一个...
- en: Drive with easy
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用easy进行驱动
- en: Driving with the easy interface
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用easy接口进行驱动
- en: 'The name ''easy'' was picked simply because this is really the easy way to
    use libcurl, and with easy, of course, comes a few limitations. Like, for example,
    that it can only do one transfer at a time and that it does the entire transfer
    in a single function call and returns once it is completed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 名称'easy'之所以被选中，只是因为这确实是使用libcurl的简单方式，当然，简单也意味着一些限制。比如，它一次只能进行一次传输，并且它在单个函数调用中完成整个传输，一旦完成就返回：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the server is slow, if the transfer is large or if you have some unpleasant
    timeouts in the network or similar, this function call can end up taking a very
    long time. You can, of course, set timeouts to not allow it to spend more than
    N seconds, but it could still mean a substantial amount of time depending on the
    particular conditions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器很慢，传输很大，或者网络中存在一些不愉快的超时等情况，这个函数调用可能需要很长时间。当然，您可以设置超时时间，不允许它花费超过N秒，但根据特定条件，这仍可能意味着相当长的时间。
- en: If you want your application to do something else while libcurl is transferring
    with the easy interface, you need to use multiple threads. If you want to do multiple
    simultaneous transfers when using the easy interface, you need to perform each
    of the transfers in its own thread.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在libcurl使用easy接口进行传输时，应用程序执行其他操作，您需要使用多个线程。如果您希望在使用easy接口时进行多个同时传输，您需要在各自的线程中执行每个传输。
- en: Drive with multi
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用multi进行驱动
- en: Driving with the multi interface
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用multi接口进行驱动
- en: The name 'multi' is for multiple, as in multiple parallel transfers, all done
    in the same single thread. The multi API is non-blocking so it can also make sense
    to use it for single transfers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 名称'multi'是指多个，即多个并行传输，全部在同一个单线程中完成。multi API是非阻塞的，因此对于单个传输也可以使用它。
- en: 'The transfer is still set in an "easy" `CURL *` handle as described [above](libcurl-easyhandle.html),
    but with the multi interface you also need a multi `CURLM *` handle created and
    use that to drive all the individual transfers. The multi handle can "hold" one
    or many easy handles:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 传输仍然设置在一个"easy" `CURL *`句柄中，如上所述，但是使用多接口时，您还需要创建一个多`CURLM *`句柄并使用它来驱动所有单个传输。多句柄可以"持有"一个或多个易句柄：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A multi handle can also get certain options set, which you do with `curl_multi_setopt()`,
    but in the simplest case you might not have anything to set there.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 多句柄还可以设置某些选项，您可以使用`curl_multi_setopt()`来设置，但在最简单的情况下，您可能没有任何需要设置的内容。
- en: To drive a multi interface transfer, you first need to add all the individual
    easy handles that should be transferred to the multi handle. You can add them
    to the multi handle at any point and you can remove them again whenever you like.
    Removing an easy handle from a multi handle will, of course, remove the association
    and that particular transfer would stop immediately.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行多接口传输，首先需要将所有应该传输到多句柄的单个易句柄添加到其中。您可以在任何时候将它们添加到多句柄中，并且可以在任何时候将它们移除。从多句柄中移除一个易句柄将会移除关联，特定的传输将立即停止。
- en: 'Adding an easy handle to the multi handle is very easy:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将易句柄添加到多句柄非常容易：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Removing one is just as easily done:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 移除一个易句柄同样容易：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Having added the easy handles representing the transfers you want to perform,
    you write the transfer loop. With the multi interface, you do the looping so you
    can ask libcurl for a set of file descriptors and a timeout value and do the `select()`
    call yourself, or you can use the slightly simplified version which does that
    for us, with `curl_multi_wait`. The simplest loop would basically be this: (*note
    that a real application would check return codes*)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了代表您要执行的传输的易句柄后，您编写传输循环。使用多接口，您进行循环，这样您可以向libcurl询问一组文件描述符和一个超时值，并自己进行`select()`调用，或者您可以使用稍微简化的版本，它会为我们执行这些操作，使用`curl_multi_wait`。最简单的循环基本上是这样的：（*请注意，真实应用程序应检查返回代码*）
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The fourth argument to `curl_multi_wait`, set to 1000 in the example above,
    is a timeout in milliseconds. It is the longest time the function will wait for
    any activity before it returns anyway. You don't want to lock up for too long
    before calling `curl_multi_perform` again as there are timeouts, progress callbacks
    and more that may loose precision if you do so.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl_multi_wait`的第四个参数，在上面的示例中设置为1000，是以毫秒为单位的超时时间。这是函数在返回之前等待任何活动的最长时间。在再次调用`curl_multi_perform`之前不要等待太长时间，因为存在超时、进度回调等，如果这样做可能会失去精度。'
- en: 'To instead do select() on our own, we extract the file descriptors and timeout
    value from libcurl like this (*note that a real application would check return
    codes*):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要改为在我们自己上执行select()，我们从libcurl中提取文件描述符和超时值，如下所示（*请注意，真实应用程序应检查返回代码*）：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Both these loops let you use one or more file descriptors of your own on which
    to wait, like if you read from your own sockets or a pipe or similar.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个循环都让您可以使用一个或多个自己的文件描述符进行等待，就像如果您从自己的套接字或管道等读取一样。
- en: And again, you can add and remove easy handles to the multi handle at any point
    during the looping. Removing a handle mid-transfer will, of course, abort that
    transfer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，您可以在循环期间的任何时候添加和移除易句柄到多句柄。在传输过程中移除句柄将中止该传输。
- en: When is a single transfer done?
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时完成单个传输？
- en: As the examples above show, a program can detect when an individual transfer
    completes by seeing that the `transfers_running` variable decreases.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面的示例所示，程序可以通过观察`transfers_running`变量减少来检测单个传输何时完成。
- en: It can also call `curl_multi_info_read()`, which will return a pointer to a
    struct (a "message") if a transfer has ended and you can then find out the result
    of that transfer using that struct.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以调用`curl_multi_info_read()`，如果传输已结束，它将返回指向一个结构体（一个"消息"）的指针，然后您可以使用该结构体了解该传输的结果。
- en: When you do multiple parallel transfers, more than one transfer can of course
    complete in the same `curl_multi_perform` invocation and then you might need more
    than one call to `curl_multi_info_read` to get info about each completed transfer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当您进行多个并行传输时，当然可以在同一次`curl_multi_perform`调用中完成多个传输，然后您可能需要多次调用`curl_multi_info_read`来获取每个已完成传输的信息。
- en: Drive with multi_socket
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用multi_socket进行驱动
- en: Driving with the "multi_socket" interface
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用"multi_socket"接口进行驱动
- en: multi_socket is the extra spicy version of the regular multi interface and is
    designed for event-driven applications. Make sure you read the [Drive with multi
    interface](libcurl-drive-multi.html) section first.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: multi_socket 是常规多接口的额外辣味版本，专为事件驱动的应用程序设计。确保你先阅读 [使用多接口进行驱动](libcurl-drive-multi.html)
    部分。
- en: multi_socket supports multiple parallel transfers—all done in the same single
    thread—and have been used to run several tens of thousands of transfers in a single
    application. It is usually the API that makes the most sense if you do a large
    number (>100 or so) of parallel transfers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: multi_socket 支持多个并行传输——全部在同一个单线程中完成——并且已被用来在单个应用程序中运行数万次传输。如果你进行大量（>100 或更多）的并行传输，这通常是最合理的
    API。
- en: Event-driven in this case means that your application uses a system level library
    or setup that "subscribes" to a number of sockets and it lets your application
    know when one of those sockets are readable or writable and it tells you exactly
    which one.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况下的事件驱动意味着你的应用程序使用了一个系统级库或设置，它“订阅”了一些套接字，并在其中一个套接字可读或可写时通知你的应用程序，还会告诉你具体是哪个套接字。
- en: This setup allows clients to scale up the number of simultaneous transfers much
    higher than with other systems, and still maintain good performance. The "regular"
    APIs otherwise waste far too much time scanning through lists of all the sockets.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置允许客户端将同时传输的数量扩展到比其他系统更高，并且仍然保持良好的性能。否则，“常规”API会浪费大量时间扫描所有套接字列表。
- en: Pick one
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择一个
- en: There are numerous event based systems to select from out there, and libcurl
    is completely agnostic to which one you use. libevent, libev are libuv three popular
    ones but you can also go directly to your operating system's native solutions
    such as epoll, kqueue, /dev/poll, pollset, Event Completion or I/O Completion
    Ports.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多事件驱动系统可供选择，而 libcurl 完全不关心你使用哪一个。libevent、libev 和 libuv 是三个流行的选项，但你也可以直接使用操作系统的本地解决方案，如
    epoll、kqueue、/dev/poll、pollset、事件完成或 I/O 完成端口。
- en: Many easy handles
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许多 easy 句柄
- en: Just like with the regular multi interface, you add easy handles to a multi
    handle with `curl_multi_add_handle()`. One easy handle for each transfer you want
    to perform.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就像常规多接口一样，你可以使用 `curl_multi_add_handle()` 将 easy 句柄添加到多句柄中。每个传输都需要一个 easy 句柄。
- en: You can add them at any time while the transfers are running and you can also
    similarly remove easy handles at any time using the `curl_multi_remove_handle`
    call. Typically though, you remove a handle only after its transfer is completed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在传输运行时随时添加它们，也可以使用 `curl_multi_remove_handle` 调用类似地随时移除 easy 句柄。不过通常情况下，只有在传输完成后才会移除句柄。
- en: multi_socket callbacks
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多套接字回调
- en: 'As explained above, this event-based mechanism relies on the application to
    know which sockets are used by libcurl and what libcurl waits for on those sockets:
    if it waits for the socket to become readable, writable or both!'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，这种基于事件的机制依赖于应用程序知道 libcurl 使用的是哪些套接字，以及 libcurl 在这些套接字上等待什么：如果它等待套接字变为可读、可写或两者兼具！
- en: It also needs to tell libcurl when its timeout time has expired, as it is control
    of driving everything libcurl can't do it itself. So libcurl must tell the application
    an updated timeout value, too.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它还需要告诉 libcurl 其超时时间已过，因为它负责驱动一切 libcurl 不能自己做。所以 libcurl 必须告诉应用程序一个更新的超时值。
- en: socket_callback
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 套接字回调
- en: 'libcurl informs the application about socket activity to wait for with a callback
    called [CURLMOPT_SOCKETFUNCTION](https://curl.haxx.se/libcurl/c/CURLMOPT_SOCKETFUNCTION.html).
    Your application needs to implement such a function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 通过一个称为 [CURLMOPT_SOCKETFUNCTION](https://curl.haxx.se/libcurl/c/CURLMOPT_SOCKETFUNCTION.html)
    的回调来通知应用程序有关待等待的套接字活动。你的应用程序需要实现这样一个函数：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using this, libcurl will set and remove sockets your application should monitor.
    Your application tells the underlying event-based system to wait for the sockets.
    This callback will be called multiple times if there are multiple sockets to wait
    for, and it will be called again when the status changes and perhaps you should
    switch from waiting for a writable socket to instead wait for it to become readable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式，libcurl 将设置和移除你的应用程序应该监视的套接字。你的应用程序告诉底层事件驱动系统等待这些套接字。如果有多个套接字需要等待，这个回调将被多次调用，并且当状态发生变化时可能需要从等待可写的套接字切换为等待可读的套接字。
- en: 'When one of the sockets that the application is monitoring on libcurl''s behalf
    registers that it becomes readable or writable, as requested, you tell libcurl
    about it by calling `curl_multi_socket_action()` and passing in the affected socket
    and an associated bitmask specifying which socket activity that was registered:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序正在监视的其中一个套接字注册为可读或可写时，如请求的，您通过调用 `curl_multi_socket_action()` 并传入受影响的套接字和指定已注册的套接字活动的关联位掩码来告诉
    libcurl：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: timer_callback
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: timer_callback
- en: The application is in control and will wait for socket activity. But even without
    socket activity there will be things libcurl needs to do. Timeout things, calling
    the progress callback, starting over a retry or failing a transfer that takes
    too long, etc. To make that work, the application must also make sure to handle
    a single-shot timeout that libcurl sets.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序控制并等待套接字活动。但即使没有套接字活动，libcurl 也有事情要做。超时事务，调用进度回调，重新开始重试或失败超时的传输等。为了使其工作，应用程序还必须确保处理
    libcurl 设置的单次超时。
- en: 'libcurl sets the timeout with the timer_callback [CURLMOPT_TIMERFUNCTION](https://curl.haxx.se/libcurl/c/CURLMOPT_TIMERFUNCTION.html):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 使用 timer_callback [CURLMOPT_TIMERFUNCTION](https://curl.haxx.se/libcurl/c/CURLMOPT_TIMERFUNCTION.html)
    来设置超时：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is only one timeout for the application to handle for the entire multi
    handle, no matter how many individual easy handles that have been added or transfers
    that are in progress. The timer callback will be updated with the current nearest-in-time
    period to wait. If libcurl gets called before the timeout expiry time because
    of socket activity, it may very well update the timeout value again before it
    expires.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 整个多 handle 只有一个超时需要应用程序处理，无论已添加了多少个单独的 easy handle 或正在进行多少个传输。定时器回调将被更新为当前最接近的等待时间段。如果因为套接字活动而在超时到期时间之前调用了
    libcurl，它很可能会在它到期之前再次更新超时值。
- en: 'When the event system of your choice eventually tells you that the timer has
    expired, you need to tell libcurl about it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当您选择的事件系统最终告诉您计时器已到期时，您需要告诉 libcurl：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: …in many cases, this will make libcurl call the timer_callback again and set
    a new timeout for the next expiry period.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: …在许多情况下，这将使 libcurl 再次调用 timer_callback 并设置下一个到期周期的新超时。
- en: How to start everything
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何开始一切
- en: When you have added one or more easy handles to the multi handle and set the
    socket and timer callbacks in the multi handle, you are ready to start the transfer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将一个或多个 easy handle 添加到多 handle 并在多 handle 中设置套接字和计时器回调后，您就可以开始传输了。
- en: 'To kick it all off, you tell libcurl it timed out (because all easy handles
    start out with a very, very short timeout) which will make libcurl call the callbacks
    to set things up and from then on you can can just let your event system drive:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始一切，您告诉 libcurl 它超时了（因为所有的 easy handle 都是从非常非常短的超时时间开始的），这将使 libcurl 调用回调函数来设置事物，并从此你可以让你的事件系统驱动：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When is it done?
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么时候完成？
- en: The 'running_handles' counter returned by `curl_multi_socket_action` holds the
    number of current transfers not completed. When that number reaches zero, we know
    there are no transfers going on.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `curl_multi_socket_action` 返回的 'running_handles' 计数器保存了当前尚未完成的传输数量。当该数字达到零时，我们知道没有传输正在进行。
- en: Each time the 'running_handles' counter changes, `curl_multi_info_read()` will
    return info about the specific transfers that completed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 'running_handles' 计数器更改时，`curl_multi_info_read()` 将返回有关已完成的特定传输的信息。
- en: Connection reuse
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接重用
- en: Connection reuse
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接重用
- en: libcurl keeps a pool of old connections alive. When one transfer has completed
    it will keep N connections alive in a "connection pool" (sometimes also called
    connection cache) so that a subsequent transfer that happens to be able to reuse
    one of the existing connections can use it instead of creating a new one. Reusing
    a connection instead of creating a new one offers significant benefits in speed
    and required resources.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 保持一组旧连接保持活动状态。当一个传输完成时，它将在一个“连接池”中保持 N 个连接活动（有时也称为连接缓存），以便后续传输能够重用其中一个现有连接而不是创建新连接。重用连接而不是创建新连接在速度和所需资源方面提供了显著的好处。
- en: When libcurl is about to make a new connection for the purposes of doing a transfer,
    it will first check to see if there's an existing connection in the pool that
    it can reuse instead. The connection re-use check is done before any DNS or other
    name resolving mechanism is used, so it is purely host name based. If there's
    an existing live connection to the right host name, a lot of other properties
    (port number, protocol, etc) are also checked to see that it can be used.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当 libcurl 准备为传输建立新连接时，它将首先检查是否有现有连接可重用。连接重用检查在使用任何 DNS 或其他名称解析机制之前进行，因此它完全基于主机名。如果存在到正确主机名的现有活动连接，则还将检查很多其他属性（端口号、协议等）以确保可以使用。
- en: Easy API pool
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 易 API 连接池
- en: When you are using the easy API, or, more specifically, `curl_easy_perform()`,
    libcurl will keep the pool associated with the specific easy handle. Then reusing
    the same easy handle will ensure it can reuse its connection.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用易 API，或者更具体地说，`curl_easy_perform()` 时，libcurl 将保持与特定易句柄关联的池。然后重用相同的易句柄将确保它可以重用其连接。
- en: Multi API pool
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多 API 连接池
- en: When you are using the multi API, the connection pool is instead kept associated
    with the multi handle. This allows you to cleanup and re-create easy handles freely
    without risking losing the connection pool, and it allows the connection used
    by one easy handle to get reused by a separate one in a later transfer. Just reuse
    the multi handle!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用多 API 时，连接池将与多句柄关联。这样可以自由清理和重新创建易句柄，而不必担心丢失连接池，并且可以使一个易句柄使用的连接在以后的传输中被另一个易句柄重用。只需重用多句柄！
- en: Sharing the "connection cache"
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享“连接缓存”
- en: Since libcurl 7.57.0, applications can use the [share interface](libcurl-sharing.html)
    to have otherwise independent transfers share the same connection pool.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 自 libcurl 7.57.0 开始，应用程序可以使用[共享接口](libcurl-sharing.html)来共享相同的连接池，否则它们是独立的传输。
- en: Callbacks
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调函数
- en: Callbacks
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调函数
- en: Lots of operations within libcurl are controlled with the use of *callbacks*.
    A callback is a function pointer provided to libcurl that libcurl then calls at
    some point in time to get a particular job done.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 内有很多操作是通过*回调*来控制的。回调是提供给 libcurl 的函数指针，libcurl 在某个时刻调用它以完成特定的工作。
- en: Each callback has its specific documented purpose and it requires that you write
    it with the exact function prototype to accept the correct arguments and return
    the documented return code and return value so that libcurl will perform the way
    you want it to.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每个回调都有其特定的文档化目的，并且要求您用精确的函数原型编写它，以接受正确的参数并返回文档化的返回代码和返回值，以便 libcurl 表现出您希望的方式。
- en: Each callback option also has a companion option that sets the associated "user
    pointer". This user pointer is a pointer that libcurl doesn't touch or care about,
    but just passes on as an argument to the callback. This allows you to, for example,
    pass in pointers to local data all the way through to your callback function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个回调选项还有一个关联的“用户指针”伴侣选项。这个用户指针是 libcurl 不会触及或关心的指针，但只是作为参数传递给回调。这使您可以将指针传递到本地数据，一直到回调函数。
- en: Unless explicitely stated in a libcurl function documentation, it is not legal
    to invoke libcurl functions from within a libcurl callback.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除非在 libcurl 函数文档中明确说明，否则不得在 libcurl 回调函数中调用 libcurl 函数。
- en: Write data
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写数据
- en: Write callback
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写回调
- en: 'The write callback is set with `CURLOPT_WRITEFUNCTION`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 写回调由 `CURLOPT_WRITEFUNCTION` 设置：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `write_callback` function must match this prototype:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`write_callback` 函数必须与此原型匹配：'
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This callback function gets called by libcurl as soon as there is data received
    that needs to be saved. *ptr* points to the delivered data, and the size of that
    data is *size* multiplied with *nmemb*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调函数会在 libcurl 收到需要保存的数据时立即被调用。*ptr* 指向传递的数据，该数据的大小为 *size* 乘以 *nmemb*。
- en: If this callback isn't set, libcurl instead uses 'fwrite' by default.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未设置此回调，则 libcurl 默认使用 'fwrite'。
- en: 'The write callback will be passed as much data as possible in all invokes,
    but it must not make any assumptions. It may be one byte, it may be thousands.
    The maximum amount of body data that will be passed to the write callback is defined
    in the curl.h header file: `CURL_MAX_WRITE_SIZE` (the usual default is 16KB).
    If `CURLOPT_HEADER` is enabled for this transfer, which makes header data get
    passed to the write callback, you can get up to `CURL_MAX_HTTP_HEADER` bytes of
    header data passed into it. This usually means 100KB.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 写入回调将尽可能传递尽可能多的数据，但不得做出任何假设。它可能是一个字节，也可能是数千个字节。将传递给写入回调的主体数据的最大量在curl.h头文件中定义：`CURL_MAX_WRITE_SIZE`（通常默认为16KB）。如果为此传输启用了`CURLOPT_HEADER`，使得头数据传递给写入回调，您可以获得最多`CURL_MAX_HTTP_HEADER`字节的头数据传递给它。这通常意味着100KB。
- en: This function may be called with zero bytes data if the transferred file is
    empty.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传输的文件为空，此函数可能会以零字节数据调用。
- en: The data passed to this function will not be zero terminated! You cannot, for
    example, use printf's "%s" operator to display the contents nor strcpy to copy
    it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给此函数的数据不会以零结尾！例如，您不能使用printf的“％s”运算符显示内容，也不能使用strcpy复制它。
- en: This callback should return the number of bytes actually taken care of. If that
    number differs from the number passed to your callback function, it will signal
    an error condition to the library. This will cause the transfer to get aborted
    and the libcurl function used will return `CURLE_WRITE_ERROR`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调函数应返回实际处理的字节数。如果该数字与传递给回调函数的数字不同，它将向库发出错误信号。这将导致传输中止，并且使用的libcurl函数将返回`CURLE_WRITE_ERROR`。
- en: 'The user pointer passed in to the callback in the *userdata* argument is set
    with `CURLOPT_WRITEDATA`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给回调函数中*userdata*参数的用户指针是使用`CURLOPT_WRITEDATA`设置的：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Read data
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取数据
- en: Read callback
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取回调
- en: 'The read callback is set with `CURLOPT_READFUNCTION`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 读取回调函数是通过`CURLOPT_READFUNCTION`设置的：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `read_callback` function must match this prototype:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_callback`函数必须匹配此原型：'
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This callback function gets called by libcurl when it wants to send data to
    the server. This is a transfer that you have set up to upload data or otherwise
    send it off to the server. This callback will be called over and over until all
    data has been delivered or the transfer failed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当libcurl希望将数据发送到服务器时，将调用此回调函数。这是您设置的用于上传数据或以其他方式将其发送到服务器的传输。此回调将一遍又一遍地调用，直到所有数据已传递或传输失败。
- en: 'The **stream** pointer points to the private data set with `CURLOPT_READDATA`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**stream**指针指向使用`CURLOPT_READDATA`设置的私有数据：'
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If this callback isn't set, libcurl instead uses 'fread' by default.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未设置此回调函数，libcurl将默认使用'fread'。
- en: The data area pointed at by the pointer **buffer** should be filled up with
    at most **size** multiplied with **nitems** number of bytes by your function.
    The callback should then return the number of bytes that it stored in that memory
    area, or 0 if we have reached the end of the data. The callback can also return
    a few "magic" return codes to cause libcurl to return failure immediately or to
    pause the particular transfer. See the [CURLOPT_READFUNCTION man page](https://curl.haxx.se/libcurl/c/CURLOPT_READFUNCTION.html)
    for details.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 指针**buffer**指向的数据区域应由您的函数用最多**size**乘以**nitems**字节数填充。然后，回调应返回存储在该内存区域中的字节数，如果已达到数据的末尾，则返回0。回调还可以返回一些“魔术”返回代码，以立即导致libcurl立即返回失败或暂停特定传输。有关详细信息，请参阅[CURLOPT_READFUNCTION
    man page](https://curl.haxx.se/libcurl/c/CURLOPT_READFUNCTION.html)。
- en: Progress information
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进度信息
- en: Progress callback
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进度回调
- en: 'The progress callback is what gets called regularly and repeatedly for each
    transfer during the entire lifetime of the transfer. The old callback was set
    with `CURLOPT_PROGRESSFUNCTION` but the modern and preferred callback is set with
    `CURLOPT_XFERINFOFUNCTION`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 进度回调是在整个传输的整个生命周期中定期和重复地为每个传输调用的。旧的回调是使用`CURLOPT_PROGRESSFUNCTION`设置的，但现代和首选的回调是使用`CURLOPT_XFERINFOFUNCTION`设置的：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `xfer_callback` function must match this prototype:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`xfer_callback`函数必须匹配此原型：'
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If this option is set and `CURLOPT_NOPROGRESS` is set to 0 (zero), this callback
    function gets called by libcurl with a frequent interval. While data is being
    transferred it will be called very frequently, and during slow periods like when
    nothing is being transferred it can slow down to about one call per second.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了此选项，并且`CURLOPT_NOPROGRESS`设置为0（零），则libcurl会以频繁的间隔调用此回调函数。在数据传输时，它将被非常频繁地调用，而在没有传输任何内容时，它可能会减慢到每秒约一次的速度。
- en: 'The **clientp** pointer points to the private data set with `CURLOPT_XFERINFODATA`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The callback gets told how much data libcurl will transfer and has transferred,
    in number of bytes:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '**dltotal** is the total number of bytes libcurl expects to download in this
    transfer.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dlnow** is the number of bytes downloaded so far.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ultotal** is the total number of bytes libcurl expects to upload in this
    transfer.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ulnow** is the number of bytes uploaded so far.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unknown/unused argument values passed to the callback will be set to zero (like
    if you only download data, the upload size will remain 0). Many times the callback
    will be called one or more times first, before it knows the data sizes, so a program
    must be made to handle that.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Returning a non-zero value from this callback will cause libcurl to abort the
    transfer and return `CURLE_ABORTED_BY_CALLBACK`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: If you transfer data with the multi interface, this function will not be called
    during periods of idleness unless you call the appropriate libcurl function that
    performs transfers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: (The deprecated callback `CURLOPT_PROGRESSFUNCTION` worked identically but instead
    of taking arguments of type `curl_off_t`, it used `double`.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Header data
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Header callback
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The header callback is set with `CURLOPT_HEADERFUNCTION`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `header_callback` function must match this prototype:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This callback function gets called by libcurl as soon as a header has been received.
    *ptr* points to the delivered data, and the size of that data is *size* multiplied
    with *nmemb*. libcurl buffers headers and delivers only "full" headers, one by
    one, to this callback.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The data passed to this function will not be zero terminated! You cannot, for
    example, use printf's "%s" operator to display the contents nor strcpy to copy
    it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: This callback should return the number of bytes actually taken care of. If that
    number differs from the number passed to your callback function, it signals an
    error condition to the library. This will cause the transfer to abort and the
    libcurl function used will return `CURLE_WRITE_ERROR`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'The user pointer passed in to the callback in the *userdata* argument is set
    with `CURLOPT_HEADERDATA`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Debug
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debug callback
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The debug callback is set with `CURLOPT_DEBUGFUNCTION`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `debug_callback` function must match this prototype:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This callback function replaces the default verbose output function in the
    library and will get called for all debug and trace messages to aid applications
    to understand what''s going on. The *type* argument explains what sort of data
    that is provided: header, data or SSL data and in which direction it flows.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: A common use for this callback is to get a full trace of all data that libcurl
    sends and receives. The data sent to this callback is always the unencrypted version,
    even when, for example, HTTPS or other encrypted protocols are used.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: This callback must return zero or cause the transfer to stop with an error code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'The user pointer passed in to the callback in the *userdata* argument is set
    with `CURLOPT_DEBUGDATA`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: sockopt
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: sockopt callback
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The sockopt callback is set with `CURLOPT_SOCKOPTFUNCTION`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `sockopt_callback` function must match this prototype:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This callback function gets called by libcurl when a new socket has been created
    but before the connect call, to allow applications to change specific socket options.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The **clientp** pointer points to the private data set with `CURLOPT_SOCKOPTDATA`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This callback should return:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: CURL_SOCKOPT_OK on success
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CURL_SOCKOPT_ERROR to signal an unrecoverable error to libcurl
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CURL_SOCKOPT_ALREADY_CONNECTED to signal success but also that the socket is
    in fact already connected to the destination
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSL context
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSL context callback
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TBD
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Seek and ioctl
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: seek and ioctl callbacks
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TBD
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Network data conversion
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Convert to and from network callbacks
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TBD
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Convert from UTF-8 callback
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TBD
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Opensocket and closesocket
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Opensocket and closesocket callbacks
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Occasionally you end up in a situation where you want your application to control
    with more precision exactly what socket libcurl will use for its operations. libcurl
    offers this pair of callbacks that replaces libcurl's own call to `socket()` and
    the subsequent `close()` of the same file descriptor.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Provide a file descriptor
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By setting the `CURLOPT_OPENSOCKETFUNCTION` callback, you can provide a custom
    function to return a file descriptor for libcurl to use:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `opensocket_callback` function must match this prototype:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The callback gets the *clientp* as first argument, which is simply an opaque
    pointer you set with `CURLOPT_OPENSOCKETDATA`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The other two arguments pass in data that identifies for what *purpose* and
    *address* the socket is to be used. The *purpose* is a typedef with a value of
    `CURLSOCKTYPE_IPCXN` or `CURLSOCKTYPE_ACCEPT`, basically idenfying in which circumstance
    the socket is created. The "accept" case being when libcurl is used to accept
    an incoming FTP connection for when FTP active mode is used, and all other cases
    when libcurl creates a socket for its own outgoing connections the *IPCXN* value
    is passed in.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The *address* pointer points to a `struct curl_sockaddr` that describes the
    IP address of the network destination for which this socket is created. Your callback
    can for example use this information to whitelist or blacklist specific addresses
    or address ranges.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The socketopen callback is also explicitly allowed to modify the target address
    in that struct, if you would like to offer some sort of network filter or translation
    layer.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The callback should return a file descriptor or `CURL_SOCKET_BAD`, which then
    will cause an unrecoverable error within libcurl and it will eventually return
    `CURLE_COULDNT_CONNECT` from its perform function.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: If you want to return a file descriptor that is *already connected* to a server,
    then you must also set the [sockopt callback](callback-sockopt.html) and make
    sure that returns the correct return value.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'The `curl_sockaddress` struct looks like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Socket close callback
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The corresponding callback to the open socket is of course the close socket.
    Usually when you provide a custom way to provide a file descriptor you want to
    provide your own cleanup version as well:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `closesocket_callback` function must match this prototype:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: SSH key
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSH key callback
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TBD
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: RTSP interleaved data
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RTSP interleave callback
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TBD
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: FTP matching
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FTP chunk callbacks
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TBD
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: FTP matching callback
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TBD
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Cleanup
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cleanup
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous sections we have discussed how to setup handles and how to drive
    the transfers. All transfers will, of course, end up at some point, either successfully
    or with a failure.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Multi API
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you have finished a single transfer with the multi API, you use `curl_multi_info_read()`
    to identify exactly which easy handle was completed and you remove that easy handle
    from the multi handle with `curl_multi_remove_handle()`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remove the last easy handle from the multi handle so there are no more
    transfers going on, you can close the multi handle like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: easy handle
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the easy handle is done serving its purpose, you can close it. If you intend
    to do another transfer, you are however advised to rather reuse the handle rather
    than to close it and create a new one.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t intend to do another transfer with the easy handle, you simply
    ask libcurl to cleanup:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Name resolving
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Name resolving
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most transfers libcurl can do involves a name that first needs to be translated
    to an internet address. That's "name resolving". Using a numerical IP address
    directly in the URL usually avoids the name resolve phase, but in many cases it
    isn't easy to manully replace the name with the IP address.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: libcurl tries very hard to [re-use an existing connection](libcurl-connectionreuse.html)
    rather than to create and connection a new one. The function that checks for an
    exsting connection to use is based purely on the name and is performed before
    any name resolving is attempted. That's one of the reasons the re-use is so much
    faster. A transfer using a reused connection will not resolve the host name again.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: If no connection can be reused, libcurl resolves the host name to the set of
    addresses it resolves to. Typically this means asking for both IPv4 and IPv6 adddresses
    and there may be a whole set of those returned to libcurl. That set of addresses
    is then tried until one works, or it returns failure.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'An application can force libcurl to use only an IPv4 or IPv6 resolved address
    by setting `CURLOPT_IPRESOLVE` to the preferred value. For example, ask to only
    use IPv6 addresses:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Name resolver backends
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: libcurl can be built to do name resolves in at least three different ways and
    depending on which backend way that was used, it gets a slightly different feature
    set and sometimes modified behavior.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The default backend is invoking the "normal" libc resolver functions in a new
    helper-thread, so that it can still do fine-grained timeouts if wanted and there
    will be no blocking calls involved.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On older systems, libcurl uses the standard synchronous name resolver functions.
    They unfortunately make all transfers within a multi handle block during its operation
    and it is much harder to time out nicely.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's also support for resolving with the c-ares third party library, which
    supports asynchronous name resolving without the use of threads. This scales better
    to huge number of parallel transfers but it isn't always 100% compatible with
    the native name resolver funtionality.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Caching
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a name has been resolved, the result will be put in libcurl's in-memory
    cache so that subsequent resolves of the same name will be near instant for as
    long the name is kept in the DNS cache. By default, each entry is kept in the
    cache for 60 seconds, but that value can be changed with `CURLOPT_DNS_CACHE_TIMEOUT`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The DNS cache is kept within the easy handle when `curl_easy_perform` is used,
    or within the multi handle when the multi inteface is used. It can also be made
    shared between multiple easy handles using the [share interface](libcurl-sharing.html).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Custom addresses for hosts
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes it is handy to provide "fake" addresses to real host names so that
    libcurl will connect to a different address instead of one an actual name resolve
    would suggest.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: With the help of the [CURLOPT_RESOLVE](https://curl.haxx.se/libcurl/c/CURLOPT_RESOLVE.html)
    option, an application can pre-populate libcurl's DNS cache with a custom address
    for a given host name and port number.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'To make libcurl connect to 127.0.0.1 when example.com on port 443 is requested,
    an application can do:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Since this puts the "fake" address into the DNS cache, it will work even when
    following redirects etc.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Name server options
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For libcurl built to use c-ares, there's a few options available that offer
    fine-grained control of what DNS servers to use and how. This is limited to c-ares
    build purely because these are powers that are not available when the standard
    system calls for name name resolving are used.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: With `CURLOPT_DNS_SERVERS`, the application can select to use a set of dedicated
    DNS servers.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `CURLOPT_DNS_INTERFACE` it can tell libcurl which network interface to
    speak DNS over instead of the default one.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `CURLOPT_DNS_LOCAL_IP4` and `CURLOPT_DNS_LOCAL_IP6`, the application can
    specify which specific network addresses to bind DNS resolves to.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global DNS cache is bad
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The is a *deprecated* option called `CURLOPT_DNS_USE_GLOBAL_CACHE` that when
    enabled tells curl to use a global DNS cache. This cache has no locks and stores
    data in a global context that then can be shared by all other easy handles that
    also is set to use the global cache.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: This option should only be used by legacy applications and you *should* work
    on converting this over to using the share interface for sharing DNS cache the
    "proper" way. This option will be removed in a future version.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Proxies
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proxies
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A proxy in a network context is a sort of middle man, a server in between you
    as a client and the remote server you want to communicate with. The client contacts
    the middle man which then goes on to contact the remote server for you.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: This sort of proxy use is sometimes used by companies and organizations, in
    which case you are usually required to use them to reach the target server.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: There are several different kinds of proxies and different protocols to use
    when communicating with a proxy, and libcurl supports a few of the most common
    proxy protocols. It is important to realize that the protocol used to the proxy
    isn't necessarily the same protocol used to the remote server.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: When setting up a transfer with libcurl you need to point out the server name
    and port number of the proxy. You may find that your favorite browsers can do
    this in slightly more advanced ways than libcurl can, and we will get into such
    details in later sections.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Proxy types
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'libcurl supports the two major proxy types: SOCKS and HTTP proxies. More specifically,
    it supports both SOCKS4 and SOCKS5 with or without remote name lookup, as well
    as both HTTP and HTTPS to the local proxy.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to specify which kind of proxy you are talking to is to set
    the scheme part of the proxy host name string (`CURLOPT_PROXY`) to match it:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`socks4` - means SOCKS4 with local name resolving'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '`socks4a` - means SOCKS4 with proxy''s name resolving'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '`socks5` - means SOCKS5 with local name resolving'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '`socks5h` - means SOCKS5 with proxy''s name resolving'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '`http` - means HTTP, which always lets the proxy resolve names'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '`https` - means HTTPS **to the proxy**, which always lets the proxy resolve
    names (Note that HTTPS proxy support was added recently, in curl 7.52.0, and it
    still only works with a subset of the TLS libraries: OpenSSL, GnuTLS and NSS.)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: You can also opt to set the type of the proxy with a separate option if you
    prefer to only set the host name, using `CURLOPT_PROXYTYPE`. Similarly, you can
    set the proxy port number to use with `CURLOPT_PROXYPORT`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Local or proxy name lookup
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a section above you can see that different proxy setups allow the name resolving
    to be done by different parties involved in the transfer. You can in several cases
    either have the client resolve the server host name and pass on the IP address
    to the proxy to connect to - which of course assumes that the name lookup works
    accurately on the client system - or you can hand over the name to the proxy to
    have the proxy resolve the name; converting it to an IP address to connect to.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: When you are using an HTTP or HTTPS proxy, you always give the name to the proxy
    to resolve.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Which proxy?
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Using proxies for various protocols
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: HTTP proxy
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS proxy
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Proxy authentication
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Post transfer info
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Post transfer info
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember how libcurl transfers are associated with an "easy handle"! Each transfer
    has such a handle and when a transfer is completed, before the handle is cleaned
    or reused for another transfer, it can be used to extract information from the
    previous operation.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Your friend for doing this is called `curl_easy_getinfo()` and you tell it which
    specific information you're interested in and it will return that to you if it
    can.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: When you use this function, you pass in the easy handle, which information you
    want and a pointer to a variable to hold the answer. You must pass in a pointer
    to a variable of the correct type or you risk that things will go side-ways. These
    information values are designed to be provided *after* the transfer is completed.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The data you receive can be a long, a 'char *', a 'struct curl_slist* ', a double
    or a socket.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you extract the `Content-Type:` value from the previous HTTP transfer:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'but if you want to extract the local port number that was used in that connection:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Available information
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Getinfo option | Type | Description |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_ACTIVESOCKET | curl_socket_t | The session''s active socket |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_APPCONNECT_TIME | double | Time from start until SSL/SSH handshake
    completed. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_CERTINFO | struct curl_slist * | Certificate chain |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_CONDITION_UNMET | long | Whether or not a time conditional was met
    |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_CONNECT_TIME | double | Time from start until remote host or proxy
    completed |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_CONTENT_LENGTH_DOWNLOAD | double | Content length from the Content-Length
    header |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_CONTENT_LENGTH_UPLOAD | double | Upload size |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_CONTENT_TYPE | char * | Content type from the Content-Type header
    |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_COOKIELIST | struct curl_slist * | List of all known cookies |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_EFFECTIVE_URL | char * | Last used URL |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_FILETIME | long | Remote time of the retrieved document |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_FTP_ENTRY_PATH | char * | The entry path after logging in to an
    FTP server |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_HEADER_SIZE | long | Number of bytes of all headers received |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_HTTPAUTH_AVAIL | long | Available HTTP authentication methods (bitmask)
    |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_HTTP_CONNECTCODE | long | Last proxy CONNECT response code |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_HTTP_VERSION | long | The http version used in the connection |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_LASTSOCKET | long | Last socket used |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_LOCAL_IP | char * | Local-end IP address of last connection |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_LOCAL_PORT | long | Local-end port of last connection |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_NAMELOOKUP_TIME | double | Time from start until name resolving
    completed |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_NUM_CONNECTS | long | Number of new successful connections used
    for previous transfer |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_OS_ERRNO | long | The errno from the last failure to connect |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_PRETRANSFER_TIME | double | Time from start until just before the
    transfer begins |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_PRIMARY_IP | char * | IP address of the last connection |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_PRIMARY_PORT | long | Port of the last connection |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_PRIVATE | char * | User''s private data pointer |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_PROTOCOL | long | The protocol used for the connection |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_PROXYAUTH_AVAIL | long | Available HTTP proxy authentication methods
    |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_PROXY_SSL_VERIFYRESULT | long | Proxy certificate verification result
    |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_REDIRECT_COUNT | long | Total number of redirects that were followed
    |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_REDIRECT_TIME | double | Time taken for all redirect steps before
    the final transfer |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_REDIRECT_URL | char * | URL a redirect would take you to, had you
    enabled redirects |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_REQUEST_SIZE | long | Number of bytes sent in the issued HTTP requests
    |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_RESPONSE_CODE | long | Last received response code |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_RTSP_CLIENT_CSEQ | long | RTSP CSeq that will next be used |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_RTSP_CSEQ_RECV | long | RTSP CSeq last received |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_RTSP_SERVER_CSEQ | long | RTSP CSeq that will next be expected |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_RTSP_SESSION_ID | char * | RTSP session ID |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_SCHEME | char * | The scheme used for the connection |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_SIZE_DOWNLOAD | double | Number of bytes downloaded |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_SIZE_UPLOAD | double | Number of bytes uploaded |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_SPEED_DOWNLOAD | double | Average download speed |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_SPEED_UPLOAD | double | Average upload speed |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_SSL_ENGINES | struct curl_slist * | A list of OpenSSL crypto engines
    |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_SSL_VERIFYRESULT | long | Certificate verification result |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_STARTTRANSFER_TIME | double | Time from start until just when the
    first byte is received |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_TLS_SESSION | struct curl_slist * | TLS session info that can be
    used for further processing. (**Deprecated option, use CURLINFO_TLS_SSL_PTR instead!**)
    |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_TLS_SSL_PTR | struct curl_slist * | TLS session info that can be
    used for further processing |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
- en: '| CURLINFO_TOTAL_TIME | double | Total time of previous transfer |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
- en: Share data between handles
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Share data between handles
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes applications need to share data between transfers. All easy handles
    added to the same multi handle automatically get a lot of sharing done between
    the handles in that same multi handle, but sometimes that's not exactly what you
    want.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Multi handle
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All easy handles added to the same multi handle automatically share [cookies](libcurl-http-cookies.html),
    [connection cache](libcurl-connectionreuse), [dns cache](libcurl-names.html) and
    SSL sessiond id cache.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Sharing between easy handles
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: libcurl has a generic "sharing interface", where the application creates a "share
    object" that then holds data that can be shared by any number of easy handles.
    The data is then stored and read from the shared object instead of kept witihn
    the handles that are sharing it.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The shared object can be set to share all or any of cookies, conection cache,
    dns cache and SSL sessiond id cache.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, setting up the share to hold cookies and dns cache:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '... and then you setup the corresponding transfer to use this share object:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Transgers done with this `curl` handle will thus use and store its cookie and
    dns information in the `share` handle. You can set several easy handles to share
    the same share object.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: What to share
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`CURL_LOCK_DATA_COOKIE` - set this bit to share cookie jar. Note that each
    easy handle still needs to get its cookie "engine" started properly to start using
    cookies.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '`CURL_LOCK_DATA_DNS` - the DNS cache is where libcurl stores addresses for
    resolved host names for a while to make subsequent lookups faster.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '`CURL_LOCK_DATA_SSL_SESSION` - the SSL session ID cache is where libcurl store
    resume information for SSL connections to be able to resume a previous connection
    faster.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '`CURL_LOCK_DATA_CONNECT` - when set, this handle will use a shared connection
    cache and thus will probably be more likely to find existing connections to re-use
    etc, which may result in faster performance when doing multiple transfers to the
    same host in a serial manner.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Locking
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want have the share object shared by transfers in a multi-threaded environment.
    Perhaps you have a CPU with many cores and you want each core to run its own thread
    and transfer data, but you still want the different transfers to shara data. Then
    you need to set the mutex callbacks.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: If you don't use threading and you *know* you access the shared object in a
    serial one-at-a-time manner you don't need to set any locks. But if there is ever
    more than one tranfser that access share object at a time, it needs to get mutex
    callbacks setup to prevent data destruction and possibly even crashes.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'Since libcurl itself doesn''t know how to lock things or even what threading
    model you''re using, you must make sure to do mutex locks that only allows one
    access at a time. A lock callback for a pthreads-using application could look
    similar to:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'With the corresponding unlock callback could look like:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Unshare
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: API compatibility
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API compatibility
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: libcurl promises API stability and guarantees that your program written today
    will remain working in the future. We don't break compatibility.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Over time, we add features, new options and new functions to the APIs but we
    do not change behavior in a non-compatible way or remove functions.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: The last time we changed the API in an non-compatible way was for 7.16.0 in
    2006 and we plan to never do it again.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Version numbers
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Curl and libcurl are individually versioned, but they mostly follow each other
    rather closely.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'The version numbering is always built up using the same system:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: X is main version number
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Y is release number
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Z is patch number
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bumping numbers
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of these X.Y.Z numbers will get bumped in every new release. The numbers
    to the right of a bumped number will be reset to zero.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: The main version number X is bumped when *really* big, world colliding changes
    are made. The release number Y is bumped when changes are performed or things/features
    are added. The patch number Z is bumped when the changes are mere bugfixes.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: It means that after a release 1.2.3, we can release 2.0.0 if something really
    big has been made, 1.3.0 if not that big changes were made or 1.2.4 if mostly
    bugs were fixed.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Bumping, as in increasing the number with 1, is unconditionally only affecting
    one of the numbers (and the ones to the right of it are set to zero). 1 becomes
    2, 3 becomes 4, 9 becomes 10, 88 becomes 89 and 99 becomes 100\. So, after 1.2.9
    comes 1.2.10\. After 3.99.3, 3.100.0 might come.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: All original curl source release archives are named according to the libcurl
    version (not according to the curl client version that, as said before, might
    differ).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Which libcurl version
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a service to any application that might want to support new libcurl features
    while still being able to build with older versions, all releases have the libcurl
    version stored in the `curl/curlver.h` file using a static numbering scheme that
    can be used for comparison. The version number is defined as:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Where XX, YY and ZZ are the main version, release and patch numbers in hexadecimal.
    All three number fields are always represented using two digits (eight bits each).
    1.2.0 would appear as "0x010200" while version 9.11.7 appears as "0x090b07".
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: This 6-digit hexadecimal number is always a greater number in a more recent
    release. It makes comparisons with greater than and less than work.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'This number is also available as three separate defines: `LIBCURL_VERSION_MAJOR`,
    `LIBCURL_VERSION_MINOR` and `LIBCURL_VERSION_PATCH`.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: These defines are, of course, only suitable to figure out the version number
    built *just now* and they won't help you figuring out which libcurl version that
    is used at run-time three years from now.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Which libcurl version runs
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To figure out which libcurl version that your application is using *right now*,
    `curl_version_info()` is there for you.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Applications should use this function to judge if things are possible to do
    or not, instead of using compile-time checks, as dynamic/DLL libraries can be
    changed independent of applications.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: curl_version_info() returns a pointer to a struct with information about version
    numbers and various features and in the running version of libcurl. You call it
    by giving it a special age counter so that libcurl knows the "age" of the libcurl
    that calls it. The age is a define called `CURLVERSION_NOW` and is a counter that
    is increased at irregular intervals throughout the curl development. The age number
    tells libcurl what struct set it can return.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'You call the function like this:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: curl_version_info_data *ver = curl_version_info( CURLVERSION_NOW );
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'The data will then be pointing at struct that has or at least can have the
    following layout:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: --libcurl
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: curl --libcurl
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We actively encourage users to first try out the transfer they want to do with
    the curl command-line tool, and once it works roughly the way you want it to,
    you append the `--libcurl [filename]` option to the command line and run it again.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: The `--libcurl` command-line option will create a C program in the provided
    file name. That C program is an application that uses libcurl to run the transfer
    you just had the curl command-line tool do. There are some exceptions and it isn't
    always a 100% match, but you will find that it can serve as an excellent inspiration
    source for what libcurl options you want or can use and what additional arguments
    to provide to them.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: If you specify the filename as a single dash, as in `--libcurl -` you will get
    the program written to stdout instead of a file.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we run a command to just get [http://example.com](http://example.com):'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This creates `example.c` in the current directory, looking similar to this:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Header files
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Header files
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is only ever one header your libcurl using application needs to include:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: That file in turn includes a few other public header files but you can basically
    pretend they don't exist. (Historically speaking, we started out slightly different
    but over time we have stabilized around this form of only using a single one for
    includes.)
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Global initialization
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Global initialization
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you do anything libcurl related in your program, you should do a global
    libcurl initialize call with `curl_global_init()`. This is necessary because some
    underlying libraries that libcurl might be using need a call ahead to get setup
    and initialized properly.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: curl_global_init() is, unfortunately, not thread safe, so you must ensure that
    you only do it once and never simultaneously with another call. It initializes
    global state so you should only call it once, and once your program is completely
    done using libcurl you can call `curl_global_cleanup()` to free and clean up the
    associated global resources the init call allocated.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: libcurl is built to handle the situation where you skip the `curl_global_init()`
    call, but it does so by calling it itself instead (if you didn't do it before
    any actual file transfer starts) and it then uses its own defaults. But beware
    that it is still not thread safe even then, so it might cause some "interesting"
    side effects for you. It is much better to call curl_global_init() yourself in
    a controlled manner.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: multi-threading
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: libcurl multi-threading
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: libcurl is thread safe but has no internal thread synchronization. You may have
    to provide your own locking or change options to properly use libcurl threaded.
    Exactly what is required depends on how libcurl was built. Please refer to the
    [libcurl thread safety](https://curl.haxx.se/libcurl/c/threadsafe.html) webpage,
    which contains the latest information.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: curl easy options
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Set handle options
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You set options in the easy handle to control how that transfer is going to
    be done, or in some cases you can actually set options and modify the transfer's
    behavior while it is in progress. You set options with `curl_easy_setopt()` and
    you provide the handle, the option you want to set and the argument to the option.
    All options take exactly one argument and you must always pass exactly three parameters
    to the curl_easy_setopt() calls.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Since the curl_easy_setopt() call accepts several hundred different options
    and the various options accept a variety of different types of arguments, it is
    very important to read up on the specifics and provide exactly the argument type
    the specific option supports and expects. Passing in the wrong type can lead to
    unexpected side-effects or hard to understand hiccups.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'The perhaps most important option that every transfer needs, is the URL. libcurl
    cannot perform a transfer without knowing which URL it concerns so you must tell
    it. The URL option name is `CURLOPT_URL` as all options are prefixed with `CURLOPT_`
    and then the descriptive name—all using uppercase letters. An example line setting
    the URL to get the "[http://example.com](http://example.com)" HTTP contents could
    look like:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Again: this only sets the option in the handle. It will not do the actual transfer
    or anything. It will basically just tell libcurl to copy the string and if that
    works it returns OK.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: It is, of course, good form to check the return code to see that nothing went
    wrong.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Setting numerical options
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since curl_easy_setopt() is a vararg function where the 3rd argument can use
    different types depending on the situation, normal C language type conversion
    cannot be done. So you **must** make sure that you truly pass a 'long' and not
    an 'int' if the documentation tells you so. On architectures where they are the
    same size, you may not get any problems but not all work like that. Similarly,
    for options that accept a 'curl_off_t' type, it is **crucial** that you pass in
    an argument using that type and no other.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'Enforce a long:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Enforce a curl_off_t:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Get handle options
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No, there's no general method to extract the same information you previously
    set with `curl_easy_setopt()`! If you need to be able to extract the information
    again that you set earlier, then we encourage you to keep track of that data yourself
    in your application.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: CURLcode return codes
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CURLcode return code
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many libcurl functions return a CURLcode. That's a special libcurl typedefed
    variable for error codes. It returns `CURLE_OK` (which has the value zero) if
    everything is fine and dandy and it returns a non-zero number if a problem was
    detected. There are almost one hundred `CURLcode` errors in use, and you can find
    them all in the `curl/curl.h` header file and documented in the libcurl-errors
    man page.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'You can convert a CURLcode into a human readable string with the `curl_easy_strerror()`
    function—but be aware that these errors are rarely phrased in a way that is suitable
    for anyone to expose in a UI or to an end user:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Another way to get a slightly better error text in case of errors is to set
    the `CURLOPT_ERRORBUFFER` option to point out a buffer in your program and then
    libcurl will store a related error message there before it returns an error:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Verbose operations
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verbose operations
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, we just showed how to get the error as a human readable text as that is
    an excellent help to figure out what went wrong in a particular transfer and often
    explains why it can be done like that or what the problem is for the moment.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'The next lifesaver when writing libcurl applications that everyone needs to
    know about and needs to use extensively, at least while developing libcurl applications
    or debugging libcurl itself, is to enable "verbose mode" with `CURLOPT_VERBOSE`:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: When libcurl is told to be verbose it will mention transfer-related details
    and information to stderr while the transfer is ongoing. This is awesome to figure
    out why things fail and to learn exactly what libcurl does when you ask it different
    things. You can redirect the output elsewhere by changing stderr with `CURLOPT_STDERR`
    or you can get even more info in a fancier way with the debug callback (explained
    further in a later section).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Trace everything
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Verbose is certainly fine, but sometimes you need more. libcurl also offers
    a trace callback that in addition to showing you all the stuff the verbose mode
    does, it also passes on *all* data sent and received so that your application
    gets a full trace of everything.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: The sent and received data passed to the trace callback is given to the callback
    in its unencrypted form, which can be very handy when working with TLS or SSH
    based protocols when capturing the data off the network for debugging isn't very
    practical.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: When you set the `CURLOPT_DEBUGFUNCTION` option, you still need to have `CURLOPT_VERBOSE`
    enabled but with the trace callback set libcurl will use that callback instead
    of its internal handling.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'The trace callback should match a prototype like this:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**handle** is the easy handle it concerns, **type** describes the particular
    data passed to the callback (data in/out, header in/out, TLS data in/out and "text"),
    **ptr** points to the data being **size** number of bytes. **userp** is the custom
    pointer you set with `CURLOPT_DEBUGDATA`.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: The data pointed to by **ptr** *will not* be zero terminated, but will be exactly
    of the size as told by the **size** argument.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: The callback must return 0 or libcurl will consider it an error and abort the
    transfer.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: On the curl web site, we host an example called [debug.c](https://curl.haxx.se/libcurl/c/debug.html)
    that includes a simple trace function to get inspiration from.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: There are also additional details in the [CURLOPT_DEBUGFUNCTION man page](https://curl.haxx.se/libcurl/c/CURLOPT_DEBUGFUNCTION.html).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: libcurl examples
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: libcurl examples
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The native API for libcurl is in C so this chapter is focussed on examples written
    in C. But since many language bindings for libcurl are thin, they usually expose
    more or less the same functions and thus they can still be interesting and educational
    for users of other languages, too.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Get a simple HTML page
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example just fetches the HTML and sends it to stdout:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Get a HTML page in memory
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example is a variation of the former that instead of sending the data to
    stdout (which often is not what you want), this stores the received data in a
    memory buffer that is made larger as the incoming data grows.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: It accomplishes this by usuing the write callback to receive the data.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Submit a login form over HTTP
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: Get an FTP directory listing
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Download an HTTPS page straight into memory
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: Upload data to an HTTP site without blocking
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: for C++ programmers
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: libcurl for C++ programmers
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TBD
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: strings are C strings, not C++ string objects
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: callback considerations
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
