- en: libcurl basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: libcurl 基础知识
- en: libcurl basics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: libcurl 基础知识
- en: The engine in the curl command-line tool is libcurl. libcurl is also the engine
    in thousands of tools, services and applications out there today, performing their
    Internet data transfers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: curl 命令行工具中的引擎是 libcurl。 libcurl 也是今天数千种工具、服务和应用程序中的引擎，执行其互联网数据传输。
- en: C API
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C API
- en: libcurl is a library of functions that are provided with a C API, for applications
    written in C. You can easily use it from C++ too, with only a few considerations
    (see [libcurl for C++ programmers](libcurl-cplusplus.html). For other languages,
    there exist "bindings" that work as intermediate layers between libcurl the library
    and corresponding functions for the particular language you like.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 是提供了 C API 的函数库，用于使用 C 编写的应用程序。您也可以轻松地从 C++ 中使用它，只需考虑几个问题（请参阅[libcurl
    for C++ programmers](libcurl-cplusplus.html)）。对于其他语言，存在“绑定”，它们作为 libcurl 库和您喜欢的特定语言的相应函数之间的中间层工作。
- en: Transfer oriented
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输导向型
- en: We have designed libcurl to be transfer oriented usually without forcing users
    to be protocol experts or in fact know much at all about networking or the protocols
    involved. You setup a transfer with as many details and specific information as
    you can and want, and then you tell libcurl to perform that transfer.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计 libcurl 通常是以传输为导向的，而不是强迫用户成为协议专家，或者实际上对网络或所涉及的协议了解很多。您设置传输时尽可能多的细节和特定信息，然后告诉
    libcurl 执行该传输。
- en: That said, networking and protocols are areas with lots of pitfalls and special
    cases so the more you know about these things, the more you will be able to understand
    about libcurl's options and ways of working. Not to mention, such knowledge is
    invaluable when you are debugging and need to understand what to do next when
    things don't go as you intended.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，网络和协议是充满许多陷阱和特殊情况的领域，所以您对这些事物的了解越多，您就越能够理解 libcurl 的选项和工作方式。更不用说，当您进行调试并需要理解当事情不按您打算的方式进行时下一步该怎么做时，这样的知识是无价的。
- en: The most basic libcurl using application can be as small as just a couple of
    lines of code, but most applications will, of course, need more code than that.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的 libcurl 使用应用程序可能只有几行代码，但大多数应用程序当然需要比那更多的代码。
- en: Simple by default, more on demand
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认简单，按需更多
- en: libcurl generally does the simple and basic transfer by default, and if you
    want to add more advanced features, you add that by setting the correct options.
    For example, libcurl doesn't support HTTP cookies by default but it does once
    you tell it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 通常通过默认方式进行简单和基本的传输，如果您想添加更多高级功能，则通过设置正确的选项来添加。例如，libcurl 默认情况下不支持 HTTP
    cookies，但一旦您告诉它，它就支持了。
- en: This makes libcurl's behaviors easier to guess and depend on, and also it makes
    it easier to maintain old behavior and add new features. Only applications that
    actually ask for and use the new features will get that behavior.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 libcurl 的行为更容易猜测和依赖，并且也使得维护旧行为并添加新功能更容易。只有实际请求并使用新功能的应用程序才会获得该行为。
- en: Easy handle
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Easy 句柄
- en: Easy handle
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Easy 句柄
- en: 'The fundamentals you need to learn with libcurl:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用 libcurl 学习的基本原理：
- en: 'First you create an "easy handle", which is your handle to a transfer, really:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您创建一个“easy 句柄”，这实际上是您对传输的句柄：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then you set various options in that handle to control the upcoming transfer.
    Like, this example sets the URL:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您在该句柄中设置各种选项以控制即将进行的传输。比如，这个示例设置了 URL：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating the easy handle and setting options on it doesn't make any transfer
    happen, and usually don't even make much more happen other than libcurl storing
    your wish to be used later when the transfer actually occurs. Lots of syntax checking
    and validation of the input may also be postponed, so just because `curl_easy_setopt`
    didn't complain, it doesn't mean that the input was correct and valid; you may
    get an error returned later.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 easy 句柄并在其上设置选项不会导致任何传输发生，并且通常甚至不会有更多事情发生，除了 libcurl 存储您希望稍后在传输实际发生时使用的内容。输入的大量语法检查和验证也可能被延迟执行，因此仅因为
    `curl_easy_setopt` 没有抱怨，并不意味着输入是正确和有效的；您可能会在以后收到错误返回。
- en: Read more on [easy options](libcurl-options.html) in its separate section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在其单独的章节中[阅读更多有关 easy 选项的信息](libcurl-options.html)。
- en: All options are "sticky". They remain set in the handle until you change them
    again, or call `curl_easy_reset()` on the handle.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有选项都是“粘性”的。它们会保持在句柄中，直到您再次更改它们，或在句柄上调用`curl_easy_reset()`。
- en: When you are done setting options to your easy handle, you can fire off the
    actual transfer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当您设置了要传输的 easy 句柄的选项后，您就可以开始实际传输。
- en: The actual "perform the transfer phase" can be done using different means and
    function calls, depending on what kind of behavior you want in your application
    and how libcurl is best integrated into your architecture. Those are further described
    later in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的"执行传输阶段"可以通过不同的方式和函数调用来完成，具体取决于您的应用程序中需要的行为以及libcurl如何最好地集成到您的架构中。这些稍后在本章中进一步描述。
- en: After the transfer has completed, you can figure out if it succeeded or not
    and you can extract stats and various information that libcurl gathered during
    the transfer from the easy handle. See [Post transfer information](libcurl-getinfo.html).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 传输完成后，您可以确定是否成功，还可以从easy句柄中提取libcurl在传输过程中收集的统计信息和各种信息。请参阅[传输后信息](libcurl-getinfo.html)。
- en: While the transfer is ongoing, libcurl calls your specified functions—known
    as *[callbacks](libcurl-callbacks.md])*—to deliver data, to read data or to do
    a wide variety of things.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输进行时，libcurl会调用您指定的函数—称为*[回调](libcurl-callbacks.md)*—来传递数据，读取数据或执行各种操作。
- en: Reuse!
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复用！
- en: Easy handles are meant and designed to be reused. When you have done a single
    transfer with the easy handle, you can immediately use it again for your next
    transfer. There are lots of gains to be had by this.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: easy句柄旨在被重复使用和设计。当您使用easy句柄进行单个传输后，您可以立即再次使用它进行下一次传输。这样做可以获得很多好处。
- en: Drive transfers
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动传输
- en: '"Drive" transfers'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '"驱动"传输'
- en: libcurl provides three different ways to perform the transfer. Which way to
    use in your case is entirely up to you and what you need.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl提供三种不同的传输方式。在您的情况下使用哪种方式完全取决于您的需求。
- en: The 'easy' interface lets you do a single transfer in a synchronous fashion.
    libcurl will do the entire transfer and return control back to your application
    when it is completed—successful or failed.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '''easy''接口允许您以同步方式进行单个传输。当传输完成时，libcurl将完成整个传输并将控制权返回给您的应用程序—无论成功与否。'
- en: The 'multi' interface is for when you want to do more than one transfer at the
    same time, or you just want a non-blocking transfer.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '''multi''接口用于同时进行多个传输，或者您只想要一个非阻塞传输。'
- en: The 'multi_socket' interface is a slight variation of the regular multi one,
    but is event-based and is really the suggested API to use if you intend to scale
    up the number of simultaneous transfers to hundreds or thousands or so.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '''multi_socket''接口是常规multi接口的轻微变体，但是基于事件，并且如果您打算将同时传输的数量扩展到数百或数千个，这确实是建议使用的API。'
- en: Let's look at each one a little closer…
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看每一个...
- en: Drive with easy
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用easy进行驱动
- en: Driving with the easy interface
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用easy接口进行驱动
- en: 'The name ''easy'' was picked simply because this is really the easy way to
    use libcurl, and with easy, of course, comes a few limitations. Like, for example,
    that it can only do one transfer at a time and that it does the entire transfer
    in a single function call and returns once it is completed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 名称'easy'之所以被选中，只是因为这确实是使用libcurl的简单方式，当然，简单也意味着一些限制。比如，它一次只能进行一次传输，并且它在单个函数调用中完成整个传输，一旦完成就返回：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the server is slow, if the transfer is large or if you have some unpleasant
    timeouts in the network or similar, this function call can end up taking a very
    long time. You can, of course, set timeouts to not allow it to spend more than
    N seconds, but it could still mean a substantial amount of time depending on the
    particular conditions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器很慢，传输很大，或者网络中存在一些不愉快的超时等情况，这个函数调用可能需要很长时间。当然，您可以设置超时时间，不允许它花费超过N秒，但根据特定条件，这仍可能意味着相当长的时间。
- en: If you want your application to do something else while libcurl is transferring
    with the easy interface, you need to use multiple threads. If you want to do multiple
    simultaneous transfers when using the easy interface, you need to perform each
    of the transfers in its own thread.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在libcurl使用easy接口进行传输时，应用程序执行其他操作，您需要使用多个线程。如果您希望在使用easy接口时进行多个同时传输，您需要在各自的线程中执行每个传输。
- en: Drive with multi
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用multi进行驱动
- en: Driving with the multi interface
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用multi接口进行驱动
- en: The name 'multi' is for multiple, as in multiple parallel transfers, all done
    in the same single thread. The multi API is non-blocking so it can also make sense
    to use it for single transfers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 名称'multi'是指多个，即多个并行传输，全部在同一个单线程中完成。multi API是非阻塞的，因此对于单个传输也可以使用它。
- en: 'The transfer is still set in an "easy" `CURL *` handle as described [above](libcurl-easyhandle.html),
    but with the multi interface you also need a multi `CURLM *` handle created and
    use that to drive all the individual transfers. The multi handle can "hold" one
    or many easy handles:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 传输仍然设置在一个"easy" `CURL *`句柄中，如上所述，但是使用多接口时，您还需要创建一个多`CURLM *`句柄并使用它来驱动所有单个传输。多句柄可以"持有"一个或多个易句柄：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A multi handle can also get certain options set, which you do with `curl_multi_setopt()`,
    but in the simplest case you might not have anything to set there.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 多句柄还可以设置某些选项，您可以使用`curl_multi_setopt()`来设置，但在最简单的情况下，您可能没有任何需要设置的内容。
- en: To drive a multi interface transfer, you first need to add all the individual
    easy handles that should be transferred to the multi handle. You can add them
    to the multi handle at any point and you can remove them again whenever you like.
    Removing an easy handle from a multi handle will, of course, remove the association
    and that particular transfer would stop immediately.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行多接口传输，首先需要将所有应该传输到多句柄的单个易句柄添加到其中。您可以在任何时候将它们添加到多句柄中，并且可以在任何时候将它们移除。从多句柄中移除一个易句柄将会移除关联，特定的传输将立即停止。
- en: 'Adding an easy handle to the multi handle is very easy:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将易句柄添加到多句柄非常容易：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Removing one is just as easily done:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 移除一个易句柄同样容易：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Having added the easy handles representing the transfers you want to perform,
    you write the transfer loop. With the multi interface, you do the looping so you
    can ask libcurl for a set of file descriptors and a timeout value and do the `select()`
    call yourself, or you can use the slightly simplified version which does that
    for us, with `curl_multi_wait`. The simplest loop would basically be this: (*note
    that a real application would check return codes*)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了代表您要执行的传输的易句柄后，您编写传输循环。使用多接口，您进行循环，这样您可以向libcurl询问一组文件描述符和一个超时值，并自己进行`select()`调用，或者您可以使用稍微简化的版本，它会为我们执行这些操作，使用`curl_multi_wait`。最简单的循环基本上是这样的：（*请注意，真实应用程序应检查返回代码*）
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The fourth argument to `curl_multi_wait`, set to 1000 in the example above,
    is a timeout in milliseconds. It is the longest time the function will wait for
    any activity before it returns anyway. You don't want to lock up for too long
    before calling `curl_multi_perform` again as there are timeouts, progress callbacks
    and more that may loose precision if you do so.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl_multi_wait`的第四个参数，在上面的示例中设置为1000，是以毫秒为单位的超时时间。这是函数在返回之前等待任何活动的最长时间。在再次调用`curl_multi_perform`之前不要等待太长时间，因为存在超时、进度回调等，如果这样做可能会失去精度。'
- en: 'To instead do select() on our own, we extract the file descriptors and timeout
    value from libcurl like this (*note that a real application would check return
    codes*):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要改为在我们自己上执行select()，我们从libcurl中提取文件描述符和超时值，如下所示（*请注意，真实应用程序应检查返回代码*）：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Both these loops let you use one or more file descriptors of your own on which
    to wait, like if you read from your own sockets or a pipe or similar.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个循环都让您可以使用一个或多个自己的文件描述符进行等待，就像如果您从自己的套接字或管道等读取一样。
- en: And again, you can add and remove easy handles to the multi handle at any point
    during the looping. Removing a handle mid-transfer will, of course, abort that
    transfer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，您可以在循环期间的任何时候添加和移除易句柄到多句柄。在传输过程中移除句柄将中止该传输。
- en: When is a single transfer done?
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时完成单个传输？
- en: As the examples above show, a program can detect when an individual transfer
    completes by seeing that the `transfers_running` variable decreases.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面的示例所示，程序可以通过观察`transfers_running`变量减少来检测单个传输何时完成。
- en: It can also call `curl_multi_info_read()`, which will return a pointer to a
    struct (a "message") if a transfer has ended and you can then find out the result
    of that transfer using that struct.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以调用`curl_multi_info_read()`，如果传输已结束，它将返回指向一个结构体（一个"消息"）的指针，然后您可以使用该结构体了解该传输的结果。
- en: When you do multiple parallel transfers, more than one transfer can of course
    complete in the same `curl_multi_perform` invocation and then you might need more
    than one call to `curl_multi_info_read` to get info about each completed transfer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当您进行多个并行传输时，当然可以在同一次`curl_multi_perform`调用中完成多个传输，然后您可能需要多次调用`curl_multi_info_read`来获取每个已完成传输的信息。
- en: Drive with multi_socket
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用multi_socket进行驱动
- en: Driving with the "multi_socket" interface
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用"multi_socket"接口进行驱动
- en: multi_socket is the extra spicy version of the regular multi interface and is
    designed for event-driven applications. Make sure you read the [Drive with multi
    interface](libcurl-drive-multi.html) section first.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: multi_socket 是常规多接口的额外辣味版本，专为事件驱动的应用程序设计。确保你先阅读 [使用多接口进行驱动](libcurl-drive-multi.html)
    部分。
- en: multi_socket supports multiple parallel transfers—all done in the same single
    thread—and have been used to run several tens of thousands of transfers in a single
    application. It is usually the API that makes the most sense if you do a large
    number (>100 or so) of parallel transfers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: multi_socket 支持多个并行传输——全部在同一个单线程中完成——并且已被用来在单个应用程序中运行数万次传输。如果你进行大量（>100 或更多）的并行传输，这通常是最合理的
    API。
- en: Event-driven in this case means that your application uses a system level library
    or setup that "subscribes" to a number of sockets and it lets your application
    know when one of those sockets are readable or writable and it tells you exactly
    which one.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况下的事件驱动意味着你的应用程序使用了一个系统级库或设置，它“订阅”了一些套接字，并在其中一个套接字可读或可写时通知你的应用程序，还会告诉你具体是哪个套接字。
- en: This setup allows clients to scale up the number of simultaneous transfers much
    higher than with other systems, and still maintain good performance. The "regular"
    APIs otherwise waste far too much time scanning through lists of all the sockets.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置允许客户端将同时传输的数量扩展到比其他系统更高，并且仍然保持良好的性能。否则，“常规”API会浪费大量时间扫描所有套接字列表。
- en: Pick one
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择一个
- en: There are numerous event based systems to select from out there, and libcurl
    is completely agnostic to which one you use. libevent, libev are libuv three popular
    ones but you can also go directly to your operating system's native solutions
    such as epoll, kqueue, /dev/poll, pollset, Event Completion or I/O Completion
    Ports.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多事件驱动系统可供选择，而 libcurl 完全不关心你使用哪一个。libevent、libev 和 libuv 是三个流行的选项，但你也可以直接使用操作系统的本地解决方案，如
    epoll、kqueue、/dev/poll、pollset、事件完成或 I/O 完成端口。
- en: Many easy handles
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许多 easy 句柄
- en: Just like with the regular multi interface, you add easy handles to a multi
    handle with `curl_multi_add_handle()`. One easy handle for each transfer you want
    to perform.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就像常规多接口一样，你可以使用 `curl_multi_add_handle()` 将 easy 句柄添加到多句柄中。每个传输都需要一个 easy 句柄。
- en: You can add them at any time while the transfers are running and you can also
    similarly remove easy handles at any time using the `curl_multi_remove_handle`
    call. Typically though, you remove a handle only after its transfer is completed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在传输运行时随时添加它们，也可以使用 `curl_multi_remove_handle` 调用类似地随时移除 easy 句柄。不过通常情况下，只有在传输完成后才会移除句柄。
- en: multi_socket callbacks
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多套接字回调
- en: 'As explained above, this event-based mechanism relies on the application to
    know which sockets are used by libcurl and what libcurl waits for on those sockets:
    if it waits for the socket to become readable, writable or both!'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，这种基于事件的机制依赖于应用程序知道 libcurl 使用的是哪些套接字，以及 libcurl 在这些套接字上等待什么：如果它等待套接字变为可读、可写或两者兼具！
- en: It also needs to tell libcurl when its timeout time has expired, as it is control
    of driving everything libcurl can't do it itself. So libcurl must tell the application
    an updated timeout value, too.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它还需要告诉 libcurl 其超时时间已过，因为它负责驱动一切 libcurl 不能自己做。所以 libcurl 必须告诉应用程序一个更新的超时值。
- en: socket_callback
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 套接字回调
- en: 'libcurl informs the application about socket activity to wait for with a callback
    called [CURLMOPT_SOCKETFUNCTION](https://curl.haxx.se/libcurl/c/CURLMOPT_SOCKETFUNCTION.html).
    Your application needs to implement such a function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 通过一个称为 [CURLMOPT_SOCKETFUNCTION](https://curl.haxx.se/libcurl/c/CURLMOPT_SOCKETFUNCTION.html)
    的回调来通知应用程序有关待等待的套接字活动。你的应用程序需要实现这样一个函数：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using this, libcurl will set and remove sockets your application should monitor.
    Your application tells the underlying event-based system to wait for the sockets.
    This callback will be called multiple times if there are multiple sockets to wait
    for, and it will be called again when the status changes and perhaps you should
    switch from waiting for a writable socket to instead wait for it to become readable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式，libcurl 将设置和移除你的应用程序应该监视的套接字。你的应用程序告诉底层事件驱动系统等待这些套接字。如果有多个套接字需要等待，这个回调将被多次调用，并且当状态发生变化时可能需要从等待可写的套接字切换为等待可读的套接字。
- en: 'When one of the sockets that the application is monitoring on libcurl''s behalf
    registers that it becomes readable or writable, as requested, you tell libcurl
    about it by calling `curl_multi_socket_action()` and passing in the affected socket
    and an associated bitmask specifying which socket activity that was registered:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序正在监视的其中一个套接字注册为可读或可写时，如请求的，您通过调用 `curl_multi_socket_action()` 并传入受影响的套接字和指定已注册的套接字活动的关联位掩码来告诉
    libcurl：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: timer_callback
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: timer_callback
- en: The application is in control and will wait for socket activity. But even without
    socket activity there will be things libcurl needs to do. Timeout things, calling
    the progress callback, starting over a retry or failing a transfer that takes
    too long, etc. To make that work, the application must also make sure to handle
    a single-shot timeout that libcurl sets.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序控制并等待套接字活动。但即使没有套接字活动，libcurl 也有事情要做。超时事务，调用进度回调，重新开始重试或失败超时的传输等。为了使其工作，应用程序还必须确保处理
    libcurl 设置的单次超时。
- en: 'libcurl sets the timeout with the timer_callback [CURLMOPT_TIMERFUNCTION](https://curl.haxx.se/libcurl/c/CURLMOPT_TIMERFUNCTION.html):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 使用 timer_callback [CURLMOPT_TIMERFUNCTION](https://curl.haxx.se/libcurl/c/CURLMOPT_TIMERFUNCTION.html)
    来设置超时：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is only one timeout for the application to handle for the entire multi
    handle, no matter how many individual easy handles that have been added or transfers
    that are in progress. The timer callback will be updated with the current nearest-in-time
    period to wait. If libcurl gets called before the timeout expiry time because
    of socket activity, it may very well update the timeout value again before it
    expires.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 整个多 handle 只有一个超时需要应用程序处理，无论已添加了多少个单独的 easy handle 或正在进行多少个传输。定时器回调将被更新为当前最接近的等待时间段。如果因为套接字活动而在超时到期时间之前调用了
    libcurl，它很可能会在它到期之前再次更新超时值。
- en: 'When the event system of your choice eventually tells you that the timer has
    expired, you need to tell libcurl about it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当您选择的事件系统最终告诉您计时器已到期时，您需要告诉 libcurl：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: …in many cases, this will make libcurl call the timer_callback again and set
    a new timeout for the next expiry period.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: …在许多情况下，这将使 libcurl 再次调用 timer_callback 并设置下一个到期周期的新超时。
- en: How to start everything
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何开始一切
- en: When you have added one or more easy handles to the multi handle and set the
    socket and timer callbacks in the multi handle, you are ready to start the transfer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将一个或多个 easy handle 添加到多 handle 并在多 handle 中设置套接字和计时器回调后，您就可以开始传输了。
- en: 'To kick it all off, you tell libcurl it timed out (because all easy handles
    start out with a very, very short timeout) which will make libcurl call the callbacks
    to set things up and from then on you can can just let your event system drive:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始一切，您告诉 libcurl 它超时了（因为所有的 easy handle 都是从非常非常短的超时时间开始的），这将使 libcurl 调用回调函数来设置事物，并从此你可以让你的事件系统驱动：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When is it done?
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么时候完成？
- en: The 'running_handles' counter returned by `curl_multi_socket_action` holds the
    number of current transfers not completed. When that number reaches zero, we know
    there are no transfers going on.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `curl_multi_socket_action` 返回的 'running_handles' 计数器保存了当前尚未完成的传输数量。当该数字达到零时，我们知道没有传输正在进行。
- en: Each time the 'running_handles' counter changes, `curl_multi_info_read()` will
    return info about the specific transfers that completed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 'running_handles' 计数器更改时，`curl_multi_info_read()` 将返回有关已完成的特定传输的信息。
- en: Connection reuse
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接重用
- en: Connection reuse
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接重用
- en: libcurl keeps a pool of old connections alive. When one transfer has completed
    it will keep N connections alive in a "connection pool" (sometimes also called
    connection cache) so that a subsequent transfer that happens to be able to reuse
    one of the existing connections can use it instead of creating a new one. Reusing
    a connection instead of creating a new one offers significant benefits in speed
    and required resources.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 保持一组旧连接保持活动状态。当一个传输完成时，它将在一个“连接池”中保持 N 个连接活动（有时也称为连接缓存），以便后续传输能够重用其中一个现有连接而不是创建新连接。重用连接而不是创建新连接在速度和所需资源方面提供了显著的好处。
- en: When libcurl is about to make a new connection for the purposes of doing a transfer,
    it will first check to see if there's an existing connection in the pool that
    it can reuse instead. The connection re-use check is done before any DNS or other
    name resolving mechanism is used, so it is purely host name based. If there's
    an existing live connection to the right host name, a lot of other properties
    (port number, protocol, etc) are also checked to see that it can be used.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当 libcurl 准备为传输建立新连接时，它将首先检查是否有现有连接可重用。连接重用检查在使用任何 DNS 或其他名称解析机制之前进行，因此它完全基于主机名。如果存在到正确主机名的现有活动连接，则还将检查很多其他属性（端口号、协议等）以确保可以使用。
- en: Easy API pool
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 易 API 连接池
- en: When you are using the easy API, or, more specifically, `curl_easy_perform()`,
    libcurl will keep the pool associated with the specific easy handle. Then reusing
    the same easy handle will ensure it can reuse its connection.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用易 API，或者更具体地说，`curl_easy_perform()` 时，libcurl 将保持与特定易句柄关联的池。然后重用相同的易句柄将确保它可以重用其连接。
- en: Multi API pool
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多 API 连接池
- en: When you are using the multi API, the connection pool is instead kept associated
    with the multi handle. This allows you to cleanup and re-create easy handles freely
    without risking losing the connection pool, and it allows the connection used
    by one easy handle to get reused by a separate one in a later transfer. Just reuse
    the multi handle!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用多 API 时，连接池将与多句柄关联。这样可以自由清理和重新创建易句柄，而不必担心丢失连接池，并且可以使一个易句柄使用的连接在以后的传输中被另一个易句柄重用。只需重用多句柄！
- en: Sharing the "connection cache"
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享“连接缓存”
- en: Since libcurl 7.57.0, applications can use the [share interface](libcurl-sharing.html)
    to have otherwise independent transfers share the same connection pool.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 自 libcurl 7.57.0 开始，应用程序可以使用[共享接口](libcurl-sharing.html)来共享相同的连接池，否则它们是独立的传输。
- en: Callbacks
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调函数
- en: Callbacks
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调函数
- en: Lots of operations within libcurl are controlled with the use of *callbacks*.
    A callback is a function pointer provided to libcurl that libcurl then calls at
    some point in time to get a particular job done.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 内有很多操作是通过*回调*来控制的。回调是提供给 libcurl 的函数指针，libcurl 在某个时刻调用它以完成特定的工作。
- en: Each callback has its specific documented purpose and it requires that you write
    it with the exact function prototype to accept the correct arguments and return
    the documented return code and return value so that libcurl will perform the way
    you want it to.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每个回调都有其特定的文档化目的，并且要求您用精确的函数原型编写它，以接受正确的参数并返回文档化的返回代码和返回值，以便 libcurl 表现出您希望的方式。
- en: Each callback option also has a companion option that sets the associated "user
    pointer". This user pointer is a pointer that libcurl doesn't touch or care about,
    but just passes on as an argument to the callback. This allows you to, for example,
    pass in pointers to local data all the way through to your callback function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个回调选项还有一个关联的“用户指针”伴侣选项。这个用户指针是 libcurl 不会触及或关心的指针，但只是作为参数传递给回调。这使您可以将指针传递到本地数据，一直到回调函数。
- en: Unless explicitely stated in a libcurl function documentation, it is not legal
    to invoke libcurl functions from within a libcurl callback.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除非在 libcurl 函数文档中明确说明，否则不得在 libcurl 回调函数中调用 libcurl 函数。
- en: Write data
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写数据
- en: Write callback
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写回调
- en: 'The write callback is set with `CURLOPT_WRITEFUNCTION`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 写回调由 `CURLOPT_WRITEFUNCTION` 设置：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `write_callback` function must match this prototype:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`write_callback` 函数必须与此原型匹配：'
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This callback function gets called by libcurl as soon as there is data received
    that needs to be saved. *ptr* points to the delivered data, and the size of that
    data is *size* multiplied with *nmemb*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调函数会在 libcurl 收到需要保存的数据时立即被调用。*ptr* 指向传递的数据，该数据的大小为 *size* 乘以 *nmemb*。
- en: If this callback isn't set, libcurl instead uses 'fwrite' by default.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未设置此回调，则 libcurl 默认使用 'fwrite'。
- en: 'The write callback will be passed as much data as possible in all invokes,
    but it must not make any assumptions. It may be one byte, it may be thousands.
    The maximum amount of body data that will be passed to the write callback is defined
    in the curl.h header file: `CURL_MAX_WRITE_SIZE` (the usual default is 16KB).
    If `CURLOPT_HEADER` is enabled for this transfer, which makes header data get
    passed to the write callback, you can get up to `CURL_MAX_HTTP_HEADER` bytes of
    header data passed into it. This usually means 100KB.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 写入回调将尽可能传递尽可能多的数据，但不得做出任何假设。它可能是一个字节，也可能是数千个字节。将传递给写入回调的主体数据的最大量在curl.h头文件中定义：`CURL_MAX_WRITE_SIZE`（通常默认为16KB）。如果为此传输启用了`CURLOPT_HEADER`，使得头数据传递给写入回调，您可以获得最多`CURL_MAX_HTTP_HEADER`字节的头数据传递给它。这通常意味着100KB。
- en: This function may be called with zero bytes data if the transferred file is
    empty.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传输的文件为空，此函数可能会以零字节数据调用。
- en: The data passed to this function will not be zero terminated! You cannot, for
    example, use printf's "%s" operator to display the contents nor strcpy to copy
    it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给此函数的数据不会以零结尾！例如，您不能使用printf的“％s”运算符显示内容，也不能使用strcpy复制它。
- en: This callback should return the number of bytes actually taken care of. If that
    number differs from the number passed to your callback function, it will signal
    an error condition to the library. This will cause the transfer to get aborted
    and the libcurl function used will return `CURLE_WRITE_ERROR`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调函数应返回实际处理的字节数。如果该数字与传递给回调函数的数字不同，它将向库发出错误信号。这将导致传输中止，并且使用的libcurl函数将返回`CURLE_WRITE_ERROR`。
- en: 'The user pointer passed in to the callback in the *userdata* argument is set
    with `CURLOPT_WRITEDATA`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给回调函数中*userdata*参数的用户指针是使用`CURLOPT_WRITEDATA`设置的：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Read data
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取数据
- en: Read callback
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取回调
- en: 'The read callback is set with `CURLOPT_READFUNCTION`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 读取回调函数是通过`CURLOPT_READFUNCTION`设置的：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `read_callback` function must match this prototype:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_callback`函数必须匹配此原型：'
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This callback function gets called by libcurl when it wants to send data to
    the server. This is a transfer that you have set up to upload data or otherwise
    send it off to the server. This callback will be called over and over until all
    data has been delivered or the transfer failed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当libcurl希望将数据发送到服务器时，将调用此回调函数。这是您设置的用于上传数据或以其他方式将其发送到服务器的传输。此回调将一遍又一遍地调用，直到所有数据已传递或传输失败。
- en: 'The **stream** pointer points to the private data set with `CURLOPT_READDATA`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**stream**指针指向使用`CURLOPT_READDATA`设置的私有数据：'
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If this callback isn't set, libcurl instead uses 'fread' by default.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未设置此回调函数，libcurl将默认使用'fread'。
- en: The data area pointed at by the pointer **buffer** should be filled up with
    at most **size** multiplied with **nitems** number of bytes by your function.
    The callback should then return the number of bytes that it stored in that memory
    area, or 0 if we have reached the end of the data. The callback can also return
    a few "magic" return codes to cause libcurl to return failure immediately or to
    pause the particular transfer. See the [CURLOPT_READFUNCTION man page](https://curl.haxx.se/libcurl/c/CURLOPT_READFUNCTION.html)
    for details.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 指针**buffer**指向的数据区域应由您的函数用最多**size**乘以**nitems**字节数填充。然后，回调应返回存储在该内存区域中的字节数，如果已达到数据的末尾，则返回0。回调还可以返回一些“魔术”返回代码，以立即导致libcurl立即返回失败或暂停特定传输。有关详细信息，请参阅[CURLOPT_READFUNCTION
    man page](https://curl.haxx.se/libcurl/c/CURLOPT_READFUNCTION.html)。
- en: Progress information
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进度信息
- en: Progress callback
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进度回调
- en: 'The progress callback is what gets called regularly and repeatedly for each
    transfer during the entire lifetime of the transfer. The old callback was set
    with `CURLOPT_PROGRESSFUNCTION` but the modern and preferred callback is set with
    `CURLOPT_XFERINFOFUNCTION`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 进度回调是在整个传输的整个生命周期中定期和重复地为每个传输调用的。旧的回调是使用`CURLOPT_PROGRESSFUNCTION`设置的，但现代和首选的回调是使用`CURLOPT_XFERINFOFUNCTION`设置的：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `xfer_callback` function must match this prototype:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`xfer_callback`函数必须匹配此原型：'
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If this option is set and `CURLOPT_NOPROGRESS` is set to 0 (zero), this callback
    function gets called by libcurl with a frequent interval. While data is being
    transferred it will be called very frequently, and during slow periods like when
    nothing is being transferred it can slow down to about one call per second.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了此选项，并且`CURLOPT_NOPROGRESS`设置为0（零），则libcurl会以频繁的间隔调用此回调函数。在数据传输时，它将被非常频繁地调用，而在没有传输任何内容时，它可能会减慢到每秒约一次的速度。
- en: 'The **clientp** pointer points to the private data set with `CURLOPT_XFERINFODATA`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**clientp** 指针指向使用 `CURLOPT_XFERINFODATA` 设置的私有数据：'
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The callback gets told how much data libcurl will transfer and has transferred,
    in number of bytes:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 回调会告知 libcurl 将传输和已传输的数据量，以字节数表示：
- en: '**dltotal** is the total number of bytes libcurl expects to download in this
    transfer.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dltotal** 是 libcurl 预计在此传输中下载的总字节数。'
- en: '**dlnow** is the number of bytes downloaded so far.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dlnow** 是迄今为止已下载的字节数。'
- en: '**ultotal** is the total number of bytes libcurl expects to upload in this
    transfer.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ultotal** 是 libcurl 预计在此传输中上传的总字节数。'
- en: '**ulnow** is the number of bytes uploaded so far.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ulnow** 是迄今为止已上传的字节数。'
- en: Unknown/unused argument values passed to the callback will be set to zero (like
    if you only download data, the upload size will remain 0). Many times the callback
    will be called one or more times first, before it knows the data sizes, so a program
    must be made to handle that.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给回调的未知/未使用的参数值将设置为零（例如，如果您只下载数据，则上传大小将保持为 0）。许多时候，回调将在知道数据大小之前首先调用一次或多次，因此必须编写程序来处理这种情况。
- en: Returning a non-zero value from this callback will cause libcurl to abort the
    transfer and return `CURLE_ABORTED_BY_CALLBACK`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从此回调返回非零值将导致 libcurl 中止传输并返回 `CURLE_ABORTED_BY_CALLBACK`。
- en: If you transfer data with the multi interface, this function will not be called
    during periods of idleness unless you call the appropriate libcurl function that
    performs transfers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用多接口传输数据，则在空闲期间不会调用此函数，除非您调用执行传输的适当的 libcurl 函数。
- en: (The deprecated callback `CURLOPT_PROGRESSFUNCTION` worked identically but instead
    of taking arguments of type `curl_off_t`, it used `double`.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: （已弃用的回调 `CURLOPT_PROGRESSFUNCTION` 的工作方式相同，但它使用 `double` 类型的参数而不是 `curl_off_t`。）
- en: Header data
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头数据
- en: Header callback
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 头回调
- en: 'The header callback is set with `CURLOPT_HEADERFUNCTION`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 头回调函数设置为 `CURLOPT_HEADERFUNCTION`：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `header_callback` function must match this prototype:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`header_callback` 函数必须匹配此原型：'
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This callback function gets called by libcurl as soon as a header has been received.
    *ptr* points to the delivered data, and the size of that data is *size* multiplied
    with *nmemb*. libcurl buffers headers and delivers only "full" headers, one by
    one, to this callback.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调函数在 libcurl 收到头后立即被调用。*ptr* 指向传递的数据，该数据的大小为 *size* 乘以 *nmemb*。libcurl 缓冲头并仅将“完整”头逐个传递给此回调。
- en: The data passed to this function will not be zero terminated! You cannot, for
    example, use printf's "%s" operator to display the contents nor strcpy to copy
    it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给此函数的数据将不以零结尾！例如，您不能使用 printf 的 "%s" 运算符显示内容，也不能使用 strcpy 复制它。
- en: This callback should return the number of bytes actually taken care of. If that
    number differs from the number passed to your callback function, it signals an
    error condition to the library. This will cause the transfer to abort and the
    libcurl function used will return `CURLE_WRITE_ERROR`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调函数应返回实际处理的字节数。如果该数字与传递给回调函数的数字不同，这将向库发出错误信号。这将导致传输中止，并且使用的 libcurl 函数将返回
    `CURLE_WRITE_ERROR`。
- en: 'The user pointer passed in to the callback in the *userdata* argument is set
    with `CURLOPT_HEADERDATA`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给回调函数的用户指针在 *userdata* 参数中设置为 `CURLOPT_HEADERDATA`：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Debug
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: Debug callback
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试回调
- en: 'The debug callback is set with `CURLOPT_DEBUGFUNCTION`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 调试回调函数设置为 `CURLOPT_DEBUGFUNCTION`：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `debug_callback` function must match this prototype:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug_callback` 函数必须匹配此原型：'
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This callback function replaces the default verbose output function in the
    library and will get called for all debug and trace messages to aid applications
    to understand what''s going on. The *type* argument explains what sort of data
    that is provided: header, data or SSL data and in which direction it flows.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调函数替换库中的默认详细输出函数，并将为所有调试和跟踪消息调用以帮助应用程序了解发生了什么。*type* 参数解释提供的数据类型：头、数据或 SSL
    数据以及流动方向。
- en: A common use for this callback is to get a full trace of all data that libcurl
    sends and receives. The data sent to this callback is always the unencrypted version,
    even when, for example, HTTPS or other encrypted protocols are used.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调的常见用途是获取 libcurl 发送和接收的所有数据的完整跟踪。发送到此回调的数据始终是未加密版本，即使例如使用 HTTPS 或其他加密协议时也是如此。
- en: This callback must return zero or cause the transfer to stop with an error code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调必须返回零或导致传输停止并带有错误代码。
- en: 'The user pointer passed in to the callback in the *userdata* argument is set
    with `CURLOPT_DEBUGDATA`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 回调中传入的*userdata*参数中的用户指针是使用`CURLOPT_DEBUGDATA`设置的：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: sockopt
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sockopt
- en: sockopt callback
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sockopt回调
- en: 'The sockopt callback is set with `CURLOPT_SOCKOPTFUNCTION`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CURLOPT_SOCKOPTFUNCTION`设置sockopt回调：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `sockopt_callback` function must match this prototype:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`sockopt_callback`函数必须匹配此原型：'
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This callback function gets called by libcurl when a new socket has been created
    but before the connect call, to allow applications to change specific socket options.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当新套接字被创建但在连接调用之前，此回调函数由libcurl调用，以允许应用程序更改特定套接字选项。
- en: 'The **clientp** pointer points to the private data set with `CURLOPT_SOCKOPTDATA`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**clientp**指针指向使用`CURLOPT_SOCKOPTDATA`设置的私有数据：'
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This callback should return:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调应返回：
- en: CURL_SOCKOPT_OK on success
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功时返回CURL_SOCKOPT_OK
- en: CURL_SOCKOPT_ERROR to signal an unrecoverable error to libcurl
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CURL_SOCKOPT_ERROR用于向libcurl发出不可恢复的错误信号
- en: CURL_SOCKOPT_ALREADY_CONNECTED to signal success but also that the socket is
    in fact already connected to the destination
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CURL_SOCKOPT_ALREADY_CONNECTED表示成功，但套接字实际上已连接到目的地
- en: SSL context
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSL上下文
- en: SSL context callback
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SSL上下文回调
- en: TBD
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Seek and ioctl
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找和ioctl
- en: seek and ioctl callbacks
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找和ioctl回调
- en: TBD
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Network data conversion
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络数据转换
- en: Convert to and from network callbacks
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换为网络回调和从网络回调
- en: TBD
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Convert from UTF-8 callback
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换为UTF-8回调
- en: TBD
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Opensocket and closesocket
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开套接字和关闭套接字
- en: Opensocket and closesocket callbacks
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开套接字和关闭套接字回调
- en: Occasionally you end up in a situation where you want your application to control
    with more precision exactly what socket libcurl will use for its operations. libcurl
    offers this pair of callbacks that replaces libcurl's own call to `socket()` and
    the subsequent `close()` of the same file descriptor.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您会遇到这样的情况，您希望应用程序更精确地控制libcurl将用于其操作的套接字。libcurl提供了一对回调函数，用于替换libcurl自己对`socket()`的调用和随后对相同文件描述符的`close()`。
- en: Provide a file descriptor
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供一个文件描述符
- en: 'By setting the `CURLOPT_OPENSOCKETFUNCTION` callback, you can provide a custom
    function to return a file descriptor for libcurl to use:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`CURLOPT_OPENSOCKETFUNCTION`回调，您可以提供一个自定义函数来返回libcurl使用的文件描述符：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `opensocket_callback` function must match this prototype:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`opensocket_callback`函数必须匹配此原型：'
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The callback gets the *clientp* as first argument, which is simply an opaque
    pointer you set with `CURLOPT_OPENSOCKETDATA`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数的第一个参数是*clientp*，它只是您使用`CURLOPT_OPENSOCKETDATA`设置的不透明指针。
- en: The other two arguments pass in data that identifies for what *purpose* and
    *address* the socket is to be used. The *purpose* is a typedef with a value of
    `CURLSOCKTYPE_IPCXN` or `CURLSOCKTYPE_ACCEPT`, basically idenfying in which circumstance
    the socket is created. The "accept" case being when libcurl is used to accept
    an incoming FTP connection for when FTP active mode is used, and all other cases
    when libcurl creates a socket for its own outgoing connections the *IPCXN* value
    is passed in.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个参数传入标识套接字用于何种*目的*和*地址*的数据。*目的*是一个具有`CURLSOCKTYPE_IPCXN`或`CURLSOCKTYPE_ACCEPT`值的typedef，基本上标识套接字在哪种情况下被创建。当libcurl用于接受传入的FTP连接时，"accept"情况是FTP主动模式使用时，而所有其他情况下，当libcurl为自己的出站连接创建套接字时，传入*IPCXN*值。
- en: The *address* pointer points to a `struct curl_sockaddr` that describes the
    IP address of the network destination for which this socket is created. Your callback
    can for example use this information to whitelist or blacklist specific addresses
    or address ranges.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*address*指针指向描述创建此套接字的网络目的地的IP地址的`struct curl_sockaddr`。例如，您的回调可以使用此信息来列入白名单或黑名单特定地址或地址范围。'
- en: The socketopen callback is also explicitly allowed to modify the target address
    in that struct, if you would like to offer some sort of network filter or translation
    layer.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: socketopen回调也明确允许修改该结构中的目标地址，如果您想提供某种网络过滤器或转换层。
- en: The callback should return a file descriptor or `CURL_SOCKET_BAD`, which then
    will cause an unrecoverable error within libcurl and it will eventually return
    `CURLE_COULDNT_CONNECT` from its perform function.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 回调应返回一个文件描述符或`CURL_SOCKET_BAD`，这将导致libcurl内部发生不可恢复的错误，并最终从其执行函数返回`CURLE_COULDNT_CONNECT`。
- en: If you want to return a file descriptor that is *already connected* to a server,
    then you must also set the [sockopt callback](callback-sockopt.html) and make
    sure that returns the correct return value.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要返回一个*已连接*到服务器的文件描述符，则还必须设置[sockopt回调](callback-sockopt.html)并确保返回正确的返回值。
- en: 'The `curl_sockaddress` struct looks like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl_sockaddress`结构如下：'
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Socket close callback
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 套接字关闭回调
- en: 'The corresponding callback to the open socket is of course the close socket.
    Usually when you provide a custom way to provide a file descriptor you want to
    provide your own cleanup version as well:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 与打开套接字对应的回调当然是关闭套接字。通常，当您提供一种自定义方式来提供文件描述符时，您也希望提供自己的清理版本：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `closesocket_callback` function must match this prototype:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`closesocket_callback`函数必须匹配此原型：'
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: SSH key
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSH密钥
- en: SSH key callback
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SSH密钥回调
- en: TBD
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: RTSP interleaved data
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RTSP交错数据
- en: RTSP interleave callback
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RTSP交错回调
- en: TBD
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: FTP matching
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP匹配
- en: FTP chunk callbacks
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FTP块回调
- en: TBD
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: FTP matching callback
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FTP匹配回调
- en: TBD
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Cleanup
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: Cleanup
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理
- en: In previous sections we have discussed how to setup handles and how to drive
    the transfers. All transfers will, of course, end up at some point, either successfully
    or with a failure.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们已经讨论了如何设置句柄以及如何驱动传输。所有传输当然最终都会在某个时刻结束，无论是成功还是失败。
- en: Multi API
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多API
- en: When you have finished a single transfer with the multi API, you use `curl_multi_info_read()`
    to identify exactly which easy handle was completed and you remove that easy handle
    from the multi handle with `curl_multi_remove_handle()`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用多API完成单个传输时，您可以使用`curl_multi_info_read()`来确定确切完成的easy句柄，并使用`curl_multi_remove_handle()`从多句柄中删除该easy句柄。
- en: 'If you remove the last easy handle from the multi handle so there are no more
    transfers going on, you can close the multi handle like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从多句柄中删除最后一个easy句柄，以便没有更多的传输正在进行，您可以像这样关闭多句柄：
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: easy handle
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: easy句柄
- en: When the easy handle is done serving its purpose, you can close it. If you intend
    to do another transfer, you are however advised to rather reuse the handle rather
    than to close it and create a new one.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当easy句柄完成其用途时，您可以关闭它。但是，如果您打算进行另一个传输，则建议您更好地重用句柄，而不是关闭它并创建一个新的句柄。
- en: 'If you don''t intend to do another transfer with the easy handle, you simply
    ask libcurl to cleanup:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不打算使用easy句柄进行另一个传输，您只需要求libcurl清理：
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Name resolving
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名称解析
- en: Name resolving
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名称解析
- en: Most transfers libcurl can do involves a name that first needs to be translated
    to an internet address. That's "name resolving". Using a numerical IP address
    directly in the URL usually avoids the name resolve phase, but in many cases it
    isn't easy to manully replace the name with the IP address.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl可以执行的大多数传输都涉及首先将名称转换为互联网地址。这就是"名称解析"。直接在URL中使用数字IP地址通常可以避免名称解析阶段，但在许多情况下，手动用IP地址替换名称并不容易。
- en: libcurl tries very hard to [re-use an existing connection](libcurl-connectionreuse.html)
    rather than to create and connection a new one. The function that checks for an
    exsting connection to use is based purely on the name and is performed before
    any name resolving is attempted. That's one of the reasons the re-use is so much
    faster. A transfer using a reused connection will not resolve the host name again.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl非常努力地尝试[重用现有连接](libcurl-connectionreuse.html)而不是创建新连接。检查要使用的现有连接的函数纯粹基于名称，并且在尝试任何名称解析之前执行。这就是重用如此快速的原因之一。使用重用连接的传输不会再次解析主机名。
- en: If no connection can be reused, libcurl resolves the host name to the set of
    addresses it resolves to. Typically this means asking for both IPv4 and IPv6 adddresses
    and there may be a whole set of those returned to libcurl. That set of addresses
    is then tried until one works, or it returns failure.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法重用连接，则libcurl将主机名解析为其解析到的地址集。通常，这意味着请求IPv4和IPv6地址，并且可能会有一整套这些地址返回给libcurl。然后尝试该地址集，直到找到一个有效的地址，否则返回失败。
- en: 'An application can force libcurl to use only an IPv4 or IPv6 resolved address
    by setting `CURLOPT_IPRESOLVE` to the preferred value. For example, ask to only
    use IPv6 addresses:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过将`CURLOPT_IPRESOLVE`设置为首选值，强制libcurl仅使用IPv4或IPv6解析的地址。例如，要求仅使用IPv6地址：
- en: '[PRE38]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Name resolver backends
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称解析器后端
- en: libcurl can be built to do name resolves in at least three different ways and
    depending on which backend way that was used, it gets a slightly different feature
    set and sometimes modified behavior.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl可以以至少三种不同的方式构建名称解析，并根据使用的后端方式，它会获得略有不同的功能集，并有时会修改行为。
- en: The default backend is invoking the "normal" libc resolver functions in a new
    helper-thread, so that it can still do fine-grained timeouts if wanted and there
    will be no blocking calls involved.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认后端是在新的辅助线程中调用“正常”的 libc 解析器函数，以便如果需要，仍然可以进行细粒度的超时，并且不涉及阻塞调用。
- en: On older systems, libcurl uses the standard synchronous name resolver functions.
    They unfortunately make all transfers within a multi handle block during its operation
    and it is much harder to time out nicely.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在旧系统上，libcurl 使用标准同步名称解析函数。不幸的是，在其操作期间，它会使多句柄内的所有传输都阻塞，并且很难进行良好的超时处理。
- en: There's also support for resolving with the c-ares third party library, which
    supports asynchronous name resolving without the use of threads. This scales better
    to huge number of parallel transfers but it isn't always 100% compatible with
    the native name resolver funtionality.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还支持使用 c-ares 第三方库进行解析，该库支持异步名称解析而无需使用线程。这对于大量并行传输更具扩展性，但并不总是与本机名称解析功能完全兼容。
- en: Caching
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: When a name has been resolved, the result will be put in libcurl's in-memory
    cache so that subsequent resolves of the same name will be near instant for as
    long the name is kept in the DNS cache. By default, each entry is kept in the
    cache for 60 seconds, but that value can be changed with `CURLOPT_DNS_CACHE_TIMEOUT`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当名称已解析时，结果将放入 libcurl 的内存缓存中，以便对相同名称的后续解析几乎瞬间完成，只要名称保留在 DNS 缓存中。默认情况下，每个条目在缓存中保留
    60 秒，但该值可以使用`CURLOPT_DNS_CACHE_TIMEOUT`进行更改。
- en: The DNS cache is kept within the easy handle when `curl_easy_perform` is used,
    or within the multi handle when the multi inteface is used. It can also be made
    shared between multiple easy handles using the [share interface](libcurl-sharing.html).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`curl_easy_perform`时，DNS 缓存保留在 easy 句柄内，或者当使用多接口时，保留在多句柄内。还可以使用[共享接口](libcurl-sharing.html)在多个
    easy 句柄之间共享。
- en: Custom addresses for hosts
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机的自定义地址
- en: Sometimes it is handy to provide "fake" addresses to real host names so that
    libcurl will connect to a different address instead of one an actual name resolve
    would suggest.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，提供“虚假”地址给真实主机名是很方便的，这样 libcurl 将连接到不同的地址，而不是实际名称解析所建议的地址。
- en: With the help of the [CURLOPT_RESOLVE](https://curl.haxx.se/libcurl/c/CURLOPT_RESOLVE.html)
    option, an application can pre-populate libcurl's DNS cache with a custom address
    for a given host name and port number.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 借助[CURLOPT_RESOLVE](https://curl.haxx.se/libcurl/c/CURLOPT_RESOLVE.html)选项的帮助，应用程序可以预先填充
    libcurl 的 DNS 缓存，为给定的主机名和端口号提供自定义地址。
- en: 'To make libcurl connect to 127.0.0.1 when example.com on port 443 is requested,
    an application can do:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 libcurl 连接到 127.0.0.1，当请求端口 443 的 example.com 时，应用程序可以执行以下操作：
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Since this puts the "fake" address into the DNS cache, it will work even when
    following redirects etc.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这将“虚假”地址放入 DNS 缓存中，即使在跟随重定向等情况下也能正常工作。
- en: Name server options
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称服务器选项
- en: For libcurl built to use c-ares, there's a few options available that offer
    fine-grained control of what DNS servers to use and how. This is limited to c-ares
    build purely because these are powers that are not available when the standard
    system calls for name name resolving are used.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构建使用 c-ares 的 libcurl，有一些可用的选项可以提供对要使用的 DNS 服务器以及如何使用的细粒度控制。这仅限于 c-ares 构建，因为当使用标准系统调用进行名称解析时，这些功能是不可用的。
- en: With `CURLOPT_DNS_SERVERS`, the application can select to use a set of dedicated
    DNS servers.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CURLOPT_DNS_SERVERS`，应用程序可以选择使用一组专用的 DNS 服务器。
- en: With `CURLOPT_DNS_INTERFACE` it can tell libcurl which network interface to
    speak DNS over instead of the default one.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CURLOPT_DNS_INTERFACE`，它可以告诉 libcurl 使用哪个网络接口来进行 DNS 通信，而不是默认的接口。
- en: With `CURLOPT_DNS_LOCAL_IP4` and `CURLOPT_DNS_LOCAL_IP6`, the application can
    specify which specific network addresses to bind DNS resolves to.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CURLOPT_DNS_LOCAL_IP4`和`CURLOPT_DNS_LOCAL_IP6`，应用程序可以指定将 DNS 解析绑定到哪些特定的网络地址。
- en: Global DNS cache is bad
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局 DNS 缓存不好
- en: The is a *deprecated* option called `CURLOPT_DNS_USE_GLOBAL_CACHE` that when
    enabled tells curl to use a global DNS cache. This cache has no locks and stores
    data in a global context that then can be shared by all other easy handles that
    also is set to use the global cache.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个*已弃用*的选项称为`CURLOPT_DNS_USE_GLOBAL_CACHE`，启用后告诉 curl 使用全局 DNS 缓存。此缓存没有锁，并在全局上下文中存储数据，然后可以由所有其他设置为使用全局缓存的
    easy 句柄共享。
- en: This option should only be used by legacy applications and you *should* work
    on converting this over to using the share interface for sharing DNS cache the
    "proper" way. This option will be removed in a future version.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项仅应由旧版应用程序使用，您*应该*努力将其转换为使用共享接口共享 DNS 缓存的“正确”方法。此选项将在将来的版本中移除。
- en: Proxies
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: Proxies
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: A proxy in a network context is a sort of middle man, a server in between you
    as a client and the remote server you want to communicate with. The client contacts
    the middle man which then goes on to contact the remote server for you.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 网络环境中的代理是一种中间人，即在您作为客户端和您要通信的远程服务器之间的服务器。客户端联系中间人，然后中间人再为您联系远程服务器。
- en: This sort of proxy use is sometimes used by companies and organizations, in
    which case you are usually required to use them to reach the target server.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的代理使用有时被公司和组织使用，此时通常要求您使用它们来访问目标服务器。
- en: There are several different kinds of proxies and different protocols to use
    when communicating with a proxy, and libcurl supports a few of the most common
    proxy protocols. It is important to realize that the protocol used to the proxy
    isn't necessarily the same protocol used to the remote server.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在与代理通信时有几种不同类型的代理和不同的协议可用，并且 libcurl 支持一些最常见的代理协议。重要的是要意识到，用于代理的协议未必与用于远程服务器的协议相同。
- en: When setting up a transfer with libcurl you need to point out the server name
    and port number of the proxy. You may find that your favorite browsers can do
    this in slightly more advanced ways than libcurl can, and we will get into such
    details in later sections.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 libcurl 进行传输时，您需要指出代理的服务器名称和端口号。您可能会发现，与 libcurl 相比，您喜爱的浏览器可以以略微更高级的方式执行此操作，我们将在后面的章节中详细介绍这些细节。
- en: Proxy types
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理类型
- en: 'libcurl supports the two major proxy types: SOCKS and HTTP proxies. More specifically,
    it supports both SOCKS4 and SOCKS5 with or without remote name lookup, as well
    as both HTTP and HTTPS to the local proxy.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 支持两种主要的代理类型：SOCKS 和 HTTP 代理。更具体地说，它支持带有或不带有远程名称解析的 SOCKS4 和 SOCKS5，以及本地代理的
    HTTP 和 HTTPS。
- en: 'The easiest way to specify which kind of proxy you are talking to is to set
    the scheme part of the proxy host name string (`CURLOPT_PROXY`) to match it:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 指定要使用的代理类型最简单的方法是设置代理主机名字符串（`CURLOPT_PROXY`）的方案部分以匹配它：
- en: '[PRE40]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`socks4` - means SOCKS4 with local name resolving'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`socks4` - 意味着带有本地名称解析的 SOCKS4'
- en: '`socks4a` - means SOCKS4 with proxy''s name resolving'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`socks4a` - 意味着带有代理名称解析的 SOCKS4'
- en: '`socks5` - means SOCKS5 with local name resolving'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`socks5` - 意味着带有本地名称解析的 SOCKS5'
- en: '`socks5h` - means SOCKS5 with proxy''s name resolving'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`socks5h` - 意味着带有代理名称解析的 SOCKS5'
- en: '`http` - means HTTP, which always lets the proxy resolve names'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`http` - 意味着 HTTP，它总是让代理解析名称'
- en: '`https` - means HTTPS **to the proxy**, which always lets the proxy resolve
    names (Note that HTTPS proxy support was added recently, in curl 7.52.0, and it
    still only works with a subset of the TLS libraries: OpenSSL, GnuTLS and NSS.)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`https` - 意味着 HTTPS **到代理**，它总是让代理解析名称（请注意，HTTPS 代理支持最近添加，从 curl 7.52.0 开始，它仅在某些
    TLS 库中有效：OpenSSL、GnuTLS 和 NSS。）'
- en: You can also opt to set the type of the proxy with a separate option if you
    prefer to only set the host name, using `CURLOPT_PROXYTYPE`. Similarly, you can
    set the proxy port number to use with `CURLOPT_PROXYPORT`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢仅设置主机名，则还可以选择使用单独的选项设置代理的类型，使用 `CURLOPT_PROXYTYPE`。类似地，您可以使用 `CURLOPT_PROXYPORT`
    设置要使用的代理端口号。
- en: Local or proxy name lookup
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地或代理名称解析
- en: In a section above you can see that different proxy setups allow the name resolving
    to be done by different parties involved in the transfer. You can in several cases
    either have the client resolve the server host name and pass on the IP address
    to the proxy to connect to - which of course assumes that the name lookup works
    accurately on the client system - or you can hand over the name to the proxy to
    have the proxy resolve the name; converting it to an IP address to connect to.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的一节中，您可以看到不同的代理设置允许由传输中涉及的不同方进行名称解析。在几种情况下，您可以选择让客户端解析服务器主机名并将 IP 地址传递给代理进行连接
    - 这当然假设客户端系统上的名称查找准确无误 - 或者您可以将名称交给代理来让代理解析名称；将其转换为要连接的 IP 地址。
- en: When you are using an HTTP or HTTPS proxy, you always give the name to the proxy
    to resolve.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 HTTP 或 HTTPS 代理时，您始终会将名称提供给代理来解析。
- en: Which proxy?
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪个代理？
- en: TBD
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Using proxies for various protocols
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用代理进行各种协议
- en: TBD
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: HTTP proxy
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 代理
- en: TBD
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: HTTPS proxy
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTPS 代理
- en: TBD
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Proxy authentication
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理认证
- en: TBD
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Post transfer info
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输后信息
- en: Post transfer info
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输后信息
- en: Remember how libcurl transfers are associated with an "easy handle"! Each transfer
    has such a handle and when a transfer is completed, before the handle is cleaned
    or reused for another transfer, it can be used to extract information from the
    previous operation.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 记得libcurl传输与“easy handle”相关联！每个传输都有这样一个handle，当一个传输完成后，在handle被清理或重新用于另一个传输之前，它可以用于从上一个操作中提取信息。
- en: Your friend for doing this is called `curl_easy_getinfo()` and you tell it which
    specific information you're interested in and it will return that to you if it
    can.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`curl_easy_getinfo()`函数，你可以获取你感兴趣的特定信息，如果可能的话，它会将该信息返回给你。
- en: When you use this function, you pass in the easy handle, which information you
    want and a pointer to a variable to hold the answer. You must pass in a pointer
    to a variable of the correct type or you risk that things will go side-ways. These
    information values are designed to be provided *after* the transfer is completed.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用此函数时，你需要传递easy handle、你想要的信息以及一个指向保存答案的变量的指针。你必须传递一个正确类型的变量的指针，否则可能会出现问题。这些信息值被设计为在传输完成*之后*提供。
- en: The data you receive can be a long, a 'char *', a 'struct curl_slist* ', a double
    or a socket.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你收到的数据可以是long、'char *'、'struct curl_slist* '、double或套接字。
- en: 'This is how you extract the `Content-Type:` value from the previous HTTP transfer:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你从上一个HTTP传输中提取`Content-Type:`值的方法：
- en: '[PRE41]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'but if you want to extract the local port number that was used in that connection:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想提取在该连接中使用的本地端口号：
- en: '[PRE42]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Available information
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可用信息
- en: '| Getinfo option | Type | Description |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 获取信息选项 | 类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| CURLINFO_ACTIVESOCKET | curl_socket_t | The session''s active socket |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_ACTIVESOCKET | curl_socket_t | 会话的活动套接字 |'
- en: '| CURLINFO_APPCONNECT_TIME | double | Time from start until SSL/SSH handshake
    completed. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_APPCONNECT_TIME | double | 从开始到SSL/SSH握手完成的时间 |'
- en: '| CURLINFO_CERTINFO | struct curl_slist * | Certificate chain |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_CERTINFO | struct curl_slist * | 证书链 |'
- en: '| CURLINFO_CONDITION_UNMET | long | Whether or not a time conditional was met
    |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_CONDITION_UNMET | long | 时间条件是否满足 |'
- en: '| CURLINFO_CONNECT_TIME | double | Time from start until remote host or proxy
    completed |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_CONNECT_TIME | double | 从开始到远程主机或代理完成的时间 |'
- en: '| CURLINFO_CONTENT_LENGTH_DOWNLOAD | double | Content length from the Content-Length
    header |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_CONTENT_LENGTH_DOWNLOAD | double | 来自Content-Length头部的内容长度 |'
- en: '| CURLINFO_CONTENT_LENGTH_UPLOAD | double | Upload size |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_CONTENT_LENGTH_UPLOAD | double | 上传大小 |'
- en: '| CURLINFO_CONTENT_TYPE | char * | Content type from the Content-Type header
    |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_CONTENT_TYPE | char * | 来自Content-Type头部的内容类型 |'
- en: '| CURLINFO_COOKIELIST | struct curl_slist * | List of all known cookies |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_COOKIELIST | struct curl_slist * | 所有已知cookie的列表 |'
- en: '| CURLINFO_EFFECTIVE_URL | char * | Last used URL |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_EFFECTIVE_URL | char * | 最后使用的URL |'
- en: '| CURLINFO_FILETIME | long | Remote time of the retrieved document |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_FILETIME | long | 检索文档的远程时间 |'
- en: '| CURLINFO_FTP_ENTRY_PATH | char * | The entry path after logging in to an
    FTP server |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_FTP_ENTRY_PATH | char * | 登录到FTP服务器后的入口路径 |'
- en: '| CURLINFO_HEADER_SIZE | long | Number of bytes of all headers received |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_HEADER_SIZE | long | 所有接收到的头部字节总数 |'
- en: '| CURLINFO_HTTPAUTH_AVAIL | long | Available HTTP authentication methods (bitmask)
    |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_HTTPAUTH_AVAIL | long | 可用的HTTP身份验证方法（位掩码） |'
- en: '| CURLINFO_HTTP_CONNECTCODE | long | Last proxy CONNECT response code |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_HTTP_CONNECTCODE | long | 最后一个代理CONNECT响应代码 |'
- en: '| CURLINFO_HTTP_VERSION | long | The http version used in the connection |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_HTTP_VERSION | long | 连接中使用的HTTP版本 |'
- en: '| CURLINFO_LASTSOCKET | long | Last socket used |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_LASTSOCKET | long | 最后使用的套接字 |'
- en: '| CURLINFO_LOCAL_IP | char * | Local-end IP address of last connection |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_LOCAL_IP | char * | 最后一次连接的本地端IP地址 |'
- en: '| CURLINFO_LOCAL_PORT | long | Local-end port of last connection |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_LOCAL_PORT | long | 最后一次连接的本地端口 |'
- en: '| CURLINFO_NAMELOOKUP_TIME | double | Time from start until name resolving
    completed |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_NAMELOOKUP_TIME | double | 从开始到名称解析完成的时间 |'
- en: '| CURLINFO_NUM_CONNECTS | long | Number of new successful connections used
    for previous transfer |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_NUM_CONNECTS | long | 用于上次传输的新成功连接数 |'
- en: '| CURLINFO_OS_ERRNO | long | The errno from the last failure to connect |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_OS_ERRNO | long | 上次连接失败的errno |'
- en: '| CURLINFO_PRETRANSFER_TIME | double | Time from start until just before the
    transfer begins |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_PRETRANSFER_TIME | double | 从开始到传输开始前的时间 |'
- en: '| CURLINFO_PRIMARY_IP | char * | IP address of the last connection |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_PRIMARY_IP | char * | 上次连接的IP地址 |'
- en: '| CURLINFO_PRIMARY_PORT | long | Port of the last connection |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_PRIMARY_PORT | long | 上次连接的端口 |'
- en: '| CURLINFO_PRIVATE | char * | User''s private data pointer |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_PRIVATE | char * | 用户私有数据指针 |'
- en: '| CURLINFO_PROTOCOL | long | The protocol used for the connection |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_PROTOCOL | long | 连接使用的协议 |'
- en: '| CURLINFO_PROXYAUTH_AVAIL | long | Available HTTP proxy authentication methods
    |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_PROXYAUTH_AVAIL | long | 可用的 HTTP 代理身份验证方法 |'
- en: '| CURLINFO_PROXY_SSL_VERIFYRESULT | long | Proxy certificate verification result
    |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_PROXY_SSL_VERIFYRESULT | long | 代理证书验证结果 |'
- en: '| CURLINFO_REDIRECT_COUNT | long | Total number of redirects that were followed
    |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_REDIRECT_COUNT | long | 已跟随的重定向总数 |'
- en: '| CURLINFO_REDIRECT_TIME | double | Time taken for all redirect steps before
    the final transfer |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_REDIRECT_TIME | double | 最终传输之前所有重定向步骤所花费的时间 |'
- en: '| CURLINFO_REDIRECT_URL | char * | URL a redirect would take you to, had you
    enabled redirects |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_REDIRECT_URL | char * | 如果启用重定向，则重定向将带您到的 URL |'
- en: '| CURLINFO_REQUEST_SIZE | long | Number of bytes sent in the issued HTTP requests
    |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_REQUEST_SIZE | long | 已发送的 HTTP 请求中的字节数 |'
- en: '| CURLINFO_RESPONSE_CODE | long | Last received response code |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_RESPONSE_CODE | long | 上次接收到的响应代码 |'
- en: '| CURLINFO_RTSP_CLIENT_CSEQ | long | RTSP CSeq that will next be used |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_RTSP_CLIENT_CSEQ | long | 下一个将被使用的 RTSP CSeq |'
- en: '| CURLINFO_RTSP_CSEQ_RECV | long | RTSP CSeq last received |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_RTSP_CSEQ_RECV | long | 上次接收到的 RTSP CSeq |'
- en: '| CURLINFO_RTSP_SERVER_CSEQ | long | RTSP CSeq that will next be expected |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_RTSP_SERVER_CSEQ | long | 下一个将被期望的 RTSP CSeq |'
- en: '| CURLINFO_RTSP_SESSION_ID | char * | RTSP session ID |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_RTSP_SESSION_ID | char * | RTSP 会话 ID |'
- en: '| CURLINFO_SCHEME | char * | The scheme used for the connection |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_SCHEME | char * | 连接使用的协议 |'
- en: '| CURLINFO_SIZE_DOWNLOAD | double | Number of bytes downloaded |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_SIZE_DOWNLOAD | double | 已下载字节数 |'
- en: '| CURLINFO_SIZE_UPLOAD | double | Number of bytes uploaded |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_SIZE_UPLOAD | double | 已上传字节数 |'
- en: '| CURLINFO_SPEED_DOWNLOAD | double | Average download speed |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_SPEED_DOWNLOAD | double | 平均下载速度 |'
- en: '| CURLINFO_SPEED_UPLOAD | double | Average upload speed |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_SPEED_UPLOAD | double | 平均上传速度 |'
- en: '| CURLINFO_SSL_ENGINES | struct curl_slist * | A list of OpenSSL crypto engines
    |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_SSL_ENGINES | struct curl_slist * | OpenSSL 加密引擎列表 |'
- en: '| CURLINFO_SSL_VERIFYRESULT | long | Certificate verification result |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_SSL_VERIFYRESULT | long | 证书验证结果 |'
- en: '| CURLINFO_STARTTRANSFER_TIME | double | Time from start until just when the
    first byte is received |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_STARTTRANSFER_TIME | double | 从开始到接收到第一个字节的时间 |'
- en: '| CURLINFO_TLS_SESSION | struct curl_slist * | TLS session info that can be
    used for further processing. (**Deprecated option, use CURLINFO_TLS_SSL_PTR instead!**)
    |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_TLS_SESSION | struct curl_slist * | 可用于进一步处理的 TLS 会话信息。（**已弃用选项，请使用
    CURLINFO_TLS_SSL_PTR 代替！**） |'
- en: '| CURLINFO_TLS_SSL_PTR | struct curl_slist * | TLS session info that can be
    used for further processing |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_TLS_SSL_PTR | struct curl_slist * | 可用于进一步处理的 TLS 会话信息 |'
- en: '| CURLINFO_TOTAL_TIME | double | Total time of previous transfer |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| CURLINFO_TOTAL_TIME | double | 上一次传输的总时间 |'
- en: Share data between handles
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理句柄之间共享数据
- en: Share data between handles
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理句柄之间共享数据
- en: Sometimes applications need to share data between transfers. All easy handles
    added to the same multi handle automatically get a lot of sharing done between
    the handles in that same multi handle, but sometimes that's not exactly what you
    want.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 有时应用程序需要在传输之间共享数据。所有添加到同一多句柄的简易句柄在同一多句柄中自动进行了许多共享，但有时这并不是您想要的。
- en: Multi handle
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多句柄
- en: All easy handles added to the same multi handle automatically share [cookies](libcurl-http-cookies.html),
    [connection cache](libcurl-connectionreuse), [dns cache](libcurl-names.html) and
    SSL sessiond id cache.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 所有添加到同一多句柄的简易句柄自动共享[cookies](libcurl-http-cookies.html)、[连接缓存](libcurl-connectionreuse)、[DNS
    缓存](libcurl-names.html)和 SSL 会话 ID 缓存。
- en: Sharing between easy handles
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在简易句柄之间共享
- en: libcurl has a generic "sharing interface", where the application creates a "share
    object" that then holds data that can be shared by any number of easy handles.
    The data is then stored and read from the shared object instead of kept witihn
    the handles that are sharing it.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 提供了一个通用的“共享接口”，应用程序创建一个“共享对象”，然后该对象保存数据，可以被任意数量的简易处理句柄共享。数据随后存储和读取自共享对象，而不是存储在共享它的处理句柄中。
- en: '[PRE43]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The shared object can be set to share all or any of cookies, conection cache,
    dns cache and SSL sessiond id cache.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 共享对象可以设置为共享所有或任何 cookie、连接缓存、DNS 缓存和 SSL 会话 ID 缓存。
- en: 'For example, setting up the share to hold cookies and dns cache:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，设置共享以保存 cookie 和 DNS 缓存：
- en: '[PRE44]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '... and then you setup the corresponding transfer to use this share object:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '...然后您设置相应的传输以使用此共享对象：'
- en: '[PRE45]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Transgers done with this `curl` handle will thus use and store its cookie and
    dns information in the `share` handle. You can set several easy handles to share
    the same share object.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此`curl`句柄完成的传输将使用并存储其cookie和dns信息在`share`句柄中。您可以设置多个easy句柄共享相同的共享对象。
- en: What to share
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分享什么
- en: '`CURL_LOCK_DATA_COOKIE` - set this bit to share cookie jar. Note that each
    easy handle still needs to get its cookie "engine" started properly to start using
    cookies.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`CURL_LOCK_DATA_COOKIE` - 设置此位以共享cookie jar。请注意，每个easy句柄仍然需要正确启动其cookie“引擎”才能开始使用cookie。'
- en: '`CURL_LOCK_DATA_DNS` - the DNS cache is where libcurl stores addresses for
    resolved host names for a while to make subsequent lookups faster.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`CURL_LOCK_DATA_DNS` - DNS缓存是libcurl存储已解析主机名地址一段时间以使后续查找更快的地方。'
- en: '`CURL_LOCK_DATA_SSL_SESSION` - the SSL session ID cache is where libcurl store
    resume information for SSL connections to be able to resume a previous connection
    faster.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`CURL_LOCK_DATA_SSL_SESSION` - SSL会话ID缓存是libcurl存储SSL连接的恢复信息，以便能够更快地恢复先前的连接。'
- en: '`CURL_LOCK_DATA_CONNECT` - when set, this handle will use a shared connection
    cache and thus will probably be more likely to find existing connections to re-use
    etc, which may result in faster performance when doing multiple transfers to the
    same host in a serial manner.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`CURL_LOCK_DATA_CONNECT` - 当设置时，此句柄将使用共享连接缓存，因此可能更有可能找到现有连接以重复使用等，这可能会在以串行方式向同一主机执行多个传输时提高性能。'
- en: Locking
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁定
- en: If you want have the share object shared by transfers in a multi-threaded environment.
    Perhaps you have a CPU with many cores and you want each core to run its own thread
    and transfer data, but you still want the different transfers to shara data. Then
    you need to set the mutex callbacks.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在多线程环境中由传输共享对象共享。也许您有一个拥有许多核心的CPU，并且希望每个核心运行自己的线程并传输数据，但仍希望不同的传输共享数据。那么您需要设置互斥回调。
- en: If you don't use threading and you *know* you access the shared object in a
    serial one-at-a-time manner you don't need to set any locks. But if there is ever
    more than one tranfser that access share object at a time, it needs to get mutex
    callbacks setup to prevent data destruction and possibly even crashes.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用线程，并且*知道*您以串行一次访问共享对象的方式访问共享对象，则无需设置任何锁。但是，如果有多个传输同时访问共享对象，需要设置互斥回调以防止数据破坏甚至崩溃。
- en: 'Since libcurl itself doesn''t know how to lock things or even what threading
    model you''re using, you must make sure to do mutex locks that only allows one
    access at a time. A lock callback for a pthreads-using application could look
    similar to:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 由于libcurl本身不知道如何锁定事物，甚至不知道您正在使用什么线程模型，因此您必须确保进行互斥锁定，只允许一次访问。用于pthread应用程序的锁回调可能类似于：
- en: '[PRE46]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'With the corresponding unlock callback could look like:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 与相应的解锁回调可能如下所示：
- en: '[PRE47]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Unshare
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不共享
- en: TBD
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: API compatibility
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API兼容性
- en: API compatibility
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API兼容性
- en: libcurl promises API stability and guarantees that your program written today
    will remain working in the future. We don't break compatibility.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl承诺API稳定性，并保证您今天编写的程序将在未来继续运行。我们不会破坏兼容性。
- en: Over time, we add features, new options and new functions to the APIs but we
    do not change behavior in a non-compatible way or remove functions.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们向API添加功能、新选项和新功能，但我们不以不兼容的方式更改行为或删除功能。
- en: The last time we changed the API in an non-compatible way was for 7.16.0 in
    2006 and we plan to never do it again.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上次以不兼容的方式更改API是在2006年的7.16.0版本，我们计划永远不再这样做。
- en: Version numbers
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 版本号
- en: Curl and libcurl are individually versioned, but they mostly follow each other
    rather closely.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Curl和libcurl具有各自的版本，但它们大多数情况下相互紧密跟随。
- en: 'The version numbering is always built up using the same system:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 版本编号始终使用相同的系统构建：
- en: '[PRE48]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: X is main version number
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X是主版本号
- en: Y is release number
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Y是发布号
- en: Z is patch number
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Z是补丁号
- en: Bumping numbers
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提升数字
- en: One of these X.Y.Z numbers will get bumped in every new release. The numbers
    to the right of a bumped number will be reset to zero.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这些X.Y.Z数字中的一个将在每个新版本中被提升。被提升数字右侧的数字将被重置为零。
- en: The main version number X is bumped when *really* big, world colliding changes
    are made. The release number Y is bumped when changes are performed or things/features
    are added. The patch number Z is bumped when the changes are mere bugfixes.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行了*真正*的巨大、影响深远的更改时，主版本号 X 会增加。当进行更改或添加事物/功能时，发布号 Y 会增加。当进行的更改仅是修复错误时，补丁号 Z
    会增加。
- en: It means that after a release 1.2.3, we can release 2.0.0 if something really
    big has been made, 1.3.0 if not that big changes were made or 1.2.4 if mostly
    bugs were fixed.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在发布 1.2.3 后，如果进行了非常大的更改，我们可以发布 2.0.0，如果没有进行太大的更改，则可以发布 1.3.0，如果主要修复了错误，则可以发布
    1.2.4。
- en: Bumping, as in increasing the number with 1, is unconditionally only affecting
    one of the numbers (and the ones to the right of it are set to zero). 1 becomes
    2, 3 becomes 4, 9 becomes 10, 88 becomes 89 and 99 becomes 100\. So, after 1.2.9
    comes 1.2.10\. After 3.99.3, 3.100.0 might come.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 增加，即将数字增加 1，无条件地只影响一个数字（其右边的数字设置为零）。1 变成 2，3 变成 4，9 变成 10，88 变成 89，99 变成 100。因此，在
    1.2.9 之后是 1.2.10。在 3.99.3 之后，可能是 3.100.0。
- en: All original curl source release archives are named according to the libcurl
    version (not according to the curl client version that, as said before, might
    differ).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 所有原始的 curl 源代码发布档案都根据 libcurl 版本命名（而不是根据可能不同的 curl 客户端版本命名）。
- en: Which libcurl version
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用哪个 libcurl 版本
- en: 'As a service to any application that might want to support new libcurl features
    while still being able to build with older versions, all releases have the libcurl
    version stored in the `curl/curlver.h` file using a static numbering scheme that
    can be used for comparison. The version number is defined as:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对任何可能希望支持新 libcurl 功能的应用程序的一种服务，同时仍然能够使用旧版本进行构建，所有发布版本都将 libcurl 版本存储在 `curl/curlver.h`
    文件中，使用静态编号方案可用于比较。版本号定义为：
- en: '[PRE49]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Where XX, YY and ZZ are the main version, release and patch numbers in hexadecimal.
    All three number fields are always represented using two digits (eight bits each).
    1.2.0 would appear as "0x010200" while version 9.11.7 appears as "0x090b07".
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 XX、YY 和 ZZ 分别是十六进制中的主版本号、发布版本号和补丁号。所有三个数字字段始终使用两位数表示（每个八位）。1.2.0 将显示为 "0x010200"，而版本
    9.11.7 则显示为 "0x090b07"。
- en: This 6-digit hexadecimal number is always a greater number in a more recent
    release. It makes comparisons with greater than and less than work.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 6 位十六进制数在更近期的发布中总是一个更大的数。它使得大于和小于的比较起作用。
- en: 'This number is also available as three separate defines: `LIBCURL_VERSION_MAJOR`,
    `LIBCURL_VERSION_MINOR` and `LIBCURL_VERSION_PATCH`.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 此数字也作为三个单独的定义可用：`LIBCURL_VERSION_MAJOR`、`LIBCURL_VERSION_MINOR` 和 `LIBCURL_VERSION_PATCH`。
- en: These defines are, of course, only suitable to figure out the version number
    built *just now* and they won't help you figuring out which libcurl version that
    is used at run-time three years from now.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些定义仅适用于确定刚刚构建的版本号，它们无法帮助您确定三年后运行时使用的 libcurl 版本。
- en: Which libcurl version runs
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行的是哪个 libcurl 版本
- en: To figure out which libcurl version that your application is using *right now*,
    `curl_version_info()` is there for you.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定您的应用程序当前使用的是哪个 libcurl 版本，`curl_version_info()` 就在那里为您服务。
- en: Applications should use this function to judge if things are possible to do
    or not, instead of using compile-time checks, as dynamic/DLL libraries can be
    changed independent of applications.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应该使用此函数来判断是否可以执行某些操作，而不是使用编译时检查，因为动态/DLL 库可以独立于应用程序进行更改。
- en: curl_version_info() returns a pointer to a struct with information about version
    numbers and various features and in the running version of libcurl. You call it
    by giving it a special age counter so that libcurl knows the "age" of the libcurl
    that calls it. The age is a define called `CURLVERSION_NOW` and is a counter that
    is increased at irregular intervals throughout the curl development. The age number
    tells libcurl what struct set it can return.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: curl_version_info() 返回一个指向包含有关版本号和正在运行的 libcurl 中各种特性的信息的结构体的指针。调用时，您需要给它一个特殊的年龄计数器，以便
    libcurl 知道调用它的 libcurl 的 "年龄"。年龄是一个名为 `CURLVERSION_NOW` 的定义，它是一个在 curl 开发的不规则间隔内不断增加的计数器。年龄数告诉
    libcurl 它可以返回哪个结构集。
- en: 'You call the function like this:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以这样调用该函数：
- en: curl_version_info_data *ver = curl_version_info( CURLVERSION_NOW );
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: curl_version_info_data *ver = curl_version_info( CURLVERSION_NOW );
- en: 'The data will then be pointing at struct that has or at least can have the
    following layout:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 数据将指向具有或至少可以具有以下布局的结构体：
- en: '[PRE50]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: --libcurl
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: --libcurl
- en: curl --libcurl
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: curl --libcurl
- en: We actively encourage users to first try out the transfer they want to do with
    the curl command-line tool, and once it works roughly the way you want it to,
    you append the `--libcurl [filename]` option to the command line and run it again.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们积极鼓励用户首先尝试使用 curl 命令行工具进行他们想要的传输，一旦它大致按照你想要的方式工作，你就可以在命令行中附加 `--libcurl [filename]`
    选项并再次运行它。
- en: The `--libcurl` command-line option will create a C program in the provided
    file name. That C program is an application that uses libcurl to run the transfer
    you just had the curl command-line tool do. There are some exceptions and it isn't
    always a 100% match, but you will find that it can serve as an excellent inspiration
    source for what libcurl options you want or can use and what additional arguments
    to provide to them.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`--libcurl` 命令行选项将在提供的文件名中创建一个 C 程序。该 C 程序是一个使用 libcurl 运行刚刚由 curl 命令行工具完成的传输的应用程序。有一些例外情况，它并不总是100%匹配，但你会发现它可以作为你想要或可以使用的
    libcurl 选项以及为它们提供的其他参数的优秀灵感来源。'
- en: If you specify the filename as a single dash, as in `--libcurl -` you will get
    the program written to stdout instead of a file.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将文件名指定为一个破折号，如 `--libcurl -`，则会将程序写入标准输出而不是文件。
- en: 'As an example, we run a command to just get [http://example.com](http://example.com):'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们运行一个命令来仅获取 [http://example.com](http://example.com)：
- en: '[PRE51]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This creates `example.c` in the current directory, looking similar to this:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在当前目录中创建 `example.c`，看起来类似于这样：
- en: '[PRE52]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Header files
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头文件
- en: Header files
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头文件
- en: 'There is only ever one header your libcurl using application needs to include:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 libcurl 使用应用程序只需要包含一个头文件：
- en: '[PRE53]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: That file in turn includes a few other public header files but you can basically
    pretend they don't exist. (Historically speaking, we started out slightly different
    but over time we have stabilized around this form of only using a single one for
    includes.)
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件又包含了一些其他的公共头文件，但你基本上可以假装它们不存在。（从历史的角度来看，我们开始时略有不同，但随着时间的推移，我们稳定下来了，只使用一个头文件进行包含。）
- en: Global initialization
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局初始化
- en: Global initialization
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局初始化
- en: Before you do anything libcurl related in your program, you should do a global
    libcurl initialize call with `curl_global_init()`. This is necessary because some
    underlying libraries that libcurl might be using need a call ahead to get setup
    and initialized properly.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中进行任何与 libcurl 相关的操作之前，你应该使用 `curl_global_init()` 进行全局 libcurl 初始化调用。这是必要的，因为
    libcurl 可能正在使用的一些底层库需要先进行调用来正确设置和初始化。
- en: curl_global_init() is, unfortunately, not thread safe, so you must ensure that
    you only do it once and never simultaneously with another call. It initializes
    global state so you should only call it once, and once your program is completely
    done using libcurl you can call `curl_global_cleanup()` to free and clean up the
    associated global resources the init call allocated.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl_global_init()` 不幸地不是线程安全的，所以你必须确保你只调用一次，并且不要与另一个调用同时进行。它初始化全局状态，所以你应该只调用一次，一旦你的程序完全停止使用
    libcurl，你可以调用 `curl_global_cleanup()` 来释放和清理初始化调用分配的相关全局资源。'
- en: libcurl is built to handle the situation where you skip the `curl_global_init()`
    call, but it does so by calling it itself instead (if you didn't do it before
    any actual file transfer starts) and it then uses its own defaults. But beware
    that it is still not thread safe even then, so it might cause some "interesting"
    side effects for you. It is much better to call curl_global_init() yourself in
    a controlled manner.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 构建为处理跳过 `curl_global_init()` 调用的情况，但它会自己调用它（如果你在任何实际文件传输开始之前没有这样做）并使用自己的默认值。但请注意，即使在这种情况下，它仍然不是线程安全的，因此它可能会给你带来一些
    "有趣" 的副作用。最好还是以受控的方式自己调用 `curl_global_init()`。
- en: multi-threading
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程
- en: libcurl multi-threading
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: libcurl 多线程
- en: libcurl is thread safe but has no internal thread synchronization. You may have
    to provide your own locking or change options to properly use libcurl threaded.
    Exactly what is required depends on how libcurl was built. Please refer to the
    [libcurl thread safety](https://curl.haxx.se/libcurl/c/threadsafe.html) webpage,
    which contains the latest information.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 是线程安全的，但没有内部线程同步。你可能需要提供自己的锁定或更改选项以正确使用 libcurl 线程化。具体需要什么取决于 libcurl
    的构建方式。请参阅 [libcurl 线程安全](https://curl.haxx.se/libcurl/c/threadsafe.html) 网页，其中包含最新信息。
- en: curl easy options
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: curl 简易选项
- en: Set handle options
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置句柄选项
- en: You set options in the easy handle to control how that transfer is going to
    be done, or in some cases you can actually set options and modify the transfer's
    behavior while it is in progress. You set options with `curl_easy_setopt()` and
    you provide the handle, the option you want to set and the argument to the option.
    All options take exactly one argument and you must always pass exactly three parameters
    to the curl_easy_setopt() calls.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 您在easy句柄中设置选项以控制传输的执行方式，或者在某些情况下，您实际上可以在传输进行时设置选项并修改传输的行为。您使用`curl_easy_setopt()`设置选项，并提供句柄、要设置的选项和选项的参数。所有选项都只接受一个参数，您必须始终向curl_easy_setopt()调用传递三个参数。
- en: Since the curl_easy_setopt() call accepts several hundred different options
    and the various options accept a variety of different types of arguments, it is
    very important to read up on the specifics and provide exactly the argument type
    the specific option supports and expects. Passing in the wrong type can lead to
    unexpected side-effects or hard to understand hiccups.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 由于curl_easy_setopt()调用接受几百种不同的选项，而各种选项接受各种不同类型的参数，因此非常重要阅读具体内容，并提供特定选项支持和期望的确切参数类型。传递错误类型可能导致意外副作用或难以理解的问题。
- en: 'The perhaps most important option that every transfer needs, is the URL. libcurl
    cannot perform a transfer without knowing which URL it concerns so you must tell
    it. The URL option name is `CURLOPT_URL` as all options are prefixed with `CURLOPT_`
    and then the descriptive name—all using uppercase letters. An example line setting
    the URL to get the "[http://example.com](http://example.com)" HTTP contents could
    look like:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 每个传输可能最重要的选项是URL。libcurl无法在不知道涉及哪个URL的情况下执行传输，因此您必须告诉它。URL选项名称为`CURLOPT_URL`，因为所有选项都以`CURLOPT_`为前缀，然后是描述性名称——全部使用大写字母。设置将URL设置为获取"[http://example.com](http://example.com)"
    HTTP内容的示例行可能如下：
- en: '[PRE54]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Again: this only sets the option in the handle. It will not do the actual transfer
    or anything. It will basically just tell libcurl to copy the string and if that
    works it returns OK.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调：这只是在句柄中设置选项。它不会执行实际传输或其他任何操作。它基本上只是告诉libcurl复制字符串，如果成功则返回OK。
- en: It is, of course, good form to check the return code to see that nothing went
    wrong.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，检查返回代码以确保没有出现问题是一个好习惯。
- en: Setting numerical options
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置数字选项
- en: Since curl_easy_setopt() is a vararg function where the 3rd argument can use
    different types depending on the situation, normal C language type conversion
    cannot be done. So you **must** make sure that you truly pass a 'long' and not
    an 'int' if the documentation tells you so. On architectures where they are the
    same size, you may not get any problems but not all work like that. Similarly,
    for options that accept a 'curl_off_t' type, it is **crucial** that you pass in
    an argument using that type and no other.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 由于curl_easy_setopt()是一个可变参数函数，第三个参数可以根据情况使用不同类型，因此无法进行正常的C语言类型转换。因此，**必须**确保您确实传递了'long'而不是'int'，如果文档告诉您如此。在它们大小相同的架构上，您可能不会遇到任何问题，但并非所有都是这样。同样，对于接受'curl_off_t'类型的选项，**至关重要**的是您传递使用该类型而不是其他类型的参数。
- en: 'Enforce a long:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 强制为long：
- en: '[PRE55]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Enforce a curl_off_t:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '强制为curl_off_t:'
- en: '[PRE56]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Get handle options
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取句柄选项
- en: No, there's no general method to extract the same information you previously
    set with `curl_easy_setopt()`! If you need to be able to extract the information
    again that you set earlier, then we encourage you to keep track of that data yourself
    in your application.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 不，没有通用方法可以提取之前使用`curl_easy_setopt()`设置的相同信息！如果您需要能够再次提取您之前设置的信息，那么我们鼓励您在应用程序中自行跟踪这些数据。
- en: CURLcode return codes
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CURLcode返回代码
- en: CURLcode return code
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CURLcode返回代码
- en: Many libcurl functions return a CURLcode. That's a special libcurl typedefed
    variable for error codes. It returns `CURLE_OK` (which has the value zero) if
    everything is fine and dandy and it returns a non-zero number if a problem was
    detected. There are almost one hundred `CURLcode` errors in use, and you can find
    them all in the `curl/curl.h` header file and documented in the libcurl-errors
    man page.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 许多libcurl函数返回一个CURLcode。这是一个特殊的libcurl typedefed变量，用于错误代码。如果一切正常，它将返回`CURLE_OK`（其值为零），如果检测到问题，则返回非零数字。几乎有一百个`CURLcode`错误在使用中，您可以在`curl/curl.h`头文件中找到它们，并在libcurl-errors手册页中找到它们的文档。
- en: 'You can convert a CURLcode into a human readable string with the `curl_easy_strerror()`
    function—but be aware that these errors are rarely phrased in a way that is suitable
    for anyone to expose in a UI or to an end user:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `curl_easy_strerror()` 函数将 CURLcode 转换为人类可读的字符串，但请注意，这些错误很少以适合在 UI 中向任何人公开或向最终用户公开的方式表达：
- en: '[PRE57]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Another way to get a slightly better error text in case of errors is to set
    the `CURLOPT_ERRORBUFFER` option to point out a buffer in your program and then
    libcurl will store a related error message there before it returns an error:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在发生错误时，另一种获取稍微更好的错误文本的方法是将 `CURLOPT_ERRORBUFFER` 选项设置为指向程序中的缓冲区，然后 libcurl 将在返回错误之前在那里存储相关的错误消息：
- en: '[PRE58]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Verbose operations
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冗长的操作
- en: Verbose operations
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冗长的操作
- en: Okay, we just showed how to get the error as a human readable text as that is
    an excellent help to figure out what went wrong in a particular transfer and often
    explains why it can be done like that or what the problem is for the moment.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们刚刚展示了如何将错误作为人类可读的文本获取，因为这对于弄清楚特定传输出了什么问题并经常解释为什么可以这样做或者问题出在哪里非常有帮助。
- en: 'The next lifesaver when writing libcurl applications that everyone needs to
    know about and needs to use extensively, at least while developing libcurl applications
    or debugging libcurl itself, is to enable "verbose mode" with `CURLOPT_VERBOSE`:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 写 libcurl 应用程序时的下一个救星，每个人都需要了解并且至少在开发 libcurl 应用程序或调试 libcurl 本身时需要广泛使用，那就是使用
    `CURLOPT_VERBOSE` 启用 "详细模式"：
- en: '[PRE59]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: When libcurl is told to be verbose it will mention transfer-related details
    and information to stderr while the transfer is ongoing. This is awesome to figure
    out why things fail and to learn exactly what libcurl does when you ask it different
    things. You can redirect the output elsewhere by changing stderr with `CURLOPT_STDERR`
    or you can get even more info in a fancier way with the debug callback (explained
    further in a later section).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 当告诉 libcurl 要冗长时，它将在传输正在进行时将与传输相关的详细信息和信息输出到 stderr。这对于弄清楚为什么事情失败以及在您询问它不同的事情时
    libcurl 到底做了什么非常有用。您可以通过更改 stderr 为 `CURLOPT_STDERR` 重定向输出，或者您可以通过调试回调以更精致的方式获取更多信息（在后面的一节中进一步解释）。
- en: Trace everything
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 追踪所有事物
- en: Verbose is certainly fine, but sometimes you need more. libcurl also offers
    a trace callback that in addition to showing you all the stuff the verbose mode
    does, it also passes on *all* data sent and received so that your application
    gets a full trace of everything.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 冗长是完全可以的，但有时您需要更多。libcurl 还提供了一个跟踪回调，除了显示详细模式所显示的所有内容之外，还传递了*所有*发送和接收的数据，以便您的应用程序获得关于所有内容的完整跟踪。
- en: The sent and received data passed to the trace callback is given to the callback
    in its unencrypted form, which can be very handy when working with TLS or SSH
    based protocols when capturing the data off the network for debugging isn't very
    practical.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给跟踪回调的发送和接收数据以其未加密的形式传递给回调函数，这在处理基于 TLS 或 SSH 的协议时非常方便，因为在网络上捕获数据以进行调试并不是很实用。
- en: When you set the `CURLOPT_DEBUGFUNCTION` option, you still need to have `CURLOPT_VERBOSE`
    enabled but with the trace callback set libcurl will use that callback instead
    of its internal handling.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 当您设置了 `CURLOPT_DEBUGFUNCTION` 选项时，仍然需要启用 `CURLOPT_VERBOSE`，但是通过设置跟踪回调 libcurl
    将使用该回调而不是其内部处理。
- en: 'The trace callback should match a prototype like this:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪回调应该匹配以下原型：
- en: '[PRE60]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**handle** is the easy handle it concerns, **type** describes the particular
    data passed to the callback (data in/out, header in/out, TLS data in/out and "text"),
    **ptr** points to the data being **size** number of bytes. **userp** is the custom
    pointer you set with `CURLOPT_DEBUGDATA`.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '**handle** 是易于处理的句柄，**type** 描述了传递给回调函数的特定数据（数据输入/输出、头部输入/输出、TLS 数据输入/输出和 "text"），**ptr**
    指向的数据是 **size** 字节的数据。**userp** 是您用 `CURLOPT_DEBUGDATA` 设置的自定义指针。'
- en: The data pointed to by **ptr** *will not* be zero terminated, but will be exactly
    of the size as told by the **size** argument.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '**ptr** 指向的数据*不会*以零终止，但其大小将完全由 **size** 参数指定。'
- en: The callback must return 0 or libcurl will consider it an error and abort the
    transfer.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数必须返回0，否则 libcurl 将视为错误并中止传输。
- en: On the curl web site, we host an example called [debug.c](https://curl.haxx.se/libcurl/c/debug.html)
    that includes a simple trace function to get inspiration from.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在 curl 网站上，我们托管了一个名为 [debug.c](https://curl.haxx.se/libcurl/c/debug.html) 的示例，其中包含一个简单的跟踪函数以供参考。
- en: There are also additional details in the [CURLOPT_DEBUGFUNCTION man page](https://curl.haxx.se/libcurl/c/CURLOPT_DEBUGFUNCTION.html).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [CURLOPT_DEBUGFUNCTION man page](https://curl.haxx.se/libcurl/c/CURLOPT_DEBUGFUNCTION.html)
    中还有更多细节。
- en: libcurl examples
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: libcurl 示例
- en: libcurl examples
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: libcurl 示例
- en: The native API for libcurl is in C so this chapter is focussed on examples written
    in C. But since many language bindings for libcurl are thin, they usually expose
    more or less the same functions and thus they can still be interesting and educational
    for users of other languages, too.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: libcurl 的本机 API 是用 C 编写的，因此本章重点介绍用 C 编写的示例。但由于 libcurl 的许多语言绑定都很简单，它们通常公开的函数多多少少相同，因此它们对其他语言的用户也可能是有趣且教育性的。
- en: Get a simple HTML page
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取简单的 HTML 页面
- en: 'This example just fetches the HTML and sends it to stdout:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例仅获取 HTML 并将其发送到 stdout：
- en: '[PRE61]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Get a HTML page in memory
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在内存中获取 HTML 页面
- en: This example is a variation of the former that instead of sending the data to
    stdout (which often is not what you want), this stores the received data in a
    memory buffer that is made larger as the incoming data grows.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例是前一个示例的变体，不是将数据发送到 stdout（通常不是你想要的），而是将接收到的数据存储在内存缓冲区中，随着传入数据的增长而变大。
- en: It accomplishes this by usuing the write callback to receive the data.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用写回调来接收数据来实现此目的。
- en: '[PRE62]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Submit a login form over HTTP
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 HTTP 提交登录表单
- en: TBD
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Get an FTP directory listing
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取 FTP 目录列表
- en: TBD
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Download an HTTPS page straight into memory
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接将 HTTPS 页面下载到内存中
- en: TBD
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: Upload data to an HTTP site without blocking
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不阻塞的情况下将数据上传到 HTTP 站点
- en: TBD
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: for C++ programmers
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适用于 C++ 程序员
- en: libcurl for C++ programmers
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适用于 C++ 程序员的 libcurl
- en: TBD
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 待定
- en: strings are C strings, not C++ string objects
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串是 C 字符串，而不是 C++ 字符串对象
- en: callback considerations
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调考虑事项
