- en: Laziness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most mainstream functional languages employ an *eager* (a.k.a. *strict*) evaluation
    strategy, where an expression is evaluated entirely even if its resulting value
    is not needed or only parts of it are needed. As we will see, there are sometimes
    advantages in *lazily* evaluating certain expressions. There are two important
    aspects of lazy evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*suspending* (a.k.a *delaying*) a computation until its result is actually
    needed (a.k.a *demanded* or *forced*); and'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*memoizing* (a.k.a *caching*) the result of a suspended computation in case
    its value is demanded again.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Many eager languages, including Elm, offer additional language constructs for
    selectively introducing laziness. We will work through two example encodings —
    natural numbers and streams — that motivate and illustrate lazy evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Natural Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will work through a few encodings of natural numbers and define some simple
    operations on them.
  prefs: []
  type: TYPE_NORMAL
- en: First Version — [`Nat.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Laziness/Nat.elm)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We start by inductively defining `Nat`ural numbers to be either `Z`ero or the
    `S`uccessor of some other `Nat`ural number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's define functions `toInt` and `fromInt` to convert `Nat`ural numbers
    to and from `Int`egers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we take `fromInt` for a spin, we see that it busts the stack rather quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Ah, right, we should define functions tail-recursively and use the [`Trampoline`](http://package.elm-lang.org/packages/elm-lang/core/1.1.0/Trampoline)
    library so that they run in constant stack space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That should do the trick...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Or not. Okay, it's time for a little more investigative journalism. We could
    fire up Elm Reactor to start debugging. Or we can be lazy (pun intended) and continue
    to poke around at the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That's interesting. The call to `fromInt` was not the problem. So the act of
    printing the resulting `Nat` causes the stack overflow? Let's write our own (trampolined)
    printing function to test this hypothesis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Sure enough, that does the trick... until we run out of heap space, that is.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Okay, now that we have sorted out our call stack and heap space concerns, let's
    return to the task of programming with `Nat`s. We can add two `Nat`s together
    by peeling `S`uccessor labels off of `y` one at a time and wrapping them around
    `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This `plus` function encodes the usual notion of addition for our `Nat` type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can define `eq`uality for `Nat`s by peeling off one data constructor at a
    time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This seems to work just fine...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '... but it is really slow for some comparisons that seem like they should be
    easy to decide quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that, under eager evaluation, both `Nat`ural numbers are evaluated
    completely before calling `eqNat`, which then very quickly decides the last two
    disequalities.
  prefs: []
  type: TYPE_NORMAL
- en: Delaying Evaluation with Thunks — [`ThunkNat.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Laziness/ThunkNat.elm)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A common approach to delaying the evaluation of an expression `e` of type `a`
    in an eager language is to define a function `\() -> e`, called a *thunk*, that
    waits for a dummy argument before evaluating the expression.
  prefs: []
  type: TYPE_NORMAL
- en: We will port the implementations above in order to delay computing the representations
    of natural numbers. In our new representation of `Nat`s, a `S`uccessor value stores
    the delayed computation of the `Nat` that it succeeds. The `force` function is
    used to evaluate a suspended computation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that implementing a function like the following is *not* a good idea, because
    a call to `delay` will force its argument to be evaluated!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To implement `fromInt`, we no longer need to `trampoline` because there are
    no direct recursive calls; instead, the latter case immediately returns a `S`uccessor
    value (which may some time later lead to a call to `fromInt`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that our new representation of non-`Z`ero numbers is quite different
    from before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Unlike `fromInt`, `toInt` *does* need to make recursive calls immediately, because
    the resulting type (`Int`) does not have the notion of delayed computation built
    in to its representation. Therefore, we will want to employ the `trampoline` strategy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, `fromInt` and `toInt` are inverses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice how `toInt` uses `force` to evaluate all of the nested suspensions that
    are stored within a `Nat`. A function like this is called *monolithic*, whereas
    a function like `fromInt` is called *incremental* because it does not trigger
    the evaluation of all nested suspensions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Another example of a monolithic function is `strNat`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: However, this function is no longer needed for its original purpose above, because
    printing the representation of a `S`uccessor value is now very quick.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can now return to our motivation for delaying the evaluation of `Nat`s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When `x` and `y` represent the same number, `eqNat` evaluates all of the nested
    suspensions in both `x` and `y`. Otherwise, it evaluates only enough of their
    delayed representations in order to demonstrate a difference in corresponding
    data constructors. As a result, all of the following comparisons run quickly,
    unlike with our original [`Nat.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Laziness/Nat.elm)
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We finish porting the original module with the following incremental implementation
    of `plus`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As a result, the following comparison evaluates quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Aside:** What happens if we ask Elm to compare `Nat`s using built-in equality?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Elm throws a run-time error when trying to compare two different function values.
    Fair enough. Notice that "physical equality" between function values is supported,
    however.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Memoizing Thunks — [`LazyNat.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Laziness/LazyNat.elm)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Defining suspensions and incremental functions can be really valuable techniques,
    but there's no free lunch. The representation of a thunk is a *closure*, which
    is a function to evaluate along with bindings for all free variables referred
    to by the function. Delaying computations willy nilly, then, can lead to a huge
    number of these closures building up. So one should restrict the use of thunks
    to situations where the benefits of being able to define incremental function
    outweights the overheads associated with delayed computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another concern is that the same delayed computation may be demanded more than
    once. If the computation takes significant resources to evaluate, then redoing
    the work every time is undesirable. In a pure language with only strict evaluation,
    there is no recourse: every time a thunk is forced, it must be re-evaluated. As
    a result, many strict languages offer special-purpose constructs for manipulating
    delayed computations with the guarantee that the result of forcing a delayed computation
    is cached in case it is forced again in the future. The term *lazy evaluation*
    is often used to describe support for delayed computations with the guarantee
    of evaluating any such computation at most once.'
  prefs: []
  type: TYPE_NORMAL
- en: In Elm, the [`Lazy`](http://package.elm-lang.org/packages/maxsnew/lazy/1.0.0/Lazy)
    library provides support for lazy evaluation. (`Lazy` is a community library,
    so an [`elm-package.json`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Laziness/elm-package.json)
    file is required to declare this dependency.) The `lazy` function turns a `Thunk
    a` into a `Lazy a` value, which `force` evaluates, reusing the result of any previous
    call to `force`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The [native JavaScript implementation](https://github.com/maxsnew/lazy/blob/1.0.0/src/Native/Lazy.js)
    of `lazy` uses a mutable variable (called `isForce`) to track whether the particular
    thunk has been evaluated and a mutable variable (called `value`) to store this
    result.
  prefs: []
  type: TYPE_NORMAL
- en: It is simple to port [`ThunkNat.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Laziness/ThunkNat.elm)
    to use the `Lazy` library in order to obtain the benefits of memoization. First,
    we redefine the type of `Nat` as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Then, we sprinkle a call to `lazy` in front of every thunked value. The resulting
    implementation can be found in [`LazyNat.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Laziness/LazyNat.elm).
    (Use `diff` or `vimdiff` to see how similar the two files are.)
  prefs: []
  type: TYPE_NORMAL
- en: Using this implementation, we now expect that `force`-ing an expensive suspension
    for the second time should be practically instantaneous. As we discussed above,
    the worst case for `eqNat` is when both its arguments are equal. So let's use
    a call to `eqNat` as an example of a slow computation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The last operation above is quite slow. So, we should be able to delay its evaluation,
    `force` and memoize its result, and reevaluate it a second time nearly instantaneously.
    But the second `force` is just as slow as the first!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Good thing we still have our investigative journalist hats on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: These two expressions require about the same amount of time to evaluate, which
    suggests that caching is kicking in for the latter case. So it appears that the
    native memo tables do not persist across REPL operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Exercise** — Write an Elm program that measures the time it takes
    to evaluate the previous two expressions (for example, using `Time.fps`).'
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common data structure that incorporates laziness is a *stream* (a.k.a. *lazy
    list*). Having worked through laziness in Elm in detail using the previous examples,
    our discussion of streams here will be brief, mainly focusing on picking the right
    representation.
  prefs: []
  type: TYPE_NORMAL
- en: First Attempt — [`NotSoLazyList.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Laziness/NotSoLazyList.elm)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One possibility for representing `LazyList`s is the following type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This datatype describes lists that are not very lazy, however. We can define
    a function `range : Int -> Int -> LazyList Int` and demonstrate how a `LazyList`
    of *n* elements immediately builds *n* `Cons` cells.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Second Attempt — [`PrettyLazyList.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Laziness/PrettyLazyList.elm)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another option is the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty good, but notice that a non-`Nil` list must have its first value
    evaluated. Consider what the representation of a `range` of `Int`s looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Final Attempt — [`LazyList.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Laziness/LazyList.elm)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What we really want is for all elements in the list, including the first, to
    be delayed until needed. We can achieve this as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Something to consider: why didn''t we use a similar strategy in defining the
    the lazy `Nat`s before?'
  prefs: []
  type: TYPE_NORMAL
- en: The `range` function is incremental. Notice the *trivial* suspension `lazy (\_
    -> Nil)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can also describe infinite streams.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `take` function is incremental.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'A lazier version of `take`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Incremental function in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting a stream to a `List` is monolithic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `drop` function is also monolithic, but does not necessarily force every
    suspension in the stream.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Combining two streams using `append` is incremental.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Reversing a stream is monolithic. Notice that `lazy (\_ -> Cons x acc)` is another
    example of a trivial thunk. The values `x` and `acc` have already been evaluated,
    so building the `Cons` value does not force any additional computations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Our final monolithic example function checks for equality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As with equality on `Nat`s, our implementation of equality for `LazyList`s can
    decide disequalities more quickly than for regular `List`s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Required
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Okasaki, Chapter 4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
