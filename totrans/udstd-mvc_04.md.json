["```\n- disable notifications, to the operations, re-enable the notifications.\n  this has the disadavantage that you might not know what notifications to \n  send when they are re-enabled. One solution could be to spool them,\n  and at re-enable, merge the duplicates and send out the minimum.\n- have coarse grained operations, operating on large sets and sending out \n  only one notification at the end.\n- Have fine grained modification routines with an option notify that allows\n  to decide when to send the notification and when not to.\n- Have the model be a centralizer of the notification delivery, but have notifyObserver called\n  externally. \n- have a smart signal that can be put in a \"trasaction on\" mode, and accumulates the\n  notifications, and then release the notification when a \"commit\" is issued \n```", "```\n import wx\n    from wx.lib.pubsub import Publisher\n\n    class Model:\n        def __init__(self):\n            self.myMoney = 0\n\n        def addMoney(self, value):\n            self.myMoney += value\n            Publisher.sendMessage(\"MONEY CHANGED\", self.myMoney) \n```", "```\n class Controller:\n        def __init__(self, app):\n            # <...>\n            pub.subscribe(self.moneyChangedHandler, \"MONEY CHANGED\")\n\n        def moneyChangedHandler(self, message):\n            \"\"\"\n            This method is the handler for \"MONEY CHANGED\" messages,\n            which pubsub will call as messages are sent from the model.\n\n            We already know the topic is \"MONEY CHANGED\", but if we\n            didn't, message.topic would tell us.\n            \"\"\"\n            self.view.setMoney(message.data) \n```"]