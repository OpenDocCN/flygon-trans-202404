["```\nif:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  S\u00a0  subtype-of\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Tthen: (Listof S)\u00a0 subtype-of\u00a0 (Listof T)\n```", "```\nif:\u00a0 \u00a0 \u00a0 \u00a0  S\u00a0 subtype-of\u00a0 \u00a0 \u00a0  Tthen:\u00a0 Q -> S\u00a0 subtype-of\u00a0 Q -> T\n```", "```\nif:\u00a0 \u00a0 T\u00a0 \u00a0 \u00a0  subtype-of\u00a0 Sthen:\u00a0 S -> Q\u00a0 subtype-of\u00a0 T -> Q\n```", "```\nif:\u00a0 \u00a0 Integer\u00a0 \u00a0 \u00a0 subtype-of\u00a0 Numberthen:\u00a0 Number -> Q\u00a0 subtype-of\u00a0 Integer -> Q\n```", "```\nif:\u00a0 \u00a0 S subtype-of T\u00a0 *and*\u00a0 T subtype-of Sthen:\u00a0 (Boxof S) subtype-of (Boxof T)\n```", "```\nif:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  S\u00a0  is-the-same-type-as\u00a0 \u00a0 \u00a0 \u00a0  Tthen:\u00a0 (Boxof S)\u00a0 is-the-same-type-as\u00a0 (Boxof T)\n```", "```\n#lang pl;; a type for a \"read-only\" box(define-type (Boxof/R A) = (-> A));; Boxof/R constructor(: box/r : (All (A) A -> (Boxof/R A)))(define (box/r x) (lambda () x));; we can see that (Boxof/R T1) is a subtype of (Boxof/R T2);; if T1 is a subtype of T2 (this is not surprising, since;; these boxes are similar to any other container, like lists):(: foo1 : Integer -> (Boxof/R Integer))(define (foo1 b) (box/r b))(: bar1 : (Boxof/R Number) -> Number)(define (bar1 b) (b))(test (bar1 (foo1 123)) => 123);; a type for a \"write-only\" box(define-type (Boxof/W A) = (A -> Void));; Boxof/W constructor(: box/w : (All (A) A -> (Boxof/W A)))(define (box/w x) (lambda (new) (set! x new)));; in contrast to the above, (Boxof/W T1) is a subtype of;; (Boxof/W T2) if T2 is a subtype of T1, *not* the other way;; (and note how this is related to A being on the *left* side;; of the arrow in the `Boxof/W' type):(: foo2 : Number -> (Boxof/W Number))(define (foo2 b) (box/w b))(: bar2 : (Boxof/W Integer) Integer -> Void)(define (bar2 b new) (b new))(test (bar2 (foo2 123) 456));; combining the above two into a type for a \"read/write\" box(define-type (Boxof/RW A) = (A -> A));; Boxof/RW constructor(: box/rw : (All (A) A -> (Boxof/RW A)))(define (box/rw x) (lambda (new) (let ([old x]) (set! x new) old)));; this combines the above two: `A' appears on both sides of the;; arrow, so (Boxof/RW T1) is a subtype of (Boxof/RW T2) if T1;; is a subtype of T2 (because there's an A on the right) *and*;; if T2 is a subtype of T1 (because there's another A on the;; left) -- and that can happen only when T1 and T2 are the same;; type.\u00a0 So this is a type error:;;\u00a0  (: foo3 : Integer -> (Boxof/RW Integer));;\u00a0  (define (foo3 b) (box/rw b));;\u00a0  (: bar3 : (Boxof/RW Number) Number -> Number);;\u00a0  (define (bar3 b new) (b new));;\u00a0  (test (bar3 (foo3 123) 456) => 123);;\u00a0  ** Expected (Number -> Number), but got (Integer -> Integer);; And this a type error too:;;\u00a0  (: foo3 : Number -> (Boxof/RW Number));;\u00a0  (define (foo3 b) (box/rw b));;\u00a0  (: bar3 : (Boxof/RW Integer) Integer -> Integer);;\u00a0  (define (bar3 b new) (b new));;\u00a0  (test (bar3 (foo3 123) 456) => 123);;\u00a0  ** Expected (Integer -> Integer), but got (Number -> Number);; The two types must be the same for this to work:(: foo3 : Integer -> (Boxof/RW Integer))(define (foo3 b) (box/rw b))(: bar3 : (Boxof/RW Integer) Integer -> Integer)(define (bar3 b new) (b new))(test (bar3 (foo3 123) 456) => 123)\n```"]