- en: Chapter 11 - DOM Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章 - DOM 事件
- en: 11.1 DOM events overview
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 DOM 事件概述
- en: An event, in terms of the DOM, is either a pre-defined or custom moment in time
    that occurs in relationship with an element in the DOM, the *document* object,
    or the *window* object. These moments are typically predetermined and programaticlly
    accounted for by associating functionality (i.e. handlers/callbacks) to occur
    when these moments in time come to pass. These moments can be initiated by that
    state of the UI (e.g. input is focused or something has been dragged), the state
    of the enviroment that is running the JavaScript program (e.g. page is loaded
    or XHR request has finished), or the state of the program itself (e.g. start monitor
    users ui interaction for 30 seconds after the page has loaded).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 就 DOM 而言，事件是与 DOM 元素、*document*对象或*window*对象中的元素相关的预定义或自定义时刻。这些时刻通常是预先确定的，并通过将功能（即处理程序/回调）与这些时刻关联起来以在这些时刻发生时执行来进行编程处理。这些时刻可以由
    UI 的状态（例如，输入被聚焦或某些内容已被拖动）、运行 JavaScript 程序的环境的状态（例如，页面已加载或 XHR 请求已完成）或程序本身的状态（例如，在页面加载后开始监视用户
    UI 交互 30 秒）引发。
- en: Setting up events can be accomplished using inline attribute event handlers,
    property event handlers, or the *addEventListener()* method. In the code below
    I'm demonstrating these three patterns for setting up an event. All three patterns
    add a *click* event that is invoked whenever the *<div>* in the html document
    is clicked by the mouse.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用内联属性事件处理程序、属性事件处理程序或*addEventListener()*方法来设置事件。在下面的代码中，我演示了这三种设置事件的模式。这三种模式都添加了一个在鼠标点击
    HTML 文档中的*<div>*时调用的*click*事件。
- en: 'live code: [http://jsfiddle.net/domenlightenment/4EPjN](http://jsfiddle.net/domenlightenment/4EPjN)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在线代码：[http://jsfiddle.net/domenlightenment/4EPjN](http://jsfiddle.net/domenlightenment/4EPjN)
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that one of the events is attached to the *<body>* element. If you find
    it odd that the attribute event handler on the *<body>* fires by clicking the
    *<div>* element consider that when the *<div>* is clicked, are you not also clicking
    on the *<body>* element. Click anywhere but on the *<div>* and you still see the
    attribute handler fire on the *<body>* element alone.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，其中一个事件附加到*<body>*元素。如果您觉得在*<div>*上点击时属性事件处理程序在*<body>*上触发很奇怪，那么请考虑当您点击*<div>*时，您也同时点击了*<body>*元素。在*<div>*以外的任何地方点击，您仍然会看到*<body>*元素上的属性处理程序触发。
- en: While all three of these patterns for attaching an event to the DOM programatically
    schedule the event, only the *addEventListener()* provides a robust and organized
    solution. The inline attribute event handler mixes together JavaScript and HTML
    and best practices advise keeping these things seperate.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这三种将事件附加到 DOM 的程序化模式都安排了事件，但只有*addEventListener()*提供了一个健壮而有组织的解决方案。内联属性事件处理程序混合了
    JavaScript 和 HTML，并且最佳实践建议将这些东西分开。
- en: The downside to using a property event handler is that only one value can be
    assigned to the event property at a time. Meaning, you can't add more than one
    propety event handler to a DOM node when assigning events as property values.
    The code below shows an example of this by assigning a value to the *onclick*
    property twice, the last value set is used when the event is invoked.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性事件处理程序的缺点是事件属性一次只能分配一个值。也就是说，当将事件分配为属性值时，不能向 DOM 节点添加多个属性事件处理程序。下面的代码通过两次将值分配给*onclick*属性来显示示例，当事件被调用时，使用最后设置的值。
- en: 'live code: [http://jsfiddle.net/domenlightenment/U8bWR](http://jsfiddle.net/domenlightenment/U8bWR)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在线代码：[http://jsfiddle.net/domenlightenment/U8bWR](http://jsfiddle.net/domenlightenment/U8bWR)
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Additionaly, using event handlers inline or property event handlers can suffer
    from scoping nuances as one attempts to leverage the scope chain from the function
    that is invoked by the event. The *addEventListener()* smooths out all of these
    issues, and will be used throughout this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用内联事件处理程序或属性事件处理程序可能会受到作用域细微差别的影响，因为尝试利用由事件调用的函数的作用域链。*addEventListener()*消除了所有这些问题，并将在本章中使用。
- en: Notes
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 笔记
- en: '*Element* nodes typically support inline event handlers (e.g. *<div onclick=""></div>*),
    property event handlers (e.g. *document.querySelector(''div'').onclick = function(){}*),
    and the use of the *addEventListener()* method.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*Element*节点通常支持内联事件处理程序（例如*<div onclick=""></div>*）、属性事件处理程序（例如*document.querySelector(''div'').onclick
    = function(){}*）和使用*addEventListener()*方法。'
- en: The *Document* node supports property event handlers (e.g. *document.onclick
    = funciton()*) and the use of the *addEventListener()* method.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*Document* 节点支持属性事件处理程序（例如 *document.onclick = funciton()*）和使用 *addEventListener()*
    方法。'
- en: The *window* object supports inline event handler's via the *<body>* or *<frameset>*
    element (e.g. *<body onload=""></body>*), property event handlers (e.g. *window.load
    = function(){}*), and the use of the *addEventListener()* method.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*window* 对象支持通过 *<body>* 或 *<frameset>* 元素的内联事件处理程序（例如 *<body onload=""></body>*）、属性事件处理程序（例如
    *window.load = function(){}*）以及使用 *addEventListener()* 方法。'
- en: A property event handler historically has been refered to as a "DOM level 0
    event". And the *addEventListener()* is often refered to as a "DOM level 2 event".
    Which is rather confusing considering there is no level 0 event or level 1 event.
    Addintioanlly, inline event handlers are known to be called, "HTML event handlers".
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 属性事件处理程序在历史上被称为“DOM level 0 事件”。*addEventListener()* 经常被称为“DOM level 2 事件”。这相当令人困惑，考虑到并没有
    level 0 事件或 level 1 事件。此外，内联事件处理程序被称为“HTML 事件处理程序”。
- en: 11.2 DOM event types
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 DOM 事件类型
- en: In the tables below I detail the most common pre-defined events that can be
    attached to *Element* nodes, the *document* object, and the *window* object. Of
    course not all events are directly applicable to the node or object it can be
    attached too. That is, just because you can attach the event without error, and
    most likley invoke the event (i.e. bubbling events like *onchange* to *window*),
    does not mean that adding something like *window.onchange* is logical given that
    this event, by design was not meant for the *window* object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的表格中，我详细介绍了可以附加到 *Element* 节点、*document* 对象和 *window* 对象的最常见的预定义事件。当然，并非所有事件都直接适用于可以附加到的节点或对象。也就是说，仅仅因为你可以附加事件而不出错，并且很可能调用事件（例如将
    *onchange* 事件绑定到 *window*），并不意味着像 *window.onchange* 这样的添加是合乎逻辑的，因为这个事件设计上并不适用于
    *window* 对象。
- en: '**User interface events**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户界面事件**'
- en: '| Event Type | Event Interface | Description | Event Targets | Bubbles | Cancelable
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 事件类型 | 事件接口 | 描述 | 事件目标 | 冒泡 | 可取消 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| *load* | *Event*, *UIEvent* | fires when an asset (HTML page, image, CSS,
    frameset, *<object>*, or JS file) is loaded. | *Element*, *Document*, *window*,
    *XMLHttpRequest*, *XMLHttpRequestUpload* | No | No |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| *load* | *Event*, *UIEvent* | 当资源（HTML页面、图像、CSS、frameset、*<object>* 或 JS
    文件）加载时触发。 | *Element*, *Document*, *window*, *XMLHttpRequest*, *XMLHttpRequestUpload*
    | 否 | 否 |'
- en: '| *unload* | *UIEvent* | fires when user agent removes the resource (document,
    element, defaultView) or any depending resources (images, CSS file, etc.) | *window*,
    *<body>*, *<frameset>* | No | No |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| *unload* | *UIEvent* | 当用户代理移除资源（文档、元素、defaultView）或任何依赖资源（图像、CSS 文件等）时触发
    | *window*, *<body>*, *<frameset>* | 否 | 否 |'
- en: '| *abort* | *Event*, *UIEvent* | Fires when an resource (object/image) is stopped
    from loading before completely loaded | *Element*, *XMLHttpRequest*, *XMLHttpRequestUpload*
    | Yes | No |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| *abort* | *Event*, *UIEvent* | 当资源（对象/图像）在完全加载之前被停止加载时触发 | *Element*, *XMLHttpRequest*,
    *XMLHttpRequestUpload* | 是 | 否 |'
- en: '| *error* | *Event*, *UIEvent* | Fires when a resource failed to load, or has
    been loaded but cannot be interpreted according to its semantics, such as an invalid
    image, a script execution error, or non-well-formed XML | *Element*, *XMLHttpRequest*,
    *XMLHttpRequestUpload* | Yes | No |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| *error* | *Event*, *UIEvent* | 当资源加载失败，或已加载但无法根据其语义解释时触发，例如无效图像、脚本执行错误或非格式良好的
    XML | *Element*, *XMLHttpRequest*, *XMLHttpRequestUpload* | 是 | 否 |'
- en: '| *resize* | *UIEvent* | Fires when a document view has been resized. This
    event type is dispatched after all effects for that occurrence of resizing of
    that particular event target have been executed by the user agent | *window*,
    *<body>*, *<frameset>* | Yes | No |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| *resize* | *UIEvent* | 当文档视图被调整大小时触发。此事件类型在特定事件目标的调整发生后，由用户代理执行所有效果后分发 |
    *window*, *<body>*, *<frameset>* | 是 | 否 |'
- en: '| *scroll* | *UIEvent* | Fires when a user scrolls a document or an element.
    | *Element*, *Document*, *window* | Yes | No |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| *scroll* | *UIEvent* | 当用户滚动文档或元素时触发。 | *Element*, *Document*, *window* |
    是 | 否 |'
- en: '| *contextmenu* | *MouseEvent* | fires by right clicking an element | *Element*
    | Yes | Yes |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| *contextmenu* | *MouseEvent* | 通过右键单击元素触发 | *Element* | 是 | 是 |'
- en: '**Focus events**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**焦点事件**'
- en: '| Event Type | Event Interface | Description | Events Targets | Bubbles | Cancelable
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 事件类型 | 事件接口 | 描述 | 事件目标 | 冒泡 | 可取消 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| *blur* | *FocusEvent* | Fires when an element loses focus either via the
    mouse or tabbing | *Element* (except *<body>* and *<frameseet>* ), *Document*
    | No | No |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| *blur* | *FocusEvent* | 当元素失去焦点时（通过鼠标或切换标签）触发 | *Element*（除了 *<body>* 和 *<frameseet>*
    ），*Document* | 否 | 否 |'
- en: '| *focus* | *FocusEvent* | Fires when an element receives focus | *Element* (except
    *<body>* and *<frameseet>* ), *Document* | No | No |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| *focus* | *FocusEvent* | 当元素获得焦点时触发 | *Element*（除了 *<body>* 和 *<frameseet>*
    ），*Document* | 否 | 否 |'
- en: '| *focusin* | *FocusEvent* | Fires when an event target is about to receive
    focus but before the focus is shifted. This event occurs right before the focus
    event | *Element* | Yes | No |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| *focusin* | *FocusEvent* | 当事件目标即将接收焦点但焦点尚未转移时触发。此事件发生在焦点事件之前 | *Element*
    | 是 | 否 |'
- en: '| *focusout* | *FocusEvent* | Fires when an event target is about to lose focus
    but before the focus is shifted. This event occurs right before the blur event
    | *Element* | Yes | No |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| *focusout* | *FocusEvent* | 当事件目标即将��去焦点但焦点尚未转移时触发。此事件发生在失焦事件之前 | *Element*
    | 是 | 否 |'
- en: '**Form events**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**表单事件**'
- en: '| Event Type | Event Interface | Description | Event Targets | Bubbles | Cancelable
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 事件类型 | 事件接口 | 描述 | 事件目标 | 冒泡 | 可取消 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| *change* | specific to HTML forms | Fires when a control loses the input focus and
    its value has been modified since gaining focus | *Element* | Yes | No |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| *change* | 特定于 HTML 表单 | 当控件失去输入焦点且自获得焦点以来其值已被修改时触发 | *Element* | 是 | 否 |'
- en: '| *reset* | specific to HTML forms | Fires when a form is reset | *Element*
    | Yes | No |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| *reset* | 特定于 HTML 表单 | 当表单被重置时触发 | *Element* | 是 | 否 |'
- en: '| *submit* | specific to HTML forms | Fires when a form is submitted | *Element*
    | Yes | Yes |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| *submit* | 特定于 HTML 表单 | 当表单被提交时触发 | *Element* | 是 | 是 |'
- en: '| *select* | specific to HTML forms | Fires when a user selects some text in
    a text field, including input and textarea | *Element* | Yes | No |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| *select* | 特定于 HTML 表单 | 当用户在文本字段中选择文本时触发，包括输入和文本区域 | *Element* | 是 | 否 |'
- en: '**Mouse events**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**鼠标事件**'
- en: '| Event Type | Event Interface | Description | Event Targets | Bubbles | Cancelable
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 事件类型 | 事件接口 | 描述 | 事件目标 | 冒泡 | 可取消 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| *click* | *MouseEvent* | Fires when mouse pointer is clicked (or user presses
    enter key) over an element. A click is defined as a mousedown and mouseup over
    the same screen location. The sequence of these events is *mousedown*>*mouseup*>*click*.
    Depending upon the environment configuration, the click event may be dispatched
    if one or more of the event types mouseover, mousemove, and mouseout occur between
    the press and release of the pointing device button. The click event may also
    be followed by the dblclick event | *Element*, *Document*, *window* | Yes | Yes
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| *click* | *MouseEvent* | 当鼠标指针在元素上点击（或用户按下回车键）时触发。点击被定义为在相同屏幕位置上按下鼠标和松开鼠标。这些事件的顺序是
    *mousedown*>*mouseup*>*click*。根据环境配置，如果在指针设备按钮按下和释放之间发生一个或多个事件类型 *mouseover*、*mousemove*
    和 *mouseout*，则可能会分派 *click* 事件。*click* 事件也可能会被 *dblclick* 事件所跟随 | *Element*, *Document*,
    *window* | 是 | 是 |'
- en: '| *dblclick* | *MouseEvent* | Fires when a mouse pointer is clicked twice over
    an element. The definition of a double click depends on the environment configuration,
    except that the event target must be the same between *mousedown*, *mouseup*,
    and *dblclick*. This event type must be dispatched after the event typeclick if
    a click and double click occur simultaneously, and after the event type *mouseup* otherwise
    | *Element*, *Document*, *window* | Yes | Yes |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| *dblclick* | *MouseEvent* | 当鼠标指针在元素上双击时触发。双击的定义取决于环境配置，除了事件目标在 *mousedown*、*mouseup*
    和 *dblclick* 之间必须相同外。如果同时发生单击和双击，则此事件类型必须在 *click* 事件之后分派，否则在 *mouseup* 事件之后分派
    | *Element*, *Document*, *window* | 是 | 是 |'
- en: '| *mousedown* | *MouseEvent* | Fires when mouse pointer is pressed over an
    element | *Element*, *Document*, *window* | Yes | Yes |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| *mousedown* | *MouseEvent* | 当鼠标指针在元素上按下时触发 | *Element*, *Document*, *window*
    | 是 | 是 |'
- en: '| *mouseenter* | *MouseEvent* | Fires when mouse pointer is moved onto the
    boundaries of an element or one of its descendent elements. This event type is
    similar to mouseover, but differs in that it does not bubble, and must not be
    dispatched when the pointer device moves from an element onto the boundaries of
    one of its descendent elements | *Element*, *Document*, *window* | No | No |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| *mouseenter* | *MouseEvent* | 当鼠标指针移动到元素或其后代元素的边界上时触发。此事件类型类似于 *mouseover*，但不同之处在于它不冒泡，并且当指针设备从一个元素移动到其后代元素的边界时，*mouseenter*
    事件不得分派 | *Element*, *Document*, *window* | 否 | 否 |'
- en: '| *mouseleave* | *MouseEvent* | Fires when mouse pointer is moved off of the
    boundaries of an element and all of its descendent elements. This event type is
    similar to mouseout, but differs in that does not bubble, and that it must not
    be dispatched until the pointing device has left the boundaries of the element
    and the boundaries of all of its children | *Element*, *Document*, *window* |
    No | No |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| *mouseleave* | *MouseEvent* | 鼠标指针移出元素及其所有后代元素的边界时触发。此事件类型类似于mouseout，但不同之处在于它不冒泡，并且只有在指针设备离开元素及其所有子元素的边界后才能触发
    | *Element*, *Document*, *window* | 否 | 否 |'
- en: '| *mousemove* | *MouseEvent* | Fires when mouse pointer is moved while it is
    over an element. The frequency rate of events while the pointing device is moved
    is implementation-, device-, and platform-specific, but multiple consecutive mousemove
    events should be fired for sustained pointer-device movement, rather than a single
    event for each instance of mouse movement. Implementations are encouraged to determine
    the optimal frequency rate to balance responsiveness with performance | *Element*,
    *Document*, *window* | Yes | No |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| *mousemove* | *MouseEvent* | 当鼠标指针在元素上移动时触发。指针设备移动时事件的频率与实现、设备和平台有关，但应为持续指针设备移动触发多个连续的mousemove事件，而不是每次鼠标移动的实例都触发单个事件。鼓励实现确定平衡响应性和性能的最佳频率
    | *Element*, *Document*, *window* | 是 | 否 |'
- en: '| *mouseout* | *MouseEvent* | Fires when mouse pointer is moved off of the
    boundaries of an element. This event type is similar to *mouseleave*, but differs
    in that does bubble, and that it must be dispatched when the pointer device moves
    from an element onto the boundaries of one of its descendent elements | *Element*,
    *Document*, *window* | Yes | Yes |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| *mouseout* | *MouseEvent* | 鼠标指针移出元素的边界时触发。此事件类型类似于*mouseleave*，但不同之处在于它冒泡，并且当指针设备从一个元素移动到其后代元素的边界上时必须触发
    | *Element*, *Document*, *window* | 是 | 是 |'
- en: '| *mouseup* | *MouseEvent* | Fires when mouse pointer button is released over
    an element | *Element*, *Document*, *window* | Yes | Yes |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| *mouseup* | *MouseEvent* | 鼠标指针按钮释放时在元素上触发 | *Element*, *Document*, *window*
    | 是 | 是 |'
- en: '| *mouseover* | *MouseEvent* | Fires when mouse pointer is moved over an element
    | *Element*, *Document*, *window* | Yes | Yes |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| *mouseover* | *MouseEvent* | 鼠标指针移过元素时触发 | *Element*, *Document*, *window*
    | 是 | 是 |'
- en: '**Wheel events**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**滚轮事件**'
- en: '| Event Type | Event Interface | Description | Event Targets | Bubbles | Cancelable
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 事件类型 | 事件接口 | 描述 | 事件目标 | 冒泡 | 可取消 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| *wheel* (browsers use *mousewheel* but the specification uses *wheel*) |
    *WheelEvent* | Fires when a mouse wheel has been rotated around any axis, or when
    an equivalent input device (such as a mouse-ball, certain tablets or touchpads,
    etc.) has emulated such an action. Depending on the platform and input device,
    diagonal wheel deltas may be delivered either as a singlewheel event with multiple
    non-zero axes or as separate wheel events for each non-zero axis. Some helpful
    details about browser support can be found [here](http://www.quirksmode.org/dom/events/scroll.html).
    | *Element*, *Document*, *Window* | Yes | Yes |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| *wheel*（浏览器使用*mousewheel*，但规范使用*wheel*） | *WheelEvent* | 当鼠标滚轮围绕任何轴旋转，或者当等效输入设备（如鼠标球、某些平板电脑或触摸板等）模拟了这样的操作时触发。根据平台和输入设备，对角线滚轮增量可能作为具有多个非零轴的单个滚轮事件传递，或者作为每个非零轴的单独滚轮事件传递。有关浏览器支持的一些有用细节可以在[这里](http://www.quirksmode.org/dom/events/scroll.html)找到。
    | *Element*, *Document*, *Window* | 是 | 是 |'
- en: '**Keyboard events**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**键盘事件**'
- en: '| Event Type | Event Interface | Description | Event Targets | Bubbles | Cancelable
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 事件类型 | 事件接口 | 描述 | 事件目标 | 冒泡 | 可取消 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| *keydown* | *KeyboardEvent* | Fires when a key is initially pressed. This
    is sent after any key mapping is performed, but before any input method editors
    receive the keypress. This is sent for any key, even if it doesn''t generate a
    character code. | *Element*, *Document* | Yes | Yes |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| *keydown* | *KeyboardEvent* | 当按下键时触发。在执行任何键映射之后发送此事件，但在任何输入法编辑器接收到按键之前发送。对于任何键都会发送此事件，即使它不生成字符代码。
    | *Element*, *Document* | 是 | 是 |'
- en: '| *keypress* | *KeyboardEvent* | Fires when a key is initially pressed, but
    only if that key normally produces a character value. This is sent after any key
    mapping is performed, but before any input method editors receive the keypress.
    | *Element*, *Document* | Yes | Yes |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| *keypress* | *KeyboardEvent* | 当按下键时触发，但仅当该键通常产生字符值时。这在执行任何按键映射之后发送，但在任何输入法编辑器接收按键之前。
    | *元素*，*文档* | 是 | 是 |'
- en: '| *keyup* | *KeyboardEvent* | Fires when a key is released. This is sent after
    any key mapping is performed, and always follows thecorresponding *keydown* and *keypress* events.
    | *Element*, *Document* | Yes | Yes |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| *keyup* | *KeyboardEvent* | 在释放按键时触发。这在执行任何按键映射之后发送，并始终跟随相应的*keydown*和*keypress*事件。
    | *元素*，*文档* | 是 | 是 |'
- en: '**Touch events**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**触摸事件**'
- en: '| Event Type | Event Interface | Description | Event Targets | Bubbles | Cancelable
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 事件类型 | 事件接口 | 描述 | 事件目标 | 冒泡 | 可取消 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| *touchstart* | *TouchEvent* | Fires event to indicate when the user places
    a touch point on the touch surface | *Element*, *Document*, *window* | Yes | Yes
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| *touchstart* | *TouchEvent* | 触发事件以指示用户在触摸表面上放置一个触摸点 | *元素*，*文档*，*窗口* | 是
    | 是 |'
- en: '| *touchend* | *TouchEvent* | Fires event to indicate when the user removes
    a touch poin[t](http://www.w3.org/TR/2011/WD-touch-events-20110505/#dfn-touch-point) from
    the touch surface, also including cases where the touch point physically leaves
    the touch surface, such as being dragged off of the screen | *Element*, *Document*,
    *window* | Yes | Yes |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| *touchend* | *TouchEvent* | 触发事件以指示用户从触摸表面移除一个触摸点，也包括触摸点物理上离开触摸表面的情况，例如被拖出屏幕
    | *元素*，*文档*，*窗口* | 是 | 是 |'
- en: '| *touchmove* | *TouchEvent* | Fires event to indicate when the user moves
    a touch point along the touch surface | *Element*, *Document*, *window* | Yes
    | Yes |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| *touchmove* | *TouchEvent* | 触发事件以指示用户沿着触摸表面移动一个触摸点 | *元素*，*文档*，*窗口* | 是
    | 是 |'
- en: '| *touchenter* | *TouchEvent* | Fires event to indicate when a touch point moves
    onto the interactive area defined by a DOM element | *Element*, *Document*, *window*
    | No | ? |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| *touchenter* | *TouchEvent* | 触发事件以指示触摸点移入DOM元素定义的交互区域 | *元素*，*文档*，*窗口* |
    否 | ? |'
- en: '| *toucheleave* | *TouchEvent* | Fires event to indicate when a touch point moves
    off the interactive area defined by a DOM element | *Element*, *Document*, *window*
    | No | ? |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| *toucheleave* | *TouchEvent* | 触发事件以指示触摸点移出DOM元素定义的交互区域 | *元素*，*文档*，*窗口*
    | 否 | ? |'
- en: '| *touchcancel* | *TouchEvent* | Fires event to indicate when a touch point
    has been disrupted in an implementation-specific manner, such as a synchronous
    event or action originating from the UA canceling the touch, or the touch point
    leaving the document window into a non-document area which is capable of handling
    user interactions. | *Element*, *Document*, *window* | Yes | No |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| *touchcancel* | *TouchEvent* | 触发事件以指示触摸点以实现特定于实现的方式被中断，例如来自UA取消触摸的同步事件或操作，或者触摸点离开文档窗口进入能够处理用户交互的非文档区域。
    | *元素*，*文档*，*窗口* | 是 | 否 |'
- en: Notes
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Touch events are typically only supported iOS, Andorid, and Blackberry browsers
    or browsers (e.g. chrome) that can switch on touch modes
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸事件通常仅受iOS、安卓和黑莓浏览器或可以切换到触摸模式的浏览器（例如chrome）支持
- en: '**Window, *<body>*, and frame specific events**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**窗口，*<body>* 和特定框架的事件**'
- en: '| Event Type | Event Interface | Description | Event Targets | Bubbles | Cancelable
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 事件类型 | 事件接口 | 描述 | 事件目标 | 冒泡 | 可取消 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| *afterprint* | ? | Fires on the object immediately after its associated document
    prints or previews for printing | *window*, *<body>*, *<frameset>* | No | No |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| *afterprint* | ? | 在对象关联的文档打印或打印预览后立即触发 | *窗口*，*<body>*，*<frameset>* | 否
    | 否 |'
- en: '| *beforeprint* | ? | Fires on the object before its associated document prints
    or previews for printing | *window*, *<body>*, *<frameset>* | No | No |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| *beforeprint* | ? | 在对象关联的文档打印或打印预览之前触发 | *窗口*，*<body>*，*<frameset>* | 否
    | 否 |'
- en: '| *beforeunload* | ? | Fires prior to a document being unloaded | *window*,
    *<body>*, *<frameset>* | No | Yes |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| *beforeunload* | ? | 在文档被卸载之前触发 | *窗口*，*<body>*，*<frameset>* | 否 | 是 |'
- en: '| *hashchange* | *HashChangeEvent* | Fires when there are changes to the portion
    of a URL that follows the number sign (#) | *window*, *<body>*, *<frameset>* |
    No | No |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| *hashchange* | *HashChangeEvent* | 在URL中跟随井号(#)后面的部分发生变化时触发 | *窗口*，*<body>*，*<frameset>*
    | 否 | 否 |'
- en: '| *messsage* | ? | Fires when the user sends a cross-document message or a
    message is sent from a *Worker* with *postMessage* | *window*, *<body>*, *<frameset>*
    | No | No |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| *messsage* | ? | 当用户发送跨文档消息或从带有 *postMessage* 的 *Worker* 发送消息时触发。 | *window*,
    *<body>*, *<frameset>* | 否 | 否 |'
- en: '| *offline* | *NavigatorOnLine* | Fires when browser is working offline | *window*,
    *<body>*, *<frameset>* | No | No |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| *offline* | *NavigatorOnLine* | 浏览器离线工作时触发。 | *window*, *<body>*, *<frameset>*
    | 否 | 否 |'
- en: '| *online* | *NavigatorOnLine* | Fires when browser is working online | *window*,
    *<body>*, *<frameset>* | No | No |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| *online* | *NavigatorOnLine* | 浏览器在线工作时触发。 | *window*, *<body>*, *<frameset>*
    | 否 | 否 |'
- en: '| *pagehide* | *PageTransitionEvent* | Fires when traversing from a session
    history entry | *window*, *<body>*, *<frameset>* | No | No |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| *pagehide* | *PageTransitionEvent* | 当从会话历史记录条目遍历到另一个条目时触发。 | *window*, *<body>*,
    *<frameset>* | 否 | 否 |'
- en: '| *pageshow* | *PageTransitionEvent* | The pagehide event is fired when traversing from a session
    history entry | *window*, *<body>*, *<frameset>* | No | No |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| *pageshow* | *PageTransitionEvent* | 当从会话历史记录条目遍历到另一个条目时触发 pagehide 事件。 |
    *window*, *<body>*, *<frameset>* | 否 | 否 |'
- en: '**Document specific events**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**特定于文档的事件**'
- en: '| Event Type | Event Interface | Description | Event Targets | Bubbles | Cancelable
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 事件类型 | 事件接口 | 描述 | 事件目标 | 冒泡 | 可取消 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| *readystatechange* | *Event* | Fires event when *readyState* is changed |
    *Document*, *XMLHttpRequest* | No | No |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| *readystatechange* | *Event* | 在 *readyState* 更改时触发事件。 | *Document*, *XMLHttpRequest*
    | 否 | 否 |'
- en: '| *DOMContentLoaded* | *Event* | Fires when a webpage has been parsed, but
    before all resources have been fully downloaded | *Document* | Yes | No |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| *DOMContentLoaded* | *Event* | 当网页已解析但尚未完全下载所有资源时触发。 | *Document* | 是 | 否
    |'
- en: '**Drag events**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**拖动事件**'
- en: '| Event Type | Event Interface | Description | Event Targets | Bubbles | Cancelable
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 事件类型 | 事件接口 | 描述 | 事件目标 | 冒泡 | 可取消 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| *drag* | *DragEvent* | Fires on the source object continuously during a drag
    operation. | *Element*, *Document*, *window* | Yes | Yes |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| *drag* | *DragEvent* | 在拖动操作期间在源对象上持续触发。 | *Element*, *Document*, *window*
    | 是 | 是 |'
- en: '| *dragstart* | *DragEvent* | Fires on the source object when the user starts
    to drag a text selection or selected object. The ondragstart event is the first
    to fire when the user starts to drag the mouse. | *Element*, *Document*, *window*
    | Yes | Yes |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| *dragstart* | *DragEvent* | 当用户开始拖动文本选择或选定对象时，在源对象上触发。当用户开始拖动鼠标时，会首先触发 ondragstart 事件。
    | *Element*, *Document*, *window* | 是 | 是 |'
- en: '| *dragend* | *DragEvent* | Fires on the source object when the user releases
    the mouse at the close of a drag operation. The ondragend event is the final drag
    event to fire, following the ondragleave event, which fires on the target object.
    | *Element*, *Document*, *window* | Yes | No |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| *dragend* | *DragEvent* | 当用户在拖动操作结束时释放鼠标时，在源对象上触发。 ondragend 事件是最后触发的拖动事件，它在触发在目标对象上的 ondragleave 事件之后触发。
    | *Element*, *Document*, *window* | 是 | 否 |'
- en: '| *dragenter* | *DragEvent* | Fires on the target element when the user drags
    the object to a valid drop target. | *Element*, *Document*, *window* | Yes | Yes
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| *dragenter* | *DragEvent* | 当用户将对象拖动到有效的放置目标时，在目标元素上触发。 | *Element*, *Document*,
    *window* | 是 | 是 |'
- en: '| *dragleave* | *DragEvent* | Fires on the target object when the user moves
    the mouse out of a valid drop target during a drag operation. | *Element*, *Document*,
    *window* | Yes | No |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| *dragleave* | *DragEvent* | 当用户在拖动操作期间将鼠标移出有效的放置目标时，在目标对象上触发。 | *Element*,
    *Document*, *window* | 是 | 否 |'
- en: '| *dragover* | *DragEvent* | Fires on the target element continuously while
    the user drags the object over a valid drop target. The ondragover event fires
    on the target object after the ondragenter event has fired. | *Element*, *Document*,
    *window* | Yes | Yes |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| *dragover* | *DragEvent* | 当用户将对象拖动到有效的放置目标上方时，在目标元素上持续触发。在 ondragenter 事件触发后，在目标对象上触发 ondragover 事件。
    | *Element*, *Document*, *window* | 是 | 是 |'
- en: '| *drop* | *DragEvent* | Fires on the target object when the mouse button is
    released during a drag-and-drop operation. The ondrop event fires before the ondragleave
    and ondragend events. | *Element*, *Document*, *window* | Yes | Yes |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| *drop* | *DragEvent* | 当在拖放操作期间释放鼠标按钮时，在目标对象上触发。在 ondragleave 和 ondragend 事件之前触发 ondrop 事件。
    | *Element*, *Document*, *window* | 是 | 是 |'
- en: Notes
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Notes
- en: The tables below were crafted from the following three resources [Document Object
    Model (DOM) Level 3 Events Specification 5 User Event Module](http://www.w3.org/TR/DOM-Level-3-Events/#events-module),
    [DOM event reference](https://developer.mozilla.org/en/DOM/DOM_event_reference),
    [HTML Living Standard 7.1.6 Event handlers on elements, Document objects, and
    Window objects,](http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#events),
    and [Event compatibility tables](http://www.quirksmode.org/dom/events/).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下表是根据以下三个资源制作的：[文档对象模型（DOM）3级事件规范5用户事件模块](http://www.w3.org/TR/DOM-Level-3-Events/#events-module)，[DOM事件参考](https://developer.mozilla.org/en/DOM/DOM_event_reference)，[HTML
    Living Standard 7.1.6 元素、文档对象和窗口对象上的事件处理程序](http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#events)，以及[事件兼容性表](http://www.quirksmode.org/dom/events/)。
- en: I've only mentioned here in this section the most common event types. Keep in
    mind there are numerous HTML5 api's that I've excluded from the this section (e.g.
    [media events](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#event-definitions)
    for *<video>* and *<audio>* elements or all state change events for the [XMLHttpRequest
    Level 2](http://www.w3.org/TR/XMLHttpRequest/#event-handlers)).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本节中仅提到了最常见的事件类型。请记住，我在本节中排除了许多HTML5 API（例如，[媒体事件](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#event-definitions)用于*<video>*和*<audio>*元素，或者[XMLHttpRequest
    Level 2](http://www.w3.org/TR/XMLHttpRequest/#event-handlers)的所有状态更改事件）。
- en: The *copy*, *cut*, and *textinput* event are not defined by DOM 3 events or
    HTML5
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*copy*、*cut*和*textinput*事件未被DOM 3事件或HTML5定义。'
- en: Use mouseenter and mouseleave instead of mouseover and mouseout. Unfortunately
    Firefox, Chrome, and Safari still haven’t added these events!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用mouseenter和mouseleave代替mouseover和mouseout。不幸的是，Firefox、Chrome和Safari仍未添加这些事件！
- en: 11.3 The event flow
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 事件流
- en: When an event is invoked the [event flows or propagates through the DOM](http://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture),
    firing the same event on other nodes and JavaScript objects. The event flow can
    be programmed to occur as a capture phase (i.e. DOM tree trunk to branch) or bubbling
    phase (i.e. DOM tree branches to trunk), or both.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件被调用时，[事件通过DOM流动或传播](http://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture)，在其他节点和JavaScript对象上触发相同的事件。事件流可以被编程为发生在捕获阶段（即DOM树从树干到树枝）或冒泡阶段（即DOM树从树枝到树干），或两者兼而有之。
- en: In the code below I set up 10 event listeners that can all be invoked, due to
    the event flow, by clicking once on the *<div>* element in the HTML document.
    When the *<div>* is clicked the capture phase begins at the *window* object and
    propagates down the DOM tree firing the *click* event for each object (i.e. *window*
    **>** *document* **>** *<html>* **>** *<body>* **>** event target) until it hits
    the event target. Once the capture phase ends the target phase starts, firing
    the *click* event on the target element itself. Next the propagation phase propagates
    up from the event target firing the *click* event until it reaches the *window*
    object (i.e. event target **>** *<body>* **>** *<html>* **>** *document* **>**
    *window*). With this knowledge it should be obvious why clicking the *<div>* in
    the code example logs to the console 1,2,3,4,5,6,7,8,9,11.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我设置了10个事件监听器，所有这些监听器都可以通过在HTML文档中的*<div>*元素上点击一次来调用，由于事件流的原因。当点击*<div>*时，捕获阶段从*window*对象开始，沿着DOM树向下传播，为每个对象（即*window*
    **>** *document* **>** *<html>* **>** *<body>* **>** 事件目标）触发*click*事件，直到达到事件目标。一旦捕获阶段结束，目标阶段开始，为目标元素本身触发*click*事件。接下来，传播阶段从事件目标开始向上传播，触发*click*事件，直到达到*window*对象（即事件目标
    **>** *<body>* **>** *<html>* **>** *document* **>** *window*）。有了这个知识，很明显为什么��代码示例中点击*<div>*会将1,2,3,4,5,6,7,8,9,11记录到控制台。
- en: 'live code: [http://jsfiddle.net/domenlightenment/CAdTv](http://jsfiddle.net/domenlightenment/CAdTv)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/CAdTv](http://jsfiddle.net/domenlightenment/CAdTv)
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After the *<div>* is clicked, the event flow proceeds in this order:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 点击*<div>*后，事件流按照以下顺序进行：
- en: capture phase invokes click events on window that are set to fire on capture
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获阶段在设置为在捕获时触发的窗口上调用点击事件
- en: capture phase invokes click events on document that are set to fire on capture
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获阶段在设置为在捕获时触发的文档上调用点击事件
- en: capture phase invokes click events on html element that are set to fire on capture
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获阶段在设置为在捕获时触发的html元素上调用点击事件
- en: capture phase invokes click events on body element that are set to fire on capture
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获阶段在设置为在捕获时触发的body元素上调用点击事件
- en: target phase invokes click events on div element that are set to fire on capture
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标阶段在设置为在捕获时触发的div元素上调用点击事件
- en: target phase invokes click events on div element that are set to fire on bubble
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标阶段调用设置为冒泡触发的div元素上的点击事件
- en: bubbling phase invokes click events on body element are set to fire on bubble
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冒泡阶段调用点击事件在body元素上设置为冒泡触发
- en: bubbling phase invokes click events on html element are set to fire on bubble
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冒泡阶段调用点击事件在html元素上设置为冒泡触发
- en: bubbling phase invokes click events on document are set to fire on bubble
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冒泡阶段调用点击事件在文档上设置为冒泡触发
- en: bubbling phase invokes click events on window are set to fire on bubble
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冒泡阶段调用点击事件在窗口上设置为冒泡触发
- en: The use of the capture phase is not all that common due to a lack of browser
    support for this phase. Typically events are assumed to be inovked during the
    bubbling phase. In the code below I remove the capture phase from the previous
    code example and demostrate typically what is occuring during an event invocation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缺乏对此阶段的浏览器支持，使用捕获阶段并不那么常见。通常事件被认为是在冒泡阶段调用的。在下面的代码中，我从上一个代码示例中删除了捕获阶段，并演示了事件调用时通常发生的情况。
- en: 'live code: [http://jsfiddle.net/domenlightenment/C6qmZ](http://jsfiddle.net/domenlightenment/C6qmZ)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/C6qmZ](http://jsfiddle.net/domenlightenment/C6qmZ)
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice in the last code example that if the click event is initiated (click
    anywhere except on the *<div>*) on the *<body>* element the click event attached
    to the *<div>* is not invoked and bubbling invocation starts on the *<body>*.
    This is due to the fact the the event target is no longer the *<div>* but instead
    the *<body>* element.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在最后的代码示例中，如果点击事件是在*<div>*之外的任何地方发起的（点击*<div>*除外），则附加到*<div>*的点击事件不会被调用，冒泡调用会在*<body>*上开始。这是因为事件目标不再是*<div>*，而是*<body>*元素。
- en: Notes
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Modern browsers do support the use of the capture phase so what was once considered
    unreliable might just server some value today. For example, one could intercept
    an event before it occurs on the event target.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器确实支持使用捕获阶段，因此曾被认为不可靠的东西今天可能会有一些价值。例如，可以在事件目标发生之前拦截事件。
- en: Keep this knowledge of event capturing and bubbling at the forefront of your
    thoughts when you read the event delegation section of this chapter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当您阅读本章的事件委托部分时，请将事件捕获和冒泡的知识放在首要位置。
- en: The event object passed to event listener functions contains a *eventPhase*
    property containing a number which indicates which phase an event is inoked in.
    A value of 1 indicates the capture phase. A value of 2 indicates the target phase.
    And a value of 3 indicates bubbling phase.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给事件监听器函数的事件对象包含一个*eventPhase*属性，其中包含一个数字，指示事件在哪个阶段调用。值为1表示捕获阶段。值为2表示目标阶段。值为3表示冒泡阶段。
- en: 11.4 Adding event listeners to *Element* nodes, *window* object, and *Document*
    object
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 向*Element*节点、*window*对象和*Document*对象添加事件监听器
- en: The *addEventListener()* method is avaliabe on all *Element* nodes, the *window*
    object, and the *document* object providing the ability to added event listeners
    to parts of an HTML document as well as JavaScript objects relating to the DOM
    and [BOM](https://developer.mozilla.org/en-US/docs/DOM/window) (browser object
    model). In the code below I leverage this method to add a *mousemove* event to
    a *<div>* element, the *document* object, and the *window* object. Notice, due
    to the event flow, that mouse movement specifically over the *<div>* will invoke
    all three listeners each to time a movement occurs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*addEventListener()*方法适用于所有*Element*节点、*window*对象和*document*对象，提供了向HTML文档的部分以及与DOM和[BOM](https://developer.mozilla.org/en-US/docs/DOM/window)（浏览器对象模型）相关的JavaScript对象添加事件监听器的能力。在下面的代码中，我利用这个方法向*<div>*元素、*document*对象和*window*对象添加了一个*mousemove*事件。请注意，由于事件流，鼠标移动特别是在*<div>*上时，每次移动都会调用这三个监听器。'
- en: 'live code: [http://jsfiddle.net/domenlightenment/sSFK5](http://jsfiddle.net/domenlightenment/sSFK5)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/sSFK5](http://jsfiddle.net/domenlightenment/sSFK5)
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The *addEventListener()* method used in the above code example takes three arguments.
    The first argument is the type of event to listen for. Notice that the event type
    string does not contain the "on" prefix (i.e. *onmousemove*) that event handlers
    require. The second argument is the function to be invoked when the event occurs.
    The third parameter is a boolean indicating if the event should be fired during
    the capture phase or bubbling phase of the event flow.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码示例中使用的*addEventListener()*方法接受三个参数。第一个参数是要监听的事件类型。请注意，事件类型字符串不包含事件处理程序所需的"on"前缀（即*onmousemove*）。第二个参数是事件发生时要调用的函数。第三个参数是一个布尔值，指示事件是否应在事件流的捕获阶段或冒泡阶段触发。
- en: Notes
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I've purposfully avoided dicussing inline event handlers & property event handlers
    in favor of promoting the use of *addEventListener()*
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意避免讨论内联事件处理程序和属性事件处理程序，而是倡导使用*addEventListener()*。
- en: Typically a developer wants events to fire during the bubbling phase so that
    object eventing handles the event before bubbling the event up the DOM. Because
    of this you almost always provide a *false* value as the last argument to the
    *addEventListener()*. In modern browsers if the 3rd parameter is not specified
    it will default to false.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开发人员希望事件在冒泡阶段触发，以便对象事件处理在将事件冒泡到DOM之前处理事件。因此，您几乎总是将*false*值作为*addEventListener()*的最后一个参数提供。在现代浏览器中，如果未指定第三个参数，则默认为false。
- en: You should be aware that the *addEventListener()* method can be used on the
    *XMLHttpRequest* object
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该知道*addEventListener()*方法也可以用于*XMLHttpRequest*对象。
- en: 11.5 Removing event listeners
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 移除事件侦听器
- en: The *removeEventListener()* method can be used to remove events listeners, if
    the orginal listener was not added using an anonymous function. In the code below
    I add two events listeners to the HTML document and attempt to remove both of
    them. However, only the listener that was attached using a function reference
    is removed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果原始侦听器不是使用匿名函数添加的，则可以使用*removeEventListener()*方法来移除事件侦听器。在下面的代码中，我向HTML文档添加了两个事件侦听器，并尝试移除它们。然而，只有使用函数引用附加的侦听器被移除。
- en: 'live code: [http://jsfiddle.net/domenlightenment/XP2Ug](http://jsfiddle.net/domenlightenment/XP2Ug)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/XP2Ug](http://jsfiddle.net/domenlightenment/XP2Ug)
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Anonymous functions added using *addEventListener()* method simply cannot be
    removed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*addEventListener()*方法添加的匿名函数无法简单地移除。
- en: 11.6 Getting event properties from the event object
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6 从事件对象获取事件属性
- en: The handler or callback function invoked for events is sent by default a parameter
    that contains all relevant information about an event itself. In the code below
    I demostrate access to this event object and log all of its properties and values
    for a load event as well as a click event. Make sure you click the *<div*> to
    see the properties assocaited with a click event.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 事件触发时调用的处理程序或回调函数默认会接收一个包含有关事件本身的所有相关信息的参数。在下面的代码中，我演示了如何访问此事件对象，并记录了加载事件和点击事件的所有属性和值。确保点击*<div*>以查看与点击事件相关的属性。
- en: 'live code: [http://jsfiddle.net/domenlightenment/d4SnQ](http://jsfiddle.net/domenlightenment/d4SnQ)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/d4SnQ](http://jsfiddle.net/domenlightenment/d4SnQ)
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Keep in mind that each event will contain slightly different properties based
    on the event type (e.g. [MouseEvent](https://developer.mozilla.org/en/DOM/MouseEvent),
    [KeyboardEvent](https://developer.mozilla.org/en/DOM/KeyboardEvent), [WheelEvent](https://developer.mozilla.org/en/DOM/WheelEvent)).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每个事件将根据事件类型（例如[MouseEvent](https://developer.mozilla.org/en/DOM/MouseEvent)、[KeyboardEvent](https://developer.mozilla.org/en/DOM/KeyboardEvent)、[WheelEvent](https://developer.mozilla.org/en/DOM/WheelEvent)）包含略有不同的属性。
- en: Notes
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The event object also provides the *stopPropagation()*, *stopImediatePropagation()*,
    and *preventDefault()* methods.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 事件对象还提供*stopPropagation()*、*stopImediatePropagation()*和*preventDefault()*方法。
- en: In this book I use the argument name *event* to reference the event object.
    In truth you can use any name you like and its not uncommon to see *e* or *evt*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我使用参数名*event*来引用事件对象。事实上，您可以使用任何您喜欢的名称，看到*e*或*evt*也是很常见的。
- en: 11.7 The value of *this* when using *addEventListener()*
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7 使用*addEventListener()*时*this*的值
- en: The value of *this* inside of the event listener function passed to the *addEventListener()*
    method will be a reference to the node or object the event is attached too. In
    the code below I attach an event to a *<div>* and then using *this* inside of
    the event listener gain access to the *<div>* element the event is attached too.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给*addEventListener()*方法的事件侦听器函数内部的*this*的值将是事件附加到的节点或对象的引用。在下面的代码中，我将事件附加到一个*<div>*，然后在事件侦听器内部使用*this*来访问事件附加的*<div>*元素。
- en: 'live code: [http://jsfiddle.net/domenlightenment/HwKgH](http://jsfiddle.net/domenlightenment/HwKgH)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在线代码：[http://jsfiddle.net/domenlightenment/HwKgH](http://jsfiddle.net/domenlightenment/HwKgH)
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When events are invoked as part of the event flow the *this* value will remain
    the value of the node or object that the event listener is attached too. In the
    code below we add a *click* event listener to the *<body>* and regardless of if
    you click on the *<div>* or the *<body>* the value of *this* always points to
    *<body>*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件作为事件流的一部分被触发时，*this*值将保持事件侦听器附加到的节点或对象的值。在下面的代码中，我们向*<body>*添加了一个*click*事件侦听器，无论您点击*<div>*还是*<body>*，*this*的值始终指向*<body>*。
- en: 'live code: [http://jsfiddle.net/domenlightenment/NF2gn](http://jsfiddle.net/domenlightenment/NF2gn)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在线代码：[http://jsfiddle.net/domenlightenment/NF2gn](http://jsfiddle.net/domenlightenment/NF2gn)
- en: '[PRE8]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Additionally its possible using the *event.currentTarget* property to get the
    same reference, to the node or object invoking the event listener, that the *this*
    property provides. In the code below I leverage the *event.currentTarget* event
    object property showcasing that it returns the same value as *this*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，可以使用*event.currentTarget*属性来获取相同的引用，即触发事件侦听器的节点或对象，就像*this*属性提供的那样。在下面的代码中，我利用*event.currentTarget*事件对象属性展示它返回与*this*相同的值。
- en: 'live code: [http://jsfiddle.net/domenlightenment/uQm3f](http://jsfiddle.net/domenlightenment/uQm3f)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在线代码：[http://jsfiddle.net/domenlightenment/uQm3f](http://jsfiddle.net/domenlightenment/uQm3f)
- en: '[PRE9]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 11.8 Referencing the *target* of an event and not the node or object the event
    is invoked on
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.8 引用事件的*target*而不是触发事件的节点或对象
- en: Because of the event flow its possible to click a *<div>*, contained inside
    of a *<body>* element and have a *click* event listener attached to the *<body>*
    element get invoked. When this happens, the event object passed to the event listener
    function attached to the *<body>* provides a reference (i.e. *event.target*) to
    the node or object that the event originated on (i.e. the target). In the code
    below when the *<div>* is clicked, the *<body>* element's *click* event listener
    is invoked and the *event.target* property references the orginal *<div>* that
    was the target of the click event. The *event.target* can be extremely useful
    when an event that fires because of the event flow needs knowledge about the origin
    of the event.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因为事件流的存在，可能会点击包含在*<body>*元素内部的*<div>*，并且触发附加到*<body>*元素的*click*事件侦听器。当这种情况发生时，传递给附加到*<body>*的事件侦听器函数的事件对象（即*event.target*）提供了对产生事件的节点或对象的引用（即目标）。在下面的代码中，当点击*<div>*时，将调用*<body>*元素的*click*事件侦听器，并且*event.target*属性引用了原始的*<div>*，即点击事件的目标。当事件因事件流而触发时，*event.target*可以非常有用，以获取有关事件来源的知识。
- en: 'live code: [http://jsfiddle.net/domenlightenment/dGkTQ](http://jsfiddle.net/domenlightenment/dGkTQ)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在线代码：[http://jsfiddle.net/domenlightenment/dGkTQ](http://jsfiddle.net/domenlightenment/dGkTQ)
- en: '[PRE10]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Consider that in our code example if the *<body>* element is clicked instead
    of the *<div>* then the event *target* and the element node that the event listener
    is invoked on are the same. Therefore *event.target*, *this*, and *event.currentTarget*
    will all contain a reference to the *<body>* element.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑，在我们的代码示例中，如果点击*<body>*元素而不是*<div>*，那么事件*target*和事件侦听器被调用的元素节点将是相同的。因此，*event.target*、*this*和*event.currentTarget*都将包含对*<body>*元素的引用。
- en: 11.9 Cancelling default browser events using *preventDefault()*
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.9 使用*preventDefault()*取消默认浏览器事件
- en: Browsers provide several events already wired up when an HTML page is presented
    to a user. For example, clicking a link has a corresponding event (i.e. you navigate
    to a url). So does clicking a checkbox (i.e. box is checked) or typing text into
    a text field (i.e. text is inputed and appears on screen). These browser events
    can be prevented by calling the *preventDefault()* method inside of the event
    handler function associated with a node or object that invokes a browser default
    event. In the code below I prevent the default event that occurs on a *<a>*, *<input>*,
    and *<textarea>*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当向用户呈现HTML页面时，浏览器提供了几个已经连接的事件。例如，单击链接具有相应的事件（即导航到URL）。单击复选框也是如此（即选中框），或者在文本字段中输入文本（即输入文本并显示在屏幕上）。这些浏览器事件可以通过在与调用浏览器默认事件的节点或对象相关联的事件处理程序函数中调用*preventDefault()*方法来阻止。在下面的代码中，我阻止了发生在*<a>*、*<input>*和*<textarea>*上的默认事件。
- en: 'live code: [http://jsfiddle.net/domenlightenment/Ywcyh](http://jsfiddle.net/domenlightenment/Ywcyh)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'live code: [http://jsfiddle.net/domenlightenment/Ywcyh](http://jsfiddle.net/domenlightenment/Ywcyh)'
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All attempts to click the link, check the box, or type in the text input in
    the previous code example will fail because I am preventing the default events
    for these elements from occuring.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码示例中，尝试单击链接、选中复选框或在文本输入中键入文本将失败，因为我正在阻止这些元素的默认事件发生。
- en: Notes
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *preventDefault()* methods does not stop events from propagating (i.e. bubbling
    or capture phases)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*preventDefault()*方法不会阻止事件传播（即冒泡或捕获阶段）'
- en: Providing a *return false* at the end of the body of the event listener has
    the same result as call the *preventDefault()* method
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件监听器主体末尾提供一个*return false*与调用*preventDefault()*方法具有相同的效果
- en: The event object passed to event listener functions contains a boolean *cancelable*
    property which indicates if the event will respond to preveentDefault() method
    and canceling default behavior
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给事件监听器函数的事件对象包含一个布尔值*cancelable*属性，该属性指示事件是否会响应*preventDefault()*方法并取消默认行为
- en: The event object passed to event listener functions contains a *defaultPrevented*
    property which indicates true if *preventDefault()* has been invoked for a bubbling
    event.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给事件监听器函数的事件对象包含一个*defaultPrevented*属性，如果对冒泡事件调用了*preventDefault()*，则该属性为true。
- en: 11.10 Stoping the event flow using *stopPropagation()*
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.10 使用*stopPropagation()*停止事件流
- en: Calling *stopProgagation()* from within an event handler/listener will stop
    the capture and bubble event flow phases, but any events directly attached to
    the node or object will still be invoked. In the code below the *onclick* event
    attached to the *<body>* is never gets invoked because we are stopping the event
    from bubbling up the DOM when clicking on the *<div>*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 从事件处理程序/监听器内部调用*stopProgagation()*将停止捕获和冒泡事件流阶段，但仍将调用直接附加到节点或对象的任何事件。在下面的代码中，由于我们阻止了事件冒泡到*<body>*上的*onclick*事件，因此*<body>*上的*onclick*事件永远不会被调用。
- en: 'live code: [http://jsfiddle.net/domenlightenment/RFKmA](http://jsfiddle.net/domenlightenment/RFKmA)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 'live code: [http://jsfiddle.net/domenlightenment/RFKmA](http://jsfiddle.net/domenlightenment/RFKmA)'
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that other click events attached to the the *<div>* still get invoked!
    Additionally using *stopPropagation()* does not prevent default events. Had the
    *<div>* in our code example been a *<a>* with an href value calling stopPropagation
    would not have stopped the browser default events from getting invoked.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，仍会调用附加到*<div>*的其他点击事件！此外，使用*stopPropagation()*不会阻止默认事件。如果我们的代码示例中的*<div>*是一个带有href值的*<a>*，调用stopPropagation将不会阻止浏览器默认事件的调用。
- en: 11.11 Stoping the event flow as well as other like events on the same target
    using *stopImmediatePropagation()*
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.11 使用*stopImmediatePropagation()*停止事件流以及目标上的其他类似事件
- en: Calling the *stopImmediatePropagation()* from within an event handler/listener
    will stop the event flow phases (i.e. *stopPropagation()*), as well as any other
    like events attached to the event target that are attached after the event listener
    that invokes the *stopImmediatePropagation()* method. In the code example below
    If we call *stopImmediatePropagation()*from the second event listener attached
    to the *<div>* the click event that follows will not get invoked.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件处理程序/监听器内部调用*stopImmediatePropagation()*将停止事件流阶段（即*stopPropagation()*），以及任何其他类似事件，这些事件附加到在调用*stopImmediatePropagation()*方法的事件监听器之后的事件目标上。在下面的代码示例中，如果我们从附加到*<div>*的第二个事件监听器中调用*stopImmediatePropagation()*，则接下来的点击事件将不会被调用。
- en: 'live code: [http://jsfiddle.net/domenlightenment/znSjM](http://jsfiddle.net/domenlightenment/znSjM)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/znSjM](http://jsfiddle.net/domenlightenment/znSjM)
- en: '[PRE13]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notes
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using the *stopImmediatePropagation()* does not prevent default events. Browser
    default events still get invoked and only calling *preventDefault()* will stop
    these events.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*stopImmediatePropagation()*并不能阻止默认事件。浏览器默认事件仍然会被调用，只有调用*preventDefault()*才能停止这些事件。
- en: 11.12 Custom events
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.12 自定义事件
- en: A developer is not limited to the predefined event types. Its possible to attach
    and invoke a custom event, using the *addEventListener()* method like normal in
    combiniation with *document.createEvent()*, *initCustomEvent()*, and *dispatchEvent()*.
    In the code below I create a custom event called *goBigBlue* and invoke that event*.*
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员不仅限于预定义的事件类型。可以使用*addEventListener()*方法像平常一样结合*document.createEvent()*、*initCustomEvent()*和*dispatchEvent()*来附加和调用自定义事件。在下面的代码中，我创建了一个名为*goBigBlue*的自定义事件并调用了该事件。
- en: 'live code: [http://jsfiddle.net/domenlightenment/fRndj](http://jsfiddle.net/domenlightenment/fRndj)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/fRndj](http://jsfiddle.net/domenlightenment/fRndj)
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notes
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: IE9 requires (not optinal) the fourth parameter on *initiCustomEvent()*
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: IE9要求（不是可选的）*initiCustomEvent()*的第四个参数
- en: The [DOM 4 specifiction added a *CustomEvent()* constructor](http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#interface-customevent)
    that has simplified the life cycle of a custom event but its not supported in
    ie9 and as of this writting and is still in flux
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[DOM 4规范添加了一个*CustomEvent()*构造函数](http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#interface-customevent)，简化了自定义事件的生命周期，但在ie9中不受支持，在撰写本文时仍在变化中。'
- en: 11.13 Simulating/Triggering mouse events
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.13 模拟/触发鼠标事件
- en: Simiulating an event is not unlike creating a custom event. In the case of simulating
    a mouse event we create a *'MouseEvent'* using *document.createEvent()*. Then,
    using *initMouseEvent()* we setup the mouse event that is going to occur. Next
    the mouse event is dispatched on the element that we'd like to simulate an event
    on (i.e the *<div>* in the html document). In the code below a click event is
    attached to the *<div>* in the page. Instead of clicking the *<div>* to invoke
    the click event the event is triggered or simulated by programatically setting
    up a mouse event and dispatching the event to the *<div>*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟事件与创建自定义事件并没有太大不同。在模拟鼠标事件的情况下，我们使用*document.createEvent()*创建一个*'MouseEvent'*。然后，使用*initMouseEvent()*设置即将发生的鼠标事件。接下来，将鼠标事件分派到我们想要模拟事件的元素上（即html文档中的*<div>*）。在下面的代码中，一个点击事件被附加到页面中的*<div>*上。而不是点击*<div>*来调用点击事件，事件是通过程序化地设置鼠标事件并将事件分派到*<div>*来触发或模拟的。
- en: 'live code: [http://jsfiddle.net/domenlightenment/kx7zJ](http://jsfiddle.net/domenlightenment/kx7zJ)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/kx7zJ](http://jsfiddle.net/domenlightenment/kx7zJ)
- en: '[PRE15]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notes
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Simulating/triggering mouse events as of this writing works in all modern browsers.
    Simulating other event types quickly becomes more complicated and leveraging [simulate.js](https://github.com/airportyh/simulate.js)
    or jQuery (e.g. jQuery *trigger()* method) becomes neccsary.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，模拟/触发鼠标事件在所有现代浏览器中都有效。模拟其他类型的事件很快变得更加复杂，需要利用[simulate.js](https://github.com/airportyh/simulate.js)或jQuery（例如jQuery的*trigger()*方法）。
- en: 11.14 Event delegation
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.14 事件委托
- en: Event delegation, stated simply, is the programmatic act of leveraging the event
    flow and a single event listener to deal with multiple event targets. A side effect
    of event delegation is that the event targets don't have to be in the DOM when
    the event is created in order for the targets to respond to the event. This is
    of course rather handy when dealing with XHR responses that update the DOM. By
    implementing event delegation new content that is added to the DOM post JavaScript
    load parsing can immediately start responding to events. Imagine you have a table
    with an unlimited number of rows and columns. Using event delegation we can add
    a single event listener to the *<table>* node which acts as a delegate for the
    node or object that is the initial target of the event. In the code example below,
    clicking any of the *<td>*'s (i.e. the target of the event) will delegate its
    event to the *click* listener on the *<table>*. Don't forget this is all made
    possible because of the event flow and in this specific case the bubbling phase.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 事件委托，简单地说，是利用事件流和单个事件监听器来处理多个事件目标的编程行为。事件委托的一个副作用是，事件目标在事件创建时不必在DOM中，也能响应事件。这在处理更新DOM的XHR响应时非常方便。通过实现事件委托，添加到DOM中的新内容在JavaScript加载解析后可以立即开始响应事件。想象一下，你有一个拥有无限行和列的表格。使用事件委托，我们可以为*<table>*节点添加一个单个事件监听器，作为事件的初始目标的委托。在下面的代码示例中，点击任何一个*<td>*（即事件的目标）将把它的事件委托给*<table>*上的*click*监听器。不要忘记，所有这些都是因为事件流，特别是冒泡阶段，才变得可能。
- en: 'live code: [http://jsfiddle.net/domenlightenment/BRkVL](http://jsfiddle.net/domenlightenment/BRkVL)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在线代码：[http://jsfiddle.net/domenlightenment/BRkVL](http://jsfiddle.net/domenlightenment/BRkVL)
- en: '[PRE16]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we were to update the table in the code example with new rows, the new rows
    would responded to the *click* event as soon as they were render to the screen
    because the click event is delegated to the *<table>* element node.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在代码示例中更新表格以添加新行，新行将在渲染到屏幕上后立即响应*click*事件，因为*click*事件被委托给了*<table>*元素节点。
- en: Notes
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Event delegation is ideally leverage when you are dealing with a *click*, *mousedown*,
    *mouseup*, *keydown*, *keyup*, and *keypress* event type.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 事件委托在处理*click*、*mousedown*、*mouseup*、*keydown*、*keyup*和*keypress*事件类型时是理想的选择。
