- en: Lesson 10 Intro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prerequisites and What to Expect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before proceeding, you should understand how to manipulate lists. Consider reviewing
    key procedures like `map` and `filter`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll learn about streams and some of their applications.
  prefs: []
  type: TYPE_NORMAL
- en: Readings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This lesson is based on [SICP 3.5](https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've gained a good understanding of assignment as a tool in modeling, as well
    as an appreciation of the complex problems that assignment raises. It is time
    to ask whether we could have gone about things in a different way, so as to avoid
    some of these problems. In this section, we explore an alternative approach to
    modeling state, based on data structures called streams. As we shall see, streams
    can mitigate some of the complexity of modeling state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s step back and review where this complexity comes from. In an attempt
    to model real-world phenomena, we made some apparently reasonable decisions: We
    modeled real-world objects with local state by computational objects with local
    variables. We identified time variation in the real world with time variation
    in the computer. We implemented the time variation of the states of the model
    objects in the computer with assignments to the local variables of the model objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Is there another approach? Can we avoid identifying time in the computer with
    time in the modeled world? Must we make the model change with time in order to
    model phenomena in a changing world? Think about the issue in terms of mathematical
    functions. We can describe the time-varying behavior of a quantity x as a function
    of time x(t). If we concentrate on x instant by instant, we think of it as a changing
    quantity. Yet if we concentrate on the entire time history of values, we do not
    emphasize change-the function itself does not change.
  prefs: []
  type: TYPE_NORMAL
- en: If time is measured in discrete steps, then we can model a time function as
    a (possibly infinite) sequence. In this section, we will see how to model change
    in terms of sequences that represent the time histories of the systems being modeled.
    To accomplish this, we introduce new data structures called streams. From an abstract
    point of view, a stream is simply a sequence. However, we will find that the straightforward
    implementation of streams as lists (as in section 2.2.1) doesn't fully reveal
    the power of stream processing. As an alternative, we introduce the technique
    of delayed evaluation, which enables us to represent very large (even infinite)
    sequences as streams.
  prefs: []
  type: TYPE_NORMAL
- en: Stream processing lets us model systems that have state without ever using assignment
    or mutable data. This has important implications, both theoretical and practical,
    because we can build models that avoid the drawbacks inherent in introducing assignment.
    On the other hand, the stream framework raises difficulties of its own, and the
    question of which modeling technique leads to more modular and more easily maintained
    systems remains open.
  prefs: []
  type: TYPE_NORMAL
- en: List Inefficiency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Lesson 4, we've been using lists to represent sequences. But there are
    downsides to list representations. Manipulating these list sequences require that
    our programs construct and copy data structures (which could be huge) at every
    step of the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this in action. This procedure is written in the iterative style
    we know and love:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This second procedure makes use of `accumulate`, `filter`, and `enumerate-interval`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In carrying out the computation, the first program needs only to store the sum
    being accumulated. In contrast, the `filter` in the second program cannot do any
    testing until `enumerate-interval` has constructed a complete list of the numbers
    in the interval. The `filter` generates another list, which in turn is passed
    to `accumulate` before being collapsed to form a sum.
  prefs: []
  type: TYPE_NORMAL
- en: Such large intermediate storage is not needed by the first program, which we
    can think of as enumerating the interval incrementally, adding each prime to the
    sum as it is generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s another example of list inefficiency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code generates a huge list of integers and a huge list of primes, even
    though we only want the second prime number!
  prefs: []
  type: TYPE_NORMAL
- en: Why Streams?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With streams, we can manipulate sequences without incurring the costs of manipulating
    sequences as lists. With streams we can achieve the best of both worlds: We can
    formulate programs elegantly as sequence manipulations, while attaining the efficiency
    of incremental computation. The basic idea is to construct a stream only partially,
    and to pass the partial construction to the program that consumes the stream.
    If the consumer attempts to access a part of the stream that has not yet been
    constructed, the stream will automatically construct just enough more of itself
    to produce the required part, thus preserving the illusion that the entire stream
    exists. In other words, although we will write programs as if we were processing
    complete sequences, we design our stream implementation to automatically and transparently
    interleave the construction of the stream with its use.'
  prefs: []
  type: TYPE_NORMAL
