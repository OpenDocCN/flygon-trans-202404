- en: UseAutoTheory and Practice of Automation in Coq Proofs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: (* Chapter written and maintained by Arthur Chargueraud *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Require Import Coq.Arith.Arith.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Lists.List.
  prefs: []
  type: TYPE_NORMAL
- en: Import ListNotations.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Maps.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Smallstep.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Stlc.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import LibTactics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Strength of Proof Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to study four proof-search tactics: auto, eauto,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: iauto and jauto. The tactics auto and eauto are builtin
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in Coq. The tactic iauto is a shorthand for the builtin tactic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: try solve [intuition eauto]. The tactic jauto is defined in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the library LibTactics, and simply performs some preprocessing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of the goal before calling eauto. The goal of this chapter is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to explain the general principles of proof search and to give
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rule of thumbs for guessing which of the four tactics mentioned
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: above is best suited for solving a given goal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Proof search is a compromise between efficiency and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expressiveness, that is, a tradeoff between how complex goals the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tactic can solve and how much time the tactic requires for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: terminating. The tactic auto builds proofs only by using the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: basic tactics reflexivity, assumption, and apply. The tactic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: eauto can also exploit eapply. The tactic jauto extends
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: eauto by being able to open conjunctions and existentials that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: occur in the context.  The tactic iauto is able to deal with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: conjunctions, disjunctions, and negation in a quite clever way;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: however it is not able to open existentials from the context.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Also, iauto usually becomes very slow when the goal involves
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: several disjunctions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that proof search tactics never perform any rewriting
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: step (tactics rewrite, subst), nor any case analysis on an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: arbitrary data structure or property (tactics destruct and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: inversion), nor any proof by induction (tactic induction). So,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proof search is really intended to automate the final steps from
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the various branches of a proof. It is not able to discover the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: overall structure of a proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma solving_by_reflexivity :'
  prefs: []
  type: TYPE_NORMAL
- en: 2 + 3 = 5.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. auto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma solving_by_apply : ∀(P Q : nat→Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (∀n, Q n → P n) →
  prefs: []
  type: TYPE_NORMAL
- en: (∀n, Q n) →
  prefs: []
  type: TYPE_NORMAL
- en: P 2.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. auto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma solving_by_eapply : ∀(P Q : nat→Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (∀n m, Q m → P n) →
  prefs: []
  type: TYPE_NORMAL
- en: Q 1 → P 2.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. auto. eauto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma solving_conj_goal : ∀(P : nat→Prop) (F : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (∀n, P n) → F → F ∧ P 2.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. auto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma solving_conj_hyp : ∀(F F'' : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: F ∧ F' → F.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. auto. eauto. jauto. (* or iauto *) Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma solving_conj_hyp'' : ∀(F F'' : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: F ∧ F' → F.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros. jauto_set. eauto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma solving_conj_more : ∀(P Q R : nat→Prop) (F : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (F ∧ (∀n m, (Q m ∧ R n) → P n)) →
  prefs: []
  type: TYPE_NORMAL
- en: (F → R 2) →
  prefs: []
  type: TYPE_NORMAL
- en: Q 1 →
  prefs: []
  type: TYPE_NORMAL
- en: P 2 ∧ F.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. jauto. (* or iauto *) Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma solving_conj_hyp_forall : ∀(P Q : nat→Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (∀n, P n ∧ Q n) → P 2.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: auto. eauto. iauto. jauto.
  prefs: []
  type: TYPE_NORMAL
- en: (* Nothing works, so we have to do some of the work by hand *)
  prefs: []
  type: TYPE_NORMAL
- en: intros. destruct (H 2). auto.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma solved_by_jauto : ∀(P Q : nat→Prop) (F : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (∀n, P n) ∧ (∀n, Q n) → P 2.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. jauto. (* or iauto *) Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma solving_disj_goal : ∀(F F'' : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: F → F ∨ F'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. auto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma solving_disj_hyp : ∀(F F'' : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: F ∨ F' → F' ∨ F.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. auto. eauto. jauto. iauto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma solving_tauto : ∀(F[1] F[2] F[3] : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: ((¬F[1] ∧ F[3]) ∨ (F[2] ∧ ¬F[3])) →
  prefs: []
  type: TYPE_NORMAL
- en: (F[2] → F[1]) →
  prefs: []
  type: TYPE_NORMAL
- en: (F[2] → F[3]) →
  prefs: []
  type: TYPE_NORMAL
- en: ¬F[2].
  prefs: []
  type: TYPE_NORMAL
- en: Proof. iauto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Existentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tactics eauto, iauto, and jauto can prove goals whose
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: conclusion is an existential. For example, if the goal is ∃ x, f x, the tactic
    eauto introduces an existential variable,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: say ?25, in place of x. The remaining goal is f ?25, and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: eauto tries to solve this goal, allowing itself to instantiate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ?25 with any appropriate value. For example, if an assumption f 2 is available,
    then the variable ?25 gets instantiated with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2 and the goal is solved, as shown below.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A major strength of jauto over the other proof search tactics is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that it is able to exploit the existentially-quantified
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hypotheses, i.e., those of the form ∃ x, P.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Negation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tactics auto and eauto suffer from some limitations with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: respect to the manipulation of negations, mostly related to the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fact that negation, written ¬ P, is defined as P → False but
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that the unfolding of this definition is not performed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: automatically. Consider the following example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For this reason, the tactics iauto and jauto systematically
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: invoke unfold not in * as part of their pre-processing. So,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: they are able to solve the previous goal right away.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We will come back later on to the behavior of proof search with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: respect to the unfolding of definitions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma equality_by_auto : ∀(f g : nat→Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (∀x, f x = g x) → g 2 = f 2.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. auto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How Proof Search Works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma search_depth_0 :'
  prefs: []
  type: TYPE_NORMAL
- en: True ∧ True ∧ True ∧ True ∧ True ∧ True.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: auto.
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma search_depth_1 : ∀(P : nat→Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: P 0 →
  prefs: []
  type: TYPE_NORMAL
- en: (P 0 → P 1) →
  prefs: []
  type: TYPE_NORMAL
- en: (P 1 → P 2) →
  prefs: []
  type: TYPE_NORMAL
- en: (P 2).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: auto 0\. (* does not find the proof *)
  prefs: []
  type: TYPE_NORMAL
- en: auto 1\. (* does not find the proof *)
  prefs: []
  type: TYPE_NORMAL
- en: auto 2\. (* does not find the proof *)
  prefs: []
  type: TYPE_NORMAL
- en: auto 3\. (* finds the proof *)
  prefs: []
  type: TYPE_NORMAL
- en: (* more generally, auto n solves the goal if n ≥ 3 *)
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma search_depth_3 : ∀(P : nat→Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (* Hypothesis H[1]: *) (P 0) →
  prefs: []
  type: TYPE_NORMAL
- en: (* Hypothesis H[2]: *) (∀k, P (k-1) → P k) →
  prefs: []
  type: TYPE_NORMAL
- en: (* Goal:          *) (P 4).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. auto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma search_depth_4 : ∀(P : nat→Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (* Hypothesis H[1]: *) (P 0) →
  prefs: []
  type: TYPE_NORMAL
- en: (* Hypothesis H[2]: *) (∀k, P (k-1) → P k) →
  prefs: []
  type: TYPE_NORMAL
- en: (* Goal:          *) (P 5).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. auto. auto 6\. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma search_depth_5 : ∀(P : nat→Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (* Hypothesis H[1]: *) (P 0) →
  prefs: []
  type: TYPE_NORMAL
- en: (* Hypothesis H[2]: *) (∀k, P (k-1) → P k) →
  prefs: []
  type: TYPE_NORMAL
- en: (* Goal:          *) (P 4 ∧ P 4).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. auto. auto 6\. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma working_of_auto_1 : ∀(P : nat→Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (* Hypothesis H[1]: *) (P 0) →
  prefs: []
  type: TYPE_NORMAL
- en: (* Hypothesis H[2]: *) (∀k, P (k-1) → P k) →
  prefs: []
  type: TYPE_NORMAL
- en: (* Hypothesis H[3]: *) (∀k, P (k+1) → P k) →
  prefs: []
  type: TYPE_NORMAL
- en: (* Goal:          *) (P 2).
  prefs: []
  type: TYPE_NORMAL
- en: (* Uncomment "debug" in the following line to see the debug trace: *)
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros P H[1] H[2] H[3]. (* debug *) eauto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: depth=5
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: depth=4 apply H2
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: depth=3 apply H2
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: depth=3 exact H1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma working_of_auto_2 : ∀(P : nat→Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (* Hypothesis H[1]: *) (P 0) →
  prefs: []
  type: TYPE_NORMAL
- en: (* Hypothesis H[3]: *) (∀k, P (k+1) → P k) →
  prefs: []
  type: TYPE_NORMAL
- en: (* Hypothesis H[2]: *) (∀k, P (k-1) → P k) →
  prefs: []
  type: TYPE_NORMAL
- en: (* Goal:          *) (P 2).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros P H[1] H[3] H[2]. (* debug *) eauto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|5||4||3||2||1||0| -- below, tabulation indicates the depth'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[P 2]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 3]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 4]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 5]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 6]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 7]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 5]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 4]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 5]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 3]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: --> [P 3]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 4]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 5]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 3]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 2]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 3]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 1]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 2]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 3]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 4]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 5]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 3]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 2]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 3]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 1]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 1]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 2]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 3]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 1]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> [P 0]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: -> !! Done !!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Adding Hints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, auto (and eauto) only tries to apply the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hypotheses that appear in the proof context. There are two
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: possibilities for telling auto to exploit a lemma that have
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'been proved previously: either adding the lemma as an assumption'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: just before calling auto, or adding the lemma as a hint, so
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that it can be used by every calls to auto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first possibility is useful to have auto exploit a lemma
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that only serves at this particular point. To add the lemma as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hypothesis, one can type generalize mylemma; intros, or simply
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'lets: mylemma (the latter requires LibTactics.v).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second possibility is useful for lemmas that need to be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: exploited several times. The syntax for adding a lemma as a hint
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is Hint Resolve mylemma. For example, the lemma asserting than
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: any number is less than or equal to itself, ∀ x, x ≤ x,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: called Le.le_refl in the Coq standard library, can be added as a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hint as follows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: A convenient shorthand for adding all the constructors of an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: inductive datatype as hints is the command Hint Constructors mydatatype.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Warning: some lemmas, such as transitivity results, should'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: not be added as hints as they would very badly affect the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: performance of proof search. The description of this problem
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and the presentation of a general work-around for transitivity
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lemmas appear further on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Ltac auto_star ::= a_new_definition.
  prefs: []
  type: TYPE_NORMAL
- en: Observe the use of ::= instead of :=, which indicates that the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tactic is being rebound to a new definition. So, the default
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definition is as follows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Nearly all standard Coq tactics and all the tactics from
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"LibTactics" can be called with a star symbol. For example, one'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'can invoke subst*, destruct* H, inverts* H, lets* I: H x,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: specializes* H x, and so on... There are two notable exceptions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The tactic auto* is just another name for the tactic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: auto_star.  And the tactic apply* H calls eapply H (or the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: more powerful applys H if needed), and then calls auto_star.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that there is no eapply* H tactic, use apply* H
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In large developments, it can be convenient to use two degrees of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: automation. Typically, one would use a fast tactic, like auto,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and a slower but more powerful tactic, like jauto. To allow for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a smooth coexistence of the two form of automation, LibTactics.v
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: also defines a "tilde" version of tactics, like apply¬ H,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: destruct¬ H, subst¬, auto¬ and so on. The meaning of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tilde symbol is described by the auto_tilde tactic, whose
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: default implementation is auto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the examples that follow, only auto_star is needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An alternative, possibly more efficient version of auto_star is the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'following":'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ltac auto_star ::= try solve eassumption | auto | jauto .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the above definition, auto_star first tries to solve the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: goal using the assumptions; if it fails, it tries using auto,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and if this still fails, then it calls jauto. Even though
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: jauto is strictly stronger than eassumption and auto, it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: makes sense to call these tactics first, because, when the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: succeed, they save a lot of time, and when they fail to prove
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the goal, they fail very quickly.".
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Determinism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Recall the original proof of the determinism lemma for the IMP
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: language, shown below.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: rewrite this proof using auto whenever possible.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (The solution uses auto 9 times.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In fact, using automation is not just a matter of calling auto
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in place of one or two other tactics. Using automation is about
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rethinking the organization of sequences of tactics so as to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: minimize the effort involved in writing and maintaining the proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This process is eased by the use of the tactics from
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: LibTactics.v.  So, before trying to optimize the way automation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'is used, let''s first rewrite the proof of determinism:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: use introv H instead of intros x H,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: use gen x instead of generalize dependent x,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: use inverts H instead of inversion H; subst,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: use tryfalse to handle contradictions, and get rid of the cases where beval
    st b[1] = true and beval st b[1] = false both appear in the context,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: stop using ceval_cases to label subcases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: To obtain a nice clean proof script, we have to remove the calls
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert (st' = st'0). Such a tactic invokation is not nice
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: because it refers to some variables whose name has been
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: automatically generated. This kind of tactics tend to be very
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: brittle.  The tactic assert (st' = st'0) is used to assert the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: conclusion that we want to derive from the induction
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hypothesis. So, rather than stating this conclusion explicitly, we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are going to ask Coq to instantiate the induction hypothesis,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: using automation to figure out how to instantiate it. The tactic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: forwards, described in LibTactics.v precisely helps with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: instantiating a fact. So, let's see how it works out on our
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: To polish the proof script, it remains to factorize the calls
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to auto, using the star symbol. The proof of determinism can then
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: be rewritten in only four lines, including no more than 10 tactics.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Preservation for STLC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Consider the proof of perservation of STLC, shown below.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This proof already uses eauto through the triple-dot
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mechanism.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: rewrite this proof using tactics from LibTactics'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and calling automation using the star symbol rather than the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: triple-dot notation. More precisely, make use of the tactics
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: inverts* and applys* to call auto* after a call to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: inverts or to applys. The solution is three lines long.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Progress for STLC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider the proof of the progress theorem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: optimize the above proof.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Hint: make use of destruct* and inverts*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution consists of 10 short lines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: BigStep and SmallStep
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Consider the proof relating a small-step reduction judgment
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to a big-step reduction judgment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Our goal is to optimize the above proof. It is generally
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: easier to isolate inductions into separate lemmas. So,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we are going to first prove an intermediate result
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that consists of the judgment over which the induction
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is being performed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: prove the following result, using tactics'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: introv, induction and subst, and apply*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution is 3 lines long.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: using the lemma above, simplify the proof of'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the result multistep__eval. You should use the tactics
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: introv, inverts, split* and apply*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution is 2 lines long.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If we try to combine the two proofs into a single one,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we will likely fail, because of a limitation of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: induction tactic. Indeed, this tactic looses
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: information when applied to a property whose arguments
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are not reduced to variables, such as t ⇒* (C n).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will thus need to use the more powerful tactic called
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: dependent induction. This tactic is available only after
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: importing the Program library, as shown below.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: prove the lemma multistep__eval without invoking'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the lemma multistep_eval_ind, that is, by inlining the proof
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: by induction involved in multistep_eval_ind, using the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tactic dependent induction instead of induction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution is 5 lines long.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Preservation for STLCRef
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The proof of preservation for STLCRef can be found in chapter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: References.  The optimized proof script is more than twice
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: shorter.  The following material explains how to build the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: optimized proof script.  The resulting optimized proof script for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the preservation theorem appears afterwards.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Let's come back to the proof case that was hard to optimize.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The difficulty comes from the statement of nth_eq_last, which
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: takes the form nth (length l) (l ++ x::nil) d = x. This lemma is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hard to exploit because its first argument, length l, mentions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a list l that has to be exactly the same as the l occuring in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: snoc l x. In practice, the first argument is often a natural
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: number n that is provably equal to length l yet that is not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: syntactically equal to length l. There is a simple fix for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'making nth_eq_last easy to apply: introduce the intermediate'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variable n explicitly, so that the goal becomes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: nth n (snoc l x) d = x, with a premise asserting n = length l.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The proof case for ref from the preservation theorem then
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: becomes much easier to prove, because rewrite nth_eq_last'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: now succeeds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The optimized proof of preservation is summarized next.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Progress for STLCRef
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The proof of progress for STLCRef can be found in chapter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: References. The optimized proof script is, here again, about
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: half the length.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Subtyping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Consider the inversion lemma for typing judgment
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of abstractions in a type system with subtyping.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: optimize the proof script, using'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: introv, lets and inverts*. In particular,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: you will find it useful to replace the pattern
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'apply K in H. destruct H as I with lets I: K H.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution is 4 lines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The lemma substitution_preserves_typing has already been used to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: illustrate the working of lets and applys in chapter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: UseTactics. Optimize further this proof using automation (with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the star symbol), and using the tactic cases_if'. The solution
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is 33 lines).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Advanced Topics in Proof Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma order_matters_1 : ∀(P : nat→Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (∀n m, P m → m ≠ 0 → P n) → P 2 → P 1.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: eauto. (* Success *)
  prefs: []
  type: TYPE_NORMAL
- en: (* The proof: intros P H K. eapply H. apply K. auto. *)
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma order_matters_2 : ∀(P : nat→Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (∀n m, m ≠ 0 → P m → P n) → P 5 → P 1.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: eauto. (* Failure *)
  prefs: []
  type: TYPE_NORMAL
- en: (* To understand why, let us replay the previous proof *)
  prefs: []
  type: TYPE_NORMAL
- en: intros P H K.
  prefs: []
  type: TYPE_NORMAL
- en: eapply H.
  prefs: []
  type: TYPE_NORMAL
- en: (* The application of eapply has left two subgoals,      ?X ≠ 0 and P ?X, where ?X is an existential variable. *)
  prefs: []
  type: TYPE_NORMAL
- en: (* Solving the first subgoal is easy for eauto: it suffices      to instantiate ?X as the value 1, which is the simplest
         value that satisfies ?X ≠ 0. *)
  prefs: []
  type: TYPE_NORMAL
- en: eauto.
  prefs: []
  type: TYPE_NORMAL
- en: (* But then the second goal becomes P 1, which is where we      started from. So, eauto gets stuck at this point. *)
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Unfolding of Definitions During Proof-Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of intermediate definitions is generally encouraged in a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: formal development as it usually leads to more concise and more
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: readable statements. Yet, definitions can make it a little harder
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to automate proofs. The problem is that it is not obvious for a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proof search mechanism to know when definitions need to be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unfolded. Note that a naive strategy that consists in unfolding
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: all definitions before calling proof search does not scale up to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: large proofs, so we avoid it. This section introduces a few
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: techniques for avoiding to manually unfold definitions before
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: calling proof search.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To illustrate the treatment of definitions, let P be an abstract
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: property on natural numbers, and let myFact be a definition
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: denoting the proposition P x holds for any x less than or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: equal to 3.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Proving that myFact under the assumption that P x holds for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: any x should be trivial. Yet, auto fails to prove it unless we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unfold the definition of myFact explicitly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: To automate the unfolding of definitions that appear as proof
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: obligation, one can use the command Hint Unfold myFact to tell
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coq that it should always try to unfold myFact when myFact
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: appears in the goal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This time, automation is able to see through the definition
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of myFact.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: However, the Hint Unfold mechanism only works for unfolding
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definitions that appear in the goal. In general, proof search does
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: not unfold definitions from the context. For example, assume we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: want to prove that P 3 holds under the assumption that True → myFact.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'There is actually one exception to the previous rule: a constant'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: occuring in an hypothesis is automatically unfolded if the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hypothesis can be directly applied to the current goal. For example,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: auto can prove myFact → P 3, as illustrated below.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Automation for Proving Absurd Goals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll see that lemmas concluding on a negation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are generally not useful as hints, and that lemmas whose
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: conclusion is False can be useful hints but having too many of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: them makes proof search inefficient. We'll also see a practical
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: work-around to the efficiency issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Consider the following lemma, which asserts that a number
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: less than or equal to 3 is not greater than 3.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Equivalently, one could state that a number greater than three is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: not less than or equal to 3.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In fact, both statements are equivalent to a third one stating
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that x ≤ 3 and x > 3 are contradictory, in the sense that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: they imply False.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The following investigation aim at figuring out which of the three
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: statments is the most convenient with respect to proof
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: automation. The following material is enclosed inside a Section,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: so as to restrict the scope of the hints that we are adding. In
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: other words, after the end of the section, the hints added within
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the section will no longer be active.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Let's try to add the first lemma, le_not_gt, as hint,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and see whether we can prove that the proposition
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ∃ x, x ≤ 3 ∧ x > 3 is absurd.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The lemma gt_not_le is symmetric to le_not_gt, so it will not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: be any better. The third lemma, le_gt_false, is a more useful
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hint, because it concludes on False, so proof search will try to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: apply it when the current goal is False.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In summary, a lemma of the form H[1] → H[2] → False is a much more
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: effective hint than H[1] → ¬ H[2], even though the two statments
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are equivalent up to the definition of the negation symbol ¬.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That said, one should be careful with adding lemmas whose
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: conclusion is False as hint. The reason is that whenever
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reaching the goal False, the proof search mechanism will
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: potentially try to apply all the hints whose conclusion is False
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: before applying the appropriate one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Adding lemmas whose conclusion is False as hint can be, locally,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a very effective solution. However, this approach does not scale
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: up for global hints.  For most practical applications, it is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reasonable to give the name of the lemmas to be exploited for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: deriving a contradiction. The tactic false H, provided by
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'LibTactics serves that purpose: false H replaces the goal'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: with False and calls eapply H. Its behavior is described next.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Observe that any of the three statements le_not_gt, gt_not_le
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: or le_gt_false can be used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, false le_gt_false; eauto proves the goal,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: but false le_gt_false; auto does not, because auto does not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: correctly instantiate the existential variable. Note that false* le_gt_false
    would not work either, because the star symbol tries
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to call auto first. So, there are two possibilities for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'completing the proof: either call false le_gt_false; eauto, or'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: call false* (le_gt_false 3).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameter typ : Type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameter subtype : typ → typ → Prop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameter subtype_refl : ∀T,'
  prefs: []
  type: TYPE_NORMAL
- en: subtype T T.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameter subtype_trans : ∀S T U,'
  prefs: []
  type: TYPE_NORMAL
- en: subtype S T → subtype T U → subtype S U.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Hint Resolve subtype_refl.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Section HintsTransitivity.
  prefs: []
  type: TYPE_NORMAL
- en: Hint Resolve subtype_trans.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma transitivity_bad_hint_1 : ∀S T,'
  prefs: []
  type: TYPE_NORMAL
- en: subtype S T.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros. (* debug *) eauto. (* Investigates 106 applications... *)
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: End HintsTransitivity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Hint Extern 1 (subtype ?S ?U) ⇒
  prefs: []
  type: TYPE_NORMAL
- en: match goal with
  prefs: []
  type: TYPE_NORMAL
- en: '| H: subtype S ?T ⊢ _ ⇒ apply (@subtype_trans S T U)'
  prefs: []
  type: TYPE_NORMAL
- en: '| H: subtype ?T U ⊢ _ ⇒ apply (@subtype_trans S T U)'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma transitivity_workaround_1 : ∀T[1] T[2] T[3] T[4],'
  prefs: []
  type: TYPE_NORMAL
- en: subtype T[1] T[2] → subtype T[2] T[3] → subtype T[3] T[4] → subtype T[1] T[4].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros. (* debug *) eauto. (* The trace shows the external hint being used *)
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma transitivity_workaround_2 : ∀S T,'
  prefs: []
  type: TYPE_NORMAL
- en: subtype S T.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros. (* debug *) eauto. (* Investigates 0 applications *)
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Omega
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tactic omega supports natural numbers (type nat) as well as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: integers (type Z, available by including the module ZArith).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It supports addition, substraction, equalities and inequalities.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before using omega, one needs to import the module Omega,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: as follows.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Here is an example. Let x and y be two natural numbers
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (they cannot be negative). Assume y is less than 4, assume
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: x+x+1 is less than y, and assume x is not zero. Then,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it must be the case that x is equal to one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example: if z is the mean of x and y, and if the'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: difference between x and y is at most 4, then the difference
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: between x and z is at most 2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: One can proof False using omega if the mathematical facts
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from the context are contradictory. In the following example,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the constraints on the values x and y cannot be all
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: satisfied in the same time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: omega can prove a goal by contradiction only if its'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: conclusion reduces to False. The tactic omega always fails
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: when the conclusion is an arbitrary proposition P, even though
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: False implies any proposition P (by ex_falso_quodlibet).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Ring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared with omega, the tactic ring adds support for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: multiplications, however it gives up the ability to reason on
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: inequations. Moreover, it supports only integers (type Z) and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: not natural numbers (type nat). Here is an example showing how
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to use ring.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Congruence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tactic congruence is able to exploit equalities from the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proof context in order to automatically perform the rewriting
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: operations necessary to establish a goal. It is slightly more
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: powerful than the tactic subst, which can only handle equalities
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of the form x = e where x is a variable and e an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Moreover, congruence is able to exploit universally quantified
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: equalities, for example ∀ a, g a = h a.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Next is an example where congruence is very useful.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The tactic congruence is able to prove a contradiction if the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: goal entails an equality that contradicts an inequality available
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in the proof context.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: One of the strengths of congruence is that it is a very fast
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tactic. So, one should not hesitate to invoke it wherever it might
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: help.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
