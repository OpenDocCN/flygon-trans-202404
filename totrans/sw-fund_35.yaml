- en: UseAutoTheory and Practice of Automation in Coq Proofs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自动理论和Coq证明中的实践
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: (* Chapter written and maintained by Arthur Chargueraud *)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: (* 本章由Arthur Chargueraud编写和维护 *)
- en: '[PRE1]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Require Import Coq.Arith.Arith.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Coq.Arith.Arith。
- en: Require Import Coq.Lists.List.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Coq.Lists.List。
- en: Import ListNotations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Import ListNotations。
- en: Require Import Maps.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Maps。
- en: Require Import Smallstep.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Smallstep。
- en: Require Import Stlc.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Stlc。
- en: Require Import LibTactics.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import LibTactics。
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Strength of Proof Search
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 证明搜索的强度
- en: 'We are going to study four proof-search tactics: auto, eauto,'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将研究四种证明搜索策略：auto，eauto，
- en: iauto and jauto. The tactics auto and eauto are builtin
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: iauto和jauto。策略auto和eauto是内置的
- en: in Coq. The tactic iauto is a shorthand for the builtin tactic
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Coq中。策略iauto是内置策略的简写
- en: try solve [intuition eauto]. The tactic jauto is defined in
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试解决[intuition eauto]。策略jauto在
- en: the library LibTactics, and simply performs some preprocessing
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 库LibTactics，并简单地执行一些预处理
- en: of the goal before calling eauto. The goal of this chapter is
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在调用eauto之前检查目标的结构。本章的目标是
- en: to explain the general principles of proof search and to give
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解释证明搜索的一般原则并给出
- en: rule of thumbs for guessing which of the four tactics mentioned
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 猜测这四种策略中的哪一种是最好的
- en: above is best suited for solving a given goal.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述最适合解决给定目标。
- en: Proof search is a compromise between efficiency and
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明搜索是效率和
- en: expressiveness, that is, a tradeoff between how complex goals the
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表达能力，即如何解决复杂目标之间的权衡
- en: tactic can solve and how much time the tactic requires for
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 策略可以解决多少和策略需要多长时间
- en: terminating. The tactic auto builds proofs only by using the
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 终止。策略auto仅通过使用构建证明
- en: basic tactics reflexivity, assumption, and apply. The tactic
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基本策略的折中：自反性、假设和应用。该策略
- en: eauto can also exploit eapply. The tactic jauto extends
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: eauto还可以利用eapply。策略jauto扩展
- en: eauto by being able to open conjunctions and existentials that
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过eauto能够打开与
- en: occur in the context.  The tactic iauto is able to deal with
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 发生在上下文中。策略iauto能够处理
- en: conjunctions, disjunctions, and negation in a quite clever way;
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与否定相当聪明地处理与否定相反的情况；
- en: however it is not able to open existentials from the context.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，它无法从上下文中打开存在量化。
- en: Also, iauto usually becomes very slow when the goal involves
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另外，当目标涉及到时，iauto通常会变得非常慢
- en: several disjunctions.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 几个析取。
- en: Note that proof search tactics never perform any rewriting
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，证明搜索策略永远不会执行任何重写
- en: step (tactics rewrite, subst), nor any case analysis on an
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 步骤（策略rewrite，subst），也不是在一个上进行案例分析
- en: arbitrary data structure or property (tactics destruct and
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任意数据结构或属性（策略destruct和
- en: inversion), nor any proof by induction (tactic induction). So,
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: inversion），也不是任何归纳证明（tactic induction）。所以，
- en: proof search is really intended to automate the final steps from
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明搜索实际上是为了自动化最后几步
- en: the various branches of a proof. It is not able to discover the
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个证明的各个分支。它不能发现
- en: overall structure of a proof.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明的总体结构。
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Lemma solving_by_reflexivity :'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 引理solving_by_reflexivity：
- en: 2 + 3 = 5.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 2 + 3 = 5。
- en: Proof. auto. Qed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。auto。Qed。
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Lemma solving_by_apply : ∀(P Q : nat→Prop),'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 引理solving_by_apply：∀(P Q：nat→Prop），
- en: (∀n, Q n → P n) →
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: (∀n，Q n → P n）→
- en: (∀n, Q n) →
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: (∀n，Q n）→
- en: P 2.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: P 2。
- en: Proof. auto. Qed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。auto。Qed。
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Lemma solving_by_eapply : ∀(P Q : nat→Prop),'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 引理solving_by_eapply：∀(P Q：nat→Prop），
- en: (∀n m, Q m → P n) →
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: (∀n m，Q m → P n）→
- en: Q 1 → P 2.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Q 1 → P 2。
- en: Proof. auto. eauto. Qed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。auto。eauto。Qed。
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lemma solving_conj_goal : ∀(P : nat→Prop) (F : Prop),'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 引理solving_conj_goal：∀(P：nat→Prop）（F：Prop），
- en: (∀n, P n) → F → F ∧ P 2.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: (∀n，P n）→ F → F ∧ P 2。
- en: Proof. auto. Qed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。auto。Qed。
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Lemma solving_conj_hyp : ∀(F F'' : Prop),'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 引理solving_conj_hyp：∀(F F'：Prop），
- en: F ∧ F' → F.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: F ∧ F' → F。
- en: Proof. auto. eauto. jauto. (* or iauto *) Qed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。auto。eauto。jauto。(* 或者iauto *) Qed。
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Lemma solving_conj_hyp'' : ∀(F F'' : Prop),'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 引理solving_conj_hyp'：∀(F F'：Prop），
- en: F ∧ F' → F.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: F ∧ F' → F。
- en: Proof. intros. jauto_set. eauto. Qed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。intros。jauto_set。eauto。Qed。
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Lemma solving_conj_more : ∀(P Q R : nat→Prop) (F : Prop),'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 引理solving_conj_more：∀(P Q R：nat→Prop)（F：Prop），
- en: (F ∧ (∀n m, (Q m ∧ R n) → P n)) →
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: (F ∧ (∀n m，(Q m ∧ R n) → P n)) →
- en: (F → R 2) →
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: (F → R 2) →
- en: Q 1 →
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Q 1 →
- en: P 2 ∧ F.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: P 2 ∧ F。
- en: Proof. jauto. (* or iauto *) Qed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。jauto。(* 或者iauto *) Qed。
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Lemma solving_conj_hyp_forall : ∀(P Q : nat→Prop),'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 引理solving_conj_hyp_forall：∀(P Q：nat→Prop），
- en: (∀n, P n ∧ Q n) → P 2.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: (∀n，P n ∧ Q n）→ P 2。
- en: Proof.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: auto. eauto. iauto. jauto.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: auto。eauto。iauto。jauto。
- en: (* Nothing works, so we have to do some of the work by hand *)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: (* 没有任何方法有效，所以我们必须手动做一些工作 *)
- en: intros. destruct (H 2). auto.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: intros。destruct（H 2）。auto。
- en: Qed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Lemma solved_by_jauto : ∀(P Q : nat→Prop) (F : Prop),'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 引理solved_by_jauto：∀(P Q：nat→Prop）（F：Prop），
- en: (∀n, P n) ∧ (∀n, Q n) → P 2.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: (∀n，P n）∧（∀n，Q n）→ P 2。
- en: Proof. jauto. (* or iauto *) Qed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。jauto。(* 或者iauto *) Qed。
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Lemma solving_disj_goal : ∀(F F'' : Prop),'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 解决 disj_goal 的引理：∀(F F'：Prop)，
- en: F → F ∨ F'.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: F → F ∨ F'。
- en: Proof. auto. Qed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。auto。证毕。
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Lemma solving_disj_hyp : ∀(F F'' : Prop),'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 解决 disj_hyp 的引理：∀(F F'：Prop)，
- en: F ∨ F' → F' ∨ F.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: F ∨ F' → F' ∨ F。
- en: Proof. auto. eauto. jauto. iauto. Qed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。auto。eauto。jauto。iauto。证毕。
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lemma solving_tauto : ∀(F[1] F[2] F[3] : Prop),'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 解决 tauto 的引理：∀(F[1] F[2] F[3]：Prop)，
- en: ((¬F[1] ∧ F[3]) ∨ (F[2] ∧ ¬F[3])) →
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ((¬F[1] ∧ F[3]) ∨ (F[2] ∧ ¬F[3])) →
- en: (F[2] → F[1]) →
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: （F[2] → F[1]）→
- en: (F[2] → F[3]) →
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: （F[2] → F[3]）→
- en: ¬F[2].
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ¬F[2]。
- en: Proof. iauto. Qed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。iauto。证毕。
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Existentials
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存在
- en: The tactics eauto, iauto, and jauto can prove goals whose
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 策略 eauto、iauto 和 jauto 可以证明目标，其
- en: conclusion is an existential. For example, if the goal is ∃ x, f x, the tactic
    eauto introduces an existential variable,
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结论是存在的。例如，如果目标是 ∃ x，f x，则策略 eauto 引入一个存在变量，
- en: say ?25, in place of x. The remaining goal is f ?25, and
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 说?25，而不是x。剩余目标是 f ?25，和
- en: eauto tries to solve this goal, allowing itself to instantiate
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: eauto 尝试解决此目标，允许自身实例化
- en: ?25 with any appropriate value. For example, if an assumption f 2 is available,
    then the variable ?25 gets instantiated with
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ?25 与任何适当的值。例如，如果存在假设 f 2，则变量?25 被实例化为
- en: 2 and the goal is solved, as shown below.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2，目标解决如下所示。
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A major strength of jauto over the other proof search tactics is
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: jauto相对于其他证明搜索策略的一个主要优势是
- en: that it is able to exploit the existentially-quantified
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它能够利用存在量化
- en: hypotheses, i.e., those of the form ∃ x, P.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设，即形式为∃ x，P 的那些。
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Negation
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 否定
- en: The tactics auto and eauto suffer from some limitations with
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 策略 auto 和 eauto 在处理中存在一些局限性
- en: respect to the manipulation of negations, mostly related to the
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就否定的处理而言，它们在很大程度上与
- en: fact that negation, written ¬ P, is defined as P → False but
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否定的事实，写作 ¬ P，被定义为 P → False，但
- en: that the unfolding of this definition is not performed
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义的展开不会执行
- en: automatically. Consider the following example.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动地。考虑以下示例。
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For this reason, the tactics iauto and jauto systematically
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于这个原因，策略 iauto 和 jauto 系统地
- en: invoke unfold not in * as part of their pre-processing. So,
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在其预处理的一部分中调用解除 not。所以，
- en: they are able to solve the previous goal right away.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 他们能够立即解决之前的目标。
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We will come back later on to the behavior of proof search with
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们稍后会回到与证明搜索行为有关的问题
- en: respect to the unfolding of definitions.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于定义展开的尊重。
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Lemma equality_by_auto : ∀(f g : nat→Prop),'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: equality_by_auto 的引理：∀(f g：nat→Prop)，
- en: (∀x, f x = g x) → g 2 = f 2.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: (∀x，f x = g x) → g 2 = f 2。
- en: Proof. auto. Qed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。auto。证毕。
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How Proof Search Works
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 证明搜索如何工作
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Lemma search_depth_0 :'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索深度_0：
- en: True ∧ True ∧ True ∧ True ∧ True ∧ True.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 真 ∧ 真 ∧ 真 ∧ 真 ∧ 真 ∧ 真。
- en: Proof.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: auto.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: auto。
- en: Abort.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃。
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Lemma search_depth_1 : ∀(P : nat→Prop),'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索深度_1的引理：∀(P：nat→Prop)，
- en: P 0 →
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: P 0 →
- en: (P 0 → P 1) →
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: （P 0 → P 1）→
- en: (P 1 → P 2) →
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: （P 1 → P 2）→
- en: (P 2).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: （P 2）。
- en: Proof.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: auto 0\. (* does not find the proof *)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: auto 0\.（*找不到证明*）
- en: auto 1\. (* does not find the proof *)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: auto 1\.（*找不到证明*）
- en: auto 2\. (* does not find the proof *)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: auto 2\.（*找不到证明*）
- en: auto 3\. (* finds the proof *)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: auto 3\.（*找到证明*）
- en: (* more generally, auto n solves the goal if n ≥ 3 *)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: （*更一般地，如果 n ≥ 3，则 auto n 解决目标*）
- en: Qed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 证毕。
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lemma search_depth_3 : ∀(P : nat→Prop),'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索深度_3的引理：∀(P：nat→Prop)，
- en: (* Hypothesis H[1]: *) (P 0) →
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: （*假设 H[1]：*）（P 0）→
- en: (* Hypothesis H[2]: *) (∀k, P (k-1) → P k) →
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: （*假设 H[2]：*）（∀k，P (k-1) → P k）→
- en: (* Goal:          *) (P 4).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: （*目标：*）（P 4）。
- en: Proof. auto. Qed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。auto。证毕。
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Lemma search_depth_4 : ∀(P : nat→Prop),'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索深度_4的引理：∀(P：nat→Prop)，
- en: (* Hypothesis H[1]: *) (P 0) →
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: （*假设 H[1]：*）（P 0）→
- en: (* Hypothesis H[2]: *) (∀k, P (k-1) → P k) →
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: （*假设 H[2]：*）（∀k，P (k-1) → P k）→
- en: (* Goal:          *) (P 5).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: （*目标：*）（P 5）。
- en: Proof. auto. auto 6\. Qed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。auto。auto 6\. 证毕。
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Lemma search_depth_5 : ∀(P : nat→Prop),'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索深度_5的引理：∀(P：nat→Prop)，
- en: (* Hypothesis H[1]: *) (P 0) →
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: （*假设 H[1]：*）（P 0）→
- en: (* Hypothesis H[2]: *) (∀k, P (k-1) → P k) →
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: （*假设 H[2]：*）（∀k，P (k-1) → P k）→
- en: (* Goal:          *) (P 4 ∧ P 4).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: （*目标：*）（P 4 ∧ P 4）。
- en: Proof. auto. auto 6\. Qed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。auto。auto 6\. 证毕。
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Lemma working_of_auto_1 : ∀(P : nat→Prop),'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索深度_1的引理：∀(P：nat→Prop)，
- en: (* Hypothesis H[1]: *) (P 0) →
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: （*假设 H[1]：*）（P 0）→
- en: (* Hypothesis H[2]: *) (∀k, P (k-1) → P k) →
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: （*假设 H[2]：*）（∀k，P (k-1) → P k）→
- en: (* Hypothesis H[3]: *) (∀k, P (k+1) → P k) →
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: （*假设 H[3]：*）（∀k，P (k+1) → P k）→
- en: (* Goal:          *) (P 2).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: （*目标：*）（P 2）。
- en: (* Uncomment "debug" in the following line to see the debug trace: *)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: （取消注释以下行中的“debug”以查看调试跟踪：）
- en: Proof. intros P H[1] H[2] H[3]. (* debug *) eauto. Qed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。intros P H[1] H[2] H[3]。（*调试*）eauto。证毕。
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: depth=5
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 深度=5
- en: depth=4 apply H2
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 深度=4 应用 H2
- en: depth=3 apply H2
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 深度=3 应用 H2
- en: depth=3 exact H1
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 深度=3 确切 H1
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Lemma working_of_auto_2 : ∀(P : nat→Prop),'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 引理 auto_2 的工作原理：∀(P：nat→Prop)，
- en: (* Hypothesis H[1]: *) (P 0) →
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: （*假设 H[1]：*）（P 0）→
- en: (* Hypothesis H[3]: *) (∀k, P (k+1) → P k) →
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: (* 假设 H[3]： *) (∀k，P (k+1) → P k) →
- en: (* Hypothesis H[2]: *) (∀k, P (k-1) → P k) →
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: (* 假设 H[2]： *) (∀k，P (k-1) → P k) →
- en: (* Goal:          *) (P 2).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: (* 目标： *) (P 2)。
- en: Proof. intros P H[1] H[3] H[2]. (* debug *) eauto. Qed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。intros P H[1] H[3] H[2]。（调试）eauto。Qed。
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|5||4||3||2||1||0| -- below, tabulation indicates the depth'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|5||4||3||2||1||0| -- 下面，制表符表示深度'
- en: '[P 2]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[P 2]'
- en: -> [P 3]
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 3]
- en: -> [P 4]
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 4]
- en: -> [P 5]
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 5]
- en: -> [P 6]
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 6]
- en: -> [P 7]
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 7]
- en: -> [P 5]
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 5]
- en: -> [P 4]
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 4]
- en: -> [P 5]
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 5]
- en: -> [P 3]
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 3]
- en: --> [P 3]
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: --> [P 3]
- en: -> [P 4]
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 4]
- en: -> [P 5]
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 5]
- en: -> [P 3]
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 3]
- en: -> [P 2]
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 2]
- en: -> [P 3]
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 3]
- en: -> [P 1]
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 1]
- en: -> [P 2]
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 2]
- en: -> [P 3]
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 3]
- en: -> [P 4]
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 4]
- en: -> [P 5]
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 5]
- en: -> [P 3]
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 3]
- en: -> [P 2]
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 2]
- en: -> [P 3]
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 3]
- en: -> [P 1]
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 1]
- en: -> [P 1]
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 1]
- en: -> [P 2]
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 2]
- en: -> [P 3]
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 3]
- en: -> [P 1]
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 1]
- en: -> [P 0]
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> [P 0]
- en: -> !! Done !!
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: -> !! 完成 !!
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Adding Hints
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加提示
- en: By default, auto (and eauto) only tries to apply the
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，auto（和 eauto）只尝试应用
- en: hypotheses that appear in the proof context. There are two
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 出现在证明上下文中的假设。有两个
- en: possibilities for telling auto to exploit a lemma that have
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 告诉 auto 利用引理的可能性有两种
- en: 'been proved previously: either adding the lemma as an assumption'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前已经被证明：要么将引理添加为假设
- en: just before calling auto, or adding the lemma as a hint, so
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在调用 auto 前，或将引理添加为提示，以便
- en: that it can be used by every calls to auto.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它可以被每个调用自动的调用使用。
- en: The first possibility is useful to have auto exploit a lemma
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一种可能性对于让 auto 利用引理很有用
- en: that only serves at this particular point. To add the lemma as
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只在这个特定点起作用。要将引理添加为
- en: hypothesis, one can type generalize mylemma; intros, or simply
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设，可以输入 generalize mylemma; intros，或者简单地
- en: 'lets: mylemma (the latter requires LibTactics.v).'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: lets：mylemma（后者需要 LibTactics.v）。
- en: The second possibility is useful for lemmas that need to be
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二种可能性对于需要的引理很有用
- en: exploited several times. The syntax for adding a lemma as a hint
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多次利用。将引理添加为提示的语法
- en: is Hint Resolve mylemma. For example, the lemma asserting than
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是 Hint Resolve mylemma。例如，断言的引理
- en: any number is less than or equal to itself, ∀ x, x ≤ x,
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任何数小于或等于自身，∀ x，x ≤ x，
- en: called Le.le_refl in the Coq standard library, can be added as a
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Coq 标准库中称为 Le.le_refl，可以作为
- en: hint as follows.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示如下。
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A convenient shorthand for adding all the constructors of an
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加一个归纳的方便简写是
- en: inductive datatype as hints is the command Hint Constructors mydatatype.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为提示的归纳数据类型是命令 Hint Constructors mydatatype。
- en: 'Warning: some lemmas, such as transitivity results, should'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 警告：某些引理，如传递性结果，应该
- en: not be added as hints as they would very badly affect the
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要添加提示，因为它们会严重影响
- en: performance of proof search. The description of this problem
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明搜索的性能。对此问题的描述
- en: and the presentation of a general work-around for transitivity
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以及对传递性的一般解决方法的展示
- en: lemmas appear further on.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引理会进一步出现。
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Ltac auto_star ::= a_new_definition.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Ltac auto_star ::= 一个新的定义。
- en: Observe the use of ::= instead of :=, which indicates that the
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意使用 ::= 而不是 :=，这表示
- en: tactic is being rebound to a new definition. So, the default
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 策略被重新绑定到一个新的定义。所以，默认
- en: definition is as follows.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义如下。
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Nearly all standard Coq tactics and all the tactics from
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 几乎所有标准 Coq 策略和所有来自
- en: '"LibTactics" can be called with a star symbol. For example, one'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"LibTactics" 可以用星号调用。例如，一个'
- en: 'can invoke subst*, destruct* H, inverts* H, lets* I: H x,'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '可以调用 subst*，destruct* H，inverts* H，lets* I: H x，'
- en: specializes* H x, and so on... There are two notable exceptions.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: specializes* H x，等等... 有两个值得注意的例外。
- en: The tactic auto* is just another name for the tactic
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 策略 auto* 只是策略的另一个名称
- en: auto_star.  And the tactic apply* H calls eapply H (or the
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: auto_star。而策略 apply* H 调用 eapply H（或
- en: more powerful applys H if needed), and then calls auto_star.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更强大的应用 H（如果需要），然后调用 auto_star。
- en: Note that there is no eapply* H tactic, use apply* H
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，没有 eapply* H 策略，使用 apply* H
- en: instead.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相反。
- en: In large developments, it can be convenient to use two degrees of
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在大型开发中，使用两个程度可能会更方便
- en: automation. Typically, one would use a fast tactic, like auto,
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动化。通常，人们会使用快速策略，如 auto，
- en: and a slower but more powerful tactic, like jauto. To allow for
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和一个更慢但更强大的策略，比如 jauto。为了允许
- en: a smooth coexistence of the two form of automation, LibTactics.v
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两种形式的自动化之间的平滑共存，LibTactics.v
- en: also defines a "tilde" version of tactics, like apply¬ H,
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还定义了策略的 "波浪" 版本，比如 apply¬ H，
- en: destruct¬ H, subst¬, auto¬ and so on. The meaning of the
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: destruct¬ H，subst¬，auto¬ 等等。策略的含义
- en: tilde symbol is described by the auto_tilde tactic, whose
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 波浪符号由 auto_tilde 策略描述，其
- en: default implementation is auto.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认实现是 auto。
- en: '[PRE35]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the examples that follow, only auto_star is needed.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在接下来的示例中，只需要auto_star。
- en: An alternative, possibly more efficient version of auto_star is the
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: auto_star的另一种可能更有效的版本是
- en: 'following":'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '以下是接下来的示例":'
- en: Ltac auto_star ::= try solve eassumption | auto | jauto .
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ltac auto_star ::= try solve eassumption | auto | jauto .
- en: With the above definition, auto_star first tries to solve the
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有了上面的定义，auto_star首先尝试解决
- en: goal using the assumptions; if it fails, it tries using auto,
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用假设;如果失败，它尝试使用auto，
- en: and if this still fails, then it calls jauto. Even though
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并且如果这仍然失败，则调用jauto。即使
- en: jauto is strictly stronger than eassumption and auto, it
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: jauto严格比eassumption和auto更强大，它
- en: makes sense to call these tactics first, because, when the
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是有意义的首先调用这些策略，因为当
- en: succeed, they save a lot of time, and when they fail to prove
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 成功，它们节省了大量时间，当它们无法证明时
- en: the goal, they fail very quickly.".
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目标，它们很快就失败了。”。
- en: '[PRE36]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Determinism
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定性
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Recall the original proof of the determinism lemma for the IMP
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回想一下IMP的确定性引理的原始证明
- en: language, shown below.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 语言，如下所示。
- en: '[PRE38]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Exercise: rewrite this proof using auto whenever possible.'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 练习：尽可能使用auto重写此证明。
- en: (The solution uses auto 9 times.)
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （解决方案使用auto 9次。）
- en: '[PRE39]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In fact, using automation is not just a matter of calling auto
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，使用自动化不仅仅是调用自动
- en: in place of one or two other tactics. Using automation is about
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代替其他一个或两个策略。使用自动化是关于
- en: rethinking the organization of sequences of tactics so as to
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重新考虑策略序列的组织以便
- en: minimize the effort involved in writing and maintaining the proof.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最小化编写和维护证明所涉及的工作。
- en: This process is eased by the use of the tactics from
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个过程得益于使用来自的策略
- en: LibTactics.v.  So, before trying to optimize the way automation
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LibTactics.v。所以，在尝试优化自动化方式之前
- en: 'is used, let''s first rewrite the proof of determinism:'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 被使用，让我们首先重写确定性的证明：
- en: use introv H instead of intros x H,
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用introv H而不是intros x H，
- en: use gen x instead of generalize dependent x,
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用gen x而不是generalize dependent x，
- en: use inverts H instead of inversion H; subst,
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用inverts H而不是inversion H;subst，
- en: use tryfalse to handle contradictions, and get rid of the cases where beval
    st b[1] = true and beval st b[1] = false both appear in the context,
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用tryfalse处理矛盾，并且消除出现在上下文中的beval st b[1] = true和beval st b[1] = false两者都出现的情况，
- en: stop using ceval_cases to label subcases.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止使用ceval_cases来标记子案例。
- en: '[PRE40]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To obtain a nice clean proof script, we have to remove the calls
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要获得一个干净的漂亮的证明脚本，我们必须删除调用
- en: assert (st' = st'0). Such a tactic invokation is not nice
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 断言（st' = st'0）。这样的策略调用不好
- en: because it refers to some variables whose name has been
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为它涉及到一些变量，它们的名称已经
- en: automatically generated. This kind of tactics tend to be very
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动生成。这种策略往往是非常
- en: brittle.  The tactic assert (st' = st'0) is used to assert the
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 脆弱。断言（st' = st'0）的策略用于断言
- en: conclusion that we want to derive from the induction
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们想从归纳中推导出的结论
- en: hypothesis. So, rather than stating this conclusion explicitly, we
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设。所以，我们不是明确陈述这个结论，我们
- en: are going to ask Coq to instantiate the induction hypothesis,
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将要求Coq实例化归纳假设，
- en: using automation to figure out how to instantiate it. The tactic
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用自动化来确定如何实例化它。战术
- en: forwards, described in LibTactics.v precisely helps with
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: forwards，在LibTactics.v中精确描述了如何帮助
- en: instantiating a fact. So, let's see how it works out on our
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实例化一个事实。所以，让我们看看它在我们的上的运行情况
- en: example.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例子。
- en: '[PRE41]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To polish the proof script, it remains to factorize the calls
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了完善证明脚本，仍然需要合并调用
- en: to auto, using the star symbol. The proof of determinism can then
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到 `auto`，使用星号符号。确定性的证明可以
- en: be rewritten in only four lines, including no more than 10 tactics.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只需用四行重新编写，包括不超过10个策略。
- en: '[PRE42]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Preservation for STLC
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STLC的保留
- en: '[PRE43]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Consider the proof of perservation of STLC, shown below.
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑STLC的保存证明，如下所示。
- en: This proof already uses eauto through the triple-dot
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个证明已经通过了通过三个点的eauto
- en: mechanism.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 机制。
- en: '[PRE44]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Exercise: rewrite this proof using tactics from LibTactics'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 练习：使用LibTactics中的策略重写此证明
- en: and calling automation using the star symbol rather than the
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并且使用星号符号调用自动化而不是
- en: triple-dot notation. More precisely, make use of the tactics
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 三点符号。更准确地说，利用策略
- en: inverts* and applys* to call auto* after a call to
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: inverts*和applys*在调用auto*之后调用
- en: inverts or to applys. The solution is three lines long.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: invert或者应用。解决方案只有三行长。
- en: '[PRE45]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Progress for STLC
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STLC的进展
- en: Consider the proof of the progress theorem.
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑进步定理的证明。
- en: '[PRE46]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Exercise: optimize the above proof.'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 练习：优化以上证明。
- en: 'Hint: make use of destruct* and inverts*.'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示：利用destruct*和inverts*。
- en: The solution consists of 10 short lines.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决方案由 10 行短代码组成。
- en: '[PRE47]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: BigStep and SmallStep
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大步和小步
- en: '[PRE48]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Consider the proof relating a small-step reduction judgment
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑与小步减少判断相关的证明
- en: to a big-step reduction judgment.
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到一个大步减少判断。
- en: '[PRE49]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Our goal is to optimize the above proof. It is generally
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的目标是优化上述证明。通常
- en: easier to isolate inductions into separate lemmas. So,
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更容易将归纳隔离到单独的引理中。所以，
- en: we are going to first prove an intermediate result
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将首先证明一个中间结果
- en: that consists of the judgment over which the induction
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包括归纳的判断。
- en: is being performed.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正在执行。
- en: 'Exercise: prove the following result, using tactics'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 练习：使用策略证明以下结果
- en: introv, induction and subst, and apply*.
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: introv，归纳和替换，并应用*。
- en: The solution is 3 lines long.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决方案为 3 行。
- en: '[PRE50]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Exercise: using the lemma above, simplify the proof of'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 练习：使用上述引理，简��
- en: the result multistep__eval. You should use the tactics
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果 multistep__eval。你应该使用策略
- en: introv, inverts, split* and apply*.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: introv，inverts，split* 和 apply*。
- en: The solution is 2 lines long.
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决方案为 2 行。
- en: '[PRE51]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If we try to combine the two proofs into a single one,
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们试图将两个证明合并为一个，
- en: we will likely fail, because of a limitation of the
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们很可能会失败，因为有一个限制
- en: induction tactic. Indeed, this tactic looses
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 归纳策略。实际上，这个策略会丢失
- en: information when applied to a property whose arguments
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用于参数的属性时的信息
- en: are not reduced to variables, such as t ⇒* (C n).
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有简化为变量，例如 t ⇒* (C n)。
- en: You will thus need to use the more powerful tactic called
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，您需要使用更强大的策略称为
- en: dependent induction. This tactic is available only after
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 依赖归纳。此策略仅在
- en: importing the Program library, as shown below.
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入 Program 库，如下所示。
- en: '[PRE52]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Exercise: prove the lemma multistep__eval without invoking'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 练习：证明引理 multistep__eval 而不调用
- en: the lemma multistep_eval_ind, that is, by inlining the proof
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引理 multistep_eval_ind，即通过内联证明
- en: by induction involved in multistep_eval_ind, using the
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过涉及 multistep_eval_ind 中的归纳
- en: tactic dependent induction instead of induction.
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 依赖归纳而不是归纳的策略。
- en: The solution is 5 lines long.
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决方案为 5 行。
- en: '[PRE53]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Preservation for STLCRef
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STLCRef 的保留
- en: '[PRE54]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The proof of preservation for STLCRef can be found in chapter
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: STLCRef 的保留证明可以在第章中找到
- en: References.  The optimized proof script is more than twice
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参考文献。优化后的证明脚本是原来的两倍多
- en: shorter.  The following material explains how to build the
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更短。以下材料解释了如何构建
- en: optimized proof script.  The resulting optimized proof script for
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 优化后的证明脚本。最终的优化后的证明脚本为
- en: the preservation theorem appears afterwards.
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保留定理随后出现。
- en: '[PRE55]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Let's come back to the proof case that was hard to optimize.
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们回到难以优化的证明案例。
- en: The difficulty comes from the statement of nth_eq_last, which
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 困难来自于 nth_eq_last 的陈述，其中
- en: takes the form nth (length l) (l ++ x::nil) d = x. This lemma is
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 采用形式 nth (length l) (l ++ x::nil) d = x。这个引理是
- en: hard to exploit because its first argument, length l, mentions
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 难以利用，因为它的第一个参数，长度 l，提到
- en: a list l that has to be exactly the same as the l occuring in
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个列表 l，必须与出现在 l 中的 l 完全相同
- en: snoc l x. In practice, the first argument is often a natural
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: snoc l x。实际上，第一个参数通常是一个自然数
- en: number n that is provably equal to length l yet that is not
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可证明等于长度 l 但不是
- en: syntactically equal to length l. There is a simple fix for
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 语法上等于长度 l。有一个简单的修复方法
- en: 'making nth_eq_last easy to apply: introduce the intermediate'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使 nth_eq_last 易于应用：引入中间
- en: variable n explicitly, so that the goal becomes
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 明确变量 n，使得目标变为
- en: nth n (snoc l x) d = x, with a premise asserting n = length l.
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: nth n (snoc l x) d = x，前提断言 n = length l。
- en: '[PRE56]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The proof case for ref from the preservation theorem then
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从保留定理的证明案例然后
- en: becomes much easier to prove, because rewrite nth_eq_last'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变得更容易证明，因为重写 nth_eq_last'
- en: now succeeds.
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在成功。
- en: '[PRE57]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The optimized proof of preservation is summarized next.
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保留的证明总结如下。
- en: '[PRE58]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Progress for STLCRef
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STLCRef 的进展
- en: The proof of progress for STLCRef can be found in chapter
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: STLCRef 的进展证明可以在第章中找到
- en: References. The optimized proof script is, here again, about
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参考文献。优化后的证明脚本是，再次，关于
- en: half the length.
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 长度的一半。
- en: '[PRE59]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Subtyping
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子类型
- en: '[PRE60]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Consider the inversion lemma for typing judgment
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑类型判断的反演引理
- en: of abstractions in a type system with subtyping.
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在具有子类型的类型系统中的抽象。
- en: '[PRE61]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Exercise: optimize the proof script, using'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 练习：优化证明脚本，使用
- en: introv, lets and inverts*. In particular,
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: introv，lets 和 inverts*。特别地，
- en: you will find it useful to replace the pattern
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您会发现将模式替换为有用
- en: 'apply K in H. destruct H as I with lets I: K H.'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '在 H 中应用 K。将 H 解构为 I，使用 lets I: K H。'
- en: The solution is 4 lines.
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决方案是4行。
- en: '[PRE62]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The lemma substitution_preserves_typing has already been used to
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引理substitution_preserves_typing已经被用于
- en: illustrate the working of lets and applys in chapter
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 说明了在章节中lets和applys的工作原理
- en: UseTactics. Optimize further this proof using automation (with
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: UseTactics。使用自动化进一步优化这个证明
- en: the star symbol), and using the tactic cases_if'. The solution
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 星号符号），并使用tactic cases_if'。解决方案
- en: is 33 lines).
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是33行）。
- en: '[PRE63]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Advanced Topics in Proof Search
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 证明搜索中的高级主题
- en: '[PRE64]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Lemma order_matters_1 : ∀(P : nat→Prop),'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 引理order_matters_1：∀(P：nat→Prop)，
- en: (∀n m, P m → m ≠ 0 → P n) → P 2 → P 1.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: (∀n m, P m → m ≠ 0 → P n) → P 2 → P 1。
- en: Proof.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: eauto. (* Success *)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: eauto。 （*成功*）
- en: (* The proof: intros P H K. eapply H. apply K. auto. *)
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: （*证明：引入P H K。eapply H。应用K。auto。*）
- en: Qed.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。
- en: 'Lemma order_matters_2 : ∀(P : nat→Prop),'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 引理order_matters_2：∀(P：nat→Prop)，
- en: (∀n m, m ≠ 0 → P m → P n) → P 5 → P 1.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: (∀n m, m ≠ 0 → P m → P n) → P 5 → P 1。
- en: Proof.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: eauto. (* Failure *)
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: eauto。 （*失败*）
- en: (* To understand why, let us replay the previous proof *)
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: （*为了理解为什么，让我们重播上一个证明*）
- en: intros P H K.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 引入P H K。
- en: eapply H.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: eapply H。
- en: (* The application of eapply has left two subgoals,      ?X ≠ 0 and P ?X, where ?X is an existential variable. *)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: （*应用eapply后留下了两个子目标，?X ≠ 0和P ?X，其中?X是一个存在变量。*）
- en: (* Solving the first subgoal is easy for eauto: it suffices      to instantiate ?X as the value 1, which is the simplest
         value that satisfies ?X ≠ 0. *)
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: （*对于eauto来说，解决第一个子目标很容易：只需将?X实例化为值1，这是满足?X ≠ 0的最简单值。*）
- en: eauto.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: eauto。
- en: (* But then the second goal becomes P 1, which is where we      started from. So, eauto gets stuck at this point. *)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: （*但是第二个目标变成了P 1，这就是我们开始的地方。所以，eauto在这一点上卡住了。*）
- en: Abort.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃。
- en: '[PRE65]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Unfolding of Definitions During Proof-Search
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在证明搜索期间展开定义
- en: The use of intermediate definitions is generally encouraged in a
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常鼓励使用中间定义
- en: formal development as it usually leads to more concise and more
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 形式化发展，因为通常会导致更简洁��更
- en: readable statements. Yet, definitions can make it a little harder
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可读性的陈述。然而，定义可能会使事情变得有点困难
- en: to automate proofs. The problem is that it is not obvious for a
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动化证明。问题在于对于一个
- en: proof search mechanism to know when definitions need to be
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明搜索机制知道何时需要展开定义
- en: unfolded. Note that a naive strategy that consists in unfolding
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 展开。请注意，一个简单的策略是展开
- en: all definitions before calling proof search does not scale up to
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在调用证明搜索之前展开所有定义并不适用于
- en: large proofs, so we avoid it. This section introduces a few
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大型证明，所以我们避免它。本节介绍了一些
- en: techniques for avoiding to manually unfold definitions before
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 避免在
- en: calling proof search.
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用证明搜索。
- en: To illustrate the treatment of definitions, let P be an abstract
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了说明定义的处理，让P是一个抽象
- en: property on natural numbers, and let myFact be a definition
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自然数的属性，并让myFact是一个定义
- en: denoting the proposition P x holds for any x less than or
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示命题P x对任何小于或等于x的x成立
- en: equal to 3.
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等于3。
- en: '[PRE66]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Proving that myFact under the assumption that P x holds for
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明myFact在假设P x成立的情况下
- en: any x should be trivial. Yet, auto fails to prove it unless we
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任何x都应该是微不足道的。然而，auto无法证明它，除非我们
- en: unfold the definition of myFact explicitly.
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 明确展开myFact的定义。
- en: '[PRE67]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: To automate the unfolding of definitions that appear as proof
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了自动展开出现在证明中的定义
- en: obligation, one can use the command Hint Unfold myFact to tell
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 义务，可以使用命令Hint Unfold myFact告诉
- en: Coq that it should always try to unfold myFact when myFact
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq应该总是尝试展开myFact当myFact
- en: appears in the goal.
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 出现在目标中。
- en: '[PRE68]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This time, automation is able to see through the definition
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一次，自动化能够看穿定义
- en: of myFact.
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: of myFact。
- en: '[PRE69]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: However, the Hint Unfold mechanism only works for unfolding
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，Hint Unfold机制仅适用于展开
- en: definitions that appear in the goal. In general, proof search does
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 出现在目标中的定义。一般来说，证明搜索会
- en: not unfold definitions from the context. For example, assume we
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要从上下文中展开定义。例如，假设我们
- en: want to prove that P 3 holds under the assumption that True → myFact.
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想要证明在True → myFact的假设下P 3成立。
- en: '[PRE70]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'There is actually one exception to the previous rule: a constant'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上有一个例外：一个常数
- en: occuring in an hypothesis is automatically unfolded if the
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果出现在假设中的命题P x会自动展开
- en: hypothesis can be directly applied to the current goal. For example,
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设可以直接应用于当前目标。例如，
- en: auto can prove myFact → P 3, as illustrated below.
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: auto可以证明myFact → P 3，如下所示。
- en: '[PRE71]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Automation for Proving Absurd Goals
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于证明荒谬目标的自动化
- en: In this section, we'll see that lemmas concluding on a negation
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到结论为否定的引理
- en: are generally not useful as hints, and that lemmas whose
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常不是有用的提示，而那些
- en: conclusion is False can be useful hints but having too many of
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结论是False可能是有用的提示，但有太多
- en: them makes proof search inefficient. We'll also see a practical
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们使证明搜索效率低下。我们还将看到一个实际的
- en: work-around to the efficiency issue.
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决效率问题的解决方法。
- en: Consider the following lemma, which asserts that a number
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑以下引理，它断言一个数字
- en: less than or equal to 3 is not greater than 3.
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小于或等于3不大于3。
- en: '[PRE72]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Equivalently, one could state that a number greater than three is
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，可以陈述大于三的数字是
- en: not less than or equal to 3.
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不小于或等于3。
- en: '[PRE73]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In fact, both statements are equivalent to a third one stating
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，这两个陈述等价于第三个陈述
- en: that x ≤ 3 and x > 3 are contradictory, in the sense that
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: x ≤ 3和x > 3是矛盾的，意思是
- en: they imply False.
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们暗示False。
- en: '[PRE74]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The following investigation aim at figuring out which of the three
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下调查旨在弄清楚三者中的哪一个
- en: statments is the most convenient with respect to proof
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 陈述是最方便的，关于证明
- en: automation. The following material is enclosed inside a Section,
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动化。以下材料被包含在一个部分内，
- en: so as to restrict the scope of the hints that we are adding. In
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以限制我们添加的提示的范围。在
- en: other words, after the end of the section, the hints added within
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 换句话说，在章节结束后，添加的提示
- en: the section will no longer be active.
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该章节将不再处于活动状态。
- en: '[PRE75]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Let's try to add the first lemma, le_not_gt, as hint,
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们尝试添加第一个引理le_not_gt作为提示，
- en: and see whether we can prove that the proposition
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看看我们是否可以证明这个命题
- en: ∃ x, x ≤ 3 ∧ x > 3 is absurd.
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ∃ x，x ≤ 3 ∧ x > 3是荒谬的。
- en: '[PRE76]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The lemma gt_not_le is symmetric to le_not_gt, so it will not
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引理gt_not_le对le_not_gt是对称的，因此不会
- en: be any better. The third lemma, le_gt_false, is a more useful
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也不会更好。第三个引理le_gt_false更有用
- en: hint, because it concludes on False, so proof search will try to
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示，因为它的结论是False，所以证明搜索将尝试
- en: apply it when the current goal is False.
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当当前目标为False时应用它。
- en: '[PRE77]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In summary, a lemma of the form H[1] → H[2] → False is a much more
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总之，形式为H[1] → H[2] → False的引理要好得多
- en: effective hint than H[1] → ¬ H[2], even though the two statments
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 比H[1] → ¬ H[2]更有效的提示，尽管这两个陈述
- en: are equivalent up to the definition of the negation symbol ¬.
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在否定符号¬的定义上等效。
- en: That said, one should be careful with adding lemmas whose
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也就是说，应该小心添加那些引理
- en: conclusion is False as hint. The reason is that whenever
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结论为False的提示。原因是每当
- en: reaching the goal False, the proof search mechanism will
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 达到目标False时，证明搜索机制将
- en: potentially try to apply all the hints whose conclusion is False
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可能尝试应用所有结论为False的提示
- en: before applying the appropriate one.
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在应用适当的提示之前。
- en: '[PRE78]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Adding lemmas whose conclusion is False as hint can be, locally,
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将结论为False的引理作为提示添加可能在局部起作用，
- en: a very effective solution. However, this approach does not scale
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个非常有效的解决方案。但是，这种方法不会扩展
- en: up for global hints.  For most practical applications, it is
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于全局提示。对于大多数实际应用，它是
- en: reasonable to give the name of the lemmas to be exploited for
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给出要利用的引理的名称是最方便的
- en: deriving a contradiction. The tactic false H, provided by
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 推导出矛盾。提供的false H策略
- en: 'LibTactics serves that purpose: false H replaces the goal'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LibTactics服务于此目的：false H替换目标
- en: with False and calls eapply H. Its behavior is described next.
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与False一起工作并调用eapply H。其行为将在下面描述。
- en: Observe that any of the three statements le_not_gt, gt_not_le
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意任何三个陈述le_not_gt，gt_not_le
- en: or le_gt_false can be used.
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者可以使用le_gt_false。
- en: '[PRE79]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In the above example, false le_gt_false; eauto proves the goal,
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上面的示例中，false le_gt_false; eauto证明了���标，
- en: but false le_gt_false; auto does not, because auto does not
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但false le_gt_false; auto不起作用，因为auto不
- en: correctly instantiate the existential variable. Note that false* le_gt_false
    would not work either, because the star symbol tries
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正确实例化存在变量。注意，false* le_gt_false也不起作用，因为星号符号尝试
- en: to call auto first. So, there are two possibilities for
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先调用auto。因此，有两种可能性
- en: 'completing the proof: either call false le_gt_false; eauto, or'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成证明：要么调用false le_gt_false; eauto，要么
- en: call false* (le_gt_false 3).
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用false* (le_gt_false 3)。
- en: '[PRE80]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Parameter typ : Type.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 参数typ：Type。
- en: 'Parameter subtype : typ → typ → Prop.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 参数subtype：typ → typ → Prop。
- en: 'Parameter subtype_refl : ∀T,'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 参数subtype_refl：∀T，
- en: subtype T T.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: subtype T T。
- en: 'Parameter subtype_trans : ∀S T U,'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 参数subtype_trans：∀S T U，
- en: subtype S T → subtype T U → subtype S U.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: subtype S T → subtype T U → subtype S U。
- en: '[PRE81]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Hint Resolve subtype_refl.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 提示解决subtype_refl。
- en: '[PRE82]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Section HintsTransitivity.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 章节HintsTransitivity。
- en: Hint Resolve subtype_trans.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 提示解决subtype_trans。
- en: '[PRE83]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Lemma transitivity_bad_hint_1 : ∀S T,'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 引理transitivity_bad_hint_1：∀S T，
- en: subtype S T.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: subtype S T。
- en: Proof.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros. (* debug *) eauto. (* Investigates 106 applications... *)
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: intros. (* debug *) eauto. (* 调查 106 次应用... *)
- en: Abort.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 中止。
- en: '[PRE84]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: End HintsTransitivity.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 结束 HintsTransitivity。
- en: '[PRE85]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Hint Extern 1 (subtype ?S ?U) ⇒
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: Hint Extern 1 (subtype ?S ?U) ⇒
- en: match goal with
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配目标，有
- en: '| H: subtype S ?T ⊢ _ ⇒ apply (@subtype_trans S T U)'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '| H: subtype S ?T ⊢ _ ⇒ 应用 (@subtype_trans S T U)'
- en: '| H: subtype ?T U ⊢ _ ⇒ apply (@subtype_trans S T U)'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '| H: subtype ?T U ⊢ _ ⇒ 应用 (@subtype_trans S T U)'
- en: end.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: '[PRE86]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Lemma transitivity_workaround_1 : ∀T[1] T[2] T[3] T[4],'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 transitivity_workaround_1 : ∀T[1] T[2] T[3] T[4],'
- en: subtype T[1] T[2] → subtype T[2] T[3] → subtype T[3] T[4] → subtype T[1] T[4].
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: subtype T[1] T[2] T[3] T[4] → subtype T[1] T[4].
- en: Proof.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros. (* debug *) eauto. (* The trace shows the external hint being used *)
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: intros. (* debug *) eauto. (* 跟踪显示外部提示被使用 *)
- en: Qed.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: '[PRE87]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Lemma transitivity_workaround_2 : ∀S T,'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 transitivity_workaround_2 : ∀S T,'
- en: subtype S T.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: subtype S T。
- en: Proof.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros. (* debug *) eauto. (* Investigates 0 applications *)
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: intros. (* debug *) eauto. (* 调查 0 次应用 *)
- en: Abort.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 中止。
- en: '[PRE88]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Omega
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Omega
- en: The tactic omega supports natural numbers (type nat) as well as
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 策略 omega 支持自然数（类型 nat）以及
- en: integers (type Z, available by including the module ZArith).
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 整数（类型 Z，通过包含模块 ZArith 可用）。
- en: It supports addition, substraction, equalities and inequalities.
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它支持加法，减法，相等性和不等式。
- en: Before using omega, one needs to import the module Omega,
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在使用 omega 之前，需要导入模块 Omega，
- en: as follows.
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如下。
- en: '[PRE89]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Here is an example. Let x and y be two natural numbers
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个例子。设 x 和 y 为两个自然数
- en: (they cannot be negative). Assume y is less than 4, assume
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （它们不能为负）。假设 y 小于 4，假设
- en: x+x+1 is less than y, and assume x is not zero. Then,
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: x+x+1 小于 y，并假设 x 不为零。那么，
- en: it must be the case that x is equal to one.
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 必须是 x 等于一的情况。
- en: '[PRE90]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Another example: if z is the mean of x and y, and if the'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个示例：如果 z 是 x 和 y 的均值，并且如果
- en: difference between x and y is at most 4, then the difference
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: x 和 y 的差异最多为 4，则差异
- en: between x and z is at most 2.
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: x 和 z 之间的差异最多为 2。
- en: '[PRE91]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: One can proof False using omega if the mathematical facts
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个可以使用 omega 证明 False 的数学事实
- en: from the context are contradictory. In the following example,
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从上下文中是矛盾的。在以下示例中，
- en: the constraints on the values x and y cannot be all
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上下文中的值 x 和 y 的约束不能全部
- en: satisfied in the same time.
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时满足。
- en: '[PRE92]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Note: omega can prove a goal by contradiction only if its'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：omega 只能在其证明目标可通过矛盾证明时证明目标。
- en: conclusion reduces to False. The tactic omega always fails
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结论化简为 False。策略 omega 总是失败
- en: when the conclusion is an arbitrary proposition P, even though
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当结论是任意命题 P 时，即使
- en: False implies any proposition P (by ex_falso_quodlibet).
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: False 可以推出任何命题 P（通过 ex_falso_quodlibet）。
- en: '[PRE93]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Ring
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环
- en: Compared with omega, the tactic ring adds support for
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 omega 相比，策略 ring 添加了对
- en: multiplications, however it gives up the ability to reason on
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 乘法，但它放弃了在
- en: inequations. Moreover, it supports only integers (type Z) and
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不等式。此外，它仅支持整数（类型 Z）和
- en: not natural numbers (type nat). Here is an example showing how
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不是自然数（类型 nat）。以下是一个示例，显示了如何
- en: to use ring.
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 ring。
- en: '[PRE94]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Congruence
  id: totrans-613
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Congruence
- en: The tactic congruence is able to exploit equalities from the
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 策略 congruence 能够利用来自
- en: proof context in order to automatically perform the rewriting
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明上下文以便自动执行重写
- en: operations necessary to establish a goal. It is slightly more
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 建立目标所需的操作。它略微更多
- en: powerful than the tactic subst, which can only handle equalities
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 强大于策略 subst，后者只能处理相等式
- en: of the form x = e where x is a variable and e an
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 形式为 x = e 其中 x 是变量，e 是
- en: expression.
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表达式。
- en: '[PRE95]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Moreover, congruence is able to exploit universally quantified
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，congruence 能够利用普遍量化的
- en: equalities, for example ∀ a, g a = h a.
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相等式，例如 ∀ a，g a = h a。
- en: '[PRE96]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Next is an example where congruence is very useful.
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来是一个 congruence 非常有用的示例。
- en: '[PRE97]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The tactic congruence is able to prove a contradiction if the
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 策略 congruence 能够证明矛盾，如果
- en: goal entails an equality that contradicts an inequality available
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目标导致的相等性与可用的不等式相矛盾
- en: in the proof context.
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在证明上下文中。
- en: '[PRE98]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: One of the strengths of congruence is that it is a very fast
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Congruence 的一项优点是它非常快
- en: tactic. So, one should not hesitate to invoke it wherever it might
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 策略。因此，无论何时都应该调用它
- en: help.
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 帮助。
- en: '[PRE99]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
