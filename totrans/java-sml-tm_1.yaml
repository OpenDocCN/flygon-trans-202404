- en: Process
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过程
- en: Process
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过程
- en: Code (good and bad) doesn't just appear from nowhere, someone needs to sit down
    and write it. How the coder approaches this task can influence the amount of time
    spent swearing at the code later.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 代码（好的和坏的）不是从无处出现的，某人需要坐下来写它。编码者如何处理这项任务会影响以后花在代码上发誓的时间。
- en: This section looks at development philosophy, workflow, and other factors that
    teams should consider before starting to work together.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了开发哲学、工作流程以及团队在开始合作之前应该考虑的其他因素。
- en: Build Fast Feedback Loops
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立快速反馈循环
- en: Build Fast Feedback Loops
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立快速反馈循环
- en: Good code is all about getting good and timely feedback. The sooner you find
    out something is wrong the easier it is to fix.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码关键在于获得良好且及时的反馈。发现问题越早，修复起来就越容易。
- en: Working on a legacy project, where the only way to discover if a code change
    is good is to deploy it to a dev/test/qa environment, is frustrating and demoralizing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个传统项目上工作，唯一发现代码更改是否有效的方法是将其部署到开发/测试/质量保证环境中，这是令人沮丧和泄气的。
- en: Make sure your project has a well designed development workflow - the effort
    of setting this up will be repaid many times over.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的项目具有良好设计的开发工作流程 - 设置这一点的努力将得到多次回报。
- en: Ideally all feedback would be instantaneous, but in practice it is either impractical
    or impossible to get all feedback this way.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，所有反馈都应该是即时的，但实际上要么是不切实际的，要么是不可能以这种方式获得所有反馈。
- en: 'Instead software development is organized as nested levels of feedback, as
    shown here:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发被组织为嵌套级别的反馈，如下所示：
- en: '![Development feedback cycles](feedback_cyclesncr.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![开发反馈循环](feedback_cyclesncr.png)'
- en: Instant Feedback
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即时反馈
- en: Instant Feedback
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 即时反馈
- en: A modern IDE such as Eclipse or IntelliJ will provide instant feedback as you
    type, using the underlying compiler and configurable static analysis tools.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如Eclipse或IntelliJ之类的现代IDE将在您输入时提供即时反馈，使用底层编译器和可配置的静态分析工具。
- en: You can increase the amount of instant feedback you receive by making good use
    of the Java type system and configuring the static analysis tools.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过充分利用Java类型系统并配置静态分析工具，您可以增加获得即时反馈的数量。
- en: While feedback from the IDE is fast and convenient, it has some drawbacks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然IDE的反馈快速且方便，但也有一些缺点。
- en: It may differ from machine to machine depending on the IDE configuration
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能因IDE配置而在不同机器上有所不同
- en: It is often non binary (i.e. not pass/fail)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通常是非二进制的（即不是通过/失败）
- en: It can be ignored / overlooked
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能被忽视/忽略
- en: The expectation of speed limits what it can achieve
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度的期望限制了它的实现
- en: For these reasons you should avoid purely IDE centric work flows. Code should
    not be considered complete by a developer until tests have been run via the build
    file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因，您应该避免纯粹基于IDE的工作流程。在通过构建文件运行测试之前，代码不应被开发人员视为完整。
- en: Fast Feedback
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速反馈
- en: Fast Feedback
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速反馈
- en: The Build File is Truth
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建文件是真实的
- en: The build script provides less-immediate feedback than the IDE because it must
    be explicitly triggered.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与IDE不同，构建脚本提供的反馈不太及时，因为必须显式触发它。
- en: 'Feedback from the build script has two major advantages, however:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，来自构建脚本的反馈有两个主要优点：
- en: It is repeatable across all machines
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在所有机器上都是可重复的
- en: With the aid of a CI server, you can ensure it is not ignored
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 借助CI服务器的帮助，您可以确保它不被忽视
- en: Because slower feedback is acceptable from the build script, a larger set of
    static and dynamic analysis can be run from here. This will usually include a
    repeat of your instant feedback.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构建脚本可以接受较慢的反馈，因此可以从这里运行更大量的静态和动态分析。这通常会包括重复您的即时反馈。
- en: Locally Runnable Tests
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可在本地运行的测试
- en: After the compiler and static analysis, the next fastest levels of feedback
    are the test suites.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译器和静态分析之后，测试套件是下一个最快速的反馈级别。
- en: At least two suites should be maintained that are runnable locally on any developer
    machine.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 应该维护至少两个可在任何开发人员机器上本地运行的套件。
- en: 'Because they are typically run immediately after compiling or before committing/pushing
    code, Martin Fowler refers to these as:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们通常在编译后立即运行或在提交/推送代码之前运行，Martin Fowler将这些称为：
- en: The compile suite
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译套件
- en: The commit suite
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交套件
- en: In Maven, these map naturally to the `test` and `integration-test` phases.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Maven中，这些自然映射到`test`和`integration-test`阶段。
- en: The criteria for a test being placed in the compile suite should, however, be
    more than **just** its execution speed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 放置在编译套件中的测试的标准应该不仅仅是**执行速度**。
- en: They must be fast (milliseconds or less per test) but must also be highly deterministic
    and repeatable. This ensures that the suite provides clean feedback - the only
    reason that a test should fail after a code change is if the change has caused
    regression.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Although this sounds simple, in practice it requires considerable rigor to ensure
    that tests cannot interfere with each other or be affected by external factors.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Tests in the commit suite may be slower and may also be slightly less repeatable.
    They should **aim** to be 100% repeatable but they may do things that carry the
    risk of occasionally causing a failure, like use network IO or write to disk.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Although many tests in this suite may do no more than launch code within the
    same JVM as the tests themselves, some of the tests should also launch the built
    artifact (war, ear, jar) and perform at least some degree of testing against it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Although the commit suite will likely depend on external resources such as containers,
    databases, queues, etc., it should still be runnable on any machine with a single
    command.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Installing and starting dependent resources should be handled automatically
    by the build scripts and tests - your project should not come with a page of notes
    on how to set up a development machine.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Commonly, the Maven Cargo plugin is used to download and configure containers
    for testing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Slower Feedback
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Slower Feedback
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both the compile suite and the commit suite should be run on a CI server, normally
    triggered by a commit/push to the repository.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the compile and commit suites, other suites should be created.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: These suites may require resources not available on a local machine and/or take
    large amounts of time to execute.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: They may also re-run the same tests against more realistic dependencies. If
    an in-memory database is normally used when running integration tests locally,
    the same tests might be run again against a production database.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: For a Maven build, these suites are likely to be implemented using profiles
    or as separate Maven modules.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: These suites will be run as frequently as possible. Most likely, this will mean
    on a timed basis because it is likely they will consume too much time to be run
    on commit. Here, "too much time" is defined as taking longer than the likely interval
    between commits/pushes to the monitored repository.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Timed test runs also sometimes run the suites when no code changes have occurred
    - this can provide useful information when identifying flaky tests.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Agree The Language You Use For Tests
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Agree the Language You Use When Discussing Tests
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Testing Pyramid
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, the language of testing is heavily overloaded, with different
    communities referring to different things by the same names.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The testing pyramid is a widely recognized diagram of how testing should be
    approached.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: It shows large numbers of unit tests at the bottom, with a smaller number of
    integration tests above them and a yet smaller number of system tests at the peak.
    Often, some clouds of manual testing are added at the top.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![The testing pyramid](pyramid.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: This diagram has probably been drawn thousands of times. Although unit tests
    will appear at the bottom of each version, the words used at the other levels
    will vary wildly.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Even when the same words are used the meanings attached to them might be different.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Although people might nod when you discuss "unit tests", "integration tests",
    "system tests", "end 2 end tests", "service tests", there is no guarantee that
    they are thinking of the same thing as you.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Depending on who you speak to, a "unit test" might be anything from a word document
    full of instructions, "any test written by a programmer", through to various formal
    (but by no means authoritative) definitions that appeared in text books.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The number of possible meanings of "integration test" is even greater.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Unit Tests
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A fairly tight definition of unit tests is now in common use in the Java community.
    We recommend that you and your team use this definition.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'To be a unit test, a test must be:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Fast (milliseconds or less)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolated (test only one unit)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeatable (able to be run millions of times on any machine with the same result)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self verifying (either passes or fails)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timely (written first)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: Although writing your tests first is often a very good idea, a test that
    meets the other criteria is still a unit test regardless of when it was written.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about "unit" testing, what constitutes a *unit* isn't necessarily
    that obvious.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: A somewhat circular definition is that a *unit* is the smallest thing that makes
    sense to test independently.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: It will often be a single class, but this is not necessarily the case. It may
    make sense to treat a group of classes as a unit (particularly if most of them
    are non-public) or occasionally even a method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: If we accept that a *unit* is a small thing, and that we'll know it when we
    see it, then we can see that the criteria for being a unit test largely matches
    the criteria we put forward for the compile suite.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The only difference is that the compile suite does not care about isolation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: If we choose to write a test that tests two (or more) *units* in tandem, it
    still belongs in the compile suite if it meets the other criteria.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: System Tests
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: System tests are also fairly well-defined. They are tests that exercise the
    overall system - i.e all your code and all the code it interacts with in a realistic
    environment.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Integration Tests
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Integration tests are harder to define. They occupy the large space of everything
    that doesn't fit the unit or system tests definitions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The two following diagrams show how this terminology fits into our world of
    test suites.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: This document will use the terminology *unit test*, *Integration test* and *System
    test* as shown in these diagrams.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: For clarity, it will sometimes state exactly what is being tested when discussing
    integration tests - e.g "test via the REST API of the war file running in Tomcat".
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Although it is tedious, this long-hand terminology is clear. It is recommended
    that you use it when discussing testing across teams. Within your own team it
    is likely you will develop a shorter language you all understand.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Properties of different test types](test_types.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: 'This maps to our suites as shown below:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![Test suites](test_types_maven.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: Use Coverage As A Tool Not A Target
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use Coverage as a Tool, not a Target
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Code coverage is a useful tool for catching your mistakes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The tool should work for you; you do not work for the tool.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: It is most useful when code coverage is run at the point at which the code and
    tests are being written, rather than on a CI server hours later.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Gaps in code coverage highlight areas of code that have not been tested. Some
    of these gaps may be expected and intentional, others may be a surprise. It is
    these surprise gaps that provide useful information.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: This is all that code coverage does.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Code that has 100% branch coverage may or may not have been tested. Code coverage
    tells you that some tests have executed the code, not that they have meaningfully
    tested it. Don't let it lull you into a false sense of security.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Some teams set coverage targets that code must meet (75% seems to be a common
    figure). Although well-intentioned, this practice is often damaging.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Code coverage is easy to measure. Other properties of tests that are desirable
    (or highly undesirable) are not easy to measure e.g.:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Is the test meaningful?
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the test easy to read and understand?
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the test tightly tied to a particular implementation?
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This last point is particularly important.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: For a test to be of value, it must enable refactoring; tests that are tied to
    one particular way of solving the problem often have negative value because they
    must be modified or rewritten whenever the code is changed. Unfortunately, it
    is easy to write tests in this way for a number of months or years before you
    realize you were doing it wrong.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: By concentrating on the one property that is easy to measure, the others are
    de-emphasized. But, much worse than this, trying to meet a coverage target can
    actively push developers towards writing tests that are tied to the implementation.
    Bad tests are easier to write than good tests.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: It is probably fair to say that there is a problem when code has only 30% unit
    test coverage. On the other hand, if coverage is achieved by setting a target,
    code with 80% coverage may be harder to work with than code with a lower figure.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: So don't set targets, instead make sure your team is committed to writing good
    tests.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: A good test is one which helps explains the code, catches regression and doesn't
    get in the way when changes are made. Writing the tests before the code can help
    encourage good tests and will ensure that code has high coverage.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
