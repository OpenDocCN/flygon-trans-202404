- en: Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code (good and bad) doesn't just appear from nowhere, someone needs to sit down
    and write it. How the coder approaches this task can influence the amount of time
    spent swearing at the code later.
  prefs: []
  type: TYPE_NORMAL
- en: This section looks at development philosophy, workflow, and other factors that
    teams should consider before starting to work together.
  prefs: []
  type: TYPE_NORMAL
- en: Build Fast Feedback Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Build Fast Feedback Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Good code is all about getting good and timely feedback. The sooner you find
    out something is wrong the easier it is to fix.
  prefs: []
  type: TYPE_NORMAL
- en: Working on a legacy project, where the only way to discover if a code change
    is good is to deploy it to a dev/test/qa environment, is frustrating and demoralizing.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure your project has a well designed development workflow - the effort
    of setting this up will be repaid many times over.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally all feedback would be instantaneous, but in practice it is either impractical
    or impossible to get all feedback this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead software development is organized as nested levels of feedback, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Development feedback cycles](feedback_cyclesncr.png)'
  prefs: []
  type: TYPE_IMG
- en: Instant Feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instant Feedback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A modern IDE such as Eclipse or IntelliJ will provide instant feedback as you
    type, using the underlying compiler and configurable static analysis tools.
  prefs: []
  type: TYPE_NORMAL
- en: You can increase the amount of instant feedback you receive by making good use
    of the Java type system and configuring the static analysis tools.
  prefs: []
  type: TYPE_NORMAL
- en: While feedback from the IDE is fast and convenient, it has some drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: It may differ from machine to machine depending on the IDE configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is often non binary (i.e. not pass/fail)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be ignored / overlooked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expectation of speed limits what it can achieve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For these reasons you should avoid purely IDE centric work flows. Code should
    not be considered complete by a developer until tests have been run via the build
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Fast Feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fast Feedback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Build File is Truth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The build script provides less-immediate feedback than the IDE because it must
    be explicitly triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feedback from the build script has two major advantages, however:'
  prefs: []
  type: TYPE_NORMAL
- en: It is repeatable across all machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the aid of a CI server, you can ensure it is not ignored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because slower feedback is acceptable from the build script, a larger set of
    static and dynamic analysis can be run from here. This will usually include a
    repeat of your instant feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Locally Runnable Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the compiler and static analysis, the next fastest levels of feedback
    are the test suites.
  prefs: []
  type: TYPE_NORMAL
- en: At least two suites should be maintained that are runnable locally on any developer
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because they are typically run immediately after compiling or before committing/pushing
    code, Martin Fowler refers to these as:'
  prefs: []
  type: TYPE_NORMAL
- en: The compile suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The commit suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Maven, these map naturally to the `test` and `integration-test` phases.
  prefs: []
  type: TYPE_NORMAL
- en: The criteria for a test being placed in the compile suite should, however, be
    more than **just** its execution speed.
  prefs: []
  type: TYPE_NORMAL
- en: They must be fast (milliseconds or less per test) but must also be highly deterministic
    and repeatable. This ensures that the suite provides clean feedback - the only
    reason that a test should fail after a code change is if the change has caused
    regression.
  prefs: []
  type: TYPE_NORMAL
- en: Although this sounds simple, in practice it requires considerable rigor to ensure
    that tests cannot interfere with each other or be affected by external factors.
  prefs: []
  type: TYPE_NORMAL
- en: Tests in the commit suite may be slower and may also be slightly less repeatable.
    They should **aim** to be 100% repeatable but they may do things that carry the
    risk of occasionally causing a failure, like use network IO or write to disk.
  prefs: []
  type: TYPE_NORMAL
- en: Although many tests in this suite may do no more than launch code within the
    same JVM as the tests themselves, some of the tests should also launch the built
    artifact (war, ear, jar) and perform at least some degree of testing against it.
  prefs: []
  type: TYPE_NORMAL
- en: Although the commit suite will likely depend on external resources such as containers,
    databases, queues, etc., it should still be runnable on any machine with a single
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and starting dependent resources should be handled automatically
    by the build scripts and tests - your project should not come with a page of notes
    on how to set up a development machine.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly, the Maven Cargo plugin is used to download and configure containers
    for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Slower Feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Slower Feedback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both the compile suite and the commit suite should be run on a CI server, normally
    triggered by a commit/push to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the compile and commit suites, other suites should be created.
  prefs: []
  type: TYPE_NORMAL
- en: These suites may require resources not available on a local machine and/or take
    large amounts of time to execute.
  prefs: []
  type: TYPE_NORMAL
- en: They may also re-run the same tests against more realistic dependencies. If
    an in-memory database is normally used when running integration tests locally,
    the same tests might be run again against a production database.
  prefs: []
  type: TYPE_NORMAL
- en: For a Maven build, these suites are likely to be implemented using profiles
    or as separate Maven modules.
  prefs: []
  type: TYPE_NORMAL
- en: These suites will be run as frequently as possible. Most likely, this will mean
    on a timed basis because it is likely they will consume too much time to be run
    on commit. Here, "too much time" is defined as taking longer than the likely interval
    between commits/pushes to the monitored repository.
  prefs: []
  type: TYPE_NORMAL
- en: Timed test runs also sometimes run the suites when no code changes have occurred
    - this can provide useful information when identifying flaky tests.
  prefs: []
  type: TYPE_NORMAL
- en: Agree The Language You Use For Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Agree the Language You Use When Discussing Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Testing Pyramid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, the language of testing is heavily overloaded, with different
    communities referring to different things by the same names.
  prefs: []
  type: TYPE_NORMAL
- en: The testing pyramid is a widely recognized diagram of how testing should be
    approached.
  prefs: []
  type: TYPE_NORMAL
- en: It shows large numbers of unit tests at the bottom, with a smaller number of
    integration tests above them and a yet smaller number of system tests at the peak.
    Often, some clouds of manual testing are added at the top.
  prefs: []
  type: TYPE_NORMAL
- en: '![The testing pyramid](pyramid.png)'
  prefs: []
  type: TYPE_IMG
- en: This diagram has probably been drawn thousands of times. Although unit tests
    will appear at the bottom of each version, the words used at the other levels
    will vary wildly.
  prefs: []
  type: TYPE_NORMAL
- en: Even when the same words are used the meanings attached to them might be different.
  prefs: []
  type: TYPE_NORMAL
- en: Although people might nod when you discuss "unit tests", "integration tests",
    "system tests", "end 2 end tests", "service tests", there is no guarantee that
    they are thinking of the same thing as you.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on who you speak to, a "unit test" might be anything from a word document
    full of instructions, "any test written by a programmer", through to various formal
    (but by no means authoritative) definitions that appeared in text books.
  prefs: []
  type: TYPE_NORMAL
- en: The number of possible meanings of "integration test" is even greater.
  prefs: []
  type: TYPE_NORMAL
- en: Unit Tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A fairly tight definition of unit tests is now in common use in the Java community.
    We recommend that you and your team use this definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be a unit test, a test must be:'
  prefs: []
  type: TYPE_NORMAL
- en: Fast (milliseconds or less)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolated (test only one unit)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeatable (able to be run millions of times on any machine with the same result)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self verifying (either passes or fails)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timely (written first)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: Although writing your tests first is often a very good idea, a test that
    meets the other criteria is still a unit test regardless of when it was written.'
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about "unit" testing, what constitutes a *unit* isn't necessarily
    that obvious.
  prefs: []
  type: TYPE_NORMAL
- en: A somewhat circular definition is that a *unit* is the smallest thing that makes
    sense to test independently.
  prefs: []
  type: TYPE_NORMAL
- en: It will often be a single class, but this is not necessarily the case. It may
    make sense to treat a group of classes as a unit (particularly if most of them
    are non-public) or occasionally even a method.
  prefs: []
  type: TYPE_NORMAL
- en: If we accept that a *unit* is a small thing, and that we'll know it when we
    see it, then we can see that the criteria for being a unit test largely matches
    the criteria we put forward for the compile suite.
  prefs: []
  type: TYPE_NORMAL
- en: The only difference is that the compile suite does not care about isolation.
  prefs: []
  type: TYPE_NORMAL
- en: If we choose to write a test that tests two (or more) *units* in tandem, it
    still belongs in the compile suite if it meets the other criteria.
  prefs: []
  type: TYPE_NORMAL
- en: System Tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: System tests are also fairly well-defined. They are tests that exercise the
    overall system - i.e all your code and all the code it interacts with in a realistic
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Integration Tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Integration tests are harder to define. They occupy the large space of everything
    that doesn't fit the unit or system tests definitions.
  prefs: []
  type: TYPE_NORMAL
- en: The two following diagrams show how this terminology fits into our world of
    test suites.
  prefs: []
  type: TYPE_NORMAL
- en: This document will use the terminology *unit test*, *Integration test* and *System
    test* as shown in these diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: For clarity, it will sometimes state exactly what is being tested when discussing
    integration tests - e.g "test via the REST API of the war file running in Tomcat".
  prefs: []
  type: TYPE_NORMAL
- en: Although it is tedious, this long-hand terminology is clear. It is recommended
    that you use it when discussing testing across teams. Within your own team it
    is likely you will develop a shorter language you all understand.
  prefs: []
  type: TYPE_NORMAL
- en: '![Properties of different test types](test_types.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This maps to our suites as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Test suites](test_types_maven.png)'
  prefs: []
  type: TYPE_IMG
- en: Use Coverage As A Tool Not A Target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use Coverage as a Tool, not a Target
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Code coverage is a useful tool for catching your mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: The tool should work for you; you do not work for the tool.
  prefs: []
  type: TYPE_NORMAL
- en: It is most useful when code coverage is run at the point at which the code and
    tests are being written, rather than on a CI server hours later.
  prefs: []
  type: TYPE_NORMAL
- en: Gaps in code coverage highlight areas of code that have not been tested. Some
    of these gaps may be expected and intentional, others may be a surprise. It is
    these surprise gaps that provide useful information.
  prefs: []
  type: TYPE_NORMAL
- en: This is all that code coverage does.
  prefs: []
  type: TYPE_NORMAL
- en: Code that has 100% branch coverage may or may not have been tested. Code coverage
    tells you that some tests have executed the code, not that they have meaningfully
    tested it. Don't let it lull you into a false sense of security.
  prefs: []
  type: TYPE_NORMAL
- en: Some teams set coverage targets that code must meet (75% seems to be a common
    figure). Although well-intentioned, this practice is often damaging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code coverage is easy to measure. Other properties of tests that are desirable
    (or highly undesirable) are not easy to measure e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the test meaningful?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the test easy to read and understand?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the test tightly tied to a particular implementation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This last point is particularly important.
  prefs: []
  type: TYPE_NORMAL
- en: For a test to be of value, it must enable refactoring; tests that are tied to
    one particular way of solving the problem often have negative value because they
    must be modified or rewritten whenever the code is changed. Unfortunately, it
    is easy to write tests in this way for a number of months or years before you
    realize you were doing it wrong.
  prefs: []
  type: TYPE_NORMAL
- en: By concentrating on the one property that is easy to measure, the others are
    de-emphasized. But, much worse than this, trying to meet a coverage target can
    actively push developers towards writing tests that are tied to the implementation.
    Bad tests are easier to write than good tests.
  prefs: []
  type: TYPE_NORMAL
- en: It is probably fair to say that there is a problem when code has only 30% unit
    test coverage. On the other hand, if coverage is achieved by setting a target,
    code with 80% coverage may be harder to work with than code with a lower figure.
  prefs: []
  type: TYPE_NORMAL
- en: So don't set targets, instead make sure your team is committed to writing good
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: A good test is one which helps explains the code, catches regression and doesn't
    get in the way when changes are made. Writing the tests before the code can help
    encourage good tests and will ensure that code has high coverage.
  prefs: []
  type: TYPE_NORMAL
