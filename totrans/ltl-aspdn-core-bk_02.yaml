- en: MVC basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MVC basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you'll explore the MVC system in ASP.NET Core. **MVC** (Model-View-Controller)
    is a pattern for building web applications that's used in almost every web framework
    (Ruby on Rails and Express are popular examples), as well as frontend JavaScript
    frameworks like Angular. Mobile apps on iOS and Android use a variation of MVC
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name suggests, MVC has three components: models, views, and controllers.
    **Controllers** handle incoming requests from a client or web browser and make
    decisions about what code to run. **Views** are templates (usually HTML plus some
    templating language like Handlebars, Pug, or Razor) that get data added to them
    and then are displayed to the user. **Models** hold the data that is added to
    views, or data that is entered by the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A common pattern for MVC code is:'
  prefs: []
  type: TYPE_NORMAL
- en: The controller receives a request and looks up some information in a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The controller creates a model with the information and attaches it to a view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The view is rendered and displayed in the user's browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user clicks a button or submits a form, which sends a new request to the
    controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you've worked with MVC in other languages, you'll feel right at home in ASP.NET
    Core MVC. If you're new to MVC, this chapter will teach you the basics and will
    help get you started.
  prefs: []
  type: TYPE_NORMAL
- en: What you'll build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The "Hello World" exercise of MVC is building a to-do list application. It's
    a great project since it's small and simple in scope, but it touches each part
    of MVC and covers many of the concepts you'd use in a larger application.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, you'll build a to-do app that lets the user add items to their
    to-do list and check them off once complete. You'll build the server (the "backend")
    using ASP.NET Core, C#, and the MVC pattern. You'll use HTML, CSS, and JavaScript
    in the views (also called the "frontend").
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't already created a new ASP.NET Core project using `dotnet new
    mvc`, follow the steps in the previous chapter. You should be able to build and
    run the project and see the default welcome screen.
  prefs: []
  type: TYPE_NORMAL
- en: Create a controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are already a few controllers in the project's Controllers folder, including
    the `HomeController` that renders the default welcome screen you see when you
    visit `http://localhost:5000`. You can ignore these controllers for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new controller for the to-do list functionality, called `TodoController`,
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Controllers/TodoController.cs`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Routes that are handled by controllers are called **actions**, and are represented
    by methods in the controller class. For example, the `HomeController` includes
    three action methods (`Index`, `About`, and `Contact`) which are mapped by ASP.NET
    Core to these route URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of conventions (common patterns) used by ASP.NET Core, such
    as the pattern that `FooController` becomes `/Foo`, and the `Index` action name
    can be left out of the URL. You can customize this behavior if you'd like, but
    for now, we'll stick to the default conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new action called `Index` to the `TodoController`, replacing the `//
    Actions go here` comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Action methods can return views, JSON data, or HTTP status codes like `200 OK`
    or `404 Not Found`. The `IActionResult` return type gives you the flexibility
    to return any of these from the action.
  prefs: []
  type: TYPE_NORMAL
- en: It's a best practice to keep controllers as lightweight as possible. In this
    case, the controller should only be responsible for getting the to-do items from
    the database, putting those items into a model the view can understand, and sending
    the view back to the user's browser.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can write the rest of the controller code, you need to create a model
    and a view.
  prefs: []
  type: TYPE_NORMAL
- en: Create models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two separate model classes that need to be created: a model that
    represents a to-do item stored in the database (sometimes called an **entity**),
    and the model that will be combined with a view (the **MV** in MVC) and sent back
    to the user''s browser. Because both of them can be referred to as "models", I''ll
    refer to the latter as a *view model*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a class called `TodoItem` in the Models directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Models/TodoItem.cs`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This class defines what the database will need to store for each to-do item:
    an ID, a title or name, whether the item is complete, and what the due date is.
    Each line defines a property of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Id** property is a guid, or a **g**lobally **u**nique **id**entifier.
    Guids (or GUIDs) are long strings of letters and numbers, like `43ec09f2-7f70-4f4b-9559-65011d5781bb`.
    Because guids are random and are extremely unlikely to be accidentally duplicated,
    they are commonly used as unique IDs. You could also use a number (integer) as
    a database entity ID, but you'd need to configure your database to always increment
    the number when new rows are added to the database. Guids are generated randomly,
    so you don't have to worry about auto-incrementing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **IsDone** property is a boolean (true/false value). By default, it will
    be `false` for all new items. Later you'll use write code to switch this property
    to `true` when the user clicks the item's checkbox in the view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Title** property is a string. This will hold the name or description of
    the to-do item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **DueAt** property is a `DateTimeOffset`, which is a C# type that stores
    a date/time stamp along with a timezone offset from UTC. Storing the date, time,
    and timezone offset together makes it easy to render dates accurately on systems
    in different timezones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice the `?` question mark after the `DateTimeOffset` type? That marks the
    DueAt property as *nullable*, or optional. If the `?` wasn't included, every to-do
    item would need to have a due date. The Id and IsDone properties aren't marked
    as nullable, so they are required and will always have a value (or a default value).
  prefs: []
  type: TYPE_NORMAL
- en: Strings in C# are always nullable, so there's no need to mark the Title property
    as nullable. C# strings can be null, empty, or contain text.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Each property is followed by `get; set;`, which is a shorthand way of saying
    the property is read/write (or more technically, it has a getter and setter methods).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it doesn't matter what the underlying database technology is.
    It could be SQL Server, MySQL, MongoDB, Redis, or something more exotic. This
    model defines what the database row or entry will look like in C# so you don't
    have to worry about the low-level database stuff in your code. This simple style
    of model is sometimes called a "plain old C# object" or POCO.
  prefs: []
  type: TYPE_NORMAL
- en: The view model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, the model (entity) you store in the database is similar but not *exactly*
    the same as the model you want to use in MVC (the view model). In this case, the
    `TodoItem` model represents a single item in the database, but the view might
    need to display two, ten, or a hundred to-do items (depending on how badly the
    user is procrastinating).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this, the view model should be a separate class that holds an array
    of `TodoItem`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Models/TodoViewModel.cs`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`IEnumerable<>` is a fancy C# way of saying that the `Items` property contains
    zero, one, or many `TodoItem`s. (In technical terms, it''s not quite an array,
    but rather an array-like interface for any sequence that can be enumerated or
    iterated over.)'
  prefs: []
  type: TYPE_NORMAL
- en: The `IEnumerable<>` interface exists in the `System.Collections.Generic` namespace,
    so you need a `using System.Collections.Generic` statement at the top of the file.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that you have some models, it's time to create a view that will take a `TodoViewModel`
    and render the right HTML to show the user their to-do list.
  prefs: []
  type: TYPE_NORMAL
- en: Create a view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Views in ASP.NET Core are built using the Razor templating language, which combines
    HTML and C# code. (If you've written pages using Jade/Pug or Handlebars moustaches
    in JavaScript, ERB in Ruby on Rails, or Thymeleaf in Java, you've already got
    the basic idea.)
  prefs: []
  type: TYPE_NORMAL
- en: Most view code is just HTML, with the occasional C# statement added in to pull
    data out of the view model and turn it into text or HTML. The C# statements are
    prefixed with the `@` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: The view rendered by the `Index` action of the `TodoController` needs to take
    the data in the view model (an array of to-do items) and display it as a nice
    table for the user. By convention, views are placed in the `Views` directory,
    in a subdirectory corresponding to the controller name. The file name of the view
    is the name of the action with a `.cshtml` extension.
  prefs: []
  type: TYPE_NORMAL
- en: '**`Views/Todo/Index.cshtml`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: At the very top of the file, the `@model` directive tells Razor which model
    to expect this view to be bound to. The model is accessed through the `Model`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming there are any to-do items in `Model.Items`, the `foreach` statement
    will loop over each to-do item and render a table row (`<tr>` element) containing
    the item's name and due date. A checkbox is also rendered that contains the item's
    ID, which you'll use later to mark the item as completed.
  prefs: []
  type: TYPE_NORMAL
- en: The layout file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might be wondering where the rest of the HTML is: what about the `<body>`
    tag, or the header and footer of the page? ASP.NET Core uses a layout view that
    defines the base structure that the rest of the views are rendered inside of.
    It''s stored in `Views/Shared/_Layout.cshtml`.'
  prefs: []
  type: TYPE_NORMAL
- en: The default ASP.NET Core template includes Bootstrap and jQuery in this layout
    file, so you can quickly create a web application. Of course, you can use your
    own CSS and JavaScript libraries if you'd like.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the stylesheet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For now, just add these CSS style rules to the bottom of the `site.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`wwwroot/css/site.css`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can use CSS rules like these to completely customize how your pages look
    and feel.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core and Razor can do much more, such as partial views and server-rendered
    view components, but a simple layout and view is all you need for now. The official
    ASP.NET Core documentation (at `https://docs.asp.net`) contains a number of examples
    if you'd like to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Add a service class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add a service class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You've created a model, a view, and a controller. Before you use the model and
    view in the controller, you also need to write code that will get the user's to-do
    items from a database.
  prefs: []
  type: TYPE_NORMAL
- en: You could write this database code directly in the controller, but it's a better
    practice to keep all the database code in a separate class called a **service**.
    This helps keep the controller as simple as possible, and makes it easier to test
    and change the database code later.
  prefs: []
  type: TYPE_NORMAL
- en: Separating your application logic into one layer that handles database access
    and another layer that handles presenting a view is sometimes called a layered,
    3-tier, or n-tier architecture.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: .NET and C# include the concept of **interfaces**, where the definition of an
    object's methods and properties is separate from the class that actually contains
    the code for those methods and properties. Interfaces make it easy to keep your
    classes decoupled and easy to test, as you'll see here (and later in the *Automated
    testing* chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create an interface that will represent the service that can interact
    with to-do items in the database. By convention, interfaces are prefixed with
    "I". Create a new file in the Services directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Services/ITodoItemService.cs`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that the namespace of this file is `AspNetCoreTodo.Services`. Namespaces
    are a way to organize .NET code files, and it's customary for the namespace to
    follow the directory the file is stored in (`AspNetCoreTodo.Services` for files
    in the `Services` directory, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this file (in the `AspNetCoreTodo.Services` namespace) references the
    `TodoItem` class (in the `AspNetCoreTodo.Models` namespace), it needs to include
    a `using` statement at the top of the file to import that namespace. Without the
    `using` statement, you''ll see an error like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since this is an interface, there isn't any actual code here, just the definition
    (or **method signature**) of the `GetIncompleteItemsAsync` method. This method
    requires no parameters and returns a `Task<IEnumerable<TodoItem>>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this syntax looks confusing, think: "a Task that contains a list of TodoItems".'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `Task` type is similar to a future or a promise, and it's used here because
    this method will be **asynchronous**. In other words, the method may not be able
    to return the list of to-do items right away because it needs to go talk to the
    database first. (More on this later.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the interface is defined, you''re ready to create the actual service
    class. I''ll cover database code in depth in the *Use a database* chapter, but
    for now you''ll just fake it and return hard-coded values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Services/FakeTodoItemService.cs`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This `FakeTodoItemService` implements the `ITodoItemService` interface but always
    returns the same array of two `TodoItem`s. You'll use this to test the controller
    and view, and then add real database code in *Use a database*.
  prefs: []
  type: TYPE_NORMAL
- en: Use dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use dependency injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back in the `TodoController`, add some code to work with the `ITodoItemService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `ITodoItemService` is in the `Services` namespace, you''ll also need
    to add a `using` statement at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the class declares a private variable to hold a reference
    to the `ITodoItemService`. This variable lets you use the service from the `Index`
    action method later (you'll see how in a minute).
  prefs: []
  type: TYPE_NORMAL
- en: The `public TodoController(ITodoItemService todoItemService)` line defines a
    **constructor** for the class. The constructor is a special method that is called
    when you want to create a new instance of a class (the `TodoController` class,
    in this case). By adding an `ITodoItemService` parameter to the constructor, you've
    declared that in order to create the `TodoController`, you'll need to provide
    an object that matches the `ITodoItemService` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces are awesome because they help decouple (separate) the logic of your
    application. Since the controller depends on the `ITodoItemService` interface,
    and not on any *specific* service class, it doesn't know or care which class it's
    actually given. It could be the `FakeTodoItemService`, a different one that talks
    to a live database, or something else! As long as it matches the interface, the
    controller doesn't care. This makes it really easy to test parts of your application
    separately. (I'll cover testing more in the *Automated testing* chapter.)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now you can finally use the `ITodoItemService` (via the private variable you
    declared) in your action method to get to-do items from the service layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the `GetIncompleteItemsAsync` method returned a `Task<IEnumerable<TodoItem>>`?
    Returning a `Task` means that the method won't necessarily have a result right
    away, but you can use the `await` keyword to make sure your code waits until the
    result is ready before continuing on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Task` pattern is common when your code calls out to a database or an API
    service, because it won''t be able to return a real result until the database
    (or network) responds. If you''ve used promises or callbacks in JavaScript or
    other languages, `Task` is the same idea: the promise that there will be a result
    - sometime in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: If you've had to deal with "callback hell" in older JavaScript code, you're
    in luck. Dealing with asynchronous code in .NET is much easier thanks to the magic
    of the `await` keyword! `await` lets your code pause on an async operation, and
    then pick up where it left off when the underlying database or network request
    finishes. In the meantime, your application isn't blocked, because it can process
    other requests as needed. This pattern is simple but takes a little getting used
    to, so don't worry if this doesn't make sense right away. Just keep following
    along!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The only catch is that you need to update the `Index` method signature to return
    a `Task<IActionResult>` instead of just `IActionResult`, and mark it as `async`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You're almost there! You've made the `TodoController` depend on the `ITodoItemService`
    interface, but you haven't yet told ASP.NET Core that you want the `FakeTodoItemService`
    to be the actual service that's used under the hood. It might seem obvious right
    now since you only have one class that implements `ITodoItemService`, but later
    you'll have multiple classes that implement the same interface, so being explicit
    is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring (or "wiring up") which concrete class to use for each interface is
    done in the `ConfigureServices` method of the `Startup` class. Right now, it looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Startup.cs**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The job of the `ConfigureServices` method is adding things to the **service
    container**, or the collection of services that ASP.NET Core knows about. The
    `services.AddMvc` line adds the services that the internal ASP.NET Core systems
    need (as an experiment, try commenting out this line). Any other services you
    want to use in your application must be added to the service container here in
    `ConfigureServices`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line anywhere inside the `ConfigureServices` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This line tells ASP.NET Core to use the `FakeTodoItemService` whenever the `ITodoItemService`
    interface is requested in a constructor (or anywhere else).
  prefs: []
  type: TYPE_NORMAL
- en: '`AddSingleton` adds your service to the service container as a **singleton**.
    This means that only one copy of the `FakeTodoItemService` is created, and it''s
    reused whenever the service is requested. Later, when you write a different service
    class that talks to a database, you''ll use a different approach (called **scoped**)
    instead. I''ll explain why in the *Use a database* chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: That's it! When a request comes in and is routed to the `TodoController`, ASP.NET
    Core will look at the available services and automatically supply the `FakeTodoItemService`
    when the controller asks for an `ITodoItemService`. Because the services the controller
    depends on are "injected" from the service container, this pattern is called **dependency
    injection**.
  prefs: []
  type: TYPE_NORMAL
- en: Finish the controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finish the controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last step is to finish the controller code. The controller now has a list
    of to-do items from the service layer, and it needs to put those items into a
    `TodoViewModel` and bind that model to the view you created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Controllers/TodoController.cs`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you haven''t already, make sure these `using` statements are at the top
    of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you're using Visual Studio or Visual Studio Code, the editor will suggest
    these `using` statements when you put your cursor on a red squiggly line.
  prefs: []
  type: TYPE_NORMAL
- en: Test it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start the application, press F5 (if you're using Visual Studio or Visual
    Studio Code), or just run `dotnet run` in the terminal. If the code compiles without
    errors, the server will spin up on port 5000 by default.
  prefs: []
  type: TYPE_NORMAL
- en: If your web browser didn't open automatically, open it and navigate to [http://localhost:5000/todo](http://localhost:5000/todo).
    You'll see the view you created, with the data pulled from your fake database
    layer (for now).
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You've built a working ASP.NET Core application. Next, you'll
    take it further with third-party packages and real database code.
  prefs: []
  type: TYPE_NORMAL
