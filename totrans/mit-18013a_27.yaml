- en: 'Chapter 26: Numerical Solution of Differential Equations'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第26章：微分方程的数值解
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简介
- en: You can employ techniques like Simpson's Rule to solve numerical solutions to
    more general first order differential equations. We explore how.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用辛普森法则等技术来解决更一般的一阶微分方程的数值解。我们来探讨一下��
- en: Topics
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主题
- en: 26.1  [Introduction to Differential Equations](section01.html)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 26.1  [微分方程简介](section01.html)
- en: 26.2  [The Left Hand Rule with Extrapolation](section02.html)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 26.2  [左手法则与外推法](section02.html)
- en: 26.3  [Generalization of the Trapezoid Rule](section03.html)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 26.3  [梯形法则的泛化](section03.html)
- en: 26.4  [Generalization of Simpson's Rule; the Runge-Kutta 2^(th) Order Rule](section04.html)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 26.4  [辛普森法则的泛化；龙格-库塔 2^(th) 阶法则](section04.html)
- en: 26.5  [Comments](section05.html)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 26.5  [评论](section05.html)
- en: 26.1 Introduction to Differential Equations
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 26.1 微分方程简介
- en: A **differential equation** is an equation involving derivatives. **The order**
    of the equation is the highest derivative occurring in the equation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**微分方程**是涉及导数的方程。**方程的阶数**是方程中出现的最高阶导数。'
- en: Here are some examples
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子
- en: '![](../Images/c8a242ce86c8c3d7110af030df531869.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c8a242ce86c8c3d7110af030df531869.jpg)'
- en: The first four of these are **first order** differential equations, the last
    is a **second order** equation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这前四个是**一阶**微分方程，最后一个是**二阶**方程。
- en: The first two are called linear differential equations because they are **linear**
    in the variable y, the first has an **"inhomogeneous term"** that is independent
    of y on the right, the second is a **homogeneous linear equation** since all terms
    are linear in y.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个被称为线性微分方程，因为它们在变量 y 中是**线性**的，第一个有一个右侧与 y 无关的**“非齐次项”**，第二个是**齐次线性方程**，因为所有项在
    y 中都是线性的。
- en: The first three of these are **"separable"** differential equations, since they
    can be rewritten as dx f(x) = dy g(y) for appropriate f and g.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这前三个是**“可分离的”**微分方程，因为它们可以重写为 dx f(x) = dy g(y)，其中 f 和 g 适当。
- en: If you know only the derivative of a function, you do not have enough information
    to determine it completely. You can therefore seek either **a solution** to a
    differential equation, or **a general solution** (which usually has a constant
    for each order of the equation in it) or **a solution subject to some additional
    condition or conditions.**
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只知道一个函数的导数，那么你没有足够的信息来完全确定它。因此，你可以寻找**微分方程的解**，或者**一般解**（通常每个方程阶数中都有一个常数），或者**在一些额外条件下的解**。
- en: You can find the general solution to any **separable first order** differential
    equation by integration, (or as it is sometimes referred to, by **"quadrature"**).
    All you need do is to integrate both sides of the equation dx f(x) = dy g(y).
    Thus you can apply the numerical techniques of the previous chapter to each of
    these directly and solve them numerically, if you cannot integrate them exactly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过积分找到任何**可分离的一阶**微分方程的一般解，（有时也称为**“求积法”**）。你只需对方程的两边进行积分 dx f(x) = dy g(y)。因此，如果无法精确积分，你可以直接将前一章的数值技术应用于每个方程，并对其进行数值求解。
- en: 'The question we address here is:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里要讨论的问题是：
- en: Suppose we have a **first order differential equation that is not separable,**
    so we cannot reduce its solution to quadratures directly. Can we apply the numerical
    techniques previously for doing integrals to the task of solving these equations?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个**不可分离的一阶微分方程**，因此我们无法直接将其解决为求积。我们能否将以前用于积分的数值技术应用于解决这些方程的任务？
- en: The answer is yes and we show how below. There is indeed a complication which
    we discuss next, but it can be overcome.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的，我们将在下面展示如何。确实有一个我们接下来会讨论的复杂性，但可以克服。
- en: The implication of this fact is, that any system whose behavior can be modeled
    by a first order differential equation, or even by a set of linked first order
    equations, can be solved numerically to any desired accuracy by a modern computer
    very quickly. This makes possible real time control of such systems and is of
    great value in engineering.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实的含义是，任何行为可以由一阶微分方程或甚至一组相关的一阶方程建模的系统，都可以通过现代计算机迅速数值解决到任何所需的精度。这使得这些系统的实时控制成为可能，并在工程领域具有巨大价值。
- en: 26.2 The Left Hand Rule with Extrapolation
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 26.2 左手法则与外推法
- en: We seek the solution of a **first order differential equation** of the form
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们寻求形式为**一阶微分方程**的解
- en: '![](../Images/6a989a64a2064b24aab0c57323a49309.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6a989a64a2064b24aab0c57323a49309.jpg)'
- en: and we will assume that **we know y(a)** and wish to find y(x) for arguments
    between a and b, and in particular **want to find y(b).**
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设**我们知道 y(a)** 并希望找到 a 和 b 之间的参数 x 的 y，特别是**想要找到 y(b)。**
- en: We consider the example
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑以下例子
- en: '![](../Images/317df2ee6c8de480f49017e7d957339f.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/317df2ee6c8de480f49017e7d957339f.jpg)'
- en: below with a = 0, b = 1 or 2 and y(0) = 1, to illustrate the methods discussed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 a = 0，b = 1 或 2 以及 y(0) = 1 的情况下，用来说明所讨论的方法。
- en: '**We want to break up the interval [a, b] into small subintervals, each of
    length d and for each subinterval approximate the change in y by an estimate of
    ![](../Images/60535789e5b27c8127497ae6f289ce70.jpg) in it, multiplied by d.**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们希望将区间 [a, b] 分成长度为 d 的小子区间，对于每个子区间，通过对其中的![](../Images/60535789e5b27c8127497ae6f289ce70.jpg)
    的估计乘以 d 来近似 y 的变化。**'
- en: With ordinary integration we had many different ways of estimating f, **a left
    rule, right rule, trapezoid rule, or Simpson rule, and others as well,** based
    upon using the values of f at various arguments within the subinterval.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用普通积分时，我们有很多不同的估计 f 的方法，**左规则、右规则、梯形规则或辛普森规则，以及其他方法，** 这些方法是基于在子区间内使用 f 在各个参数处的值。
- en: The complication here is that we do not know the value of y anywhere but at
    the point a, or more generally, we can only expect to have an approximate value
    for y at the left hand side of our subinterval based upon our computations on
    previous subintervals. In fact the purpose of our treatment of that subinterval
    is to extend our estimate of y on its left end to an estimate of y on its right
    end.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的复杂性在于我们除了在点 a 处不知道 y 的值外，在任何地方都不知道 y 的值，或者更一般地说，我们只能根据在以前的子区间上的计算来期望在子区间的左侧有
    y 的近似值。实际上，我们对该子区间的处理的目的是将我们对其左端点上 y 的估计扩展到对其右端点上 y 的估计。
- en: In consequence of this fact, we have to use some procedure for estimating y
    in the subinterval in order to apply any of the previous techniques other than
    the left hand rule.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个事实，我们必须使用一些程序来估计子区间中的 y，以便应用左手法则之外的任何以前的技术。
- en: 'This complication does not affect **the left hand rule;** so we first ask,
    **how can we apply that rule?** And then: **is it possible to get an accurate
    numerical solution by use of the left hand rule?** The left hand rule discovered
    by Euler and others, consists of making the estimate for the change in y over
    the interval x to x + d'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个复杂性不影响**左手法则**；所以我们首先问，**我们如何应用那个规则？** 然后：**使用左手法则是否可能得到准确的数值解？** 欧拉和其他人发现的左手法则，包括对区间
    x 到 x + d 的 y 变化进行估计。
- en: '**y(x + d) - y(x) = f(x, y(x))*d**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**y(x + d) - y(x) = f(x, y(x))*d**'
- en: and successively applying it to each subinterval between a and b to compute
    y(a + j*d) successively for each j and compute ultimately y(b). It involves computing
    the change in y over each interval by using the value of x and y obtained previously
    at the left end of the interval in f(x, y).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 并且依次将其应用于 a 和 b 之间的每个子区间，以计算每个 j 下的 y(a + j*d) 并最终计算出 y(b)。它涉及在 f(x, y) 中使用前一个子区间左端点处获得的
    x 和 y 的值来计算每个区间内的 y 的变化。
- en: This method has the virtue that it is extremely easy to implement on a spreadsheet.
    It has the defect that it is not very accurate. It is asymmetric between the endpoints
    of each subinterval, and as a result, **if you decrease d by a factor of two,
    the leading error term goes down by a factor of two.** As a consequence, to improve
    accuracy by a factor of 1000 you have to reduce d by a factor of 1000, and that
    is not an efficient way to solve such differential equations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是在电子表格上实现非常容易。它的缺点是不太准确。它在每个子区间的端点之间是不对称的，因此，**如果你将 d 减小一半，那么主导误差项也会减小一半。**
    结果，要将准确性提高 1000 倍，你必须将 d 减小 1000 倍，而这并不是解决这类微分方程的有效方法。
- en: The following instructions implement this rule for f(x, y) when the last row
    here is copied or filled down N - 1 rows. These are columns A, B, C and D and
    rows 1-9.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的指令实现了当此处的最后一行被复制或向下填充 N - 1 行时，用于 f(x, y) 的此规则。这些是 A、B、C 和 D 列，以及 1-9 行。
- en: To switch to a different differential equation you need only change the D9 entry
    appropriately and copy the results down.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换到不同的微分方程，你只需要适当地更改 D9 条目并将结果复制下来。
- en: '| A | B | C | D | 1=row number |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| A | B | C | D | 1=row number |'
- en: '| Left Hand Rule |   |   | f(x,y)=x+y | 2 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 左手法则 |   |   | f(x,y)=x+y | 2 |'
- en: '| enter a | 0 |   |   | 3 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 输入 a | 0 |   |   | 3 |'
- en: '| enter b | 1 |   |   | 4 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 输入 b | 1 |   |   | 4 |'
- en: '| enter N | 64 |   |   | 5 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 输入 N | 64 |   |   | 5 |'
- en: '| enter y(a) | 1 |   |   | 6 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 输入 y(a) | 1 |   |   | 6 |'
- en: '| d | =(B4-B3)/B5 | � |   | 7 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| d | =(B4-B3)/B5 | � |   | 7 |'
- en: '| interval index | X | Y | f(x,y) | 8 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 区间索引 | X | Y | f(x,y) | 8 |'
- en: '| 0 | =B3 | =B6 | =B9+C9 | 9 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 0 | =B3 | =B6 | =B9+C9 | 9 |'
- en: '| =A9+1 | =B9+$B$7 | =C9+(B10-B9)*D9 | =B10+C10 | 10 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| =A9+1 | =B9+$B$7 | =C9+(B10-B9)*D9 | =B10+C10 | 10 |'
- en: The interval index plays no role here and is included only to allow convenient
    checking that you have enough rows for your computation. (You could omit it.)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里间隔索引无关紧要，仅用于方便检查您的计算是否有足够的行。 （您可以省略它。）
- en: '**We can use extrapolation to improve performance here,** just as we used it
    for numerical differentiation in [Chapter 7](../chapter07/contents.html) and for
    numerical integration in the last previous chapter.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们可以利用外推法来提高这里的性能，** 就像我们在[第7章](../chapter07/contents.html)中用于数值微分以及在上一章中用于数值积分一样。'
- en: Suppose we characterize our subdivision of the interval [a, b] by the number
    of subintervals N. Let us refer to the result of applying the left hand rule here
    as just described as L(N). To compute L(N/2) given your computation of L(N) you
    need only copy the whole thing over elsewhere, switch the entry in B10 by multiplying
    the second term by 2, and copy that entry down. The answer will appear after half
    as many steps.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们用子间隔数N来表征我们对区间[a, b]的划分。 让我们将应用左手规则的结果称为L(N)。 要计算L(N/2)，只需复制整个内容到其他位置，通过将B10中的条目乘以2来更改第二项，然后将该条目复制下来。
    答案将在一半的步骤后出现。
- en: We can then define an extrapolated left hand rule, L[2](N) whose accuracy should
    improve by a factor of 4 when N is replaced by 2N, by
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以定义一个外推的左手规则，L[2](N)，当N被2N替换时其准确性应该提高4倍，通过
- en: L[2](2N) = 2L(2N) - L(N)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: L[2](2N) = 2L(2N) - L(N)
- en: 'This rule should then have behavior not far from that of the trapezoid rule.
    And we can do better by extrapolating this rule, to form L[3]:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这条规则的行为应该与梯形法则的行为相差不远。 而且我们可以通过外推这个规则来做得更好，形成L[3]：
- en: L[3](2N) = (4*L[2](2N) - L[2](N))/3
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: L[3](2N) = (4*L[2](2N) - L[2](N))/3
- en: This should cause errors to decrease by a factor of 8 on doubling the number
    of intervals, and we can extrapolate again, to form L[4], and so on, according
    to the rule
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该使得误差在加倍间隔的情况下减少8倍，然后我们可以再次外推，形成L[4]，依此类推，根据规则
- en: '**L[j](2N) = ((2^(j-1))* L[j-1](2N) - L[j-1](N))/(2^(j - 1)-1)**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**L[j](2N) = ((2^(j-1))* L[j-1](2N) - L[j-1](N))/(2^(j - 1)-1)**'
- en: Surprisingly enough, you can achieve considerable accuracy this way. L(32) is
    not very accurate, and L(1), L(2), L(4), ..., L(16) are worse, but they permit
    computation of L[6](32) which is much better.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，通过这种方式可以达到相当高的准确性。 L(32)不是很准确，而L(1)，L(2)，L(4)，...，L(16)更差，但它们允许计算L ，后者要好得多。
- en: '**Exercise 26.1 Set up a spreadsheet to compute these for f(x, y) = x + y,
    a = 0, b = 1 with y(a) = 1 and compute L[6](64) for the value of y at x = 1.**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习26.1 设置一个电子表格来计算这些值，对于f(x, y) = x + y, a = 0, b = 1，其中y(a) = 1，并计算y在x =
    1处的值的L 。**'
- en: The results obtained for y(2) for this problem are as follows. The proportional
    error is described in the second table
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，得到的y(2)的结果如下。比例误差在第二个表格中描述
- en: '| N | L | L[2] | L[3] | L[4] | L[5] | L[6] | L[7] | L[8] |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| N | L | L[2] | L[3] | L[4] | L[5] | L[6] | L[7] | L[8] |'
- en: '| 1 | 3 |   |   |   |   |   |   |   |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 3 |   |   |   |   |   |   |   |'
- en: '| 2 | 5 | 7 |   | exact answer | = | 11.7781122 |   |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 5 | 7 |   | 精确答案 | = | 11.7781122 |   |'
- en: '| 4 | 7.125 | 9.25 | 10 |   |   |   |   |   |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 7.125 | 9.25 | 10 |   |   |   |   |   |'
- en: '| 8 | 8.921 | 10.71686 | 11.20581 | 11.37807 |   |   |   |   |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 8.921 | 10.71686 | 11.20581 | 11.37807 |   |   |   |   |'
- en: '| 16 | 10.17 | 11.41207 | 11.64381 | 11.70638 | 11.728268 |   |   |   |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 10.17 | 11.41207 | 11.64381 | 11.70638 | 11.728268 |   |   |   |'
- en: '| 32 | 10.92 | 11.66817 | 11.75353 | 11.76921 | 11.773395 | 11.77485027 |  
    |   |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 10.92 | 11.66817 | 11.75353 | 11.76921 | 11.773395 | 11.77485027 |  
    |   |'
- en: '| 64 | 11.33 | 11.74777 | 11.77431 | 11.77727 | 11.777811 | 11.77795396 | 11.77800322
    |   |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 64 | 11.33 | 11.74777 | 11.77431 | 11.77727 | 11.777811 | 11.77795396 | 11.77800322
    |   |'
- en: '| 128 | 11.55 | 11.77013 | 11.77758 | 11.77805 | 11.778098 | 11.7781071 | 11.77810953
    | 11.77811037 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 11.55 | 11.77013 | 11.77758 | 11.77805 | 11.778098 | 11.7781071 | 11.77810953
    | 11.77811037 |'
- en: It is quite remarkable, but even going back to the one interval approximation
    improves the final answer, by allowing one more extrapolation
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 令人非常惊讶的是，即使回到一个间隔的近似值也会改善最终答案，因为它允许进行一次额外的外推。
- en: '| N\L index | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| N\L 索引 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |'
- en: '| 1 | -0.7453 |   |   |   |   |   |   |   |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 1 | -0.7453 |   |   |   |   |   |   |   |'
- en: '| 2 | -0.5755 | -0.405677 | -1 | � | � | � | � |   |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 2 | -0.5755 | -0.405677 | -1 | � | � | � | � |   |'
- en: '| 4 | -0.3951 | -0.214645 | -0.15097 | � | � | � | � |   |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 4 | -0.3951 | -0.214645 | -0.15097 | � | � | � | � |   |'
- en: '| 8 | -0.2426 | -0.090104 | -0.04859 | -0.03396 | � | � | � |   |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 8 | -0.2426 | -0.090104 | -0.04859 | -0.03396 | � | � | � |   |'
- en: '| 16 | -0.1368 | -0.031078 | -0.0114 | -0.00609 | -0.00423 | � | � |   |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 16 | -0.1368 | -0.031078 | -0.0114 | -0.00609 | -0.00423 | � | � |   |'
- en: '| 32 | -0.0731 | -0.009335 | -0.00209 | -0.00076 | -0.0004 | -0.000277 | �
    |   |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 32 | -0.0731 | -0.009335 | -0.00209 | -0.00076 | -0.0004 | -0.000277 | �
    |   |'
- en: '| 64 | -0.0378 | -0.002576 | -0.00032 | -7.1E-05 | -2.6E-05 | -1.34E-05 | -9.25E-06
    |   |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 64 | -0.0378 | -0.002576 | -0.00032 | -7.1E-05 | -2.6E-05 | -1.34E-05 | -9.25E-06
    |   |'
- en: '| 128 | -0.0193 | -0.000678 | -4.5E-05 | -5.6E-06 | -1.2E-06 | -4.33E-07 |
    -2.27E-07 | -1.56E-07 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 128 | -0.0193 | -0.000678 | -4.5E-05 | -5.6E-06 | -1.2E-06 | -4.33E-07 |
    -2.27E-07 | -1.56E-07 |'
- en: '|   | Proportional Error for Left Hand Rule y'' = y + z, y(0) = 1, finding
    y(2) |   |   |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|   | 左手规则y'' = y + z的比例误差，y(0) = 1，找到y(2) |   |   |'
- en: '**It can be seen by these results that using the simplest possible numerical
    method and extrapolating the hell out of it, can actually give accurate results.**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**由这些结果可以看出，使用最简单的数值方法并对其进行极端外推，实际上可以得到准确的结果。**'
- en: Note here that all extrapolation was done with the **final answers** at x =
    2 obtained using the left hand rule. You could obtain slightly better results
    by applying the extrapolations at intermediate x values, as soon as they become
    available to improve all the computations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里所有的外推都是使用左手规则在x = 2处得到的**最终答案**。当中间的x值变得可用时，你可以通过在中间x值上应用外推来改善所有的计算，从而获得稍微更好的结果。
- en: Thus the first extrapolation could be applied to update y after two intervals,
    the second after each set of four intervals, etc. This reduces the effect of errors
    in y compounding, which is only slightly helpful here.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一次外推可以应用于在两个区间后更新y，第二次在每组四个区间后更新，等等。这减少了y中的误差叠加的影响，在这里只有轻微的帮助。
- en: Obviously you do better the smaller you make d, that is, the large you make
    N.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你越把d减小，就越好，也就是说，你把N变得越大，效果就越好。
- en: But here extrapolating using smaller values of N is much more effective than
    doubling N in improving the answer.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在这里，使用更小的N值进行外推比将N加倍改进答案要有效得多。
- en: <applet code="FirstOrderODE" codebase="../applets/" archive="firstOrderODE.jar,mk_lib.jar,parser_math.jar,jcbwt363.jar"
    width="760" height="450"></applet>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <applet code="FirstOrderODE" codebase="../applets/" archive="firstOrderODE.jar,mk_lib.jar,parser_math.jar,jcbwt363.jar"
    width="760" height="450"></applet>
- en: 26.3 Generalization of the Trapezoid Rule
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 26.3 梯形法则的泛化
- en: Use of the trapezoid rule, which is substantially better than use of the left
    hand rule for approximating integrals numerically, can be applied here if you
    can find a way to calculate f(x, y) at the right ends of the intervals when you
    only have an estimate for y at the left end.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用梯形法则来数值逼近积分，比使用左手法则要好得多，如果你能找到一种方法，在你只有左端点处y的估计时，在区间的右端点处计算f(x, y)。
- en: An obvious first approximation to doing this is to approximate y at the right
    end of the interval using the linear approximation to y defined at the left end.
    The resulting rule is
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，首先近似这样做是使用在左端点定义的y的线性近似来近似区间的右端点的y。得到的规则是
- en: '![](../Images/a78def72cc980b189f7715987cf1400e.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a78def72cc980b189f7715987cf1400e.jpg)'
- en: This rule consists of approximating the difference between the values of y at
    the ends of the interval by **half of d multiplied the sum of the derivative f
    at the left end and the linear approximation to the derivative at the right end
    defined at the left end.** When f does not depend on y we get the usual trapezoid
    rule.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则由以下方法近似区间端点处y值的差异，即**d的一半乘以左端点处f的导数和在左端点定义的对右端点处导数的线性近似的和。**当f不依赖于y时，我们得到通常的梯形法则。
- en: Another way to look at this for subinterval from x to x + d is by defining "iterations"
    of the left hand rule, as follows
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种观察区间从x到x + d的方法是通过定义左手规则的“迭代”，如下所示
- en: '![](../Images/32908ee170e7b366e4077e38f235d237.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/32908ee170e7b366e4077e38f235d237.jpg)'
- en: In these terms the computation rule here is
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些条件下，这里的计算规则是
- en: '![](../Images/53f36528c2aa15ffb89467168ec830d2.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/53f36528c2aa15ffb89467168ec830d2.jpg)'
- en: The left hand rule is off because y changes over the interval. The linear approximation
    to y applied here is off only because **y's derivative changes,** and this is
    a second derivative effect.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 左手规则不适用，因为y在区间上发生了变化。这里应用的对y的线性近似只不过是因为**y的导数发生了变化**，这是一个二阶导数的影响。
- en: Thus the error it causes is quadratic in the interval size, and is on a par
    with the error intrinsic to the trapezoid rule. We therefore expect this rule
    to give results that improve in accuracy by a factor of four when N is doubled.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它造成的误差是与区间大小的平方成正比的，并且与梯形法固有的误差相当。因此，我们预计当 N 加倍时，该规则的结果会提高 4 倍的准确性。
- en: Again, there is no great complication in setting up a spreadsheet to compute
    the predictions of this rule for any N and you can extrapolate as before with
    it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，设置一个电子表格来计算这个规则对于任何 N 的预测并不复杂，你可以像以前一样进行外推。
- en: It has the advantage that you can start with the factor 4 extrapolation because
    accuracy improvement by a factor of 4 on doubling the number of points is built
    into its structure.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它的优点在于，你可以从因子 4 的外推开始，因为在加倍点数时，准确性提高了 4 倍，这一点内在于其结构之中。
- en: The rule no longer has the same weight structure as the trapezoid rule because
    when you compute f(x, y) at a given intermediate point from the left you are using
    the linear approximation at the previous point, while when you compute it in the
    interval to its right you use the value of y computed from the rule itself in
    the previous interval. Such is life.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则不再具有与梯形法相同的权重结构，因为当你在给定的中间点从左边计算 f(x, y) 时，你使用的是在上一个点处的线性近似，而当你在其右侧的区间中计算时，你使用的是在前一个区间中从规则本身计算出的
    y 的值。这就是生活。
- en: Here are the entries in rows 9 and 10 that can be used in place of those above
    to produce this computation, when those in red are copied down. The red entries
    in columns D and E are given for the differential equation y' = x + y. They have
    to be changed and the results copied down, in order to switch to a different differential
    equation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第 9 和第 10 行中的条目，可以替代上面的条目来产生此计算，当红色条目被复制时。表中 D 和 E 列中的红色条目是给出微分方程 y' = x +
    y 的。它们必须被更改，并且结果被复制，以便切换到不同的微分方程。
- en: '| B | C | D | E |   |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| B | C | D | E |   |'
- en: '| X | y=y(x-d)+(f[0](x-d)+f[1](x))*d/2 | f[0](x)=x+y(x) | f[1](x+d)=x+d+y(x)+d*f[0](x)
    | 8 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| X | y=y(x-d)+(f[0](x-d)+f[1](x))*d/2 | f[0](x)=x+y(x) | f[1](x+d)=x+d+y(x)+d*f[0](x)
    | 8 |'
- en: '| =B3 | =B6 | =B9+C9 | =B10+C9+(B10-B9)*D9 | 9 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| =B3 | =B6 | =B9+C9 | =B10+C9+(B10-B9)*D9 | 9 |'
- en: '| =B9+$B$7 | =C9+(D9+E9)*(B10-B9)/2 | =B10+C10 | =B12+C10+(B12-B10)*D10 | 10
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| =B9+$B$7 | =C9+(D9+E9)*(B10-B9)/2 | =B10+C10 | =B12+C10+(B12-B10)*D10 | 10
    |'
- en: '**Exercise 26.2 Compare the results obtained using the rule above, with those
    obtained using the left hand rule, upon the same problem.**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 26.2 比较使用上述规则和使用左手规则得到的结果，对同一问题进行比较。**'
- en: Here are results obtained using this trapezoid like method with various levels
    of extrapolation
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种梯形法得到的结果如下所示，具有不同级别的外推：
- en: '| N\L# | L[1] | L[2] | L[3] | L[4] | L[5] | L[6] | L[7] | L[8] |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| N\L# | L[1] | L[2] | L[3] | L[4] | L[5] | L[6] | L[7] | L[8] |'
- en: '| 1 | 5 |   |   |   |   |   |   |   |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 5 |   |   |   |   |   |   |   |'
- en: '| 2 | 9.5 | 11 |   |   |   |   |   |   |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 9.5 | 11 |   |   |   |   |   |   |'
- en: '| 4 | 10.9458 | 11.42773 | 11.48883929 |   |   |   |   |   |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 10.9458 | 11.42773 | 11.48883929 |   |   |   |   |   |'
- en: '| 8 | 11.52449 | 11.71739 | 11.75877194 | 11.77676745 |   |   |   |   |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 11.52449 | 11.71739 | 11.75877194 | 11.77676745 |   |   |   |   |'
- en: '| 16 | 11.70817 | 11.76939 | 11.77681781 | 11.77802087 | 11.7780613 |   |  
    |   |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 11.70817 | 11.76939 | 11.77681781 | 11.77802087 | 11.7780613 |   |  
    |   |'
- en: '| 32 | 11.75976 | 11.77696 | 11.77804039 | 11.77812189 | 11.77812515 | 11.77812617
    |   |   |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 11.75976 | 11.77696 | 11.77804039 | 11.77812189 | 11.77812515 | 11.77812617
    |   |   |'
- en: '| 64 | 11.77341 | 11.77796 | 11.77810835 | 11.77811289 | 11.77811259 | 11.7781124
    | 11.77811229 |   |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 64 | 11.77341 | 11.77796 | 11.77810835 | 11.77811289 | 11.77811259 | 11.7781124
    | 11.77811229 |   |'
- en: '| 128 | 11.77692 | 11.77809 | 11.77811199 | 11.77811223 | 11.77811221 | 11.7781122
    | 11.7781122 | 11.7781122 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 11.77692 | 11.77809 | 11.77811199 | 11.77811223 | 11.77811221 | 11.7781122
    | 11.7781122 | 11.7781122 |'
- en: The accuracy of these calculations for this problem are shown in the following
    table
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些计算对于这个问题的准确度显示在下表中：
- en: '| N\L# | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| N\L# | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |'
- en: '| 1 | -0.57548 | � |   |   |   |   |   |   |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 1 | -0.57548 | � |   |   |   |   |   |   |'
- en: '| 2 | -0.19342 | -0.06606 |   |   |   |   |   |   |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 2 | -0.19342 | -0.06606 |   |   |   |   |   |   |'
- en: '| 4 | -0.07067 | -0.02975 | -0.02456 | � | � |   |   |   |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 4 | -0.07067 | -0.02975 | -0.02456 | � | � |   |   |   |'
- en: '| 8 | -0.02153 | -0.00516 | -0.00164 | -0.00011 | � |   |   |   |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 8 | -0.02153 | -0.00516 | -0.00164 | -0.00011 | � |   |   |   |'
- en: '| 16 | -0.00594 | -0.00074 | -0.00011 | -7.8E-06 | -4E-06 |   |   |   |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 16 | -0.00594 | -0.00074 | -0.00011 | -7.8E-06 | -4E-06 |   |   |   |'
- en: '| 32 | -0.00156 | -9.8E-05 | -6.1E-06 | 8.23E-07 | 1.1E-06 | 1.19E-06 | � |
    � |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 32 | -0.00156 | -9.8E-05 | -6.1E-06 | 8.23E-07 | 1.1E-06 | 1.19E-06 | � |
    � |'
- en: '| 64 | -0.0004 | -1.3E-05 | -3.3E-07 | 5.84E-08 | 3.4E-08 | 1.68E-08 | 7.6E-09
    | � |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 64 | -0.0004 | -1.3E-05 | -3.3E-07 | 5.84E-08 | 3.4E-08 | 1.68E-08 | 7.6E-09
    | � |'
- en: '| 128 | -0.0001 | -1.6E-06 | -1.8E-08 | 2.51E-09 | 7.1E-10 | 1.84E-10 | 5.3E-11
    | 2.4E-11 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 128 | -0.0001 | -1.6E-06 | -1.8E-08 | 2.51E-09 | 7.1E-10 | 1.84E-10 | 5.3E-11
    | 2.4E-11 |'
- en: '| ����������� Proportional Error for (f[0](x) + f[1](x+d))/2 Rule y'' = y +
    z, y(0) = 1,finding y(2) |   |   |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| ����������� (f[0](x) + f[1](x+d))/2 规则的比例误差 y'' = y + z, y(0) = 1，寻找 y(2)
    |   |   |'
- en: You will note that the estimates here without extrapolation are a little better
    than those for the first iteration of the previous method, by a factor of 6 for
    N = 128\. However, after extrapolation the results are more accurate by a factor
    of thousands than in the previous table. [See First Order ODE Applet](section02.html#FirstOrderODE)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，这里没有外推的估计比上一个方法的第一次迭代更好一点，对于 N = 128，好了 6 倍。然而，在外推后，结果比上一个表格中更准确了成千上万倍。[请参阅一阶常微分方程
    Applet](section02.html#FirstOrderODE)
- en: 26.4 Generalization of Simpson's Rule; the Runge-Kutta 2^(th) Order Rule
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 26.4 辛普森规则的泛化；龙格-库塔 2 阶规则
- en: You can do even better by providing a rule for estimating the change in y over
    an interval with the accuracy of Simpson's rule.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供一个估计区间内 y 变化的规则，其精度与辛普森规则相当，您甚至可以做得更好。
- en: To do so we estimate f at the beginning, middle and end of the interval, and
    give relative weights to these of 1 4 1 as in Simpson's rule. It is only necessary
    to apply estimates of f at the middle and right endpoints that are accurate "to
    second order", so that their error is cubic or smaller.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们估计区间起点、中点和终点处的 f，并给予这些估计相对权重 1 4 1，就像辛普森规则一样。只需要对中点和右端点的 f 的估计精确到“二阶”，使其误差为立方或更小。
- en: There are many ways to do this. The left hand value for f presents no problems
    at all and is f(x, y(x)). The Runge-Kutta second order rule involves using
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以做到这一点。f 的左手值根本没有问题，是 f(x, y(x))。龙格-库塔二阶规则涉及使用
- en: '![](../Images/3ae4d4d1b9084952184ad02c89a9d382.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3ae4d4d1b9084952184ad02c89a9d382.jpg)'
- en: to approximate the integrand in the middle of the interval, and
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在区间中间对被积函数进行近似，以及
- en: '![](../Images/181ca403e44250f50da13eb0c02a7957.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/181ca403e44250f50da13eb0c02a7957.jpg)'
- en: to approximate it at the right end, with
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在右端进行近似，使用
- en: '![](../Images/08a2dcd55b7196ac31e8eff1dbfeb95f.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08a2dcd55b7196ac31e8eff1dbfeb95f.jpg)'
- en: Thus, with the notations given this method provides the following rule
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，给定的符号，该方法提供以下规则
- en: '![](../Images/e985a585295c36097fdda1317afbcd3e.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e985a585295c36097fdda1317afbcd3e.jpg)'
- en: Again, this rule can be implemented without much difficulty on a spreadsheet.
    You now need a column for each of x, y and the four f terms that occur in this
    rule, which requires one or two entries and copying for each column. It can be
    extrapolated as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个规则可以在电子表格上很容易地实现。现在您需要为 x、y 和此规则中出现的四个 f 项中的每个列都需要一个或两个条目，并且为每个列复制。它也可以被外推。
- en: '**Exercise 26.3 Compute solution to the same equation, y'' = y + x using this
    method with the old initial conditions, y(0) = 1 at x = 1\. How much better is
    it than the previous one for N = 32?**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 26.3 使用旧的初始条件，y(0) = 1，在 x = 1 时计算相同方程的解，y'' = y + x。对于 N = 32，它比以前的方法好多少？**'
- en: The remarkable thing about this rule is that the error is of fourth order, as
    it is for Simpson's rule. Thus, if we double the number of intervals the error
    falls by 16 for large N values. Simpson's rule has the symmetry that makes this
    so. It is a bit surprising that the estimates here do not have a cubic error term,
    but they do not have one.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则的显著之处在于误差是四阶的，就像辛普森规则一样。因此，如果我们将区间数加倍，那么对于大的 N 值，误差将减小 16 倍。辛普森规则具有这样的对称性，这使得成立。令人惊讶的是，这里的估计没有立方误差项，但它们确实没有。
- en: With x in B11 and y in C11 here are the relevant entries for the f 's in D,
    E, F and G for this equation, to be copied down for the equation y' = y + x
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有了 B11 中的 x 和 C11 中的 y，这里是对于方程中的 D、E、F 和 G 的 f 的相关条目，用于拷贝以计算方程 y' = y + x
- en: '| f = x + y(x) | f[1] = f + (1 + f)d / 2 | f + (1 + f[1])d / 2 | f + (1 + f[2])d
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| f = x + y(x) | f[1] = f + (1 + f)d / 2 | f + (1 + f[1])d / 2 | f + (1 + f[2])d
    |'
- en: '| =B11+C11 | =D11+(1+D11)*(B12-B11)/2 | =D11+(1+E11)*(B12-B11)/2 | =D11+(1+F11)*(B12-B11)
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| =B11+C11 | =D11+(1+D11)*(B12-B11)/2 | =D11+(1+E11)*(B12-B11)/2 | =D11+(1+F11)*(B12-B11)
    |'
- en: Here are results for this method at x = 2\. The extrapolations start with the
    assumption that the leading term in the error decreases by a factor of 16 on halving
    the intervals
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是在 x = 2 时这种方法的结果。外推假设误差的主导项在减半区间后减小了 16 倍。
- en: '| N\L# | 1 | 2 | 3 | 4 | 5 | 6 | 7 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| N\L# | 1 | 2 | 3 | 4 | 5 | 6 | 7 |'
- en: '| 1 | 11 | � |   |   | exact answer | = | 11.7781122 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 11 | � |   |   | 精确答案 | = | 11.7781122 |'
- en: '| 2 | 11.670139 | 11.71481481 | � |   |   |   |   |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 11.670139 | 11.71481481 | � |   |   |   |   |'
- en: '| 4 | 11.767941 | 11.77446077 | 11.77638483 |   |   |   |   |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 11.767941 | 11.77446077 | 11.77638483 |   |   |   |   |'
- en: '| 8 | 11.777331 | 11.77795654 | 11.77806931 | 11.77809605 |   |   |   |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 11.777331 | 11.77795654 | 11.77806931 | 11.77809605 |   |   |   |'
- en: '| 16 | 11.778058 | 11.7781065 | 11.77811134 | 11.77811201 | 11.77811213 |  
    |   |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 11.778058 | 11.7781065 | 11.77811134 | 11.77811201 | 11.77811213 |  
    |   |'
- en: '| 32 | 11.778109 | 11.77811201 | 11.77811218 | 11.7781122 | 11.7781122 | 11.7781122
    |   |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 11.778109 | 11.77811201 | 11.77811218 | 11.7781122 | 11.7781122 | 11.7781122
    |   |'
- en: '| 64 | 11.778112 | 11.77811219 | 11.7781122 | 11.7781122 | 11.7781122 | 11.7781122
    | 11.7781122 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 64 | 11.778112 | 11.77811219 | 11.7781122 | 11.7781122 | 11.7781122 | 11.7781122
    | 11.7781122 |'
- en: '|   | Runge-Kutta rule y'' = y + x, y(0) = 1, value for y(2) with extrapolations
    |   |   |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|   | Runge-Kutta 规则 y'' = y + x, y(0) = 1, 对于 y(2) 的值与外推 |   |   |'
- en: The proportional errors are indicated here
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了比例误差
- en: '| N\L# | 1 | 2 | 3 | 4 | 5 | 6 | 7 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| N\L# | 1 | 2 | 3 | 4 | 5 | 6 | 7 |'
- en: '| 1 | -0.06606425 |   |   |   |   |   |   |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 1 | -0.06606425 |   |   |   |   |   |   |'
- en: '| 2 | -0.00916728 | -0.00537 |   |   |   |   |   |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 2 | -0.00916728 | -0.00537 |   |   |   |   |   |'
- en: '| 4 | -0.0008636 | -0.00031 | -0.00015 |   |   |   |   |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 4 | -0.0008636 | -0.00031 | -0.00015 |   |   |   |   |'
- en: '| 8 | -6.6365E-05 | -1.3E-05 | -3.6E-06 | -1.4E-06 |   |   |   |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 8 | -6.6365E-05 | -1.3E-05 | -3.6E-06 | -1.4E-06 |   |   |   |'
- en: '| 16 | -4.6011E-06 | -4.8E-07 | -7.3E-08 | -1.6E-08 | -5.5E-09 |   |   |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 16 | -4.6011E-06 | -4.8E-07 | -7.3E-08 | -1.6E-08 | -5.5E-09 |   |   |'
- en: '| 32 | -3.0291E-07 | -1.6E-08 | -1.3E-09 | -1.6E-10 | -3.2E-11 | -1.1E-11 |
      |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 32 | -3.0291E-07 | -1.6E-08 | -1.3E-09 | -1.6E-10 | -3.2E-11 | -1.1E-11 |
      |'
- en: '| 64 | -1.9431E-08 | -5.3E-10 | -2.2E-11 | -1.4E-12 | -1.4E-13 | -1.3E-14 |
    8.3E-15 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 64 | -1.9431E-08 | -5.3E-10 | -2.2E-11 | -1.4E-12 | -1.4E-13 | -1.3E-14 |
    8.3E-15 |'
- en: '|   | Runge-Kutta rule y'' = y + x, y(0) = 1, proportional error for y(2) with
    extrapolations |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|   | Runge-Kutta 规则 y'' = y + x, y(0) = 1, 对于 y(2) 的外推的比例误差 |'
- en: It can be seen that the same number of evaluation points (N for Runge Kutta
    is comparable to 2N for the trapezoid like rule) yields perhaps a thousand times
    the accuracy for this evaluation rule in this example, though the best extrapolation
    for the trapezoid is better than the best unextrapolated Runge-Kutta formula here
    by a factor of a thousand. [See First Order ODE Applet](section02.html#FirstOrderODE)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，对于这个评估规则，相同数量的评估点（Runge-Kutta 的 N 相当于梯形规则的 2N）在这个例子中可能产生大约一千倍的准确性，尽管梯形法的最佳外推比这里的最佳未外推
    Runge-Kutta 公式好一千倍。[查看一阶常微分方程 Applet](section02.html#FirstOrderODE)
- en: 26.5 Comments
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 26.5 Comments
- en: 'These methods suggest the following questions:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法提出了以下问题：
- en: '**When will they fail?'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**它们何时会失败？'
- en: Can they be improved?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 它们能被改进吗？
- en: Are there better techniques available?**
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有更好的技术可用？**
- en: These methods obviously cannot be applied directly on **an infinite interval,**
    so if confronted by one you must do something to it, like changing the independent
    variable to make it into a finite interval problem before even thinking of using
    one.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些方法显然不能直接应用于**无限区间**，因此如果遇到这种情况，你必须对其进行处理，比如改变自变量，使其成为一个有限区间问题，然后再考虑使用其中一种方法。
- en: They can and will fail as well for finite problems, in two general cases; **if
    f is such that its higher derivatives become large,** you may have trouble attempting
    to use them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有限问题，它们也可能失败，有两种一般情况；**如果 f 的高阶导数变大，**你可能会在尝试使用它们时遇到困难。
- en: Examples of such are **sin(100000x)** and ![](../Images/5fbfab4140fbb96f1dfe7972d0016eab.jpg)
    for x near 0\. These are definite trouble for techniques like this.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如 **sin(100000x)** 和 ![](../Images/5fbfab4140fbb96f1dfe7972d0016eab.jpg) 对于接近
    0 的 x 值。这些对于这样的技术确实是个问题。
- en: In the former case, though f is bounded, using small N values will not give
    a reasonable picture of f, and in the latter case, no N value will do so sufficiently
    near 0.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一种情况下，尽管 f 是有界的，但使用较小的 N 值将无法给出 f 的合理图像，在后一种情况下，无论 N 值如何，都不会在足够接近 0 处给出合理的图像。
- en: There is another way you can run into a problem and that is when, though f is
    well behaved, the **solution you seek becomes infinite at some point in the interval
    you are concerned with.**
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种情况可能会遇到问题，那就是，尽管 f 表现良好，但你寻找的解在你关心的区间某一点上变为无穷大。
- en: That is not really as bad or strange a problem as you might expect. It does
    mess up these methods if you try to apply them naively though.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是你可能期望的那么糟糕或奇怪的问题。但如果你尝试天真地应用它们，它们确实会破坏这些方法。
- en: First it only really means that the reciprocal of y, the function ![](../Images/bbc3ca3074a5791ebd97075f55e9869f.jpg),
    goes through zero at the point at which y becomes infinite. It is really no more
    surprising for ![](../Images/bbc3ca3074a5791ebd97075f55e9869f.jpg) to be zero
    than it is for it to be anything else, **so this can easily happen with a non-linear
    differential equation.**
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这实际上只意味着y的倒数，函数![](../Images/bbc3ca3074a5791ebd97075f55e9869f.jpg)，在y变为无穷大时经过零点。![](../Images/bbc3ca3074a5791ebd97075f55e9869f.jpg)为零并不比它为其他任何值更令人惊讶，**所以这种情况在非线性微分方程中很容易发生。**
- en: 'Second and most important, **if you know y'' you also know ![](../Images/978cc56f9c322071add477ed5303754e.jpg)**
    and can apply these methods to ![](../Images/bbc3ca3074a5791ebd97075f55e9869f.jpg)
    just as easily as you can to y. If we make the definition: ![](../Images/e6079840c174e0eed830084f97176d04.jpg)
    we find, for y'' = f(x, y)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，最重要的是，**如果您知道y'，您也知道![](../Images/978cc56f9c322071add477ed5303754e.jpg)**，并且可以像对y一样轻松地对![](../Images/bbc3ca3074a5791ebd97075f55e9869f.jpg)应用这些方法。如果我们定义：![](../Images/e6079840c174e0eed830084f97176d04.jpg)，我们发现，对于y'
    = f(x, y)
- en: '![](../Images/7cbe19d2fc985bcbf3d8d2e3f01f4f0b.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7cbe19d2fc985bcbf3d8d2e3f01f4f0b.jpg)'
- en: and we can apply the rules discussed to solve for z(b) instead of y(b) given
    z(a).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用讨论过的规则来解决给定z(a)而不是y(b)的z(b)。
- en: In fact when y is greater than 1, the derivative of z will be smaller than that
    of y and so you can expect to find it easier to approximate the changes in z than
    in y. When y explodes and goes to infinity, z wanders quietly near 0, and its
    behavior can easily be tracked by our methods.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当y大于1时，z的导数将小于y的导数，因此您可以期望在近似z的变化方面比y更容易。当y爆炸并趋向无穷大时，z在0附近静静地漫步，其行为可以很容易地通过我们的方法跟踪。
- en: Thus a cautious approach to solving equations where this can happen is to set
    up your favorite method for y and for z ![](../Images/6e5ef7bf6dd62f0e3986ab11a568cfb6.jpg)
    **simultaneously,** and **use the y approach when the magnitude of y is less than
    1 and the z one when the magnitude of z is at most 1.**
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在解决可能发生这种情况的方程时，谨慎的方法是同时为y和z![](../Images/6e5ef7bf6dd62f0e3986ab11a568cfb6.jpg)设置您喜欢的方法，并且**当y的数量小于1且z的数量最多为1时使用y方法，当z的数量最多为1时使用z方法。**
- en: In our example, in which we have y' = x + y, the equation for z becomes z' =
    -z²x - z, which is quite as easy to handle as the original equation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们有y' = x + y，z的方程变为z' = -z²x - z，这与原方程一样容易处理。
- en: In our computation we worked with the y' equation, though y was greater than
    1 throughout the interval. We could probably have done even better by working
    with the z equation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的计算中，我们使用了y'方程，尽管整个区间内y大于1。通过使用z方程，我们可能会做得更好。
- en: Of course in our example, the original equation is linear in y and the inhomogeneous
    term is linear in x, so this problem will not arise.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在我们的例子中，原方程中y是线性的，而非齐次项是x的线性，因此这个问题不会出现。
- en: '**Exercise 26.4 Try your favorite method on the differential equation ![](../Images/6755d5cf5fb0e2241cba07cd8c9fd9aa.jpg),
    with z(0) = 1, and compare the reciprocal of the values you obtain for z(1), that
    is, ![](../Images/32c55f6a518737e0fd53c4387ed8ae78.jpg) with those you obtained
    earlier for y.**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习26.4 尝试您喜欢的方法解决微分方程![](../Images/6755d5cf5fb0e2241cba07cd8c9fd9aa.jpg)，其中z(0)
    = 1，并比较您获得的z(1)的倒数值，即![](../Images/32c55f6a518737e0fd53c4387ed8ae78.jpg)与您之前为y获得的值。**'
- en: There is much lore about numerical methods, and the subject is called numerical
    analysis.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 数值方法有很多传统知识，这个领域被称为数值分析。
- en: It used to be a very dry field, because it is tedious and dull to learn a method
    that you can't possibly use, something like trying to read a cookbook when you
    have no kitchen to cook in.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这曾经是一个非常枯燥的领域，因为学习一种您根本无法使用的方法是乏味的，就像在没有厨房可以烹饪的情况下尝试阅读食谱一样。
- en: Nowadays you can easily play with these methods, and they have dramatic application
    to real time control so that the field is now actually fun.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以轻松地玩弄这些方法，并且它们对实时控制有戏剧性的应用，因此这个领域现在实际上很有趣。
- en: You will note that in every case, extrapolation using larger intervals only
    was able to improve the accuracy of estimates here, by factors on the order of
    a hundred thousand to a million, for each method.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，在每种情况下，仅使用更大的间隔进行外推能够提高这里的估计精度，每种方法的因素大约为十万到一百万。
- en: Is extrapolation of the kind we have used the best we can do here to improve
    solutions?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的外推方法是改进解决方案的最佳方法吗？
- en: The answer is no.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的。
- en: These extrapolations have the great advantage that they are easy to perform,
    but they gain one added power of accuracy at the cost of doubling N.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些外推的方法有一个很大的优势，就是易于执行，但以加倍N的代价获得了额外的精确度。
- en: In fact, if you play your cards right, you can gain one added power of accuracy
    by increasing N by 2, by choosing the best possible weights, for the points and
    using the correspondingly accurate rule for approximating f in each interval.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果你运用得当，通过将N增加2倍，并选择最佳的权重，为点选择最佳权重，并在每个区间使用相应准确的规则来近似f，你可以获得额外的精确度。
- en: If you imagine y written as a power series in x, theoretically each new point
    could be used to eliminate the contribution from one higher power, so that with
    N points it could be possible to produce a rule whose error would occur only from
    the N-th and higher derivatives of y.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想象y写成x的幂级数，理论上每个新点都可以用来消除一个更高幂次的贡献，这样，使用N个点可能会产生一个仅由y的N次及更高导数产生误差的规则。
- en: Thus, much greater accuracy is possible than what we have attained here. But
    then again, what we have done here requires relatively little effort.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，比我们在这里所达到的要更高的准确度是可能的。但另一方面，我们在这里所做的工作所需的努力相对较少。
