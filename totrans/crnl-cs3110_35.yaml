- en: 'Recitation 24: Solving Recurrences'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recitation, we saw how to solve recurrences, with the example
    of a simple multiplication function using only additions, and running in time
    *O(log n)*. Today we will see more examples of those, by proving the complexity
    of mergesort, as well as the complexity of a function calculating Fibonacci numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Merge sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementation of merge sort
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Merge sort asymptotic timing analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let's show that `merge_sort` is not only a *correct* but also an *efficient*
    algorithm for sorting lists of numbers. We start by observing without proof that
    the performance of the `split` function is linear in the size of the input list.
    This can be shown by the same approach we will take for `merge`, so let's just
    look at `merge` instead.
  prefs: []
  type: TYPE_NORMAL
- en: The `merge` function too is linear-time—that is, *O*(*n*)—in the total length
    of the two input lists. We will first find a recurrence relation for the execution
    time. Suppose the total length of the input lists is zero or one. Then the function
    must execute one of the two *O*(1)  arms of the case expression. These take at
    most some time *c*[0] to execute. So we have
  prefs: []
  type: TYPE_NORMAL
- en: '*T*(0) = *c*[0]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*T*(1) = *c*[0]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now, consider lists of total length *n*. The recursive call is on lists of total
    length *n*−1, so we have
  prefs: []
  type: TYPE_NORMAL
- en: '*T*(*n*) = *T*(*n*−1) + *c*[1]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: where *c*[1] is an constant upper bound on the time required to execute the
    if statement and the operator `::` (which takes constant time for usual implementations
    of lists). This gives us a recurrence relation to solve for *T*.  We can apply
    the iterative method to solve the recurrence relation by expanding out the recurrence
    relation inequalities for the first few steps.
  prefs: []
  type: TYPE_NORMAL
- en: '*T*(0) = *c*[0]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*T*(1) = *c*[0] *T*(2) = *T*(1) + *c*[1] = *c*[0] + *c*[1] *T*(3) = *T*(2)
    + *c*[1] = *c*[0] + 2*c*[1] *T*(4) = *T*(3) + *c*[1] = *c*[0] + 3*c*[1'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '...] *T*(*n*) = *T*(*n*−1) + *c*[1] = *c*[0] + (*n*−1)*c*[1] = (*c*[0] - c[1])+
    *c*[1]*n*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We notice a pattern which the last line captures. This pattern can be proved
    more rigorously by induction: let us prove by induction that for *n >=0*, *T*(*n*)=(*c*[0]
    - c[1])+ *c*[1]*n*. For *n=0*, the result is true (proved above), and if it is
    true for *n-1*, it is true for n using the last line above.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that *T*(*n*) is *O*(*n*) if for all *n* greater than some *n*[0], we
    can find a constant *k* such that *T*(*n*) < *kn*. For n at least 1, this is easily
    satisfied by setting *k* = *c*[0] + 2*c*[1]. Or we can just remember that any
    first-degree polynomial is *O*(*n*) and also Θ(*n*). An even simpler way to find
    the right bound is to observe that the choice of constants *c[0]* and *c[1]* doesn't
    matter; if we plug in 1 for both of them we get *T*(1) = 1, *T*(2)=2, *T*(3)=3,
    etc., which is clearly *O*(*n*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s consider the `merge_sort` function itself. Again, for zero- and
    one-element lists we compute in constant time. For *n*-element lists we make two
    recursive calls, but to sublists that are about half the size, and calls to `split`
    and `merge` that each take Θ(*n*) time. For simplicity we''ll pretend that the
    sublists are exactly half the size. The recurrence relation we obtain has this
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '*T*(0) = *c*[0]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*T*(1) = *c*[0] *T*(*n*) = 2 *T*(*n*/2) + *c*[1]*n + * *c*[2]*n + c*[3]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let''s use the iterative method to figure out the running time of `merge_sort`.
    We know that any solution must work for arbitrary constants *c*[0] and *c*[4],
    so again we replace them both with 1 to keep things simple. That leaves us with
    the following recurrence equations to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '*T*(1) = 1'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*T*(*n*) = 2 *T*(*n*/2) + *n*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Starting with the iterative method, we can start expanding the time equation
    until we notice a pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '*T*(*n*) = 2*T*(*n*/2) + *n*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: = 2(2*T*(*n*/4) + *n*/2) + *n*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: = 4*T*(*n*/4) + *n* + *n*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: = 4(2*T*(*n*/8) + *n*/4) + *n* + *n*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: = 8*T*(*n*/8) + *n* + *n* + *n*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: = *nT*(*n*/*n*) + *n* + ... + *n* + *n* + *n*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: = *n* + *n* + ... + *n* + *n* + *n*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Counting the number of repetitions of *n* in the sum at the end, we see that
    there are lg *n* + 1 of them.  Thus the running time is *n*(lg *n* + 1) = *n*
    lg *n* + *n*. We observe that *n* lg *n* + *n* < *n* lg *n* + *n* lg *n* = 2*n*
    lg *n* for *n*>0, so the running time is *O*(*n* lg *n*).  So now we've done the
    analysis by using the iterative method, let's use strong induction to verify that
    the bound is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Merge sort analysis using strong induction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Property P(n) to prove:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*n* ≥ 1 ⇒ *T*(*n*) = *n* lg *n* + *n*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Proof by strong (course-of-values) induction on n**. For arbitrary *n*, show
    P(n) is true assuming the induction hypothesis *T*(*m*) = *m* lg *m* + *m* for
    all *m*<*n*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case n = 0**: vacuously true'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case n = 1**: T(1) = 1 = 1 lg 1 + 1'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case n > 1**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Induction Hypothesis:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Proof:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*T*(*n*) = 2 T(*n*/2) + *n*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: = (*n*/2) lg (*n*/2) + 2(*n*/2) + *n*              *(by induction hypothesis)*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: = *n* lg (*n*/2) + 2*n*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: = *n* lg *n* − 1) 1) + 2*n*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: = *n* lg *n* + *n*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since *n* lg *n* + *n* is Θ(*n* lg *n*), we have shown that merge sort is Θ(*n*
    lg *n*).
  prefs: []
  type: TYPE_NORMAL
- en: The Fibonacci numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Fibonacci numbers, written *F(n)*, are defined by *F(0)=0*, *F(1)=1*, and
    for *n>1*, *F(n)=F(n-1)+F(n-2)*. The first few Fibonacci numbers are 0,1,1,2,3,5,8,13,21,34,55,89,...
  prefs: []
  type: TYPE_NORMAL
- en: A first implementation and its complexity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We would like to write a function that would calculate the *n*-th Fibonacci
    number. A first implementation would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function follows directly from the definition of Fibonacci numbers, thus
    its correctness. Now, if we try running it in OCaml on say 100, it takes forever
    to complete. Let us see why by analyzing its asymptotic time.
  prefs: []
  type: TYPE_NORMAL
- en: The asymptotic time taken for *n=0* and *n=1* is constant, let us call it *c[0]*,
    so that *T(0)=T(1)=c[0]*. To calculate *T(n)* we make two recursive call, so that
    *T(n)=T(n-1)+T(n-2)*.
  prefs: []
  type: TYPE_NORMAL
- en: In mathematics, it can be shown that a solution of this recurrence relation
    is of the form *T(n)=a[1]*r[1]^n+a[2]*r[2]^n*, where *r[1]* and *r[2]* are the
    solutions of the equation *r²=r+1*. We get *r[1]=(1+sqrt(5))/2* and *r[2]=(1-sqrt(5))/2*.
    Then with *T(0)=T(1)=c[0]*, we get *a[1]+a[2]=a[1]r[1]+a[2]r[2]=c[0]*, leading
    to *a[1]=c[0]r[1]/sqrt(5)* and *a[2]=-c[0]r[2]/sqrt(5)*.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that *r[2]<1*, therefore *r[2]^n* is *o(1)*. Therefore *T(n)* is
    *Θ(r[1]^n)*, with *r[1]=(1+sqrt(5))/2*. The algorithm thus takes an exponential
    time to complete.
  prefs: []
  type: TYPE_NORMAL
- en: A more efficient implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation is clearly linear: each loop takes a constant time to complete,
    there are order of *n* loops. Like before, the correctness can be obtained by
    a recurrence on *n* (by stating that at each loop, *a=F(i-2)* and *b=F(i-1)*).'
  prefs: []
  type: TYPE_NORMAL
