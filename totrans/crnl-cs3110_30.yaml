- en: Coq3110An Introduction to Coq for CS 3110
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Coq3110 《CS 3110 中的 Coq 入门》
- en: 'This material is based on an online textbook by Benjamin Pierce et al. titled
    "Software Foundations":'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这些材料基于由本杰明·皮尔斯等人撰写的在线教材《软件基础》：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Inductive Types
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归纳类型
- en: 'Coq is a functional programming language. We can define data types, just like
    in OCaml. For example:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Coq 是一种函数式编程语言。我们可以定义数据类型，就像在 OCaml 中一样。例如：
- en: Days of the week
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一周的天
- en: Boolean
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔
- en: Natural numbers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自然数
- en: Days of the Week
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一周的天
- en: 'A datatype definition:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数据类型定义：
- en: 'Inductive day : Type :='
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳类型 day : 类型 :='
- en: '| monday : day'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '| 星期一 : 天'
- en: '| tuesday : day'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '| 星期二 : 天'
- en: '| wednesday : day'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '| 星期三 : 天'
- en: '| thursday : day'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '| 星期四 : 天'
- en: '| friday : day'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '| 星期五 : 天'
- en: '| saturday : day'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '| 星期六 : 天'
- en: '| sunday : day.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '| 星期日 : 天。'
- en: 'A function on days:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关于天的函数：
- en: 'Definition next_weekday (d:day) : day :='
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 next_weekday (d:day) : day :='
- en: match d with
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 d 与
- en: '| monday ⇒ tuesday'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '| 星期一 ⇒ 星期二'
- en: '| tuesday ⇒ wednesday'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '| 星期二 ⇒ 星期三'
- en: '| wednesday ⇒ thursday'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '| 星期三 ⇒ 星期四'
- en: '| thursday ⇒ friday'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '| 星期四 ⇒ 星期五'
- en: '| friday ⇒ monday'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '| 星期五 ⇒ 星期一'
- en: '| saturday ⇒ monday'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '| 星期六 ⇒ 星期一'
- en: '| sunday ⇒ monday'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '| 星期日 ⇒ 星期一'
- en: end.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: end.
- en: Check checks the type of an expression.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Check 检查表达式的类型。
- en: Check next_weekday.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Check next_weekday.
- en: (* ===> next_weekday : day -> day *)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> next_weekday : day -> day *)
- en: Computation
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算
- en: Eval compute in e evaluates e and prints the result, much like entering e into
    the REPL in OCaml.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Coq 中，Eval compute in e 会计算 e 并打印结果，就像在 OCaml 的 REPL 中输入 e 一样。
- en: Eval compute in (next_weekday friday).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Eval compute in (next_weekday 星期五).
- en: (* ==> monday : day *)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: (* ==> 星期一 : 天 *)
- en: Eval compute in (next_weekday (next_weekday saturday)).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Eval compute in (next_weekday (next_weekday 星期六)).
- en: (* ==> tuesday : day *)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: (* ==> 星期二 : 天 *)
- en: Unit tests
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'A "unit test" for our function — i.e., a mathematical claim about its behavior:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们函数的一个“单元测试” — 即，关于其行为的数学断言：
- en: 'Example test_next_weekday:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '例子 test_next_weekday:'
- en: (next_weekday (next_weekday saturday)) = tuesday.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: (next_weekday (next_weekday 星期六)) = 星期二。
- en: 'A proof script giving evidence for the claim:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个给出声明证据的证明脚本：
- en: Proof. reflexivity. Qed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。reflexivity. Qed.
- en: reflexivity is a *tactic* that is built into Coq. In essence, it applies Coq's
    computational rules (i.e., dynamic semantics) to both side of the = sign. Then
    it compares to see whether both sides reduced to the same value. If so, that counts
    as evidence that the equality holds.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: reflexivity 是内置于 Coq 中的 *策略*。实质上，它应用 Coq 的计算规则（即，动态语义）到等号的两侧。然后比较两侧是否简化为相同的值。如果是，那就是等式成立的证据。
- en: Extraction into OCaml
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取到 OCaml
- en: Extraction day.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 提取 day.
- en: (* type day =
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: (* 类型 day =
- en: '| Monday'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '| 星期一'
- en: '... *)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '... *)'
- en: Extraction next_weekday.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 提取 next_weekday.
- en: (* let next_weekday = function
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: (* let next_weekday = function
- en: '| Monday -> Tuesday'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '| 星期一 -> 星期二'
- en: '... *)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '... *)'
- en: Booleans
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'A familiar datatype:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个熟悉的数据类型：
- en: 'Inductive bool : Type :='
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳类型 bool : 类型 :='
- en: '| true : bool'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '| true : bool'
- en: '| false : bool.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '| false : bool.'
- en: Booleans are also provided in Coq's standard library, but we are defining from
    scratch, just to see how it's done.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Coq 的标准库中也提供了布尔值，但我们是从头开始定义的，只是为了看看如何做。
- en: Functions on booleans
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔函数
- en: We can code these up with using any built-in boolean operators.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用任何内置布尔运算符编写这些代码。
- en: 'Definition negb (b:bool) : bool :='
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 negb (b:bool) : bool :='
- en: match b with
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 b 与
- en: '| true ⇒ false'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '| true ⇒ false'
- en: '| false ⇒ true'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '| false ⇒ true'
- en: end.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: end.
- en: Coq has an if expression that we could use instead of pattern matching.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Coq 有一个 if 表达式，我们可以用它来代替模式匹配。
- en: 'Definition andb (b1:bool) (b2:bool) : bool :='
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 andb (b1:bool) (b2:bool) : bool :='
- en: if b1 then b2 else false.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: if b1 then b2 else false.
- en: 'Definition orb (b1:bool) (b2:bool) : bool :='
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 orb (b1:bool) (b2:bool) : bool :='
- en: if b1 then true else b2.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: if b1 then true else b2.
- en: Unit tests
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'These test acheive complete coverage of orb:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试实现了 orb 的完全覆盖：
- en: 'Example test_orb1: (orb true false) = true.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '例子 test_orb1: (orb true false) = true.'
- en: Proof. reflexivity. Qed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。reflexivity. Qed.
- en: 'Example test_orb2: (orb false false) = false.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '例子 test_orb2: (orb false false) = false.'
- en: Proof. reflexivity. Qed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。reflexivity. Qed.
- en: 'Example test_orb3: (orb false true) = true.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '例子 test_orb3: (orb false true) = true.'
- en: Proof. reflexivity. Qed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。reflexivity. Qed.
- en: 'Example test_orb4: (orb true true) = true.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '例子 test_orb4: (orb true true) = true.'
- en: Proof. reflexivity. Qed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。reflexivity. Qed.
- en: Natural Numbers
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自然数
- en: 'The natural numbers in unary representation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以一元表示法表示的自然数：
- en: 'Inductive nat : Type :='
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳类型 nat : 类型 :='
- en: '| O : nat'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '| O : nat'
- en: '| S : nat → nat.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '| S : nat → nat.'
- en: 'The clauses of this definition can be read:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义的子句可以读作：
- en: O is a natural number (note that this is the letter "O," not the numeral "0").
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: O 是一个自��数（注意这是字母“O”，不是数字“0”）。
- en: S is a "constructor" that takes a natural number and yields another one — that
    is, if n is a natural number, then S n is too.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S 是一个“构造函数”，它接受一个自然数并产生另一个自然数 — 也就是说，如果 n 是一个自然数，那么 S n 也是。
- en: Two functions on numbers
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两个关于数字的函数
- en: 'Add one:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 加一：
- en: 'Definition succ (n : nat) : nat :='
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 succ (n : nat) : nat :='
- en: S n.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: S n。
- en: 'Subtract one:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 减去一个：
- en: (* requires: n >= 1 *)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: （需要：n ≥ 1）
- en: 'Definition pred (n : nat) : nat :='
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 pred (n : nat) : nat :='
- en: match n with
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 n 与
- en: '| O ⇒ O'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '| O ⇒ O'
- en: '| S n'' ⇒ n'''
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '| S n'' ⇒ n'''
- en: end.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: Syntactic sugar for numbers
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字的语法糖
- en: 'Arabic numerals can be used in input as a shorthand for sequences of applications
    of S to O, and Coq uses the same shorthand on output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 阿拉伯数字可以用作输入的简写，表示对 O 应用 S 的序列，Coq 在输出上也使用相同的简写：
- en: Check (S (S (S (S O)))).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 (S (S (S (S O)))。
- en: (* ===> 4 *)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: （===> 4）
- en: Eval compute in (pred 4).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 (pred 4) 中计算的结果。
- en: (* ===> 3 *)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: （===> 3）
- en: Recursive functions
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归函数
- en: 'Recursive functions are defined using Fixpoint instead of Definition:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数是使用 Fixpoint 定义的，而不是 Definition：
- en: 'Fixpoint evenb (n:nat) : bool :='
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fixpoint evenb (n:nat) : bool :='
- en: match n with
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 n 与
- en: '| O ⇒ true'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '| O ⇒ true'
- en: '| S O ⇒ false'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '| S O ⇒ false'
- en: '| S (S n'') ⇒ evenb n'''
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '| S (S n'') ⇒ evenb n'''
- en: end.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: 'We can define oddb in terms of evenb:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据 evenb 定义 oddb：
- en: 'Definition oddb (n:nat) : bool :='
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 oddb (n:nat) : bool :='
- en: negb (evenb n).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: negb (evenb n)。
- en: 'Example test_oddb1: (oddb 1) = true.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_oddb1: (oddb 1) = true。'
- en: Proof. reflexivity. Qed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。反射性。Qed。
- en: 'Example test_oddb2: (oddb 4) = false.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_oddb2: (oddb 4) = false。'
- en: Proof. reflexivity. Qed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。反射性。Qed。
- en: Arithmetic
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算术
- en: 'Fixpoint plus (n : nat) (m : nat) : nat :='
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fixpoint plus (n : nat) (m : nat) : nat :='
- en: match n with
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 n 与
- en: '| O ⇒ m'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '| O ⇒ m'
- en: '| S n'' ⇒ S (plus n'' m)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '| S n'' ⇒ S (plus n'' m)'
- en: end.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: 'When two arguments have the same type, we can list them together. (n m : nat)
    means the same as (n : nat) (m : nat).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '当两个参数具有相同类型时，我们可以将它们一起列出。（n m : nat）的意思与（n : nat）（m : nat）相同。'
- en: 'Fixpoint mult (n m : nat) : nat :='
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fixpoint mult (n m : nat) : nat :='
- en: match n with
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 n 与
- en: '| O ⇒ O'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '| O ⇒ O'
- en: '| S n'' ⇒ plus m (mult n'' m)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '| S n'' ⇒ plus m (mult n'' m)'
- en: end.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: 'Fixpoint minus (n m:nat) : nat :='
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fixpoint minus (n m:nat) : nat :='
- en: match n, m with
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 n, m 与
- en: '| O , _ ⇒ O'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '| O , _ ⇒ O'
- en: '| S _ , O ⇒ n'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '| S _ , O ⇒ n'
- en: '| S n'', S m'' ⇒ minus n'' m'''
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '| S n'', S m'' ⇒ minus n'' m'''
- en: end.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: Factorial
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阶乘
- en: 'Fixpoint factorial (n:nat) : nat :='
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fixpoint factorial (n:nat) : nat :='
- en: match n with
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 n 与
- en: '| O ⇒ 1'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '| O ⇒ 1'
- en: '| S n'' ⇒ mult n (factorial n'')'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '| S n'' ⇒ mult n (factorial n'')'
- en: end.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: 'Example test_factorial1: (factorial 3) = 6.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_factorial1: (factorial 3) = 6。'
- en: Proof. reflexivity. Qed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。反射性。Qed。
- en: 'Example test_factorial2: (factorial 5) = (mult 10 12).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_factorial2: (factorial 5) = (mult 10 12)。'
- en: Proof. reflexivity. Qed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。反射性。Qed。
- en: Extensible Syntax
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可扩展的语法
- en: Notation "x + y" := (plus x y)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 "x + y" := (plus x y)
- en: '(at level 50, left associativity) : nat_scope.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: （在级别 50，左结合性）：nat_scope。
- en: Notation "x - y" := (minus x y)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 "x - y" := (minus x y)
- en: '(at level 50, left associativity) : nat_scope.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: （在级别 50，左结合性）：nat_scope。
- en: Notation "x × y" := (mult x y)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 "x × y" := (mult x y)
- en: '(at level 40, left associativity) : nat_scope.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: （在级别 40，左结合性）：nat_scope。
- en: Check ((0 + 1) + 1).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 ((0 + 1) + 1)。
- en: 'A theorem about addition:'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有关加法的定理：
- en: 'Theorem plus_O_n : ∀ n : nat, 0 + n = n.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 plus_O_n: ∀ n : nat, 0 + n = n。'
- en: Proof. reflexivity. Qed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。反射性。Qed。
- en: Logic
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑
- en: 'Coq is also a proof assistant. Coq''s built-in logic has:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Coq 也是一个证明助手。Coq 的内置逻辑有：
- en: Inductive definitions
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归纳定义
- en: ∀ (universal quantification)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ∀（全称量化）
- en: → (implication)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: →（蕴含）
- en: that's it!
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就是这样！
- en: Everything else ('and', 'or', 'negation', 'equals', ...) can be coded up, and
    is in the standard library.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 其他所有内容（'and'，'or'，'否定'，'等于'，...）都可以编码，并且在标准库中。
- en: Propositions
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命题
- en: 'In Coq, the type of things that can (potentially) be proven is Prop.Here is
    an example of a provable proposition:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Coq 中，可以（潜在地）被证明的事物的类型是 Prop。这里有一个可证明的命题的示例：
- en: Check (3 = 3).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 (3 = 3)。
- en: (* ===> Prop *)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: （===> Prop）
- en: 'Here is an example of an unprovable proposition:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个无法证明的命题的示例：
- en: Check (∀ (n:nat), n = 2).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 (∀ (n:nat), n = 2)。
- en: (* ===> Prop *)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: （===> Prop）
- en: Values of type Prop
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型 Prop 的值
- en: Types are *inhabited* by values.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 类型由值*居住*。
- en: true and false inhabit bool.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: true 和 false 居住于 bool。
- en: 0, 1, ... inhabit nat.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0, 1, ... 居住于 nat。
- en: what inhabits Prop?
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么居住于 Prop？
- en: The propositions we try to prove!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图证明的命题！
- en: e.g., 0×3 = 0 inhabits Prop.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，0×3 = 0 居住于 Prop。
- en: But propositions are just another kind of type...
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 但命题只是另一种类型...
- en: what inhabits the type 0×3 = 0?
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么居住于类型 0×3 = 0？
- en: A proof that provides evidence that 0×3 = 0!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一个提供证据表明 0×3 = 0! 的证明。
- en: Proofs
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 证明
- en: Propositions are inhabited by *proof objects* aka *proof terms*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 命题由*证明对象*或*证明项*所居住。
- en: 'Lemma silly : 0 × 3 = 0.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 silly: 0 × 3 = 0。'
- en: Proof. reflexivity. Qed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。反射性。Qed。
- en: Print silly.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 silly。
- en: (* ===> silly = eq_refl : 0 * 3 = 0 *)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '（===> silly = eq_refl : 0 * 3 = 0）'
- en: (Here, the eq_refl proof object provides evidence for the equality. We'll come
    back to how it does that...)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: （在这里，eq_refl 证明对象提供了相等性的证据。我们将回到它是如何做到的...）
- en: Constructing proof objects
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造证明对象
- en: 'We could even have written the proof object ourselves:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以自己编写证明对象：
- en: 'Definition silly'' : 0 × 3 = 0 :='
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 silly'' : 0 × 3 = 0 :='
- en: eq_refl.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: eq_refl。
- en: Print silly'.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 silly'。
- en: Print silly.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 silly。
- en: (* ===> silly' = eq_refl : 0 * 3 = 0 *)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> 愚蠢' = eq_refl : 0 * 3 = 0 *)
- en: (* ===> silly = eq_refl : 0 * 3 = 0 *)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> silly = eq_refl : 0 * 3 = 0 *)
- en: 'These mean the same thing:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些意思相同：
- en: 'Lemma name : prop. Proof. *tactics* Qed.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '引理 name : prop。 证明。 *tactics* Qed。'
- en: 'Definition name : prop := *proof object* .'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义名称：prop := *proof object* 。
- en: The first form lets us *interactively* build a proof object, the latter requires
    us to state it all at once.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种形式让我们 *交互式* 构建证明对象，后者要求我们一次性陈述所有内容。
- en: Another Proof Object
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另一个证明对象
- en: Print plus_O_n.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 plus_O_n。
- en: (* ===> plus_O_n =
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> plus_O_n =
- en: fun n : nat
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: fun n : nat
- en: => eq_refl
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: => eq_refl
- en: : forall n : nat, 0 + n = n *)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: : forall n : nat, 0 + n = n *)
- en: This proof object is a function that takes in n and returns a proof object eq_refl.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个证明对象是一个函数，它接受 n 并返回一个证明对象 eq_refl。
- en: Reading Coq
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读 Coq
- en: 'We read name = expr : type the same, whether the type is Prop or Type.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取 name = expr：type 是一样的，无论类型是 Prop 还是 Type。
- en: Print andb.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 andb。
- en: (* ===> andb =
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> andb =
- en: fun b1 b2 : bool
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: fun b1 b2 : bool
- en: => if b1 then b2 else false
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: => if b1 then b2 else false
- en: : bool -> bool -> bool *)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: : bool -> bool -> bool *)
- en: Print plus_O_n.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 plus_O_n。
- en: (* ===> plus_O_n =
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> plus_O_n =
- en: fun n : nat
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: fun n : nat
- en: => eq_refl
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: => eq_refl
- en: : forall n : nat, 0 + n = n *)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: : forall n : nat, 0 + n = n *)
- en: Coq unifies the notions of
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Coq 统一了 Prop 和 Type 的概念
- en: types with formulas, and
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公式的类型，以及
- en: programs with proofs.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有证明的程序。
- en: Coq's Connectives
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Coq 的连接词
- en: 'Same connectives we saw in IQC:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 IQC 中看到的相同连接词：
- en: Implication ⇒
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蕴涵 ⇒
- en: Universal quantification ∀
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全称量化 ∀
- en: Conjunction ∧
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合取 ∧
- en: Disjunction ∨
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 析取 ∨
- en: True and False
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真和假
- en: Negation ¬
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否定 ¬
- en: Existential quantification ∃
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在量化 ∃
- en: Equality =
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等号 =
- en: Implies and forall
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暗示和全称
- en: 'These are the built-in connectives in Coq.Coq treats both connectives the same
    way:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 Coq 中的内置连接词。Coq 对待这两个连接词的方式是一样的：
- en: The proof object for P → Q is a *function* that takes evidence for P as input
    and produces evidence for Q as output.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 P → Q 的证明对象是一个 *函数*，它以 P 的证据作为输入并产生 Q 的证据作为输出。
- en: The proof object for ∀ x, P is a *function* that takes x as input and produces
    evidence for P as output.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 ∀ x，P 的证明对象是一个 *函数*，它以 x 作为输入并产生 P 的证据作为输出。
- en: Implies and forall intro
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暗示与全称介绍
- en: The introduction rules in IQC corresponds to the intros tactic in Coq.The intros
    tactic moves one or more quantifiers or hypotheses from the goal to a "context"
    of current assumptions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IQC 中的引入规则对应于 Coq 中的 intros 策略。intros 策略将一个或多个量词或假设从目标移到当前假设的“上下文”中。
- en: 'Lemma imp_intro : (1 + 1) = 2 → 0 × 3 = 0.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 imp_intro : (1 + 1) = 2 → 0 × 3 = 0。'
- en: Proof. intros H. reflexivity. Qed.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 intros H。反射性。 Qed。
- en: Print imp_intro.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 imp_intro。
- en: (* ===> imp_intro =
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> imp_intro =
- en: fun _ : 1 + 1 = 2 => eq_refl
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: fun _ : 1 + 1 = 2 => eq_refl
- en: : 1 + 1 = 2 -> 0 * 3 = 0 *)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: : 1 + 1 = 2 -> 0 * 3 = 0 *)
- en: The proof object takes in evidence for 1+1=2, discards that evidence, and returns
    evidence for 0×3=0.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 该证明对象接受 1+1=2 的证据，丢弃该证据，并返回 0×3=0 的证据。
- en: 'Lemma forall_intro : ∀ (n:nat), n = n.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 forall_intro : ∀ (n:nat), n = n。'
- en: Proof. intros n. reflexivity. Qed.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 intros n。反射性。 Qed。
- en: Print forall_intro.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 forall_intro。
- en: (* ===> forall_intro =
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> forall_intro =
- en: fun n : nat => eq_refl
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: fun n : nat => eq_refl
- en: : forall n : nat, n = n *)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: : forall n : nat, n = n *)
- en: The proof object takes in n, and returns evidence for n=n.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 证明对象接受 n，并返回 n=n 的证据。
- en: Implies and forall elim
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暗示和全称消除
- en: The elimination rules *for these connectives* in IQC correspond to the apply
    tactic in Coq.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IQC 中，*这些连接词* 的消除规则对应于 Coq 中的 apply 策略。
- en: 'Lemma imp_elim : ∀ (P Q : Prop), P → (P→Q) → Q.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 imp_elim : ∀ (P Q : Prop), P → (P→Q) → Q。'
- en: Proof.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros P Q. intros HP HPimpQ.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: intros P Q。 intros HP HPimpQ。
- en: apply HPimpQ. assumption.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 HPimpQ。 假设。
- en: Qed.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: Print imp_elim.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 imp_elim。
- en: (* ===> imp_elim = fun (P Q : Prop) (HP : P)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> imp_elim = fun (P Q : Prop) (HP : P)
- en: (HPimpQ : P -> Q)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: (HPimpQ : P -> Q)
- en: => HPimpQ HP
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: => HPimpQ HP
- en: : forall P Q : Prop,
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: : forall P Q : Prop，
- en: P -> (P -> Q) -> Q *)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: P -> (P -> Q) -> Q *)
- en: 'Note:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: The assumption tactic corresponds to the IQC assumption rule.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设策略对应于 IQC 的假设规则。
- en: The proof object applies a function. Implication elimination is really function
    application!
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证明对象应用一个函数。蕴涵消除实际上是函数应用！
- en: 'Lemma forall_elim : (∀ (n:nat), n=0) → 1=0.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 forall_elim : (∀ (n:nat), n=0) → 1=0。'
- en: Proof. intros H. apply H with (n:=1). Qed.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 intros H。使用 (n:=1) 应用 H。 Qed。
- en: Print forall_elim.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 forall_elim。
- en: (* ===> forall_elim =
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> forall_elim =
- en: fun H : forall n : nat, n = 0 => H 1
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: fun H : forall n : nat, n = 0 => H 1
- en: : (forall n : nat, n = 0) -> 1 = 0 *)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: : (forall n : nat, n = 0) -> 1 = 0 *)
- en: Conjunction
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合取
- en: 'Logical conjunction is not built-in to the language, though it''s available
    in the standard library.Conjunction is a binary operator on propositions:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑连接在语言中不是内置的，尽管它在标准库中是可用的。连接是命题上的二元运算符：
- en: 'Inductive and (P Q : Prop) : Prop :='
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳性和（P Q：命题）：命题：=
- en: 'conj : P → Q → (and P Q).'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: conj：P → Q →（and P Q）。
- en: 'Notation "P ∧ Q" := (and P Q) : type_scope.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 符号"P ∧ Q"：=（and P Q）：type_scope。
- en: And intro
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: And intro
- en: And intro in IQC corresponds to applying the conj constructor in Coq.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: And intro 在 IQC 中对应于在 Coq 中应用 conj 构造函数。
- en: 'Theorem and_intro :'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 and_intro：
- en: (0 = 0) ∧ (4 = mult 2 2).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: (0 = 0) ∧ (4 = mult 2 2)。
- en: Proof.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: apply conj. reflexivity. reflexivity. Qed.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: apply conj。reflexivity。reflexivity。Qed。
- en: Print and_intro.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 and_intro。
- en: (* ===>  and_intro =
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> and_intro =
- en: conj (0 = 0) (4 = 2 * 2)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: conj (0 = 0) (4 = 2 * 2)
- en: eq_refl eq_refl
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: eq_refl eq_refl
- en: : 0 = 0 /\ 4 = 2 * 2 *)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ：0 = 0 /\ 4 = 2 * 2 *)
- en: And elim
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: And elim
- en: And elim in IQC corresponds to the inversion tactic in Coq, which breaks apart
    the evidence for a Prop into smaller pieces of evidence.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IQC 中的 And elim 对应于 Coq 中的反演策略，它将一个命题的证据拆分成更小的证据片段。
- en: 'Theorem and_elim : ∀ P Q : Prop,'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 and_elim：∀ P Q：命题，
- en: P ∧ Q → P.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: P ∧ Q → P。
- en: Proof.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros P Q H.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 推导 P Q H。
- en: inversion H as [HP HQ].
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 [HP HQ] 的反演 H。
- en: apply HP.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: apply HP。
- en: Qed.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: A proof we did in IQC
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们在 IQC 中完成的一个证明
- en: 'Theorem and_commut : ∀ P Q : Prop,'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 and_commut：∀ P Q：命题，
- en: P ∧ Q → Q ∧ P.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: P ∧ Q → Q ∧ P。
- en: Proof.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros P Q H.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 推导 P Q H。
- en: inversion H as [HP HQ].
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 [HP HQ] 的反演 H。
- en: apply conj.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: apply conj。
- en: apply HQ.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 HQ。
- en: apply HP.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: apply HP。
- en: Qed.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: Writing tactics is the "assembly language" programming of Coq. There are automated
    tactics that find proofs for us!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 编写策略就像是 Coq 的"汇编语言"编程一样。有自动化策略可以为我们找到证明！
- en: 'Theorem and_commut'' : ∀ P Q : Prop,'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 and_commut'：∀ P Q：命题，
- en: P ∧ Q → Q ∧ P.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: P ∧ Q → Q ∧ P。
- en: Proof. firstorder. Qed.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。firstorder。Qed。
- en: Disjunction
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 析取
- en: 'Inductive or (P Q : Prop) : Prop :='
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳性或（P Q：命题）：命题：=
- en: '| or_introl : P → or P Q'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '| or_introl：P → or P Q'
- en: '| or_intror : Q → or P Q.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '| or_intror：Q → or P Q。'
- en: 'Notation "P ∨ Q" := (or P Q) : type_scope.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 符号"P ∨ Q"：=（or P Q）：type_scope。
- en: Check or_introl.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 or_introl。
- en: (* ===>  forall P Q : Prop, P -> P \/ Q *)
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '(* ===> forall P Q : 命题， P -> P \/ Q *)'
- en: Check or_intror.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 or_intror。
- en: (* ===>  forall P Q : Prop, Q -> P \/ Q *)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '（* ===> forall P Q : 命题， Q -> P \/ Q *）'
- en: A proof we did in IQC
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们在 IQC 中完成的一个证明
- en: 'Theorem or_commut : ∀ P Q : Prop,'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 or_commut：∀ P Q：命题，
- en: P ∨ Q → Q ∨ P.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: P ∨ Q → Q ∨ P。
- en: Proof.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros P Q H.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 推导 P Q H。
- en: inversion H as [HP | HQ].
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 [HP | HQ] 的反演 H。
- en: apply or_intror. apply HP.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 or_intror。apply HP。
- en: apply or_introl. apply HQ.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: apply or_introl。apply HQ。
- en: Qed.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: 'We could even write down an explicit proof object for or_commut without using
    tactics to construct it:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在不使用策略来构造它的情况下为 or_commut 写下一个明确的证明对象：
- en: 'Definition or_commut'' : ∀ P Q,'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 or_commut'：∀ P Q，
- en: P ∨ Q → Q ∨ P
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: P ∨ Q → Q ∨ P
- en: :=
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: :=
- en: 'fun (P Q : Prop) (H : P ∨ Q) ⇒'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: fun（P Q：命题）（H：P ∨ Q）⇒
- en: match H with
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 H，其中
- en: '| or_introl HP ⇒ or_intror Q P HP'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '| or_introl HP ⇒ or_intror Q P HP'
- en: '| or_intror HQ ⇒ or_introl Q P HQ'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '| or_intror HQ ⇒ or_introl Q P HQ'
- en: end.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: end。
- en: Or we could let Coq find the proof.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以让 Coq 找到证明。
- en: 'Theorem or_commut'''' : ∀ P Q : Prop,'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 or_commut''：∀ P Q：命题，
- en: P ∨ Q → Q ∨ P.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: P ∨ Q → Q ∨ P。
- en: Proof. firstorder. Qed.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。firstorder。Qed。
- en: True and False
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: True 和 False
- en: True has a single constructor that takes no arguments.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: True 具有一个不带参数的单个构造函数。
- en: 'Inductive True : Prop :='
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳性 True：命题：=
- en: 'I : True.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: I：True。
- en: 'False has no constructors. Intuition: False is a proposition for which there
    is no way to give evidence.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: False 没有构造函数。直觉：False 是一个没有办法提供证据的命题。
- en: 'Inductive False : Prop := .'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳性 False：命题：=。
- en: Proofs with True and False
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有 True 和 False 的证明
- en: Applying the I constructor corresponds to IQC's true intro.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 I 构造函数对应于 IQC 的 true intro。
- en: 'Theorem True_is_provable : True.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 True_is_provable：True。
- en: Proof. apply I. Qed.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。应用 I。Qed。
- en: Once we have False as an assumption, the contradiction tactic lets us conclude
    whatever we want. That corresponds to IQC's false elim.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们假设 False，矛盾策略就让我们能够得出任何我们想要的结论。这对应于 IQC 的 false elim。
- en: 'Theorem False_implies_nonsense :'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 False_implies_nonsense：
- en: False → 2 + 2 = 5.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: False → 2 + 2 = 5。
- en: Proof.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros. contradiction.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: intros。矛盾。
- en: Qed.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: 'Theorem exfalso : ∀ (P:Prop),'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 exfalso：∀（P：命题），
- en: False → P.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: False → P。
- en: Proof.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros. contradiction.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: intros。矛盾。
- en: Qed.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: Negation
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 否定
- en: Negation is defined in Coq exactly as in IQC. The fold and unfold tactics let
    us convert between ¬P and P→False.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 否定在 Coq 中的定义与 IQC 中完全相同。fold 和 unfold 策略让我们在 ¬P 和 P→False 之间转换。
- en: Definition not (P:Prop) := P → False.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 not（P：命题）：= P → False。
- en: 'Notation "¬ x" := (not x) : type_scope.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 符号"¬ x"：=（not x）：type_scope。
- en: 'Theorem not_False : ¬ False.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 not_False：¬ False。
- en: Proof. unfold not. apply exfalso. Qed.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。展开 not。应用 exfalso。Qed。
- en: 'Theorem contradiction_implies_anything :'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 contradiction_implies_anything：
- en: '∀ P Q : Prop, (P ∧ ¬P) → Q.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: ∀ P Q：命题，（P ∧ ¬P）→ Q。
- en: Proof. firstorder. Qed.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。firstorder。Qed。
- en: Existential Quantification
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存在量词
- en: 'Inductive ex (X:Type) (P : X→Prop) : Prop :='
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳定义 ex (X:Type) (P : X→Prop) : Prop :='
- en: 'ex_intro : ∀ (witness:X), P witness → ex X P.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 'ex_intro : ∀ (witness:X), P witness → ex X P。'
- en: To give evidence we must actually name a *witness* a specific value x — and
    then give evidence for P x.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供证据，我们必须实际命名一个*见证者*，即一个特定的值 x — 然后为 P x 提供证据。
- en: Notation "'exists' x , p" := (ex _ (fun x ⇒ p))
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 符号"'exists' x , p"的意思是(ex _ (fun x ⇒ p))
- en: '(at level 200, x ident, right associativity) : type_scope.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '(at level 200, x ident, right associativity) : type_scope。'
- en: 'Notation "''exists'' x : X , p" := (ex _ (fun x:X ⇒ p))'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '符号 "''exists'' x : X , p" 的意思是 (ex _ (fun x:X ⇒ p))'
- en: '(at level 200, x ident, right associativity) : type_scope.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '(at level 200, x ident, right associativity) : type_scope。'
- en: Proof with exists
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Proof with exists
- en: The ex_intro constructor corresponds to IQC's exists intro.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ex_intro 构造子对应于 IQC 的 exists intro。
- en: 'Example exists_example_1 :'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 例如 exists_example_1：
- en: ∃ n, n + (n × n) = 6.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: ∃ n, n + (n × n) = 6。
- en: Proof.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: apply ex_intro with (witness:=2).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 ex_intro with (witness:=2)。
- en: reflexivity.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: reflexivity。
- en: Qed.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: Note that we explicitly give the witness.We'll omit exists elimination, though
    it also is in Coq.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们明确给出了证人。尽管在 Coq 中它也是存在的，但我们将省略存在消除。
- en: A proof we did in IQC
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 IQC 中我们做的一个证明
- en: 'Theorem dist_exists_or : ∀ (X:Type) (P Q : X → Prop),'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 dist_exists_or : ∀ (X:Type) (P Q : X → Prop),'
- en: (∃ x, P x ∨ Q x) ↔ (∃ x, P x) ∨ (∃ x, Q x).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: (∃ x, P x ∨ Q x) ↔ (∃ x, P x) ∨ (∃ x, Q x)。
- en: Proof.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: firstorder.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: firstorder。
- en: Qed.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: Equality
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相等性
- en: The equality relation is definable, not built-in to the language.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 相等关系是可定义的，不是内置到语言中的。
- en: 'Inductive eq {X:Type} : X → X → Prop :='
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳定义 eq {X:Type} : X → X → Prop :='
- en: 'refl_equal : ∀ x, eq x x.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 'refl_equal : ∀ x, eq x x。'
- en: Notation "x = y" := (eq x y)
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 "x = y" 的意思是 (eq x y)
- en: '(at level 70, no associativity) : type_scope.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '(at level 70, no associativity) : type_scope。'
- en: 'Lemma four: 2 + 2 = 1 + 3.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 引理 four：2 + 2 = 1 + 3。
- en: Proof.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: apply refl_equal.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 refl_equal。
- en: Qed.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: reflexivity is essentially just apply refl_equal.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 反射性基本上就是应用 refl_equal。
- en: Excluded middle
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排中律
- en: Note that some theorems that are true in classical logic are *not* provable
    in Coq's (constructive) logic. E.g., let's look at how this proof gets stuck...
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一些在经典逻辑中为真的定理在 Coq 的（构造性）逻辑中*不能*被证明。例如，让我们看看这个证明如何陷入困境...
- en: 'Theorem excluded_middle : ∀ P : Prop,'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 excluded_middle : ∀ P : Prop,'
- en: P ∨ ¬P.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: P ∨ ¬P。
- en: Proof.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros P. unfold not.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: intros P。 展开 not。
- en: (* We either have to go left or right... *)
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: (* 我们要么向左走要么向右走... *)
- en: left. (* But now what?  We don't have evidence for P. *)
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: left. (* 现在呢？我们没有 P 的证据。 *)
- en: Undo.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 撤销。
- en: right. intros HP. (* And now we don't have evidence for False. *)
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: right。 intros HP。 (* 现在我们没有 False 的证据了。 *)
- en: Abort.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 中止。
- en: Proofs from IPC and IQC
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPC 和 IQC 中的证明
- en: Here are Coq proofs for all the theorems we proved in IQC and IPC. The firstorder
    tactic searches for, and finds, a proof object for each of these theorems. You
    can enter Print <theorem_name> to see that object.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们在 IQC 和 IPC 中证明的所有定理的 Coq 证明。firstorder 策略搜索并找到了每个定理的证明对象。您可以输入 Print <theorem_name>
    来查看该对象。
- en: 'Theorem lec19thm1 : ∀ (A B : Prop),'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 lec19thm1 : ∀ (A B : Prop),'
- en: A → (B → A).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: A → (B → A)。
- en: Proof. firstorder. Qed.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 firstorder。 Qed。
- en: 'Theorem lec19thm2 : ∀ (A B : Prop),'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 lec19thm2 : ∀ (A B : Prop),'
- en: A → (B → (A ∧ B)).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: A → (B → (A ∧ B))。
- en: Proof. firstorder. Qed.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 firstorder。 Qed。
- en: 'Theorem lec19thm3 : ∀ (A B : Prop),'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 lec19thm3 : ∀ (A B : Prop),'
- en: (A ∨ B) → (B ∨ A).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: (A ∨ B) → (B ∨ A)。
- en: Proof. firstorder. Qed.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 firstorder。 Qed。
- en: 'Theorem rec18thm1 : ∀ (A B : Prop),'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 rec18thm1 : ∀ (A B : Prop),'
- en: (A ∧ B) → A.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: (A ∧ B) → A。
- en: Proof. firstorder. Qed.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 firstorder。 Qed。
- en: 'Theorem rec18thm2 : ∀ (A B : Prop),'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 rec18thm2 : ∀ (A B : Prop),'
- en: (A ∧ B) → (B ∧ A).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: (A ∧ B) → (B ∧ A)。
- en: Proof. firstorder. Qed.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 firstorder。 Qed。
- en: 'Theorem rec18thm3 : ∀ (A B C : Prop),'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 rec18thm3 : ∀ (A B C : Prop),'
- en: (A → B) → ((B→C) → (A→C)).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: (A → B) → ((B→C) → (A→C))。
- en: Proof. firstorder. Qed.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 firstorder。 Qed。
- en: 'Theorem rec18thm4 : ∀ (S C O : Prop),'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 rec18thm4 : ∀ (S C O : Prop),'
- en: ((S→C) ∧ O ∧ ((O->~C) ∧ (C->~O))) → ¬S.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: ((S→C) ∧ O ∧ ((O->~C) ∧ (C->~O))) → ¬S。
- en: Proof. firstorder. Qed.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 firstorder。 Qed。
- en: 'Theorem lec21thm1 : ∀ (Q R : Type → Prop),'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 lec21thm1 : ∀ (Q R : Type → Prop),'
- en: (∀ x, R(x) ∧ Q(x)) → (∀ x, R(x)) ∧ (∀ x, Q(x)).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: (∀ x, R(x) ∧ Q(x)) → (∀ x, R(x)) ∧ (∀ x, Q(x))。
- en: Proof. firstorder. Qed.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 firstorder。 Qed。
- en: 'Theorem lec21thm2 : ∀ (Q R : Type → Prop),'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 lec21thm2 : ∀ (Q R : Type → Prop),'
- en: (∃ x, Q(x) ∨ R(x)) → (∃ x, R(x)) ∨ (∃ x, Q(x)).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: (∃ x, Q(x) ∨ R(x)) → (∃ x, R(x)) ∨ (∃ x, Q(x))。
- en: Proof. firstorder. Qed.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 firstorder。 Qed。
- en: 'Theorem rec19thm1 : ∀ (A B : Prop),'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 rec19thm1 : ∀ (A B : Prop),'
- en: ((A → B) ∧ ¬B) → ¬A.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: ((A → B) ∧ ¬B) → ¬A。
- en: Proof. firstorder. Qed.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 firstorder。 Qed。
- en: 'Theorem rec19thm2 : ∀ (A B : Prop),'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 rec19thm2 : ∀ (A B : Prop),'
- en: (A → (B ∨ (A → B))) → (A → B).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: (A → (B ∨ (A → B))) → (A → B)。
- en: Proof. firstorder. Qed.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 firstorder。 Qed。
- en: 'Theorem rec19thm3 : ∀ (A B : Prop),'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 rec19thm3 : ∀ (A B : Prop),'
- en: ~((~A ∨ ¬B) ∧ (A ∧ B)).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: ~((~A ∨ ¬B) ∧ (A ∧ B))。
- en: Proof. firstorder. Qed.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 firstorder。 Qed。
- en: 'Theorem rec19thm4 : ∀ (P Q : Type → Prop),'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 rec19thm4 : ∀ (P Q : Type → Prop),'
- en: '(∀ (x y : Type), (P(x) → Q(y))) ∧ (∃ x, P(x))'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: （∀（x y：Type），（P（x）→Q（y）））∧（∃x，P（x））
- en: → (∃ y, Q(y)).
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: →（∃y，Q（y））。
- en: Proof. firstorder. Qed.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。firstorder。Qed。
- en: 'Theorem rec19thm5 : ∀ (P Q : Type → Prop),'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 定理rec19thm5：∀（P Q：Type → Prop），
- en: (∀ x, P(x)) → (∀ x, Q(x)) → (∀ x, (P(x) ↔ Q(x))).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: （∀x，P（x））→（∀x，Q（x））→（∀x，（P（x）↔Q（x）））。
- en: Proof. firstorder. Qed.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。firstorder。Qed。
- en: '* * *'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[Index](coqindex.html)'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[索引](coqindex.html)'
- en: '* * *'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: This page has been generated by [coqdoc](http://www.lix.polytechnique.fr/coq/)
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面由[coqdoc](http://www.lix.polytechnique.fr/coq/)生成。
