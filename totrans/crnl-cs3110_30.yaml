- en: Coq3110An Introduction to Coq for CS 3110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This material is based on an online textbook by Benjamin Pierce et al. titled
    "Software Foundations":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Inductive Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Coq is a functional programming language. We can define data types, just like
    in OCaml. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Days of the week
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Natural numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Days of the Week
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A datatype definition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive day : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| monday : day'
  prefs: []
  type: TYPE_NORMAL
- en: '| tuesday : day'
  prefs: []
  type: TYPE_NORMAL
- en: '| wednesday : day'
  prefs: []
  type: TYPE_NORMAL
- en: '| thursday : day'
  prefs: []
  type: TYPE_NORMAL
- en: '| friday : day'
  prefs: []
  type: TYPE_NORMAL
- en: '| saturday : day'
  prefs: []
  type: TYPE_NORMAL
- en: '| sunday : day.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function on days:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition next_weekday (d:day) : day :='
  prefs: []
  type: TYPE_NORMAL
- en: match d with
  prefs: []
  type: TYPE_NORMAL
- en: '| monday ⇒ tuesday'
  prefs: []
  type: TYPE_NORMAL
- en: '| tuesday ⇒ wednesday'
  prefs: []
  type: TYPE_NORMAL
- en: '| wednesday ⇒ thursday'
  prefs: []
  type: TYPE_NORMAL
- en: '| thursday ⇒ friday'
  prefs: []
  type: TYPE_NORMAL
- en: '| friday ⇒ monday'
  prefs: []
  type: TYPE_NORMAL
- en: '| saturday ⇒ monday'
  prefs: []
  type: TYPE_NORMAL
- en: '| sunday ⇒ monday'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: Check checks the type of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Check next_weekday.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> next_weekday : day -> day *)
  prefs: []
  type: TYPE_NORMAL
- en: Computation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Eval compute in e evaluates e and prints the result, much like entering e into
    the REPL in OCaml.
  prefs: []
  type: TYPE_NORMAL
- en: Eval compute in (next_weekday friday).
  prefs: []
  type: TYPE_NORMAL
- en: (* ==> monday : day *)
  prefs: []
  type: TYPE_NORMAL
- en: Eval compute in (next_weekday (next_weekday saturday)).
  prefs: []
  type: TYPE_NORMAL
- en: (* ==> tuesday : day *)
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A "unit test" for our function — i.e., a mathematical claim about its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_next_weekday:'
  prefs: []
  type: TYPE_NORMAL
- en: (next_weekday (next_weekday saturday)) = tuesday.
  prefs: []
  type: TYPE_NORMAL
- en: 'A proof script giving evidence for the claim:'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity is a *tactic* that is built into Coq. In essence, it applies Coq's
    computational rules (i.e., dynamic semantics) to both side of the = sign. Then
    it compares to see whether both sides reduced to the same value. If so, that counts
    as evidence that the equality holds.
  prefs: []
  type: TYPE_NORMAL
- en: Extraction into OCaml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Extraction day.
  prefs: []
  type: TYPE_NORMAL
- en: (* type day =
  prefs: []
  type: TYPE_NORMAL
- en: '| Monday'
  prefs: []
  type: TYPE_NORMAL
- en: '... *)'
  prefs: []
  type: TYPE_NORMAL
- en: Extraction next_weekday.
  prefs: []
  type: TYPE_NORMAL
- en: (* let next_weekday = function
  prefs: []
  type: TYPE_NORMAL
- en: '| Monday -> Tuesday'
  prefs: []
  type: TYPE_NORMAL
- en: '... *)'
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A familiar datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive bool : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| true : bool'
  prefs: []
  type: TYPE_NORMAL
- en: '| false : bool.'
  prefs: []
  type: TYPE_NORMAL
- en: Booleans are also provided in Coq's standard library, but we are defining from
    scratch, just to see how it's done.
  prefs: []
  type: TYPE_NORMAL
- en: Functions on booleans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can code these up with using any built-in boolean operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition negb (b:bool) : bool :='
  prefs: []
  type: TYPE_NORMAL
- en: match b with
  prefs: []
  type: TYPE_NORMAL
- en: '| true ⇒ false'
  prefs: []
  type: TYPE_NORMAL
- en: '| false ⇒ true'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: Coq has an if expression that we could use instead of pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition andb (b1:bool) (b2:bool) : bool :='
  prefs: []
  type: TYPE_NORMAL
- en: if b1 then b2 else false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition orb (b1:bool) (b2:bool) : bool :='
  prefs: []
  type: TYPE_NORMAL
- en: if b1 then true else b2.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These test acheive complete coverage of orb:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_orb1: (orb true false) = true.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_orb2: (orb false false) = false.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_orb3: (orb false true) = true.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_orb4: (orb true true) = true.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Natural Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The natural numbers in unary representation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive nat : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| O : nat'
  prefs: []
  type: TYPE_NORMAL
- en: '| S : nat → nat.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The clauses of this definition can be read:'
  prefs: []
  type: TYPE_NORMAL
- en: O is a natural number (note that this is the letter "O," not the numeral "0").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S is a "constructor" that takes a natural number and yields another one — that
    is, if n is a natural number, then S n is too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two functions on numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition succ (n : nat) : nat :='
  prefs: []
  type: TYPE_NORMAL
- en: S n.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subtract one:'
  prefs: []
  type: TYPE_NORMAL
- en: (* requires: n >= 1 *)
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition pred (n : nat) : nat :='
  prefs: []
  type: TYPE_NORMAL
- en: match n with
  prefs: []
  type: TYPE_NORMAL
- en: '| O ⇒ O'
  prefs: []
  type: TYPE_NORMAL
- en: '| S n'' ⇒ n'''
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: Syntactic sugar for numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arabic numerals can be used in input as a shorthand for sequences of applications
    of S to O, and Coq uses the same shorthand on output:'
  prefs: []
  type: TYPE_NORMAL
- en: Check (S (S (S (S O)))).
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> 4 *)
  prefs: []
  type: TYPE_NORMAL
- en: Eval compute in (pred 4).
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> 3 *)
  prefs: []
  type: TYPE_NORMAL
- en: Recursive functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recursive functions are defined using Fixpoint instead of Definition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixpoint evenb (n:nat) : bool :='
  prefs: []
  type: TYPE_NORMAL
- en: match n with
  prefs: []
  type: TYPE_NORMAL
- en: '| O ⇒ true'
  prefs: []
  type: TYPE_NORMAL
- en: '| S O ⇒ false'
  prefs: []
  type: TYPE_NORMAL
- en: '| S (S n'') ⇒ evenb n'''
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define oddb in terms of evenb:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition oddb (n:nat) : bool :='
  prefs: []
  type: TYPE_NORMAL
- en: negb (evenb n).
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_oddb1: (oddb 1) = true.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_oddb2: (oddb 4) = false.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fixpoint plus (n : nat) (m : nat) : nat :='
  prefs: []
  type: TYPE_NORMAL
- en: match n with
  prefs: []
  type: TYPE_NORMAL
- en: '| O ⇒ m'
  prefs: []
  type: TYPE_NORMAL
- en: '| S n'' ⇒ S (plus n'' m)'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'When two arguments have the same type, we can list them together. (n m : nat)
    means the same as (n : nat) (m : nat).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixpoint mult (n m : nat) : nat :='
  prefs: []
  type: TYPE_NORMAL
- en: match n with
  prefs: []
  type: TYPE_NORMAL
- en: '| O ⇒ O'
  prefs: []
  type: TYPE_NORMAL
- en: '| S n'' ⇒ plus m (mult n'' m)'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixpoint minus (n m:nat) : nat :='
  prefs: []
  type: TYPE_NORMAL
- en: match n, m with
  prefs: []
  type: TYPE_NORMAL
- en: '| O , _ ⇒ O'
  prefs: []
  type: TYPE_NORMAL
- en: '| S _ , O ⇒ n'
  prefs: []
  type: TYPE_NORMAL
- en: '| S n'', S m'' ⇒ minus n'' m'''
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: Factorial
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fixpoint factorial (n:nat) : nat :='
  prefs: []
  type: TYPE_NORMAL
- en: match n with
  prefs: []
  type: TYPE_NORMAL
- en: '| O ⇒ 1'
  prefs: []
  type: TYPE_NORMAL
- en: '| S n'' ⇒ mult n (factorial n'')'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_factorial1: (factorial 3) = 6.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_factorial2: (factorial 5) = (mult 10 12).'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Extensible Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notation "x + y" := (plus x y)
  prefs: []
  type: TYPE_NORMAL
- en: '(at level 50, left associativity) : nat_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Notation "x - y" := (minus x y)
  prefs: []
  type: TYPE_NORMAL
- en: '(at level 50, left associativity) : nat_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Notation "x × y" := (mult x y)
  prefs: []
  type: TYPE_NORMAL
- en: '(at level 40, left associativity) : nat_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Check ((0 + 1) + 1).
  prefs: []
  type: TYPE_NORMAL
- en: 'A theorem about addition:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Theorem plus_O_n : ∀ n : nat, 0 + n = n.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Coq is also a proof assistant. Coq''s built-in logic has:'
  prefs: []
  type: TYPE_NORMAL
- en: Inductive definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ∀ (universal quantification)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: → (implication)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: that's it!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything else ('and', 'or', 'negation', 'equals', ...) can be coded up, and
    is in the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Propositions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Coq, the type of things that can (potentially) be proven is Prop.Here is
    an example of a provable proposition:'
  prefs: []
  type: TYPE_NORMAL
- en: Check (3 = 3).
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> Prop *)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of an unprovable proposition:'
  prefs: []
  type: TYPE_NORMAL
- en: Check (∀ (n:nat), n = 2).
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> Prop *)
  prefs: []
  type: TYPE_NORMAL
- en: Values of type Prop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Types are *inhabited* by values.
  prefs: []
  type: TYPE_NORMAL
- en: true and false inhabit bool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0, 1, ... inhabit nat.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: what inhabits Prop?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The propositions we try to prove!
  prefs: []
  type: TYPE_NORMAL
- en: e.g., 0×3 = 0 inhabits Prop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But propositions are just another kind of type...
  prefs: []
  type: TYPE_NORMAL
- en: what inhabits the type 0×3 = 0?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A proof that provides evidence that 0×3 = 0!
  prefs: []
  type: TYPE_NORMAL
- en: Proofs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Propositions are inhabited by *proof objects* aka *proof terms*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma silly : 0 × 3 = 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Print silly.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> silly = eq_refl : 0 * 3 = 0 *)
  prefs: []
  type: TYPE_NORMAL
- en: (Here, the eq_refl proof object provides evidence for the equality. We'll come
    back to how it does that...)
  prefs: []
  type: TYPE_NORMAL
- en: Constructing proof objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We could even have written the proof object ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition silly'' : 0 × 3 = 0 :='
  prefs: []
  type: TYPE_NORMAL
- en: eq_refl.
  prefs: []
  type: TYPE_NORMAL
- en: Print silly'.
  prefs: []
  type: TYPE_NORMAL
- en: Print silly.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> silly' = eq_refl : 0 * 3 = 0 *)
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> silly = eq_refl : 0 * 3 = 0 *)
  prefs: []
  type: TYPE_NORMAL
- en: 'These mean the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma name : prop. Proof. *tactics* Qed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Definition name : prop := *proof object* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first form lets us *interactively* build a proof object, the latter requires
    us to state it all at once.
  prefs: []
  type: TYPE_NORMAL
- en: Another Proof Object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Print plus_O_n.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> plus_O_n =
  prefs: []
  type: TYPE_NORMAL
- en: fun n : nat
  prefs: []
  type: TYPE_NORMAL
- en: => eq_refl
  prefs: []
  type: TYPE_NORMAL
- en: : forall n : nat, 0 + n = n *)
  prefs: []
  type: TYPE_NORMAL
- en: This proof object is a function that takes in n and returns a proof object eq_refl.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Coq
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We read name = expr : type the same, whether the type is Prop or Type.'
  prefs: []
  type: TYPE_NORMAL
- en: Print andb.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> andb =
  prefs: []
  type: TYPE_NORMAL
- en: fun b1 b2 : bool
  prefs: []
  type: TYPE_NORMAL
- en: => if b1 then b2 else false
  prefs: []
  type: TYPE_NORMAL
- en: : bool -> bool -> bool *)
  prefs: []
  type: TYPE_NORMAL
- en: Print plus_O_n.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> plus_O_n =
  prefs: []
  type: TYPE_NORMAL
- en: fun n : nat
  prefs: []
  type: TYPE_NORMAL
- en: => eq_refl
  prefs: []
  type: TYPE_NORMAL
- en: : forall n : nat, 0 + n = n *)
  prefs: []
  type: TYPE_NORMAL
- en: Coq unifies the notions of
  prefs: []
  type: TYPE_NORMAL
- en: types with formulas, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: programs with proofs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coq's Connectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Same connectives we saw in IQC:'
  prefs: []
  type: TYPE_NORMAL
- en: Implication ⇒
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Universal quantification ∀
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conjunction ∧
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disjunction ∨
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: True and False
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Negation ¬
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Existential quantification ∃
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equality =
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implies and forall
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are the built-in connectives in Coq.Coq treats both connectives the same
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: The proof object for P → Q is a *function* that takes evidence for P as input
    and produces evidence for Q as output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proof object for ∀ x, P is a *function* that takes x as input and produces
    evidence for P as output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implies and forall intro
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The introduction rules in IQC corresponds to the intros tactic in Coq.The intros
    tactic moves one or more quantifiers or hypotheses from the goal to a "context"
    of current assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma imp_intro : (1 + 1) = 2 → 0 × 3 = 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros H. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Print imp_intro.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> imp_intro =
  prefs: []
  type: TYPE_NORMAL
- en: fun _ : 1 + 1 = 2 => eq_refl
  prefs: []
  type: TYPE_NORMAL
- en: : 1 + 1 = 2 -> 0 * 3 = 0 *)
  prefs: []
  type: TYPE_NORMAL
- en: The proof object takes in evidence for 1+1=2, discards that evidence, and returns
    evidence for 0×3=0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma forall_intro : ∀ (n:nat), n = n.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros n. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Print forall_intro.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> forall_intro =
  prefs: []
  type: TYPE_NORMAL
- en: fun n : nat => eq_refl
  prefs: []
  type: TYPE_NORMAL
- en: : forall n : nat, n = n *)
  prefs: []
  type: TYPE_NORMAL
- en: The proof object takes in n, and returns evidence for n=n.
  prefs: []
  type: TYPE_NORMAL
- en: Implies and forall elim
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The elimination rules *for these connectives* in IQC correspond to the apply
    tactic in Coq.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma imp_elim : ∀ (P Q : Prop), P → (P→Q) → Q.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros P Q. intros HP HPimpQ.
  prefs: []
  type: TYPE_NORMAL
- en: apply HPimpQ. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Print imp_elim.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> imp_elim = fun (P Q : Prop) (HP : P)
  prefs: []
  type: TYPE_NORMAL
- en: (HPimpQ : P -> Q)
  prefs: []
  type: TYPE_NORMAL
- en: => HPimpQ HP
  prefs: []
  type: TYPE_NORMAL
- en: : forall P Q : Prop,
  prefs: []
  type: TYPE_NORMAL
- en: P -> (P -> Q) -> Q *)
  prefs: []
  type: TYPE_NORMAL
- en: 'Note:'
  prefs: []
  type: TYPE_NORMAL
- en: The assumption tactic corresponds to the IQC assumption rule.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proof object applies a function. Implication elimination is really function
    application!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lemma forall_elim : (∀ (n:nat), n=0) → 1=0.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros H. apply H with (n:=1). Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Print forall_elim.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> forall_elim =
  prefs: []
  type: TYPE_NORMAL
- en: fun H : forall n : nat, n = 0 => H 1
  prefs: []
  type: TYPE_NORMAL
- en: : (forall n : nat, n = 0) -> 1 = 0 *)
  prefs: []
  type: TYPE_NORMAL
- en: Conjunction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logical conjunction is not built-in to the language, though it''s available
    in the standard library.Conjunction is a binary operator on propositions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive and (P Q : Prop) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: 'conj : P → Q → (and P Q).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notation "P ∧ Q" := (and P Q) : type_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: And intro
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: And intro in IQC corresponds to applying the conj constructor in Coq.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem and_intro :'
  prefs: []
  type: TYPE_NORMAL
- en: (0 = 0) ∧ (4 = mult 2 2).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: apply conj. reflexivity. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Print and_intro.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===>  and_intro =
  prefs: []
  type: TYPE_NORMAL
- en: conj (0 = 0) (4 = 2 * 2)
  prefs: []
  type: TYPE_NORMAL
- en: eq_refl eq_refl
  prefs: []
  type: TYPE_NORMAL
- en: : 0 = 0 /\ 4 = 2 * 2 *)
  prefs: []
  type: TYPE_NORMAL
- en: And elim
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: And elim in IQC corresponds to the inversion tactic in Coq, which breaks apart
    the evidence for a Prop into smaller pieces of evidence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem and_elim : ∀ P Q : Prop,'
  prefs: []
  type: TYPE_NORMAL
- en: P ∧ Q → P.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros P Q H.
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [HP HQ].
  prefs: []
  type: TYPE_NORMAL
- en: apply HP.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: A proof we did in IQC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Theorem and_commut : ∀ P Q : Prop,'
  prefs: []
  type: TYPE_NORMAL
- en: P ∧ Q → Q ∧ P.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros P Q H.
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [HP HQ].
  prefs: []
  type: TYPE_NORMAL
- en: apply conj.
  prefs: []
  type: TYPE_NORMAL
- en: apply HQ.
  prefs: []
  type: TYPE_NORMAL
- en: apply HP.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tactics is the "assembly language" programming of Coq. There are automated
    tactics that find proofs for us!
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem and_commut'' : ∀ P Q : Prop,'
  prefs: []
  type: TYPE_NORMAL
- en: P ∧ Q → Q ∧ P.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. firstorder. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Disjunction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inductive or (P Q : Prop) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| or_introl : P → or P Q'
  prefs: []
  type: TYPE_NORMAL
- en: '| or_intror : Q → or P Q.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notation "P ∨ Q" := (or P Q) : type_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Check or_introl.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===>  forall P Q : Prop, P -> P \/ Q *)
  prefs: []
  type: TYPE_NORMAL
- en: Check or_intror.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===>  forall P Q : Prop, Q -> P \/ Q *)
  prefs: []
  type: TYPE_NORMAL
- en: A proof we did in IQC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Theorem or_commut : ∀ P Q : Prop,'
  prefs: []
  type: TYPE_NORMAL
- en: P ∨ Q → Q ∨ P.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros P Q H.
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [HP | HQ].
  prefs: []
  type: TYPE_NORMAL
- en: apply or_intror. apply HP.
  prefs: []
  type: TYPE_NORMAL
- en: apply or_introl. apply HQ.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could even write down an explicit proof object for or_commut without using
    tactics to construct it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition or_commut'' : ∀ P Q,'
  prefs: []
  type: TYPE_NORMAL
- en: P ∨ Q → Q ∨ P
  prefs: []
  type: TYPE_NORMAL
- en: :=
  prefs: []
  type: TYPE_NORMAL
- en: 'fun (P Q : Prop) (H : P ∨ Q) ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match H with
  prefs: []
  type: TYPE_NORMAL
- en: '| or_introl HP ⇒ or_intror Q P HP'
  prefs: []
  type: TYPE_NORMAL
- en: '| or_intror HQ ⇒ or_introl Q P HQ'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: Or we could let Coq find the proof.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem or_commut'''' : ∀ P Q : Prop,'
  prefs: []
  type: TYPE_NORMAL
- en: P ∨ Q → Q ∨ P.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. firstorder. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: True and False
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: True has a single constructor that takes no arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive True : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: 'I : True.'
  prefs: []
  type: TYPE_NORMAL
- en: 'False has no constructors. Intuition: False is a proposition for which there
    is no way to give evidence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive False : Prop := .'
  prefs: []
  type: TYPE_NORMAL
- en: Proofs with True and False
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applying the I constructor corresponds to IQC's true intro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem True_is_provable : True.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. apply I. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have False as an assumption, the contradiction tactic lets us conclude
    whatever we want. That corresponds to IQC's false elim.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem False_implies_nonsense :'
  prefs: []
  type: TYPE_NORMAL
- en: False → 2 + 2 = 5.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros. contradiction.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem exfalso : ∀ (P:Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: False → P.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros. contradiction.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Negation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Negation is defined in Coq exactly as in IQC. The fold and unfold tactics let
    us convert between ¬P and P→False.
  prefs: []
  type: TYPE_NORMAL
- en: Definition not (P:Prop) := P → False.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notation "¬ x" := (not x) : type_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem not_False : ¬ False.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. unfold not. apply exfalso. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem contradiction_implies_anything :'
  prefs: []
  type: TYPE_NORMAL
- en: '∀ P Q : Prop, (P ∧ ¬P) → Q.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. firstorder. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Existential Quantification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inductive ex (X:Type) (P : X→Prop) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: 'ex_intro : ∀ (witness:X), P witness → ex X P.'
  prefs: []
  type: TYPE_NORMAL
- en: To give evidence we must actually name a *witness* a specific value x — and
    then give evidence for P x.
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'exists' x , p" := (ex _ (fun x ⇒ p))
  prefs: []
  type: TYPE_NORMAL
- en: '(at level 200, x ident, right associativity) : type_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notation "''exists'' x : X , p" := (ex _ (fun x:X ⇒ p))'
  prefs: []
  type: TYPE_NORMAL
- en: '(at level 200, x ident, right associativity) : type_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof with exists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ex_intro constructor corresponds to IQC's exists intro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example exists_example_1 :'
  prefs: []
  type: TYPE_NORMAL
- en: ∃ n, n + (n × n) = 6.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: apply ex_intro with (witness:=2).
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we explicitly give the witness.We'll omit exists elimination, though
    it also is in Coq.
  prefs: []
  type: TYPE_NORMAL
- en: A proof we did in IQC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Theorem dist_exists_or : ∀ (X:Type) (P Q : X → Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (∃ x, P x ∨ Q x) ↔ (∃ x, P x) ∨ (∃ x, Q x).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: firstorder.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Equality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The equality relation is definable, not built-in to the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive eq {X:Type} : X → X → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: 'refl_equal : ∀ x, eq x x.'
  prefs: []
  type: TYPE_NORMAL
- en: Notation "x = y" := (eq x y)
  prefs: []
  type: TYPE_NORMAL
- en: '(at level 70, no associativity) : type_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma four: 2 + 2 = 1 + 3.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: apply refl_equal.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity is essentially just apply refl_equal.
  prefs: []
  type: TYPE_NORMAL
- en: Excluded middle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that some theorems that are true in classical logic are *not* provable
    in Coq's (constructive) logic. E.g., let's look at how this proof gets stuck...
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem excluded_middle : ∀ P : Prop,'
  prefs: []
  type: TYPE_NORMAL
- en: P ∨ ¬P.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros P. unfold not.
  prefs: []
  type: TYPE_NORMAL
- en: (* We either have to go left or right... *)
  prefs: []
  type: TYPE_NORMAL
- en: left. (* But now what?  We don't have evidence for P. *)
  prefs: []
  type: TYPE_NORMAL
- en: Undo.
  prefs: []
  type: TYPE_NORMAL
- en: right. intros HP. (* And now we don't have evidence for False. *)
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: Proofs from IPC and IQC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are Coq proofs for all the theorems we proved in IQC and IPC. The firstorder
    tactic searches for, and finds, a proof object for each of these theorems. You
    can enter Print <theorem_name> to see that object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem lec19thm1 : ∀ (A B : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: A → (B → A).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. firstorder. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem lec19thm2 : ∀ (A B : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: A → (B → (A ∧ B)).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. firstorder. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem lec19thm3 : ∀ (A B : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (A ∨ B) → (B ∨ A).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. firstorder. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem rec18thm1 : ∀ (A B : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (A ∧ B) → A.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. firstorder. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem rec18thm2 : ∀ (A B : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (A ∧ B) → (B ∧ A).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. firstorder. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem rec18thm3 : ∀ (A B C : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (A → B) → ((B→C) → (A→C)).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. firstorder. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem rec18thm4 : ∀ (S C O : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: ((S→C) ∧ O ∧ ((O->~C) ∧ (C->~O))) → ¬S.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. firstorder. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem lec21thm1 : ∀ (Q R : Type → Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (∀ x, R(x) ∧ Q(x)) → (∀ x, R(x)) ∧ (∀ x, Q(x)).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. firstorder. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem lec21thm2 : ∀ (Q R : Type → Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (∃ x, Q(x) ∨ R(x)) → (∃ x, R(x)) ∨ (∃ x, Q(x)).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. firstorder. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem rec19thm1 : ∀ (A B : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: ((A → B) ∧ ¬B) → ¬A.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. firstorder. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem rec19thm2 : ∀ (A B : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (A → (B ∨ (A → B))) → (A → B).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. firstorder. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem rec19thm3 : ∀ (A B : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: ~((~A ∨ ¬B) ∧ (A ∧ B)).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. firstorder. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem rec19thm4 : ∀ (P Q : Type → Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: '(∀ (x y : Type), (P(x) → Q(y))) ∧ (∃ x, P(x))'
  prefs: []
  type: TYPE_NORMAL
- en: → (∃ y, Q(y)).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. firstorder. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem rec19thm5 : ∀ (P Q : Type → Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (∀ x, P(x)) → (∀ x, Q(x)) → (∀ x, (P(x) ↔ Q(x))).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. firstorder. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[Index](coqindex.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This page has been generated by [coqdoc](http://www.lix.polytechnique.fr/coq/)
  prefs: []
  type: TYPE_NORMAL
