["```\nfun f(n :: Number) -> Number:\n  n + 3\nend\n\nf(\"x\")\n```", "```\nfun f(n):\n  n + 3\nend\n\nf(\"x\")\n```", "```\nfun f n:\n  n + 3\nend\n```", "```\ndata TyExprC:\n  | numC(n :: Number)\n  | plusC(l :: TyExprC, r :: TyExprC)\n  | multC(l :: TyExprC, r :: TyExprC)\n  | trueC\n  | falseC\n  | ifC(c :: TyExprC, t :: TyExprC, e :: TyExprC)\n  | idC(s :: String)\n  | appC(f :: TyExprC, a :: TyExprC)\n  | fdC(arg :: String, at :: Type, rt :: Type, body :: TyExprC)\nend\n```", "```\ndata Type:\n  | numT\n  | boolT\n  | funT(a :: Type, r :: Type)\nend\n```", "```\n| numC(n :: Number)\n| plusC(l :: TyExprC, r :: TyExprC)\n| multC(l :: TyExprC, r :: TyExprC)\n```", "```\n| trueC\n| falseC\n| ifC(c :: TyExprC, t :: TyExprC, e :: TyExprC)\n```", "```\n| idC(s :: String)\n| appC(f :: TyExprC, a :: TyExprC)\n| fdC(arg :: String, at :: Type, rt :: Type, body :: TyExprC)\n```", "```\nfun f(x :: String) -> Number:\n  if x == \"pi\":\n    3.14\n  else:\n    2.78\n  end\nend\n\n2 + f(\"pi\")\n```", "```\ntc :: TyExprC -> Boolean\n```", "```\n| appC(f, a) =>\n  f-t = tc(f, tnv)\n  a-t = tc(a, tnv)\n  if is-funT(f-t):\n    if a-t == f-t.arg:\n```", "```\nfun tc-arith-binop(l :: TyExprC, r :: TyExprC, tnv :: TyEnv) -> Type:\n  if (tc(l, tnv) == numT) and (tc(r, tnv) == numT):\n    numT\n  else:\n    raise('type error in arithmetic')\n  end\nend\n```", "```\n    p =\n      lam(x :: Number) -> (Number -> Number):\n        lam(y :: Number) -> Number:\n          x + y\n        end\n      end\n    ```", "```\n    lam(f :: (Number -> String), n :: Number) -> String:\n      f(n)\n    end\n    ```", "```\n(fun(x): x(x) end)(fun(x):  x(x) end)\n```", "```\ndata BinTree:\n  | leaf\n  | node (value :: Number,\n          left :: BinTree,\n          right :: BinTree)\nend\n```", "```\nleaf :: BinTree  # a constant, so no arrow\nnode :: Number, BinTree, BinTree -> BinTree\nis-leaf :: BinTree -> Bool\nis-node :: BinTree -> Bool\n.value :: BinTree%(is-node) -> Number\n.left :: BinTree%(is-node) -> BTnum\n.right :: BinTree%(is-node) -> BTnum\n```", "```\ndata Payment:\n  | cash(value :: Number)\n  | card(number :: Number, value :: Number)\nend\n```", "```\n.value :: Payment(is-cash) -> Number\n.value :: Payment(is-card) -> Number\n```", "```\n.value :: Payment -> Number\n```", "```\ncases (BinTree) t:\n  | leaf => e1\n  | node(v, l, r) => e2\nend\n```", "```\nif is-leaf(t):\n  e1\nelse if is-node(t):\n  v = t.value\n  l = t.left\n  r = t.right\n  e2\nend\n```"]