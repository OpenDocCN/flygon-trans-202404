["```\n\n    In this chapter, we begin a new direction that will continue for\n    the rest of the course.  Up to now most of our attention has been\n    focused on various aspects of Coq itself, while from now on we'll\n    mostly be using Coq to formalize other things.  (We'll continue to\n    pause from time to time to introduce a few additional aspects of\n    Coq.)\n\n    Our first case study is a *simple imperative programming language*\n    called Imp, embodying a tiny core fragment of conventional\n    mainstream languages such as C and Java.  Here is a familiar\n    mathematical function written in Imp.\n\n```", "```\n(*\u00a0IMPORTS\u00a0*)\nRequire Import Coq.Bool.Bool.\nRequire Import Coq.Arith.Arith.\nRequire Import Coq.Arith.EqNat.\nRequire Import Coq.omega.Omega.\nRequire Import Coq.Lists.List.\nImport ListNotations.\n\nRequire Import Maps.\n(*\u00a0/IMPORTS\u00a0*)\n\n```", "```\n\n## Syntax\n\n```", "```\n\n    These two definitions specify the *abstract syntax* of\n    arithmetic and boolean expressions.\n\n```", "```\n\n    In this chapter, we'll elide the translation from the\n    concrete syntax that a programmer would actually write to these\n    abstract syntax trees \u2014 the process that, for example, would\n    translate the string \"1+2*3\" to the AST\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0a\u00a0::=\u00a0nat\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0a\u00a0+\u00a0a\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0a\u00a0-\u00a0a\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0a\u00a0*\u00a0a\n\n\u00a0\u00a0\u00a0\u00a0b\u00a0::=\u00a0true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0a\u00a0=\u00a0a\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0a\u00a0\u2264\u00a0a\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0not\u00a0b\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0b\u00a0and\u00a0b\n\n    Compared to the Coq version above...\n\n*   The BNF is more informal \u2014 for example, it gives some suggestions about the surface syntax of expressions (like the fact that the addition operation is written + and is an infix symbol) while leaving other aspects of lexical analysis and parsing (like the relative precedence of +, -, and *, the use of parens to explicitly group subexpressions, etc.) unspecified. Some additional information (and human intelligence) would be required to turn this description into a formal definition, for example when implementing a compiler. \n\n     The Coq version consistently omits all this information and concentrates on the abstract syntax only. \n\n*   On the other hand, the BNF version is lighter and easier to read. Its informality makes it flexible, a big advantage in situations like discussions at the blackboard, where conveying general ideas is more important than getting every detail nailed down precisely. \n\n     Indeed, there are dozens of BNF-like notations and people switch freely among them, usually without bothering to say which form of BNF they're using because there is no need to: a rough-and-ready informal understanding is all that's important.\n\n    It's good to be comfortable with both sorts of notations: informal\n    ones for communicating between humans and formal ones for carrying\n    out implementations and proofs.\n\n```", "```\nFixpoint aeval (a : aexp) : nat :=\n\u00a0\u00a0match a with\n\u00a0\u00a0| ANum n \u21d2 n\n\u00a0\u00a0| APlus a[1] a[2] \u21d2 (aeval a[1]) + (aeval a[2])\n\u00a0\u00a0| AMinus a[1] a[2]  \u21d2 (aeval a[1]) - (aeval a[2])\n\u00a0\u00a0| AMult a[1] a[2] \u21d2 (aeval a[1]) * (aeval a[2])\n\u00a0\u00a0end.\n\nExample test_aeval1:\n\u00a0\u00a0aeval (APlus (ANum 2) (ANum 2)) = 4.\n\n    Proof. reflexivity. Qed.\n\n```", "```\nFixpoint beval (b : bexp) : bool :=\n\u00a0\u00a0match b with\n\u00a0\u00a0| BTrue       \u21d2 true\n\u00a0\u00a0| BFalse      \u21d2 false\n\u00a0\u00a0| BEq a[1] a[2]   \u21d2 beq_nat (aeval a[1]) (aeval a[2])\n\u00a0\u00a0| BLe a[1] a[2]   \u21d2 leb (aeval a[1]) (aeval a[2])\n\u00a0\u00a0| BNot b[1]     \u21d2 negb (beval b[1])\n\u00a0\u00a0| BAnd b[1] b[2]  \u21d2 andb (beval b[1]) (beval b[2])\n\u00a0\u00a0end.\n\n```", "```\nFixpoint optimize_0plus (a:aexp) : aexp :=\n\u00a0\u00a0match a with\n\u00a0\u00a0| ANum n \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ANum n\n\u00a0\u00a0| APlus (ANum 0) e[2] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0optimize_0plus e[2]\n\u00a0\u00a0| APlus e[1] e[2] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0APlus (optimize_0plus e[1]) (optimize_0plus e[2])\n\u00a0\u00a0| AMinus e[1] e[2] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0AMinus (optimize_0plus e[1]) (optimize_0plus e[2])\n\u00a0\u00a0| AMult e[1] e[2] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0AMult (optimize_0plus e[1]) (optimize_0plus e[2])\n\u00a0\u00a0end.\n\n```", "```\nExample test_optimize_0plus:\n\u00a0\u00a0optimize_0plus (APlus (ANum 2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(APlus (ANum 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(APlus (ANum 0) (ANum 1))))\n\u00a0\u00a0= APlus (ANum 2) (ANum 1).\n\n    Proof. reflexivity. Qed.\n\n```", "```\nTheorem optimize_0plus_sound: \u2200a,\n\u00a0\u00a0aeval (optimize_0plus a) = aeval a.\nProof.\n\u00a0\u00a0intros a. induction a.\n\u00a0\u00a0- (*\u00a0ANum\u00a0*) reflexivity.\n\u00a0\u00a0- (*\u00a0APlus\u00a0*) destruct a[1].\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0a[1]\u00a0=\u00a0ANum\u00a0n\u00a0*) destruct n.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0n\u00a0=\u00a00\u00a0*)  simpl. apply IHa2.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0n\u00a0<>\u00a00\u00a0*) simpl. rewrite IHa2. reflexivity.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0a[1]\u00a0=\u00a0APlus\u00a0a1_1\u00a0a1_2\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0simpl. simpl in IHa1. rewrite IHa1.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite IHa2. reflexivity.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0a[1]\u00a0=\u00a0AMinus\u00a0a1_1\u00a0a1_2\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0simpl. simpl in IHa1. rewrite IHa1.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite IHa2. reflexivity.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0a[1]\u00a0=\u00a0AMult\u00a0a1_1\u00a0a1_2\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0simpl. simpl in IHa1. rewrite IHa1.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite IHa2. reflexivity.\n\u00a0\u00a0- (*\u00a0AMinus\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl. rewrite IHa1. rewrite IHa2. reflexivity.\n\u00a0\u00a0- (*\u00a0AMult\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl. rewrite IHa1. rewrite IHa2. reflexivity. Qed.\n\n```", "```\n\n## Tacticals\n\n    *Tacticals* is Coq's term for tactics that take other tactics as\n    arguments \u2014 \"higher-order tactics,\" if you will.\n\n```", "```\nTheorem silly1 : \u2200ae, aeval ae = aeval ae.\nProof. try reflexivity. (*\u00a0this\u00a0just\u00a0does\u00a0reflexivity\u00a0*) Qed.\n\nTheorem silly2 : \u2200(P : Prop), P \u2192 P.\nProof.\n\u00a0\u00a0intros P HP.\n\u00a0\u00a0try reflexivity. (*\u00a0just\u00a0reflexivity\u00a0would\u00a0have\u00a0failed\u00a0*)\n\u00a0\u00a0apply HP. (*\u00a0we\u00a0can\u00a0still\u00a0finish\u00a0the\u00a0proof\u00a0in\u00a0some\u00a0other\u00a0way\u00a0*)\nQed.\n\n```", "```\n\n### The ; Tactical (Simple Form)\n\n    In its most common form, the ; tactical takes two tactics as\n    arguments.  The compound tactic T;T' first performs T and then\n    performs T' on *each subgoal* generated by T. \n\n    For example, consider the following trivial lemma:\n\n```", "```\n\n    We can simplify this proof using the ; tactical:\n\n```", "```\n\n    Using try and ; together, we can get rid of the repetition in\n    the proof that was bothering us a little while ago.\n\n```", "```\n\n    Coq experts often use this \"...; try... \" idiom after a tactic\n    like induction to take care of many similar cases all at once.\n    Naturally, this practice has an analog in informal proofs.  For\n    example, here is an informal proof of the optimization theorem\n    that matches the structure of the formal one:\n\n    *Theorem*: For all arithmetic expressions a,\n\n```", "```\n    \u00a0\u00a0aeval\u00a0(optimize_0plus\u00a0(ANum\u00a0n))\u00a0=\u00a0aeval\u00a0(ANum\u00a0n).\n\n     This is immediate from the definition of optimize_0plus. \n\n    ```", "```\n    \u00a0\u00a0aeval\u00a0(optimize_0plus\u00a0(APlus\u00a0a[1]\u00a0a[2]))\u00a0=\u00a0aeval\u00a0(APlus\u00a0a[1]\u00a0a[2]).\n\n     Consider the possible forms of a[1]. For most of them, optimize_0plus simply calls itself recursively for the subexpressions and rebuilds a new expression of the same form as a[1]; in these cases, the result follows directly from the IH. \n\n     The interesting case is when a[1] = ANum n for some n. If n = ANum 0, then \n\n    ```", "```\n\n    ```", "```\nTheorem optimize_0plus_sound'': \u2200a,\n\u00a0\u00a0aeval (optimize_0plus a) = aeval a.\nProof.\n\u00a0\u00a0intros a.\n\u00a0\u00a0induction a;\n\u00a0\u00a0\u00a0\u00a0(*\u00a0Most\u00a0cases\u00a0follow\u00a0directly\u00a0by\u00a0the\u00a0IH\u00a0*)\n\u00a0\u00a0\u00a0\u00a0try (simpl; rewrite IHa1; rewrite IHa2; reflexivity);\n\u00a0\u00a0\u00a0\u00a0(*\u00a0...\u00a0or\u00a0are\u00a0immediate\u00a0by\u00a0definition\u00a0*)\n\u00a0\u00a0\u00a0\u00a0try reflexivity.\n\u00a0\u00a0(*\u00a0The\u00a0interesting\u00a0case\u00a0is\u00a0when\u00a0a\u00a0=\u00a0APlus\u00a0a[1]\u00a0a[2].\u00a0*)\n\u00a0\u00a0- (*\u00a0APlus\u00a0*)\n\u00a0\u00a0\u00a0\u00a0destruct a[1]; try (simpl; simpl in IHa1; rewrite IHa1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite IHa2; reflexivity).\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0a[1]\u00a0=\u00a0ANum\u00a0n\u00a0*) destruct n;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0simpl; rewrite IHa2; reflexivity. Qed.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0T;\u00a0[T[1]\u00a0|\u00a0T[2]\u00a0|\u00a0... |\u00a0Tn]\n\n    is a tactic that first performs T and then performs T[1] on the\n   first subgoal generated by T, performs T[2] on the second\n   subgoal, etc.\n\n    So T;T' is just special notation for the case when all of the\n   Ti's are the same tactic; i.e., T;T' is shorthand for:\n\n```", "```\n\n### The repeat Tactical\n\n    The repeat tactical takes another tactic and keeps applying this\n    tactic until it fails. Here is an example showing that 10 is in\n    a long list using repeat.\n\n```", "```\n\n    The tactic repeat T never fails: if the tactic T doesn't apply\n    to the original goal, then repeat still succeeds without changing\n    the original goal (i.e., it repeats zero times).\n\n```", "```\n\n    The tactic repeat T also does not have any upper bound on the\n    number of times it applies T.  If T is a tactic that always\n    succeeds, then repeat T will loop forever (e.g., repeat simpl\n    loops forever, since simpl always succeeds).  While evaluation\n    in Coq's term language, Gallina, is guaranteed to terminate,\n    tactic evaluation is not!  This does not affect Coq's logical\n    consistency, however, since the job of repeat and other tactics\n    is to guide Coq in constructing proofs; if the construction\n    process diverges, this simply means that we have failed to\n    construct a proof, not that we have constructed a wrong one. \n\n#### Exercise: 3 stars (optimize_0plus_b)\n\n    Since the optimize_0plus transformation doesn't change the value\n    of aexps, we should be able to apply it to all the aexps that\n    appear in a bexp without changing the bexp's value.  Write a\n    function which performs that transformation on bexps, and prove\n    it is sound.  Use the tacticals we've just seen to make the proof\n    as elegant as possible.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 4 stars, optional (optimizer)\n\n    *Design exercise*: The optimization implemented by our\n    optimize_0plus function is only one of many possible\n    optimizations on arithmetic and boolean expressions.  Write a more\n    sophisticated optimizer and prove it correct.  (You will probably\n    find it easiest to start small \u2014 add just a single, simple\n    optimization and prove it correct \u2014 and build up to something\n    more interesting incrementially.)\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610\n\n```", "```\nTactic Notation \"simpl_and_try\" tactic(c) :=\n\u00a0\u00a0simpl;\n\u00a0\u00a0try c.\n\n```", "```\n\n## The omega Tactic\n\n    The omega tactic implements a decision procedure for a subset of\n    first-order logic called *Presburger arithmetic*.  It is based on\n    the Omega algorithm invented in 1991 by William Pugh [[Pugh 1991]](Bib.html#Pugh 1991).\n\n    If the goal is a universally quantified formula made out of\n\n*   numeric constants, addition (+ and S), subtraction (- and pred), and multiplication by constants (this is what makes it Presburger arithmetic), \n\n*   equality (= and \u2260) and inequality (\u2264), and \n\n*   the logical connectives \u2227, \u2228, \u00ac, and \u2192,\n\n    then invoking omega will either solve the goal or tell you that\n    it is actually false.\n\n```", "```\n\n## A Few More Handy Tactics\n\n    Finally, here are some miscellaneous tactics that you may find\n    convenient.\n\n*   clear H: Delete hypothesis H from the context. \n\n*   subst x: Find an assumption x = e or e = x in the context, replace x with e throughout the context and current goal, and clear the assumption. \n\n*   subst: Substitute away *all* assumptions of the form x = e or e = x. \n\n*   rename... into...: Change the name of a hypothesis in the proof context. For example, if the context includes a variable named x, then rename x into y will change all occurrences of x to y. \n\n*   assumption: Try to find a hypothesis H in the context that exactly matches the goal; if one is found, behave like apply H. \n\n*   contradiction: Try to find a hypothesis H in the current context that is logically equivalent to False. If one is found, solve the goal. \n\n*   constructor: Try to find a constructor c (from some Inductive definition in the current environment) that can be applied to solve the current goal. If one is found, behave like apply c.\n\n    We'll see examples below.\n\n```", "```\nModule aevalR_first_try.\n\nInductive aevalR : aexp \u2192 nat \u2192 Prop :=\n\u00a0\u00a0| E_ANum  : \u2200(n: nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aevalR (ANum n) n\n\u00a0\u00a0| E_APlus : \u2200(e[1] e[2]: aexp) (n[1] n[2]: nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aevalR e[1] n[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aevalR e[2] n[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aevalR (APlus e[1] e[2]) (n[1] + n[2])\n\u00a0\u00a0| E_AMinus: \u2200(e[1] e[2]: aexp) (n[1] n[2]: nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aevalR e[1] n[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aevalR e[2] n[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aevalR (AMinus e[1] e[2]) (n[1] - n[2])\n\u00a0\u00a0| E_AMult : \u2200(e[1] e[2]: aexp) (n[1] n[2]: nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aevalR e[1] n[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aevalR e[2] n[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aevalR (AMult e[1] e[2]) (n[1] * n[2]).\n\n```", "```\nNotation \"e '\u21d3' n\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0:= (aevalR e n)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(at level 50, left associativity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: type_scope.\n\nEnd aevalR_first_try.\n\n```", "```\nReserved Notation \"e '\u21d3' n\" (at level 50, left associativity).\n\nInductive aevalR : aexp \u2192 nat \u2192 Prop :=\n\u00a0\u00a0| E_ANum : \u2200(n:nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(ANum n) \u21d3 n\n\u00a0\u00a0| E_APlus : \u2200(e[1] e[2]: aexp) (n[1] n[2] : nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(e[1] \u21d3 n[1]) \u2192 (e[2] \u21d3 n[2]) \u2192 (APlus e[1] e[2]) \u21d3 (n[1] + n[2])\n\u00a0\u00a0| E_AMinus : \u2200(e[1] e[2]: aexp) (n[1] n[2] : nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(e[1] \u21d3 n[1]) \u2192 (e[2] \u21d3 n[2]) \u2192 (AMinus e[1] e[2]) \u21d3 (n[1] - n[2])\n\u00a0\u00a0| E_AMult :  \u2200(e[1] e[2]: aexp) (n[1] n[2] : nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(e[1] \u21d3 n[1]) \u2192 (e[2] \u21d3 n[2]) \u2192 (AMult e[1] e[2]) \u21d3 (n[1] * n[2])\n\n\u00a0\u00a0where \"e '\u21d3' n\" := (aevalR e n) : type_scope.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0E_APlus\u00a0:\u00a0\u2200(e[1]\u00a0e[2]:\u00a0aexp)\u00a0(n[1]\u00a0n[2]:\u00a0nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aevalR\u00a0e[1]\u00a0n[1]\u00a0\u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aevalR\u00a0e[2]\u00a0n[2]\u00a0\u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aevalR\u00a0(APlus\u00a0e[1]\u00a0e[2])\u00a0(n[1]\u00a0+\u00a0n[2])\n\n    ...would be written like this as an inference rule:\n\n                        e[1]\u00a0\u21d3\u00a0n[1]\n           |\n\n                     |\n\n                        e[2]\u00a0\u21d3\u00a0n[2]\n           |\n\n                        (E_APlus) \u00a0\n           |\n\n* * *\n\n           |\n\n                        APlus\u00a0e[1]\u00a0e[2]\u00a0\u21d3\u00a0n[1]+n[2]\n           |\n\n                     |\n\n    Formally, there is nothing deep about inference rules: they\n    are just implications.  You can read the rule name on the right as\n    the name of the constructor and read each of the linebreaks\n    between the premises above the line (as well as the line itself)\n    as \u2192.  All the variables mentioned in the rule (e[1], n[1],\n    etc.) are implicitly bound by universal quantifiers at the\n    beginning. (Such variables are often called *metavariables* to\n    distinguish them from the variables of the language we are\n    defining.  At the moment, our arithmetic expressions don't include\n    variables, but we'll soon be adding them.)  The whole collection\n    of rules is understood as being wrapped in an Inductive\n    declaration.  In informal prose, this is either elided or else\n    indicated by saying something like \"Let aevalR be the smallest\n    relation closed under the following rules...\". \n\n    For example, \u21d3 is the smallest relation closed under these\n    rules:\n\n           |\n\n                        (E_ANum) \u00a0\n           |\n\n* * *\n\n           |\n\n                        ANum\u00a0n\u00a0\u21d3\u00a0n\n           |\n\n                     |\n\n                        e[1]\u00a0\u21d3\u00a0n[1]\n           |\n\n                     |\n\n                        e[2]\u00a0\u21d3\u00a0n[2]\n           |\n\n                        (E_APlus) \u00a0\n           |\n\n* * *\n\n           |\n\n                        APlus\u00a0e[1]\u00a0e[2]\u00a0\u21d3\u00a0n[1]+n[2]\n           |\n\n                     |\n\n                        e[1]\u00a0\u21d3\u00a0n[1]\n           |\n\n                     |\n\n                        e[2]\u00a0\u21d3\u00a0n[2]\n           |\n\n                        (E_AMinus) \u00a0\n           |\n\n* * *\n\n           |\n\n                        AMinus\u00a0e[1]\u00a0e[2]\u00a0\u21d3\u00a0n[1]-n[2]\n           |\n\n                     |\n\n                        e[1]\u00a0\u21d3\u00a0n[1]\n           |\n\n                     |\n\n                        e[2]\u00a0\u21d3\u00a0n[2]\n           |\n\n                        (E_AMult) \u00a0\n           |\n\n* * *\n\n           |\n\n                        AMult\u00a0e[1]\u00a0e[2]\u00a0\u21d3\u00a0n[1]*n[2]\n           |\n\n                     |\n\n```", "```\nTheorem aeval_iff_aevalR : \u2200a n,\n\u00a0\u00a0(a \u21d3 n) \u2194 aeval a = n.\n\n    Proof.\n\u00a0split.\n\u00a0- (*\u00a0->\u00a0*)\n\u00a0\u00a0\u00a0intros H.\n\u00a0\u00a0\u00a0induction H; simpl.\n\u00a0\u00a0\u00a0+ (*\u00a0E_ANum\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0reflexivity.\n\u00a0\u00a0\u00a0+ (*\u00a0E_APlus\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0rewrite IHaevalR1. rewrite IHaevalR2. reflexivity.\n\u00a0\u00a0\u00a0+ (*\u00a0E_AMinus\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0rewrite IHaevalR1. rewrite IHaevalR2. reflexivity.\n\u00a0\u00a0\u00a0+ (*\u00a0E_AMult\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0rewrite IHaevalR1. rewrite IHaevalR2. reflexivity.\n\u00a0- (*\u00a0<-\u00a0*)\n\u00a0\u00a0\u00a0generalize dependent n.\n\u00a0\u00a0\u00a0induction a;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0simpl; intros; subst.\n\u00a0\u00a0\u00a0+ (*\u00a0ANum\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0apply [E_ANum](Imp.html#AExp.E_ANum).\n\u00a0\u00a0\u00a0+ (*\u00a0APlus\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0apply [E_APlus](Imp.html#AExp.E_APlus).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHa1. reflexivity.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHa2. reflexivity.\n\u00a0\u00a0\u00a0+ (*\u00a0AMinus\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0apply [E_AMinus](Imp.html#AExp.E_AMinus).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHa1. reflexivity.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHa2. reflexivity.\n\u00a0\u00a0\u00a0+ (*\u00a0AMult\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0apply [E_AMult](Imp.html#AExp.E_AMult).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHa1. reflexivity.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHa2. reflexivity.\n    Qed.\n\n```", "```\nTheorem aeval_iff_aevalR' : \u2200a n,\n\u00a0\u00a0(a \u21d3 n) \u2194 aeval a = n.\nProof.\n\u00a0\u00a0(*\u00a0WORKED\u00a0IN\u00a0CLASS\u00a0*)\n\u00a0\u00a0split.\n\u00a0\u00a0- (*\u00a0->\u00a0*)\n\u00a0\u00a0\u00a0\u00a0intros H; induction H; subst; reflexivity.\n\u00a0\u00a0- (*\u00a0<-\u00a0*)\n\u00a0\u00a0\u00a0\u00a0generalize dependent n.\n\u00a0\u00a0\u00a0\u00a0induction a; simpl; intros; subst; constructor;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0try apply IHa1; try apply IHa2; reflexivity.\nQed.\n\n```", "```\nInductive bevalR: bexp \u2192 bool \u2192 Prop :=\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n.\n\nLemma beval_iff_bevalR : \u2200b bv,\n\u00a0\u00a0bevalR b bv \u2194 beval b = bv.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nEnd AExp.\n\n```", "```\nModule aevalR_division.\n\n```", "```\nInductive aexp : Type :=\n\u00a0\u00a0| ANum : nat \u2192 aexp\n\u00a0\u00a0| APlus : aexp \u2192 aexp \u2192 aexp\n\u00a0\u00a0| AMinus : aexp \u2192 aexp \u2192 aexp\n\u00a0\u00a0| AMult : aexp \u2192 aexp \u2192 aexp\n\u00a0\u00a0| ADiv : aexp \u2192 aexp \u2192 aexp. (*\u00a0<---\u00a0new\u00a0*)\n\n```", "```\nReserved Notation \"e '\u21d3' n\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(at level 50, left associativity).\n\nInductive aevalR : aexp \u2192 nat \u2192 Prop :=\n\u00a0\u00a0| E_ANum : \u2200(n:nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(ANum n) \u21d3 n\n\u00a0\u00a0| E_APlus : \u2200(a[1] a[2]: aexp) (n[1] n[2] : nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(a[1] \u21d3 n[1]) \u2192 (a[2] \u21d3 n[2]) \u2192 (APlus a[1] a[2]) \u21d3 (n[1] + n[2])\n\u00a0\u00a0| E_AMinus : \u2200(a[1] a[2]: aexp) (n[1] n[2] : nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(a[1] \u21d3 n[1]) \u2192 (a[2] \u21d3 n[2]) \u2192 (AMinus a[1] a[2]) \u21d3 (n[1] - n[2])\n\u00a0\u00a0| E_AMult :  \u2200(a[1] a[2]: aexp) (n[1] n[2] : nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(a[1] \u21d3 n[1]) \u2192 (a[2] \u21d3 n[2]) \u2192 (AMult a[1] a[2]) \u21d3 (n[1] * n[2])\n\u00a0\u00a0| E_ADiv :  \u2200(a[1] a[2]: aexp) (n[1] n[2] n[3]: nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(a[1] \u21d3 n[1]) \u2192 (a[2] \u21d3 n[2]) \u2192 (n[2] > 0) \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(mult n[2] n[3] = n[1]) \u2192 (ADiv a[1] a[2]) \u21d3 n[3]\n\nwhere \"a '\u21d3' n\" := (aevalR a n) : type_scope.\n\nEnd aevalR_division.\n\nModule aevalR_extended.\n\n```", "```\nReserved Notation \"e '\u21d3' n\" (at level 50, left associativity).\n\nInductive aexp : Type :=\n\u00a0\u00a0| AAny  : aexp                   (*\u00a0<---\u00a0NEW\u00a0*)\n\u00a0\u00a0| ANum : nat \u2192 aexp\n\u00a0\u00a0| APlus : aexp \u2192 aexp \u2192 aexp\n\u00a0\u00a0| AMinus : aexp \u2192 aexp \u2192 aexp\n\u00a0\u00a0| AMult : aexp \u2192 aexp \u2192 aexp.\n\n```", "```\nInductive aevalR : aexp \u2192 nat \u2192 Prop :=\n\u00a0\u00a0| E_Any : \u2200(n:nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0AAny \u21d3 n                 (*\u00a0<---\u00a0new\u00a0*)\n\u00a0\u00a0| E_ANum : \u2200(n:nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(ANum n) \u21d3 n\n\u00a0\u00a0| E_APlus : \u2200(a[1] a[2]: aexp) (n[1] n[2] : nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(a[1] \u21d3 n[1]) \u2192 (a[2] \u21d3 n[2]) \u2192 (APlus a[1] a[2]) \u21d3 (n[1] + n[2])\n\u00a0\u00a0| E_AMinus : \u2200(a[1] a[2]: aexp) (n[1] n[2] : nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(a[1] \u21d3 n[1]) \u2192 (a[2] \u21d3 n[2]) \u2192 (AMinus a[1] a[2]) \u21d3 (n[1] - n[2])\n\u00a0\u00a0| E_AMult :  \u2200(a[1] a[2]: aexp) (n[1] n[2] : nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(a[1] \u21d3 n[1]) \u2192 (a[2] \u21d3 n[2]) \u2192 (AMult a[1] a[2]) \u21d3 (n[1] * n[2])\n\nwhere \"a '\u21d3' n\" := (aevalR a n) : type_scope.\n\nEnd aevalR_extended.\n\n```", "```\n\n# Expressions With Variables\n\n    Let's turn our attention back to defining Imp.  The next thing we\n    need to do is to enrich our arithmetic and boolean expressions\n    with variables.  To keep things simple, we'll assume that all\n    variables are global and that they only hold numbers.\n\n```", "```\nDefinition state := total_map nat.\n\nDefinition empty_state : state :=\n\u00a0\u00a0t_empty 0.\n\n```", "```\nInductive aexp : Type :=\n\u00a0\u00a0| ANum : nat \u2192 aexp\n\u00a0\u00a0| AId : id \u2192 aexp                (*\u00a0<-----\u00a0NEW\u00a0*)\n\u00a0\u00a0| APlus : aexp \u2192 aexp \u2192 aexp\n\u00a0\u00a0| AMinus : aexp \u2192 aexp \u2192 aexp\n\u00a0\u00a0| AMult : aexp \u2192 aexp \u2192 aexp.\n\n```", "```\nDefinition W : id := Id \"W\".\nDefinition X : id := Id \"X\".\nDefinition Y : id := Id \"Y\".\nDefinition Z : id := Id \"Z\".\n\n```", "```\nInductive bexp : Type :=\n\u00a0\u00a0| BTrue : bexp\n\u00a0\u00a0| BFalse : bexp\n\u00a0\u00a0| BEq : aexp \u2192 aexp \u2192 bexp\n\u00a0\u00a0| BLe : aexp \u2192 aexp \u2192 bexp\n\u00a0\u00a0| BNot : bexp \u2192 bexp\n\u00a0\u00a0| BAnd : bexp \u2192 bexp \u2192 bexp.\n\n```", "```\nFixpoint aeval (st : state) (a : aexp) : nat :=\n\u00a0\u00a0match a with\n\u00a0\u00a0| ANum n \u21d2 n\n\u00a0\u00a0| AId x \u21d2 st x                                (*\u00a0<-----\u00a0NEW\u00a0*)\n\u00a0\u00a0| APlus a[1] a[2] \u21d2 (aeval st a[1]) + (aeval st a[2])\n\u00a0\u00a0| AMinus a[1] a[2]  \u21d2 (aeval st a[1]) - (aeval st a[2])\n\u00a0\u00a0| AMult a[1] a[2] \u21d2 (aeval st a[1]) * (aeval st a[2])\n\u00a0\u00a0end.\n\nFixpoint beval (st : state) (b : bexp) : bool :=\n\u00a0\u00a0match b with\n\u00a0\u00a0| BTrue       \u21d2 true\n\u00a0\u00a0| BFalse      \u21d2 false\n\u00a0\u00a0| BEq a[1] a[2]   \u21d2 beq_nat (aeval st a[1]) (aeval st a[2])\n\u00a0\u00a0| BLe a[1] a[2]   \u21d2 leb (aeval st a[1]) (aeval st a[2])\n\u00a0\u00a0| BNot b[1]     \u21d2 negb (beval st b[1])\n\u00a0\u00a0| BAnd b[1] b[2]  \u21d2 andb (beval st b[1]) (beval st b[2])\n\u00a0\u00a0end.\n\nExample aexp1 :\n\u00a0\u00a0aeval (t_update empty_state X 5)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(APlus (ANum 3) (AMult (AId X) (ANum 2)))\n\u00a0\u00a0= 13.\n\n    Proof. reflexivity. Qed.\n\nExample bexp1 :\n\u00a0\u00a0beval (t_update empty_state X 5)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(BAnd BTrue (BNot (BLe (AId X) (ANum 4))))\n\u00a0\u00a0= true.\n\n    Proof. reflexivity. Qed.\n\n```", "```\n\n## Syntax\n\n    Informally, commands c are described by the following BNF\n    grammar.  (We choose this slightly awkward concrete syntax for the\n    sake of being able to define Imp syntax using Coq's Notation\n    mechanism.  In particular, we use IFB to avoid conflicting with\n    the if notation from the standard library.)\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0Z\u00a0::=\u00a0X;;\n\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a01;;\n\u00a0\u00a0\u00a0\u00a0\u00a0WHILE\u00a0not\u00a0(Z\u00a0=\u00a00)\u00a0DO\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0Y\u00a0*\u00a0Z;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Z\u00a0::=\u00a0Z\u00a0-\u00a01\n\u00a0\u00a0\u00a0\u00a0\u00a0END\n\n    When this command terminates, the variable Y will contain the\n   factorial of the initial value of X. \n\n    Here is the formal definition of the abstract syntax of\n    commands:\n\n```", "```\n\n    As usual, we can use a few Notation declarations to make things\n    more readable.  To avoid conflicts with Coq's built-in notations,\n    we keep this light \u2014 in particular, we don't introduce any\n    notations for aexps and bexps to avoid confusion with the\n    numeric and boolean operators we've already defined.\n\n```", "```\n\n    For example, here is the factorial function again, written as a\n    formal definition to Coq:\n\n```", "```\n\n## More Examples\n\n    Assignment:\n\n```", "```\n\n### Loops\n\n```", "```\n\n### An infinite loop:\n\n```", "```\n\n# Evaluating Commands\n\n    Next we need to define what it means to evaluate an Imp command.\n    The fact that WHILE loops don't necessarily terminate makes defining\n    an evaluation function tricky...\n\n```", "```\nFixpoint ceval_fun_no_while (st : state) (c : com)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: state :=\n\u00a0\u00a0match c with\n\u00a0\u00a0\u00a0\u00a0| SKIP \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st\n\u00a0\u00a0\u00a0\u00a0| x ::= a[1] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t_update st x (aeval st a[1])\n\u00a0\u00a0\u00a0\u00a0| c[1] ;; c[2] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0let st' := ceval_fun_no_while st c[1] in\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval_fun_no_while st' c[2]\n\u00a0\u00a0\u00a0\u00a0| IFB b THEN c[1] ELSE c[2] FI \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (beval st b)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0then ceval_fun_no_while st c[1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else ceval_fun_no_while st c[2]\n\u00a0\u00a0\u00a0\u00a0| WHILE b DO c END \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0st  (*\u00a0bogus\u00a0*)\n\u00a0\u00a0end.\n\n```", "```\n  Fixpoint ceval_fun (st : state) (c : com) : state :=\n    match c with\n      ...\n      | WHILE b DO c END =>\n          if (beval st b)\n            then ceval_fun st (c; WHILE b DO c END)\n            else st\n    end.\n\n```", "```\n         Fixpoint loop_false (n : nat) : False := loop_false n.\n\n```", "```\n\n## Evaluation as a Relation\n\n    Here's a better way: define ceval as a *relation* rather than a\n    *function* \u2014 i.e., define it in Prop instead of Type, as we\n    did for aevalR above. \n\n    This is an important change.  Besides freeing us from awkward\n    workarounds, it gives us a lot more flexibility in the definition.\n    For example, if we add nondeterministic features like any to the\n    language, we want the definition of evaluation to be\n    nondeterministic \u2014 i.e., not only will it not be total, it will\n    not even be a function! \n\n    We'll use the notation c / st \u21d3 st' for the ceval relation:\n    c / st \u21d3 st' means that executing program c in a starting\n    state st results in an ending state st'.  This can be\n    pronounced \"c takes state st to st'\". \n\n### Operational Semantics\n\n    Here is an informal definition of evaluation, presented as inference\n    rules for readability:\n\n           |\n\n                        (E_Skip) \u00a0\n           |\n\n* * *\n\n           |\n\n                        SKIP\u00a0/\u00a0st\u00a0\u21d3\u00a0st\n           |\n\n                     |\n\n                        aeval\u00a0st\u00a0a[1]\u00a0=\u00a0n\n           |\n\n                        (E_Ass) \u00a0\n           |\n\n* * *\n\n           |\n\n                        x\u00a0:=\u00a0a[1]\u00a0/\u00a0st\u00a0\u21d3\u00a0(t_update\u00a0st\u00a0x\u00a0n)\n           |\n\n                     |\n\n                        c[1]\u00a0/\u00a0st\u00a0\u21d3\u00a0st'\n           |\n\n                     |\n\n                        c[2]\u00a0/\u00a0st'\u00a0\u21d3\u00a0st''\n           |\n\n                        (E_Seq) \u00a0\n           |\n\n* * *\n\n           |\n\n                        c[1];;c[2]\u00a0/\u00a0st\u00a0\u21d3\u00a0st''\n           |\n\n                     |\n\n                        beval\u00a0st\u00a0b[1]\u00a0=\u00a0true\n           |\n\n                     |\n\n                        c[1]\u00a0/\u00a0st\u00a0\u21d3\u00a0st'\n           |\n\n                        (E_IfTrue) \u00a0\n           |\n\n* * *\n\n           |\n\n                        IF\u00a0b[1]\u00a0THEN\u00a0c[1]\u00a0ELSE\u00a0c[2]\u00a0FI\u00a0/\u00a0st\u00a0\u21d3\u00a0st'\n           |\n\n                     |\n\n                        beval\u00a0st\u00a0b[1]\u00a0=\u00a0false\n           |\n\n                     |\n\n                        c[2]\u00a0/\u00a0st\u00a0\u21d3\u00a0st'\n           |\n\n                        (E_IfFalse) \u00a0\n           |\n\n* * *\n\n           |\n\n                        IF\u00a0b[1]\u00a0THEN\u00a0c[1]\u00a0ELSE\u00a0c[2]\u00a0FI\u00a0/\u00a0st\u00a0\u21d3\u00a0st'\n           |\n\n                     |\n\n                        beval\u00a0st\u00a0b\u00a0=\u00a0false\n           |\n\n                        (E_WhileEnd) \u00a0\n           |\n\n* * *\n\n           |\n\n                        WHILE\u00a0b\u00a0DO\u00a0c\u00a0END\u00a0/\u00a0st\u00a0\u21d3\u00a0st\n           |\n\n                     |\n\n                        beval\u00a0st\u00a0b\u00a0=\u00a0true\n           |\n\n                     |\n\n                        c\u00a0/\u00a0st\u00a0\u21d3\u00a0st'\n           |\n\n                     |\n\n                        WHILE\u00a0b\u00a0DO\u00a0c\u00a0END\u00a0/\u00a0st'\u00a0\u21d3\u00a0st''\n           |\n\n                        (E_WhileLoop) \u00a0\n           |\n\n* * *\n\n           |\n\n                        WHILE\u00a0b\u00a0DO\u00a0c\u00a0END\u00a0/\u00a0st\u00a0\u21d3\u00a0st''\n           |\n\n                     |\n\n    Here is the formal definition.  Make sure you understand\n    how it corresponds to the inference rules.\n\n```", "```\n\n    The cost of defining evaluation as a relation instead of a\n    function is that we now need to construct *proofs* that some\n    program evaluates to some result state, rather than just letting\n    Coq's computation mechanism do it for us.\n\n```", "```\n\n#### Exercise: 2 stars (ceval_example2)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 3 stars, advanced (pup_to_n)\n\n    Write an Imp program that sums the numbers from 1 to\n   X (inclusive: 1 + 2 + ... + X) in the variable Y.\n   Prove that this program executes as intended for X = 2\n   (this is trickier than you might expect).\n\n```", "```\n\n    \u2610\n\n```", "```\nTheorem ceval_deterministic: \u2200c st st[1] st[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[1]  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0st[1] = st[2].\n\n    Proof.\n\u00a0\u00a0intros c st st[1] st[2] E[1] E[2].\n\u00a0\u00a0generalize dependent st[2].\n\u00a0\u00a0induction E[1];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intros st[2] E[2]; inversion E[2]; subst.\n\u00a0\u00a0- (*\u00a0E_Skip\u00a0*) reflexivity.\n\u00a0\u00a0- (*\u00a0E_Ass\u00a0*) reflexivity.\n\u00a0\u00a0- (*\u00a0E_Seq\u00a0*)\n\u00a0\u00a0\u00a0\u00a0assert (st' = st'0) as EQ[1].\n\u00a0\u00a0\u00a0\u00a0{ (*\u00a0Proof\u00a0of\u00a0assertion\u00a0*) apply IHE1_1; assumption. }\n\u00a0\u00a0\u00a0\u00a0subst st'0.\n\u00a0\u00a0\u00a0\u00a0apply IHE1_2. assumption.\n\u00a0\u00a0- (*\u00a0E_IfTrue,\u00a0b[1]\u00a0evaluates\u00a0to\u00a0true\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHE1. assumption.\n\u00a0\u00a0- (*\u00a0E_IfTrue,\u00a0\u00a0b[1]\u00a0evaluates\u00a0to\u00a0false\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite H in H[5]. inversion H[5].\n\u00a0\u00a0- (*\u00a0E_IfFalse,\u00a0b[1]\u00a0evaluates\u00a0to\u00a0true\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rewrite H in H[5]. inversion H[5].\n\u00a0\u00a0- (*\u00a0E_IfFalse,\u00a0b[1]\u00a0evaluates\u00a0to\u00a0false\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHE1. assumption.\n\u00a0\u00a0- (*\u00a0E_WhileEnd,\u00a0b[1]\u00a0evaluates\u00a0to\u00a0false\u00a0*)\n\u00a0\u00a0\u00a0\u00a0reflexivity.\n\u00a0\u00a0- (*\u00a0E_WhileEnd,\u00a0b[1]\u00a0evaluates\u00a0to\u00a0true\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rewrite H in H[2]. inversion H[2].\n\u00a0\u00a0- (*\u00a0E_WhileLoop,\u00a0b[1]\u00a0evaluates\u00a0to\u00a0false\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rewrite H in H[4]. inversion H[4].\n\u00a0\u00a0- (*\u00a0E_WhileLoop,\u00a0b[1]\u00a0evaluates\u00a0to\u00a0true\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assert (st' = st'0) as EQ[1].\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ (*\u00a0Proof\u00a0of\u00a0assertion\u00a0*) apply IHE1_1; assumption. }\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subst st'0.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHE1_2. assumption. Qed.\n\n```", "```\nTheorem plus2_spec : \u2200st n st',\n\u00a0\u00a0st X = n \u2192\n\u00a0\u00a0plus2 / st \u21d3 st' \u2192\n\u00a0\u00a0st' X = n + 2.\nProof.\n\u00a0\u00a0intros st n st' HX Heval.\n\n```", "```\n\u00a0\u00a0inversion Heval. subst. clear Heval. simpl.\n\u00a0\u00a0apply t_update_eq. Qed.\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\nTheorem loop_never_stops : \u2200st st',\n\u00a0\u00a0~(loop / st \u21d3 st').\nProof.\n\u00a0\u00a0intros st st' contra. unfold loop in contra.\n\u00a0\u00a0remember (WHILE BTrue DO SKIP END) as loopdef\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0eqn:Heqloopdef.\n\n```", "```\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nFixpoint no_whiles (c : com) : bool :=\n\u00a0\u00a0match c with\n\u00a0\u00a0| SKIP \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0true\n\u00a0\u00a0| _ ::= _ \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0true\n\u00a0\u00a0| c[1] ;; c[2] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0andb (no_whiles c[1]) (no_whiles c[2])\n\u00a0\u00a0| IFB _ THEN ct ELSE cf FI \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0andb (no_whiles ct) (no_whiles cf)\n\u00a0\u00a0| WHILE _ DO _ END  \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0false\n\u00a0\u00a0end.\n\n```", "```\nInductive no_whilesR: com \u2192 Prop :=\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n.\n\nTheorem no_whiles_eqv:\n\u00a0\u00a0\u00a0\u2200c, no_whiles c = true \u2194 no_whilesR c.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n\n# Additional Exercises\n\n#### Exercise: 3 stars (stack_compiler)\n\n    HP Calculators, programming languages like Forth and Postscript\n    and abstract machines like the Java Virtual Machine all evaluate\n    arithmetic expressions using a stack. For instance, the expression\n\n```", "```\n\n    would be entered as\n\n```", "```\n\n    and evaluated like this (where we show the program being evaluated\n   on the right and the contents of the stack on the left):\n\n```", "```\n\n    The task of this exercise is to write a small compiler that\n  translates aexps into stack machine instructions.\n\n    The instruction set for our stack language will consist of the\n  following instructions:\n\n*   SPush n: Push the number n on the stack.\n\n*   SLoad x: Load the identifier x from the store and push it on the stack\n\n*   SPlus: Pop the two top numbers from the stack, add them, and push the result onto the stack.\n\n*   SMinus: Similar, but subtract.\n\n*   SMult: Similar, but multiply.\n\n```", "```\n\n    Write a function to evaluate programs in the stack language. It\n    should take as input a state, a stack represented as a list of\n    numbers (top stack item is the head of the list), and a program\n    represented as a list of instructions, and it should return the\n    stack after executing the program.  Test your function on the\n    examples below.\n\n    Note that the specification leaves unspecified what to do when\n    encountering an SPlus, SMinus, or SMult instruction if the\n    stack contains less than two elements.  In a sense, it is\n    immaterial what we do, since our compiler will never emit such a\n    malformed program.\n\n```", "```\n\n    Next, write a function that compiles an aexp into a stack\n    machine program. The effect of running the program should be the\n    same as pushing the value of the expression on the stack.\n\n```", "```\n\n    After you've defined s_compile, prove the following to test\n    that it works.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 4 stars, advanced (stack_compiler_correct)\n\n    Now we'll prove the correctness of the compiler implemented in the\n    previous exercise.  Remember that the specification left\n    unspecified what to do when encountering an SPlus, SMinus, or\n    SMult instruction if the stack contains less than two\n    elements.  (In order to make your correctness proof easier you\n    might find it helpful to go back and change your implementation!)\n\n    Prove the following theorem.  You will need to start by stating a\n    more general lemma to get a usable induction hypothesis; the main\n    theorem will then be a simple corollary of this lemma.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 3 stars, optional (short_circuit)\n\n    Most modern programming languages use a \"short-circuit\" evaluation\n    rule for boolean and: to evaluate BAnd b[1] b[2], first evaluate\n    b[1].  If it evaluates to false, then the entire BAnd\n    expression evaluates to false immediately, without evaluating\n    b[2].  Otherwise, b[2] is evaluated to determine the result of the\n    BAnd expression.\n\n    Write an alternate version of beval that performs short-circuit\n    evaluation of BAnd in this manner, and prove that it is\n    equivalent to beval.\n\n```", "```\n\n    \u2610\n\n```", "```\n\n#### Exercise: 4 stars, advanced (break_imp)\n\n    Imperative languages like C and Java often include a break or\n    similar statement for interrupting the execution of loops. In this\n    exercise we consider how to add break to Imp.  First, we need to\n    enrich the language of commands with an additional case.\n\n```", "```\n\n    Next, we need to define the behavior of BREAK.  Informally,\n    whenever BREAK is executed in a sequence of commands, it stops\n    the execution of that sequence and signals that the innermost\n    enclosing loop should terminate.  (If there aren't any\n    enclosing loops, then the whole program simply terminates.)  The\n    final state should be the same as the one in which the BREAK\n    statement was executed.\n\n    One important point is what to do when there are multiple loops\n    enclosing a given BREAK. In those cases, BREAK should only\n    terminate the *innermost* loop. Thus, after executing the\n    following...\n\n```", "```\nInductive result : Type :=\n\u00a0\u00a0| SContinue : result\n\u00a0\u00a0| SBreak : result.\n\nReserved Notation \"c1 '/' st '\u21d3' s '/' st'\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(at level 40, st, s at level 39).\n\n```", "```\nInductive ceval : com \u2192 state \u2192 result \u2192 state \u2192 Prop :=\n\u00a0\u00a0| E_Skip : \u2200st,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CSkip / st \u21d3 SContinue / st\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n\u00a0\u00a0where \"c1 '/' st '\u21d3' s '/' st'\" := (ceval c[1] st s st').\n\n```", "```\nTheorem break_ignore : \u2200c st st' s,\n\u00a0\u00a0\u00a0\u00a0\u00a0(BREAK;; c) / st \u21d3 s / st' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0st = st'.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nTheorem while_continue : \u2200b c st st' s,\n\u00a0\u00a0(WHILE b DO c END) / st \u21d3 s / st' \u2192\n\u00a0\u00a0s = SContinue.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nTheorem while_stops_on_break : \u2200b c st st',\n\u00a0\u00a0beval st b = true \u2192\n\u00a0\u00a0c / st \u21d3 SBreak / st' \u2192\n\u00a0\u00a0(WHILE b DO c END) / st \u21d3 SContinue / st'.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem while_break_true : \u2200b c st st',\n\u00a0\u00a0(WHILE b DO c END) / st \u21d3 SContinue / st' \u2192\n\u00a0\u00a0beval st' b = true \u2192\n\u00a0\u00a0\u2203st'', c / st'' \u21d3 SBreak / st'.\nProof.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem ceval_deterministic: \u2200(c:com) st st[1] st[2] s[1] s[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 s[1] / st[1]  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 s[2] / st[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0st[1] = st[2] \u2227 s[1] = s[2].\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nEnd BreakImp.\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n(*\u00a0$Date:\u00a02016-12-20\u00a010:33:44\u00a0-0500\u00a0(Tue,\u00a020\u00a0Dec\u00a02016)\u00a0$\u00a0*)\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "``` \n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]