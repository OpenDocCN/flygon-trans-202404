- en: About Me
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于我
- en: About Me
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于我
- en: Hi, I'm [Dumindu Madunuwan](https://lk.linkedin.com/in/dumindunuwan). I'm a
    web developer, mainly PHP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，我是[Dumindu Madunuwan](https://lk.linkedin.com/in/dumindunuwan)。我是一名网页开发者，主要使用PHP。
- en: Around 2007–2009, I chose web development because at that time I truly believed,
    web will be the next ultimate, system independent & language independent platform
    and the next generation software ecosystem will be implemented top of browsers.
    The web I expected is sort of similar to this.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在2007年至2009年，我选择了网页开发，因为那时我真正相信，网络将成为下一个终极、系统独立和语言独立的平台，下一代软件生态系统将在浏览器之上实现。我期望的网络与此有些相似。
- en: '[![The Future of The Web : Mozilla Labs Aurora Concept Browser](mozilla_labs_aurora_concept_browser.png)](http://www.youtube.com/watch?v=FZ-zvx1QCcA
    "The Future of The Web : Mozilla Labs Aurora Concept Browser")'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[![Web的未来：Mozilla Labs Aurora概念浏览器](mozilla_labs_aurora_concept_browser.png)](http://www.youtube.com/watch?v=FZ-zvx1QCcA
    "Web的未来：Mozilla Labs Aurora概念浏览器")'
- en: Like some of web developers, I truly bet on HTML5 over native apps on past years.
    I learned about HTML5, CSS3, RWD, Mobile First Design, UI/UX and etc. Now a days
    we have hundreds of front-end frameworks but still web technologies can't win
    over native apps, especially on performance.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 像一些网页开发者一样，我过去确实更看好HTML5而不是本机应用程序。我学习了HTML5、CSS3、RWD、Mobile First Design、UI/UX等。如今，我们有数百个前端框架，但仍然无法胜过本机应用程序，尤其是在性能方面。
- en: It’s true that web technologies are slowly adapting for native app development
    via asmjs, NativeScript, Electron, WebAssembly, React Native but future web application
    development will be more complex because of Emerging Connected Cars and VR Ecosystems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，网络技术正在逐渐适应通过asmjs、NativeScript、Electron、WebAssembly、React Native进行本机应用程序开发，但由于新兴的联网汽车和虚拟现实生态系统，未来的网络应用程序开发将变得更加复杂。
- en: Also in the other hand, now we have much powerful alternatives for PHP, like
    node and Go. So as a PHP developer its time to learn something new, a new language.
    I chose Rust because it's an interesting language to learn and next generation
    browser engine, [Servo](https://servo.org/) is written using Rust.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，现在我们有许多强大的PHP替代品，比如node和Go。所以作为PHP开发者，现在是学习新东西的时候，学习一门新的语言。我选择Rust是因为它是一门有趣的学习语言，下一代浏览器引擎[Servo](https://servo.org/)是用Rust编写的。
- en: '* * *'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[![Medium](medium.png)](https://medium.com/@dumindu "Medium") [![Ycombinator](ycombinator.png)](https://news.ycombinator.com/user?id=dumindunuwan
    "Ycombinator") [![Reddit](reddit.png)](https://www.reddit.com/user/dumindunuwan/
    "Reddit") [![Github](github.png)](https://github.com/dumindu/ "Github") [![LinkedIn](linkedin.png)](https://lk.linkedin.com/in/dumindunuwan/
    "LinkedIn") [![Pinterest](pinterest.png)](https://www.pinterest.com/dumindu/ "Pinterest")
    [![Behance](behance.png)](https://www.behance.net/dumindu-madunuwan/ "Behance")'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[![Medium](medium.png)](https://medium.com/@dumindu "Medium") [![Ycombinator](ycombinator.png)](https://news.ycombinator.com/user?id=dumindunuwan
    "Ycombinator") [![Reddit](reddit.png)](https://www.reddit.com/user/dumindunuwan/
    "Reddit") [![Github](github.png)](https://github.com/dumindu/ "Github") [![LinkedIn](linkedin.png)](https://lk.linkedin.com/in/dumindunuwan/
    "LinkedIn") [![Pinterest](pinterest.png)](https://www.pinterest.com/dumindu/ "Pinterest")
    [![Behance](behance.png)](https://www.behance.net/dumindu-madunuwan/ "Behance")'
- en: Why Rust?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Rust？
- en: Why Rust?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Rust？
- en: Rust initially designed and developed by Mozilla employee Graydon Hoare as a
    personal project. Mozilla began sponsoring the project in 2009 and announced it
    in 2010\. But the first stable release, Rust 1.0 released on May 15, 2015.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rust最初由Mozilla员工Graydon Hoare作为个人项目设计和开发。Mozilla于2009年开始赞助该项目，并在2010年宣布。但是，第一个稳定版本Rust
    1.0于2015年5月15日发布。
- en: '[![Rethinking Systems Programming](rust_control_over_safety.png)](http://thoughtram.io/rust-and-nickel/#/11)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[![重新思考系统编程](rust_control_over_safety.png)](http://thoughtram.io/rust-and-nickel/#/11)'
- en: The goal of Rust is to be a good language for creating highly concurrent and
    highly safe systems. Also as you can see on above diagram, Rust designed to provide
    speed and safety at the same time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的目标是成为创建高度并发和高度安全系统的良好语言。正如您在上图中所看到的，Rust旨在同时提供速度和安全性。
- en: '"Rust is a systems programming language focused on three goals: safety, speed,
    and concurrency."'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"Rust是一种专注于三个目标的系统编程语言：安全性、速度和并发性。"'
- en: __ Rust Documentation
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: __ Rust文档
- en: Rust is very young and very modern language. It's a **compiled programming language**
    and it uses [LLVM](https://en.wikipedia.org/wiki/LLVM) on its backend. Also Rust
    is a **multi-paradigm programming language**, it supports imperative procedural,
    concurrent actor, object-oriented and pure functional styles. It also supports
    generic programming and meta programming, in both static and dynamic styles.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 是一种非常年轻和现代的语言。它是一种**编译型编程语言**，在后端使用[LLVM](https://en.wikipedia.org/wiki/LLVM)。此外，Rust
    是一种**多范式编程语言**，支持命令式过程、并发actor、面向对象和纯函数式风格。它还支持静态和动态风格的泛型编程和元编程。
- en: Its design elements came from a wide range of sources.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 其设计元素来自各种来源。
- en: 'Abstract Machine Model : **C**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象机器模型：**C**
- en: 'Data types : **C, SML, OCaml, Lisp, Limbo**'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型：**C, SML, OCaml, Lisp, Limbo**
- en: 'Optional Bindings : **Swift**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选绑定：**Swift**
- en: 'Hygienic Macros : **Scheme**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卫生宏：**Scheme**
- en: 'Functional Programming : **Haskell, OCaml, F#**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程：**Haskell, OCaml, F#**
- en: 'Attributes : **ECMA**-335'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性：**ECMA**-335
- en: 'Memory Model and Memory Management : **C++, ML Kit, Cyclone**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存模型和内存管理：**C++, ML Kit, Cyclone**
- en: 'Type Classes : **Haskell**'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型类：**Haskell**
- en: 'Crate : Assembly in the **ECMA**-335 CLI model'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箱：**ECMA**-335 CLI 模型中的汇编
- en: 'Channels and Concurrency : **Newsqueak, Alef, Limbo**'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道和并发性：**Newsqueak, Alef, Limbo**
- en: 'Message passing and Thread failure : **Erlang**'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息传递和线程失败：**Erlang**
- en: and etc.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。
- en: Rust **doesn't use an automated garbage collection** system(GC) by default.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Rust **默认不使用自动垃圾回收**系统（GC）。
- en: 🔎 One of Rust’s most unique and compelling features is [ownership](https://doc.rust-lang.org/stable/book/ownership.html),
    which uses to achieves memory safety. Rust creates memory pointers optimistically,
    checks memory pointers’ limited accesses at the compiler time with the usage of
    [References and Borrowing](https://doc.rust-lang.org/stable/book/references-and-borrowing.html).
    And it does automatic compile time memory management by checking the [Lifetimes](https://doc.rust-lang.org/stable/book/lifetimes.html).
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 🔎 Rust 最独特和引人注目的特性之一是[所有权](https://doc.rust-lang.org/stable/book/ownership.html)，它用于实现内存安全。
    Rust 乐观地创建内存指针，通过使用[引用和借用](https://doc.rust-lang.org/stable/book/references-and-borrowing.html)在编译时检查内存指针的有限访问。它通过检查[Lifetimes](https://doc.rust-lang.org/stable/book/lifetimes.html)实现自动的编译时内存管理。
- en: Rust compiler observe the code at compiler time and help to [prevent many types
    of errors](https://doc.rust-lang.org/error-index.html) that are possible to write
    in C++
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 编译器在编译时观察代码，并帮助[防止许多种可能在 C++ 中编写的错误](https://doc.rust-lang.org/error-index.html)。
- en: Installation
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: Installation
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: There are many ways to install Rust on your system. For the moment the official
    way to install Rust is using [Rustup](https://rustup.rs/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多安装 Rust 的方法。目前官方安装 Rust 的方式是使用[Rustup](https://rustup.rs/)。
- en: '[🕮](https://github.com/rust-lang-nursery/rustup.rs) Rustup installs The Rust
    Programming Language from the official release channels, enabling you to easily
    switch between stable, beta, and nightly compilers and keep them updated. It makes
    cross-compiling simpler with binary builds of the standard library for common
    platforms.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[🕮](https://github.com/rust-lang-nursery/rustup.rs) Rustup 从官方发布渠道安装 Rust 编程语言，使您可以轻松在稳定版、测试版和夜间版编译器之间切换并保持其更新。它通过为常见平台提供标准库的二进制构建，简化了交叉编译。'
- en: '[🕮](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup installs
    `rustc`, `cargo`, `rustup` and other standard tools to Cargo''s `bin` directory.
    On Unix it is located at `$HOME/.cargo/bin` and on Windows at `%USERPROFILE%\.cargo\bin`.
    This is the same directory that `cargo install` will install Rust programs and
    Cargo plugins.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[🕮](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup 将 `rustc`、`cargo`、`rustup`
    和其他标准工具安装到 Cargo 的 `bin` 目录中。在 Unix 上，它位于 `$HOME/.cargo/bin`，在 Windows 上位于 `%USERPROFILE%\.cargo\bin`。这是
    `cargo install` 将安装 Rust 程序和 Cargo 插件的相同目录。'
- en: '**💡** More information can be found on the [Github page of Rustup project](https://github.com/rust-lang-nursery/rustup.rs).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**💡** 更多信息可以在[Rustup 项目的 Github 页面](https://github.com/rust-lang-nursery/rustup.rs)找到。'
- en: After installing Rust you can check the current version by typing `rustc --version`
    or`rustc -V` on your terminal to verify the success of the installation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Rust 后，您可以在终端上键入 `rustc --version` 或 `rustc -V` 来检查当前版本，以验证安装成功。
- en: Hello World
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World
- en: Hello World
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`fn` means function. main function is the beginning of every Rust program.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`fn` 表示函数。主函数是每个 Rust 程序的起点。'
- en: '`println!` prints text to the console and its *!* indicate that it’s a [macro](https://doc.rust-lang.org/book/macros.html)
    instead of a function.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`println!` 将文本打印到控制台，其 *!* 表示它是一个 [宏](https://doc.rust-lang.org/book/macros.html)
    而不是函数。'
- en: 💡 Rust files should have .rs file extension and if you’re using more than one
    word for the file name, follow the [snake_case](https://en.wikipedia.org/wiki/Snake_case).
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 💡 Rust 文件应该具有 .rs 文件扩展名，如果文件名使用了多个单词，请遵循 [snake_case](https://en.wikipedia.org/wiki/Snake_case)。
- en: compiling via `rustc file.rs`
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `rustc file.rs` 进行编译
- en: executing by `./file` on Linux and Mac or `file.exe` on Windows
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 和 Mac 上通过 `./file` 执行，在 Windows 上通过 `file.exe` 执行
- en: '* * *'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 💯 These are the other usages of println! macro,
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 💯 这是 println! 宏的其他用法，
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Cargo, Crates and Basic Project Structure
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cargo、Crates 和基本项目结构
- en: Cargo, Crates and Basic Project Structure
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cargo、Crates 和基本项目结构
- en: Cargo is Rust’s build-in Package Manager. But mainly it uses for,
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Cargo 是 Rust 的内置包管理器。但主要用于，
- en: '▸ Create new project : `cargo new`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ▸ 创建新项目：`cargo new`
- en: '▸ Update dependencies : `cargo update`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ▸ 更新依赖：`cargo update`
- en: '▸ Build project : `cargo build`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ▸ 构建项目：`cargo build`
- en: '▸ Build and run a project : `cargo run`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ▸ 构建并运行项目：`cargo run`
- en: '▸ Run tests : `cargo test`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ▸ 运行测试：`cargo test`
- en: '▸ Generate documentation via rustdoc : `cargo doc`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ▸ 通过 rustdoc 生成文档：`cargo doc`
- en: Other than that there are some cargo commands, especially for publishing crates
    directly via cargo.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还有一些 Cargo 命令，专门用于通过 cargo 直接发布 crates。
- en: '▸ `cargo login` : acquiring an API token'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ▸ `cargo login`：获取 API 令牌
- en: '▸ `cargo package` : make the local create uploadable to crates.io'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ▸ `cargo package`：使本地创建可上传到 crates.io
- en: '▸ `cargo publish` : make the local create uploadable to crates.io and upload
    the crate'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ▸ `cargo publish`：使本地创建可上传到 crates.io 并上传 crate
- en: ⭐️ **A crate is a package. Crates can be shared via** [**Cargo**](https://crates.io/)**.**
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ **一个 crate 是一个 package。Crates 可以通过** [**Cargo**](https://crates.io/) **分享。**
- en: '* * *'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: A crate can produce an executable or a library. In other words, it can be a
    binary crate or a library crate.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 crate 可以生成一个可执行文件或一个库。换句话说，它可以是一个二进制 crate 或一个库 crate。
- en: '`cargo new crate_name --bin` : produces an **executable**'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cargo new crate_name --bin`：生成一个 **可执行文件**'
- en: '`cargo new crate_name --lib` OR `cargo new crate_name`: produces a **library**'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cargo new crate_name --lib` 或 `cargo new crate_name`：生成一个 **库**'
- en: The first one generates,
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种生成方式为，
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: and the second one generates,
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种生成方式为，
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Cargo.toml**(capital c) is the configuration file which contains all of the
    metadata that Cargo needs to compile your project.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cargo.toml**（大写的 c）是配置文件，包含了 Cargo 编译项目所需的所有元数据。'
- en: '**src** folder is the place to store the source code.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**src** 文件夹是存储源代码的地方。'
- en: Each crate has an implicit crate root/ entry point. **main.rs** is the crate
    root for a binary crate and **lib.rs** is the crate root for a library crate.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 crate 都有一个隐式 crate 根 / 入口点。对于二进制 crate，**main.rs** 是 crate 根，对于库 crate，**lib.rs**
    是 crate 根。
- en: 💡 When we build a binary crate via `cargo build` or `cargo run`, the executable
    file will be stored in **target/debug/** folder. But when build it via `cargo
    build --release` for a release it will be stored in **target/release/** folder.
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 💡 当我们通过 `cargo build` 或 `cargo run` 构建一个二进制 crate 时，可执行文件将存储在 **target/debug/**
    文件夹中。但当通过 `cargo build --release` 构建用于发布的版本时，可执行文件将存储在 **target/release/** 文件夹中。
- en: '* * *'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: This is how [Cargo Docs describes](http://doc.crates.io/guide.html#project-layout)
    about the recommended Project Layout,
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 [Cargo Docs 描述](http://doc.crates.io/guide.html#project-layout) 推荐的项目布局，
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ▸ Source code goes in the `src` directory.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ▸ 源代码放在 `src` 目录中。
- en: ▸ The default library file is `src/lib.rs`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ▸ 默认库文件为 `src/lib.rs`。
- en: ▸ The default executable file is `src/main.rs`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ▸ 默认可执行文件为 `src/main.rs`。
- en: ▸ Other executables can be placed in `src/bin/*.rs`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ▸ 其他可执行文件可以放在 `src/bin/*.rs` 中。
- en: ▸ Integration tests go in the `tests` directory (unit tests go in each file
    they're testing).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ▸ 集成测试放在 `tests` 目录中（单元测试放在它们所测试的每个文件中）。
- en: ▸ Examples go in the `examples` directory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ▸ 示例放在 `examples` 目录中。
- en: ▸ Benchmarks go in the `benches` directory.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ▸ 基准测试放在 `benches` 目录中。
- en: Comments and Documenting the code
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释和代码文档
- en: Comments and Documenting the code
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释和代码文档
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Nested block comments are supported.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 支持嵌套的块注释。
- en: 💡 **Always avoid block comments, Use line comments instead.**
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 💡 **始终避免使用块注释，改用行注释。**
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Doc comments support Markdown notations. Using `cargo doc`, the HTML documentation
    can be generated from these doc comments. Let’s see the difference between the
    two sets of doc comments.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 文档注释支持 Markdown 标记。使用 `cargo doc` 命令，可以从这些文档注释生成 HTML 文档。让我们看看这两组文档注释之间的区别。
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see both use to document the same module. First comment has been
    added before the module while the second one has been added inside the module.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，两者都用于记录相同的模块。第一个注释已添加到模块之前，而第二个注释已添加到模块内部。
- en: 💡 **Only use //! to write crate and module-level documentation, nothing else.
    When using mod blocks, use /// outside of the block.**
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 💡 **只使用//!编写 crate 和模块级文档，不要写其他内容。使用 mod 块时，在块外使用///。**
- en: Also we can use **doc attributes** for documenting the code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用**文档属性**来记录代码。
- en: 🔎 An [attribute](https://doc.rust-lang.org/reference.html#attributes) is a general,
    free-form **metadatum** that is interpreted according to name, convention, and
    language and compiler version. Any item declaration may have an attribute applied
    to it.
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 🔎 [属性](https://doc.rust-lang.org/reference.html#attributes)是一个通用的、自由形式的**元数据**，根据名称、约定和语言和编译器版本进行解释。任何项目声明都可以应用属性。
- en: In here each comments are equivalent to relevant data attributes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的每个注释都等同于相关的数据属性。
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Variable bindings , Constants & Statics
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量绑定，常量和静态变量
- en: Variable bindings , Constants & Statics
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量绑定，常量和静态变量
- en: ⭐️ In Rust variable are **immutable by default**, so we call them **Variable
    bindings**. To make them mutable, `mut` keyword is used.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ 在 Rust 中，变量默认是**不可变的**，因此我们称它们为**变量绑定**。要使它们可变，使用`mut` 关键字。
- en: ⭐️ Rust is a **statically typed** language; It checks data type at compile time.
    But it **doesn’t require you to actually type it when declare variable bindings**.
    On that case compiler checks the usage and set a better data type for it. But
    for **constants and statics you must annotate the type**. Types come after a colon(:)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ Rust 是一种**静态类型**语言；它在编译时检查数据类型。但是**声明变量绑定时不需要实际输入类型**。在这种情况下，编译器会检查用法并为其设置更好的数据类型。但是**常量和静态变量必须注明类型**。类型在冒号(:)之后声明。
- en: Variable bindings
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量绑定
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Constants
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Statics
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态变量
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**let** keyword is used in binding expressions. We can bind a name to a value
    or a function. Also because of left-hand side of a let expression is a ‘pattern’,
    you can bind multiple names to set of values or function values.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**let** 关键字用于绑定表达式。我们可以将名称绑定到值或函数。此外，由于 let 表达式的左侧是一个‘模式’，您可以将多个名称绑定到一组值或函数值。'
- en: '**const** keyword is used to define constants. It lives for the entire lifetime
    of a program but have no fixed address in memory. **static** keyword is used to
    define ‘global variable’ type facility. There is only one instance for each value,
    and it’s at a **fixed location in memory**.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**const** 关键字用于定义常量。它在整个程序的生命周期内存在，但在内存中没有固定的地址。**static** 关键字用于定义‘全局变量’类型的设施。每个值只有一个实例，并且位于内存中的**固定位置**。'
- en: 💡 **Always use const**, instead of static. It’s pretty rare that you actually
    want a memory location associated with your constant, and using a const allows
    for optimizations like constant propagation not only in your crate but also in
    downstream crates.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 💡 **始终使用 const**，而不是 static。你实际上很少需要将内存位置与常量关联起来，使用 const 允许进行优化，例如常量传播不仅在你的
    crate 中，在下游 crate 中也能进行。
- en: 💡 Usually statics are placed at top of the code file, outside the functions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 💡 通常静态变量放置在代码文件的顶部，函数之外。
- en: Functions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Functions
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Functions are declared with the keyword `fn`
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数使用关键字 `fn` 声明
- en: When using **arguments**, you **must declare data types**.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用**参数**时，您**必须声明数据类型**。
- en: By default functions **return empty tuple ()**. If you want to return a value,
    **return type must be specified** after **->**
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，函数**返回空元组 ()**。如果要返回一个值，必须在**->**之后指定**返回类型**。
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Primitive Data Types
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始数据类型
- en: Primitive Data Types
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始数据类型
- en: '**bool** : true or false'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bool**：true 或 false'
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**char** : a single Unicode scalar value'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**char**：一个单一的 Unicode 标量值'
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**i8 i16 i32 i64** : fixed size(bit) signed(+/-) integer types'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**i8 i16 i32 i64**：固定大小(bit)有符号(+/-)整数类型'
- en: '| DATA TYPE | MIN | MAX |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 最小值 | 最大值 |'
- en: '| --- | --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| i8 | -128 | 127 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| i8 | -128 | 127 |'
- en: '| i16 | -32768 | 32767 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| i16 | -32768 | 32767 |'
- en: '| i32 | -2147483648 | 2147483647 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| i32 | -2147483648 | 2147483647 |'
- en: '| i64 | -9223372036854775808 | 9223372036854775807 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| i64 | -9223372036854775808 | 9223372036854775807 |'
- en: 💡 Min and max values are based on IEEE standard for Binary Floating-Point Arithmetic;
    From **-2ⁿ⁻¹ to 2ⁿ⁻¹-1** . You can use **min_value()** and **max_value()** to
    find min and max of each integer type, ex. i8::min_value();
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 💡 最小值和最大值基于 IEEE 标准的二进制浮点算术；从**-2ⁿ⁻¹到2ⁿ⁻¹-1**。您可以使用 **min_value()** 和 **max_value()**
    来找到每种整数类型的最小值和最大值，例如 i8::min_value();
- en: '**u8 u16 u32 u64** : fixed size(bit) unsigned(+) integer types'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**u8 u16 u32 u64**：固定大小(bit)无符号(+)整数类型'
- en: '| DATA TYPE | MIN | MAX |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 最小值 | 最大值 |'
- en: '| --- | --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| u8 | 0 | 255 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| u8 | 0 | 255 |'
- en: '| u16 | 0 | 65535 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| u16 | 0 | 65535 |'
- en: '| u32 | 0 | 4294967295 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| u32 | 0 | 4294967295 |'
- en: '| u64 | 0 | 18446744073709551615 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| u64 | 0 | 18446744073709551615 |'
- en: 💡 Same as signed numbers, min and max values are based on IEEE standard for
    Binary Floating-Point Arithmetic; From **0 to 2ⁿ-1** . Same way you can use **min_value()**
    and **max_value()** to find min and max of each integer type, ex. u8::max_value();
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 💡 与有符号数一样，最小值和最大值基于IEEE二进制浮点算术标准；从**0到2ⁿ-1**。同样，您可以使用**min_value()**和**max_value()**来找到每种整数类型的最小值和最大值，例如u8::max_value();
- en: '**isize** : variable sized signed(+/-) integer'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**isize**：可变大小的有符号（+/-）整数'
- en: Simply this is the data type to cover all signed integer types but memory allocates
    according to the size of a pointer. Min and max values are similar to i64 .
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，这是一种数据类型，用于涵盖所有有符号整数类型，但内存分配根据指针的大小。最小和最大值类似于i64。
- en: '**usize** : variable sized unsigned(+) integer'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**usize**：可变大小的无符号（+）整数'
- en: Simply this is the data type to cover all unsigned integer types but memory
    allocates according to the size of a pointer. Min and max values are similar to
    u64.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，这是一种数据类型，用于涵盖所有无符号整数类型，但内存分配根据指针的大小。最小和最大值类似于u64。
- en: '**f32** : 32-bit floating point'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**f32**：32位浮点数'
- en: Similar to float in other languages, **Single precision**.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于其他语言中的浮点数，**单精度**。
- en: 💡 Should avoid using this unless you need to reduce memory consumption badly
    or if you are doing low-level optimization, when targeted hardware not supports
    for double-precision or when single-precision is faster than double-precision
    on it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 💡 除非您迫切需要减少内存消耗，或者正在进行低级优化，当目标硬件不支持双精度，或者当单精度比双精度更快时，应避免使用这种类型。
- en: '**f64** : 64-bit floating point'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**f64**：64位浮点数'
- en: Similar to double in other languages, **Double precision**.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于其他语言中的双精度，**双精度**。
- en: '**arrays** : fixed-size list of elements of same data type'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组**：相同数据类型的固定大小元素列表'
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ⭐️ Arrays are **immutable** by default and also **even with mut, its element
    count can not be changed**.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ 数组默认为**不可变**，即使使用mut，其元素数量也不能更改。
- en: 🔎 If you are looking for a dynamic/growable array, you can use **Vec**. Vectors
    can contain any type of elements but all elements must be in the same data type.
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 🔎 如果您正在寻找一个动态/可增长的数组，可以使用**Vec**。向量可以包含任何类型的元���，但所有元素必须是相同的数据类型。
- en: '**tuples** : fixed-size ordered list of elements of different(or same) data
    types'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元组**：固定大小的有序元素列表，元素可以是不同（或相同）数据类型'
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ⭐️ Tuples are also **immutable** by default and **even with mut, its element
    count can not be changed. Also if you want to change an element’s value, new value
    should have the same data type of previous value**.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ 元组默认也是**不可变**的，即使使用mut，其元素数量也不能更改。此外，如果要更改元素的值，新值应与先前的数据类型相同。
- en: '**slice** : dynamically-sized reference to another data structure'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切片**：对另一个数据结构的动态大小引用'
- en: Think you want to get/pass a part of an array or any other data structure. Instead
    of copy it to another array (or same data structure), Rust allows to create a
    view/reference to access only that part of data. And it can be mutable or not.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想要获取/传递数组或任何其他数据结构的一部分。而不是将其复制到另一个数组（或相同数据结构）中，Rust允许创建一个视图/引用，仅访问数据的那部分。它可以是可变的或不可变的。
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**str** : unsized UTF-8 sequence of Unicode string slices'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**str**：未定大小的UTF-8 Unicode字符串切片'
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ⭐️ It's an **immutable/statically allocated slice** holding an **unknown sized
    sequence of UTF-8** code points stored in somewhere in memory. **&str** is used
    to borrow and assign the whole array to the given variable binding.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ 这是一个**不可变/静态分配的切片**，其中存储在内存中的某个位置的**未知大小的UTF-8**代码点序列。**&str**用于借用并将整个数组分配给给定的变量绑定。
- en: '🔎 A [String](https://doc.rust-lang.org/std/string/struct.String.html) is a
    **heap**-allocated string. This string is growable, and is also guaranteed to
    be UTF-8\. They are commonly created by converting from a string slice using the
    **to_string()** or **String::from()** methods. ex: `“Hello”.to_string();` `String::from("Hello");`'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 🔎 [字符串](https://doc.rust-lang.org/std/string/struct.String.html)是一个**堆**分配的字符串。该字符串是可增长的，并且保证为UTF-8。它们通常通过使用**to_string()**或**String::from()**方法从字符串切片转换而来。例如：`“Hello”.to_string();`
    `String::from("Hello");`
- en: 💡 In general, you should use **String** when you need **ownership**, and **&str**
    when you just need to **borrow a string**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 💡 一般情况下，当您需要**所有权**时应使用**String**，当您只需要**借用字符串**时应使用**&str**。
- en: '**functions**'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**'
- en: As we discussed on functions section, b is a function pointer, to plus_one function
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在函数部分讨论的那样，b是一个函数指针，指向plus_one函数
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Operators
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: Operators
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: '**Arithmetic Operators** : + - * / %'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算术运算符**：+ - * / %'
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 🔎 Also **+** is used for **array and string concatenation**
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 🔎 还有**+**用于**数组和字符串的连接**
- en: '**Comparison Operators** : == != < > <= >='
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较运算符**：== != < > <= >='
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Logical Operators** : ! && ||'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑运算符**：! && ||'
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 🔎 On integer types, ! inverts the individual bits in the two’s complement representation
    of the value.
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 🔎 在整数类型上，!会反转值的二进制补码表示中的各个位。
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Bitwise Operators** : & | ^ << >>'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位运算符**：& | ^ << >>'
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Assignment and Compound Assignment Operators**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**赋值和复合赋值运算符**'
- en: The = operator is used to assign a name to a value or a function. Compound Assignment
    Operators are created by composing one of + - * / % & | ^ << >> operators with
    = operator.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: =运算符用于将值或函数的名称分配给一个名称。复合赋值运算符是通过将+ - * / % & | ^ << >>运算符之一与=运算符组合而成的。
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Type Casting Operator** : as'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型转换运算符**：as'
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Borrowing and Dereference Operators** : & &mut *'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**借用和解引用运算符**：& &mut *'
- en: The **& or &mut** operators are used for **borrowing** and ***** operator for
    **Dereferencing**.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**&或&mut**运算符用于**借用**，*****运算符用于**解引用**。'
- en: 🔎 Usage of these operators is an advanced topic, for more information use [Rust
    Reference Documentation](https://doc.rust-lang.org/reference.html#unary-operator-expressions).
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 🔎 这些运算符的使用是一个高级话题，更多信息请参考[Rust参考文档](https://doc.rust-lang.org/reference.html#unary-operator-expressions)。
- en: Control Flows
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流
- en: Control Flows
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流
- en: '**if - else if - else**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**if - else if - else**'
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ⭐️ **Return data type should be same on each block, when using this as an expression.**
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ **当将其用作表达式时，每个块的返回数据类型应该相同。**
- en: '**match**'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匹配**'
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**while**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**while**'
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**loop**'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环**'
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**for**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**for**'
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Vectors
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量
- en: Vectors
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量
- en: If you remember, array is a fixed-size list of elements, of same data type.
    Even with mut, it’s element count can not be changed. Vector is kind of a re-sizable
    array but all elements must be in the same type.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记得，数组是相同数据类型的固定大小元素列表。即使使用mut，其元素计数也不能更改。向量是一种可调整大小的数组，但所有元素必须是相同类型的。
- en: ⭐️ It’s a generic type, written as Vec <t class="hljs-meta">. T can have any
    type, ex. The type of a Vec of i32s is Vec<i32 class="hljs-meta">. Also Vectors
    always allocate their data in dynamically allocated heap.</i32></t>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ 这是一个通用类型，写作Vec <t class="hljs-meta">。T可以是任何类型，例如。i32s的Vec的类型是Vec<i32 class="hljs-meta">。此外，向量总是在动态分配的堆中分配它们的数据。</i32></t>
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ⭐️ Mainly a vector represent 3 things; a pointer to the data, No of elements
    currently have(length), capacity (Amount of space allocated for any future elements).
    If the length of a vector exceeds its capacity, its capacity will be increased
    automatically. But its elements will be reallocated(which can be slow). So always
    use Vec::with_capacity whenever it’s possible.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ 主要一个向量代表3个东西；指向数据的指针，当前拥有的元素数量（长度），容量（为任何未来元素分配的空间量）。如果向量的长度超过其容量，其容量将自动增加。但其元素将被重新分配（可能会很慢）。因此，尽可能在可能的情况下始终使用Vec::with_capacity。
- en: 🔎 String data type is a UTF-8 encoded vector. But you can not index into a String
    because of encoding.
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 🔎 字符串数据类型是UTF-8编码的向量。但由于编码的原因，您无法对字符串进行索引。
- en: Vectors can be used with iterators in three ways,
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 向量可以以三种方式与迭代器一起使用，
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Structs
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: Structs
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: ⭐️ Structs are used to encapsulate related properties into one unified datatype.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ 结构体用于将相关属性封装成一个统一的数据类型。
- en: 💡 By convention, the name of the struct starts with a capital letter and follows
    CamelCase.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 💡 按照惯例，结构体的名称以大写字母开头，并遵循驼峰命名法。
- en: There are 3 variants of structs,
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有3种结构体的变体，
- en: C-like structs
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似C的结构体
- en: one or more comma separated name:value pairs
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个或多个逗号分隔的名称:值对
- en: brace-enclosed list
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大括号包围的列表
- en: similar to classes (without it’s methods) in other languages like Java
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其他语言（如Java）中的类（没有方法）类似
- en: because fields have names, we can access them through dot notation
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为字段有名称，所以我们可以通过���符号访问它们
- en: Tuple structs
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 元组结构体
- en: one or more comma separated values
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个或多个逗号分隔的值
- en: parenthesized list like tuples
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像元组一样用括号括起来的列表
- en: looks like a named tuples
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看起来像命名元组
- en: Unit structs
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元结构体
- en: a struct with no members at all
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个没有任何成员的结构体
- en: it defines a new type but it resembles an empty tuple, ()
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它定义了一个新类型，但它类似于一个空元组，()
- en: rarely in use, useful with generics
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很少使用，与泛型一起很有用
- en: ⭐️ When regarding OOP in Rust, attributes and methods are placed separately
    on structs and traits. Structs contain only attributes, traits contain only methods.
    They are getting connected via impls
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ 在Rust中涉及面向对象编程时，属性和方法分别放置在结构体和特征上。结构体仅包含属性，特征仅包含方法。它们通过impls连接在一起
- en: 01\. C-like structs
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 01\. 类C结构体
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 02\. Tuple structs
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 02\. 元组结构体
- en: ⭐️ When a tuple struct has only one element, we called it ‘newtype’ pattern.
    Because it helps to create a new type.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ 当元组结构只有一个元素时，我们称之为 'newtype' 模式。因为它有助于创建一个新类型。
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 03\. Unit structs
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 03\. 单元结构体
- en: This is rarely useful on its own, but in combination with other features, it
    can become useful.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身很少有用，但与其他功能结合使用时，它可以变得有用。
- en: '📖 ex: A library may ask you to create a structure that implements a certain
    trait to handle events. If you don’t have any data you need to store in the structure,
    you can create a unit-like struct.'
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 📖 例如：一个库可能会要求您创建一个实现某个特定特征以处理事件的结构。如果您不需要在结构中存储任何数据，可以创建一个类似于单元的结构。
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Enums
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: Enums
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: ⭐️ An enum is a single type. It contains variants, which are possible values
    of the enum at a given time. For example,
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ 枚举是一个单一类型。它包含变体，这些是枚举在给定时间的可能值。例如，
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '⭐️ Variants can be accessed through :: notation , ex. Day::Sunday'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '⭐️ 可以通过 :: 符号访问变体，例如 Day::Sunday'
- en: ⭐️ Each enum variant can have,
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ 每个枚举变体都可以有，
- en: no data (unit variant)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无数据（单元变体）
- en: unnamed ordered data (tuple variant)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未命名的有序数据（元组变体）
- en: named data (struct variant)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名数据（struct 变体）
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Generics
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: Generics
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: 📖 Sometimes, when writing a function or data type, we may want it to work for
    multiple types of arguments. In Rust, we can do this with generics.
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 📖 有时，在编写函数或数据类型时，我们可能希望它适用于多种类型的参数。在 Rust 中，我们可以使用泛型来实现这一点。
- en: '💭 The concept is, instead of declaring a specific data type we use an uppercase
    letter(or CamelCase identifier). ex, instead x : u8 we use x : T . but we have
    to inform to the compiler that T is a generic type(can be any type) by adding
    <t class="hljs-meta">at first.</t>'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '💭 这个概念是，我们不是声明一个特定的数据类型，而是使用一个大写字母（或 CamelCase 标识符）。例如，代替 x : u8，我们使用 x : T。但我们必须向编译器声明
    T 是一个泛型类型（可以是任何类型），通过在最前面添加 <t class="hljs-meta">。</t>'
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ⭐️ Above Option and Result types are kind of special generic types which are
    already defined in Rust’s standard library.
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⭐️ 上述 Option 和 Result 类型是 Rust 标准库中已经定义的一些特殊泛型类型。
- en: ''
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An optional value can have either Some value or no value/ None.
  id: totrans-259
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选值可以是 Some 值，也可以是没有值 / None。
- en: A result can represent either success/ Ok or failure/ Err
  id: totrans-260
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果可以表示成功 / Ok 或失败 / Err
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 📖 The Option type is a way to use Rust’s type system to express the possibility
    of absence. Result expresses the possibility of error.
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 📖 Option 类型是使用 Rust 的类型系统来表达缺失可能性的一种方式。Result 表达了错误的可能性。
- en: '[PRE41]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 🔎 Many useful methods have been implemented around Option and Result types.
    More information can be found on std::option::Option and std::result::Result pages
    on Rust doc.
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 🔎 在 Option 和 Result 类型周围已经实现了许多有用的方法。关于它们的更多信息可以在 Rust 文档中的 std::option::Option
    和 std::result::Result 页面找到。
- en: ⭐️ Also more practical examples of options & results can be found on Error Handling
    section in Rust doc.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ 在 Rust 文档的错误处理部分也可以找到更多关于选项（Options）和结果（Results）的实用示例。
- en: Impls & Traits
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 & 特征
- en: Impls & Traits
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 & 特征
- en: 💡 When we discussed about C-like structs, I mentioned that those are similar
    to classes in other languages like Java, but without their methods. impls are
    used to define methods for Rust structs and enums.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 💡 当我们讨论类似于 C 的结构体时，我提到过它们与其他语言（如 Java）中的类相似，但没有它们的方法。impls 用于为 Rust 结构体和枚举定义方法。
- en: 💡 Traits are kind of similar to interfaces in other languages like Java. They
    are used to define the functionality a type must provide. Multiple traits can
    be implemented to a single type.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 💡 特征与其他语言（如 Java）中的接口有些相似。它们用于定义类型必须提供的功能。一个类型可以实现多个特征。
- en: ⭐️⭐️⭐️ But traits can also include default implementations of methods. Default
    methods can be override when implementing types.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️⭐️⭐️ 但特征也可以包含方法的默认实现。当实现类型时，可以覆盖默认方法。
- en: '[PRE42]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ⭐️ As you can see methods take a special first parameter, the type itself. It
    can be either self, &self, or &mut self . self if it’s a value on the stack(taking
    ownership), &self if it’s a reference, and &mut self if it’s a mutable reference.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ 正如您所见，方法接受一个特殊的第一个参数，即类型本身。它可以是 self、&self 或 &mut self。如果它是堆栈上的值（拥有权），则为
    self，如果它是引用，则为 &self，如果它是可变引用，则为 &mut self。
- en: '⭐️ Some other languages support static methods. At such times, we call a function
    directly through the class without creating an object. In Rust, we call them Associated
    Functions. we use :: instead of . when calling them from struct. ex. Person::new(“Elon
    Musk Jr”);'
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '⭐️ 一些其他语言支持静态方法。这时，我们可以直接通过类调用一个函数而不创建对象。在 Rust 中，我们称之为关联函数。当从结构体调用它们时，我们使用
    :: 而不是 .。例如，Person::new（“埃隆·马斯克·小”）;'
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ⭐️ Traits may inherit from other traits.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ 特征可以继承自其他特征。
- en: '[PRE44]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 🔎 While Rust favors static dispatch, it also supports dynamic dispatch through
    a mechanism called ‘trait objects.’
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 🔎 虽然Rust偏向于静态分派，但也支持通过一种称为‘特质对象’的机制进行动态分派。
- en: 🅆 Dynamic dispatch is the process of selecting which implementation of a polymorphic
    operation (method or function) to call at run time.
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 🅆 动态分派是在运行时选择要调用的多态操作（方法或函数）的过程。
- en: '[PRE45]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Ownership
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥有权
- en: Ownership
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥有权
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the above examples, we are just trying to **assign the value of ‘a’ to ‘b’**
    . Almost the same code in both code blocks, but having **two different data types**.
    And the second one gives an error. This is because of the **Ownership**.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们只是尝试**将‘a’的值赋给‘b’**。两个代码块中的代码几乎相同，但有**两种不同的数据类型**。第二个会报错。这是因为**所有权**。
- en: ⭐️ Variable bindings have **ownership** of what they’re bound to. A piece of
    data can only have **one owner at a time**. When a binding goes out of scope,
    Rust will free the bound resources. This is how Rust achieves **memory safety**.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ 变量绑定拥有它们所绑定的**所有权**。一段数据一次只能有**一个所有者**。当一个绑定超出范围时，Rust会释放绑定的资源。这就是Rust实现**内存安全**的方式。
- en: '[Ownership (noun)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)'
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[所有权（名词）](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)'
- en: The act, state, or right of possessing something.
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 拥有某物的行为、状态或权利。
- en: ⭐️ **When assigning** a variable binding to another variable binding **or when
    passing it to a function**(Without referencing), if its data type is a
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ **当将**一个变量绑定**赋给另一个变量绑定**时（不引用），如果其数据类型是一个
- en: '**Copy Type**'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**复制类型**'
- en: Bound resources are **made a copy and assign** or pass it to the function.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定的资源被**复制并分配**或传递给函数。
- en: The ownership state of the original bindings are set to **“copied” state**.
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始绑定的所有权状态被设置为**“复制”状态**。
- en: '**Mostly Primitive types**'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大多数原始类型**'
- en: '**Move type**'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**移动类型**'
- en: Bound resources are **moved** to the new variable binding and we **can not access
    the original variable binding** anymore.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定的资源被**移动**到新的变量绑定，我们**无法再访问原始的变量绑定**。
- en: The ownership state of the original bindings are set to **“moved” state**.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始绑定的所有权状态被设置为**“移动”状态**。
- en: '**Non-primitive types**'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非原始类型**'
- en: 🔎 The functionality of a type is handled by the traits which have been implemented
    to it. By default, variable bindings have ‘move semantics.’ However, if a type
    implements [**core::marker::Copy trait**](https://doc.rust-lang.org/core/marker/trait.Copy.html)
    , it has a 'copy semantics'.
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 🔎 一个类型的功能由已实现的特质处理。默认情况下，变量绑定具有‘移动语义’。但是，如果一个类型实现了[**core::marker::Copy trait**](https://doc.rust-lang.org/core/marker/trait.Copy.html)，它具有'复制语义'。
- en: 💡 **So in the above second example, ownership of the Vec object moves to “b”
    and “a” doesn’t have any ownership to access the resource.**
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 💡 **所以在上面的第二个例子中，Vec对象的所有权移动到“b”，“a”没有所有权访问资源。**
- en: Borrowing
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 借用
- en: Borrowing
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 借用
- en: In real life applications, most of the times we have to pass variable bindings
    to other functions or assign them to another variable bindings. In this case we
    **referencing** the original binding; **borrow** the data of it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，大多数情况下我们需要将变量绑定传递给其他函数或将它们分配给另一个变量绑定。在这种情况下，我们**引用**原始绑定；**借用**它的数据。
- en: '[Borrow (verb)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)'
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[借用（动词）](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)'
- en: To receive something with the promise of returning it.
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 带有承诺返回的接收。
- en: ⭐️ There are two types of Borrowing,
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ 有两种借用类型，
- en: '**Shared Borrowing** `(&T)`'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**共享借用** `(&T)`'
- en: A piece of data can be **borrowed by a single or multiple users**, but **data
    should not be altered**.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一段数据可以被**单个或多个用户借用**，但**数据不应该被更改**。
- en: '**Mutable Borrowing** `(&mut T)`'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**可变借用** `(&mut T)`'
- en: A piece of data can be **borrowed and altered by a single user**, but the data
    should not be accessible for any other users at that time.
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一段数据可以被**单个用户借用并更改**，但此时其他用户不应该能够访问该数据。
- en: ⭐️ And there are **very important rules** regarding borrowing,
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ 还有关于借用的**非常重要的规则**，
- en: One piece of data can be borrowed **either** as a shared borrow **or** as a
    mutable borrow **at a given time. But not both at the same time**.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一段数据可以被借用为**共享借用** **或** 作为可变借用 **之一**。但不能同时发生。
- en: Borrowing **applies for both copy types and move types**.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 借用**适用于复制类型和移动类型**。
- en: The concept of **Liveness** ↴
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**活性**的概念 ↴'
- en: '[PRE47]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 💡 **Let’s see how to use shared and mutable borrowings in examples.**
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 💡 **让我们看看如何在示例中使用共享和可变借用。**
- en: Examples for Shared Borrowing
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享借用示例
- en: '[PRE48]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Examples for Mutable Borrowing
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变借用示例
- en: '[PRE49]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Lifetimes
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期
- en: Lifetimes
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期
- en: When we are dealing with references, we have to make sure that the referencing
    data stay alive until we are stop using the references.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理引用时，我们必须确保引用的数据在我们停止使用引用之前保持存活。
- en: Think,
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想，
- en: We have a variable binding, “**a**”.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个变量绑定，“**a**”。
- en: We are referencing the value of “a”, from another variable binding “**x**”.
    We have to make sure that “a” **lives** until we stop using “x”
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在引用“a”的值，来自另一个变量绑定“**x**”。我们必须确保“a”在我们停止使用“x”之前**存活**。
- en: 🔎 **Memory management** is a form of resource management applied to computer
    memory. Up until the mid-1990s, the majority of programming languages used **Manual
    Memory Management** which **requires the programmer to give manual instructions**
    to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy
    invented **Garbage collection**(GC), a form of **Automatic Memory Management**(AMM).
    It determines what memory is no longer used and frees it automatically instead
    of relying on the programmer. However **Objective-C and Swift** provide similar
    functionality through **Automatic Reference Counting**(ARC).
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 🔎 **内存管理**是应用于计算机内存的资源管理形式。直到1990年代中期，大多数编程语言使用**手动内存管理**，需要程序员给出手动指令来识别和释放未使用的对象/垃圾。约1959年，约翰·麦卡锡发明了**垃圾收集**(GC)，一种**自动内存管理**(AMM)形式。它确定哪些内存不再使用并自动释放，而不依赖于程序员。然而，**Objective-C和Swift**通过**自动引用计数**(ARC)提供类似功能。
- en: In Rust,
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，
- en: A resource can only have **one owner** at a time. When it goes **out of the
    scope**, Rust removes it from the Memory.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个资源一次只能有**一个所有者**。当它超出范围时，Rust会将其从内存中移除。
- en: When we want to reuse the same resource, we are **referencing** it/ **borrowing**
    its content.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要重复使用相同的资源时，我们正在**引用**它/ **借用**其内容。
- en: When dealing with **references**, we have to specify **lifetime annotations**
    to provide instructions for the **compiler** to set **how long** those referenced
    resources **should be alive**.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理**引用**时，我们必须指定**生命周期注解**，以便为**编译器**提供指示，设置这些引用资源**应该存活多久**。
- en: ⭐️But because of lifetime annotations make **code more verbose**, in order to
    make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted**
    in `fn` definitions. In this case, the compiler assigns lifetime annotations **implicitly**.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ⭐️但是由于生命周期注解使**代码更冗长**，为了使**常见模式**更符合人体工程学，Rust允许在`fn`定义中**省略**生命周期。在这种情况下，编译器会**隐式**分配生命周期注解。
- en: Lifetime annotations are **checked at compile-time**. Compiler checks when a
    data is used for the first and the last times. According to that, Rust manages
    memory in **run time**. This is the major reason of having **slower compilation
    times** in Rust.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期注解在**编译时检查**。编译器在数据第一次和最后一次使用时进行检查。根据这一点，Rust在**运行时**管理内存。这是Rust编译时间**较慢**的主要原因。
- en: Unlike C and C++, **usually** Rust doesn’t explicitly drop values at all.
  id: totrans-331
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与C和C++**不同**，Rust通常不会显式丢弃值。
- en: Unlike GC, Rust doesn’t place deallocation calls where the data is no longer
    referenced.
  id: totrans-332
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与GC不同，Rust不会在数据不再被引用的地方放置释放调用。
- en: Rust places deallocation calls where the data is about to go out of the scope
    and then enforces that no references to that resource exist after that point.
  id: totrans-333
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust在数据即将超出范围的地方放置释放调用，然后强制确保在那一点之后不存在对该资源的引用。
- en: 💡 Lifetimes are denoted with an apostrophe. By convention, a lowercase letter
    is used for naming. Usually **starts with** `'a` and **follows alphabetic order**
    when we need to add **multiple lifetime** annotations.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 💡 生命周期用撇号表示。按照惯例，小写字母用于命名。通常以**'a**开头，并在需要添加**多个生命周期**注解时按字母顺序**跟随**。
- en: When using references,
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用引用时，
- en: 𝟎𝟏. On **Function Declaration**
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 𝟎𝟏. 在**函数声明**中
- en: 'Input and output parameters with references should attach lifetimes after `&`
    sign. ex `..(x: &''a str)` , `..(x: &''a mut str)`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '带有引用的输入和输出参数应在`&`符号后附加生命周期。例如 `..(x: &''a str)`，`..(x: &''a mut str)`'
- en: After the function name, we should mention that the given lifetimes are generic
    types. ex `fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数名之后，我们应该提到给定的生命周期是泛型类型。例如 `fn foo<'a>(..)`，`fn foo<'a, 'b>(..)`
- en: '[PRE50]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 𝟎𝟐. On **Struct or Enum Declaration**
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 𝟎𝟐. 在**结构体或枚举声明**中
- en: Elements with references should attach lifetimes after `&` sign.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有引用的元素应在`&`符号后附加生命周期。
- en: After the name of the struct or enum, we should mention that the given lifetimes
    are generic types.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在结构体或枚举的名称之后，我们应该提到给定的生命周期是泛型类型。
- en: '[PRE51]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 𝟎𝟑. With **Impls and Traits**
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 𝟎𝟑. 使用**Impls和Traits**
- en: '[PRE52]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 𝟎𝟒. With **Generic Types**
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 𝟎𝟒. 使用**泛型类型**
- en: '[PRE53]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Lifetime Elision
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生命周期省略
- en: As I mentioned earlier, in order to make **common patterns** more ergonomic,
    Rust allows lifetimes to be **elided/omitted**. This process is called **Lifetime
    Elision**.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，为了使**常见模式**更符合人体工程学，Rust 允许省略生命周期。这个过程称为**生命周期省略**。
- en: 💡 For the moment Rust supports Lifetime Elisions only on `fn` definitions. But
    in the future it will support for `impl` headers as well.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 💡 目前 Rust 仅在`fn`定义中支持生命周期省略。但在未来，它也将支持`impl`头部的生命周期省略。
- en: ⭐️ lifetime annotations of `fn` definitions can be elided
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ fn 定义的生命周期注释可以被省略
- en: if its **parameter list** has either,
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其**参数列表**中有要么，
- en: '**only one input parameter passes by reference**.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只有一个输入参数通过引用传递**。'
- en: a parameter with **either** `&self` **or** **&mut self** reference.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有**要么** `&self` **要么** **&mut self** 引用的参数。
- en: '[PRE54]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 💡 In the Lifetime Elision process of fn definitions,
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 💡 在 fn 定义的生命周期省略过程中，
- en: ''
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Each parameter passes by reference is got a distinct lifetime annotation. ex.
    `..(x: &str, y: &str)` 🡒 `..<''a, ''b>(x: &''a str, y: &''b str)`'
  id: totrans-358
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '每个通过引用传递的参数都有一个不同的生命周期注释。例如 `..(x: &str, y: &str)` 🡒 `..<''a, ''b>(x: &''a
    str, y: &''b str)`'
- en: 'If the parameter list has only one parameter passes by reference, that lifetime
    is assigned to all elided lifetimes in the return values of that function. ex.
    `..(x: i32, y: &str) -> &str` 🡒 `..<''a>(x: i32, y: &''a str) -> &''a str`'
  id: totrans-359
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '如果参数列表只有一个通过引用传递的参数，则该生命周期将分配给该函数返回值中所有省略的生命周期。例如 `..(x: i32, y: &str) -> &str`
    🡒 `..<''a>(x: i32, y: &''a str) -> &''a str`'
- en: 'Even it has multiple parameters pass by reference, if one of them has &self
    or &mut self, the lifetime of self is assigned to all elided output lifetimes.
    ex. `impl Impl{ fn function(&self, x: &str) -> &str {} }` 🡒 `impl<''a> Impl<''a>{
    fn function(&''a self, x: &''b str) -> &''a str {} }`'
  id: totrans-360
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '即使它有多个通过引用传递的参数，如果其中一个有 &self 或 &mut self，self 的生命周期将分配给所有省略的输出生命周期。例如 `impl
    Impl{ fn function(&self, x: &str) -> &str {} }` 🡒 `impl<''a> Impl<''a>{ fn function(&''a
    self, x: &''b str) -> &''a str {} }`'
- en: For all other cases, we have to write lifetime annotations manually.
  id: totrans-361
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有其他情况，我们必须手动编写生命周期注释。
- en: '''static'
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '''static'
- en: ⭐️ `'static` lifetime annotation is a **reserved** lifetime annotation. These
    references are valid for the entire program. They are saved in the data segment
    of the binary and the data referred to will never go out of scope.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ⭐️ `'static` 生命周期注释是一个**保留**的生命周期注释。这些引用在整个程序中都有效。它们保存在二进制文件的数据段中，所引用的数据永远不会超出作用域。
- en: 💡 **Let’s see how to use lifetime annotations in examples.**
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 💡 **让我们看看如何在示例中使用生命周期注释。**
- en: '[PRE55]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
