- en: About Me
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: About Me
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hi, I'm [Dumindu Madunuwan](https://lk.linkedin.com/in/dumindunuwan). I'm a
    web developer, mainly PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Around 2007‚Äì2009, I chose web development because at that time I truly believed,
    web will be the next ultimate, system independent & language independent platform
    and the next generation software ecosystem will be implemented top of browsers.
    The web I expected is sort of similar to this.
  prefs: []
  type: TYPE_NORMAL
- en: '[![The Future of The Web : Mozilla Labs Aurora Concept Browser](mozilla_labs_aurora_concept_browser.png)](http://www.youtube.com/watch?v=FZ-zvx1QCcA
    "The Future of The Web : Mozilla Labs Aurora Concept Browser")'
  prefs: []
  type: TYPE_NORMAL
- en: Like some of web developers, I truly bet on HTML5 over native apps on past years.
    I learned about HTML5, CSS3, RWD, Mobile First Design, UI/UX and etc. Now a days
    we have hundreds of front-end frameworks but still web technologies can't win
    over native apps, especially on performance.
  prefs: []
  type: TYPE_NORMAL
- en: It‚Äôs true that web technologies are slowly adapting for native app development
    via asmjs, NativeScript, Electron, WebAssembly, React Native but future web application
    development will be more complex because of Emerging Connected Cars and VR Ecosystems.
  prefs: []
  type: TYPE_NORMAL
- en: Also in the other hand, now we have much powerful alternatives for PHP, like
    node and Go. So as a PHP developer its time to learn something new, a new language.
    I chose Rust because it's an interesting language to learn and next generation
    browser engine, [Servo](https://servo.org/) is written using Rust.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[![Medium](medium.png)](https://medium.com/@dumindu "Medium") [![Ycombinator](ycombinator.png)](https://news.ycombinator.com/user?id=dumindunuwan
    "Ycombinator") [![Reddit](reddit.png)](https://www.reddit.com/user/dumindunuwan/
    "Reddit") [![Github](github.png)](https://github.com/dumindu/ "Github") [![LinkedIn](linkedin.png)](https://lk.linkedin.com/in/dumindunuwan/
    "LinkedIn") [![Pinterest](pinterest.png)](https://www.pinterest.com/dumindu/ "Pinterest")
    [![Behance](behance.png)](https://www.behance.net/dumindu-madunuwan/ "Behance")'
  prefs: []
  type: TYPE_NORMAL
- en: Why Rust?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why Rust?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust initially designed and developed by Mozilla employee Graydon Hoare as a
    personal project. Mozilla began sponsoring the project in 2009 and announced it
    in 2010\. But the first stable release, Rust 1.0 released on May 15, 2015.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Rethinking Systems Programming](rust_control_over_safety.png)](http://thoughtram.io/rust-and-nickel/#/11)'
  prefs: []
  type: TYPE_NORMAL
- en: The goal of Rust is to be a good language for creating highly concurrent and
    highly safe systems. Also as you can see on above diagram, Rust designed to provide
    speed and safety at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '"Rust is a systems programming language focused on three goals: safety, speed,
    and concurrency."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: __ Rust Documentation
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rust is very young and very modern language. It's a **compiled programming language**
    and it uses [LLVM](https://en.wikipedia.org/wiki/LLVM) on its backend. Also Rust
    is a **multi-paradigm programming language**, it supports imperative procedural,
    concurrent actor, object-oriented and pure functional styles. It also supports
    generic programming and meta programming, in both static and dynamic styles.
  prefs: []
  type: TYPE_NORMAL
- en: Its design elements came from a wide range of sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstract Machine Model : **C**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data types : **C, SML, OCaml, Lisp, Limbo**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional Bindings : **Swift**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hygienic Macros : **Scheme**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Functional Programming : **Haskell, OCaml, F#**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Attributes : **ECMA**-335'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memory Model and Memory Management : **C++, ML Kit, Cyclone**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type Classes : **Haskell**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Crate : Assembly in the **ECMA**-335 CLI model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Channels and Concurrency : **Newsqueak, Alef, Limbo**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Message passing and Thread failure : **Erlang**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and etc.
  prefs: []
  type: TYPE_NORMAL
- en: Rust **doesn't use an automated garbage collection** system(GC) by default.
  prefs: []
  type: TYPE_NORMAL
- en: üîé One of Rust‚Äôs most unique and compelling features is [ownership](https://doc.rust-lang.org/stable/book/ownership.html),
    which uses to achieves memory safety. Rust creates memory pointers optimistically,
    checks memory pointers‚Äô limited accesses at the compiler time with the usage of
    [References and Borrowing](https://doc.rust-lang.org/stable/book/references-and-borrowing.html).
    And it does automatic compile time memory management by checking the [Lifetimes](https://doc.rust-lang.org/stable/book/lifetimes.html).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rust compiler observe the code at compiler time and help to [prevent many types
    of errors](https://doc.rust-lang.org/error-index.html) that are possible to write
    in C++
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to install Rust on your system. For the moment the official
    way to install Rust is using [Rustup](https://rustup.rs/).
  prefs: []
  type: TYPE_NORMAL
- en: '[üïÆ](https://github.com/rust-lang-nursery/rustup.rs) Rustup installs The Rust
    Programming Language from the official release channels, enabling you to easily
    switch between stable, beta, and nightly compilers and keep them updated. It makes
    cross-compiling simpler with binary builds of the standard library for common
    platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: '[üïÆ](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup installs
    `rustc`, `cargo`, `rustup` and other standard tools to Cargo''s `bin` directory.
    On Unix it is located at `$HOME/.cargo/bin` and on Windows at `%USERPROFILE%\.cargo\bin`.
    This is the same directory that `cargo install` will install Rust programs and
    Cargo plugins.'
  prefs: []
  type: TYPE_NORMAL
- en: '**üí°** More information can be found on the [Github page of Rustup project](https://github.com/rust-lang-nursery/rustup.rs).'
  prefs: []
  type: TYPE_NORMAL
- en: After installing Rust you can check the current version by typing `rustc --version`
    or`rustc -V` on your terminal to verify the success of the installation.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hello World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`fn` means function. main function is the beginning of every Rust program.'
  prefs: []
  type: TYPE_NORMAL
- en: '`println!` prints text to the console and its *!* indicate that it‚Äôs a [macro](https://doc.rust-lang.org/book/macros.html)
    instead of a function.'
  prefs: []
  type: TYPE_NORMAL
- en: üí° Rust files should have .rs file extension and if you‚Äôre using more than one
    word for the file name, follow the [snake_case](https://en.wikipedia.org/wiki/Snake_case).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: compiling via `rustc file.rs`
  prefs: []
  type: TYPE_NORMAL
- en: executing by `./file` on Linux and Mac or `file.exe` on Windows
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: üíØ These are the other usages of println! macro,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Cargo, Crates and Basic Project Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cargo, Crates and Basic Project Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cargo is Rust‚Äôs build-in Package Manager. But mainly it uses for,
  prefs: []
  type: TYPE_NORMAL
- en: '‚ñ∏ Create new project : `cargo new`'
  prefs: []
  type: TYPE_NORMAL
- en: '‚ñ∏ Update dependencies : `cargo update`'
  prefs: []
  type: TYPE_NORMAL
- en: '‚ñ∏ Build project : `cargo build`'
  prefs: []
  type: TYPE_NORMAL
- en: '‚ñ∏ Build and run a project : `cargo run`'
  prefs: []
  type: TYPE_NORMAL
- en: '‚ñ∏ Run tests : `cargo test`'
  prefs: []
  type: TYPE_NORMAL
- en: '‚ñ∏ Generate documentation via rustdoc : `cargo doc`'
  prefs: []
  type: TYPE_NORMAL
- en: Other than that there are some cargo commands, especially for publishing crates
    directly via cargo.
  prefs: []
  type: TYPE_NORMAL
- en: '‚ñ∏ `cargo login` : acquiring an API token'
  prefs: []
  type: TYPE_NORMAL
- en: '‚ñ∏ `cargo package` : make the local create uploadable to crates.io'
  prefs: []
  type: TYPE_NORMAL
- en: '‚ñ∏ `cargo publish` : make the local create uploadable to crates.io and upload
    the crate'
  prefs: []
  type: TYPE_NORMAL
- en: ‚≠êÔ∏è **A crate is a package. Crates can be shared via** [**Cargo**](https://crates.io/)**.**
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: A crate can produce an executable or a library. In other words, it can be a
    binary crate or a library crate.
  prefs: []
  type: TYPE_NORMAL
- en: '`cargo new crate_name --bin` : produces an **executable**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cargo new crate_name --lib` OR `cargo new crate_name`: produces a **library**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first one generates,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: and the second one generates,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Cargo.toml**(capital c) is the configuration file which contains all of the
    metadata that Cargo needs to compile your project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**src** folder is the place to store the source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each crate has an implicit crate root/ entry point. **main.rs** is the crate
    root for a binary crate and **lib.rs** is the crate root for a library crate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: üí° When we build a binary crate via `cargo build` or `cargo run`, the executable
    file will be stored in **target/debug/** folder. But when build it via `cargo
    build --release` for a release it will be stored in **target/release/** folder.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This is how [Cargo Docs describes](http://doc.crates.io/guide.html#project-layout)
    about the recommended Project Layout,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: ‚ñ∏ Source code goes in the `src` directory.
  prefs: []
  type: TYPE_NORMAL
- en: ‚ñ∏ The default library file is `src/lib.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: ‚ñ∏ The default executable file is `src/main.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: ‚ñ∏ Other executables can be placed in `src/bin/*.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: ‚ñ∏ Integration tests go in the `tests` directory (unit tests go in each file
    they're testing).
  prefs: []
  type: TYPE_NORMAL
- en: ‚ñ∏ Examples go in the `examples` directory.
  prefs: []
  type: TYPE_NORMAL
- en: ‚ñ∏ Benchmarks go in the `benches` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Comments and Documenting the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comments and Documenting the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Nested block comments are supported.
  prefs: []
  type: TYPE_NORMAL
- en: üí° **Always avoid block comments, Use line comments instead.**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Doc comments support Markdown notations. Using `cargo doc`, the HTML documentation
    can be generated from these doc comments. Let‚Äôs see the difference between the
    two sets of doc comments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see both use to document the same module. First comment has been
    added before the module while the second one has been added inside the module.
  prefs: []
  type: TYPE_NORMAL
- en: üí° **Only use //! to write crate and module-level documentation, nothing else.
    When using mod blocks, use /// outside of the block.**
  prefs: []
  type: TYPE_NORMAL
- en: Also we can use **doc attributes** for documenting the code.
  prefs: []
  type: TYPE_NORMAL
- en: üîé An [attribute](https://doc.rust-lang.org/reference.html#attributes) is a general,
    free-form **metadatum** that is interpreted according to name, convention, and
    language and compiler version. Any item declaration may have an attribute applied
    to it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In here each comments are equivalent to relevant data attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Variable bindings , Constants & Statics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variable bindings , Constants & Statics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ‚≠êÔ∏è In Rust variable are **immutable by default**, so we call them **Variable
    bindings**. To make them mutable, `mut` keyword is used.
  prefs: []
  type: TYPE_NORMAL
- en: ‚≠êÔ∏è Rust is a **statically typed** language; It checks data type at compile time.
    But it **doesn‚Äôt require you to actually type it when declare variable bindings**.
    On that case compiler checks the usage and set a better data type for it. But
    for **constants and statics you must annotate the type**. Types come after a colon(:)
  prefs: []
  type: TYPE_NORMAL
- en: Variable bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Statics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**let** keyword is used in binding expressions. We can bind a name to a value
    or a function. Also because of left-hand side of a let expression is a ‚Äòpattern‚Äô,
    you can bind multiple names to set of values or function values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**const** keyword is used to define constants. It lives for the entire lifetime
    of a program but have no fixed address in memory. **static** keyword is used to
    define ‚Äòglobal variable‚Äô type facility. There is only one instance for each value,
    and it‚Äôs at a **fixed location in memory**.'
  prefs: []
  type: TYPE_NORMAL
- en: üí° **Always use const**, instead of static. It‚Äôs pretty rare that you actually
    want a memory location associated with your constant, and using a const allows
    for optimizations like constant propagation not only in your crate but also in
    downstream crates.
  prefs: []
  type: TYPE_NORMAL
- en: üí° Usually statics are placed at top of the code file, outside the functions.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are declared with the keyword `fn`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using **arguments**, you **must declare data types**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default functions **return empty tuple ()**. If you want to return a value,
    **return type must be specified** after **->**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Primitive Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Primitive Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**bool** : true or false'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**char** : a single Unicode scalar value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**i8 i16 i32 i64** : fixed size(bit) signed(+/-) integer types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| DATA TYPE | MIN | MAX |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| i8 | -128 | 127 |'
  prefs: []
  type: TYPE_TB
- en: '| i16 | -32768 | 32767 |'
  prefs: []
  type: TYPE_TB
- en: '| i32 | -2147483648 | 2147483647 |'
  prefs: []
  type: TYPE_TB
- en: '| i64 | -9223372036854775808 | 9223372036854775807 |'
  prefs: []
  type: TYPE_TB
- en: üí° Min and max values are based on IEEE standard for Binary Floating-Point Arithmetic;
    From **-2‚Åø‚Åª¬π to 2‚Åø‚Åª¬π-1** . You can use **min_value()** and **max_value()** to
    find min and max of each integer type, ex. i8::min_value();
  prefs: []
  type: TYPE_NORMAL
- en: '**u8 u16 u32 u64** : fixed size(bit) unsigned(+) integer types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| DATA TYPE | MIN | MAX |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| u8 | 0 | 255 |'
  prefs: []
  type: TYPE_TB
- en: '| u16 | 0 | 65535 |'
  prefs: []
  type: TYPE_TB
- en: '| u32 | 0 | 4294967295 |'
  prefs: []
  type: TYPE_TB
- en: '| u64 | 0 | 18446744073709551615 |'
  prefs: []
  type: TYPE_TB
- en: üí° Same as signed numbers, min and max values are based on IEEE standard for
    Binary Floating-Point Arithmetic; From **0 to 2‚Åø-1** . Same way you can use **min_value()**
    and **max_value()** to find min and max of each integer type, ex. u8::max_value();
  prefs: []
  type: TYPE_NORMAL
- en: '**isize** : variable sized signed(+/-) integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simply this is the data type to cover all signed integer types but memory allocates
    according to the size of a pointer. Min and max values are similar to i64 .
  prefs: []
  type: TYPE_NORMAL
- en: '**usize** : variable sized unsigned(+) integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simply this is the data type to cover all unsigned integer types but memory
    allocates according to the size of a pointer. Min and max values are similar to
    u64.
  prefs: []
  type: TYPE_NORMAL
- en: '**f32** : 32-bit floating point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to float in other languages, **Single precision**.
  prefs: []
  type: TYPE_NORMAL
- en: üí° Should avoid using this unless you need to reduce memory consumption badly
    or if you are doing low-level optimization, when targeted hardware not supports
    for double-precision or when single-precision is faster than double-precision
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: '**f64** : 64-bit floating point'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to double in other languages, **Double precision**.
  prefs: []
  type: TYPE_NORMAL
- en: '**arrays** : fixed-size list of elements of same data type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: ‚≠êÔ∏è Arrays are **immutable** by default and also **even with mut, its element
    count can not be changed**.
  prefs: []
  type: TYPE_NORMAL
- en: üîé If you are looking for a dynamic/growable array, you can use **Vec**. Vectors
    can contain any type of elements but all elements must be in the same data type.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**tuples** : fixed-size ordered list of elements of different(or same) data
    types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: ‚≠êÔ∏è Tuples are also **immutable** by default and **even with mut, its element
    count can not be changed. Also if you want to change an element‚Äôs value, new value
    should have the same data type of previous value**.
  prefs: []
  type: TYPE_NORMAL
- en: '**slice** : dynamically-sized reference to another data structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think you want to get/pass a part of an array or any other data structure. Instead
    of copy it to another array (or same data structure), Rust allows to create a
    view/reference to access only that part of data. And it can be mutable or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**str** : unsized UTF-8 sequence of Unicode string slices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: ‚≠êÔ∏è It's an **immutable/statically allocated slice** holding an **unknown sized
    sequence of UTF-8** code points stored in somewhere in memory. **&str** is used
    to borrow and assign the whole array to the given variable binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'üîé A [String](https://doc.rust-lang.org/std/string/struct.String.html) is a
    **heap**-allocated string. This string is growable, and is also guaranteed to
    be UTF-8\. They are commonly created by converting from a string slice using the
    **to_string()** or **String::from()** methods. ex: `‚ÄúHello‚Äù.to_string();` `String::from("Hello");`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: üí° In general, you should use **String** when you need **ownership**, and **&str**
    when you just need to **borrow a string**.
  prefs: []
  type: TYPE_NORMAL
- en: '**functions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we discussed on functions section, b is a function pointer, to plus_one function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Arithmetic Operators** : + - * / %'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: üîé Also **+** is used for **array and string concatenation**
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Comparison Operators** : == != < > <= >='
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Logical Operators** : ! && ||'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: üîé On integer types, ! inverts the individual bits in the two‚Äôs complement representation
    of the value.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Bitwise Operators** : & | ^ << >>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**Assignment and Compound Assignment Operators**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The = operator is used to assign a name to a value or a function. Compound Assignment
    Operators are created by composing one of + - * / % & | ^ << >> operators with
    = operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**Type Casting Operator** : as'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Borrowing and Dereference Operators** : & &mut *'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **& or &mut** operators are used for **borrowing** and ***** operator for
    **Dereferencing**.
  prefs: []
  type: TYPE_NORMAL
- en: üîé Usage of these operators is an advanced topic, for more information use [Rust
    Reference Documentation](https://doc.rust-lang.org/reference.html#unary-operator-expressions).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Control Flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Control Flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**if - else if - else**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: ‚≠êÔ∏è **Return data type should be same on each block, when using this as an expression.**
  prefs: []
  type: TYPE_NORMAL
- en: '**match**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**while**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**loop**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**for**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you remember, array is a fixed-size list of elements, of same data type.
    Even with mut, it‚Äôs element count can not be changed. Vector is kind of a re-sizable
    array but all elements must be in the same type.
  prefs: []
  type: TYPE_NORMAL
- en: ‚≠êÔ∏è It‚Äôs a generic type, written as Vec <t class="hljs-meta">. T can have any
    type, ex. The type of a Vec of i32s is Vec<i32 class="hljs-meta">. Also Vectors
    always allocate their data in dynamically allocated heap.</i32></t>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: ‚≠êÔ∏è Mainly a vector represent 3 things; a pointer to the data, No of elements
    currently have(length), capacity (Amount of space allocated for any future elements).
    If the length of a vector exceeds its capacity, its capacity will be increased
    automatically. But its elements will be reallocated(which can be slow). So always
    use Vec::with_capacity whenever it‚Äôs possible.
  prefs: []
  type: TYPE_NORMAL
- en: üîé String data type is a UTF-8 encoded vector. But you can not index into a String
    because of encoding.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Vectors can be used with iterators in three ways,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ‚≠êÔ∏è Structs are used to encapsulate related properties into one unified datatype.
  prefs: []
  type: TYPE_NORMAL
- en: üí° By convention, the name of the struct starts with a capital letter and follows
    CamelCase.
  prefs: []
  type: TYPE_NORMAL
- en: There are 3 variants of structs,
  prefs: []
  type: TYPE_NORMAL
- en: C-like structs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: one or more comma separated name:value pairs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: brace-enclosed list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: similar to classes (without it‚Äôs methods) in other languages like Java
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: because fields have names, we can access them through dot notation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tuple structs
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: one or more comma separated values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: parenthesized list like tuples
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: looks like a named tuples
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit structs
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: a struct with no members at all
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: it defines a new type but it resembles an empty tuple, ()
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: rarely in use, useful with generics
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ‚≠êÔ∏è When regarding OOP in Rust, attributes and methods are placed separately
    on structs and traits. Structs contain only attributes, traits contain only methods.
    They are getting connected via impls
  prefs: []
  type: TYPE_NORMAL
- en: 01\. C-like structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 02\. Tuple structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ‚≠êÔ∏è When a tuple struct has only one element, we called it ‚Äònewtype‚Äô pattern.
    Because it helps to create a new type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 03\. Unit structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is rarely useful on its own, but in combination with other features, it
    can become useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'üìñ ex: A library may ask you to create a structure that implements a certain
    trait to handle events. If you don‚Äôt have any data you need to store in the structure,
    you can create a unit-like struct.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ‚≠êÔ∏è An enum is a single type. It contains variants, which are possible values
    of the enum at a given time. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '‚≠êÔ∏è Variants can be accessed through :: notation , ex. Day::Sunday'
  prefs: []
  type: TYPE_NORMAL
- en: ‚≠êÔ∏è Each enum variant can have,
  prefs: []
  type: TYPE_NORMAL
- en: no data (unit variant)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: unnamed ordered data (tuple variant)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: named data (struct variant)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: üìñ Sometimes, when writing a function or data type, we may want it to work for
    multiple types of arguments. In Rust, we can do this with generics.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'üí≠ The concept is, instead of declaring a specific data type we use an uppercase
    letter(or CamelCase identifier). ex, instead x : u8 we use x : T . but we have
    to inform to the compiler that T is a generic type(can be any type) by adding
    <t class="hljs-meta">at first.</t>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: ‚≠êÔ∏è Above Option and Result types are kind of special generic types which are
    already defined in Rust‚Äôs standard library.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An optional value can have either Some value or no value/ None.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: A result can represent either success/ Ok or failure/ Err
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: üìñ The Option type is a way to use Rust‚Äôs type system to express the possibility
    of absence. Result expresses the possibility of error.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: üîé Many useful methods have been implemented around Option and Result types.
    More information can be found on std::option::Option and std::result::Result pages
    on Rust doc.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ‚≠êÔ∏è Also more practical examples of options & results can be found on Error Handling
    section in Rust doc.
  prefs: []
  type: TYPE_NORMAL
- en: Impls & Traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Impls & Traits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: üí° When we discussed about C-like structs, I mentioned that those are similar
    to classes in other languages like Java, but without their methods. impls are
    used to define methods for Rust structs and enums.
  prefs: []
  type: TYPE_NORMAL
- en: üí° Traits are kind of similar to interfaces in other languages like Java. They
    are used to define the functionality a type must provide. Multiple traits can
    be implemented to a single type.
  prefs: []
  type: TYPE_NORMAL
- en: ‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è But traits can also include default implementations of methods. Default
    methods can be override when implementing types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: ‚≠êÔ∏è As you can see methods take a special first parameter, the type itself. It
    can be either self, &self, or &mut self . self if it‚Äôs a value on the stack(taking
    ownership), &self if it‚Äôs a reference, and &mut self if it‚Äôs a mutable reference.
  prefs: []
  type: TYPE_NORMAL
- en: '‚≠êÔ∏è Some other languages support static methods. At such times, we call a function
    directly through the class without creating an object. In Rust, we call them Associated
    Functions. we use :: instead of . when calling them from struct. ex. Person::new(‚ÄúElon
    Musk Jr‚Äù);'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: ‚≠êÔ∏è Traits may inherit from other traits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: üîé While Rust favors static dispatch, it also supports dynamic dispatch through
    a mechanism called ‚Äòtrait objects.‚Äô
  prefs: []
  type: TYPE_NORMAL
- en: üÖÜ Dynamic dispatch is the process of selecting which implementation of a polymorphic
    operation (method or function) to call at run time.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the above examples, we are just trying to **assign the value of ‚Äòa‚Äô to ‚Äòb‚Äô**
    . Almost the same code in both code blocks, but having **two different data types**.
    And the second one gives an error. This is because of the **Ownership**.
  prefs: []
  type: TYPE_NORMAL
- en: ‚≠êÔ∏è Variable bindings have **ownership** of what they‚Äôre bound to. A piece of
    data can only have **one owner at a time**. When a binding goes out of scope,
    Rust will free the bound resources. This is how Rust achieves **memory safety**.
  prefs: []
  type: TYPE_NORMAL
- en: '[Ownership (noun)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The act, state, or right of possessing something.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ‚≠êÔ∏è **When assigning** a variable binding to another variable binding **or when
    passing it to a function**(Without referencing), if its data type is a
  prefs: []
  type: TYPE_NORMAL
- en: '**Copy Type**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bound resources are **made a copy and assign** or pass it to the function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The ownership state of the original bindings are set to **‚Äúcopied‚Äù state**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mostly Primitive types**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Move type**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bound resources are **moved** to the new variable binding and we **can not access
    the original variable binding** anymore.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The ownership state of the original bindings are set to **‚Äúmoved‚Äù state**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-primitive types**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: üîé The functionality of a type is handled by the traits which have been implemented
    to it. By default, variable bindings have ‚Äòmove semantics.‚Äô However, if a type
    implements [**core::marker::Copy trait**](https://doc.rust-lang.org/core/marker/trait.Copy.html)
    , it has a 'copy semantics'.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: üí° **So in the above second example, ownership of the Vec object moves to ‚Äúb‚Äù
    and ‚Äúa‚Äù doesn‚Äôt have any ownership to access the resource.**
  prefs: []
  type: TYPE_NORMAL
- en: Borrowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Borrowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In real life applications, most of the times we have to pass variable bindings
    to other functions or assign them to another variable bindings. In this case we
    **referencing** the original binding; **borrow** the data of it.
  prefs: []
  type: TYPE_NORMAL
- en: '[Borrow (verb)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To receive something with the promise of returning it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ‚≠êÔ∏è There are two types of Borrowing,
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared Borrowing** `(&T)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A piece of data can be **borrowed by a single or multiple users**, but **data
    should not be altered**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutable Borrowing** `(&mut T)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A piece of data can be **borrowed and altered by a single user**, but the data
    should not be accessible for any other users at that time.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ‚≠êÔ∏è And there are **very important rules** regarding borrowing,
  prefs: []
  type: TYPE_NORMAL
- en: One piece of data can be borrowed **either** as a shared borrow **or** as a
    mutable borrow **at a given time. But not both at the same time**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Borrowing **applies for both copy types and move types**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The concept of **Liveness** ‚Ü¥
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: üí° **Let‚Äôs see how to use shared and mutable borrowings in examples.**
  prefs: []
  type: TYPE_NORMAL
- en: Examples for Shared Borrowing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Examples for Mutable Borrowing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Lifetimes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lifetimes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are dealing with references, we have to make sure that the referencing
    data stay alive until we are stop using the references.
  prefs: []
  type: TYPE_NORMAL
- en: Think,
  prefs: []
  type: TYPE_NORMAL
- en: We have a variable binding, ‚Äú**a**‚Äù.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are referencing the value of ‚Äúa‚Äù, from another variable binding ‚Äú**x**‚Äù.
    We have to make sure that ‚Äúa‚Äù **lives** until we stop using ‚Äúx‚Äù
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: üîé **Memory management** is a form of resource management applied to computer
    memory. Up until the mid-1990s, the majority of programming languages used **Manual
    Memory Management** which **requires the programmer to give manual instructions**
    to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy
    invented **Garbage collection**(GC), a form of **Automatic Memory Management**(AMM).
    It determines what memory is no longer used and frees it automatically instead
    of relying on the programmer. However **Objective-C and Swift** provide similar
    functionality through **Automatic Reference Counting**(ARC).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In Rust,
  prefs: []
  type: TYPE_NORMAL
- en: A resource can only have **one owner** at a time. When it goes **out of the
    scope**, Rust removes it from the Memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we want to reuse the same resource, we are **referencing** it/ **borrowing**
    its content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When dealing with **references**, we have to specify **lifetime annotations**
    to provide instructions for the **compiler** to set **how long** those referenced
    resources **should be alive**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ‚≠êÔ∏èBut because of lifetime annotations make **code more verbose**, in order to
    make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted**
    in `fn` definitions. In this case, the compiler assigns lifetime annotations **implicitly**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lifetime annotations are **checked at compile-time**. Compiler checks when a
    data is used for the first and the last times. According to that, Rust manages
    memory in **run time**. This is the major reason of having **slower compilation
    times** in Rust.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike C and C++, **usually** Rust doesn‚Äôt explicitly drop values at all.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike GC, Rust doesn‚Äôt place deallocation calls where the data is no longer
    referenced.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust places deallocation calls where the data is about to go out of the scope
    and then enforces that no references to that resource exist after that point.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: üí° Lifetimes are denoted with an apostrophe. By convention, a lowercase letter
    is used for naming. Usually **starts with** `'a` and **follows alphabetic order**
    when we need to add **multiple lifetime** annotations.
  prefs: []
  type: TYPE_NORMAL
- en: When using references,
  prefs: []
  type: TYPE_NORMAL
- en: ùüéùüè. On **Function Declaration**
  prefs: []
  type: TYPE_NORMAL
- en: 'Input and output parameters with references should attach lifetimes after `&`
    sign. ex `..(x: &''a str)` , `..(x: &''a mut str)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the function name, we should mention that the given lifetimes are generic
    types. ex `fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: ùüéùüê. On **Struct or Enum Declaration**
  prefs: []
  type: TYPE_NORMAL
- en: Elements with references should attach lifetimes after `&` sign.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the name of the struct or enum, we should mention that the given lifetimes
    are generic types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: ùüéùüë. With **Impls and Traits**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: ùüéùüí. With **Generic Types**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Lifetime Elision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I mentioned earlier, in order to make **common patterns** more ergonomic,
    Rust allows lifetimes to be **elided/omitted**. This process is called **Lifetime
    Elision**.
  prefs: []
  type: TYPE_NORMAL
- en: üí° For the moment Rust supports Lifetime Elisions only on `fn` definitions. But
    in the future it will support for `impl` headers as well.
  prefs: []
  type: TYPE_NORMAL
- en: ‚≠êÔ∏è lifetime annotations of `fn` definitions can be elided
  prefs: []
  type: TYPE_NORMAL
- en: if its **parameter list** has either,
  prefs: []
  type: TYPE_NORMAL
- en: '**only one input parameter passes by reference**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a parameter with **either** `&self` **or** **&mut self** reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: üí° In the Lifetime Elision process of fn definitions,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Each parameter passes by reference is got a distinct lifetime annotation. ex.
    `..(x: &str, y: &str)` ü°í `..<''a, ''b>(x: &''a str, y: &''b str)`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the parameter list has only one parameter passes by reference, that lifetime
    is assigned to all elided lifetimes in the return values of that function. ex.
    `..(x: i32, y: &str) -> &str` ü°í `..<''a>(x: i32, y: &''a str) -> &''a str`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Even it has multiple parameters pass by reference, if one of them has &self
    or &mut self, the lifetime of self is assigned to all elided output lifetimes.
    ex. `impl Impl{ fn function(&self, x: &str) -> &str {} }` ü°í `impl<''a> Impl<''a>{
    fn function(&''a self, x: &''b str) -> &''a str {} }`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: For all other cases, we have to write lifetime annotations manually.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '''static'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ‚≠êÔ∏è `'static` lifetime annotation is a **reserved** lifetime annotation. These
    references are valid for the entire program. They are saved in the data segment
    of the binary and the data referred to will never go out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: üí° **Let‚Äôs see how to use lifetime annotations in examples.**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
