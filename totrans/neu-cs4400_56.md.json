["```\n{rec {fact {fun {n}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  {if {= 0 n}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  1\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  {* n {fact {- n 1}}}}}}\u00a0 {fact 5}}\n```", "```\n{rec {x x} x}\n```", "```\n;; Define a type for functional environments(define-type ENV = Symbol -> VAL)(: EmptyEnv : -> ENV)(define (EmptyEnv)\u00a0 (lambda (id) (error 'lookup \"no binding for ~s\" id)))(: lookup : Symbol ENV -> VAL)(define (lookup name env)\u00a0 (env name))(: Extend : Symbol VAL ENV -> ENV)(define (Extend id val rest-env)\u00a0 (lambda (name)\u00a0 \u00a0 (if (eq? name id)\u00a0 \u00a0 \u00a0 val\u00a0 \u00a0 \u00a0 (rest-env name))))\n```", "```\n[(With bound-id named-expr bound-body) (eval bound-body\u00a0 \u00a0 \u00a0  (Extend bound-id (eval named-expr env) env))]\n```", "```\n[(WRec bound-id named-expr bound-body) (eval bound-body\u00a0 \u00a0 \u00a0  (Extend bound-id (eval named-expr env) env))]\n```", "```\n[(WRec bound-id named-expr bound-body) (eval bound-body\u00a0 \u00a0 \u00a0  (extend-rec bound-id named-expr env))]\n```", "```\n(: extend-rec : Symbol FLANG ENV -> ENV) ; FLANG, not VAL!;; extend an environment with a new binding that is the result of;; evaluating an expression in the same environment as the extended;; result(define (extend-rec id expr rest-env)\u00a0 (lambda (name)\u00a0 \u00a0 (if (eq? name id)\u00a0 \u00a0 \u00a0 ... something that uses expr to get a value ...\u00a0 \u00a0 \u00a0 (rest-env name))))\n```", "```\n(define (extend-rec id expr rest-env)\u00a0 (lambda (name)\u00a0 \u00a0 (if (eq? name id)\u00a0 \u00a0 \u00a0 (eval expr ...this environment...)\u00a0 \u00a0 \u00a0 (rest-env name))))\n```", "```\n(define (extend-rec id expr rest-env)\u00a0 (letrec ([rec-env (lambda (name)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (if (eq? name id)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eval expr rec-env)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (rest-env name)))])\u00a0 \u00a0 rec-env))\n```", "```\n(define (extend-rec id expr rest-env)\u00a0 (: rec-env : Symbol -> VAL)\u00a0 (define (rec-env name)\u00a0 \u00a0 (if (eq? name id)\u00a0 \u00a0 \u00a0 (eval expr rec-env)\u00a0 \u00a0 \u00a0 (rest-env name)))\u00a0 rec-env)\n```", "```\n    {rec {x x} x}\n    ```", "```\n    (eval (Id 'x) the-new-env)\n    ```", "```\n    (lookup 'x the-new-env)\n    ```", "```\n    (the-new-env 'x)\n    ```", "```\n    (eval expr rec-env)\n    ```", "```\n(define (extend-rec id expr rest-env)\u00a0 (: rec-env : Symbol -> VAL)\u00a0 (define (rec-env name)\u00a0 \u00a0 (if (eq? name id)\u00a0 \u00a0 \u00a0 val\u00a0 \u00a0 \u00a0 (rest-env name)))\u00a0 (: val : VAL)\u00a0 (define val (eval expr rec-env))\u00a0 rec-env)\n```", "```\n(letrec ([x ...]\u00a0 \u00a0 \u00a0 \u00a0  [y ...x...])\u00a0 ...)\n```", "```\n(define x ...)(define y ...x...)\n```", "```\n(letrec ([y ...x...]\u00a0 \u00a0 \u00a0 \u00a0  [x ...])\u00a0 ...)\n```", "```\n{rec {x x} x}\n```", "```\n#lang pl#|The grammar:\u00a0 <FLANG> ::= <num>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { + <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { - <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { * <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { / <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { with { <id> <FLANG> } <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { rec { <id> <FLANG> } <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | <id>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { fun { <id> } <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { call <FLANG> <FLANG> }Evaluation rules:\u00a0 eval(N,env)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = N\u00a0 eval({+ E1 E2},env)\u00a0 \u00a0 \u00a0 \u00a0 = eval(E1,env) + eval(E2,env)\u00a0 eval({- E1 E2},env)\u00a0 \u00a0 \u00a0 \u00a0 = eval(E1,env) - eval(E2,env)\u00a0 eval({* E1 E2},env)\u00a0 \u00a0 \u00a0 \u00a0 = eval(E1,env) * eval(E2,env)\u00a0 eval({/ E1 E2},env)\u00a0 \u00a0 \u00a0 \u00a0 = eval(E1,env) / eval(E2,env)\u00a0 eval(x,env)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = lookup(x,env)\u00a0 eval({with {x E1} E2},env) = eval(E2,extend(x,eval(E1,env),env))\u00a0 eval({rec {x E1} E2},env)\u00a0 = ???\u00a0 eval({fun {x} E},env)\u00a0 \u00a0 \u00a0 = <{fun {x} E}, env>\u00a0 eval({call E1 E2},env1)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  = eval(Ef,extend(x,eval(E2,env1),env2))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  if eval(E1,env1) = <{fun {x} Ef}, env2>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  = error!\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 otherwise|#(define-type FLANG\u00a0 [Num\u00a0 Number]\u00a0 [Add\u00a0 FLANG FLANG]\u00a0 [Sub\u00a0 FLANG FLANG]\u00a0 [Mul\u00a0 FLANG FLANG]\u00a0 [Div\u00a0 FLANG FLANG]\u00a0 [Id\u00a0  Symbol]\u00a0 [With Symbol FLANG FLANG]\u00a0 [WRec Symbol FLANG FLANG]\u00a0 [Fun\u00a0 Symbol FLANG]\u00a0 [Call FLANG FLANG])(: parse-sexpr : Sexpr -> FLANG);; parses s-expressions into FLANGs(define (parse-sexpr sexpr)\u00a0 (match sexpr\u00a0 \u00a0 [(number: n)\u00a0 \u00a0 (Num n)]\u00a0 \u00a0 [(symbol: name) (Id name)]\u00a0 \u00a0 [(cons 'with more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'with (list (symbol: name) named) body)\u00a0 \u00a0 \u00a0 \u00a0 (With name (parse-sexpr named) (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `with' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(cons 'rec more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'rec (list (symbol: name) named) body)\u00a0 \u00a0 \u00a0 \u00a0 (WRec name (parse-sexpr named) (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `rec' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(cons 'fun more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'fun (list (symbol: name)) body)\u00a0 \u00a0 \u00a0 \u00a0 (Fun name (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `fun' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(list '+ lhs rhs) (Add (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '- lhs rhs) (Sub (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '* lhs rhs) (Mul (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '/ lhs rhs) (Div (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list 'call fun arg)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (Call (parse-sexpr fun) (parse-sexpr arg))]\u00a0 \u00a0 [else (error 'parse-sexpr \"bad syntax in ~s\" sexpr)]))(: parse : String -> FLANG);; parses a string containing a FLANG expression to a FLANG AST(define (parse str)\u00a0 (parse-sexpr (string->sexpr str)));; Types for environments, values, and a lookup function(define-type VAL\u00a0 [NumV Number]\u00a0 [FunV Symbol FLANG ENV]);; Define a type for functional environments(define-type ENV = Symbol -> VAL)(: EmptyEnv : -> ENV)(define (EmptyEnv)\u00a0 (lambda (id) (error 'lookup \"no binding for ~s\" id)))(: lookup : Symbol ENV -> VAL);; lookup a symbol in an environment, return its value or throw an;; error if it isn't bound(define (lookup name env)\u00a0 (env name))(: Extend : Symbol VAL ENV -> ENV);; extend a given environment cache with a new binding(define (Extend id val rest-env)\u00a0 (lambda (name)\u00a0 \u00a0 (if (eq? name id)\u00a0 \u00a0 \u00a0 val\u00a0 \u00a0 \u00a0 (rest-env name))))(: extend-rec : Symbol FLANG ENV -> ENV);; extend an environment with a new binding that is the result of;; evaluating an expression in the same environment as the extended;; result(define (extend-rec id expr rest-env)\u00a0 (: rec-env : Symbol -> VAL)\u00a0 (define (rec-env name)\u00a0 \u00a0 (if (eq? name id)\u00a0 \u00a0 \u00a0 val\u00a0 \u00a0 \u00a0 (rest-env name)))\u00a0 (: val : VAL)\u00a0 (define val (eval expr rec-env))\u00a0 rec-env)(: NumV->number : VAL -> Number);; convert a FLANG runtime numeric value to a Racket one(define (NumV->number val)\u00a0 (cases val\u00a0 \u00a0 [(NumV n) n]\u00a0 \u00a0 [else (error 'arith-op \"expected a number, got: ~s\" val)]))(: arith-op : (Number Number -> Number) VAL VAL -> VAL);; gets a Racket numeric binary operator, and uses it within a NumV;; wrapper(define (arith-op op val1 val2)\u00a0 (NumV (op (NumV->number val1) (NumV->number val2))))(: eval : FLANG ENV -> VAL);; evaluates FLANG expressions by reducing them to values(define (eval expr env)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) (NumV n)]\u00a0 \u00a0 [(Add l r) (arith-op + (eval l env) (eval r env))]\u00a0 \u00a0 [(Sub l r) (arith-op - (eval l env) (eval r env))]\u00a0 \u00a0 [(Mul l r) (arith-op * (eval l env) (eval r env))]\u00a0 \u00a0 [(Div l r) (arith-op / (eval l env) (eval r env))]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (eval bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (Extend bound-id (eval named-expr env) env))]\u00a0 \u00a0 [(WRec bound-id named-expr bound-body)\u00a0 \u00a0  (eval bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (extend-rec bound-id named-expr env))]\u00a0 \u00a0 [(Id name) (lookup name env)]\u00a0 \u00a0 [(Fun bound-id bound-body)\u00a0 \u00a0  (FunV bound-id bound-body env)]\u00a0 \u00a0 [(Call fun-expr arg-expr)\u00a0 \u00a0  (let ([fval (eval fun-expr env)])\u00a0 \u00a0 \u00a0  (cases fval\u00a0 \u00a0 \u00a0 \u00a0  [(FunV bound-id bound-body f-env)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eval bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (Extend bound-id (eval arg-expr env) f-env))]\u00a0 \u00a0 \u00a0 \u00a0  [else (error 'eval \"`call' expects a function, got: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fval)]))]))(: run : String -> Number);; evaluate a FLANG program contained in a string(define (run str)\u00a0 (let ([result (eval (parse str) (EmptyEnv))])\u00a0 \u00a0 (cases result\u00a0 \u00a0 \u00a0 [(NumV n) n]\u00a0 \u00a0 \u00a0 [else (error 'run \"evaluation returned a non-number: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  result)])));; tests(test (run \"{call {fun {x} {+ x 1}} 4}\")\u00a0 \u00a0 \u00a0 => 5)(test (run \"{with {add3 {fun {x} {+ x 3}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call add3 1}}\")\u00a0 \u00a0 \u00a0 => 4)(test (run \"{with {add3 {fun {x} {+ x 3}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {add1 {fun {x} {+ x 1}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {x 3}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call add1 {call add3 x}}}}}\")\u00a0 \u00a0 \u00a0 => 7)(test (run \"{with {identity {fun {x} x}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {foo {fun {x} {+ x 1}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call {call identity foo} 123}}}\")\u00a0 \u00a0 \u00a0 => 124)(test (run \"{with {x 3}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {f {fun {y} {+ x y}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {x 5}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call f 4}}}}\")\u00a0 \u00a0 \u00a0 => 7)(test (run \"{call {with {x 3}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {fun {y} {+ x y}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 4}\")\u00a0 \u00a0 \u00a0 => 7)(test (run \"{call {call {fun {x} {call x 1}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {fun {x} {fun {y} {+ x y}}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 123}\")\u00a0 \u00a0 \u00a0 => 124)\n```"]