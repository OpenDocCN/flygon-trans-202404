- en: Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a map?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To compare different authors, or to identify a good match in a web search, we
    can use a histogram of a document. It contains all the words used, and for each
    word how often it was used.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, given an input text, we want to compute a mapping
  prefs: []
  type: TYPE_NORMAL
- en: \[ \textit{words} \rightarrow \mathbb{N} \]that maps a word \(w\) to the number
    of times it is used in the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'We therefore need a data type that can store pairs of (word, count), that is,
    pairs of (String, Int). It should support the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: insert a new pair (given word and count),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: given a word, find the current count,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: update the count for a word,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: enumerate all the pairs in the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This data type is called a map or dictionary. A map implements a mapping from
    some key type to some value type.
  prefs: []
  type: TYPE_NORMAL
- en: The Java library provides a parameterized data type Map<K,V>, where K is the
    key type and V is the value type. We can think of it as a container for (K,V)
    pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create such a map as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of having to write Pair for every mapping, we can use the small utility
    function to. It does nothing but combine two elements into a pair, and makes the
    syntax for creating a map nicer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can access the mappings using the nice mathematical syntax \(m[x]\) for
    the result of mapping key \(x\) by the mapping \(m\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that requesting a key that is not in the map will return the value null.
    This means that the result type of the map access is actually V? (see [nullable
    types](tutorial-null)).
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that you have to first check the result for null before you can
    do anything with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the getOrElse method: if the key is not in the map,
    it will use the provided code to compute a default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The result type of getOrElse is the (not nullable) value type V, so there is
    no need to check for null.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check if a mapping is defined for a given key using the in operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can determine the number of entries in a map m as m.size, use m.isEmpty()
    to determine if the map has no mappings, and you can iterate over all the entries
    of a map using a for-loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Mutable maps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Often we need a mutable map, where we can add, update, and remove mappings.
    We use the syntax m[key] on the left side of an assignment to add or change a
    mapping. Mappings are removed using m.remove(key).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful method is getOrPut. If the given key is in the map, it returns
    the value from the map. Otherwise, it executes the given piece of code, stores
    the value in the map (for the given key), and returns the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Computing a word histogram
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is my first attempt at a histogram program ([histogram1.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/30-maps/histogram1.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The function histogram creates an empty map hist from strings to integers. It
    then looks at all words in the file, converts them to uppercase. Using getOrElse,
    we obtain the current mapping of the word or zero if the word is not yet there.
    We increase the number by one, and store the new number in the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I run it on the text file [text.txt](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/30-maps/text.txt),
    I get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is not very pretty, so I should use a nicer way of printing out
    the map. This can be done by iterating over the contents of the map, as follows
    ([histogram2.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/30-maps/histogram2.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is much nicer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is still not perfect, because it''s quite hard to find the word we are
    looking for. It would be better if the list was sorted. We can do this by converting
    the map to a sorted map ([histogram3.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/30-maps/histogram3.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the output becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How do maps work?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Maps are implemented using a hash table, which allows extremely fast insertion,
    removal, and search, but does not maintain any ordering on the keys. (Come to
    [CS206](../cs206) to learn about hash tables.)
  prefs: []
  type: TYPE_NORMAL
- en: A pronounciation dictionary
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's build a real "dictionary", one that maps words to other words. In this
    case, we want to build a map that maps English words to their pronounciation (English
    pronounciation is so unpredictable, it would be nice to have a tool to help with
    this).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the data file [cmudict.txt](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/30-maps/cmudict.txt).
    Here are a few example lines from this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The format is roughly this: A line starting with # is a comment. Other lines
    start with a word in upper case, then a space, then the pronounciation in a particular
    format (the phonemes are separated by spaces, we will not go into details).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some words have more than one correct pronounciation, see "adhesive" above.
    As you can see, the additional pronounciations are indicated by the number in
    parentheses after the word. Here is another example for a word with three pronounciations
    (and partly different meanings):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a function that reads the file and constructs a mapping. It simply
    ignores the additional pronounciations and only uses the first one for each word
    (note that it returns an immutable map even though it internally works with a
    mutable map): ([cmudict1.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/30-maps/cmudict1.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a quick test of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s put our map to some use. English has many words that are homophones:
    they sound the same, like “be” and “bee”, or ”sewing” and ”sowing”. We want to
    find some more examples. What would be the largest number of different words that
    all have the same pronounciation?'
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine this, we need to create a dictionary for the opposite direction:
    mapping pronounciations to words. Since there may be several words with the same
    pronounciation, this will be a Map<String, Set<String>>, that is a mapping from
    strings to sets of strings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We write a general function that computes the inverse function of a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We test with some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we use the reverse map to display all the words that have at least
    a certain number of homophones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output for \(k = 10\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try another puzzle: There are words in English that sound the same if
    you remove the first letter: "knight" and "night" is an example. Let''s try to
    find all such words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How many of these words do you know?
  prefs: []
  type: TYPE_NORMAL
- en: There is a word in English where you can remove both the first letter or the
    second letter, and it still sounds the same. (In other words, if the whole word
    is XYABCDE, then YABCDE and XABCDE sound the same as XYABCDE.)
  prefs: []
  type: TYPE_NORMAL
- en: Can you figure out which word this is?
  prefs: []
  type: TYPE_NORMAL
