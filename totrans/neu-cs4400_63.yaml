- en: State and EnvironmentsTuesday, February 28th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A quick example of how mutation can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'and compare that to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is a good idea if you follow the exact evaluation of
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'and see how both bindings have separate environment so each one gets its own
    private state. The equivalent code in the homework interpreter extended with `set!`
    doesn’t need boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: (To see multiple values from a single expression you can extend the language
    with a `list` binding.) Note that we cannot describe this behavior with substitution
    rules! We now use the environments to make it possible to change bindings — so
    finally an environment is actually an environment rather than a substitution cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you look at the above, note that we still use lexical scope — in fact,
    the local binding is actually a private state that nobody can access. For example,
    if we write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: then the resulting function that us bound to `counter` keeps a local integer
    state which no other code can access — you cannot modify it, reset it, or even
    know if it is really an integer that is used in there.
  prefs: []
  type: TYPE_NORMAL
