- en: Reallocating underlying array of slice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reallocating underlying array of slice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: When appending data into slice, if the underlying array of the slice doesn't
    have enough space, a new array will be allocated. Then the elements in old array
    will be copied into this new memory, accompanied with adding new data behind.
    So when using `Go` built-in `append` function, you must always keep the idea that
    "the array may have been changed" in mind, and be very careful about it, otherwise,
    it may bite you!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me explain it through a contrived example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `s1` is `[0, 0]`, and the `s2` is `[0, 0, 0]`; in `addTail` function, I
    want to add `1` and `2` behind the slice. So the wanted output is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'But the actual result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The operations on `s1` are successful, while `s2` not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `delve` to debug this issue and check the internal mechanism of
    slice: Add breakpoint on `addTail` function, and it is first hit when processing
    `s1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The length and capacity of `s1` are both `2`, and the underlying array address
    is `0xc82000a2a0`, so what happened when executing the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the length and capacity of `s1` are both `2`, there is no room for new
    buddy. To append a new value, a new array must be allocated, and it contains both
    `[0, 0]` from `s1` and the new value(`1` or `2`). You can consider `append(s,
    v)` generated an anonymous new slice, and it is appended in `ns`. We can check
    it after running "`ns = append(ns, append(s, v))`":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the length of anonymous slice is `3`, capacity is `4`, and the underlying
    array address is `0xc82000e240`, different from `s1`''s (`0xc82000a2a0`). Continue
    executing until exit loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can see `s1`, `ns[0]` and `ns[1]` have `3` independent array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s follow the same steps to check what happened on `s2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The length of `s2` is `3`, and capacity is `4`, so there is one slot for adding
    new element. Check the `s2` and `ns`'' values after executing "`ns = append(ns,
    append(s, v))`" the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the new anonymous slice''s array address is also `0xc82000e220`,
    that''s because the `s2` has enough space to hold new value, no new array is allocated.
    Check the `s2` and `ns` again after adding `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: All `3` slices point to the same array, so the later value(`2`) will override
    previous item(`1`).
  prefs: []
  type: TYPE_NORMAL
- en: So in a conclusion, `append` is very tricky since it can modify the underlying
    array without noticing you. You must know the memory layout behind every slice
    clearly, else the slice can give you a big, unwanted surprise!
  prefs: []
  type: TYPE_NORMAL
