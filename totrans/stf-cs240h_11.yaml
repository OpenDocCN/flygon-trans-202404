- en: Web and Database Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: May 15, 2014 - CS240H
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to follow along on your laptop towards the end:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For ghc-7.6:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For ghc-7.8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ll also need to have PostgreSQL installed
  prefs: []
  type: TYPE_NORMAL
- en: Agenda
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Intro/motivation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modeling a web application in Haskell
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a content management system
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you care about web programming?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The WWW is starting to get *pretty* popular
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: If you building something, there’s a good chance you’ll deploy as a web app
    the internet
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if your application doesn’t seem very “webby”
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP becoming prevelent general-purpose protocol for APIs (both internal and
    external)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Good client support
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Good server-side support (frameworks, SSL, virtual domains…)
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to “sell” to management
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you people write a web app?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actually, that depends…
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A busy space of frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used to be dominated by Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: terms like “Java Servlet Container”, “J2EE”, “Enterprise Java Beans”, “POJO”
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: everybody had a really bad experience with that in the late 90s/early 2Ks
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Java is still the primary server-side language for, e.g. Google, Amazon
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The cool kids are mostly using dynamic languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby/Ruby on Rails/Sinatra
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Python/Django
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: node.js/express
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: etc…
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Web Programming - Most Popular Language Today?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: . . .
  prefs: []
  type: TYPE_NORMAL
- en: But why dynamic languages?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But why dynamic languages?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Less verbose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: e.g. no type declerations
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: vs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: But why dynamic languages?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Advanced features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: like closures
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: vs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: But why dynamic languages?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other less compelling reasons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fast development and prototyping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic language GOOD because *dynamic* web sites!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “When rendering web pages, often you have very many components interacting on
    a web page. You have buttons over here and little widgets over there and there
    are dozens of them on a webpage, as well as possibly dozens or hundreds of web
    pages on your website that are all **dynamic**. […] using a statically typed language
    is actually quite inflexible. […] like the whole system has to type check just
    to be able to move a button around”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- Nick Kallen from Twitter'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is it really about dynamism?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No type declerations (but still typed)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A lot of the arguments are really about weaknesses in Java et al.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modeling a web application in Haskell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Claim: a web application does three things:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: parses a request from the client
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: performs some side effects (e.g. reading/writing to a database)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: generates some response for the client
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Given the following two types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fill in the type for an `Application`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Boilerplate code: [http://cs240h.scs.stanford.edu/Application.hs](Application.hs)'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling a web application in Haskell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE10]haskell data Request = Request {pathInfo :: [String], requestMethod
    :: Method, ...} data Response = Response Status [Header] String type Application
    = Request -> IO Response [PRE11]'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve just implemented the WAI package – “Web Application Interface”!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The WAI package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Common interface between servers and applications so you can mix-and-match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Servers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: warp
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: FastCGI
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: wai-handler-devel (for development)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'App frameworks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yesod
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scotty
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hails (shameless plug)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple (shameless plug)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Others through adapters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The WAI package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A really simple application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s build the simplest application that displays something in a browser
  prefs: []
  type: TYPE_NORMAL
- en: 'First install `wai` and `warp`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Finally, build the app!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Demo Time!
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s build a CMS!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (Very) quick intro to *Simple*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Very) quick intro to *postgresql-orm*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write some code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Simple* - a web framework in Haskell'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Simple* is a web framework with one type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Very small wrapper around WAI’s `Application` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s us refer to the `Request` anywhere without passing it around
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s us refer to some application state anywhere without passing it around
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s us decide we’re ready to respond and stop computing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some *Simple* combinators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Stop computing and respond to a request:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the request and app state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Parse query and form parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Some *Simple* combinators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Routing combinators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Higher-level *Simple* combinators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Common case is to match on method and a particular path pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So a typical small app might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Object relational mapper (ORM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: maps from native types to SQL
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case maps to PostgreSQL flavored SQL
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Haskell types must be of the form:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Instances of the `Model` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the `Model` derives `Generic` we don’t need to write an implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us access to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we’re in Haskell, let’s us avoid a bunch of edge cases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fields cannot be null (unless they are a `Maybe`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fields cannot be different types (unless they are an `Either`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation because redundant in many cases
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OK, let’s get to coding:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
