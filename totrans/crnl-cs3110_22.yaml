- en: 'Recitation 14: Async Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last lecture, we saw some simple examples of programming with deferred
    computations in `async`. In this recitation, we will implement a simple echo server
    using `async` and *pipes*. We will also briefly discuss exception handling in
    `async`.
  prefs: []
  type: TYPE_NORMAL
- en: Pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many programs have one component that produces some data and another component
    that consumes it. This idiom is sometimes called the *producer-consumer* pattern.
    A simple way to implement the producers and consumers is to keep them in lock
    step: whenever the producer generates an item, control is passed to the consumer
    which processes it, and finally returns control back to the producer. However,
    this is not very efficient, especially if not all items take the same amount of
    time to produce and consume.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another different way to implement producers and consumers is to use a FIFO
    *pipe*. The producer generates data items and writes them into the pipe, and the
    consumer reads items from the pipe. Importantly, the pipe can contain many items,
    so the producer and consumer need not proceed in lock step. The `async` [Pipe](https://ocaml.janestreet.com/ocaml-core/111.28.00/doc/async/#Std.Pipe)
    module includes functions for creating and manipulating pipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that the type `[ `Eof | `Ok of ''a]` is a *polymorphic variant*. For
    the purposes of this course, it can be treated as an ordinary datatype (whose
    constructors are prefixed with the backtick symbol, "`"). The Pipe module also
    includes other useful functions for closing the endpoints of a pipe and for mapping,
    filtering, and transferring pipe contents include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The notation `f:('a -> b)` used in `map` and other functions is a *labled parameter*.
    To invoke a function with a labeled parameter, use the syntax `~f:(fun x -> x)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example demonstrating how to move data across a pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `write` returns a deferred unit that eventually becomes determined.
  prefs: []
  type: TYPE_NORMAL
- en: As a more substantial example, the following program implements an echo server
    (code adapted from [Real World OCaml](https://realworldocaml.org/v1/en/html/concurrent-programming-with-async.html)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: ocamlbuild -use-ocamlfind -pkg core -pkg async -tag thread server.byte
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: ./server.byte
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: cs3110 compile -t -p async server
  prefs: []
  type: TYPE_NORMAL
- en: cs3110 run server
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '% telnet localhost 3110'
  prefs: []
  type: TYPE_NORMAL
- en: Trying 127.0.0.1...
  prefs: []
  type: TYPE_NORMAL
- en: Connected to localhost.
  prefs: []
  type: TYPE_NORMAL
- en: Escape character is '^]'.
  prefs: []
  type: TYPE_NORMAL
- en: Hello
  prefs: []
  type: TYPE_NORMAL
- en: Hello
  prefs: []
  type: TYPE_NORMAL
- en: World
  prefs: []
  type: TYPE_NORMAL
- en: World
  prefs: []
  type: TYPE_NORMAL
- en: Zardoz
  prefs: []
  type: TYPE_NORMAL
- en: Zardoz
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'val try_with : (unit -> ''a Deferred.t) -> [`Ok of ''a | `Err of exn] Deferred.t'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
