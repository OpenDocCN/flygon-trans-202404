- en: Mapreduce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Mapreduce
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will revisit higher order functions from Unit 2 (`map` and
    `accumulate`) and combine it with parallelism which enables us to process a huge
    amount of data efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Background to Mapreduce
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Engineers in Google noticed that a majority of their computations could be broken
    down into a `map` of some function over data, followed by an `accumulate` (also
    known as `reduce`, hence the name) afterwards. The result is a library procedure
    named `mapreduce` that takes two functions as arguments; one that acts as a `mapper`
    and another that acts as a `reducer`. It accepts a large chunk of data, divide
    them into smaller parts, apply the `mapper` to the smaller sized data and combines
    the results with a `reducer`. Mapreduce handles everything related to parallelism,
    and we only have to provide the 2 functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this may *seem* like what `mapreduce` is doing, this is **not** `mapreduce`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Why is that not mapreduce? Because it doesn''t handle dividing the data, applying
    the mapper parallelism and sorting them before reducing them. What it gets right
    though is that whoever wants to use mapreduce only needs to pass four arguments:
    `mapper, reducer, base-case` and the `data`we want to process to the `mapreduce`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested, [here](http://static.googleusercontent.com/media/research.google.com/en/us/archive
    /mapreduce-osdi04.pdf) is an paper written by the Google employees who came up
    with mapreduce. It is not required, but it is pretty readable and interesting.
    [The old lecture notes](http://inst.eecs.berkeley.edu/~cs61as/reader/notes.pdf#page=24)
    also have a good explanation, and you should read those if you feel like you don't
    understand mapreduce.
  prefs: []
  type: TYPE_NORMAL
- en: Breakdown of Mapreduce
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](/static/mapreduce.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Map the `mapper` to the smaller data (done in parallel). This involves selecting
    parts of the input we want to process and "attaching" a key to each results
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort the result to 'buckets' based on their keys
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each 'bucket' is passed to a `reducer` that accumulates the values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will look at each of these steps into more detail in subsequence sections.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this lesson, we will use the example of searching through a text
    file and find the frequency of the words.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will act as our test files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that every line is 'tagged' with their titles. We recommend keeping this
    tab open somewhere so that you know what our input looks like.
  prefs: []
  type: TYPE_NORMAL
- en: You can get this data and the other functions of our implementation of mapreduce
    [here](/static/mapreduce.scm). Note that this implementation does not involve
    parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: Mapper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](/static/mapreduce_mapper.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Input**: (smaller) A key-value pair'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output**: list of key-value pairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `mapper` is a function that accepts data (as a key-value pair), and returns
    a **list** of key-value pairs. A list of key-value pairs is the same as associative
    lists (also known as a-lists) that we played with in lesson 9\. The keys are used
    to keep track of where the data is from; this is important for the parallelization.
    Note that the key of the input is not neccessarily the same as the key(s) that
    the mapper outputs. This will be our ADT for kv-pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the first item of our sample input, the result is the following
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Why do we output a list of key-value pairs instead of a single key-value pair?
    Here are some reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**no key-value**: There will be cases where our data does not contain a key
    that is of an interest to us. For example imagine a case where you want to count
    number of vowels in a word, and you encounter the word ''fly''. We would return
    the empty list in this case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**multiple key-value**: There will be cases where our data corresponds to 2
    or more keys that we want to produce. This is applicable to our song lyrics example
    (shown below)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extended Example: Word-Count'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is the definition of a mapper for our example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What does our mapper do? It accepts a key-value pair (its key is the song title,
    its value is a line from the song). For every word in the lines, use the word
    as the new key, and pair that with the value 1\. Note that even if a word appears
    twice in the line, like '(please please me), it outputs (please . 1) twice and
    NOT (please . 2). That is fine, because here we are only starting the count for
    each at 1\. We add them up later.
  prefs: []
  type: TYPE_NORMAL
- en: sort-into-buckets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](/static/mapreduce_sort.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we actually get into the `reducer`, there is an intermediary step that
    sorts the keys, and group the same keys together. Fortunately, we can take advantage
    of abstraction and use the function `**sort-into-buckets**` to sort them into
    ''buckets''for us. key-value pairs with the same keys are grouped under the same
    ''bucket''. This is the result of calling the mapper from the previous step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling sort-into-buckets results inthe following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Some parts of the result is ommited to keep it short. Note how the keys and
    values are organized here. The result is a list of buckets, where a bucket is
    a list of kv-pair with the same keys. `((i . 1) (i . 1) (i . 1) (i . 1))` is an
    example of a bucket, where each kv-pair has the key 'i'.
  prefs: []
  type: TYPE_NORMAL
- en: Reducer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](/static/mapreduce_reduce.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Input**: two "values"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output**: a value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `reducer` accepts two values(without the keys), and outputs a single value.
    This will be the output associated with that particular key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extended Example: Word-Count'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is the definition for our reducer
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Reducing One Bucket
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that our reducer accepts two values while the result of our previous step
    (sort-into-buckets) is a list of buckets (where a bucket is a list of key- value
    pairs). Let''s look at how we can use our `reducer` to a single key- value. Let
    us use our first list of key-value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`> (accumulate reducer 0 (map kv-value ''((i . 1) (i . 1) (i . 1) (i . 1) (i
    . 1))))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'this simplifies to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`> (accumulate reducer 0 ''(1 1 1 1 1))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`5`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we call accumulate, we have to obtain the values from the list of kv-
    pairs by using map. Note that the result of calling accumulate is a single value
    (the 5) associated with the key (which is ''i'' in this case). Because our end
    result needs to be a kv-pair, we have to return `(i . 5)` in the end. The expression
    then becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can generalize the expression above into any other "bucket" besides '((i
    . 1) (i . 1) (i . 1) (i . 1) (i . 1)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Reducing a List of Buckets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The procedure `reduce-bucket` above reduces one bucket. Our result from the
    previous step, `(sort-into-buckets (map mapper data))` is a list of buckets. To
    reduce a list of buckets, we can use map again. We are going to define the function
    `group-reduce` that does exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use what we have so far, it evaluates into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Some values are omitted for conciseness. The final result is again, a list
    of kv-pairs: the key is the word, the value is how many times those words appear
    in our data. We have just used mapreduce to construct word counts for words in
    our data!'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the final (hand-wavy, approximated) definition of our mapreduce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Why is it not the actual mapreduce? The actual one will involve mapping and
    reducing our kv-pairs parallely and we have to take into account of concurrency
    issues. The definition above captures the major parts that we are concerned with.
  prefs: []
  type: TYPE_NORMAL
- en: Practice with Mapreduce
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Writing a mapreduce function is all about defining your mapper and reducer.
    We have series of different scenarios and want you guys to define the corresponding
    mapper, reducer and at the end the call to mapreduce.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember:'
  prefs: []
  type: TYPE_NORMAL
- en: The input to your mapper is a key-value-pair and it outputs a **list** of key-value
    pairs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input to your reducer are two values and it outputs one value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining Mapreduce
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As hinted before, since mapreduce takes as an input a list of key-value pairs
    and outputs a list of key-value pairs, it is possible to chain mapreduce together.
    It would look something like this: `(mapreduce some-mapper some- reducer some-base-case
    (mapreduce another-mapper another-reducer another-base- case actual-input))`.
    Note that the keys and values for the first mapreduce may be totally different
    from your second mapreduce.'
  prefs: []
  type: TYPE_NORMAL
- en: Most Frequent Word
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's write another mapreduce function (We're not chaining yet). This time,
    our input has a key of 'words' and the value are numbers, representing how many
    times they appeared in a document. We want our output to be a list of a **single**
    key-value pair where just like the input, our key is a word and our value is a
    number such that it is the highest number encountered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: our solution isn''t ideal, and it''s a little contrived. It doesn''t
    take advantage of the parallelism that mapreduce offers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now We're Chaining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our function above works, if we pass the pairs with the key as a word, and value
    as a number. In real life, we might not have direct access to the word counts
    of each word; we have to process that from the original document.
  prefs: []
  type: TYPE_NORMAL
- en: Write the function `real-most-frequent` that accepts a list of key-value pairs
    where the key is the name of the file, and the values are lines from that file
    (just like our all-songs example) . Our output is again, a list of **single**
    key-value pair. You may want to reuse any functions we have defined so far in
    the lesson.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The reader does not contain MapReduce exercises. If you want to get more practices,
    there are MapReduce questions on the Lesson 14 discussion.
  prefs: []
  type: TYPE_NORMAL
