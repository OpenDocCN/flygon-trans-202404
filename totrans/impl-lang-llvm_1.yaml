- en: Lexer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kaleidoscope Language and its Lexer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1.1 The Basic Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This tutorial will be illustrated with a toy language that we’ll call “Kaleidoscope”
    (derived from “meaning beautiful, form, and view”). Kaleidoscope is a procedural
    language that allows you to define functions, use conditionals, math, etc. Over
    the course of the tutorial, we’ll extend Kaleidoscope to support the if/then/else
    construct, a for loop, user defined operators, JIT compilation with a simple command
    line interface, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we want to keep things simple, the only datatype in Kaleidoscope is
    a 64-bit floating point type (aka `double` in C parlance). As such, all values
    are implicitly double precision and the language doesn’t require type declarations.
    This gives the language a very nice and simple syntax. For example, the following
    simple example computes Fibonacci numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We also allow Kaleidoscope to call into standard library functions (the LLVM
    JIT makes this completely trivial). This means that you can use the `extern` keyword
    to define a function before you use it (this is also useful for mutually recursive
    functions). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A more interesting example is included in Chapter 6 where we write a little
    Kaleidoscope application that displays a Mandelbrot Set at various levels of magnification.
  prefs: []
  type: TYPE_NORMAL
- en: Lets dive into the implementation of this language!
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 The Lexer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to implementing a language, the first thing needed is the ability
    to process a text file and recognize what it says. The traditional way to do this
    is to use a “lexer” (aka ‘scanner’) to break the input up into “tokens”. Each
    token returned by the lexer includes a token code and potentially some metadata
    (e.g. the numeric value of a number). First, we define the possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Each token returned by our lexer will either be one of the Token enum values
    or it will be an ‘unknown’ character like `+`, which is returned as its ASCII
    value. If the current token is an identifier, the IdentifierStr global variable
    holds the name of the identifier. If the current token is a numeric literal (like
    1.0), NumVal holds its value. Note that we use global variables for simplicity,
    this is not the best choice for a real language implementation :).
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual implementation of the lexer is a single function named gettok. The
    gettok function is called to return the next token from standard input. Its definition
    starts as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: gettok works by calling the C getchar() function to read characters one at a
    time from standard input. It eats them as it recognizes them and stores the last
    character read, but not processed, in LastChar. The first thing that it has to
    do is ignore whitespace between tokens. This is accomplished with the loop above.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing gettok needs to do is recognize identifiers and specific keywords
    like `def`. Kaleidoscope does this with this simple loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this code sets the `IdentifierStr` global whenever it lexes an identifier.
    Also, since language keywords are matched by the same loop, we handle them here
    inline. Numeric values are similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all pretty straight-forward code for processing input. When reading
    a numeric value from input, we use the C strtod function to convert it to a numeric
    value that we store in NumVal. Note that this isn’t doing sufficient error checking:
    it will incorrectly read "1.23.45.67" and handle it as if you typed in "1.23".
    Feel free to extend it :). Next we handle comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We handle comments by skipping to the end of the line and then return the next
    token. Finally, if the input doesn’t match one of the above cases, it is either
    an operator character like `+` or the end of the file. These are handled with
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have the complete lexer for the basic Kaleidoscope language (the
    full code listing for the Lexer is available in the next chapter of the tutorial).
    Next we’ll build a simple parser that uses this to build an Abstract Syntax Tree.
    When we have that, we’ll include a driver so that you can use the lexer and parser
    together.
  prefs: []
  type: TYPE_NORMAL
