- en: The Linker Is not a Magical Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linker Is not a Magical Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Depressingly often (happened to me again just before I wrote this), the view
    many programmers have of the process of going from source code to a statically
    linked executable in a compiled language is:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit source code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile source code into object files
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Something magical happens
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run executable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Step 3 is, of course, the linking step. Why would I say such an outrageous
    thing? I''ve been doing tech support for decades, and I get the following questions
    again and again:'
  prefs: []
  type: TYPE_NORMAL
- en: The linker says def is defined more than once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The linker says abc is an unresolved symbol.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is my executable so large?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Followed by "What do I do now?" usually with the phrases "seems to" and "somehow"
    mixed in, and an aura of utter bafflement. It's the "seems to" and "somehow" that
    indicate that the linking process is viewed as a magical process, presumably understandable
    only by wizards and warlocks. The process of compiling does not elicit these kinds
    of phrases, implying that programmers generally understand how compilers work,
    or at least what they do.
  prefs: []
  type: TYPE_NORMAL
- en: A linker is a very stupid, pedestrian, straightforward program. All it does
    is concatenate together the code and data sections of the object files, connect
    the references to symbols with their definitions, pull unresolved symbols out
    of the library, and write out an executable. That's it. No spells! No magic! The
    tedium in writing a linker is usually all about decoding and generating the usually
    ridiculously overcomplicated file formats, but that doesn't change the essential
    nature of a linker.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s say the linker is saying def is defined more than once. Many programming
    languages, such as C, C++, and D, have both declarations and definitions. Declarations
    normally go into header files, like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'which generates an external reference to the symbol `iii`. A definition, on
    the other hand, actually sets aside storage for the symbol, usually appears in
    the implementation file, and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How many definitions can there be for each symbol? As in the film *Highlander*,
    there can be only one. So, what if a definition of iii appears in more than one
    implementation file?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The linker will complain about `iii` being multiply defined.
  prefs: []
  type: TYPE_NORMAL
- en: Not only can there be only one, there must be one. If iii only appears as a
    declaration, but never a definition, the linker will complain about iii being
    an unresolved symbol.
  prefs: []
  type: TYPE_NORMAL
- en: To determine why an executable is the size it is, take a look at the map file
    that linkers optionally generate. A map file is nothing more than a list of all
    the symbols in the executable along with their addresses. This tells you what
    modules were linked in from the library, and the sizes of each module. Now you
    can see where the bloat is coming from. Often there will be library modules that
    you have no idea why were linked in. To figure it out, temporarily remove the
    suspicious module from the library, and relink. The undefined symbol error then
    generated will indicate who is referencing that module.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is not always immediately obvious why you get a particular linker
    message, there is nothing magical about linkers. The mechanics are straightforward;
    it's the details you have to figure out in each case.
  prefs: []
  type: TYPE_NORMAL
- en: By [Walter Bright](http://creativecommons.org/licenses/by/3.0/us/)
  prefs: []
  type: TYPE_NORMAL
