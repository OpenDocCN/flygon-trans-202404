["```\nrotate : LazyList a -> List a -> LazyList a -> LazyList a\nrotate xs ys acc =\n  case (force xs, ys) of\n    (Nil        , y::[])  -> lazy (\\_ -> Cons y acc)\n    (Cons x xs' , y::ys') ->\n      lazy (\\_ -> Cons x (rotate xs' ys' (lazy (\\_ -> Cons y acc)))) \n```", "```\ntype Queue a = Q (LazyList a) (List a) (LazyList a) \n```", "```\nempty : Queue a\nempty = Q (lazy (\\_ -> Nil)) [] (lazy (\\_ -> Nil))\n\nisEmpty : Queue a -> Bool\nisEmpty (Q front _ _) = case force front of {Nil -> True; _ -> False}\n\npeek : Queue a -> Maybe a\npeek (Q front _ _) = maybeHead front \n```", "```\nenqueue : a -> Queue a -> Queue a\nenqueue x (Q front back sched) =\n  case force sched of\n    Cons _ sched' -> Q front (x::back) sched'\n    Nil ->\n      let front' = rotate front back (lazy (\\_ -> Nil)) in\n      Q front' [] front' \n```", "```\ndequeue : Queue a -> Maybe (Queue a)\ndequeue (Q front back sched) =\n  case force front of\n    Nil -> Nothing\n    Cons _ front' ->\n      case force sched of\n        Cons _ sched' -> Just (Q (tail front') back sched')\n        Nil ->\n          let front'' = rotate front' back (lazy (\\_ -> Nil)) in\n          Just (Q front'' [] front'') \n```", "```\nenqueue : a -> Queue a -> Queue a\nenqueue x (Q front back sched) = exec front (x::back) sched\n\ndequeue : Queue a -> Maybe (Queue a)\ndequeue (Q front back sched) =\n  case force front of\n    Nil       -> Nothing\n    Cons _ f' -> Just (exec f' back sched)\n\nexec front back sched =\n  case force sched of\n    Cons _ sched' -> Q front back sched'\n    Nil ->\n      let front' = rotate front back (lazy (\\_ -> Nil)) in\n      Q front' [] front' \n```"]