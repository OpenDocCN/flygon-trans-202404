- en: Hierarchical Structures - Little-t Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Overview of Little-t Trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s discuss some general properties of little-t trees. We''ve seen that
    structures like `(cons (list 1 2) (list 3 4))` can be represented in a tree-like
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e7d0a76598c2cb59ddc615967182a67b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Little-t trees are composed of *branches* and *leaves*. The tree above has
    five **branches**; they correspond to the lines on the diagram above. Notice that
    a branch can lead to a **subtree**â€”a tree that is contained within a larger tree.
    In this case, the branch `((1 2) 3 4)` contains the subtree `(1 2)`. A **leaf**
    has no branches connecting from it. The tree above has 4 leaves: `1`, `2`, `3`,
    and `4`. Leaves are found at the "bottom" of the tree, also called the **fringe**.'
  prefs: []
  type: TYPE_NORMAL
- en: Compared to trees in the real world, trees in computer science tend to be upside-down!
  prefs: []
  type: TYPE_NORMAL
- en: Recursion with Little-t Trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with trees, it is usually helpful to think recursively. As an example,
    let's write a function `count-leaves` that counts the number of leaves in a tree.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by informally outlining what our function will do in plain English.
    This is called writing **pseudocode**. After we understand how our `count-leaves`
    function should behave, we'll write the actual Racket code for it. This is good
    general technique for solving problems.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudocode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall how we defined `length`, which finds the number of elements in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` of an empty list is 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length` of a non-empty list `x` is 1 plus the `length` of the `cdr` of `x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The base case is the same for `count-leaves`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count-leaves` of an empty list is 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our recusive case is slightly different though. In `length`, we are guaranteed
    that the `car` of the list is a single element, so we count its length as 1. But
    for `count-leaves`, its `car` may contain one or more trees, and so its length
    will not always be 1. Therefore, we need to recursively find the `count-leaves`
    of the `car` of the tree as well! Our recursive call is therefore:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count-leaves` of a tree is the `count-leaves` of the `car` of the tree plus
    `count-leaves` of the `cdr` of the tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Eventually we will `car` ourselves to the leaf of the tree, and so our second
    base case will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count-leaves` of a leaf is `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pair?` Predicate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we call `car` on a tree, we have to determine if it returns another tree
    (a pair), or a leaf (a single element, technically known as an *atom*). How do
    we check for it? Racket has a built-in predicate `pair?` that tests if its argument
    is the result of a `cons`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(pair? (cons 1 2))` returns `#t`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(pair? (cons 1 (cons 2 3)))` returns `#t`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(pair? 2)` returns `#f`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(pair? ''pear)` returns `#f`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(pair? ''())` returns `#f`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using `pair?` and the pseudocode above, we can write the complete code for
    `count-leaves`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: `scale-tree`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Lesson 4, we saw the function `scale-list`, which multiplies each item in
    a list by a given numeric factor. We are going to write an analogous function,
    `scale-tree`, which accepts a deep list and a numeric factor and multiplies all
    elements in the deep list by that factor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: Below is an unfinished definition of scale-tree. Which base case(s) do we need
    to correctly define `scale-tree`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, try `scale-tree` out in your interpreter with some examples of your own!
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: `deep-reverse`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s work on a problem with a similar structure. This time, we want to write
    a function called `deep-reverse` that reverses the order of all elements in a
    deep list. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that not only do `(1 2)` and `(3 4)` switch places, but their elements
    do as well. `deep-reverse` should also work for lists that do not contain other
    lists inside of it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: Below is an unfinished definition of `deep-reverse`. Which recursive call(s)
    do we need in order to correctly define `deep-reverse`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Try this out in your Racket interpreter!
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Trees can contain subtrees, so recursion can be very helpful when solving problems
    involving trees.
  prefs: []
  type: TYPE_NORMAL
