- en: Hierarchical Structures - Little-t Trees
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Overview of Little-t Trees
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s discuss some general properties of little-t trees. We''ve seen that
    structures like `(cons (list 1 2) (list 3 4))` can be represented in a tree-like
    structure:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e7d0a76598c2cb59ddc615967182a67b.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: 'Little-t trees are composed of *branches* and *leaves*. The tree above has
    five **branches**; they correspond to the lines on the diagram above. Notice that
    a branch can lead to a **subtree**—a tree that is contained within a larger tree.
    In this case, the branch `((1 2) 3 4)` contains the subtree `(1 2)`. A **leaf**
    has no branches connecting from it. The tree above has 4 leaves: `1`, `2`, `3`,
    and `4`. Leaves are found at the "bottom" of the tree, also called the **fringe**.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Compared to trees in the real world, trees in computer science tend to be upside-down!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Recursion with Little-t Trees
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with trees, it is usually helpful to think recursively. As an example,
    let's write a function `count-leaves` that counts the number of leaves in a tree.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by informally outlining what our function will do in plain English.
    This is called writing **pseudocode**. After we understand how our `count-leaves`
    function should behave, we'll write the actual Racket code for it. This is good
    general technique for solving problems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Pseudocode
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall how we defined `length`, which finds the number of elements in a list:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '`length` of an empty list is 0.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length` of a non-empty list `x` is 1 plus the `length` of the `cdr` of `x`.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The base case is the same for `count-leaves`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '`count-leaves` of an empty list is 0.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our recusive case is slightly different though. In `length`, we are guaranteed
    that the `car` of the list is a single element, so we count its length as 1. But
    for `count-leaves`, its `car` may contain one or more trees, and so its length
    will not always be 1. Therefore, we need to recursively find the `count-leaves`
    of the `car` of the tree as well! Our recursive call is therefore:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '`count-leaves` of a tree is the `count-leaves` of the `car` of the tree plus
    `count-leaves` of the `cdr` of the tree.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Eventually we will `car` ourselves to the leaf of the tree, and so our second
    base case will be:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '`count-leaves` of a leaf is `1`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pair?` Predicate
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we call `car` on a tree, we have to determine if it returns another tree
    (a pair), or a leaf (a single element, technically known as an *atom*). How do
    we check for it? Racket has a built-in predicate `pair?` that tests if its argument
    is the result of a `cons`. For example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '`(pair? (cons 1 2))` returns `#t`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(pair? (cons 1 (cons 2 3)))` returns `#t`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(pair? 2)` returns `#f`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(pair? ''pear)` returns `#f`.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(pair? ''())` returns `#f`.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real Code
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using `pair?` and the pseudocode above, we can write the complete code for
    `count-leaves`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Example: `scale-tree`'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Lesson 4, we saw the function `scale-list`, which multiplies each item in
    a list by a given numeric factor. We are going to write an analogous function,
    `scale-tree`, which accepts a deep list and a numeric factor and multiplies all
    elements in the deep list by that factor.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4课中，我们看到了函数`scale-list`，它将列表中的每个项目乘以给定的数字因子。我们将编写一个类似的函数`scale-tree`，它接受一个深层列表和一个数字因子，并将深层列表中的所有元素乘以该因子。
- en: 'Here is an example call:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例调用：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Test Your Understanding**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**检验你的理解**'
- en: Below is an unfinished definition of scale-tree. Which base case(s) do we need
    to correctly define `scale-tree`?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`scale-tree`的未完成定义。我们需要哪些基本情况才能正确定义`scale-tree`？
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, try `scale-tree` out in your interpreter with some examples of your own!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用一些你自己的例子在解释器中尝试`scale-tree`！
- en: 'Example: `deep-reverse`'
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子：`deep-reverse`
- en: 'Let''s work on a problem with a similar structure. This time, we want to write
    a function called `deep-reverse` that reverses the order of all elements in a
    deep list. For example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决一个结构类似的问题。这一次，我们想要编写一个名为`deep-reverse`的函数，它将深层列表中所有元素的顺序颠倒。例如：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that not only do `(1 2)` and `(3 4)` switch places, but their elements
    do as well. `deep-reverse` should also work for lists that do not contain other
    lists inside of it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，不仅`(1 2)`和`(3 4)`交换位置，它们的元素也是如此。`deep-reverse`也应该适用于不包含其他列表的列表。
- en: '**Test Your Understanding**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**检验你的理解**'
- en: Below is an unfinished definition of `deep-reverse`. Which recursive call(s)
    do we need in order to correctly define `deep-reverse`?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`deep-reverse`的未完成定义。我们需要哪些递归调用才能正确定义`deep-reverse`？
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Try this out in your Racket interpreter!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Racket解释器中尝试一下！
- en: Takeaways
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Trees can contain subtrees, so recursion can be very helpful when solving problems
    involving trees.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 树可以包含子树，因此在解决涉及树的问题时，递归可能非常有帮助。
