- en: Tiny ES6 Notebook
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微型 ES6 笔记本
- en: 'From: [mattharrison/Tiny-es6-Notebook](https://github.com/mattharrison/Tiny-es6-Notebook)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 来自：[mattharrison/Tiny-es6-Notebook](https://github.com/mattharrison/Tiny-es6-Notebook)
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This is not so much an instructional manual, but rather notes, tables, and examples
    for ECMAScript2015 or ES6 syntax (aka modern JavaScript). It was created by the
    author as an additional resource during training, meant to be distributed as a
    physical notebook. Participants (who favor the physical characteristics of dead
    tree material) could add their own notes, thoughts, and have a valuable reference
    of curated examples.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本教学手册，而是 ECMAScript2015 或 ES6 语法（也称为现代 JavaScript）的注释、表格和示例。它是作者在培训期间的额外资源，旨在作为一本实体笔记��分发。喜欢纸质材料的参与者可以添加自己的注释、想法，并获得经过精心筛选的示例的宝贵参考。
- en: Strict Mode
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严格模式
- en: 'ES6 modules are always strict according to the spec. There should be no need
    to place this code at the top of your code to enable strict mode:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 模块根据规范始终是严格的。不需要将此代码放在代码顶部以启用严格模式：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Strict mode does the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式会执行以下操作：
- en: Requires explicit creation of global variables (via `let`)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要显式创建全局变量（通过 `let`）
- en: Throws exceptions when assigning to a non-writable variable
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向不可写变量赋值时会抛出异常
- en: Throws errors when deleting undeletable properties
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除不可删除属性时会抛出错误
- en: Throws `SyntaxError` if duplicating function parameter names
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果重复函数参数名称会抛出 `SyntaxError`
- en: Throws a `SyntaxError` when putting a `0` in front of a numeric literal (use
    `0o` for an octal)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数字文字前面放一个 `0` 会抛出 `SyntaxError`（使用 `0o` 表示八进制）
- en: Throws a `TypeError` when setting a property on a primitive.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在原始值上设置属性时会抛出 `TypeError`。
- en: Variables
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: 'There are various ways to declare a variable in ES6\. Function local variables
    are declared with `var`, block variables are declared with `let`, and constant
    variables are declared with `const`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中有各种声明变量的方式。函数局部变量使用 `var` 声明，块变量使用 `let` 声明，常量变量使用 `const` 声明：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Constant variables are not necessarily immutable (their value can change), but
    they can't be rebound to another object or primitive.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 常量变量不一定是不可变的（它们的值可以改变），但它们不能重新绑定到另一个对象或原始值。
- en: Tip
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: A good rule of thumb is to use `const` as the default declaration. Use `let`
    only if needed and try to stay away from `var`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的经验法则是将 `const` 作为默认声明。只在需要时使用 `let`，并尽量避免使用 `var`。
- en: Scoping
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作用域
- en: 'The following function illustrates scoping with the `let` declaration:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数说明了使用 `let` 声明的作用域：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 输出为：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we use a `var` declaration we see different behavior:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `var` 声明，我们会看到不同的行为：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 输出为：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Destructuring
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解构
- en: 'We can pull out variables from a list by *destructuring*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 *解构* 从列表中提取变量：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Default values can be provided during destructuring:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在解构过程中提供默认值：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Copy the list using the *spread* operator:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *spread* 运算符复制列表：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There is also the notion of object destructuring:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 还有对象解构的概念：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Default values can also be provided for object destructuring:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对象解构也可以提供默认值：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also rename the properties during object destrucruting:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在对象解构过程中重命名属性：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '...and we can combine renaming with default values:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '...我们可以将重命名与默认值结合：'
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Types
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型
- en: 'There are two types of data in ES6, primitives and objects. ES6 has six primitive,
    immutable data types: string, number, boolean, null, undefined, and symbol (new
    in ECMAScript 2015). When we use the literals we get a primitive. ES6 does *autoboxing*
    when we invoke a method on them. There are also object wrappers for string, number,
    boolean, and symbol. They are `String`, `Number`, `Boolean`, and `Symbol` respectively.
    If you call the constructor with `new`, you will get back on object, to get the
    primitive value call `.valueOf()`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中有两种数据类型，原始值和对象。ES6 有六种原始、不可变的数据类型：字符串、数字、布尔值、null、undefined 和 symbol（ECMAScript
    2015 中新增）。当我们使用文字时，我们得到一个原始值。当我们在它们上调用方法时，ES6 会进行 *自动装箱*。还有用于字符串、数字、布尔值和 symbol
    的对象包装器。它们分别是 `String`、`Number`、`Boolean` 和 `Symbol`。如果使用 `new` 调用构造函数，将得到一个对象，要获取原始值，请调用
    `.valueOf()`。
- en: '`null`'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`null`'
- en: A value that often represents a place where an object will be expected.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通常表示对象将被期望的地方的值。
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Even though `null` is a primitive, the result of `typeof` is an object. This
    is according to the spec [[1]](#id2) (though it is considered a wart).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `null` 是一个原始值，但 `typeof` 的结果是一个对象。这是根据规范[[1]](#id2)（尽管被认为是一个缺陷）。
- en: '| [[1]](#id1) | [http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator-runtime-semantics-evaluation](http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator-runtime-semantics-evaluation)
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| [[1]](#id1) | [http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator-runtime-semantics-evaluation](http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator-runtime-semantics-evaluation)
    |'
- en: '`undefined`'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`undefined`'
- en: 'A property of the global object whose value is the primitive value `undefined`.
    A variable that has been declared but not assigned has the value of `undefined`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个全局对象的属性，其值是原始值 `undefined`。已声明但未赋值的变量的值为 `undefined`：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `typeof` of an `undefined` value is the string `"undefined"`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`undefined` 的 `typeof` 是字符串 `"undefined"`：'
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Be careful of loose equality and strict equality comparisons with `null`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎使用与 `null` 的松散等式和严格等式比较：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Boolean
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔
- en: A boolean variable can have a value of `true` or `false`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔变量可以有值 `true` 或 `false`。
- en: 'We can coerce other values to booleans with the `Boolean` wrapper. Most values
    are truthy:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Boolean` 包装器将其他值强制转换为布尔值。大多数值都是真值：
- en: Truthy and Falsey values
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 真值和假值
- en: '| Truthy | Falsey |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 真值 | 假值 |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `true` | `false` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `true` | `false` |'
- en: '| Most objects | `null` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 大多数对象 | `null` |'
- en: '| `1` | `0` or `-0` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` 或 `-0` |'
- en: '| `"string"` | `""` (empty string) |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `"string"` | `""`（空字符串） |'
- en: '| `[]` (empty list) | `undefined` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `[]`（空列表） | `undefined` |'
- en: '| `{}` (empty object) |   |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `{}`（空对象） |   |'
- en: '| `Boolean(new Boolean(false))` |   |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `Boolean(new Boolean(false))` |   |'
- en: Note calling `new Boolean(obj)` (ie as a constructor) returns a `Boolean` object,
    whereas calling `Boolean(obj)` (as if it were a function) returns a primitive
    `true` or `false`. Also, note that coercing any object to a boolean coerces to
    `true`, even if the internal value was `false`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意调用 `new Boolean(obj)`（即作为构造函数）返回一个 `Boolean` 对象，而调用 `Boolean(obj)`（仿佛它是一个函数）返回一个原始的
    `true` 或 `false`。另外，请注意，将任何对象强制转换为布尔值都会强制转换为 `true`，即使内部值是 `false`。
- en: 'A common technique to get primitive boolean values is to use a *double negation*
    rather than using `Boolean`. This is not necessary in an `if` statement. But,
    if you want to create a variable that holds a boolean value (or return one), this
    trick can come in handy. The `!` (not operator) coerces the value to a negated
    boolean, so if we apply it again, we should get the correct boolean value:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 获取原始布尔值的常用技巧是使用*双重否定*而不是使用 `Boolean`。这在 `if` 语句中是不必要的。但是，如果你想要创建一个保存布尔值的变量（或者返回一个布尔值），这个技巧会很方便。`!`（非运算符）强制将值转换为否定的布尔值，因此如果我们再次应用它，我们应该得到正确的布尔值：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Boolean Properties
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔属性
- en: '| Property | Description |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Boolean.length` | `1` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `Boolean.length` | `1` |'
- en: '| `Boolean.prototype` | The `Boolean` prototype |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `Boolean.prototype` | `Boolean` 的原型 |'
- en: Boolean Prototype Methods
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔原型方法
- en: '| Method | Description |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `b.p.constructor()` | The `Boolean` object |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `b.p.constructor()` | `Boolean` 对象 |'
- en: '| `b.p.toString()` | String with value `"true"` or `"false"` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `b.p.toString()` | 值为 `"true"` 或 `"false"` 的字符串 |'
- en: '| `b.p.valueOf()` | Primitive boolean value |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `b.p.valueOf()` | 原始布尔值 |'
- en: Objects
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象
- en: 'ES6 adds the ability to have object keys created from variable names:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 添加了从变量名创建对象键的能力：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Array spread is an ES6 feature. Object spread is not, though many JS engines
    support it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 数组展开是 ES6 的一个特性。对象展开不是，尽管许多 JS 引擎支持它。
- en: 'If we want to include properties in another object, we can do a shallow *spread*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在另一个对象中包含属性，我们可以进行浅层*展开*：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In addition there is support for *computed property keys*:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另外还支持*计算属性键*：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There is also a shorthand for *method definition*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法定义* 还有一个简写形式：'
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Typically we would wrap these in a function to create the object:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们会将这些封装在一个函数中以创建对象：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can also define properties in an object:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在对象中定义属性：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`Object` can be called as a constructor (with `new`) and as a function. Both
    behave the same and wrap what they were called with with an object.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object` 可以被调用为构造函数（使用 `new`）和作为函数。两者的行为相同，并将其调用的内容包装在一个对象中。'
- en: Using the methods `Object.defineProperties` and `Object.defineProperty`, we
    can set properties using *data descriptors* or *accessor descriptors*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法 `Object.defineProperties` 和 `Object.defineProperty`，我们可以使用*数据描述符*或*访问器描述符*设置属性。
- en: 'An accessor descriptor allows us to create functions (`get` and `set`) to define
    member access. It looks like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器描述符允许我们创建函数（`get` 和 `set`）来定义成员访问。它看起来像这样：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A data descriptor allows us to create a value for a property and to set whether
    it is writeable. It looks like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 数据描述符允许我们为属性创建一个值，并设置它是否可写。它看起来像这样：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If `configurable` has the value of `false`, then no value besides `writeable`
    can be changed with `Object.defineProperty`. Also, the property cannot be deleted.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `configurable` 的值为 `false`，则除了 `writeable` 之外，不能使用 `Object.defineProperty`
    更改任何值。此外，属性不能被删除。
- en: The `enumerable` property determines if the property shows up in `Object.keys()`
    or a `for ... in` loop.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerable` 属性确定属性是否会出现在 `Object.keys()` 或 `for ... in` 循环中。'
- en: 'An example of a accessor descriptor:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个访问器描述符的示例：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These can be specified on classes as well:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也可以在类中指定：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The following tables list the properties of an object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了对象的属性。
- en: Object Properties
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对象属性
- en: '| Property | Description |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Object.prototype` | The objects prototype |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `Object.prototype` | 对象的原型 |'
- en: '| `Object.prototype.__proto__` | value: `null` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `Object.prototype.__proto__` | 值：`null` |'
- en: Object Methods
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对象方法
- en: '| Method | Description |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Object.assign(target, ...sources)` | Copy properties from `sources` into
    `target` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `Object.assign(target, ...sources)` | 将 `sources` 的属性复制到 `target` 中 |'
- en: '| `Object.create(obj, [prop])` | Create a new object with `prototype` of `obj`
    and properties from `prop` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `Object.create(obj, [prop])` | 创建一个具有 `obj` 的 `prototype` 和 `prop` 属性的新对象
    |'
- en: '| `Object.defineProperties( obj, prop)` | Update properties of `obj` from `prop`
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `Object.defineProperties( obj, prop)` | 从 `prop` 更新 `obj` 的属性 |'
- en: '| `Object.defineProperty( obj, name, desc)` | Create a property named `name`
    on `obj` with descriptor `desc` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `Object.defineProperty( obj, name, desc)` | 在 `obj` 上创建一个名为 `name` 的属性，具有描述符
    `desc` |'
- en: '| `Object.freeze(obj)` | Prevents future changes to properties (adding of removing)
    of `obj`. Strict mode throws errors, otherwise silent failure when trying to tweak
    properties later |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `Object.freeze(obj)` | 阻止对 `obj` 的属性（添加或删除）的未来更改。在严格模式���会抛出错误，否则在尝试稍后调整属性时会静默失败
    |'
- en: '| `Object.getOwnProperty Descriptor(obj, name)` | Get the descriptor for `name`
    on `obj`. Can''t be in prototype chain. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `Object.getOwnProperty Descriptor(obj, name)` | 获取 `obj` 上 `name` 的描述符。不能在原型链中。
    |'
- en: '| `Object.getOwnProperty Descriptors( obj)` | Enumerate descriptors on `obj`
    that aren''t in prototype chain. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `Object.getOwnProperty Descriptors( obj)` | 枚举在 `obj` 上不在原型链中的描述符 |'
- en: '| `Object.getOwnProperty Names(obj)` | Return array of string of string properties
    found on `obj` that aren''t in prototype chain |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `Object.getOwnProperty Names(obj)` | 返回在 `obj` 上找到的不在原型链中的字符串属性的字符串数组 |'
- en: '| `Object.getOwnProperty Symbols(obj)` | Return array of symbols of symbol
    properties found on `obj` that aren''t in prototype chain |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `Object.getOwnProperty Symbols(obj)` | 返回在 `obj` 上找到的不在原型链中的符号属性的符号数组 |'
- en: '| `Object.getPrototypeOf( obj)` | Return the prototype of `obj` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `Object.getPrototypeOf( obj)` | 返回 `obj` 的原型 |'
- en: '| `Object.is(a, b)` | Boolean whether the values are the same. Doesn''t coerce
    like `==`. Also, unlike `===`, doesn''t treat `-0` equal to `+0`, or `NaN` not
    equal to `NaN`. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `Object.is(a, b)` | 布尔值，判断两个值是否相同。不会像 `==` 那样强制转换。而且，不像 `===`，不会将 `-0` 视为等于
    `+0`，或者 `NaN` 不等于 `NaN`。 |'
- en: '| `Object.isExtensible(obj)` | Boolean whether the object can have properties
    added |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `Object.isExtensible(obj)` | 布尔值，判断对象是否可以添加属性 |'
- en: '| `Object.isFrozen(obj)` | Boolean whether the object is frozen (frozen is
    also sealed and non-extensible) |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `Object.isFrozen(obj)` | 布尔值，判断对象是否被冻结（冻结也是封闭的和不可扩展的） |'
- en: '| `Object.isSealed(obj)` | Boolean whether the object is sealed (non-extensible,
    non-removable, but potentially writeable) |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `Object.isSealed(obj)` | 布尔值，判断对象是否被封闭（不可扩展，不可移除，但可能可写） |'
- en: '| `Object.keys(obj)` | Enumerable properties given in `for ... in` loop that
    are not in prototype chain |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `Object.keys(obj)` | 在 `for ... in` 循环中给出的可枚举属性，不在原型链中 |'
- en: '| `Object.preventExtensions( obj)` | No new properties directly (can be added
    to prototype), but can remove them |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `Object.preventExtensions( obj)` | 不能直接添加新属性（可以添加到原型中），但可以删除它们 |'
- en: '| `Object.seal(obj)` | Prevent change of properties on an object. Note that
    the values can change. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `Object.seal(obj)` | 阻止对象属性的更改。请注意，值可以更改。 |'
- en: '| `Object.setPrototypeOf(obj, proto)` | Set the `prototype` property of an
    object |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `Object.setPrototypeOf(obj, proto)` | 设置对象的 `prototype` 属性 |'
- en: Object Prototype Methods
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对象原型方法
- en: '| Method | Description |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `o.p.constructor()` | The `Object` constructor |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `o.p.constructor()` | `Object` 构造函数 |'
- en: '| `o.p.hasOwnProperty(prop)` | Boolean whether `prop` is a direct property
    of `o` (not in prototype chain) |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `o.p.hasOwnProperty(prop)` | 布尔值，判断 `prop` 是否是 `o` 的直接属性（不在原型链中） |'
- en: '| `o.p.isPrototypeOf(obj)` | Boolean whether `o` exists in `obj`''s prototype
    chain |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `o.p.isPrototypeOf(obj)` | 布尔值，判断 `o` 是否存在于 `obj` 的原型链中 |'
- en: '| `o.p.propertyIs Enumerable(property)` | Boolean whether property is enumerable
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `o.p.propertyIs Enumerable(property)` | 属性是否可枚举的布尔值 |'
- en: '| `o.p.toLocaleString()` | A string representing the object in locale |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `o.p.toLocaleString()` | 代表对象的区域敏感字符串 |'
- en: '| `o.p.toString()` | A string representing the object |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `o.p.toString()` | 代表对象的字符串 |'
- en: '| `o.p.valueOf()` | Return primitive value |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `o.p.valueOf()` | 返回原始值 |'
- en: Numbers
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: '`NaN`'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`NaN`'
- en: '`NaN` is a global property to represent *not a number*. This is the result
    of certain math failures, such as the square root of a negative number. The function
    `isNaN` will test whether a value is `NaN`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaN`是一个全局属性，表示*不是一个数字*。这是某些数学运算失败的结果，比如负数的平方根。函数`isNaN`将测试一个值是否为`NaN`。'
- en: '`Infinity`'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Infinity`'
- en: '`Infinity` is a global property to represent a very large number. There is
    also `-Infinity` for for a very large negative values.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Infinity`是一个全局属性，表示一个非常大的数字。还有`-Infinity`表示非常大的负值。'
- en: You can specify whole number literals as integers, hex, octal, or binary numbers.
    There is also support for creating float values. See the number types table.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将整数文字指定为整数、十六进制、八进制或二进制数字。还支持创建浮点值。请参阅数字类型表。
- en: Number types
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 数字类型
- en: '| Type | Example |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 示例 |'
- en: '| --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Integer | `14` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | `14` |'
- en: '| Integer (Hex) | `0xe` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 整数（十六进制） | `0xe` |'
- en: '| Integer (Octal) | `0o16` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 整数（八进制） | `0o16` |'
- en: '| Integer (Binary) | `0b1110` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 整数（二进制） | `0b1110` |'
- en: '| Float | `14.0` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 浮点数 | `14.0` |'
- en: '| Float | `1.4e1` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 浮点数 | `1.4e1` |'
- en: Called as a constructor (`new Number(obj)`), will return a `Number` object.
    When called as a function (without `new`), it will perform a type conversion to
    the primitive.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 作为构造函数调用（`new Number(obj)`），将返回一个`Number`对象。当作为函数调用（不带`new`）时，将执行到原始类型的类型转换。
- en: Number Properties
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 数字属性
- en: '| Property | Description |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Number.EPSILON` | Smallest value between numbers `2.220446049250313e-16`
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `Number.EPSILON` | 数字之间的最小值`2.220446049250313e-16` |'
- en: '| `Number.MAX_SAFE_INTEGER` | Largest integer `9007199254740991` (`2^53 - 1`)
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `Number.MAX_SAFE_INTEGER` | 最大整数`9007199254740991` (`2^53 - 1`) |'
- en: '| `Number.MAX_VALUE` | Largest number `1.7976931348623157e+308` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `Number.MAX_VALUE` | 最大数字`1.7976931348623157e+308` |'
- en: '| `Number.MIN_SAFE_INTEGER` | Most negative integer `-9007199254740991` (`-(2^53
    - 1)`) |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `Number.MIN_SAFE_INTEGER` | 最小负整数`-9007199254740991` (`-(2^53 - 1)`) |'
- en: '| `Number.MIN_VALUE` | Smallest number `5e-324` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `Number.MIN_VALUE` | 最小数字`5e-324` |'
- en: '| `Number.NEGATIVE_INFINITY` | Negative overflow `-Infinity` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `Number.NEGATIVE_INFINITY` | 负溢出`-Infinity` |'
- en: '| `Number.NaN` | Not a number value `NaN` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `Number.NaN` | 非数字值`NaN` |'
- en: '| `Number.POSITIVE_INFINITY` | Positive overflow |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `Number.POSITIVE_INFINITY` | 正溢出 |'
- en: '| `Number.name` | value: `Number` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `Number.name` | 值：`Number` |'
- en: '| `Number.prototype` | Prototype for `Number` constructor |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `Number.prototype` | `Number`构造函数的原型 |'
- en: Number Methods
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 数字方法
- en: '| Method | Description |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `n.isFinite(val)` | Test if `val` is finite |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `n.isFinite(val)` | 测试`val`是否有限 |'
- en: '| `n.isInteger(val)` | Test if `val` is integer |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `n.isInteger(val)` | 测试`val`是否为整数 |'
- en: '| `n.isNaN(val)` | Test if `val` is `NaN` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `n.isNaN(val)` | 测试`val`是否为`NaN` |'
- en: '| `n.isSafeInteger(val)` | Test if `val` is integer between safe values |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `n.isSafeInteger(val)` | 测试`val`是否在安全值之间的整数 |'
- en: '| `n.parseFloat(s)` | Convert string, `s` to number (or `NaN`) |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `n.parseFloat(s)` | 将字符串`s`转换为数字（或`NaN`） |'
- en: '| `n.parseInt(s, [radix])` | Convert string, `s` to integer (or `NaN`) for
    given base (`radix`) |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `n.parseInt(s, [radix])` | 将字符串`s`转换为给定基数（`radix`）的整数（或`NaN`） |'
- en: Number Prototype Methods
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 数字原型方法
- en: '| Method | Description |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `n.p.constructor()` |   |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `n.p.constructor()` |   |'
- en: '| `n.p.toExponential( [numDigits])` | Return a string in exponential notation
    with `numDigits` of precision |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `n.p.toExponential( [numDigits])` | 以`numDigits`精度返回指数表示的字符串 |'
- en: '| `n.p.toFixed([digits])` | Return a string in fixed-point notation with `digits`
    of precision |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `n.p.toFixed([digits])` | 以`digits`精度返回固定点表示的字符串 |'
- en: '| `n.p.toLocaleString([locales, [options]])` | Return a string representation
    in locale sensitive notation |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `n.p.toLocaleString([locales, [options]])` | 以区域敏感的表示返回字符串 |'
- en: '| `n.p.toPrecision([numDigits])` | Return a string in fixed-point or exponential
    notation with `numDigits` of precision |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `n.p.toPrecision([numDigits])` | 以`numDigits`精度返回固定点或指数表示的字符串 |'
- en: '| `n.p.toString([radix])` | Return a string representation. `radix` can be
    between `2` and `36` for indicating the base |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `n.p.toString([radix])` | 返回字符串表示。`radix`可以在`2`和`36`之间表示基数 |'
- en: '| `n.p.valueOf()` | Return the primitive value of the number |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `n.p.valueOf()` | 返回数字的原始值 |'
- en: '`Math` Library'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Math`库'
- en: ES6 has a built-in math library to perform common operations.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ES6具有内置的数学库来执行常见操作。
- en: Math Properties
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 数学属性
- en: '| Property | Description |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Math.E` | value: `2.718281828459045` |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `Math.E` | 值为 `2.718281828459045` |'
- en: '| `Math.LN10` | value: `2.302585092994046` |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `Math.LN10` | 值为 `2.302585092994046` |'
- en: '| `Math.LN2` | value: `0.6931471805599453` |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `Math.LN2` | 值为 `0.6931471805599453` |'
- en: '| `Math.LOG10E` | value: `0.4342944819032518` |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `Math.LOG10E` | 值为 `0.4342944819032518` |'
- en: '| `Math.LOG2E` | value: `1.4426950408889634` |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `Math.LOG2E` | 值为 `1.4426950408889634` |'
- en: '| `Math.PI` | value: `3.141592653589793` |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `Math.PI` | 值为 `3.141592653589793` |'
- en: '| `Math.SQRT1_2` | value: `0.7071067811865476` |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `Math.SQRT1_2` | 值为 `0.7071067811865476` |'
- en: '| `Math.SQRT2` | value: `1.4142135623730951` |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `Math.SQRT2` | 值为 `1.4142135623730951` |'
- en: Math Methods
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 数学方法
- en: '| Method | Description |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Math.abs(n)` | Compute absolute value |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `Math.abs(n)` | 计算绝对值 |'
- en: '| `Math.acos(n)` | Compute arccosine |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `Math.acos(n)` | 计算反余弦 |'
- en: '| `Math.acosh(n)` | Compute hyperbolic arccosine |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `Math.acosh(n)` | 计算反双曲余弦 |'
- en: '| `Math.asin(n)` | Compute arcsine |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `Math.asin(n)` | 计算反正弦 |'
- en: '| `Math.asinh(n)` | Compute hyperbolic arcsine |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `Math.asinh(n)` | 计算反双曲正弦 |'
- en: '| `Math.atan(n)` | Compute arctangent |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `Math.atan(n)` | 计算反正切 |'
- en: '| `Math.atan2(y, x)` | Compute arctangent of quotient |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `Math.atan2(y, x)` | 计算商的反正切 |'
- en: '| `Math.atanh(n)` | Compute hyperbolic arctangent |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `Math.atanh(n)` | 计算反双曲正切 |'
- en: '| `Math.cbrt(n)` | Compute cube root |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `Math.cbrt(n)` | 计算立方根 |'
- en: '| `Math.ceil(n)` | Compute the smallest integer larger than `n` |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `Math.ceil(n)` | 计算大于 `n` 的最小整数 |'
- en: '| `Math.clz32(n)` | Compute count of leading zeros |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `Math.clz32(n)` | 计算前导零的计数 |'
- en: '| `Math.cos(n)` | Compute cosine |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `Math.cos(n)` | 计算余弦 |'
- en: '| `Math.cosh(n)` | Compute hyperbolic cosine |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `Math.cosh(n)` | 计算双曲余弦 |'
- en: '| `Math.exp(x)` | Compute e to the x |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `Math.exp(x)` | 计算 e 的 x 次方 |'
- en: '| `Math.expm1(x)` | Compute e to the x minux 1 |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `Math.expm1(x)` | 计算 e 的 x 次方减 1 |'
- en: '| `Math.floor(n)` | Compute largest integer smaller than `n` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `Math.floor(n)` | 计算小于 `n` 的最大整数 |'
- en: '| `Math.fround(n)` | Compute nearest float |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `Math.fround(n)` | 计算最接近的浮点数 |'
- en: '| `Math.hypot(x, [y], [...)` | Compute hypotenuse (square root of sums) |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `Math.hypot(x, [y], [...)` | 计算斜边（和的平方根） |'
- en: '| `Math.imul(x, y)` | Compute integer product |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `Math.imul(x, y)` | 计算整数乘积 |'
- en: '| `Math.log(n)` | Compute natural log |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `Math.log(n)` | 计算自然对数 |'
- en: '| `Math.log10(n)` | Compute log base 10 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `Math.log10(n)` | 计算以 10 为底的对数 |'
- en: '| `Math.log1p(n)` | Compute natural log of 1 + `n` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `Math.log1p(n)` | 计算 1 + `n` 的自然对数 |'
- en: '| `Math.log2(n)` | Compute log base 2 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `Math.log2(n)` | 计算以 2 为底的对数 |'
- en: '| `Math.max(...)` | Compute maximum |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `Math.max(...)` | 计算最大值 |'
- en: '| `Math.min(...)` | Compute minimum |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `Math.min(...)` | 计算最小值 |'
- en: '| `Math.pow(x, y)` | Compute x to the y power |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `Math.pow(x, y)` | 计算 x 的 y 次方 |'
- en: '| `Math.random()` | Random number between 0 and 1 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `Math.random()` | 0 到 1 之间的随机数 |'
- en: '| `Math.round(n)` | Compute nearest integer |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `Math.round(n)` | 计算最接近的整数 |'
- en: '| `Math.sign(n)` | Return `-1`, `0`, or `1` for negative, zero, or positive
    value of `n` |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `Math.sign(n)` | 对于 `n` 的负值，零值或正值，返回 `-1`，`0` 或 `1` |'
- en: '| `Math.sin(n)` | Compute sine |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `Math.sin(n)` | 计算正弦 |'
- en: '| `Math.sinh(n)` | Compute hyperbolic sine |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `Math.sinh(n)` | 计算双曲正弦 |'
- en: '| `Math.sqrt(n)` | Compute square root |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `Math.sqrt(n)` | 计算平方根 |'
- en: '| `Math.tan(n)` | Compute tangent |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `Math.tan(n)` | 计算正切 |'
- en: '| `Math.tanh(n)` | Compute hyperbolic tangent |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `Math.tanh(n)` | 计算双曲正切 |'
- en: '| `Math.trunc(b)` | Compute integer value without decimal |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `Math.trunc(b)` | 计算没有小数的整数值 |'
- en: Built-in Types
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置类型
- en: Strings
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: 'ES6 strings are series of UTF-16 code units. A string literal can be created
    with single or double quotes:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 字符串是一系列 UTF-16 代码单元。可以用单引号或双引号创建字符串字面量：
- en: '[PRE28]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To make long strings you can use to backslash to signify that the string continues
    on the following line:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要制作长字符串，您可以使用反斜杠表示字符串在以下行继续：
- en: '[PRE29]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Alternatively the `+` operator allows for string concatenation:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 或者 `+` 运算符允许字符串连接：
- en: '[PRE30]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Template Literals
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板字面量
- en: 'Using backticks, you can create *template literals*. These allow for interpolation:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反引号，您可以创建 *模板字面量*。这允许插值：
- en: '[PRE31]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that template literals can be multi-line:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，模板字面量可以是多行的：
- en: '[PRE32]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Raw Strings
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始字符串
- en: 'If you need strings with backslashes in them, you can escape the backslash
    with a backslash (`/`) or you can use *raw* strings:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要带有反斜杠的字符串，您可以用反斜杠 (`/`) 转义反斜杠，或者您可以使用 *原始* 字符串：
- en: '[PRE33]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Methods
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: String Properties
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串属性
- en: '| Property | Description |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `String.length` | value: `1` |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `String.length` | 值为 `1` |'
- en: '| `String.name` | value: `String` |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `String.name` | 值为 `String` |'
- en: '| `String.prototype` | Prototype for `String` constructor |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `String.prototype` | `String` 构造函数的原型 |'
- en: Static String Methods
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 静态字符串方法
- en: '| Method | Description |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `String.fromCharCode(n1, ...)` | Return string containing characters from
    Unicode values `n1` |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `String.fromCharCode(n1, ...)` | 返回包含Unicode值`n1`的字符的字符串 |'
- en: '| `String.fromCodePoint(n1, ...)` | Return string containing characters from
    Unicode points `n1` |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `String.fromCodePoint(n1, ...)` | 返回包含Unicode点`n1`的字符的字符串 |'
- en: '| `String.raw` | Create a raw template literal (follow this by your string
    surrounded by back ticks) |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `String.raw` | 创建原始模板文字（在反引号包围的字符串后跟随此） |'
- en: String Prototype Methods
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串原型方法
- en: '| Method | Description |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `s.p.anchor(aName)` | Return `<a name="aName">s</a>` |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.anchor(aName)` | 返回`<a name="aName">s</a>` |'
- en: '| `s.p.big()` | Return `<big>s</big>` |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.big()` | 返回`<big>s</big>` |'
- en: '| `s.p.blink()` | Return `<blink>s</blink>` |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.blink()` | 返回`<blink>s</blink>` |'
- en: '| `s.p.bold()` | Return `<b>s</b>` |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.bold()` | 返回`<b>s</b>` |'
- en: '| `s.p.charAt(idx)` | Return string with character at `idx`. Empty string if
    invalid index |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.charAt(idx)` | 返回在`idx`处的字符的字符串。如果索引无效则返回空字符串 |'
- en: '| `s.p.charCodeAt(idx)` | Return integer between 0 and 65535 for the UTF-16
    code. `NaN` if invalid index |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.charCodeAt(idx)` | 返回UTF-16代码的0到65535之间的整数。如果索引无效则返回`NaN` |'
- en: '| `s.p.codePointAt(idx)` | Return integer value for Unicode code point. `undefined`
    if invalid index |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.codePointAt(idx)` | 返回Unicode代码点的整数值。如果索引无效则返回`undefined` |'
- en: '| `s.p.concat(s1, ...)` | Return concatenation of strings |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.concat(s1, ...)` | 返回字符串的连接 |'
- en: '| `s.p.constructor()` | String constructor |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.constructor()` | 字符串构造函数 |'
- en: '| `s.p.endsWith(sub, [length])` | Boolean if `s` (limited to `length` size)
    ends with `sub` |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.endsWith(sub, [length])` | 如果`s`（限制为`length`大小）以`sub`结尾则返回布尔值 |'
- en: '| `s.p.fixed()` | Return `<tt>s</tt>` |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.fixed()` | 返回`<tt>s</tt>` |'
- en: '| `s.p.fontcolor(c)` | Return `<font color="c">s</font>` |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.fontcolor(c)` | 返回`<font color="c">s</font>` |'
- en: '| `s.p.fontsize(num)` | Return `<font size="num">s</font>` |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.fontsize(num)` | 返回`<font size="num">s</font>` |'
- en: '| `s.p.includes(sub, [start])` | Boolean if `sub` found in `s` from `start`
    |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.includes(sub, [start])` | 如果从`start`找到`sub`在`s`中则返回布尔值 |'
- en: '| `s.p.indexOf(sub, [start])` | Index of `sub` in `s` starting from `start`.
    `-1` if not found |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.indexOf(sub, [start])` | `sub`在从`start`开始的`s`中的索引。如果未找到则返回`-1` |'
- en: '| `s.p.italics()` | Return `<i>s</i>` |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.italics()` | 返回`<i>s</i>` |'
- en: '| `s.p.lastIndexOf(sub, start)` | Return index of `sub` starting from rightmost
    `start` characters (default `+Infinity`). `-1` if not found |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.lastIndexOf(sub, start)` | 返回从最右边的`start`字符开始的`sub`的索引（默认`+Infinity`）。如果未找到则返回`-1`
    |'
- en: '| `s.p.link(url)` | Return `<a href="url">s</a>` |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.link(url)` | 返回`<a href="url">s</a>` |'
- en: '| `s.p.localeCompare( other, [locale, [option])` | Return `-1`, `0`, or `1`
    `s` comes before `other`, is equal to, or after |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.localeCompare( other, [locale, [option])` | 返回`-1`，`0`或`1`，`s`在`other`之前，相等或之后
    |'
- en: '| `s.p.match(reg)` | Return an array with the whole match in index 0, remaining
    entries correspond to parentheses |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.match(reg)` | 返回一个数组，整个匹配在索引0中，其余条目对应括号 |'
- en: '| `s.p.normalize([unf])` | Return the Unicode Normalization Form of a string.
    `unf` can be `"NFC"`, `"NFD"`, `"NFKC"`, or `"NFKD"` |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.normalize([unf])` | 返回字符串的Unicode标准化形式。`unf`可以是`"NFC"`，`"NFD"`，`"NFKC"`或`"NFKD"`
    |'
- en: '| `s.p.repeat(num)` | Return `s` concatenated with itself `num` times |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.repeat(num)` | 返回`num`次连接的`s` |'
- en: '| `s.p.replace(this, that)` | Return a new string with replacing `this` with
    `that`. `this` can be a regular expression or a string. `that` can be a string
    or a function that takes `match`, a parameter for every parenthesized match, an
    index offset for the match, and the original string. It returns a new value. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.replace(this, that)` | 返回一个新字符串，用`that`替换`this`。`this`可以是正则表达式或字符串。`that`可以是一个字符串或一个函数，该函数接受`match`，每个括号匹配的参数，匹配的索引偏移和原始字符串。它返回一个新值。
    |'
- en: '| `s.p.search(reg)` | Return the index where the regular expression first matches
    `s` or `-1` |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.search(reg)` | 返回正则表达式首次匹配`s`的索引或`-1` |'
- en: '| `s.p.slice(start, [end])` | Return string sliced at half open interval including
    `start` and up to be not including `end`. Negative values mean `s.length - val`
    |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.slice(start, [end])` | 返回在半开区间切片的字符串，包括`start`并且不包括`end`。负值意味着`s.length
    - val` |'
- en: '| `s.p.small()` | Return `<small>s</small>` |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.small()` | 返回`<small>s</small>` |'
- en: '| `s.p.split([sep, [limit]])` | Return array with string broken into substrings
    around `sep`. `sep` may be a regular expression. `limit` determines the number
    of splits in the result. If the regular expression contains parentheses, then
    the matched portions are also included in the result. Use `s.join` to undo |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.split([sep, [limit]])` | 返回一个由字符串围绕`sep`分割的子字符串数组。`sep`可以是正则表达式。`limit`确定结果中的分割数。如果正则表达式包含括号，则匹配的部分也包含在结果中。使用`s.join`来撤销
    |'
- en: '| `s.p.startsWith(sub, [pos])` | Boolean if `s` (beginning at `pos` index)
    starts with `sub` |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.startsWith(sub, [pos])` | 如果`s`（从`pos`索引开始）以`sub`开头则返回布尔值 |'
- en: '| `s.p.strike()` | Return `<string>s</strike>` |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.strike()` | 返回`<string>s</strike>` |'
- en: '| `s.p.sub()` | Return `<sub>s</sub>` |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.sub()` | 返回`<sub>s</sub>` |'
- en: '| `s.p.substr(pos, [length])` | Return substring starting at `pos` index (can
    be negative). `length` is the number of characters to include. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.substr(pos, [length])` | 返回从`pos`索引开始的子字符串（可以为负）。`length`是要包括的字符数。 |'
- en: '| `s.p.substring(start, [end])` | Return slice of string including `start`
    going up to be not including `end` (half-open). Negative values not allowed. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.substring(start, [end])` | 返回包括`start`在内但不包括`end`的字符串切片（半开放）。不允许负值。
    |'
- en: '| `s.p.sup()` | Return `<sup>s</sup>` |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.sup()` | 返回`<sup>s</sup>` |'
- en: '| `s.p.toLocaleLowerCase()` | Return lower case value according to local |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.toLocaleLowerCase()` | 根据本地返回小写值 |'
- en: '| `s.p.toLocaleUpperCase()` | Return upper case value according to local |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.toLocaleUpperCase()` | 根据本地返回大写值 |'
- en: '| `s.p.toLowerCase()` | Return lower case value |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.toLowerCase()` | 返回小写值 |'
- en: '| `s.p.toString()` | Return string representation |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.toString()` | 返回字符串表示 |'
- en: '| `s.p.toUpperCase()` | Return upper case value |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.toUpperCase()` | 返回大写值 |'
- en: '| `s.p.trim()` | Return string with leading and trailing whitespace removed
    |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.trim()` | 返回删除前导和尾随空格的字符串 |'
- en: '| `s.p.trimLeft()` | Return string with leading whitespace removed |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.trimLeft()` | 返回删除前导空格的字符串 |'
- en: '| `s.p.trimRight()` | Return string with trailing whitespace removed |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.trimRight()` | 返回删除尾随空格的字符串 |'
- en: '| `s.p.valueOf()` | Return primitive value of string representation |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.valueOf()` | 返回字符串表示的原始值 |'
- en: '| `s.p[@@iterator]()` | Return an iterator for the string. Calling `.next()`
    on the iterator returns code points |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `s.p[@@iterator]()` | 返回字符串的迭代器。在迭代器上调用`.next()`会返回代码点 |'
- en: Note
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Many of the HTML generating methods create markup that is not compatible with
    HTML5.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 许多生成 HTML 的方法创建的标记与 HTML5 不兼容。
- en: Arrays
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: 'ES6 arrays can be created with the literal syntax or by calling the `Array`
    constructor:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 数组可以使用文字语法创建，也可以通过调用`Array`构造函数创建：
- en: '[PRE34]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Arrays need not be dense:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 数组不需要是密集的：
- en: '[PRE35]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `includes` method is useful for checking membership on arrays:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`includes` 方法对于检查数组成员资格很有用：'
- en: '[PRE36]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we need the index number during iteration, the `entries` method gives us
    a list of index, item pairs:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在迭代过程中需要索引号，则`entries`方法会给我们一个索引、项目对的列表：
- en: '[PRE37]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can do index operations on arrays:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在数组上进行索引操作：
- en: '[PRE38]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Note that index operations do not support negative index values:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 注意索引操作不支持负索引值：
- en: '[PRE39]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In ES6 we can subclass `Array`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中我们可以对`Array`进行子类化：
- en: '[PRE40]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can *slice* arrays using the `slice` method. Note that the slice returns
    an array, even if it has a single item. Note that the `slice` method can take
    negative indices:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`slice`方法*切片*数组。请注意，即使只有一个项目，切片也会返回一个数组。请注意，`slice`方法可以接受负索引：
- en: '[PRE41]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Array Properties
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 数组属性
- en: '| Property | Description |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Array.length` | value: `1` |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `Array.length` | 值：`1` |'
- en: '| `Array.name` | value: `Array` |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `Array.name` | 值：`Array` |'
- en: '| `Array.prototype` | Prototype for `Array` constructor |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `Array.prototype` | `Array`构造函数的原型 |'
- en: Array Methods
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 数组方法
- en: '| Method | Description |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Array.from(iter, [func, [this]])` | Return a new `Array` from an iterable.
    `func` will be called on every item. `this` is a value to use for `this` when
    executing `func`. |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `Array.from(iter, [func, [this]])` | 从可迭代对象返回一个新的`Array`。对每个项目调用`func`。在执行`func`时使用`this`的值。
    |'
- en: '| `Array.isArray(item)` | Return boolean if `item` is an `Array` |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `Array.isArray(item)` | 如果`item`是`Array`则返回布尔值 |'
- en: '| `Array.of(val, [..., valN])` | Return `Array` with values. Integer values
    are inserted, whereas `Array(3)`, creates an `Array` with three slots. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `Array.of(val, [..., valN])` | 返回带有值的`Array`。整数值被插入，而`Array(3)`创建一个具有三个插槽的`Array`。
    |'
- en: Array Prototype Methods
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 数组原型方法
- en: '| Method | Description |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `a.p.concat(val, [..., valN])` | Return a new `Array`, with values inserted.
    If value is array, the items are appended |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.concat(val, [..., valN])` | 返回一个新的`Array`，插入值。如果值是数组，则追加项目 |'
- en: '| `a.p.copyWithin(target, [start, [end]])` | Return `a` mutated with items
    from `start` to `end` shallow copied into index `target` |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.copyWithin(target, [start, [end]])` | 返回经过变异的`a`，从`start`到`end`的项目浅复制到索引`target`中
    |'
- en: '| `a.p.entries()` | Return array iterator |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.entries()` | 返回数组迭代器 |'
- en: '| `a.p.every(func, [this])` | Return boolean if `func(item, [idx, [a]])` is
    true for every item in array (`idx` is the index, and `a` is the array). `this`
    is the value of `this` for the function |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.every(func, [this])` | 返回一个布尔值，如果对数组中的每个项目调用`func(item, [idx, [a]])`都为真（`idx`是索引，`a`是数组）。`this`是函数的`this`值
    |'
- en: '| `a.p.fill(val, [start, [end]])` | Return `a` mutated, with `val` inserted
    from `start` index up to but not including `end` index. Index values may be negative
    |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.fill(val, [start, [end]])` | 返回经过变异的`a`，从`start`索引开始插入`val`，直到但不包括`end`索引。索引值可以为负数
    |'
- en: '| `a.p.filter(func, [this])` | Return a new array of items from `a` where predicate
    `func(item, [idx, [a]])` is true. `this` is the value of `this` for the function
    |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.filter(func, [this])` | 返回一个新数组，其中包含谓词`func(item, [idx, [a]])`为真的项目。`this`是函数的`this`值
    |'
- en: '| `a.p.find(func, [this])` | Return first item (or `undefined`) from `a` where
    predicate `func(item, [idx, [a]])` is true. `this` is the value of `this` for
    the function |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.find(func, [this])` | 返回数组中谓词`func(item, [idx, [a]])`为真的第一个项目（或`undefined`）。`this`是函数的`this`值
    |'
- en: '| `a.p.findIndex(func, [this])` | Return first index (or `-1`) from `a` where
    predicate `func(item, [idx, [a]])` is true. `this` is the value of `this` for
    the function |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.findIndex(func, [this])` | 返回数组中谓词`func(item, [idx, [a]])`为真的第一个索引（或`-1`）。`this`是函数的`this`值
    |'
- en: '| `a.p.forEach(func, [this])` | Return `undefined`. Apply `func(item, [idx,
    [a]])` to every item of `a`. `this` is the value of `this` for the function |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.forEach(func, [this])` | 返回`undefined`。对`a`的每个项目应用`func(item, [idx,
    [a]])`。`this`是函数的`this`值 |'
- en: '| `a.p.includes(val, [start])` | Return a boolean if `a` contains `val` starting
    from `start` index |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.includes(val, [start])` | 返回一个布尔值，如果从`start`索引开始，`a`包含`val` |'
- en: '| `a.p.indexOf(val, [start])` | Return first index (or `-1`) of `val` in `a`,
    starting from `start` index |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.indexOf(val, [start])` | 返回`a`中`val`的第一个索引（或`-1`），从`start`索引开始 |'
- en: '| `a.p.join([sep])` | Return string with `sep` (default `'',''`) inserted between
    items |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.join([sep])` | 返回带有`sep`（默认为`,`）插入的字符串 |'
- en: '| `a.p.keys()` | Return iterator of index values (doesn''t skip sparse values)
    |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.keys()` | 返回索引值的迭代器（不跳过稀疏值） |'
- en: '| `a.p.lastIndexOf(val, [start])` | Return last index (or `-1`) of `val` in
    `a`, searching backwards from `start` index |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.lastIndexOf(val, [start])` | 返回`a`中`val`的最后一个索引（或`-1`），从`start`索引开始向后搜索
    |'
- en: '| `a.p.map(func, [this])` | Return new array with `func(item, [idx, [a]])`
    called on every item of `a`. `this` is the value of `this` for the function |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.map(func, [this])` | 返回一个新数组，其中对`a`的每个项目调用`func(item, [idx, [a]])`。`this`是函数的`this`值
    |'
- en: '| `a.p.pop()` | Return last item (or `undefined`) of `a` (mutates `a`) |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.pop()` | 返回`a`的最后一个项目（或`undefined`）（改变`a`） |'
- en: '| `a.p.push(val, [..., valN])` | Return new length of `a`. Add values to end
    of `a` |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.push(val, [..., valN])` | 返回`a`的新长度。将值添加到`a`的末尾 |'
- en: '| `a.p.reduce(func, [init])` | Return results of reduction. Call `func(accumulator,
    val, idx, a)` for every item. If `init` is provided, `accumulator` is set to it
    initially, otherwise `accumulator` is first item of `a`. |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.reduce(func, [init])` | 返回归约的结果。对每个项目调用`func(accumulator, val, idx,
    a)`。如果提供了`init`，则初始时将`accumulator`设置为它，否则`accumulator`是`a`的第一个项目。 |'
- en: '| `a.p.reduceRight(func, [init])` | Return results of reduction applied backwards
    |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.reduceRight(func, [init])` | 返回应用反向的归约的结果 |'
- en: '| `a.p.reverse()` | Return and mutate `a` in reverse order |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.reverse()` | 返回并改变`a`的顺序为倒序 |'
- en: '| `a.p.shift()` | Return and remove first item from `a` (mutates `a`) |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.shift()` | 返回并移除`a`的第一个项目（改变`a`） |'
- en: '| `a.p.slice([start, [end]])` | Return shallow copy of `a` from `start` up
    to but not including `end`. Negative index values allowed |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.slice([start, [end]])` | 返回从`start`到但不包括`end`的`a`的浅拷贝。允许负索引值 |'
- en: '| `a.p.some(func, [this])` | Return boolean if `func(item, [idx, [a]])` is
    true for any item in array (`idx` is the index, and `a` is the array). `this`
    is the value of `this` for the function |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.some(func, [this])` | 返回一个布尔值，如果对数组中的任何项目调用`func(item, [idx, [a]])`都为真（`idx`是索引，`a`是数组）。`this`是函数的`this`值
    |'
- en: '| `a.p.sort([func])` | Return and mutate sorted `a`. Can use `func(a, b)` which
    returns `-1`, `0`, or `1` |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.sort([func])` | 返回并改变排序后的 `a`。可以使用 `func(a, b)`，返回 `-1`，`0` 或 `1` |'
- en: '| `a.p.splice(start, [deleteCount, [item1, ..., itemN]])` | Return array with
    deleted objects. Mutate `a` at index `start`, remove `deleteCount` items, and
    insert `items`. |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.splice(start, [deleteCount, [item1, ..., itemN]])` | 返回删除对象的数组。在索引 `start`
    处改变 `a`，删除 `deleteCount` 个项目，并插入 `items`。 |'
- en: '| `a.p.toLocaleString( [locales, [options]])` | Return a string representing
    array in locales |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.toLocaleString( [locales, [options]])` | 返回表示区域设置中数组的字符串 |'
- en: '| `a.p.toString()` | Return a string representing array in locales |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.toString()` | 返回表示区域设置中数组的字符串 |'
- en: '| `a.p.unshift([item1, ... itemN])` | Return length of `a`. Mutate `a` by inserting
    elements in front of `a`. (Will be in same order as appearing in call) |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.unshift([item1, ... itemN])` | 返回 `a` 的长度。通过在 `a` 前面插入元素来改变 `a`。（将按照调用时出现的顺序）
    |'
- en: '| `a.p.values()` | Return iterator with items in `a` |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.values()` | 返回具有 `a` 中项目的迭代器 |'
- en: ArrayBuffers
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组缓冲区
- en: 'An `ArrayBuffer` holds generic byte based data. To manipulate the contents,
    we point a view (typed arrays or data views) at certain locations:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayBuffer` 包含通用的基于字节的数据。为了操作内容，我们将视图（类型化数组或数据视图）指向特定位置：'
- en: '[PRE42]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ArrayBuffer Properties
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayBuffer 属性
- en: '| Property | Description |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ArrayBuffer.length` | `1` |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `ArrayBuffer.length` | `1` |'
- en: '| `ArrayBuffer.prototype` | The `ArrayBuffer` prototype |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `ArrayBuffer.prototype` | `ArrayBuffer` 原型 |'
- en: ArrayBuffer Prototype Methods
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayBuffer 原型方法
- en: '| Method | Description |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `a.p.constructor()` | The `ArrayBuffer` object |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.constructor()` | `ArrayBuffer` 对象 |'
- en: '| `a.p.slice(begin, [end])` | Return a new `ArrayBuffer` with copy of `a` from
    `begin` up to but not including `n` |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `a.p.slice(begin, [end])` | 返回从 `begin` 到 `n` 之前的 `a` 的副本的新 `ArrayBuffer`
    |'
- en: TypedArrays
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型化数组
- en: 'ES6 supports various flavors of *typed arrays*. These hold binary data, rather
    than ES6 objects:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 支持各种类型的 *类型化数组*。这些数组保存的是二进制数据，而不是 ES6 对象：
- en: '[PRE43]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'There are a few differences from normal arrays:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通数组有一些不同：
- en: Items have the same type
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目具有相同的类型
- en: The array is contiguous
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组是连续的
- en: It is initialized with zeros
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被初始化为零
- en: 'To put a typed array into a normal array, we can use the *spread* operator:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 要将类型化数组放入普通数组中，我们可以使用 *spread* 运算符：
- en: '[PRE44]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Typed Arrays
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 类型化数组
- en: '| Type | Size (bytes) | Desctription | C type |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 大小（字节） | 描述 | C 类型 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `Int8Array` | 1 | signed integer | `int8_t` |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| `Int8Array` | 1 | 有符号整数 | `int8_t` |'
- en: '| `Uint8Array` | 1 | unsigned integer | `uint8_t` |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| `Uint8Array` | 1 | 无符号整数 | `uint8_t` |'
- en: '| `Uint8ClampedArray` | 1 | unsigned integer | `uint8_t` |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| `Uint8ClampedArray` | 1 | 无符号整数 | `uint8_t` |'
- en: '| `Int16Array` | 2 | signed integer | `int16_t` |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| `Int16Array` | 2 | 有符号整数 | `int16_t` |'
- en: '| `Uint16Array` | 2 | unsigned integer | `unint16_t` |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| `Uint16Array` | 2 | 无符号整数 | `unint16_t` |'
- en: '| `Int32Array` | 4 | signed integer | `int32_t` |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| `Int32Array` | 4 | 有符号整数 | `int32_t` |'
- en: '| `Uint32Array` | 4 | unsigned integer | `unint32_t` |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| `Uint32Array` | 4 | 无符号整数 | `unint32_t` |'
- en: '| `Float32Array` | 4 | 32 bit floating point | `float` |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| `Float32Array` | 4 | 32 位浮点数 | `float` |'
- en: '| `Float64Array` | 8 | 64 bit floating point | `float` |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| `Float64Array` | 8 | 64 位浮点数 | `float` |'
- en: 'The following `Array` methods are missing: `push`, `pop`, `shift`, `splice`,
    and `unshift`.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `Array` 方法缺失：`push`，`pop`，`shift`，`splice` 和 `unshift`。
- en: There are also two extra methods found on `TypedArrays`
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个额外的方法可以在 `TypedArrays` 上找到
- en: TypedArray Prototype Methods
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 类型化数组原型方法
- en: '| Method | Description |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `t.p.set(array, [offset])` | Return `undefined`. Copy `array` into `t` at
    `offset` location |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| `t.p.set(array, [offset])` | 返回 `undefined`。将 `array` 复制到 `t` 的 `offset`
    位置 |'
- en: '| `t.p.subarray(start, [end])` | Return `TypeArray` with view of data in `t`
    starting at position `start` up to but not including `end`. Note that the `t`
    and the new object share the data. |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| `t.p.subarray(start, [end])` | 返回从位置 `start` 开始到 `end` 之前的 `t` 数据视图的 `TypeArray`。请注意，`t`
    和新对象共享数据。 |'
- en: Data Views
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据视图
- en: A `DataView` is another interface for interacting with an `ArrayBuffer`. If
    you need control over endianness, you should use this rather than a typed array.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataView` 是与 `ArrayBuffer` 交互的另一个接口。如果需要控制字节序，应该使用它而不是类型化数组。'
- en: '[PRE45]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The constructor supports a buffer and option offset and length:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数支持缓冲区和可选的偏移量和长度：
- en: '[PRE46]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: DataView Properties
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: DataView 属性
- en: '| Property | Description |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `DataView.name` | `DataView` |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| `DataView.name` | `DataView` |'
- en: '| `DataView.prototype` | `DataView` constructor |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| `DataView.prototype` | `DataView` 构造函数 |'
- en: '| `DataView.prototype.buffer` | The underlying `ArrayBuffer` |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| `DataView.prototype.buffer` | 底层的`ArrayBuffer` |'
- en: '| `DataView.prototype.byteLength` | The length of the view |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| `DataView.prototype.byteLength` | 视图的长度 |'
- en: '| `DataView.prototype.byteOffset` | The offset of the view |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| `DataView.prototype.byteOffset` | 视图的偏移量 |'
- en: DataView Prototype Methods
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: DataView原型方法
- en: '| Method | Description |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `d.p.getFloat32(offset, [littleEndian])` | Retrieve signed 32-bit float from
    `offset`. If `littleEndian` is `true` use litte endian format |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getFloat32(offset, [littleEndian])` | 从`offset`处检索带符号32位浮点数。如果`littleEndian`为`true`，则使用小端格式
    |'
- en: '| `d.p.getFloat64(offset, [littleEndian])` | Retrieve signed 64-bit float from
    `offset`. If `littleEndian` is `true` use litte endian format |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getFloat64(offset, [littleEndian])` | 从`offset`处检索带符号64位浮点数。如果`littleEndian`为`true`，则使用小端格式
    |'
- en: '| `d.p.getInt16(offset, [littleEndian])` | Retrieve signed 16-bit integer from
    `offset`. If `littleEndian` is `true` use litte endian format |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getInt16(offset, [littleEndian])` | 从`offset`处检索带符号16位整数。如果`littleEndian`为`true`，则使用小端格式
    |'
- en: '| `d.p.getInt32(offset, [littleEndian])` | Retrieve signed 32-bit integer from
    `offset`. If `littleEndian` is `true` use litte endian format |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getInt32(offset, [littleEndian])` | 从`offset`处检索带符号32位整数。如果`littleEndian`为`true`，则使用小端格式
    |'
- en: '| `d.p.getInt8(offset, [littleEndian])` | Retrieve signed 8-bit integer from
    `offset`. If `littleEndian` is `true` use litte endian format |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getInt8(offset, [littleEndian])` | 从`offset`处检索带符号8位整数。如果`littleEndian`为`true`，则使用小端格式
    |'
- en: '| `d.p.getUint16(offset, [littleEndian])` | Retrieve unsigned 16-bit integer
    from `offset`. If `littleEndian` is `true` use litte endian format |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getUint16(offset, [littleEndian])` | 从`offset`处检索无符号16位整数。如果`littleEndian`为`true`，则使用小端格式
    |'
- en: '| `d.p.getUint32(offset, [littleEndian])` | Retrieve unsigned 32-bit integer
    from `offset`. If `littleEndian` is `true` use litte endian format |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getUint32(offset, [littleEndian])` | 从`offset`处检索无符号32位整数。如果`littleEndian`为`true`，则使用小端格式
    |'
- en: '| `d.p.getUint8(offset, [littleEndian])` | Retrieve unsigned 8-bit integer
    from `offset`. If `littleEndian` is `true` use litte endian format |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getUint8(offset, [littleEndian])` | 从`offset`处检索无符号8位整数。如果`littleEndian`为`true`，则使用小端格式
    |'
- en: '| `d.p.setFloat32(offset, value, [littleEndian])` | Set signed 32-bit float
    `value` at `offset`. If `littleEndian` is `true` use litte endian format |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setFloat32(offset, value, [littleEndian])` | 在`offset`处设置带符号32位浮点数`value`。如果`littleEndian`为`true`，则使用小端格式
    |'
- en: '| `d.p.setFloat64(offset, value, [littleEndian])` | Set signed 64-bit float
    `value` at `offset`. If `littleEndian` is `true` use litte endian format |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setFloat64(offset, value, [littleEndian])` | 在`offset`处设置带符号的64位浮点数`value`。如果`littleEndian`为`true`，则使用小端格式
    |'
- en: '| `d.p.setInt16(offset, value, [littleEndian])` | Set signed 16-bit integer
    `value` at `offset`. If `littleEndian` is `true` use litte endian format |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setInt16(offset, value, [littleEndian])` | 在`offset`处设置带符号16位整数`value`。如果`littleEndian`为`true`，则使用小端格式
    |'
- en: '| `d.p.setInt32(offset, value, [littleEndian])` | Set signed 32-bit integer
    `value` at `offset`. If `littleEndian` is `true` use litte endian format |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setInt32(offset, value, [littleEndian])` | 在`offset`处设置带符号32位整数`value`。如果`littleEndian`为`true`，则使用小端格式
    |'
- en: '| `d.p.setInt8(offset, value, [littleEndian])` | Set signed 8-bit integer `value`
    at `offset`. If `littleEndian` is `true` use litte endian format |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setInt8(offset, value, [littleEndian])` | 在`offset`处设置带符号8位整数`value`。如果`littleEndian`为`true`，则使用小端格式
    |'
- en: '| `d.p.setUint16(offset, value, [littleEndian])` | Set unsigned 16-bit integer
    `value` at `offset`. If `littleEndian` is `true` use litte endian format |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setUint16(offset, value, [littleEndian])` | 在`offset`处设置无符号16位整数`value`。如果`littleEndian`为`true`，则使用小端格式
    |'
- en: '| `d.p.setUint32(offset, value, [littleEndian])` | Set unsigned 32-bit integer
    `value` at `offset`. If `littleEndian` is `true` use litte endian format |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setUint32(offset, value, [littleEndian])` | 在`offset`处设置无符号32位整数`value`。如果`littleEndian`为`true`，则使用小端格式
    |'
- en: '| `d.p.setUint8(offset, value, [littleEndian])` | Set unsigned 8-bit integer
    `value` at `offset`. If `littleEndian` is `true` use litte endian format |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setUint8(offset, value, [littleEndian])` | 在`offset`处设置无符号8位整数`value`。如果`littleEndian`为`true`，则使用小端格式
    |'
- en: Date
  id: totrans-461
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Date
- en: 'Options for `Date`. To get the current time simply use:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date`的选项。要获取当前时间，只需使用：'
- en: '[PRE47]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If an integer is provided, you will get the seconds from the Unix epoch:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供整数，则将获得自Unix纪元以来的秒数：
- en: '[PRE48]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The ES6 spec only supports a variant of ISO8601, but in practice a string in
    RFC 2822/1123 is also supported:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: ES6规范仅支持ISO8601的一种变体，但实际上也支持RFC 2822/1123中的字符串：
- en: '[PRE49]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, the `Date` constructor allows us to specify the year, month, date,
    hours, minutes, seconds, and milliseconds:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Date`构造函数允许我们指定年、月、日、小时、分钟、秒和毫秒：
- en: '[PRE50]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Dates created with the constructor are in the local time. To create a `Date`
    in UTC, use the `Date.UTC` method.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数创建的日期是在本地时间。要在 UTC 中创建一个 `Date`，请使用 `Date.UTC` 方法。
- en: Note
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'An RFC 2822/RFC 1123 string is a human readable string that looks like:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 RFC 2822/RFC 1123 字符串是一个类似于以下的可读字符串：
- en: '[PRE51]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `toUTCString` method will give you this string.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`toUTCString` 方法将给出这个字符串。'
- en: Note
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'ISO 8601 in ES6 is specified like this:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 中的 ISO 8601 规定如下：
- en: '[PRE52]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There is a `toISOString` method on `Date` that will return this format.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date` 上有一个 `toISOString` 方法，将返回这种格式。'
- en: Date Properties
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 日期属性
- en: '| Property | Description |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Date.name` | `Date` |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '| `Date.name` | `Date` |'
- en: '| `Date.prototype` | `Date` constructor |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '| `Date.prototype` | `Date` 构造函数 |'
- en: Date Methods
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 日期方法
- en: '| Method | Description |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `d.UTC(year, month, [day, [hour, [minute, [second, [millisecond]]]]])` |
    Return milliseconds since Unix epoch from UTC time specified |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| `d.UTC(year, month, [day, [hour, [minute, [second, [millisecond]]]]])` |
    返回自指定 UTC 时间以来的自 Unix 纪元以来的毫秒数 |'
- en: '| `d.now()` | Return milliseconds since Unix epoch |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| `d.now()` | 返回自 Unix 纪元以来的毫秒数 |'
- en: '| `d.parse(str)` | Return milliseconds since Unix epoch for ISO 8601 string
    |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| `d.parse(str)` | 返回 ISO 8601 字符串的自 Unix 纪元以来的毫秒数 |'
- en: Date Prototype Methods
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 日期原型方法
- en: '| Method | Description |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `d.p.getDate()` | Return day of month, number between `1` and `31` |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getDate()` | 返回月份中的日期，介于 `1` 和 `31` 之间的数字 |'
- en: '| `d.p.getDay()` | Return day of the week (`0` is Sunday). |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getDay()` | 返回一周中的日期（`0` 代表星期日）。'
- en: '| `d.p.getFullYear()` | Return year, number between `0` and `9999` |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getFullYear()` | 返回年份，介于 `0` 和 `9999` 之间的数字 |'
- en: '| `d.p.getHours()` | Return hour, number between `0` and `23` |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getHours()` | 返回小时数，介于 `0` 和 `23` 之间的数字 |'
- en: '| `d.p.getMilliseconds()` | Return milliseconds, number between `0` and `999`
    |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getMilliseconds()` | 返回毫秒数，介于 `0` 和 `999` 之间���数字 |'
- en: '| `d.p.getMinutes()` | Return minutes, number between `0` and `59` |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getMinutes()` | 返回分钟数，介于 `0` 和 `59` 之间的数字 |'
- en: '| `d.p.getMonth()` | Return month, number between `0` (Jan) and `11` (Dec)
    |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getMonth()` | 返回月份，介于 `0`（一月）和 `11`（十二月）之间的数字 |'
- en: '| `d.p.getSeconds()` | Return seconds, number between `0` and `59` |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getSeconds()` | 返回秒数，介于 `0` 和 `59` 之间的数字 |'
- en: '| `d.p.getTime()` | Return milliseconds since Unix epoch |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getTime()` | 返回自 Unix 纪元以来的毫秒数 |'
- en: '| `d.p.getTimezoneOffset()` | Return timezone offset in minutes |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getTimezoneOffset()` | 返回时区偏移量（以分钟为单位） |'
- en: '| `d.p.getUTCDate()` | Return UTC day of month, number between `1` and `31`
    |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getUTCDate()` | 返回 UTC 月份中的日期，介于 `1` 和 `31` 之间的数字 |'
- en: '| `d.p.getUTCDay()` | Return UTC day of the week (`0` is Sunday). |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getUTCDay()` | 返回 UTC 一周中的日期（`0` 代表星期日）。'
- en: '| `d.p.getUTCFullYear()` | Return UTC year, number between `0` and `9999` |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getUTCFullYear()` | 返回 UTC 年份，介于 `0` 和 `9999` 之间的数字 |'
- en: '| `d.p.getUTCHours()` | Return hour, number between `0` and `23` |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getUTCHours()` | 返回小时数，介于 `0` 和 `23` 之间的数字 |'
- en: '| `d.p.getUTCMilliseconds()` | Return UTC milliseconds, number between `0`
    and `999` |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getUTCMilliseconds()` | 返回 UTC 毫秒数，介于 `0` 和 `999` 之间的数字 |'
- en: '| `d.p.getUTCMinutes()` | Return UTCminutes, number between `0` and `59` |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getUTCMinutes()` | 返回 UTC 分钟数，介于 `0` 和 `59` 之间的数字 |'
- en: '| `d.p.getUTCMonth()` | Return UTCmonth, number between `0` (Jan) and `11`
    (Dec) |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getUTCMonth()` | 返回 UTC 月份，介于 `0`（一月）和 `11`（十二月）之间的数字 |'
- en: '| `d.p.getUTCSeconds()` | Return UTC seconds, number between `0` and `59` |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getUTCSeconds()` | 返回 UTC 秒数，介于 `0` 和 `59` 之间的数字 |'
- en: '| `d.p.getYear()` | Broken year implementation, use `getFullYear` |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.getYear()` | 已弃用的年份实现，请使用 `getFullYear` |'
- en: '| `d.p.setDate(num)` | Return milliseconds after Unix epoch after mutating
    day of month |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setDate(num)` | 在改变月份中的日期后返回自 Unix 纪元以来的毫秒数 |'
- en: '| `d.p.setFullYear(year, [month, [day]])` | Return milliseconds after Unix
    epoch after mutating day values |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setFullYear(year, [month, [day]])` | 在改变日期值后返回自 Unix 纪元以来的毫秒数 |'
- en: '| `d.p.setHours(hours, [min, [sec, [ms]]])` | Return milliseconds after Unix
    epoch after mutating time values |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setHours(hours, [min, [sec, [ms]]])` | 在改变时间值后返回自 Unix 纪元以来的毫秒数 |'
- en: '| `d.p.setMilliseconds(ms)` | Return milliseconds after Unix epoch after mutating
    ms value |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setMilliseconds(ms)` | 在改变毫秒值后返回自 Unix 纪元以来的毫秒数 |'
- en: '| `d.p.setMinutes(min, [sec, [ms]])` | Return milliseconds after Unix epoch
    after mutating time values |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setMinutes(min, [sec, [ms]])` | 在改变时间值后返回自 Unix 纪元以来的毫秒数 |'
- en: '| `d.p.setMonth(month, [day])` | Return milliseconds after Unix epoch after
    mutating day values |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setMonth(month, [day])` | 在改变日期值后返回自 Unix 纪元以来的毫秒数 |'
- en: '| `d.p.setSeconds(sec, [ms])` | Return milliseconds after Unix epoch after
    mutating time values |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setSeconds(sec, [ms])` | 在改变时间值后返回自 Unix 纪元以来的毫秒数 |'
- en: '| `d.p.setTime(epoch)` | Return milliseconds after Unix epoch after mutating
    time value |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setTime(epoch)` | 在变异时间值后返回Unix纪元后的毫秒数 |'
- en: '| `d.p.setUTCDate(num)` | Return milliseconds after Unix epoch after mutating
    day of month |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setUTCDate(num)` | 在变异日期后返回Unix纪元后的毫秒数 |'
- en: '| `d.p.setUTCFullYear(year, [month, [day]])` | Return milliseconds after Unix
    epoch after mutating day values |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setUTCFullYear(year, [month, [day]])` | 在变异日期值后返回Unix纪元后的毫秒数 |'
- en: '| `d.p.setUTCHours(hours, [min, [sec, [ms]]])` | Return milliseconds after
    Unix epoch after mutating time values |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setUTCHours(hours, [min, [sec, [ms]]])` | 在变异时间值后返回Unix纪元后的毫秒数 |'
- en: '| `d.p.setUTCMilliseconds( ms)` | Return milliseconds after Unix epoch after
    mutating ms value |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setUTCMilliseconds( ms)` | 在变异ms值后返回Unix纪元后的毫秒数 |'
- en: '| `d.p.setUTCMinutes(min, [sec, [ms]])` | Return milliseconds after Unix epoch
    after mutating time values |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setUTCMinutes(min, [sec, [ms]])` | 在变异时间值后返回Unix纪元后的毫秒数 |'
- en: '| `d.p.setUTCMonth(month, [day])` | Return milliseconds after Unix epoch after
    mutating day values |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setUTCMonth(month, [day])` | 在变异日期值后返回Unix纪元后的毫秒数 |'
- en: '| `d.p.setUTCSeconds(sec, [ms])` | Return milliseconds after Unix epoch after
    mutating time values |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setUTCSeconds(sec, [ms])` | 在变异时间值���返回Unix纪元后的毫秒数 |'
- en: '| `d.p.setYear(year)` | Broken year implementation, use `setFullYear` |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.setYear(year)` | 已损坏的年份实现，请使用`setFullYear` |'
- en: '| `d.p.toDateString()` | Return human readable of date in American English
    |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.toDateString()` | 返回美式英语日期的可读形式 |'
- en: '| `d.p.toGMTString()` | Broken, use `toUTCString` |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.toGMTString()` | 已损坏，请使用`toUTCString` |'
- en: '| `d.p.toISOString()` | Return date string in ISO 8601 form |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.toISOString()` | 返回ISO 8601形式的日期字符串 |'
- en: '| `d.p.toJSON()` | Return date JSON string form (ISO 8601) |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.toJSON()` | 返回日期JSON字符串形式（ISO 8601） |'
- en: '| `d.p.toLocaleDateString( [locales, [options]])` | Return string of date portion
    in locale |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.toLocaleDateString( [locales, [options]])` | 返回区域设置中日期部分的字符串 |'
- en: '| `d.p.toLocaleString( [locales, [options]])` | Return string of date and time
    in locale |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.toLocaleString( [locales, [options]])` | 返回区域设置中的日期和时间字符串 |'
- en: '| `d.p.toLocaleTimeString( [locales, [options]])` | Return string of time in
    locale |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.toLocaleTimeString( [locales, [options]])` | 返回区域设置中的时间字符串 |'
- en: '| `d.p.toString()` | Return a string representation in American English |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.toString()` | 返回美式英语的字符串表示 |'
- en: '| `d.p.toTimeString()` | Return a string representation of time portion in
    American English |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.toTimeString()` | 返回美式英语时间部分的字符串表示 |'
- en: '| `d.p.toUTCString()` | Return (usually RFC-1123 formatted) version of string
    in UTC timezone |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.toUTCString()` | 返回UTC时区中的（通常是RFC-1123格式化的）字符串版本 |'
- en: '| `d.p.valueOf()` | Return milliseconds after Unix epoch |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| `d.p.valueOf()` | 返回Unix纪元后的毫秒数 |'
- en: Maps
  id: totrans-539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地图
- en: Maps do not have prototypes (like objects do) that could collide with your keys.
    Objects only support strings or symbols as keys, whereas maps support any type
    for keys (functions, objects, or primitives). Another benefit of maps is that
    you can easily get the length with the `size` property. To get the length of an
    object, you need to iterate over it.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 地图没有原型（就像对象那样）可能与您的键冲突。对象只支持字符串或符号作为键，而地图支持任何类型的键（函数、对象或基元）。地图的另一个好处是您可以轻松地通过`size`属性获取长度。要获取对象的长度，您需要对其进行迭代。
- en: Should you use an object or a map? If you need record type data, use an object.
    For hashlike collections that you need to mutate and iterate over, choose a map.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该使用对象还是地图？如果需要记录类型数据，请使用对象。对于需要变异和迭代的哈希集合，请选择地图。
- en: A `Map` can be created simply by calling the constructor, or by passing an iterable
    of key value pairs.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 只需调用构造函数或传递键值对的可迭代对象即可创建`Map`。
- en: '[PRE53]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Map Properties
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 地图属性
- en: '| Property | Description |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Map.name` | `Map` |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '| `Map.name` | `Map` |'
- en: '| `Map.prototype` | Constructor prototype for `Map` |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| `Map.prototype` | `Map`的构造函数原型 |'
- en: '| `Map.prototype.size` | Return number of items in map |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| `Map.prototype.size` | 返回地图中的项目数 |'
- en: Map Prototype Methods
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 地图原型方法
- en: '| Method | Description |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `m.p.clear()` | Return `undefined`. Remove all items from `m` (mutates `m`)
    |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| `m.p.clear()` | 返回`undefined`。从`m`中删除所有项目（变异`m`） |'
- en: '| `m.p.delete(key)` | Return boolean if `key` was in `m`. Mutates `m` and removes
    it |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| `m.p.delete(key)` | 如果`key`在`m`中，则返回布尔值。变异`m`并将其删除 |'
- en: '| `m.p.entries()` | Return iterator for array of key, value pairs |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| `m.p.entries()` | 返回键值对数组的迭代器 |'
- en: '| `m.p.forEach(func, [this])` | Return `undefined`. Apply `func(value, key,
    m)` to every key and value in `m` |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| `m.p.forEach(func, [this])` | 返回`undefined`。将`func（value，key，m）`应用于`m`中的每个键和值
    |'
- en: '| `m.p.get(key)` | Return value or `undefined` |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| `m.p.get(key)` | 返回值或 `undefined` |'
- en: '| `m.p.has(key)` | Return boolean if `key` found in `m` |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| `m.p.has(key)` | 如果 `key` 在 `m` 中找到，则返回布尔值 |'
- en: '| `m.p.keys()` | Return iterator of keys in `m` in order of insertion |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| `m.p.keys()` | 返回按插入顺序排列的 `m` 中的键的迭代器 |'
- en: '| `m.p.set(key, value)` | Return `m`, mutating `m` with `value` for `key` |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| `m.p.set(key, value)` | 使用 `value` 来改变 `m` 中的 `key`，返回 `m` |'
- en: '| `m.p.values()` | Return iterator for values in order of insertion |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| `m.p.values()` | 按插入顺序返回值的迭代器 |'
- en: '`WeakMaps`'
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`WeakMaps`'
- en: '`WeakMaps` allow you to track objects until they are garbage collected. The
    keys don''t create references, so data may disappear from weakmap if the key happens
    to be garbage collected (or if its containing object is collected).'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakMaps` 允许您跟踪对象，直到它们被垃圾收集。键不创建引用，因此如果键恰好被垃圾收集（或其包含的对象被收集），数据可能会从 weakmap
    中消失。'
- en: The constructor has the same interface as `Map`, you can create an empty `WeakMap`
    by provided no arguments, or you can pass in an iterable of key value pairs.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数具有与`Map`相同的接口，您可以通过不提供参数来创建一个空的`WeakMap`，或者您可以传递一个键值对的可迭代对象。
- en: WeakMap Properties
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 弱映射属性
- en: '| Property | Description |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `WeakMap.name` | `WeakMap` |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| `WeakMap.name` | `WeakMap` |'
- en: '| `WeakMap.prototype` | Constructor prototype for `WeakMap` |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| `WeakMap.prototype` | `WeakMap` 的构造函数原型 |'
- en: WeakMap Prototype Methods
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 弱映射原型方法
- en: '| Method | Description |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `w.p.delete(key)` | Return `true` if `key` existed and was removed, else
    `false` |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| `w.p.delete(key)` | 如果 `key` 存在且被移除，则返回 `true`，否则返回 `false` |'
- en: '| `w.p.get(key)` | Return value for `key` or `undefined` if missing |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '| `w.p.get(key)` | 返回 `key` 的值，如果缺少则返回 `undefined` |'
- en: '| `w.p.has(key)` | Return boolean if `key` found in `w` |'
  id: totrans-575
  prefs: []
  type: TYPE_TB
  zh: '| `w.p.has(key)` | 如果 `key` 在 `w` 中找到，则返回布尔值 |'
- en: '| `w.p.set(key, value)` | Return `w` after mutating it with new `key` and `value`
    |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '| `w.p.set(key, value)` | 使用新的 `key` 和 `value` 改变 `w`，并返回 `w` |'
- en: Sets
  id: totrans-577
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: 'A set is a mutable unordered collection that cannot contain duplicates. Sets
    are used to remove duplicates and test for membership. You can make an empty `Set`
    by calling the constructor with no arguments. If you wish to create a `Set` from
    an iterable, pass that into the constructor:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一个可变的无序集合，不能包含重复项。集合用于删除重复项并测试成员资格。您可以通过调用没有参数的构造函数来创建一个空的`Set`。如果要从可迭代对象创建
    `Set`，请将其传递到构造函数中：
- en: '[PRE54]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Set operations are not provided. Here is an example of adding difference:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 不提供集合操作。以下是添加差异的示例：
- en: '[PRE55]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Set Properties
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 集合属性
- en: '| Property | Description |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Set.name` | `Set` |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '| `Set.name` | `Set` |'
- en: '| `Set.prototype` | Constructor prototype for `Set` |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '| `Set.prototype` | `Set` 的构造函数原型 |'
- en: '| `Set.prototype.size` | Return size of set |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '| `Set.prototype.size` | 返回集合的大小 |'
- en: Set Prototype Methods
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 集合原型方法
- en: '| Method | Description |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `s.p.add(item)` | Return `s`. Add `item` to `s` (mutating) |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.add(item)` | 返回 `s`。将 `item` 添加到 `s`（变异） |'
- en: '| `s.p.clear()` | Return `undefined`. Removes (mutating) all items from `s`
    |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.clear()` | 返回 `undefined`。从 `s` 中删除（变异）所有项 |'
- en: '| `s.p.delete(item)` | Return value if deleted, otherwise returns `false` (mutating)
    |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.delete(item)` | 如果删除，则返回值，否则返回 `false`（变异） |'
- en: '| `s.p.entries()` | Return iterator of `item`, `item` pairs (both the same)
    for every item of `s` (same interface as `Map`) |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.entries()` | 返回 `s` 中每个项（相同接口的 `Map`）的迭代器，包括每个项，每个项 |'
- en: '| `s.p.forEach(func, [this])` | Return `undefined`. Apply `func(item, item,
    s)` to every item in `s`. Same interface as `Array` and `Map` |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.forEach(func, [this])` | 返回 `undefined`。对 `s` 中的每个项应用 `func(item, item,
    s)`。与 `Array` 和 `Map` 具有相同的接口 |'
- en: '| `s.p.has(item)` | Return boolean if `item` found in `s` |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.has(item)` | 如果 `item` 在 `s` 中找到，则返回布尔值 |'
- en: '| `s.p.values()` | Return iterator for items in insertion order |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.values()` | 返回按插入顺序排列的项的迭代器 |'
- en: Weak Set
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弱集合
- en: Weak sets are collections of objects, and not any type. We cannot enumerate
    over them. Objects may spontaneously disappear from them when they are garbage
    collected.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 弱集合是对象的集合，而不是任何类型。我们无法对它们进行枚举。对象可能在垃圾收集时从中自动消失。
- en: The `WeakSet` constructor has the same interace as `Set` (no arguments or an
    iterable).
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakSet` 构造函数具有与 `Set` 相同的接口（无参数或可迭代对象）。'
- en: WeakSet Properties
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 弱集合属性
- en: '| Property | Description |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `WeakSet.name` | `WeakSet` |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '| `WeakSet.name` | `WeakSet` |'
- en: '| `WeakSet.prototype` | Prototype for `WeakSet` |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '| `WeakSet.prototype` | `WeakSet` 的原型 |'
- en: WeakSet Prototype Methods
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 弱集合原型方法
- en: '| Method | Description |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `w.p.add(item)` | Return `w`, inserts `item` into `w` |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '| `w.p.add(item)` | 返回 `w`，将 `item` 插入 `w` |'
- en: '| `w.p.delete(item)` | Return `true` if `item` was in `w` (also removes it),
    otherwise return `false` |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '| `w.p.delete(item)` | 如果`item`在`w`中则返回`true`（同时移除它），否则返回`false` |'
- en: '| `w.p.has(item)` | Return boolean if `item` in `w` |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
  zh: '| `w.p.has(item)` | 如果`item`在`w`中则返回布尔值 |'
- en: Proxies
  id: totrans-612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代理
- en: A proxy allows you to create custom behavior for basic operations (getting/setting
    properties, calling functions, looping over values, decorating, etc). We use a
    *handler* to configure *traps* for a *target*.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 代理允许您为基本操作（获取/设置属性，调用函数，循环值，装饰等）创建自定义行为。我们使用*handler*为*target*配置*traps*。
- en: 'The constructor takes two arguments, a target, and a handler:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受两个参数，一个是目标，一个是处理程序：
- en: '[PRE56]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Proxy Methods
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 代理方法
- en: '| Property | Description |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Proxy.revocable(target, handler)` | Create a revocable proxy. When `revoke`
    is called, proxy throws `TypeError` |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '| `Proxy.revocable(target, handler)` | 创建一个可撤销的代理。当调用`revoke`时，代理会抛出`TypeError`
    |'
- en: Reflection
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反射
- en: The `Reflect` object allows you to inspect objects. `Reflect` is not a constructor,
    all the methods are static.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect`对象允许您检查对象。`Reflect`不是一个构造函数，所有方法都是静态的。'
- en: Math Methods
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 数学方法
- en: '| Method | Description |'
  id: totrans-623
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Reflect.apply(obj, this, args)` | Return result of `obj(...args)` with `this`
    value |'
  id: totrans-625
  prefs: []
  type: TYPE_TB
  zh: '| `Reflect.apply(obj, this, args)` | 返回使用`this`值调用`obj(...args)`的结果 |'
- en: '| `Reflect.construct(obj, args)` | Return result of `new obj(...args)` |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
  zh: '| `Reflect.construct(obj, args)` | 返回`new obj(...args)`的结果 |'
- en: '| `Reflect.defineProperty(obj, key, descriptor)` | Like `Object.defineProperty(
    obj, key, descriptor)`, but returns `Boolean` |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '| `Reflect.defineProperty(obj, key, descriptor)` | 类似于`Object.defineProperty(obj,
    key, descriptor)`，但返回`Boolean` |'
- en: '| `Reflect.deleteProperty(obj, key)` | Remove `key` from `obj`, returns `Boolean`
    |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
  zh: '| `Reflect.deleteProperty(obj, key)` | 从`obj`中删除`key`，返回`Boolean` |'
- en: '| `Reflect.get(obj, key)` | Return `obj[key]` |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
  zh: '| `Reflect.get(obj, key)` | 返回`obj[key]` |'
- en: '| `Reflect.getOwnProperty Descriptor(obj, key)` | Return property descriptor
    of `obj[key]` |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
  zh: '| `Reflect.getOwnPropertyDescriptor(obj, key)` | 返回`obj[key]`的属性描述符 |'
- en: '| `Reflect.getPrototypeOf(obj)` | Return prototype for `obj` or `null` (if
    no inherited properties) |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
  zh: '| `Reflect.getPrototypeOf(obj)` | 返回`obj`的原型或`null`（如果没有继承属性） |'
- en: '| `Reflect.has(obj, key)` | Return `key in obj` |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '| `Reflect.has(obj, key)` | 返回 `key in obj` |'
- en: '| `Reflect.isExtensible(obj)` | Return `Boolean` if you can add new properties
    to `obj` |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| `Reflect.isExtensible(obj)` | 如果您可以向`obj`添加新属性，则返回`Boolean` |'
- en: '| `Reflect.ownKeys(obj)` | Return `Array` of keys in `obj` |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '| `Reflect.ownKeys(obj)` | 返回`obj`中的键的`Array` |'
- en: '| `Reflect.preventExtensions( obj)` | Disallow extensions on `obj`, return
    `Boolean` if successful |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '| `Reflect.preventExtensions(obj)` | 禁止在`obj`上添加扩展，如果成功则返回`Boolean` |'
- en: '| `Reflect.set(obj, key, value, [this])` | Return `Boolean` if successful setting
    property `key` on `obj`. |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '| `Reflect.set(obj, key, value, [this])` | 在`obj`上成功设置属性`key`时返回`Boolean`。
    |'
- en: Symbols
  id: totrans-637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 符号
- en: ES6 introduced a new primitive type, Symbol. They have string-like properties
    (immutable, can't set properties on them, can be property names). They also have
    object-like behavior (unique from others even if the description is the same).
    Symbols are unique values that can be used for property keys without collisions.
    They must be accessed using an index operation (square brackets) and not dot notation.
    The are also not iterated over in a `for ... in` loop. To retrieve them we need
    to use `Object.getOwnPropertySymbols` or `Reflect.ownKeys`.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了一种新的原始类型，Symbol。它们具有类似字符串的属性（不可变，不能在其上设置属性，可以作为属性名）。它们还具有类似对象的行为（即使描述相同，也是唯一的）。符号是唯一的值，可以用作属性键而不会发生冲突。它们必须使用索引操作（方括号）访问，而不是点符号。它们也不会在`for
    ... in`循环中迭代。要检索它们，我们需要使用`Object.getOwnPropertySymbols`或`Reflect.ownKeys`。
- en: 'The constructor takes an optional description argument:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受一个可选的描述参数：
- en: '[PRE57]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`Symbol` is not a constructor, and a `TypeError` will be raised if you try
    to use it as one.'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '`Symbol`不是一个构造函数，如果您尝试将其用作构造函数，则会引发`TypeError`。'
- en: Symbol Properties
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 符号属性
- en: '| Property | Description |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Symbol.hasInstance` | Used to define class behavior for `instanceof`. Define
    method as `static [Symbol.hasInstance](instance) ...` |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '| `Symbol.hasInstance` | 用于为`instanceof`定义类行为。将方法定义为`static [Symbol.hasInstance](instance)
    ...` |'
- en: '| `Symbol. isConcatSpreadable` | Used to define class behavior for `Array.concat`.
    Set to `true` if items are spread (or flattened). |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
  zh: '| `Symbol.isConcatSpreadable` | 用于为`Array.concat`定义类行为。如果项目被展开（或扁平化），则设置为`true`。
    |'
- en: '| `Symbol.iterator` | Used to define class behavior for `for...of`. Should
    follow iteration protocol. Can be a generator |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '| `Symbol.iterator` | 用于为`for...of`定义类行为。应遵循迭代协议。可以是一个生成器 |'
- en: '| `Symbol.match` | Used to define class behavior for responding as a regular
    expression in `String` methods: `startsWith`, `endsWith`, `includes` |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '| `Symbol.match` | 用于定义类行为，以便在 `String` 方法中作为正则表达式响应：`startsWith`、`endsWith`、`includes`
    |'
- en: '| `Symbol.name` | value: `Symbol` |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
  zh: '| `Symbol.name` | 值：`Symbol` |'
- en: '| `Symbol.prototype` | The prototype for `Symbol` |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
  zh: '| `Symbol.prototype` | `Symbol` 的原型 |'
- en: '| `Symbol.replace` | Used to define class behavior for responding to `String.p.replace`
    method |'
  id: totrans-652
  prefs: []
  type: TYPE_TB
  zh: '| `Symbol.replace` | 用于定义类行为，以响应 `String.p.replace` 方法 |'
- en: '| `Symbol.search` | Used to define class behavior for responding to `String.p.search`
    method |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
  zh: '| `Symbol.search` | 用于定义类行为，以响应 `String.p.search` 方法 |'
- en: '| `Symbol.species` | Used to define class behavior for which constructor to
    use when creating derived objects |'
  id: totrans-654
  prefs: []
  type: TYPE_TB
  zh: '| `Symbol.species` | 用于定义类行为，在创建派生对象时使用哪个构造函数 |'
- en: '| `Symbol.split` | Used to define class behavior for responding to `String.p.split`
    method |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
  zh: '| `Symbol.split` | 用于定义类行为，以响应 `String.p.split` 方法 |'
- en: '| `Symbol.toPrimitive` | Used to define class behavior for responding to coercion.
    Define method as `static [Symbol.toPrimitive] (hint) ...`, where `hint` can be
    `''number''`, `''string''`, or `''default''` |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
  zh: '| `Symbol.toPrimitive` | 用于定义类行为，以响应强制转换。将方法定义为 `static [Symbol.toPrimitive]
    (hint) ...`，其中 `hint` 可以是 `''number''`、`''string''` 或 `''default''` |'
- en: '| `Symbol.toStringTag` | Used to define class behavior for responding to `Object.p.toString`
    method |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| `Symbol.toStringTag` | 用于定义类行为，以响应 `Object.p.toString` 方法 |'
- en: '| `Symbol.unscopables` | Used to define class behavior in `with` statement.
    Should be set to an object mapping properties to boolean value if they are not
    visible in `with`. (ie `true` means throw `ReferenceError`) |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '| `Symbol.unscopables` | 用于定义 `with` 语句中的类行为。应该设置为将属性映射到布尔值的对象，如果它们在 `with`
    中不可见，则为 `true`（即 `true` 表示抛出 `ReferenceError`） |'
- en: Symbol Methods
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 符号方法
- en: '| Method | Description |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Symbol.for(key)` | Return symbol in global registry for `key`, other create
    symbol and return it. |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
  zh: '| `Symbol.for(key)` | 返回全局注册表中的 `key` 的符号，其他创建符号并返回它。 |'
- en: '| `Symbol.keyFor(symbol)` | Return string value for symbol in global registry,
    `undefined` if symbol not in registry |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
  zh: '| `Symbol.keyFor(symbol)` | 返回全局注册表中符号的字符串值，如果符号不在注册表中则返回 `undefined` |'
- en: Symbol Prototype Methods
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 符号原型方法
- en: '| Method | Description |'
  id: totrans-665
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-666
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `s.p.toString()` | Return string representation for symbol |'
  id: totrans-667
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.toString()` | 返回符号的字符串表示 |'
- en: '| `s.p.valueOf()` | Return primitive value (symbol) of a symbol |'
  id: totrans-668
  prefs: []
  type: TYPE_TB
  zh: '| `s.p.valueOf()` | 返回符号的原始值（符号） |'
- en: Built-in Functions
  id: totrans-669
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置函数
- en: Built-in Functions
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数
- en: '| Method | Description |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `eval(str)` | Evaluate code found in str |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '| `eval(str)` | 评估在 str 中找到的代码 |'
- en: '| `isFinite(val)` | Return `false` if `val` is `Infinity`, `-Infinity`, or
    `NaN`, else `true` |'
  id: totrans-674
  prefs: []
  type: TYPE_TB
  zh: '| `isFinite(val)` | 如果 `val` 是 `Infinity`、`-Infinity` 或 `NaN`，则返回 `false`，否则返回
    `true` |'
- en: '| `isNaN(val)` | Return `true` if `val` is `NaN`, else `False` |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
  zh: '| `isNaN(val)` | 如果 `val` 是 `NaN`，则返回 `true`，否则返回 `False` |'
- en: '| `parseFloat(str)` | Return float if `str` can be converted to a number, else
    `NaN` |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
  zh: '| `parseFloat(str)` | 如果 `str` 可以转换为数字，则返回浮点数，否则返回 `NaN` |'
- en: '| `parseInt(val, radix)` | Return integer if `str` can be converted to an integer,
    else `NaN`. It ignores characters that are not numbers in `radix` |'
  id: totrans-677
  prefs: []
  type: TYPE_TB
  zh: '| `parseInt(val, radix)` | 如果 `str` 可以转换为整数，则返回整数，否则返回 `NaN`。它忽略 `radix` 中不是数字的字符
    |'
- en: '| `decodeURI(uri)` | Return the unencoded version of the string. Should be
    used on full URI |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
  zh: '| `decodeURI(uri)` | 返回字符串的未编码版本。应该用于完整的 URI |'
- en: '| `decodeURIComponent(str)` | Return the unencoded version of the string. Should
    be used on parts of URI |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
  zh: '| `decodeURIComponent(str)` | 返回字符串的未编码版本。应该用于 URI 的部分 |'
- en: '| `encodeURI(uri)` | Return the encoded version of the URI. Should be used
    on full URI |'
  id: totrans-680
  prefs: []
  type: TYPE_TB
  zh: '| `encodeURI(uri)` | 返回 URI 的编码版本。应该用于完整的 URI |'
- en: '| `encodeURIComponent(uri)` | Return the encoded version of the URI. Should
    be used on parts of URI |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
  zh: '| `encodeURIComponent(uri)` | 返回 URI 的编码版本。应该用于 URI 的部分 |'
- en: Unicode
  id: totrans-682
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unicode
- en: 'If we have a unicode glyph, we can include that directly:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个 Unicode 符号，我们可以直接包含它：
- en: '[PRE58]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Alternatively, we can use the Unicode code point to specify a Unicode character:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 Unicode 代码点来指定 Unicode 字符：
- en: '[PRE59]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If we have exactly four hexadecimal digits we can escape like this:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有确切的四个十六进制数字，我们可以这样转义：
- en: '[PRE60]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can get a code point using the `codePointAt` string method:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `codePointAt` 字符串方法获取代码点：
- en: '[PRE61]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To convert a code point back to a string using the `fromCodePoint` static method:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `fromCodePoint` 静态方法将代码点转换回字符串：
- en: '[PRE62]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If we use the `/u` flag in a regular expression, we can search for Unicode characters,
    which will handle surrogate pairs.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在正则表达式中使用`/u`标志，我们可以搜索Unicode字符，这将处理代理对。
- en: Functions
  id: totrans-694
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions are easy to define, we simply give them a name, the parameters they
    accept and a body:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 函数很容易定义，我们只需给它们一个名称，它们接受的参数和一个主体：
- en: '[PRE63]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The arguments are stored in an implicit variable, `arguments`. We can invoke
    functions with any number of arguments:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 参数存储在一个隐式变量`arguments`中。我们可以用任意数量的参数调用函数：
- en: '[PRE64]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Default Arguments
  id: totrans-699
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认参数
- en: 'If we want to have a default value for an argument use a `=` to specify it
    immediately following the argument:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为参数设置默认值，使用`=`紧跟在参数后面指定它：
- en: '[PRE65]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Variable Parameters
  id: totrans-702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量参数
- en: 'Using `...` (*rest*) turns the remaining parameters into an array:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`...` (*rest*)将剩余参数转换为数组：
- en: '[PRE66]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Again, because ES6 provides the `arguments` object, we can also create a function
    that accepts variable parameters like this:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，因为ES6提供了`arguments`对象，我们也可以创建一个接受可变参数的函数，像这样：
- en: '[PRE67]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Calling Functions
  id: totrans-707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用函数
- en: 'You can use `...` to *spread* an array into arguments:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`...`来*展开*一个数组成为参数：
- en: '[PRE68]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `bind` Method
  id: totrans-710
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`bind`方法'
- en: 'Functions have a method, `bind`, that allows you to set `this` and any other
    parameters. This essentially allows you to *partial* the function:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有一个名为`bind`的方法，允许你设置`this`和任何其他参数。这本质上允许你*部分*函数：
- en: '[PRE69]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The first parameter to bind is the value passed for this. The rest are the arguments
    for the function. If you want a callback to use the parent's `this`, you can call
    bind on the function passing in the parent's `this`. Alternatively, you can use
    an arrow function.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定的第一个参数是传递给`this`的值。其余的是函数的参数。如果你想让回调使用父类的`this`，你可以在函数上调用bind，传入父类的`this`。或者，你可以使用箭头函数。
- en: Arrow functions
  id: totrans-714
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'ES6 introduced anonymous *arrow* functions. There are a few differences with
    arrow functions:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了匿名*箭头*函数。箭头函数有一些不同之处：
- en: Implicit return
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式返回
- en: '`this` is not rebound'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this`不会重新绑定'
- en: Cannot be generators
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能是生成器
- en: 'The second feature makes them nice for callbacks and handlers, but not a good
    choice for methods. We can write:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个特性使它们适用于回调和处理程序，但不适合方法。我们可以这样写：
- en: '[PRE70]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 如：
- en: '[PRE71]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `=>` is called a *fat arrow*. Since, this is a one line function, we can
    remove the curly braces and take advantage of the implicit return.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '`=>`被称为*胖箭头*。由于这是一个单行函数，我们可以移除花括号并利用隐式返回。'
- en: 'Note that the parentheses can be removed if you only have a single parameter
    and are inlining the function:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果只有一个参数并且内联函数，括号可以被移除：
- en: '[PRE72]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If we want a multiline arrow function, then remove the `function`, and add
    `=>`:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个多行箭头函数，那么去掉`function`，加上`=>`：
- en: '[PRE73]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'becomes:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 变成：
- en: '[PRE74]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Tail Call
  id: totrans-730
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尾调用
- en: 'If you perform a recursive call in the last position of a function, that is
    called *tail call*. ES6 will allow you to do this without growing the stack:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在函数的最后位置执行递归调用，那就是*尾调用*。ES6允许你这样做而不会增加堆栈：
- en: '[PRE75]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Some implementations might not support this. This fails with Node 7.7 and Chrome
    56 with `fib(100000)`.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 一些实现可能不支持这个。在Node 7.7和Chrome 56中，使用`fib(100000)`会失败。
- en: Classes
  id: totrans-735
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: 'ES6 introduced `class` which is syntactic sugar around creating objects with
    functions. ES6 classes support prototype inheritance, calls to parent classes
    via `super`, instance methods, and static methods:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了`class`，它是围绕使用函数创建对象的语法糖。ES6类支持原型继承，通过`super`调用父类，实例方法和静态方法：
- en: '[PRE76]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Note that when you create a new instance of a `class`, you need to use `new`:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当你创建一个`class`的新实例时，需要使用`new`：
- en: '[PRE77]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Classes in ES6 are not *hoisted*. This means that you can't use a class until
    after you defined it. Functions, are hoisted, and you can use them anywhere in
    the scope of the code that defines them.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: ES6中的类不会*提升*。这意味着你不能在定义之前使用类。函数会被提升，你可以在定义它们的代码范围内的任何地方使用它们。
- en: 'Prior to ES6, we could only create objects from functions:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6之前，我们只能从函数创建对象：
- en: '[PRE78]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The method is added after the fact to the prototype, so the instances can share
    the method. We could define the method in the function, but then every instance
    would get its own copy.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是在原型之后添加的，所以实例可以共享该方法。我们可以在函数中定义方法，但那样每个实例都会有自己的副本。
- en: ES6 just provides an arguably cleaner syntax for this.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: ES6为此提供了一个更清晰的语法。
- en: Subclasses
  id: totrans-747
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子类
- en: One thing to be aware of with subclasses is that they should call `super`. Because
    ES6 is just syntactic sugar, if we don't call `super`, we won't have the prototypes,
    and we can't create an instance without the prototypes. As a result, `this` is
    undefined until `super` is called. If you don't call super you should return `Object.create(...)`.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 子类中需要注意的一点是，它们应该调用`super`。因为ES6只是语法糖，如果我们不调用`super`，我们将没有原型，而且我们无法创建没有原型的实例。因此，直到调用`super`之前，`this`都是未定义的。如果不调用super，应该返回`Object.create(...)`。
- en: '[PRE79]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Static Methods
  id: totrans-750
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态方法
- en: A *static method* is a method called directly on the class, not on the instance.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态方法*是直接在类上调用的方法，而不是在实例上调用的。'
- en: '[PRE80]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Object Literal
  id: totrans-753
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象字面量
- en: 'We can also create instances using object literals, though in practice this
    leads to a lot of code duplication:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用对象字面量创建实例，尽管实际上这会导致大量的代码重复：
- en: '[PRE81]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Operators
  id: totrans-756
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符
- en: Assignment
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值
- en: Built-in Operators
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 内置运算符
- en: '| Operator | Description |'
  id: totrans-759
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-760
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `=` | Assignment |'
  id: totrans-761
  prefs: []
  type: TYPE_TB
  zh: '| `=` | 赋值 |'
- en: '| `+` | Addition, , unary plus (coerce to number), concatenation (string) |'
  id: totrans-762
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 加法，一元加（转换为数字），连接（字符串） |'
- en: '| `++` | Increment |'
  id: totrans-763
  prefs: []
  type: TYPE_TB
  zh: '| `++` | 自增 |'
- en: '| `-` | Subtraction, unary negation (coerce to number) |'
  id: totrans-764
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 减法，一元否定（转换为数字） |'
- en: '| `--` | Decrement |'
  id: totrans-765
  prefs: []
  type: TYPE_TB
  zh: '| `--` | 自减 |'
- en: '| `*` | Multiplication |'
  id: totrans-766
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 乘法 |'
- en: '| `/` | Division |'
  id: totrans-767
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 除法 |'
- en: '| `%` | Remainder (modulus) |'
  id: totrans-768
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 取余（模运算） |'
- en: '| `**` | Power |'
  id: totrans-769
  prefs: []
  type: TYPE_TB
  zh: '| `**` | 幂 |'
- en: '| `<<` | Left shift |'
  id: totrans-770
  prefs: []
  type: TYPE_TB
  zh: '| `<<` | 左移 |'
- en: '| `>>` | Right shift |'
  id: totrans-771
  prefs: []
  type: TYPE_TB
  zh: '| `>>` | 右移 |'
- en: '| `<<<` | Unsigned left shift |'
  id: totrans-772
  prefs: []
  type: TYPE_TB
  zh: '| `<<<` | 无符号左移 |'
- en: '| `>>>` | Unsigned right shift |'
  id: totrans-773
  prefs: []
  type: TYPE_TB
  zh: '| `>>>` | 无符号右移 |'
- en: '| `&` | Bitwise AND |'
  id: totrans-774
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 位与操作 |'
- en: '| `^` | Bitwise XOR |'
  id: totrans-775
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 位异或操作 |'
- en: '| `&#124;` | Bitwise OR |'
  id: totrans-776
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 位或操作 |'
- en: '| `~` | Bitwise NOT |'
  id: totrans-777
  prefs: []
  type: TYPE_TB
  zh: '| `~` | 位非操作 |'
- en: '| `&&` | Logical AND |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | 逻辑与 |'
- en: '| `&#124;&#124;` | Logical OR |'
  id: totrans-779
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | 逻辑或操作 |'
- en: '| `!` | Logical NOT |'
  id: totrans-780
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 逻辑非 |'
- en: '| `,` | Comma operator, evaluates all operands and returns last |'
  id: totrans-781
  prefs: []
  type: TYPE_TB
  zh: '| `,` | 逗号运算符，评估所有操作数并返回最后一个 |'
- en: '| `delete X` | Delete an object, property, index |'
  id: totrans-782
  prefs: []
  type: TYPE_TB
  zh: '| `delete X` | 删除对象、属性或索引 |'
- en: '| `typeof` | Return string indicating type of operand |'
  id: totrans-783
  prefs: []
  type: TYPE_TB
  zh: '| `typeof` | 返回表示操作数类型的字符串 |'
- en: '| `void` | Create an expression without a return value |'
  id: totrans-784
  prefs: []
  type: TYPE_TB
  zh: '| `void` | 创建一个没有返回值的表达式 |'
- en: '| `in` | Return boolean if property in object |'
  id: totrans-785
  prefs: []
  type: TYPE_TB
  zh: '| `in` | 如果对象中有该属性，则返回布尔值 |'
- en: '| `instanceof` | Return boolean if object instance of type |'
  id: totrans-786
  prefs: []
  type: TYPE_TB
  zh: '| `instanceof` | 如果对象是某类型的实例，则返回布尔值 |'
- en: '| `new` | Create a new instance of a type |'
  id: totrans-787
  prefs: []
  type: TYPE_TB
  zh: '| `new` | 创建一个类型的新实例 |'
- en: '| `...` | *Spread* sequence into array or parameters |'
  id: totrans-788
  prefs: []
  type: TYPE_TB
  zh: '| `...` | 将*spread*序列展开为数组或参数 |'
- en: Conditionals
  id: totrans-789
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'ES6 has an `if` statement with zero or more `else if` statements, and an optional
    `else` statement at the end:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: ES6支持带零个或多个`else if`语句以及可选的结尾`else`语句的`if`语句：
- en: '[PRE82]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'ES6 supports the following tests: `>`, `>=`, `<`, `<=`, `==`, `!=`, `===`,
    and `!==`. For boolean operators use `&&`, `||`, and `!` for and, or, and not
    respectively.'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: ES6支持以下测试：`>`, `>=`, `<`, `<=`, `==`, `!=`, `===`, 和 `!==`。对于布尔运算符，使用`&&`、`||`和`!`分别表示与、或和非。
- en: 'For `==` and `!=`, ES6 tries to compare numeric values of the operands if they
    have differing types, hence:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`==`和`!=`，如果操作数具有不同的类型，ES6会尝试比较其数值，因此：
- en: '[PRE83]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'If this bothers you (and it should), use the *strict* equality operators (`===`
    and `!==`):'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这让你感到不适（确实应该），请使用*严格*相等运算符（`===`和`!==`）：
- en: '[PRE84]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Short Circuiting
  id: totrans-797
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 短路
- en: 'The `and` statement will *short circuit* if it evaluates to false:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '`and`语句如果求值为false将会*短路*：'
- en: '[PRE85]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Likewise, the `or` statement will short circuit when something evaluates to
    true:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当某些条件求值为true时，`or`语句会短路：
- en: '[PRE86]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Ternary Operator
  id: totrans-802
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三元运算符
- en: 'ES6 has a ternary operator. Instead of writing:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: ES6具有三元运算符。不需要编写：
- en: '[PRE87]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We can write:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样写：
- en: '[PRE88]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Switch
  id: totrans-807
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Switch
- en: 'ES6 supports the switch statement:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: ES6支持switch语句：
- en: '[PRE89]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Looping
  id: totrans-810
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'There are various ways to iterate:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种各样的迭代方式：
- en: '`for ... in` - Iterates over the properties of an object. This only walks through
    properties that have `[[Enumerable]]` set to `true`.'
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for ... in` - 遍历对象的属性。这仅遍历具有`[[Enumerable]]`设置为`true`的属性。'
- en: '`for ... of` - Iterates over the items of a collection. Any object which has
    the `[Symbol.iterator]` property can be iterated with this method.'
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for ... of` - 遍历集合的项。任何具有`[Symbol.iterator]`属性的对象都可以使用此方法进行迭代。'
- en: '`forEach` is a method on the `Array` object. It takes a callback that is invoked
    for every item of the array.'
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach`是`Array`对象上的方法。它接受一个回调函数，对数组的每个项都调用该函数。'
- en: 'There is also a `while` loop:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`while`循环：
- en: '[PRE90]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'And a `do ... while` loop:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`do ... while`循环：
- en: '[PRE91]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Iteration
  id: totrans-819
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代
- en: We can make a class that knows how to iterate. We have to provide a method for
    `[Symbol.iterator]`, and the result of that method needs to have a `next` method.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个知道如何迭代的类。我们必须提供一个 `[Symbol.iterator]` 方法，并且该方法的结果需要有一个 `next` 方法。
- en: 'Here is an example of creating a class for iteration:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个创建迭代类的示例：
- en: '[PRE92]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The result of `next` should be an object that indicates whether looping is finished
    in the `done` property, and returns the item of iteration in the `value` property.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '`next` 的结果应该是一个对象，该对象指示循环是否完成（在 `done` 属性中），并在 `value` 属性中返回迭代项。'
- en: 'And here we use it in a `for .. of` loop:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for .. of` 循环中使用它：
- en: '[PRE93]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We can also loop with an object literal:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用对象字面量循环：
- en: '[PRE94]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Use the iterator in a loop:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中使用迭代器：
- en: '[PRE95]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Exceptions
  id: totrans-830
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: 'ES6 allows us to handle exceptions should they occur:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 允许我们处理异常，如果发生异常的话：
- en: '[PRE96]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'If there is a `finally` statement, it executes after the other blocks, regardless
    of whether and exception occurred:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有 `finally` 语句，则无论是否发生异常，它都会在其他块之后执行：
- en: '[PRE97]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Throwing Errors
  id: totrans-835
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抛出错误
- en: 'ES6 allows us to throw errors as well:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 也允许我们抛出错误：
- en: '[PRE98]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Error Types
  id: totrans-838
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误类型
- en: 'There are various built-in error types:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种内置错误类型：
- en: '`EvalError` - Not used in ES6, available for backward compatibility'
  id: totrans-840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EvalError` - 在 ES6 中未使用，仅用于向后兼容性'
- en: '`RangeError` - A value that is out of the set of allowed values'
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RangeError` - 超出允许值集的值'
- en: '`ReferenceError` - Error for referring to a non valid reference (`let val =
    badRef`)'
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReferenceError` - 引用无效引用时出错（`let val = badRef`）'
- en: '`SyntaxError` - Error when syntax is incorrect (`foo bar`)'
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SyntaxError` - 语法不正确时出错（`foo bar`）'
- en: '`TypeError` - Error when type of value is incorrect (`undefined.junk()`)'
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypeError` - 当值的类型不正确时出错（`undefined.junk()`）'
- en: '`URIError` - Error when URI encoding/decoding goes awry (`decodeURI(''%2'')`)'
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URIError` - 当 URI 编码/解码出错时出错（`decodeURI(''%2'')`）'
- en: Generators
  id: totrans-846
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器
- en: Iterators that use `function*` and `yield`, rather than normal `function` and
    `return` are *generators*. They generate values on the fly as they are iterated
    over. Following a `yield` statement, the state of the function is frozen.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `function*` 和 `yield` 而不是普通的 `function` 和 `return` 的迭代器是*生成器*。它们在迭代时即时生成值。在
    `yield` 语句之后，函数的状态被冻结。
- en: '[PRE99]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Using a generator:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成器：
- en: '[PRE100]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Modules
  id: totrans-851
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: 'A module is a JavaScript file. To use object in other files, we need to *export*
    the objects. Here we create a `fib.js` file and export the generator:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是一个 JavaScript 文件。要在其他文件中使用对象，我们需要*导出*对象。在这里，我们创建一个 `fib.js` 文件并导出生成器：
- en: '[PRE101]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Using Modules
  id: totrans-854
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模块
- en: 'We can load exported object using the `import` statement:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `import` 语句加载导出的对象：
- en: '[PRE102]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Note
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'As of now, support for this feature is limited (available behind flag in Chrome
    60, Edge 38, Firefox 54 and up). To use imports in non-modern browsers or in node,
    we need to use Babel to get support:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，对此功能的支持有限（在 Chrome 60、Edge 38、Firefox 54 及更高版本中通过标志可用）。要在非现代浏览器或节点中使用导入，我们需要使用
    Babel 来获得支持：
- en: '[PRE103]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Promises
  id: totrans-860
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承诺
- en: Promises are objects that allow for asynchronous programming. They are an alternative
    for callbacks. If you know that a value might be available in the future, a promise
    can represent that.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺是允许进行异步编程的对象。它们是回调的替代品。如果你知道一个值可能在未来可用，那么承诺可以表示这一点。
- en: 'There are three states for a promise:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺有三种状态：
- en: Pending - result is not ready
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂起 - 结果尚未准备好
- en: Fulfilled - result is ready
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已实现 - 结果已准备好
- en: Rejected - an error occurred
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已拒绝 - 发生错误
- en: On the promise object a `then` method will be called to move the state to either
    fulfilled or rejected.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺对象上将调用 `then` 方法来将状态移动到已实现或已拒绝。
- en: 'An async function that implements a promise allows us to *chain* a `then` and
    a `catch` method:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 实现承诺的异步函数允许我们*链接*`then` 和 `catch` 方法：
- en: '[PRE104]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Promise Properties
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺属性
- en: '| Property | Description |'
  id: totrans-870
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-871
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Promise.length` | Return `1`, number of constructor arguments |'
  id: totrans-872
  prefs: []
  type: TYPE_TB
  zh: '| `Promise.length` | 返回 `1`，构造函数参数的数量 |'
- en: '| `Promise.name` | value: `Promise` |'
  id: totrans-873
  prefs: []
  type: TYPE_TB
  zh: '| `Promise.name` | 值：`Promise` |'
- en: '| `Promise.prototype` | Prototype for `Promise` |'
  id: totrans-874
  prefs: []
  type: TYPE_TB
  zh: '| `Promise.prototype` | `Promise` 的原型 |'
- en: Promise Methods
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺方法
- en: '| Method | Description |'
  id: totrans-876
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-877
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Promise.all(promises)` | Return `Promise` that returns when `promises` are
    fulfilled, or rejects if any of them reject. |'
  id: totrans-878
  prefs: []
  type: TYPE_TB
  zh: '| `Promise.all(promises)` | 返回一个 `Promise`，在 `promises` 全部实现时返回，或者在其中任何一个拒绝时拒绝。
    |'
- en: '| `Promise.race(promises)` | Return `Promise` that returns when any of the
    `promises` reject or fulfill |'
  id: totrans-879
  prefs: []
  type: TYPE_TB
  zh: '| `Promise.race(promises)` | 返回一个 `Promise`，在任何一个 `promises` 拒绝或实现时返回 |'
- en: '| `Promise.reject(reason)` | Return `Promise` that rejects with `reason` |'
  id: totrans-880
  prefs: []
  type: TYPE_TB
  zh: '| `Promise.reject(reason)` | 返回一个以`reason`为参数拒绝的`Promise` |'
- en: '| `Promise.resolve(value)` | Return a `Promise` that fulfills with `value`.
    If `value` has a `then` method, it will return it''s final state |'
  id: totrans-881
  prefs: []
  type: TYPE_TB
  zh: '| `Promise.resolve(value)` | 返回一个以`value`为参数完成的`Promise`。如果`value`有一个`then`方法，它将返回其最终状态
    |'
- en: Promise Prototype Methods
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: Promise原型方法
- en: '| Method | Description |'
  id: totrans-883
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-884
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `p.p.catch(func)` | Return new `Promise` with rejection handler `func` |'
  id: totrans-885
  prefs: []
  type: TYPE_TB
  zh: '| `p.p.catch(func)` | 返回具有拒绝处理程序`func`的新`Promise` |'
- en: '| `p.p.constructor()` | Return `Promise` function |'
  id: totrans-886
  prefs: []
  type: TYPE_TB
  zh: '| `p.p.constructor()` | 返回`Promise`函数 |'
- en: '| `p.p.then(fulfillFn, rejectFn)` | Return `Promise` that calls `fulfillFn(value)`
    on success, or `rejectFn(reason)` on failure |'
  id: totrans-887
  prefs: []
  type: TYPE_TB
  zh: '| `p.p.then(fulfillFn, rejectFn)` | 返回一个`Promise`，成功时调用`fulfillFn(value)`，失败时调用`rejectFn(reason)`
    |'
- en: Regular Expressions
  id: totrans-888
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式
- en: 'A regular expression allows you to match characters in strings. You can create
    then using the literal syntax. Between the slashes place the regular expression.
    Flags can be specified at the end:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式允许您在字符串中匹配字符。您可以使用文字语法创建它们。在斜杠之间放置正则表达式。标志可以在末尾指定：
- en: '[PRE105]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'You can use the `match` method on a string:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在字符串上使用`match`方法：
- en: '[PRE106]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Or the `exec` method on a regex:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 或在正则表达式上使用`exec`方法：
- en: '[PRE107]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: If there is a match it returns an array. The 0 position is the matched portion,
    the remaining items correspond to the captured groups. These are specified with
    parentheses. You can just count the left parentheses (unless they are escaped)
    in order. Index 1 will be the group of the first parenthesis, index 2 will be
    the second left parenthesis group, etc.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匹配成功，它将返回一个数组。位置0是匹配的部分，其余项目对应于捕获的组。这些用括号指定。您只需计算左括号（除非它们被转义）的数量。索引1将是第一个括号的组，索引2将是第二个左括号的组，依此类推。
- en: 'You can also call the constructor:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以调用构造函数：
- en: '[PRE108]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: RegExp Flags
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式标志
- en: '| Flag | Description |'
  id: totrans-899
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 描述 |'
- en: '| --- | --- |'
  id: totrans-900
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `g` | Match *globally*, returning all matches, not just first |'
  id: totrans-901
  prefs: []
  type: TYPE_TB
  zh: '| `g` | *全局*匹配，返回所有匹配项，而不仅仅是第一个 |'
- en: '| `i` | *Ignore* case when matching |'
  id: totrans-902
  prefs: []
  type: TYPE_TB
  zh: '| `i` | *忽略*大小写匹配 |'
- en: '| `m` | Treat newlines as breaks for `^` and `$`, allowing *multi line* matching
    |'
  id: totrans-903
  prefs: []
  type: TYPE_TB
  zh: '| `m` | 将换行符视为`^`和`$`的断点，允��*多行*匹配 |'
- en: '| `y` | *Sticky* match, start looking from `r.lastIndex` property |'
  id: totrans-904
  prefs: []
  type: TYPE_TB
  zh: '| `y` | *粘性*匹配，从`r.lastIndex`属性开始查找 |'
- en: '| `u` | *Unicode* match |'
  id: totrans-905
  prefs: []
  type: TYPE_TB
  zh: '| `u` | *Unicode*匹配 |'
- en: Character Classes
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类
- en: '| Character | Description |'
  id: totrans-907
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-908
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\d` | Match one digit (`[0-9]`) |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 匹配一个数字（`[0-9]`） |'
- en: '| `\D` | Match one non-digit (`[^0-9]`) |'
  id: totrans-910
  prefs: []
  type: TYPE_TB
  zh: '| `\D` | 匹配一个非数字（`[^0-9]`） |'
- en: '| `\w` | Match one *word* character (`[0-9a-zA-z]`) |'
  id: totrans-911
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 匹配一个*单词*字符（`[0-9a-zA-z]`） |'
- en: '| `\W` | Match one non-word character (`[^0-9a-zA-z]`) |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
  zh: '| `\W` | 匹配一个非单词字符（`[^0-9a-zA-z]`） |'
- en: '| `\s` | Match one *space* character |'
  id: totrans-913
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 匹配一个*空格*字符 |'
- en: '| `\S` | Match one non-space character |'
  id: totrans-914
  prefs: []
  type: TYPE_TB
  zh: '| `\S` | 匹配一个非空格字符 |'
- en: '| `\b` | Match word boundary |'
  id: totrans-915
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 匹配单词边界 |'
- en: '| `\B` | Match non-word boundary |'
  id: totrans-916
  prefs: []
  type: TYPE_TB
  zh: '| `\B` | 匹配非单词边界 |'
- en: '| `\t`, `\r`, `\v`, `\f` | Match one tab, carriage return, vertical tab, or
    line feed respectively |'
  id: totrans-917
  prefs: []
  type: TYPE_TB
  zh: '| `\t`, `\r`, `\v`, `\f` | 分别匹配一个制表符、回车符、垂直制表符或换行符 |'
- en: '| `\0` | Match one null character |'
  id: totrans-918
  prefs: []
  type: TYPE_TB
  zh: '| `\0` | 匹配一个空字符 |'
- en: '| `\cCHAR` | Match one control character. Where `CHAR` is character |'
  id: totrans-919
  prefs: []
  type: TYPE_TB
  zh: '| `\cCHAR` | 匹配一个控制字符。其中`CHAR`是字符 |'
- en: '| `\xHH` | Match one character with hex code `HH` |'
  id: totrans-920
  prefs: []
  type: TYPE_TB
  zh: '| `\xHH` | 匹配一个具有十六进制代码`HH`的字符 |'
- en: '| `\uHHHH` | Match one UTF-16 character with hex code `HHHH` |'
  id: totrans-921
  prefs: []
  type: TYPE_TB
  zh: '| `\uHHHH` | 匹配一个具有十六进制代码`HHHH`的UTF-16字符 |'
- en: '| `\u{HHHH}` | Match one unicode character with hex code `HHHH` (use `u` flag)
    |'
  id: totrans-922
  prefs: []
  type: TYPE_TB
  zh: '| `\u{HHHH}` | 匹配一个具有十六进制代码`HHHH`的Unicode字符（使用`u`标志） |'
- en: Syntax Characters
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 语法字符
- en: '| Character | Description |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-925
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `^` | Match beginning of line (note different in character class) |'
  id: totrans-926
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 匹配行首（请注意字符类中的不同） |'
- en: '| `$` | Match end of line |'
  id: totrans-927
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 匹配行尾 |'
- en: '| `a&#124;b` | Match `a` or `b` |'
  id: totrans-928
  prefs: []
  type: TYPE_TB
  zh: '| `a&#124;b` | 匹配`a`或`b` |'
- en: '| `[abet]` | *Character class* match one of `a`, `b`, `e`, or `t` |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
  zh: '| `[abet]` | *字符类*匹配`a`、`b`、`e`或`t`中的一个 |'
- en: '| `[^abe]` | `^` negates matches in character class. One of not `a`, `b`, or
    `e` |'
  id: totrans-930
  prefs: []
  type: TYPE_TB
  zh: '| `[^abe]` | `^`在字符类中否定匹配。不是`a`、`b`或`e`中的一个 |'
- en: '| `\[` | *Escape*. Capture literal `[`. The following need to be escaped `^
    $ \ . * + ? ( ) [ ] { } &#124;` |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
  zh: '| `\[` | *转义*。捕获文字`[`。以下需要转义`^ $ \ . * + ? ( ) [ ] { } &#124;` |'
- en: '| `.` | Match one character except newline |'
  id: totrans-932
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 匹配除换行符之外的一个字符 |'
- en: '| `a?` | Match `a` zero or one time (`a{0,1}`) (note different following `*`,
    `+`, `?`, `}`) |'
  id: totrans-933
  prefs: []
  type: TYPE_TB
  zh: '| `a?` | 匹配`a`零次或一次（`a{0,1}`）（请注意后面的`*`、`+`、`?`、`}`不同） |'
- en: '| `a*` | Match `a` zero or more times (`a{0,}`) |'
  id: totrans-934
  prefs: []
  type: TYPE_TB
  zh: '| `a*` | 匹配`a`零次或多次（`a{0,}`） |'
- en: '| `a+` | Match `a` one or more times (`a{1,}`) |'
  id: totrans-935
  prefs: []
  type: TYPE_TB
  zh: '| `a+` | 匹配一个或多个 `a`（`a{1,}`） |'
- en: '| `a{3}` | Match `a` three times |'
  id: totrans-936
  prefs: []
  type: TYPE_TB
  zh: '| `a{3}` | 匹配三次 `a` |'
- en: '| `a{3,}` | Match `a` three or more times |'
  id: totrans-937
  prefs: []
  type: TYPE_TB
  zh: '| `a{3,}` | 匹配三次或更多次 `a` |'
- en: '| `a{3,5}` | Match `a` three to five times |'
  id: totrans-938
  prefs: []
  type: TYPE_TB
  zh: '| `a{3,5}` | 匹配三到五次 `a` |'
- en: '| `b.*?n` | `?` match non-greedy. ie from `banana` return `ban` instead of
    `banan` |'
  id: totrans-939
  prefs: []
  type: TYPE_TB
  zh: '| `b.*?n` | `?` 匹配非贪婪。例如从 `banana` 中返回 `ban` 而不是 `banan` |'
- en: '| `(Paul)` | *Capture* match in group. Captured result will be in position
    1 `exec` |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
  zh: '| `(Paul)` | *捕获* 匹配在组中。捕获的结果将在 `exec` 中的位置 1 |'
- en: '| `(?:Paul)` | Match `Paul` but don''t capture. Result will only be in position
    0 in `exec` |'
  id: totrans-941
  prefs: []
  type: TYPE_TB
  zh: '| `(?:Paul)` | 匹配 `Paul` 但不捕获。结果仅在 `exec` 中的位置 0 |'
- en: '| `\NUM` | *Backreference* to match previous capture group. `/<(\w+)>(.*)<\/\1>/`
    will capture an xml tag name in 1 and the content in 2 |'
  id: totrans-942
  prefs: []
  type: TYPE_TB
  zh: '| `\NUM` | *反向引用* 以匹配先前捕获的组。`/<(\w+)>(.*)<\/\1>/` 将在 1 中捕获 xml 标记名称，在 2 中捕获内容
    |'
- en: '| `Foo(?=script)` | *Assertion* match `Foo` only if followed by `script` (don''t
    capture `script`) |'
  id: totrans-943
  prefs: []
  type: TYPE_TB
  zh: '| `Foo(?=script)` | *断言* 仅在后面跟着 `script` 时匹配 `Foo`（不捕获 `script`） |'
- en: '| `Foo(?!script)` | *Assertion* match `Foo` only if not followed by `script`
    |'
  id: totrans-944
  prefs: []
  type: TYPE_TB
  zh: '| `Foo(?!script)` | *断言* 仅当后面不跟着 `script` 时匹配 `Foo` |'
- en: RegExp Properties
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式属性
- en: '| Property | Description |'
  id: totrans-946
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-947
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `RegExp.length` | value: `2` |'
  id: totrans-948
  prefs: []
  type: TYPE_TB
  zh: '| `RegExp.length` | 值：`2` |'
- en: '| `RegExp.name` | value: `RegExp` |'
  id: totrans-949
  prefs: []
  type: TYPE_TB
  zh: '| `RegExp.name` | 值：`RegExp` |'
- en: '| `RegExp.prototype` | value: `/(?:)/` |'
  id: totrans-950
  prefs: []
  type: TYPE_TB
  zh: '| `RegExp.prototype` | 值：`/(?:)/` |'
- en: '| `r.p.flags` | Return flags for regular expression |'
  id: totrans-951
  prefs: []
  type: TYPE_TB
  zh: '| `r.p.flags` | 返回正则表达式的标志 |'
- en: '| `r.p.global` | Return boolean if global (`g`) flag is used |'
  id: totrans-952
  prefs: []
  type: TYPE_TB
  zh: '| `r.p.global` | 如果使用了全局标志 (`g`)，则返回布尔值 |'
- en: '| `r.p.ignoreCase` | Return boolean if ignore case (`i`) flag is used |'
  id: totrans-953
  prefs: []
  type: TYPE_TB
  zh: '| `r.p.ignoreCase` | 如果使用了忽略大小写 (`i`) 标志，则返回布尔值 |'
- en: '| `r.p.multiline` | Return boolean if multi line (`m`) flag is used |'
  id: totrans-954
  prefs: []
  type: TYPE_TB
  zh: '| `r.p.multiline` | 如果使用了多行 (`m`) 标志，则返回布尔值 |'
- en: '| `r.p.source` | Return string value for regular expression |'
  id: totrans-955
  prefs: []
  type: TYPE_TB
  zh: '| `r.p.source` | 返回正则表达式的字符串值 |'
- en: '| `r.p.sticky` | Return boolean if sticky (`y`) flag is used |'
  id: totrans-956
  prefs: []
  type: TYPE_TB
  zh: '| `r.p.sticky` | 如果使用了粘性 (`y`) 标志，则返回布尔值 |'
- en: '| `r.p.unicode` | Return boolean if unicode (`u`) flag is used |'
  id: totrans-957
  prefs: []
  type: TYPE_TB
  zh: '| `r.p.unicode` | 如果使用了 unicode (`u`) 标志，则返回布尔值 |'
- en: '| `r.sticky` | Return integer specifying where to start looking for next match
    |'
  id: totrans-958
  prefs: []
  type: TYPE_TB
  zh: '| `r.sticky` | 返回指定从哪里开始查找下一个匹配项的整数 |'
- en: RegExp Prototype Methods
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式原型方法
- en: '| Method | Description |'
  id: totrans-960
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-961
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `r.p.compile()` | Not useful, just create a `RegExp` |'
  id: totrans-962
  prefs: []
  type: TYPE_TB
  zh: '| `r.p.compile()` | 无用，只是创建一个 `RegExp` |'
- en: '| `r.p.constructor()` | Return constructor for `RegExp` |'
  id: totrans-963
  prefs: []
  type: TYPE_TB
  zh: '| `r.p.constructor()` | 返回 `RegExp` 的构造函数 |'
- en: '| `r.p.exec(s)` | Return array with matches found in string `s`. Index 0 is
    matched item, other items correspond to capture parentheses. Updates `r` properties
    |'
  id: totrans-964
  prefs: []
  type: TYPE_TB
  zh: '| `r.p.exec(s)` | 返回在字符串 `s` 中找到的匹配数组。索引 0 是匹配项，其他项对应捕获括号。更新 `r` 的属性 |'
- en: '| `r.p.test(s)` | Return boolean if `r` matches against string `s` |'
  id: totrans-965
  prefs: []
  type: TYPE_TB
  zh: '| `r.p.test(s)` | 如果 `r` 与字符串 `s` 匹配，则返回布尔值 |'
- en: '| `r.p.toString()` | Return string representation of `r` |'
  id: totrans-966
  prefs: []
  type: TYPE_TB
  zh: '| `r.p.toString()` | 返回 `r` 的字符串表示形式 |'
