- en: Tiny ES6 Notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From: [mattharrison/Tiny-es6-Notebook](https://github.com/mattharrison/Tiny-es6-Notebook)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is not so much an instructional manual, but rather notes, tables, and examples
    for ECMAScript2015 or ES6 syntax (aka modern JavaScript). It was created by the
    author as an additional resource during training, meant to be distributed as a
    physical notebook. Participants (who favor the physical characteristics of dead
    tree material) could add their own notes, thoughts, and have a valuable reference
    of curated examples.
  prefs: []
  type: TYPE_NORMAL
- en: Strict Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ES6 modules are always strict according to the spec. There should be no need
    to place this code at the top of your code to enable strict mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Strict mode does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Requires explicit creation of global variables (via `let`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throws exceptions when assigning to a non-writable variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throws errors when deleting undeletable properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throws `SyntaxError` if duplicating function parameter names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throws a `SyntaxError` when putting a `0` in front of a numeric literal (use
    `0o` for an octal)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throws a `TypeError` when setting a property on a primitive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are various ways to declare a variable in ES6\. Function local variables
    are declared with `var`, block variables are declared with `let`, and constant
    variables are declared with `const`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Constant variables are not necessarily immutable (their value can change), but
    they can't be rebound to another object or primitive.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: A good rule of thumb is to use `const` as the default declaration. Use `let`
    only if needed and try to stay away from `var`.
  prefs: []
  type: TYPE_NORMAL
- en: Scoping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following function illustrates scoping with the `let` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use a `var` declaration we see different behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Destructuring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can pull out variables from a list by *destructuring*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Default values can be provided during destructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the list using the *spread* operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also the notion of object destructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Default values can also be provided for object destructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also rename the properties during object destrucruting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '...and we can combine renaming with default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two types of data in ES6, primitives and objects. ES6 has six primitive,
    immutable data types: string, number, boolean, null, undefined, and symbol (new
    in ECMAScript 2015). When we use the literals we get a primitive. ES6 does *autoboxing*
    when we invoke a method on them. There are also object wrappers for string, number,
    boolean, and symbol. They are `String`, `Number`, `Boolean`, and `Symbol` respectively.
    If you call the constructor with `new`, you will get back on object, to get the
    primitive value call `.valueOf()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`null`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A value that often represents a place where an object will be expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Even though `null` is a primitive, the result of `typeof` is an object. This
    is according to the spec [[1]](#id2) (though it is considered a wart).
  prefs: []
  type: TYPE_NORMAL
- en: '| [[1]](#id1) | [http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator-runtime-semantics-evaluation](http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator-runtime-semantics-evaluation)
    |'
  prefs: []
  type: TYPE_TB
- en: '`undefined`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A property of the global object whose value is the primitive value `undefined`.
    A variable that has been declared but not assigned has the value of `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `typeof` of an `undefined` value is the string `"undefined"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful of loose equality and strict equality comparisons with `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Boolean
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A boolean variable can have a value of `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can coerce other values to booleans with the `Boolean` wrapper. Most values
    are truthy:'
  prefs: []
  type: TYPE_NORMAL
- en: Truthy and Falsey values
  prefs: []
  type: TYPE_NORMAL
- en: '| Truthy | Falsey |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `true` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| Most objects | `null` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `0` or `-0` |'
  prefs: []
  type: TYPE_TB
- en: '| `"string"` | `""` (empty string) |'
  prefs: []
  type: TYPE_TB
- en: '| `[]` (empty list) | `undefined` |'
  prefs: []
  type: TYPE_TB
- en: '| `{}` (empty object) |   |'
  prefs: []
  type: TYPE_TB
- en: '| `Boolean(new Boolean(false))` |   |'
  prefs: []
  type: TYPE_TB
- en: Note calling `new Boolean(obj)` (ie as a constructor) returns a `Boolean` object,
    whereas calling `Boolean(obj)` (as if it were a function) returns a primitive
    `true` or `false`. Also, note that coercing any object to a boolean coerces to
    `true`, even if the internal value was `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common technique to get primitive boolean values is to use a *double negation*
    rather than using `Boolean`. This is not necessary in an `if` statement. But,
    if you want to create a variable that holds a boolean value (or return one), this
    trick can come in handy. The `!` (not operator) coerces the value to a negated
    boolean, so if we apply it again, we should get the correct boolean value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Boolean Properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Boolean.length` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `Boolean.prototype` | The `Boolean` prototype |'
  prefs: []
  type: TYPE_TB
- en: Boolean Prototype Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `b.p.constructor()` | The `Boolean` object |'
  prefs: []
  type: TYPE_TB
- en: '| `b.p.toString()` | String with value `"true"` or `"false"` |'
  prefs: []
  type: TYPE_TB
- en: '| `b.p.valueOf()` | Primitive boolean value |'
  prefs: []
  type: TYPE_TB
- en: Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ES6 adds the ability to have object keys created from variable names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Array spread is an ES6 feature. Object spread is not, though many JS engines
    support it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to include properties in another object, we can do a shallow *spread*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition there is support for *computed property keys*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a shorthand for *method definition*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically we would wrap these in a function to create the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define properties in an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`Object` can be called as a constructor (with `new`) and as a function. Both
    behave the same and wrap what they were called with with an object.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the methods `Object.defineProperties` and `Object.defineProperty`, we
    can set properties using *data descriptors* or *accessor descriptors*.
  prefs: []
  type: TYPE_NORMAL
- en: 'An accessor descriptor allows us to create functions (`get` and `set`) to define
    member access. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'A data descriptor allows us to create a value for a property and to set whether
    it is writeable. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If `configurable` has the value of `false`, then no value besides `writeable`
    can be changed with `Object.defineProperty`. Also, the property cannot be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The `enumerable` property determines if the property shows up in `Object.keys()`
    or a `for ... in` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a accessor descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'These can be specified on classes as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The following tables list the properties of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Object Properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.prototype` | The objects prototype |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.prototype.__proto__` | value: `null` |'
  prefs: []
  type: TYPE_TB
- en: Object Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.assign(target, ...sources)` | Copy properties from `sources` into
    `target` |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.create(obj, [prop])` | Create a new object with `prototype` of `obj`
    and properties from `prop` |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.defineProperties( obj, prop)` | Update properties of `obj` from `prop`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.defineProperty( obj, name, desc)` | Create a property named `name`
    on `obj` with descriptor `desc` |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.freeze(obj)` | Prevents future changes to properties (adding of removing)
    of `obj`. Strict mode throws errors, otherwise silent failure when trying to tweak
    properties later |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.getOwnProperty Descriptor(obj, name)` | Get the descriptor for `name`
    on `obj`. Can''t be in prototype chain. |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.getOwnProperty Descriptors( obj)` | Enumerate descriptors on `obj`
    that aren''t in prototype chain. |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.getOwnProperty Names(obj)` | Return array of string of string properties
    found on `obj` that aren''t in prototype chain |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.getOwnProperty Symbols(obj)` | Return array of symbols of symbol
    properties found on `obj` that aren''t in prototype chain |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.getPrototypeOf( obj)` | Return the prototype of `obj` |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.is(a, b)` | Boolean whether the values are the same. Doesn''t coerce
    like `==`. Also, unlike `===`, doesn''t treat `-0` equal to `+0`, or `NaN` not
    equal to `NaN`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.isExtensible(obj)` | Boolean whether the object can have properties
    added |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.isFrozen(obj)` | Boolean whether the object is frozen (frozen is
    also sealed and non-extensible) |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.isSealed(obj)` | Boolean whether the object is sealed (non-extensible,
    non-removable, but potentially writeable) |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.keys(obj)` | Enumerable properties given in `for ... in` loop that
    are not in prototype chain |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.preventExtensions( obj)` | No new properties directly (can be added
    to prototype), but can remove them |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.seal(obj)` | Prevent change of properties on an object. Note that
    the values can change. |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.setPrototypeOf(obj, proto)` | Set the `prototype` property of an
    object |'
  prefs: []
  type: TYPE_TB
- en: Object Prototype Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `o.p.constructor()` | The `Object` constructor |'
  prefs: []
  type: TYPE_TB
- en: '| `o.p.hasOwnProperty(prop)` | Boolean whether `prop` is a direct property
    of `o` (not in prototype chain) |'
  prefs: []
  type: TYPE_TB
- en: '| `o.p.isPrototypeOf(obj)` | Boolean whether `o` exists in `obj`''s prototype
    chain |'
  prefs: []
  type: TYPE_TB
- en: '| `o.p.propertyIs Enumerable(property)` | Boolean whether property is enumerable
    |'
  prefs: []
  type: TYPE_TB
- en: '| `o.p.toLocaleString()` | A string representing the object in locale |'
  prefs: []
  type: TYPE_TB
- en: '| `o.p.toString()` | A string representing the object |'
  prefs: []
  type: TYPE_TB
- en: '| `o.p.valueOf()` | Return primitive value |'
  prefs: []
  type: TYPE_TB
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`NaN`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`NaN` is a global property to represent *not a number*. This is the result
    of certain math failures, such as the square root of a negative number. The function
    `isNaN` will test whether a value is `NaN`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Infinity`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Infinity` is a global property to represent a very large number. There is
    also `-Infinity` for for a very large negative values.'
  prefs: []
  type: TYPE_NORMAL
- en: You can specify whole number literals as integers, hex, octal, or binary numbers.
    There is also support for creating float values. See the number types table.
  prefs: []
  type: TYPE_NORMAL
- en: Number types
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Integer | `14` |'
  prefs: []
  type: TYPE_TB
- en: '| Integer (Hex) | `0xe` |'
  prefs: []
  type: TYPE_TB
- en: '| Integer (Octal) | `0o16` |'
  prefs: []
  type: TYPE_TB
- en: '| Integer (Binary) | `0b1110` |'
  prefs: []
  type: TYPE_TB
- en: '| Float | `14.0` |'
  prefs: []
  type: TYPE_TB
- en: '| Float | `1.4e1` |'
  prefs: []
  type: TYPE_TB
- en: Called as a constructor (`new Number(obj)`), will return a `Number` object.
    When called as a function (without `new`), it will perform a type conversion to
    the primitive.
  prefs: []
  type: TYPE_NORMAL
- en: Number Properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Number.EPSILON` | Smallest value between numbers `2.220446049250313e-16`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Number.MAX_SAFE_INTEGER` | Largest integer `9007199254740991` (`2^53 - 1`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Number.MAX_VALUE` | Largest number `1.7976931348623157e+308` |'
  prefs: []
  type: TYPE_TB
- en: '| `Number.MIN_SAFE_INTEGER` | Most negative integer `-9007199254740991` (`-(2^53
    - 1)`) |'
  prefs: []
  type: TYPE_TB
- en: '| `Number.MIN_VALUE` | Smallest number `5e-324` |'
  prefs: []
  type: TYPE_TB
- en: '| `Number.NEGATIVE_INFINITY` | Negative overflow `-Infinity` |'
  prefs: []
  type: TYPE_TB
- en: '| `Number.NaN` | Not a number value `NaN` |'
  prefs: []
  type: TYPE_TB
- en: '| `Number.POSITIVE_INFINITY` | Positive overflow |'
  prefs: []
  type: TYPE_TB
- en: '| `Number.name` | value: `Number` |'
  prefs: []
  type: TYPE_TB
- en: '| `Number.prototype` | Prototype for `Number` constructor |'
  prefs: []
  type: TYPE_TB
- en: Number Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `n.isFinite(val)` | Test if `val` is finite |'
  prefs: []
  type: TYPE_TB
- en: '| `n.isInteger(val)` | Test if `val` is integer |'
  prefs: []
  type: TYPE_TB
- en: '| `n.isNaN(val)` | Test if `val` is `NaN` |'
  prefs: []
  type: TYPE_TB
- en: '| `n.isSafeInteger(val)` | Test if `val` is integer between safe values |'
  prefs: []
  type: TYPE_TB
- en: '| `n.parseFloat(s)` | Convert string, `s` to number (or `NaN`) |'
  prefs: []
  type: TYPE_TB
- en: '| `n.parseInt(s, [radix])` | Convert string, `s` to integer (or `NaN`) for
    given base (`radix`) |'
  prefs: []
  type: TYPE_TB
- en: Number Prototype Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `n.p.constructor()` |   |'
  prefs: []
  type: TYPE_TB
- en: '| `n.p.toExponential( [numDigits])` | Return a string in exponential notation
    with `numDigits` of precision |'
  prefs: []
  type: TYPE_TB
- en: '| `n.p.toFixed([digits])` | Return a string in fixed-point notation with `digits`
    of precision |'
  prefs: []
  type: TYPE_TB
- en: '| `n.p.toLocaleString([locales, [options]])` | Return a string representation
    in locale sensitive notation |'
  prefs: []
  type: TYPE_TB
- en: '| `n.p.toPrecision([numDigits])` | Return a string in fixed-point or exponential
    notation with `numDigits` of precision |'
  prefs: []
  type: TYPE_TB
- en: '| `n.p.toString([radix])` | Return a string representation. `radix` can be
    between `2` and `36` for indicating the base |'
  prefs: []
  type: TYPE_TB
- en: '| `n.p.valueOf()` | Return the primitive value of the number |'
  prefs: []
  type: TYPE_TB
- en: '`Math` Library'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ES6 has a built-in math library to perform common operations.
  prefs: []
  type: TYPE_NORMAL
- en: Math Properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.E` | value: `2.718281828459045` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.LN10` | value: `2.302585092994046` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.LN2` | value: `0.6931471805599453` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.LOG10E` | value: `0.4342944819032518` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.LOG2E` | value: `1.4426950408889634` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.PI` | value: `3.141592653589793` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.SQRT1_2` | value: `0.7071067811865476` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.SQRT2` | value: `1.4142135623730951` |'
  prefs: []
  type: TYPE_TB
- en: Math Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.abs(n)` | Compute absolute value |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.acos(n)` | Compute arccosine |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.acosh(n)` | Compute hyperbolic arccosine |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.asin(n)` | Compute arcsine |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.asinh(n)` | Compute hyperbolic arcsine |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.atan(n)` | Compute arctangent |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.atan2(y, x)` | Compute arctangent of quotient |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.atanh(n)` | Compute hyperbolic arctangent |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.cbrt(n)` | Compute cube root |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.ceil(n)` | Compute the smallest integer larger than `n` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.clz32(n)` | Compute count of leading zeros |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.cos(n)` | Compute cosine |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.cosh(n)` | Compute hyperbolic cosine |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.exp(x)` | Compute e to the x |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.expm1(x)` | Compute e to the x minux 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.floor(n)` | Compute largest integer smaller than `n` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.fround(n)` | Compute nearest float |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.hypot(x, [y], [...)` | Compute hypotenuse (square root of sums) |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.imul(x, y)` | Compute integer product |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.log(n)` | Compute natural log |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.log10(n)` | Compute log base 10 |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.log1p(n)` | Compute natural log of 1 + `n` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.log2(n)` | Compute log base 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.max(...)` | Compute maximum |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.min(...)` | Compute minimum |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.pow(x, y)` | Compute x to the y power |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.random()` | Random number between 0 and 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.round(n)` | Compute nearest integer |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.sign(n)` | Return `-1`, `0`, or `1` for negative, zero, or positive
    value of `n` |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.sin(n)` | Compute sine |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.sinh(n)` | Compute hyperbolic sine |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.sqrt(n)` | Compute square root |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.tan(n)` | Compute tangent |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.tanh(n)` | Compute hyperbolic tangent |'
  prefs: []
  type: TYPE_TB
- en: '| `Math.trunc(b)` | Compute integer value without decimal |'
  prefs: []
  type: TYPE_TB
- en: Built-in Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ES6 strings are series of UTF-16 code units. A string literal can be created
    with single or double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To make long strings you can use to backslash to signify that the string continues
    on the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively the `+` operator allows for string concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Template Literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using backticks, you can create *template literals*. These allow for interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that template literals can be multi-line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Raw Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need strings with backslashes in them, you can escape the backslash
    with a backslash (`/`) or you can use *raw* strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: String Properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `String.length` | value: `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `String.name` | value: `String` |'
  prefs: []
  type: TYPE_TB
- en: '| `String.prototype` | Prototype for `String` constructor |'
  prefs: []
  type: TYPE_TB
- en: Static String Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `String.fromCharCode(n1, ...)` | Return string containing characters from
    Unicode values `n1` |'
  prefs: []
  type: TYPE_TB
- en: '| `String.fromCodePoint(n1, ...)` | Return string containing characters from
    Unicode points `n1` |'
  prefs: []
  type: TYPE_TB
- en: '| `String.raw` | Create a raw template literal (follow this by your string
    surrounded by back ticks) |'
  prefs: []
  type: TYPE_TB
- en: String Prototype Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.anchor(aName)` | Return `<a name="aName">s</a>` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.big()` | Return `<big>s</big>` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.blink()` | Return `<blink>s</blink>` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.bold()` | Return `<b>s</b>` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.charAt(idx)` | Return string with character at `idx`. Empty string if
    invalid index |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.charCodeAt(idx)` | Return integer between 0 and 65535 for the UTF-16
    code. `NaN` if invalid index |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.codePointAt(idx)` | Return integer value for Unicode code point. `undefined`
    if invalid index |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.concat(s1, ...)` | Return concatenation of strings |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.constructor()` | String constructor |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.endsWith(sub, [length])` | Boolean if `s` (limited to `length` size)
    ends with `sub` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.fixed()` | Return `<tt>s</tt>` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.fontcolor(c)` | Return `<font color="c">s</font>` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.fontsize(num)` | Return `<font size="num">s</font>` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.includes(sub, [start])` | Boolean if `sub` found in `s` from `start`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.indexOf(sub, [start])` | Index of `sub` in `s` starting from `start`.
    `-1` if not found |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.italics()` | Return `<i>s</i>` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.lastIndexOf(sub, start)` | Return index of `sub` starting from rightmost
    `start` characters (default `+Infinity`). `-1` if not found |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.link(url)` | Return `<a href="url">s</a>` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.localeCompare( other, [locale, [option])` | Return `-1`, `0`, or `1`
    `s` comes before `other`, is equal to, or after |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.match(reg)` | Return an array with the whole match in index 0, remaining
    entries correspond to parentheses |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.normalize([unf])` | Return the Unicode Normalization Form of a string.
    `unf` can be `"NFC"`, `"NFD"`, `"NFKC"`, or `"NFKD"` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.repeat(num)` | Return `s` concatenated with itself `num` times |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.replace(this, that)` | Return a new string with replacing `this` with
    `that`. `this` can be a regular expression or a string. `that` can be a string
    or a function that takes `match`, a parameter for every parenthesized match, an
    index offset for the match, and the original string. It returns a new value. |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.search(reg)` | Return the index where the regular expression first matches
    `s` or `-1` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.slice(start, [end])` | Return string sliced at half open interval including
    `start` and up to be not including `end`. Negative values mean `s.length - val`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.small()` | Return `<small>s</small>` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.split([sep, [limit]])` | Return array with string broken into substrings
    around `sep`. `sep` may be a regular expression. `limit` determines the number
    of splits in the result. If the regular expression contains parentheses, then
    the matched portions are also included in the result. Use `s.join` to undo |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.startsWith(sub, [pos])` | Boolean if `s` (beginning at `pos` index)
    starts with `sub` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.strike()` | Return `<string>s</strike>` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.sub()` | Return `<sub>s</sub>` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.substr(pos, [length])` | Return substring starting at `pos` index (can
    be negative). `length` is the number of characters to include. |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.substring(start, [end])` | Return slice of string including `start`
    going up to be not including `end` (half-open). Negative values not allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.sup()` | Return `<sup>s</sup>` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.toLocaleLowerCase()` | Return lower case value according to local |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.toLocaleUpperCase()` | Return upper case value according to local |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.toLowerCase()` | Return lower case value |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.toString()` | Return string representation |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.toUpperCase()` | Return upper case value |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.trim()` | Return string with leading and trailing whitespace removed
    |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.trimLeft()` | Return string with leading whitespace removed |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.trimRight()` | Return string with trailing whitespace removed |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.valueOf()` | Return primitive value of string representation |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p[@@iterator]()` | Return an iterator for the string. Calling `.next()`
    on the iterator returns code points |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Many of the HTML generating methods create markup that is not compatible with
    HTML5.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ES6 arrays can be created with the literal syntax or by calling the `Array`
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays need not be dense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `includes` method is useful for checking membership on arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need the index number during iteration, the `entries` method gives us
    a list of index, item pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do index operations on arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that index operations do not support negative index values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In ES6 we can subclass `Array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can *slice* arrays using the `slice` method. Note that the slice returns
    an array, even if it has a single item. Note that the `slice` method can take
    negative indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Array Properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Array.length` | value: `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `Array.name` | value: `Array` |'
  prefs: []
  type: TYPE_TB
- en: '| `Array.prototype` | Prototype for `Array` constructor |'
  prefs: []
  type: TYPE_TB
- en: Array Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Array.from(iter, [func, [this]])` | Return a new `Array` from an iterable.
    `func` will be called on every item. `this` is a value to use for `this` when
    executing `func`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Array.isArray(item)` | Return boolean if `item` is an `Array` |'
  prefs: []
  type: TYPE_TB
- en: '| `Array.of(val, [..., valN])` | Return `Array` with values. Integer values
    are inserted, whereas `Array(3)`, creates an `Array` with three slots. |'
  prefs: []
  type: TYPE_TB
- en: Array Prototype Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.concat(val, [..., valN])` | Return a new `Array`, with values inserted.
    If value is array, the items are appended |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.copyWithin(target, [start, [end]])` | Return `a` mutated with items
    from `start` to `end` shallow copied into index `target` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.entries()` | Return array iterator |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.every(func, [this])` | Return boolean if `func(item, [idx, [a]])` is
    true for every item in array (`idx` is the index, and `a` is the array). `this`
    is the value of `this` for the function |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.fill(val, [start, [end]])` | Return `a` mutated, with `val` inserted
    from `start` index up to but not including `end` index. Index values may be negative
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.filter(func, [this])` | Return a new array of items from `a` where predicate
    `func(item, [idx, [a]])` is true. `this` is the value of `this` for the function
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.find(func, [this])` | Return first item (or `undefined`) from `a` where
    predicate `func(item, [idx, [a]])` is true. `this` is the value of `this` for
    the function |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.findIndex(func, [this])` | Return first index (or `-1`) from `a` where
    predicate `func(item, [idx, [a]])` is true. `this` is the value of `this` for
    the function |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.forEach(func, [this])` | Return `undefined`. Apply `func(item, [idx,
    [a]])` to every item of `a`. `this` is the value of `this` for the function |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.includes(val, [start])` | Return a boolean if `a` contains `val` starting
    from `start` index |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.indexOf(val, [start])` | Return first index (or `-1`) of `val` in `a`,
    starting from `start` index |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.join([sep])` | Return string with `sep` (default `'',''`) inserted between
    items |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.keys()` | Return iterator of index values (doesn''t skip sparse values)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.lastIndexOf(val, [start])` | Return last index (or `-1`) of `val` in
    `a`, searching backwards from `start` index |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.map(func, [this])` | Return new array with `func(item, [idx, [a]])`
    called on every item of `a`. `this` is the value of `this` for the function |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.pop()` | Return last item (or `undefined`) of `a` (mutates `a`) |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.push(val, [..., valN])` | Return new length of `a`. Add values to end
    of `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.reduce(func, [init])` | Return results of reduction. Call `func(accumulator,
    val, idx, a)` for every item. If `init` is provided, `accumulator` is set to it
    initially, otherwise `accumulator` is first item of `a`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.reduceRight(func, [init])` | Return results of reduction applied backwards
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.reverse()` | Return and mutate `a` in reverse order |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.shift()` | Return and remove first item from `a` (mutates `a`) |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.slice([start, [end]])` | Return shallow copy of `a` from `start` up
    to but not including `end`. Negative index values allowed |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.some(func, [this])` | Return boolean if `func(item, [idx, [a]])` is
    true for any item in array (`idx` is the index, and `a` is the array). `this`
    is the value of `this` for the function |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.sort([func])` | Return and mutate sorted `a`. Can use `func(a, b)` which
    returns `-1`, `0`, or `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.splice(start, [deleteCount, [item1, ..., itemN]])` | Return array with
    deleted objects. Mutate `a` at index `start`, remove `deleteCount` items, and
    insert `items`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.toLocaleString( [locales, [options]])` | Return a string representing
    array in locales |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.toString()` | Return a string representing array in locales |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.unshift([item1, ... itemN])` | Return length of `a`. Mutate `a` by inserting
    elements in front of `a`. (Will be in same order as appearing in call) |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.values()` | Return iterator with items in `a` |'
  prefs: []
  type: TYPE_TB
- en: ArrayBuffers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An `ArrayBuffer` holds generic byte based data. To manipulate the contents,
    we point a view (typed arrays or data views) at certain locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: ArrayBuffer Properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ArrayBuffer.length` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `ArrayBuffer.prototype` | The `ArrayBuffer` prototype |'
  prefs: []
  type: TYPE_TB
- en: ArrayBuffer Prototype Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.constructor()` | The `ArrayBuffer` object |'
  prefs: []
  type: TYPE_TB
- en: '| `a.p.slice(begin, [end])` | Return a new `ArrayBuffer` with copy of `a` from
    `begin` up to but not including `n` |'
  prefs: []
  type: TYPE_TB
- en: TypedArrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ES6 supports various flavors of *typed arrays*. These hold binary data, rather
    than ES6 objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few differences from normal arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: Items have the same type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The array is contiguous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is initialized with zeros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To put a typed array into a normal array, we can use the *spread* operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Typed Arrays
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Size (bytes) | Desctription | C type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Int8Array` | 1 | signed integer | `int8_t` |'
  prefs: []
  type: TYPE_TB
- en: '| `Uint8Array` | 1 | unsigned integer | `uint8_t` |'
  prefs: []
  type: TYPE_TB
- en: '| `Uint8ClampedArray` | 1 | unsigned integer | `uint8_t` |'
  prefs: []
  type: TYPE_TB
- en: '| `Int16Array` | 2 | signed integer | `int16_t` |'
  prefs: []
  type: TYPE_TB
- en: '| `Uint16Array` | 2 | unsigned integer | `unint16_t` |'
  prefs: []
  type: TYPE_TB
- en: '| `Int32Array` | 4 | signed integer | `int32_t` |'
  prefs: []
  type: TYPE_TB
- en: '| `Uint32Array` | 4 | unsigned integer | `unint32_t` |'
  prefs: []
  type: TYPE_TB
- en: '| `Float32Array` | 4 | 32 bit floating point | `float` |'
  prefs: []
  type: TYPE_TB
- en: '| `Float64Array` | 8 | 64 bit floating point | `float` |'
  prefs: []
  type: TYPE_TB
- en: 'The following `Array` methods are missing: `push`, `pop`, `shift`, `splice`,
    and `unshift`.'
  prefs: []
  type: TYPE_NORMAL
- en: There are also two extra methods found on `TypedArrays`
  prefs: []
  type: TYPE_NORMAL
- en: TypedArray Prototype Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `t.p.set(array, [offset])` | Return `undefined`. Copy `array` into `t` at
    `offset` location |'
  prefs: []
  type: TYPE_TB
- en: '| `t.p.subarray(start, [end])` | Return `TypeArray` with view of data in `t`
    starting at position `start` up to but not including `end`. Note that the `t`
    and the new object share the data. |'
  prefs: []
  type: TYPE_TB
- en: Data Views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `DataView` is another interface for interacting with an `ArrayBuffer`. If
    you need control over endianness, you should use this rather than a typed array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor supports a buffer and option offset and length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: DataView Properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `DataView.name` | `DataView` |'
  prefs: []
  type: TYPE_TB
- en: '| `DataView.prototype` | `DataView` constructor |'
  prefs: []
  type: TYPE_TB
- en: '| `DataView.prototype.buffer` | The underlying `ArrayBuffer` |'
  prefs: []
  type: TYPE_TB
- en: '| `DataView.prototype.byteLength` | The length of the view |'
  prefs: []
  type: TYPE_TB
- en: '| `DataView.prototype.byteOffset` | The offset of the view |'
  prefs: []
  type: TYPE_TB
- en: DataView Prototype Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getFloat32(offset, [littleEndian])` | Retrieve signed 32-bit float from
    `offset`. If `littleEndian` is `true` use litte endian format |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getFloat64(offset, [littleEndian])` | Retrieve signed 64-bit float from
    `offset`. If `littleEndian` is `true` use litte endian format |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getInt16(offset, [littleEndian])` | Retrieve signed 16-bit integer from
    `offset`. If `littleEndian` is `true` use litte endian format |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getInt32(offset, [littleEndian])` | Retrieve signed 32-bit integer from
    `offset`. If `littleEndian` is `true` use litte endian format |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getInt8(offset, [littleEndian])` | Retrieve signed 8-bit integer from
    `offset`. If `littleEndian` is `true` use litte endian format |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getUint16(offset, [littleEndian])` | Retrieve unsigned 16-bit integer
    from `offset`. If `littleEndian` is `true` use litte endian format |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getUint32(offset, [littleEndian])` | Retrieve unsigned 32-bit integer
    from `offset`. If `littleEndian` is `true` use litte endian format |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getUint8(offset, [littleEndian])` | Retrieve unsigned 8-bit integer
    from `offset`. If `littleEndian` is `true` use litte endian format |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setFloat32(offset, value, [littleEndian])` | Set signed 32-bit float
    `value` at `offset`. If `littleEndian` is `true` use litte endian format |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setFloat64(offset, value, [littleEndian])` | Set signed 64-bit float
    `value` at `offset`. If `littleEndian` is `true` use litte endian format |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setInt16(offset, value, [littleEndian])` | Set signed 16-bit integer
    `value` at `offset`. If `littleEndian` is `true` use litte endian format |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setInt32(offset, value, [littleEndian])` | Set signed 32-bit integer
    `value` at `offset`. If `littleEndian` is `true` use litte endian format |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setInt8(offset, value, [littleEndian])` | Set signed 8-bit integer `value`
    at `offset`. If `littleEndian` is `true` use litte endian format |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setUint16(offset, value, [littleEndian])` | Set unsigned 16-bit integer
    `value` at `offset`. If `littleEndian` is `true` use litte endian format |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setUint32(offset, value, [littleEndian])` | Set unsigned 32-bit integer
    `value` at `offset`. If `littleEndian` is `true` use litte endian format |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setUint8(offset, value, [littleEndian])` | Set unsigned 8-bit integer
    `value` at `offset`. If `littleEndian` is `true` use litte endian format |'
  prefs: []
  type: TYPE_TB
- en: Date
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Options for `Date`. To get the current time simply use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If an integer is provided, you will get the seconds from the Unix epoch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The ES6 spec only supports a variant of ISO8601, but in practice a string in
    RFC 2822/1123 is also supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `Date` constructor allows us to specify the year, month, date,
    hours, minutes, seconds, and milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Dates created with the constructor are in the local time. To create a `Date`
    in UTC, use the `Date.UTC` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'An RFC 2822/RFC 1123 string is a human readable string that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `toUTCString` method will give you this string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'ISO 8601 in ES6 is specified like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: There is a `toISOString` method on `Date` that will return this format.
  prefs: []
  type: TYPE_NORMAL
- en: Date Properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Date.name` | `Date` |'
  prefs: []
  type: TYPE_TB
- en: '| `Date.prototype` | `Date` constructor |'
  prefs: []
  type: TYPE_TB
- en: Date Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `d.UTC(year, month, [day, [hour, [minute, [second, [millisecond]]]]])` |
    Return milliseconds since Unix epoch from UTC time specified |'
  prefs: []
  type: TYPE_TB
- en: '| `d.now()` | Return milliseconds since Unix epoch |'
  prefs: []
  type: TYPE_TB
- en: '| `d.parse(str)` | Return milliseconds since Unix epoch for ISO 8601 string
    |'
  prefs: []
  type: TYPE_TB
- en: Date Prototype Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getDate()` | Return day of month, number between `1` and `31` |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getDay()` | Return day of the week (`0` is Sunday). |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getFullYear()` | Return year, number between `0` and `9999` |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getHours()` | Return hour, number between `0` and `23` |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getMilliseconds()` | Return milliseconds, number between `0` and `999`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getMinutes()` | Return minutes, number between `0` and `59` |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getMonth()` | Return month, number between `0` (Jan) and `11` (Dec)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getSeconds()` | Return seconds, number between `0` and `59` |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getTime()` | Return milliseconds since Unix epoch |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getTimezoneOffset()` | Return timezone offset in minutes |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getUTCDate()` | Return UTC day of month, number between `1` and `31`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getUTCDay()` | Return UTC day of the week (`0` is Sunday). |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getUTCFullYear()` | Return UTC year, number between `0` and `9999` |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getUTCHours()` | Return hour, number between `0` and `23` |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getUTCMilliseconds()` | Return UTC milliseconds, number between `0`
    and `999` |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getUTCMinutes()` | Return UTCminutes, number between `0` and `59` |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getUTCMonth()` | Return UTCmonth, number between `0` (Jan) and `11`
    (Dec) |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getUTCSeconds()` | Return UTC seconds, number between `0` and `59` |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.getYear()` | Broken year implementation, use `getFullYear` |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setDate(num)` | Return milliseconds after Unix epoch after mutating
    day of month |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setFullYear(year, [month, [day]])` | Return milliseconds after Unix
    epoch after mutating day values |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setHours(hours, [min, [sec, [ms]]])` | Return milliseconds after Unix
    epoch after mutating time values |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setMilliseconds(ms)` | Return milliseconds after Unix epoch after mutating
    ms value |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setMinutes(min, [sec, [ms]])` | Return milliseconds after Unix epoch
    after mutating time values |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setMonth(month, [day])` | Return milliseconds after Unix epoch after
    mutating day values |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setSeconds(sec, [ms])` | Return milliseconds after Unix epoch after
    mutating time values |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setTime(epoch)` | Return milliseconds after Unix epoch after mutating
    time value |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setUTCDate(num)` | Return milliseconds after Unix epoch after mutating
    day of month |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setUTCFullYear(year, [month, [day]])` | Return milliseconds after Unix
    epoch after mutating day values |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setUTCHours(hours, [min, [sec, [ms]]])` | Return milliseconds after
    Unix epoch after mutating time values |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setUTCMilliseconds( ms)` | Return milliseconds after Unix epoch after
    mutating ms value |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setUTCMinutes(min, [sec, [ms]])` | Return milliseconds after Unix epoch
    after mutating time values |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setUTCMonth(month, [day])` | Return milliseconds after Unix epoch after
    mutating day values |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setUTCSeconds(sec, [ms])` | Return milliseconds after Unix epoch after
    mutating time values |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.setYear(year)` | Broken year implementation, use `setFullYear` |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.toDateString()` | Return human readable of date in American English
    |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.toGMTString()` | Broken, use `toUTCString` |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.toISOString()` | Return date string in ISO 8601 form |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.toJSON()` | Return date JSON string form (ISO 8601) |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.toLocaleDateString( [locales, [options]])` | Return string of date portion
    in locale |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.toLocaleString( [locales, [options]])` | Return string of date and time
    in locale |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.toLocaleTimeString( [locales, [options]])` | Return string of time in
    locale |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.toString()` | Return a string representation in American English |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.toTimeString()` | Return a string representation of time portion in
    American English |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.toUTCString()` | Return (usually RFC-1123 formatted) version of string
    in UTC timezone |'
  prefs: []
  type: TYPE_TB
- en: '| `d.p.valueOf()` | Return milliseconds after Unix epoch |'
  prefs: []
  type: TYPE_TB
- en: Maps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Maps do not have prototypes (like objects do) that could collide with your keys.
    Objects only support strings or symbols as keys, whereas maps support any type
    for keys (functions, objects, or primitives). Another benefit of maps is that
    you can easily get the length with the `size` property. To get the length of an
    object, you need to iterate over it.
  prefs: []
  type: TYPE_NORMAL
- en: Should you use an object or a map? If you need record type data, use an object.
    For hashlike collections that you need to mutate and iterate over, choose a map.
  prefs: []
  type: TYPE_NORMAL
- en: A `Map` can be created simply by calling the constructor, or by passing an iterable
    of key value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Map Properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Map.name` | `Map` |'
  prefs: []
  type: TYPE_TB
- en: '| `Map.prototype` | Constructor prototype for `Map` |'
  prefs: []
  type: TYPE_TB
- en: '| `Map.prototype.size` | Return number of items in map |'
  prefs: []
  type: TYPE_TB
- en: Map Prototype Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `m.p.clear()` | Return `undefined`. Remove all items from `m` (mutates `m`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `m.p.delete(key)` | Return boolean if `key` was in `m`. Mutates `m` and removes
    it |'
  prefs: []
  type: TYPE_TB
- en: '| `m.p.entries()` | Return iterator for array of key, value pairs |'
  prefs: []
  type: TYPE_TB
- en: '| `m.p.forEach(func, [this])` | Return `undefined`. Apply `func(value, key,
    m)` to every key and value in `m` |'
  prefs: []
  type: TYPE_TB
- en: '| `m.p.get(key)` | Return value or `undefined` |'
  prefs: []
  type: TYPE_TB
- en: '| `m.p.has(key)` | Return boolean if `key` found in `m` |'
  prefs: []
  type: TYPE_TB
- en: '| `m.p.keys()` | Return iterator of keys in `m` in order of insertion |'
  prefs: []
  type: TYPE_TB
- en: '| `m.p.set(key, value)` | Return `m`, mutating `m` with `value` for `key` |'
  prefs: []
  type: TYPE_TB
- en: '| `m.p.values()` | Return iterator for values in order of insertion |'
  prefs: []
  type: TYPE_TB
- en: '`WeakMaps`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`WeakMaps` allow you to track objects until they are garbage collected. The
    keys don''t create references, so data may disappear from weakmap if the key happens
    to be garbage collected (or if its containing object is collected).'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor has the same interface as `Map`, you can create an empty `WeakMap`
    by provided no arguments, or you can pass in an iterable of key value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: WeakMap Properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `WeakMap.name` | `WeakMap` |'
  prefs: []
  type: TYPE_TB
- en: '| `WeakMap.prototype` | Constructor prototype for `WeakMap` |'
  prefs: []
  type: TYPE_TB
- en: WeakMap Prototype Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `w.p.delete(key)` | Return `true` if `key` existed and was removed, else
    `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `w.p.get(key)` | Return value for `key` or `undefined` if missing |'
  prefs: []
  type: TYPE_TB
- en: '| `w.p.has(key)` | Return boolean if `key` found in `w` |'
  prefs: []
  type: TYPE_TB
- en: '| `w.p.set(key, value)` | Return `w` after mutating it with new `key` and `value`
    |'
  prefs: []
  type: TYPE_TB
- en: Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A set is a mutable unordered collection that cannot contain duplicates. Sets
    are used to remove duplicates and test for membership. You can make an empty `Set`
    by calling the constructor with no arguments. If you wish to create a `Set` from
    an iterable, pass that into the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Set operations are not provided. Here is an example of adding difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Set Properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Set.name` | `Set` |'
  prefs: []
  type: TYPE_TB
- en: '| `Set.prototype` | Constructor prototype for `Set` |'
  prefs: []
  type: TYPE_TB
- en: '| `Set.prototype.size` | Return size of set |'
  prefs: []
  type: TYPE_TB
- en: Set Prototype Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.add(item)` | Return `s`. Add `item` to `s` (mutating) |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.clear()` | Return `undefined`. Removes (mutating) all items from `s`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.delete(item)` | Return value if deleted, otherwise returns `false` (mutating)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.entries()` | Return iterator of `item`, `item` pairs (both the same)
    for every item of `s` (same interface as `Map`) |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.forEach(func, [this])` | Return `undefined`. Apply `func(item, item,
    s)` to every item in `s`. Same interface as `Array` and `Map` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.has(item)` | Return boolean if `item` found in `s` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.values()` | Return iterator for items in insertion order |'
  prefs: []
  type: TYPE_TB
- en: Weak Set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Weak sets are collections of objects, and not any type. We cannot enumerate
    over them. Objects may spontaneously disappear from them when they are garbage
    collected.
  prefs: []
  type: TYPE_NORMAL
- en: The `WeakSet` constructor has the same interace as `Set` (no arguments or an
    iterable).
  prefs: []
  type: TYPE_NORMAL
- en: WeakSet Properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `WeakSet.name` | `WeakSet` |'
  prefs: []
  type: TYPE_TB
- en: '| `WeakSet.prototype` | Prototype for `WeakSet` |'
  prefs: []
  type: TYPE_TB
- en: WeakSet Prototype Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `w.p.add(item)` | Return `w`, inserts `item` into `w` |'
  prefs: []
  type: TYPE_TB
- en: '| `w.p.delete(item)` | Return `true` if `item` was in `w` (also removes it),
    otherwise return `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `w.p.has(item)` | Return boolean if `item` in `w` |'
  prefs: []
  type: TYPE_TB
- en: Proxies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A proxy allows you to create custom behavior for basic operations (getting/setting
    properties, calling functions, looping over values, decorating, etc). We use a
    *handler* to configure *traps* for a *target*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor takes two arguments, a target, and a handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Proxy Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Proxy.revocable(target, handler)` | Create a revocable proxy. When `revoke`
    is called, proxy throws `TypeError` |'
  prefs: []
  type: TYPE_TB
- en: Reflection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Reflect` object allows you to inspect objects. `Reflect` is not a constructor,
    all the methods are static.
  prefs: []
  type: TYPE_NORMAL
- en: Math Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Reflect.apply(obj, this, args)` | Return result of `obj(...args)` with `this`
    value |'
  prefs: []
  type: TYPE_TB
- en: '| `Reflect.construct(obj, args)` | Return result of `new obj(...args)` |'
  prefs: []
  type: TYPE_TB
- en: '| `Reflect.defineProperty(obj, key, descriptor)` | Like `Object.defineProperty(
    obj, key, descriptor)`, but returns `Boolean` |'
  prefs: []
  type: TYPE_TB
- en: '| `Reflect.deleteProperty(obj, key)` | Remove `key` from `obj`, returns `Boolean`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Reflect.get(obj, key)` | Return `obj[key]` |'
  prefs: []
  type: TYPE_TB
- en: '| `Reflect.getOwnProperty Descriptor(obj, key)` | Return property descriptor
    of `obj[key]` |'
  prefs: []
  type: TYPE_TB
- en: '| `Reflect.getPrototypeOf(obj)` | Return prototype for `obj` or `null` (if
    no inherited properties) |'
  prefs: []
  type: TYPE_TB
- en: '| `Reflect.has(obj, key)` | Return `key in obj` |'
  prefs: []
  type: TYPE_TB
- en: '| `Reflect.isExtensible(obj)` | Return `Boolean` if you can add new properties
    to `obj` |'
  prefs: []
  type: TYPE_TB
- en: '| `Reflect.ownKeys(obj)` | Return `Array` of keys in `obj` |'
  prefs: []
  type: TYPE_TB
- en: '| `Reflect.preventExtensions( obj)` | Disallow extensions on `obj`, return
    `Boolean` if successful |'
  prefs: []
  type: TYPE_TB
- en: '| `Reflect.set(obj, key, value, [this])` | Return `Boolean` if successful setting
    property `key` on `obj`. |'
  prefs: []
  type: TYPE_TB
- en: Symbols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ES6 introduced a new primitive type, Symbol. They have string-like properties
    (immutable, can't set properties on them, can be property names). They also have
    object-like behavior (unique from others even if the description is the same).
    Symbols are unique values that can be used for property keys without collisions.
    They must be accessed using an index operation (square brackets) and not dot notation.
    The are also not iterated over in a `for ... in` loop. To retrieve them we need
    to use `Object.getOwnPropertySymbols` or `Reflect.ownKeys`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor takes an optional description argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`Symbol` is not a constructor, and a `TypeError` will be raised if you try
    to use it as one.'
  prefs: []
  type: TYPE_NORMAL
- en: Symbol Properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Symbol.hasInstance` | Used to define class behavior for `instanceof`. Define
    method as `static [Symbol.hasInstance](instance) ...` |'
  prefs: []
  type: TYPE_TB
- en: '| `Symbol. isConcatSpreadable` | Used to define class behavior for `Array.concat`.
    Set to `true` if items are spread (or flattened). |'
  prefs: []
  type: TYPE_TB
- en: '| `Symbol.iterator` | Used to define class behavior for `for...of`. Should
    follow iteration protocol. Can be a generator |'
  prefs: []
  type: TYPE_TB
- en: '| `Symbol.match` | Used to define class behavior for responding as a regular
    expression in `String` methods: `startsWith`, `endsWith`, `includes` |'
  prefs: []
  type: TYPE_TB
- en: '| `Symbol.name` | value: `Symbol` |'
  prefs: []
  type: TYPE_TB
- en: '| `Symbol.prototype` | The prototype for `Symbol` |'
  prefs: []
  type: TYPE_TB
- en: '| `Symbol.replace` | Used to define class behavior for responding to `String.p.replace`
    method |'
  prefs: []
  type: TYPE_TB
- en: '| `Symbol.search` | Used to define class behavior for responding to `String.p.search`
    method |'
  prefs: []
  type: TYPE_TB
- en: '| `Symbol.species` | Used to define class behavior for which constructor to
    use when creating derived objects |'
  prefs: []
  type: TYPE_TB
- en: '| `Symbol.split` | Used to define class behavior for responding to `String.p.split`
    method |'
  prefs: []
  type: TYPE_TB
- en: '| `Symbol.toPrimitive` | Used to define class behavior for responding to coercion.
    Define method as `static [Symbol.toPrimitive] (hint) ...`, where `hint` can be
    `''number''`, `''string''`, or `''default''` |'
  prefs: []
  type: TYPE_TB
- en: '| `Symbol.toStringTag` | Used to define class behavior for responding to `Object.p.toString`
    method |'
  prefs: []
  type: TYPE_TB
- en: '| `Symbol.unscopables` | Used to define class behavior in `with` statement.
    Should be set to an object mapping properties to boolean value if they are not
    visible in `with`. (ie `true` means throw `ReferenceError`) |'
  prefs: []
  type: TYPE_TB
- en: Symbol Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Symbol.for(key)` | Return symbol in global registry for `key`, other create
    symbol and return it. |'
  prefs: []
  type: TYPE_TB
- en: '| `Symbol.keyFor(symbol)` | Return string value for symbol in global registry,
    `undefined` if symbol not in registry |'
  prefs: []
  type: TYPE_TB
- en: Symbol Prototype Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.toString()` | Return string representation for symbol |'
  prefs: []
  type: TYPE_TB
- en: '| `s.p.valueOf()` | Return primitive value (symbol) of a symbol |'
  prefs: []
  type: TYPE_TB
- en: Built-in Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Built-in Functions
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `eval(str)` | Evaluate code found in str |'
  prefs: []
  type: TYPE_TB
- en: '| `isFinite(val)` | Return `false` if `val` is `Infinity`, `-Infinity`, or
    `NaN`, else `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `isNaN(val)` | Return `true` if `val` is `NaN`, else `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `parseFloat(str)` | Return float if `str` can be converted to a number, else
    `NaN` |'
  prefs: []
  type: TYPE_TB
- en: '| `parseInt(val, radix)` | Return integer if `str` can be converted to an integer,
    else `NaN`. It ignores characters that are not numbers in `radix` |'
  prefs: []
  type: TYPE_TB
- en: '| `decodeURI(uri)` | Return the unencoded version of the string. Should be
    used on full URI |'
  prefs: []
  type: TYPE_TB
- en: '| `decodeURIComponent(str)` | Return the unencoded version of the string. Should
    be used on parts of URI |'
  prefs: []
  type: TYPE_TB
- en: '| `encodeURI(uri)` | Return the encoded version of the URI. Should be used
    on full URI |'
  prefs: []
  type: TYPE_TB
- en: '| `encodeURIComponent(uri)` | Return the encoded version of the URI. Should
    be used on parts of URI |'
  prefs: []
  type: TYPE_TB
- en: Unicode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we have a unicode glyph, we can include that directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the Unicode code point to specify a Unicode character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have exactly four hexadecimal digits we can escape like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get a code point using the `codePointAt` string method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert a code point back to a string using the `fromCodePoint` static method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If we use the `/u` flag in a regular expression, we can search for Unicode characters,
    which will handle surrogate pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions are easy to define, we simply give them a name, the parameters they
    accept and a body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The arguments are stored in an implicit variable, `arguments`. We can invoke
    functions with any number of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Default Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to have a default value for an argument use a `=` to specify it
    immediately following the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Variable Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using `...` (*rest*) turns the remaining parameters into an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, because ES6 provides the `arguments` object, we can also create a function
    that accepts variable parameters like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Calling Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use `...` to *spread* an array into arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `bind` Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Functions have a method, `bind`, that allows you to set `this` and any other
    parameters. This essentially allows you to *partial* the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter to bind is the value passed for this. The rest are the arguments
    for the function. If you want a callback to use the parent's `this`, you can call
    bind on the function passing in the parent's `this`. Alternatively, you can use
    an arrow function.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ES6 introduced anonymous *arrow* functions. There are a few differences with
    arrow functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Implicit return
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this` is not rebound'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cannot be generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second feature makes them nice for callbacks and handlers, but not a good
    choice for methods. We can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'As:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `=>` is called a *fat arrow*. Since, this is a one line function, we can
    remove the curly braces and take advantage of the implicit return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the parentheses can be removed if you only have a single parameter
    and are inlining the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want a multiline arrow function, then remove the `function`, and add
    `=>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Tail Call
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you perform a recursive call in the last position of a function, that is
    called *tail call*. ES6 will allow you to do this without growing the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Some implementations might not support this. This fails with Node 7.7 and Chrome
    56 with `fib(100000)`.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ES6 introduced `class` which is syntactic sugar around creating objects with
    functions. ES6 classes support prototype inheritance, calls to parent classes
    via `super`, instance methods, and static methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that when you create a new instance of a `class`, you need to use `new`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Classes in ES6 are not *hoisted*. This means that you can't use a class until
    after you defined it. Functions, are hoisted, and you can use them anywhere in
    the scope of the code that defines them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to ES6, we could only create objects from functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The method is added after the fact to the prototype, so the instances can share
    the method. We could define the method in the function, but then every instance
    would get its own copy.
  prefs: []
  type: TYPE_NORMAL
- en: ES6 just provides an arguably cleaner syntax for this.
  prefs: []
  type: TYPE_NORMAL
- en: Subclasses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing to be aware of with subclasses is that they should call `super`. Because
    ES6 is just syntactic sugar, if we don't call `super`, we won't have the prototypes,
    and we can't create an instance without the prototypes. As a result, `this` is
    undefined until `super` is called. If you don't call super you should return `Object.create(...)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Static Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *static method* is a method called directly on the class, not on the instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Object Literal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also create instances using object literals, though in practice this
    leads to a lot of code duplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assignment
  prefs: []
  type: TYPE_NORMAL
- en: Built-in Operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `=` | Assignment |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Addition, , unary plus (coerce to number), concatenation (string) |'
  prefs: []
  type: TYPE_TB
- en: '| `++` | Increment |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | Subtraction, unary negation (coerce to number) |'
  prefs: []
  type: TYPE_TB
- en: '| `--` | Decrement |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Multiplication |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | Division |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | Remainder (modulus) |'
  prefs: []
  type: TYPE_TB
- en: '| `**` | Power |'
  prefs: []
  type: TYPE_TB
- en: '| `<<` | Left shift |'
  prefs: []
  type: TYPE_TB
- en: '| `>>` | Right shift |'
  prefs: []
  type: TYPE_TB
- en: '| `<<<` | Unsigned left shift |'
  prefs: []
  type: TYPE_TB
- en: '| `>>>` | Unsigned right shift |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | Bitwise AND |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Bitwise XOR |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | Bitwise OR |'
  prefs: []
  type: TYPE_TB
- en: '| `~` | Bitwise NOT |'
  prefs: []
  type: TYPE_TB
- en: '| `&&` | Logical AND |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;&#124;` | Logical OR |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | Logical NOT |'
  prefs: []
  type: TYPE_TB
- en: '| `,` | Comma operator, evaluates all operands and returns last |'
  prefs: []
  type: TYPE_TB
- en: '| `delete X` | Delete an object, property, index |'
  prefs: []
  type: TYPE_TB
- en: '| `typeof` | Return string indicating type of operand |'
  prefs: []
  type: TYPE_TB
- en: '| `void` | Create an expression without a return value |'
  prefs: []
  type: TYPE_TB
- en: '| `in` | Return boolean if property in object |'
  prefs: []
  type: TYPE_TB
- en: '| `instanceof` | Return boolean if object instance of type |'
  prefs: []
  type: TYPE_TB
- en: '| `new` | Create a new instance of a type |'
  prefs: []
  type: TYPE_TB
- en: '| `...` | *Spread* sequence into array or parameters |'
  prefs: []
  type: TYPE_TB
- en: Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ES6 has an `if` statement with zero or more `else if` statements, and an optional
    `else` statement at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'ES6 supports the following tests: `>`, `>=`, `<`, `<=`, `==`, `!=`, `===`,
    and `!==`. For boolean operators use `&&`, `||`, and `!` for and, or, and not
    respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For `==` and `!=`, ES6 tries to compare numeric values of the operands if they
    have differing types, hence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'If this bothers you (and it should), use the *strict* equality operators (`===`
    and `!==`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Short Circuiting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `and` statement will *short circuit* if it evaluates to false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, the `or` statement will short circuit when something evaluates to
    true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Ternary Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ES6 has a ternary operator. Instead of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Switch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ES6 supports the switch statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Looping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are various ways to iterate:'
  prefs: []
  type: TYPE_NORMAL
- en: '`for ... in` - Iterates over the properties of an object. This only walks through
    properties that have `[[Enumerable]]` set to `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for ... of` - Iterates over the items of a collection. Any object which has
    the `[Symbol.iterator]` property can be iterated with this method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEach` is a method on the `Array` object. It takes a callback that is invoked
    for every item of the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is also a `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'And a `do ... while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Iteration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can make a class that knows how to iterate. We have to provide a method for
    `[Symbol.iterator]`, and the result of that method needs to have a `next` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of creating a class for iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The result of `next` should be an object that indicates whether looping is finished
    in the `done` property, and returns the item of iteration in the `value` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'And here we use it in a `for .. of` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also loop with an object literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the iterator in a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ES6 allows us to handle exceptions should they occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is a `finally` statement, it executes after the other blocks, regardless
    of whether and exception occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Throwing Errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ES6 allows us to throw errors as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Error Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are various built-in error types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EvalError` - Not used in ES6, available for backward compatibility'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RangeError` - A value that is out of the set of allowed values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReferenceError` - Error for referring to a non valid reference (`let val =
    badRef`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SyntaxError` - Error when syntax is incorrect (`foo bar`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypeError` - Error when type of value is incorrect (`undefined.junk()`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`URIError` - Error when URI encoding/decoding goes awry (`decodeURI(''%2'')`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Iterators that use `function*` and `yield`, rather than normal `function` and
    `return` are *generators*. They generate values on the fly as they are iterated
    over. Following a `yield` statement, the state of the function is frozen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A module is a JavaScript file. To use object in other files, we need to *export*
    the objects. Here we create a `fib.js` file and export the generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Using Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can load exported object using the `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'As of now, support for this feature is limited (available behind flag in Chrome
    60, Edge 38, Firefox 54 and up). To use imports in non-modern browsers or in node,
    we need to use Babel to get support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Promises are objects that allow for asynchronous programming. They are an alternative
    for callbacks. If you know that a value might be available in the future, a promise
    can represent that.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three states for a promise:'
  prefs: []
  type: TYPE_NORMAL
- en: Pending - result is not ready
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fulfilled - result is ready
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rejected - an error occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the promise object a `then` method will be called to move the state to either
    fulfilled or rejected.
  prefs: []
  type: TYPE_NORMAL
- en: 'An async function that implements a promise allows us to *chain* a `then` and
    a `catch` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Promise Properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Promise.length` | Return `1`, number of constructor arguments |'
  prefs: []
  type: TYPE_TB
- en: '| `Promise.name` | value: `Promise` |'
  prefs: []
  type: TYPE_TB
- en: '| `Promise.prototype` | Prototype for `Promise` |'
  prefs: []
  type: TYPE_TB
- en: Promise Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Promise.all(promises)` | Return `Promise` that returns when `promises` are
    fulfilled, or rejects if any of them reject. |'
  prefs: []
  type: TYPE_TB
- en: '| `Promise.race(promises)` | Return `Promise` that returns when any of the
    `promises` reject or fulfill |'
  prefs: []
  type: TYPE_TB
- en: '| `Promise.reject(reason)` | Return `Promise` that rejects with `reason` |'
  prefs: []
  type: TYPE_TB
- en: '| `Promise.resolve(value)` | Return a `Promise` that fulfills with `value`.
    If `value` has a `then` method, it will return it''s final state |'
  prefs: []
  type: TYPE_TB
- en: Promise Prototype Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `p.p.catch(func)` | Return new `Promise` with rejection handler `func` |'
  prefs: []
  type: TYPE_TB
- en: '| `p.p.constructor()` | Return `Promise` function |'
  prefs: []
  type: TYPE_TB
- en: '| `p.p.then(fulfillFn, rejectFn)` | Return `Promise` that calls `fulfillFn(value)`
    on success, or `rejectFn(reason)` on failure |'
  prefs: []
  type: TYPE_TB
- en: Regular Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A regular expression allows you to match characters in strings. You can create
    then using the literal syntax. Between the slashes place the regular expression.
    Flags can be specified at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `match` method on a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Or the `exec` method on a regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: If there is a match it returns an array. The 0 position is the matched portion,
    the remaining items correspond to the captured groups. These are specified with
    parentheses. You can just count the left parentheses (unless they are escaped)
    in order. Index 1 will be the group of the first parenthesis, index 2 will be
    the second left parenthesis group, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also call the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: RegExp Flags
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `g` | Match *globally*, returning all matches, not just first |'
  prefs: []
  type: TYPE_TB
- en: '| `i` | *Ignore* case when matching |'
  prefs: []
  type: TYPE_TB
- en: '| `m` | Treat newlines as breaks for `^` and `$`, allowing *multi line* matching
    |'
  prefs: []
  type: TYPE_TB
- en: '| `y` | *Sticky* match, start looking from `r.lastIndex` property |'
  prefs: []
  type: TYPE_TB
- en: '| `u` | *Unicode* match |'
  prefs: []
  type: TYPE_TB
- en: Character Classes
  prefs: []
  type: TYPE_NORMAL
- en: '| Character | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | Match one digit (`[0-9]`) |'
  prefs: []
  type: TYPE_TB
- en: '| `\D` | Match one non-digit (`[^0-9]`) |'
  prefs: []
  type: TYPE_TB
- en: '| `\w` | Match one *word* character (`[0-9a-zA-z]`) |'
  prefs: []
  type: TYPE_TB
- en: '| `\W` | Match one non-word character (`[^0-9a-zA-z]`) |'
  prefs: []
  type: TYPE_TB
- en: '| `\s` | Match one *space* character |'
  prefs: []
  type: TYPE_TB
- en: '| `\S` | Match one non-space character |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | Match word boundary |'
  prefs: []
  type: TYPE_TB
- en: '| `\B` | Match non-word boundary |'
  prefs: []
  type: TYPE_TB
- en: '| `\t`, `\r`, `\v`, `\f` | Match one tab, carriage return, vertical tab, or
    line feed respectively |'
  prefs: []
  type: TYPE_TB
- en: '| `\0` | Match one null character |'
  prefs: []
  type: TYPE_TB
- en: '| `\cCHAR` | Match one control character. Where `CHAR` is character |'
  prefs: []
  type: TYPE_TB
- en: '| `\xHH` | Match one character with hex code `HH` |'
  prefs: []
  type: TYPE_TB
- en: '| `\uHHHH` | Match one UTF-16 character with hex code `HHHH` |'
  prefs: []
  type: TYPE_TB
- en: '| `\u{HHHH}` | Match one unicode character with hex code `HHHH` (use `u` flag)
    |'
  prefs: []
  type: TYPE_TB
- en: Syntax Characters
  prefs: []
  type: TYPE_NORMAL
- en: '| Character | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Match beginning of line (note different in character class) |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | Match end of line |'
  prefs: []
  type: TYPE_TB
- en: '| `a&#124;b` | Match `a` or `b` |'
  prefs: []
  type: TYPE_TB
- en: '| `[abet]` | *Character class* match one of `a`, `b`, `e`, or `t` |'
  prefs: []
  type: TYPE_TB
- en: '| `[^abe]` | `^` negates matches in character class. One of not `a`, `b`, or
    `e` |'
  prefs: []
  type: TYPE_TB
- en: '| `\[` | *Escape*. Capture literal `[`. The following need to be escaped `^
    $ \ . * + ? ( ) [ ] { } &#124;` |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Match one character except newline |'
  prefs: []
  type: TYPE_TB
- en: '| `a?` | Match `a` zero or one time (`a{0,1}`) (note different following `*`,
    `+`, `?`, `}`) |'
  prefs: []
  type: TYPE_TB
- en: '| `a*` | Match `a` zero or more times (`a{0,}`) |'
  prefs: []
  type: TYPE_TB
- en: '| `a+` | Match `a` one or more times (`a{1,}`) |'
  prefs: []
  type: TYPE_TB
- en: '| `a{3}` | Match `a` three times |'
  prefs: []
  type: TYPE_TB
- en: '| `a{3,}` | Match `a` three or more times |'
  prefs: []
  type: TYPE_TB
- en: '| `a{3,5}` | Match `a` three to five times |'
  prefs: []
  type: TYPE_TB
- en: '| `b.*?n` | `?` match non-greedy. ie from `banana` return `ban` instead of
    `banan` |'
  prefs: []
  type: TYPE_TB
- en: '| `(Paul)` | *Capture* match in group. Captured result will be in position
    1 `exec` |'
  prefs: []
  type: TYPE_TB
- en: '| `(?:Paul)` | Match `Paul` but don''t capture. Result will only be in position
    0 in `exec` |'
  prefs: []
  type: TYPE_TB
- en: '| `\NUM` | *Backreference* to match previous capture group. `/<(\w+)>(.*)<\/\1>/`
    will capture an xml tag name in 1 and the content in 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `Foo(?=script)` | *Assertion* match `Foo` only if followed by `script` (don''t
    capture `script`) |'
  prefs: []
  type: TYPE_TB
- en: '| `Foo(?!script)` | *Assertion* match `Foo` only if not followed by `script`
    |'
  prefs: []
  type: TYPE_TB
- en: RegExp Properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `RegExp.length` | value: `2` |'
  prefs: []
  type: TYPE_TB
- en: '| `RegExp.name` | value: `RegExp` |'
  prefs: []
  type: TYPE_TB
- en: '| `RegExp.prototype` | value: `/(?:)/` |'
  prefs: []
  type: TYPE_TB
- en: '| `r.p.flags` | Return flags for regular expression |'
  prefs: []
  type: TYPE_TB
- en: '| `r.p.global` | Return boolean if global (`g`) flag is used |'
  prefs: []
  type: TYPE_TB
- en: '| `r.p.ignoreCase` | Return boolean if ignore case (`i`) flag is used |'
  prefs: []
  type: TYPE_TB
- en: '| `r.p.multiline` | Return boolean if multi line (`m`) flag is used |'
  prefs: []
  type: TYPE_TB
- en: '| `r.p.source` | Return string value for regular expression |'
  prefs: []
  type: TYPE_TB
- en: '| `r.p.sticky` | Return boolean if sticky (`y`) flag is used |'
  prefs: []
  type: TYPE_TB
- en: '| `r.p.unicode` | Return boolean if unicode (`u`) flag is used |'
  prefs: []
  type: TYPE_TB
- en: '| `r.sticky` | Return integer specifying where to start looking for next match
    |'
  prefs: []
  type: TYPE_TB
- en: RegExp Prototype Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `r.p.compile()` | Not useful, just create a `RegExp` |'
  prefs: []
  type: TYPE_TB
- en: '| `r.p.constructor()` | Return constructor for `RegExp` |'
  prefs: []
  type: TYPE_TB
- en: '| `r.p.exec(s)` | Return array with matches found in string `s`. Index 0 is
    matched item, other items correspond to capture parentheses. Updates `r` properties
    |'
  prefs: []
  type: TYPE_TB
- en: '| `r.p.test(s)` | Return boolean if `r` matches against string `s` |'
  prefs: []
  type: TYPE_TB
- en: '| `r.p.toString()` | Return string representation of `r` |'
  prefs: []
  type: TYPE_TB
