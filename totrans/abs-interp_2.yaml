- en: 2  What can be formalized by abstract interpretation?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstract interpretation is useful in computer science to formalize reasonings
    involving the [sound [and complete]] approximation of the semantics of formal
    systems. A non-exhaustive list of typical examples of application is given below.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1  Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The analysis of properties of grammars as well as parsing are abstract interpretations
    of the grammar operational semantics and its abstractions (such as parse trees,
    protolanguages, or terminal languages) [[39](#CousotCousot03-TCS-parsing)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.2  Semantics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The semantics of programs describes their possible runtime executions in all
    possible execution environments at some level of abstraction. The hierarchy of
    semantics, including trace, small-step, and big-step operational semantics, relational
    semantics, denotational semantics, predicate transformers, and axiomatic semantics
    in their angelic, natural, and demoniac versions can be designed by abstract interpretation
    [[32](#CousotCousot92-1-POPL),[19](#Cousot02-TCS)]. An extension to transfinite
    behaviors is useful to formalize e.g. *semantic slicing* [[54](#GiacobazziMastroeni03-transfinite)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.3  Proofs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Formal proofs of program correctness involve an abstraction since specifications
    always ignore some aspects of program execution which need not be taken into account
    in the proof [[18](#Cousot00-SARA)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.4  Static analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Static analysis is the automatic determination of abstract program properties
    [[22](#CousotCousot77-1-POPL),[44](#CousotHalbwachs78-1-POPL),[26](#CousotCousot79-1-POPL),[15](#Cousot81-1-MuchnickJones)]
    including *Dataflow Analysis* [[67](#Hecht77-1)], [[26](#CousotCousot79-1-POPL),[36](#CousotCousot00-POPL)],
    *Set-based Analysis* [[35](#CousotCousot95-3-FPCA)], etc. This was the motivating
    application behind the introduction of the abstract interpretation theory.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5  Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Static typing and type inference [[97](#Pierce02-TypesBook)] can be understood
    as an abstract interpretation of runtime type checking thus providing a "correct
    by construction" design method [[16](#Cousot97-1-POPL),[11](#CominiDamianiVrech08-SAS)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.6  Model-checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Model-checking* exhaustively verifies temporal properties on a finite model
    of hardware or software computer systems [[10](#ClarkeGrumbergPeled99-1)]. This
    abstraction of a system into a model is often left implicit. *Abstract model checking*,
    as formalized by abstract interpretation, makes this abstraction explicit [[9](#ClarkeEtAl-TOPLAS94)],
    [[36](#CousotCousot00-POPL)], .Model-checking is reputed to be terminating, sound,
    and complete on the model. From an abstract interpretation point of view, relating
    the system to its model, it may be sound on the model but unsound on the system
    (e.g. the model is correct for safety properties but wrong for liveness properties),
    it is often incomplete (no finite model can cover the specified behaviors of the
    system [[100](#Ranzato01-esop01)]) and, in practice, may explode combinatorially.
    In all cases abstract interpretations of the system into a model have to be considered.
    All transition models are abstract semantics but the converse is not true.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.7  Predicate abstraction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Predicate abstraction [[61](#GrafSaidi96-CAV)] can be used to reduce any static
    analysis on a *finite* abstract domain to boolean fixpoint computations as performed
    by a model-checker using a theorem prover to automatically derive the abstract
    transformers involved in the fixpoint definition. Parametric predicate abstraction
    is an extension to infinite abstract domains [[20](#Cousot03-ZM)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.8  Counter-example-based refinement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spurious counter-example-based refinement in abstract model-checking is formalized
    as an abstract domain completion problem in the abstract interpretation theory
    [[56](#GiacobazziQuintarelli-SAS01),[43](#CousotGantyRaskin07-SAS)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.9  Strong Preservation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem of modifying finite abstract model checking by minimal refinements
    in order to get strong preservation for some specification language, including
    partition refinement algorithms, is a completion problem in the abstract interpretation
    theory [[101](#RanzatoTapparo-06-VMCAI)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.10  Program transformation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Program transformations (such as *partial evaluation* [[72](#JonesGomardSestoft93-1)])
    often require a static analysis of the source program, as formalized by abstract
    interpretation (e.g. [[71](#Jones-SAS97)]). Moreover, the transformation itself,
    from source to object programs, involves a loss of information on the original
    program or a limitation on the possible program behaviors. This approximation
    can be formalized by abstract interpretation. This was exemplified on dead-code
    elimination, slicing, partial evaluation, or program monitoring [[38](#CousotCousot02-POPL)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.11  Watermarking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Looking for program watermarks that are not subject to obfuscation, one can
    think to an abstract interpretation of the program semantics [[40](#CousotCousot04-POPL)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.12  Information hiding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In language-based software security, the information to be hidden to an intruder
    can be formalized as an abstract interpretation of the program semantics [[55](#GiacobazziMastroeni-FORMATS05)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.13  Code obfuscation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The aim of code obfuscation is to prevent malicious users from discovering properties
    of the original source program. This goal can be precisely modeled by abstract
    interpretation, where the hiding of properties corresponds to abstracting the
    semantics [[99](#DallaPredaGiacobazzi-SEFM05)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.14  Malware detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An obfuscated malware is better detected by the effects of its execution as
    recognized by an abstract interpretation rather than by a syntactic signature
    [[98](#DallaPredaEtAl-POPL07)].
  prefs: []
  type: TYPE_NORMAL
- en: 2.15  Termination
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A relational abstract-interpretation-based static analysis on a well-founded
    abstract domain can be systematically extended to a termination analysis [[3](#BerdineEtAl-POPL07)]
    (whence liveness analyses). Termination analysis may require probabilistic hypotheses
    [[87](#Monniaux_SAS01)] or fairness hypotheses on parallel processes [[78](#Mauborgne-SAS-00)].
  prefs: []
  type: TYPE_NORMAL
