- en: Module 0x6 | Forensic Kung Fu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Module 0x6 | Forensic Kung Fu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firefox Investigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find Firefox profile databases in
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In above directories, there are many SQLite database files, so let's to import
    these databases and see what we get
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: More about [Firefox forensic](http://www.forensicswiki.org/wiki/Mozilla_Firefox_3_History_File_Format)
  prefs: []
  type: TYPE_NORMAL
- en: Google Chrome Investigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: More about [Chrome forensic](http://www.forensicswiki.org/wiki/Google_Chrome)
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Windows Forensic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows Forensic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](win-foren__winreg1.png)'
  prefs: []
  type: TYPE_IMG
- en: Enumeration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: `KEY_ALL_ACCESS` enables you to write and deleted. The default access
    is `KEY_READ` if you specify nothing.'
  prefs: []
  type: TYPE_NORMAL
- en: Android Forensic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Forensic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parsing APK file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our example will be on DIVA (Damn insecure and vulnerable App) APK file. You
    can download the file from [here](http://www.payatu.com/wp-content/uploads/2016/01/diva-beta.tar.gz).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Some methods may not return the expected output because the missing information
    in the apk, e.g. the suggested apk doesn''t have icon and signs but you can download
    some known apk like twitter apk or so and test it, it works.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll use ruby_apk gem to do that
  prefs: []
  type: TYPE_NORMAL
- en: Install ruby_apk gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, lets start parsing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Memory Forensic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory Forensic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dump Linux memory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To dump Linux memory for a specific process to disk, we need the follwoing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Get process id (PID):** `/proc/\[PID\]/cmdline`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*cmdline* is file holds the complete command line for the process.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get PID maps:** `/proc/\[PID\]/maps`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*maps* is file containing the currently mapped memory regions and their access
    permissions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get processs memory pages:** `/proc/\[PID\]/mem`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*mem* is a file can be used to access the pages of a process''s memory through'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Case study
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's assume we want to dump `gnome-keyring-daemon` process's memory to our
    disk in order to extract the logged-in user(s) password(s) since its stored in
    as a plan text in memory. Moreover, we know that it comes after "libgck-1" or
    "libgcrypt" strings in memory. We'll brack that a parts then put it together.
  prefs: []
  type: TYPE_NORMAL
- en: '**Get process id (PID)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Get PID maps:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Get processs memory pages:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Network Traffic Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network Traffic Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic PCAP File Parsing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Download [packets.pcap](https://github.com/rubyfu/RubyFu/blob/master/files/module06/packets.pcap)
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Find FTP Credentials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Download [ftp.pcap](https://github.com/rubyfu/RubyFu/blob/master/files/module06/ftp.pcap)
    file
  prefs: []
  type: TYPE_NORMAL
- en: Capturing and building PCAP file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometime we don't have the time or option to install external libraries on our
    environment. Let's work capture all packets on all interfaces then see how to
    build a [**pcap**](https://wiki.wireshark.org/Development/LibpcapFileFormat) file
    to write in it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: <!--
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.behindthefirewalls.com/2014/01/extracting-files-from-network-traffic-pcap.html](http://www.behindthefirewalls.com/2014/01/extracting-files-from-network-traffic-pcap.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://jarmoc.com/blog/2013/05/22/bsjtf-ctf-writeup-what-in-the-name-of-zeus/](http://jarmoc.com/blog/2013/05/22/bsjtf-ctf-writeup-what-in-the-name-of-zeus/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://hamsa.cs.northwestern.edu/readings/password-cracking2/](http://hamsa.cs.northwestern.edu/readings/password-cracking2/)'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: <!--
  prefs: []
  type: TYPE_NORMAL
- en: '!/usr/bin/env ruby'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=owsr3X453Z4](https://www.youtube.com/watch?v=owsr3X453Z4)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: require 'packetfu'
  prefs: []
  type: TYPE_NORMAL
- en: require 'pp'
  prefs: []
  type: TYPE_NORMAL
- en: capture = PacketFu::Capture.new :iface => 'mon0', :promisc => true, :start =>
    true
  prefs: []
  type: TYPE_NORMAL
- en: capture.stream.each do |p|
  prefs: []
  type: TYPE_NORMAL
- en: pkt = PacketFu::Packet.parse p
  prefs: []
  type: TYPE_NORMAL
- en: pp pkt
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: \
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: array 56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: include PacketFu
  prefs: []
  type: TYPE_NORMAL
- en: packets = PcapFile.file_to_array '/home/KING/wireless.pcap'
  prefs: []
  type: TYPE_NORMAL
- en: packets.each*with_index do |packet , ref|
  prefs: []
  type: TYPE_NORMAL
- en: puts "*" *75
  prefs: []
  type: TYPE_NORMAL
- en: 'puts "Reference: #{ref}"'
  prefs: []
  type: TYPE_NORMAL
- en: puts "\*" _ 75
  prefs: []
  type: TYPE_NORMAL
- en: pkt = Packet.parse(packet)
  prefs: []
  type: TYPE_NORMAL
- en: puts pkt.dissect
  prefs: []
  type: TYPE_NORMAL
- en: sleep 2
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: \
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: packets = PcapFile.read_packets '/home/KING/wireless.pcap'
  prefs: []
  type: TYPE_NORMAL
- en: packet = packets[56]
  prefs: []
  type: TYPE_NORMAL
- en: pkt = Packet.parse(packet)
  prefs: []
  type: TYPE_NORMAL
- en: puts pkt.inspect_hex
  prefs: []
  type: TYPE_NORMAL
- en: =begin
  prefs: []
  type: TYPE_NORMAL
- en: '1876'
  prefs: []
  type: TYPE_NORMAL
- en: '1551'
  prefs: []
  type: TYPE_NORMAL
- en: '1550'
  prefs: []
  type: TYPE_NORMAL
- en: '1339'
  prefs: []
  type: TYPE_NORMAL
- en: '1324'
  prefs: []
  type: TYPE_NORMAL
- en: '459'
  prefs: []
  type: TYPE_NORMAL
- en: '458'
  prefs: []
  type: TYPE_NORMAL
- en: =end
  prefs: []
  type: TYPE_NORMAL
- en: '--->'
  prefs: []
  type: TYPE_NORMAL
- en: Parsing Log Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parsing Log Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apache Log File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's first list the important information that we may need from the Apache
    logs
  prefs: []
  type: TYPE_NORMAL
- en: IP address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time stamp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URI path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Response code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User agent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To read a log file, I prefer to read it as lines
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: I was looking for a simple regular expression for Apache logs. I found one [here](http://stackoverflow.com/questions/4846394/how-to-efficiently-parse-large-text-files-in-ruby)
    with small tweak.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So I came up with this small method which parses and converts Apache "access.log"
    file to an array contains a list of hashes with our needed information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: The Apache LogFormat is configured as `LogFormat "%h %l %u %t \"%r\"
    %>s %b \"%{Referer}i\" \"%{User-agent}i\"" combined` which is the default configurations.'
  prefs: []
  type: TYPE_NORMAL
- en: '%h is the remote host (i.e. the client IP address)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%l is the identity of the user determined by identd (not usually used since
    not reliable)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%u is the user name determined by HTTP authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%t is the time the request was received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%r is the request line from the client. ("GET / HTTP/1.0")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%>s is the status code sent from the server to the client (200, 404 etc.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '%b is the size of the response to the client (in bytes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referer is the page that linked to this URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-agent is the browser identification string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IIS Log File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is a basic IIS log regular expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
