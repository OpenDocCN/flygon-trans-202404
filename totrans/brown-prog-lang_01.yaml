- en: 1Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|     [1.1 Our Philosophy](#%28part._.Our_.Philosophy%29) |'
  prefs: []
  type: TYPE_TB
- en: '|     [1.2 Predictability as a Theme](#%28part._predictability%29) |'
  prefs: []
  type: TYPE_TB
- en: '|     [1.3 The Structure of This Book](#%28part._.The_.Structure_of_.This_.Book%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|     [1.4 The Language of This Book](#%28part._.The_.Language_of_.This_.Book%29)
    |'
  prefs: []
  type: TYPE_TB
- en: 1.1Our Philosophy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many people would regard this as being two books in one. One book is an introduction
    to programming, teaching you basic concepts of organizing data and the programs
    that operate over them, ending in the investigation of universally useful algorithms.
    The other book is an introduction to programming languages: a study, from one
    level up, of the media by which we structure these data and programs.'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, these are not unrelated topics. We learn programming through one
    or more languages, and the programs we write then become natural subjects of study
    to understand languages at large. Nevertheless, these are considered sufficiently
    different topics that they are approached separately. This is how we approached
    them, too.The one noble exception to this separation is the best computer science
    book ever written, The Structure and Interpretation of Computer Programs.
  prefs: []
  type: TYPE_NORMAL
- en: We have come to realize that this separation is neither meaningful nor helpful.
    The topics are deeply intertwined and, by accepting that interleaving, the result
    is likely to be a much better book. This is my experiment with that format.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2Predictability as a Theme
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to organize the study of programming and programming languages.
    My central theme is the concept of predictability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programs are typically static: they live on the moral equivalent of a paper,
    unmoving and unchanging. But when we run a program, it produces a complex, dynamic
    behavior that yields utility, pleasure, and (sometimes) frustration. Everyone
    who writes programs ultimately cares—<wbr>whether they realize it or not—<wbr>in
    predicting the latter from the former. Sometimes we even write programs to help
    us with this task (as we’ll see in [Examples, Testing, and Program Checking](testing.html),
    [Predicting Growth](predicting-growth.html), [Reasoning about Programs: A First
    Look at Types](types.html), and elsewhere).'
  prefs: []
  type: TYPE_NORMAL
- en: Predictability has a bad rap. Under the guise of “program reasoning”, it came
    to be viewed simultaneously as both noble and mind-numbingly boring. It is certainly
    noble, but we will try to present it a way that will hopefully seem utterly natural,
    indeed entirely obvious (because we believe it is). Hopefully you’ll come away
    from this study reasonably convinced about the central place of predictability
    in your own work, and as a metric for programming language design.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3The Structure of This Book
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike some other textbooks, this one does not follow a top-down narrative.
    Rather it has the flow of a conversation, with backtracking. We will often build
    up programs incrementally, just as a pair of programmers would. We will include
    mistakes, not because we don’t know better, but because this is the best way for
    you to learn. Including mistakes makes it impossible for you to read passively:
    you must instead engage with the material, because you can never be sure of the
    veracity of what you’re reading.'
  prefs: []
  type: TYPE_NORMAL
- en: At the end, you’ll always get to the right answer. However, this non-linear
    path is more frustrating in the short term (you will often be tempted to say,
    “Just tell me the answer, already!”), and it makes the book a poor reference guide
    (you can’t open up to a random page and be sure what it says is correct). However,
    that feeling of frustration is the sensation of learning. We don’t know of a way
    around it.
  prefs: []
  type: TYPE_NORMAL
- en: 'At various points you will encounter this:'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is an exercise. Do try it.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This is a traditional textbook exercise. It’s something you need to do on your
    own. If you’re using this book as part of a course, this may very well have been
    assigned as homework. In contrast, you will also find exercise-like questions
    that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There’s an activity here! Do you see it?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: When you get to one of these, stop. Read, think, and formulate an answer before
    you proceed. You must do this because this is actually an exercise, but the answer
    is already in the book—<wbr>most often in the text immediately following (i.e.,
    in the part you’re reading right now)—<wbr>or is something you can determine for
    yourself by running a program. If you just read on, you’ll see the answer without
    having thought about it (or not see it at all, if the instructions are to run
    a program), so you will get to neither (a) test your knowledge, nor (b) improve
    your intuitions. In other words, these are additional, explicit attempts to encourage
    active learning. Ultimately, however, we can only encourage it; it’s up to you
    to practice it.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4The Language of This Book
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book uses a new programming language called [Pyret](http://pyret.org/).
    Pyret is the outgrowth of our deep experience programming in and designing functional,
    object-oriented, and scripting languages, as well as their type systems, program
    analyses, and development environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The language’s syntax is inspired by Python.Unlike Python, Pyret will enforce
    indentation rather than interpret it: that is, indentation will simply become
    another syntax well-formedness criterion. But that hasn’t been implemented yet.
    It fits the niche missing in computer science education of a simple language that
    sheds both the strange corner-cases ([of which there are many](http://cs.brown.edu/~sk/Publications/Papers/Published/pmmwplck-python-full-monty/))
    of Python while adding important features that Python lacks for learning programming
    (such as algebraic datatypes, optional annotations on variables, design decisions
    that better enable the construction of development environments, and strong support
    for testing). Beginning programmers can rest in the knowledge they are being cared
    for, while programmers with past acquaintance of the language menagerie, from
    serpents to dromedaries, should find Pyret familiar and comfortable.'
  prefs: []
  type: TYPE_NORMAL
