- en: 1Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|     [1.1 Our Philosophy](#%28part._.Our_.Philosophy%29) |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
- en: '|     [1.2 Predictability as a Theme](#%28part._predictability%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
- en: '|     [1.3 The Structure of This Book](#%28part._.The_.Structure_of_.This_.Book%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
- en: '|     [1.4 The Language of This Book](#%28part._.The_.Language_of_.This_.Book%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
- en: 1.1Our Philosophy
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many people would regard this as being two books in one. One book is an introduction
    to programming, teaching you basic concepts of organizing data and the programs
    that operate over them, ending in the investigation of universally useful algorithms.
    The other book is an introduction to programming languages: a study, from one
    level up, of the media by which we structure these data and programs.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, these are not unrelated topics. We learn programming through one
    or more languages, and the programs we write then become natural subjects of study
    to understand languages at large. Nevertheless, these are considered sufficiently
    different topics that they are approached separately. This is how we approached
    them, too.The one noble exception to this separation is the best computer science
    book ever written, The Structure and Interpretation of Computer Programs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: We have come to realize that this separation is neither meaningful nor helpful.
    The topics are deeply intertwined and, by accepting that interleaving, the result
    is likely to be a much better book. This is my experiment with that format.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 1.2Predictability as a Theme
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to organize the study of programming and programming languages.
    My central theme is the concept of predictability.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Programs are typically static: they live on the moral equivalent of a paper,
    unmoving and unchanging. But when we run a program, it produces a complex, dynamic
    behavior that yields utility, pleasure, and (sometimes) frustration. Everyone
    who writes programs ultimately cares—<wbr>whether they realize it or not—<wbr>in
    predicting the latter from the former. Sometimes we even write programs to help
    us with this task (as we’ll see in [Examples, Testing, and Program Checking](testing.html),
    [Predicting Growth](predicting-growth.html), [Reasoning about Programs: A First
    Look at Types](types.html), and elsewhere).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Predictability has a bad rap. Under the guise of “program reasoning”, it came
    to be viewed simultaneously as both noble and mind-numbingly boring. It is certainly
    noble, but we will try to present it a way that will hopefully seem utterly natural,
    indeed entirely obvious (because we believe it is). Hopefully you’ll come away
    from this study reasonably convinced about the central place of predictability
    in your own work, and as a metric for programming language design.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 1.3The Structure of This Book
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike some other textbooks, this one does not follow a top-down narrative.
    Rather it has the flow of a conversation, with backtracking. We will often build
    up programs incrementally, just as a pair of programmers would. We will include
    mistakes, not because we don’t know better, but because this is the best way for
    you to learn. Including mistakes makes it impossible for you to read passively:
    you must instead engage with the material, because you can never be sure of the
    veracity of what you’re reading.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: At the end, you’ll always get to the right answer. However, this non-linear
    path is more frustrating in the short term (you will often be tempted to say,
    “Just tell me the answer, already!”), and it makes the book a poor reference guide
    (you can’t open up to a random page and be sure what it says is correct). However,
    that feeling of frustration is the sensation of learning. We don’t know of a way
    around it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'At various points you will encounter this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is an exercise. Do try it.
  id: totrans-19
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This is a traditional textbook exercise. It’s something you need to do on your
    own. If you’re using this book as part of a course, this may very well have been
    assigned as homework. In contrast, you will also find exercise-like questions
    that look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There’s an activity here! Do you see it?
  id: totrans-23
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: When you get to one of these, stop. Read, think, and formulate an answer before
    you proceed. You must do this because this is actually an exercise, but the answer
    is already in the book—<wbr>most often in the text immediately following (i.e.,
    in the part you’re reading right now)—<wbr>or is something you can determine for
    yourself by running a program. If you just read on, you’ll see the answer without
    having thought about it (or not see it at all, if the instructions are to run
    a program), so you will get to neither (a) test your knowledge, nor (b) improve
    your intuitions. In other words, these are additional, explicit attempts to encourage
    active learning. Ultimately, however, we can only encourage it; it’s up to you
    to practice it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 1.4The Language of This Book
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This book uses a new programming language called [Pyret](http://pyret.org/).
    Pyret is the outgrowth of our deep experience programming in and designing functional,
    object-oriented, and scripting languages, as well as their type systems, program
    analyses, and development environments.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The language’s syntax is inspired by Python.Unlike Python, Pyret will enforce
    indentation rather than interpret it: that is, indentation will simply become
    another syntax well-formedness criterion. But that hasn’t been implemented yet.
    It fits the niche missing in computer science education of a simple language that
    sheds both the strange corner-cases ([of which there are many](http://cs.brown.edu/~sk/Publications/Papers/Published/pmmwplck-python-full-monty/))
    of Python while adding important features that Python lacks for learning programming
    (such as algebraic datatypes, optional annotations on variables, design decisions
    that better enable the construction of development environments, and strong support
    for testing). Beginning programmers can rest in the knowledge they are being cared
    for, while programmers with past acquaintance of the language menagerie, from
    serpents to dromedaries, should find Pyret familiar and comfortable.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语言的语法受到Python的启发。与Python不同，Pyret将强制执行缩进而不是解释它：也就是说，缩进将简单地成为另一个语法规范。但这还没有实现。它填补了计算机科学教育中缺失的一个简单语言的空白，这种语言既摆脱了Python的奇怪的边界情况（[其中有很多](http://cs.brown.edu/~sk/Publications/Papers/Published/pmmwplck-python-full-monty/)），同时又增加了Python缺少的重要特性，用于学习编程（如代数数据类型、变量的可选注释、更好地支持开发环境构建的设计决策以及对测试的强力支持）。初学者可以放心，因为他们得到了关怀，而过去对语言动物园（从蛇到单峰驼都有）有所了解的程序员应该会觉得Pyret是熟悉和舒适的。
