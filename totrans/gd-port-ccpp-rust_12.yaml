- en: Porting Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Porting Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting, the assumption at this point is you *need* to port code. If
    you're not sure you do to port code, then maybe you don't. After all, if your
    C/C++ code works fine, then why change it?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: TODO This section will provide a more real world C/C++ example and port it to
    the equivalent Rust
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Automation tools
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Corrode
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Corrode](https://github.com/jameysharp/corrode) is a command-line tool that
    can partially convert C into Rust. At the very least it may spare you some drudgery
    ensuring the functionality is as close to the original as possible.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Corrode will take a C file, e.g. `somefile.c` plus any arguments from `gcc`
    and produces a `somefile.rs` which is the equivalent code in Rust.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: It works by parsing the C code into an abstract syntax tree and then generating
    Rust from that.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly Corrode is written in Haskell and more interestingly is written
    as a [literate Haskell source](https://github.com/jameysharp/corrode/blob/master/src/Language/Rust/Corrode/C.md)
    - the code is a markdown document interspersed with Haskell.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Bindgen
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Bindgen](https://github.com/servo/rust-bindgen) is a tool for generating FFI
    interfaces for Rust from existing C and C++ header files. You might find this
    beneficial if you''re porting code from C / C++, or writing a new component that
    must work with an existing code base.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Bindgen requires that you preinstall the Clang C++ compiler in order to parse
    code into a structure it can digest.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The readme documentation on the site link provides more information on installing
    and using the tool.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Experiences
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A number of websites offer insights of the porting process from C to Rust
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[Porting Zopfli from C to Rust](https://github.com/carols10cents/rust-out-your-c-talk).
    Zopfli is a library that performs good but slow deflate algorithm. It produces
    smaller compressed files than zlib while still remaining compatible with it.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: TODO
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tips
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use references wherever you can
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TODO references are equivalent to C++ references or to pointers in C. Passing
    by reference is an efficient way of passing any object greater than 64-bits in
    size into a function without relinquishing ownership. In some cases, it is even
    a good idea to return by reference since the caller can always clone the object
    if they need to, and more often than not they can just use the reference providing
    the lifetimes allow for it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: TODO you do not need to use references on intrinstic types such as integers,
    bools etc. and there is no point unless you intend for them to be mutable and
    change.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Learn move semantics
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C and C++ default to copy on assign, Rust moves on assign unless the type implements
    the `Copy` trait. This is easily one of the most mind boggling things that new
    Rust programmers will encounter. Code that works perfectly well in C++ will instantly
    fail in Rust.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The way to overcome this is first use references and secondly don't move unless
    you intend for the recipient to be the new owner of an object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: TODO if you intend for the recipient to own a copy of an object then implement
    the Clone trait on your struct. Then you may call `.clone()` and the recipient
    becomes the owner of the clone instead of your copy.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: TODO 如果你希望接收方拥有对象的副本，则在你的结构体上实现 Clone 特质。然后你可以调用`.clone()`，接收方将成为克隆的所有者，而不是你的副本。
- en: Use modules to naturally arrange your source code
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模块自然地组织你的源代码
- en: TODO
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: TODO
- en: Using composition and traits
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用组合和特质
- en: TODO Rust does not allow you to inherit one struct from another. The manner
    of overcoming this.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: TODO Rust 不允许你从另一个结构体继承。克服这一点的方法。
- en: Using Cargo.toml to create your build profiles
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Cargo.toml 创建你的构建配置文件
- en: Use Rust naming conventions and formatting
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Rust 命名规范和格式化
- en: C and C++ have never had
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 C++ 从未有过
- en: Foreign Function Interface
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部函数接口
- en: TODO for now read the [FFI omnibus](http://jakegoulding.com/rust-ffi-omnibus/).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: TODO 现在阅读 [FFI omnibus](http://jakegoulding.com/rust-ffi-omnibus/)。
- en: Leaving function names unmangled
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留函数名称不变
- en: TODO attribute no_mangle
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: TODO 添加 no_mangle 属性
- en: libc
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: libc
- en: TODO Rust provides a crate with bindings for C library functions. If you find
    yourself receiving a pointer allocated with malloc you could free it with the
    corresponding call to free() via the bindings.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: TODO Rust 提供了一个包含 C 库函数绑定的 crate。如果你发现自己接收到通过 malloc 分配的指针，你可以通过绑定调用对应的 free()
    来释放它。
- en: TODO add the following to your `Cargo.toml`
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: TODO 将以下内容添加到你的`Cargo.toml`中
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: TODO example of using libc
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: TODO 使用 libc 的示例
