- en: Boxes and MutationTuesday, February 21st
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To actually implement a circular structure, we will now use *side-effects*,
    using a new kind of Racket value which supports mutation: a box. A box value is
    built with the `box` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: the value is retrieved with the `unbox’ function,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: and finally, the value can be changed with the `set-box!` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: An important thing to note is that `set-box!` is much like `display` etc, it
    returns a value that is not printed in the Racket REPL, because there is no point
    in using the result of a `set-box!`, it is called for the side-effect it generates.
    (Languages like C blur this distinction between returning a value and a side-effect
    with its assignment statement.)
  prefs: []
  type: TYPE_NORMAL
- en: 'As a side note, we now have side effects of two kinds: mutation of state, and
    I/O (at least the O part). (Actually, there is also infinite looping that can
    be viewed as another form of a side effect.) This means that we’re now in a completely
    different world, and lots of new things can make sense now. A few things that
    you should know about:'
  prefs: []
  type: TYPE_NORMAL
- en: We never used more than one expression in a function body because there was
    no point in it, but now there is. To evaluate a sequence of Racket expressions,
    you wrap them in a `begin` expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In most places you don’t actually need to use `begin` — these are places that
    are said to have an *implicit* `begin`: the body of a function (or any lambda
    expression), the body of a `let` (and `let`-relatives), the consequence positions
    in `cond`, `match`, and `cases` clauses and more. One of the common places where
    a `begin` is used is in an `if` expression (and some people prefer using `cond`
    instead when there is more than a single expression).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cond` without an `else` in the end can make sense, if all you’re using it
    it for is side-effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if` could get a single expression which is executed when the condition is
    true (and an unspecified value is used otherwise), but our language (as well as
    the default Racket language) always forbids this — there are convenient special
    forms for a one-sided `if`s: `when` & `unless`, and they can have any number of
    expressions (they have an implicit `begin`). They have an advantage of saying
    “this code does some side-effects here” more explicit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a function called `for-each` which is just like `map`, except that
    it doesn’t collect the list of results, it is used only for performing side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When any one of these things is used (in Racket or other languages), you can
    tell that side-effects are involved, because there is no point in any of them
    otherwise. In addition, any name that ends with a `!` (“bang”) is used to mark
    a function that changes state (usually a function that only changes state).
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do we create a cycle? Simple, boxes can have any value, and they can
    be put in other values like lists, so we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'and we get a circular value. (Note how it is printed.) And with types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
