- en: Representing Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Queue Data Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `set-car!` and `set-cdr!` allows us to create a data structure that we
    could not have implemented efficiently before: a queue. A **queue** is a sequence
    in which items are inserted at one end (called the rear of the queue) and deleted
    from the other end (the front). Because items are always removed in the order
    in which they are inserted, a queue is sometimes called a FIFO (first in, first
    out).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](http://3.bp.blogspot.com/_w9XO9zBePXE/SKFjlee6K-I/AAAAAAAAAdk/iRjNgU62cmM/
    s1600/royston_queue.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Queue in Action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assume we have the functions `make-queue`, which returns a new queue, `insert-queue!`,
    which adds a new element to a queue, and `delete-queue!`, which removes an element
    in a queue (we are going to implement them soon!). Lets examine the mechanisms
    of a queue.
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Resulting Queue |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `(define q (make-queue))` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `(insert-queue! q ''a)` | `a` |'
  prefs: []
  type: TYPE_TB
- en: '| `(insert-queue! q ''b)` | `a b` |'
  prefs: []
  type: TYPE_TB
- en: '| `(delete-queue! q)` | b |'
  prefs: []
  type: TYPE_TB
- en: '| `(insert-queue! q ''c)` | b c |'
  prefs: []
  type: TYPE_TB
- en: '| `(insert-queue! q ''d)` | `b c d` |'
  prefs: []
  type: TYPE_TB
- en: '| `(delete-queue! q)` | `c d` |'
  prefs: []
  type: TYPE_TB
- en: 'In terms of data abstraction, we can regard a queue as defined by the following
    set of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'a constructor: `(make-queue)` returns an empty queue (a queue containing no
    items).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'two selectors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(empty-queue? <_queue_>)` tests if the queue is empty.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(front-queue <_queue_>)` returns the object at the front of the queue, signaling
    an error if the queue is empty. **It does not modify the queue.**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'two mutators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(insert-queue! <_queue_> <_item_>)` inserts the item at the rear of the queue
    and returns the modified queue as its value.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(delete-queue! <_queue_>)` removes the item at the front of the queue and
    returns the modified queue as its value, signaling an error if the queue is empty
    before the deletion.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Queues as Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because a queue is a list of items, we can technically represent it with an
    ordinary list. The front of the queue will be the `car` of the list, inserting
    a new element will be equivalent to appending a new pair at the end. Deleting
    an item will just be the `cdr`. Why don't we go with this implementation? The
    problem is the run time. To add an item to the back of a list, we have to go through
    a series of `cdr`s. If the list is really long, it will take us a really long
    time to find the last pair. The run time for this is `Î˜(n)`, where `n` is the
    length of the list.
  prefs: []
  type: TYPE_NORMAL
- en: A list allows us access to the first item in constant time, but when you need
    to find the last pair, it takes a long time. We can solve this by storing and
    updating the pointer to the backmost pair.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/44b4d2bc1275d24e3d1a3098b9325efb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking at the queue above, we see that we store two pointers: one that points
    to the front of the list and one to the back. If we try to add a new item, `''d`,
    to the queue, the structure will be changed into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ac70f6a07a551383054f2350a1c1b210.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we want to find the last pair of `q`, we can follow the `(cdr q)` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define the queue operations, we use the following procedures, which enable
    us to select and modify the front and rear pointers of a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can implement the actual queue operations. We will consider a queue
    to be empty if its front pointer is the empty list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `make-queue` constructor returns, as an initially empty queue, a pair whose
    `car` and `cdr` are both the empty list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To select the item at the front of the queue, we return the `car` of the pair
    indicated by the front pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Adding to a Queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will follow the general algorithm outlined before:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cons` a new pair containing the new item'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the queue is empty, we set its `front-ptr` and `rear-ptr` to this new pair
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the queue isn't empty, we find the final pair, change its `cdr` to the newly
    made pair and update the `rear-ptr`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (define (insert-queue! queue item) (let ((new-pair (cons item '()))) (cond ((empty-queue?
    queue) (set-front-ptr! queue new-pair) (set-rear-ptr! queue new-pair) queue) (else
    (set-cdr! (rear-ptr queue) new-pair) (set-rear-ptr! queue new-pair) queue))))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Deleting from a Queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To delete from a queue, we can simply change the `front-ptr` to point to the
    next pair.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/ac70f6a07a551383054f2350a1c1b210.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If starting from the queue above we decide to delete the first time, the change
    will only be where the `front-ptr` points to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/368ec8b3e335f9a139ebbaf028b67d33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Takeaways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`set-car!` and `set-cdr!` allows us to implement a new data structure (the
    queue) much more efficiently than what `cons`, `car`, and `cdr` alone can build.'
  prefs: []
  type: TYPE_NORMAL
