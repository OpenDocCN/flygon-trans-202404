- en: MapsTotal and Partial Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Coq Standard Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One small digression before we get to maps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unlike the chapters we have seen so far, this one does not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Require Import the chapter before it (and, transitively, all the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: earlier chapters).  Instead, in this chapter and from now, on
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we're going to import the definitions and theorems we need
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: directly from Coq's standard library stuff.  You should not notice
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: much difference, though, because we've been careful to name our
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: own definitions and theorems the same as their counterparts in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: standard library, wherever they overlap.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Documentation for the standard library can be found at
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[http://coq.inria.fr/library/](http://coq.inria.fr/library/).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Search command is a good way to look for theorems involving
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: objects of specific types.  Take a minute now to experiment with it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive id : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| Id : string → id.'
  prefs: []
  type: TYPE_NORMAL
- en: Definition beq_id x y :=
  prefs: []
  type: TYPE_NORMAL
- en: match x,y with
  prefs: []
  type: TYPE_NORMAL
- en: '| Id n[1], Id n[2] ⇒ if string_dec n[1] n[2] then true else false'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem beq_id_refl : ∀id, true = beq_id id id.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros [n]. simpl. destruct ([string_dec](http://coq.inria.fr/library/Coq.Strings.String.html#string_dec)
    n n).
  prefs: []
  type: TYPE_NORMAL
- en: '- reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- destruct n[0]. reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem beq_id_true_iff : ∀x y : id,'
  prefs: []
  type: TYPE_NORMAL
- en: beq_id x y = true ↔ x = y.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros [n[1]] [n[2]].
  prefs: []
  type: TYPE_NORMAL
- en: unfold [beq_id](Maps.html#beq_id).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([string_dec](http://coq.inria.fr/library/Coq.Strings.String.html#string_dec)
    n[1] n[2]).
  prefs: []
  type: TYPE_NORMAL
- en: '- subst. split. reflexivity. reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- split.'
  prefs: []
  type: TYPE_NORMAL
- en: + intros contra. inversion contra.
  prefs: []
  type: TYPE_NORMAL
- en: + intros H. inversion H. subst. destruct n. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem beq_id_false_iff : ∀x y : id,'
  prefs: []
  type: TYPE_NORMAL
- en: beq_id x y = false
  prefs: []
  type: TYPE_NORMAL
- en: ↔ x ≠ y.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros x y. rewrite ← [beq_id_true_iff](Maps.html#beq_id_true_iff).
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [not_true_iff_false](http://coq.inria.fr/library/Coq.Bool.Bool.html#not_true_iff_false).
    reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem false_beq_id : ∀x y : id,'
  prefs: []
  type: TYPE_NORMAL
- en: x ≠ y
  prefs: []
  type: TYPE_NORMAL
- en: → beq_id x y = false.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros x y. rewrite [beq_id_false_iff](Maps.html#beq_id_false_iff).
  prefs: []
  type: TYPE_NORMAL
- en: intros H. apply H. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Definition total_map (A:Type) := id → A.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition t_empty {A:Type} (v : A) : total_map A :='
  prefs: []
  type: TYPE_NORMAL
- en: (fun _ ⇒ v).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition t_update {A:Type} (m : total_map A)'
  prefs: []
  type: TYPE_NORMAL
- en: '(x : id) (v : A) :='
  prefs: []
  type: TYPE_NORMAL
- en: fun x' ⇒ if beq_id x x' then v else m x'.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Definition examplemap :=
  prefs: []
  type: TYPE_NORMAL
- en: t_update (t_update (t_empty false) (Id "foo") false)
  prefs: []
  type: TYPE_NORMAL
- en: (Id "bar") true.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Example update_example1 : examplemap (Id "baz") = false.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Example update_example2 : examplemap (Id "foo") = false.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Example update_example3 : examplemap (Id "quux") = false.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Example update_example4 : examplemap (Id "bar") = true.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma t_apply_empty:  ∀A x v, @t_empty A v x = v.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma t_update_eq : ∀A (m: total_map A) x v,'
  prefs: []
  type: TYPE_NORMAL
- en: (t_update m x v) x = v.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem t_update_neq : ∀(X:Type) v x[1] x[2]'
  prefs: []
  type: TYPE_NORMAL
- en: '(m : total_map X),'
  prefs: []
  type: TYPE_NORMAL
- en: x[1] ≠ x[2] →
  prefs: []
  type: TYPE_NORMAL
- en: (t_update m x[1] v) x[2] = m x[2].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma t_update_shadow : ∀A (m: total_map A) v[1] v[2] x,'
  prefs: []
  type: TYPE_NORMAL
- en: t_update (t_update m x v[1]) x v[2]
  prefs: []
  type: TYPE_NORMAL
- en: = t_update m x v[2].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma beq_idP : ∀x y, reflect (x = y) (beq_id x y).'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem t_update_same : ∀X x (m : total_map X),'
  prefs: []
  type: TYPE_NORMAL
- en: t_update m x (m x) = m.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem t_update_permute : ∀(X:Type) v[1] v[2] x[1] x[2]'
  prefs: []
  type: TYPE_NORMAL
- en: '(m : total_map X),'
  prefs: []
  type: TYPE_NORMAL
- en: x[2] ≠ x[1] →
  prefs: []
  type: TYPE_NORMAL
- en: (t_update (t_update m x[2] v[2]) x[1] v[1])
  prefs: []
  type: TYPE_NORMAL
- en: = (t_update (t_update m x[1] v[1]) x[2] v[2]).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Partial maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we define *partial maps* on top of total maps.  A partial
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: map with elements of type A is simply a total map with elements
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of type option A and default element None.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We now straightforwardly lift all of the basic lemmas about total
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: maps to partial maps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
