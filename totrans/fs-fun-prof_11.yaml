- en: The "Understanding F# types" Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: F# is not just about functions; the powerful type system is another key ingredient.
    And just as with functions, understanding the type system is critical to being
    fluent and comfortable in the language.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the common .NET types. F# has some other types that are very
    common in functional languages but not available in imperative languages like
    C# or Java.
  prefs: []
  type: TYPE_NORMAL
- en: This series introduces these types and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: '[Understanding F# types: Introduction](types-intro.html). A new world of types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Overview of types in F#](overview-of-types-in-fsharp.html). A look at the
    big picture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Type abbreviations](type-abbreviations.html). Also known as aliases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Tuples](tuples.html). Multiplying types together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Records](records.html). Extending tuples with labels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Discriminated Unions](discriminated-unions.html). Adding types together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Option type](the-option-type.html). And why it is not null or nullable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Enum types](enum-types.html). Not the same as a union type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Built-in .NET types](cli-types.html). Ints, strings, bools, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Units of measure](units-of-measure.html). Type safety for numerics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Understanding type inference](type-inference.html). Behind the magic curtain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Understanding F# types: Introduction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Understanding F# types: Introduction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*NOTE: Before reading this series, I suggest that you read the ["thinking functionally"](thinking-functionally.html)
    and ["expressions and syntax"](expressions-and-syntax.html) series as a prerequisite.*'
  prefs: []
  type: TYPE_NORMAL
- en: F# is not just about functions; the powerful type system is another key ingredient.
    And just as with functions, understanding the type system is critical to being
    fluent and comfortable in the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, so far we have seen some basic types that can be used as input and output
    to functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types such as `int`, `float`, `string`, and `bool`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple function types such as `int->int`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `unit` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of these types should be unfamiliar. Analogues of these are available in
    C# and other imperative languages.
  prefs: []
  type: TYPE_NORMAL
- en: But in this series we are going to introduce some new kinds of types that are
    very common in functional languages but uncommon in imperative languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The extended types we will look at in this series are:'
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Option type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enum types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all these types, we will discuss both the abstract principles and the details
    of how to use them in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Lists and other recursive data types are also very important types, but there
    is so much to say about them that they will need their own series!
  prefs: []
  type: TYPE_NORMAL
- en: Overview of types in F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview of types in F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into all the specific types, let's look at the big picture.
  prefs: []
  type: TYPE_NORMAL
- en: What are types for?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are coming from an object-oriented design background, one of the paradigm
    shifts involved in "thinking functionally" is to change how you think about types.
  prefs: []
  type: TYPE_NORMAL
- en: A well designed object-oriented program will have a strong focus on behavior
    rather than data, so it will use a lot of polymorphism, either using "duck-typing"
    or explicit interfaces, and will try to avoid having explicit knowledge of the
    actual concrete classes being passed around.
  prefs: []
  type: TYPE_NORMAL
- en: A well designed functional program, on the other hand, will have a strong focus
    on *data types* rather than behavior. F# puts much more emphasis on designing
    types correctly than an imperative language such as C#, and many of the examples
    in this series and later series will focus on creating and refining type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what is a type? Types are surprisingly hard to define. One definition from
    a well known textbook says:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A type system is a tractable syntactic method of proving the absence of certain
    program behaviors by classifying phrases according to the kinds of values they
    compute"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*(Benjamin Pierce, Types and Programming Languages)*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Ok, that definition is a bit technical. So let''s turn it around -- what do
    we use types for in practice? In the context of F#, you can think of types as
    being used in two main ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, as an *annotation to a value* that allows certain checks to be made,
    especially at compile time. In other words, types allow you to have "compile time
    unit tests".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, as *domains* for functions to act upon. That is, a type is a sort of
    data modeling tool that allows you to represent a real world domain in your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two definitions interact. The better the type definitions reflect the
    real-world domain, the better they will statically encode the business rules.
    And the better they statically encode the business rules, the better the "compile
    time unit tests" work. In the ideal scenario, if your program compiles, then it
    really is correct!
  prefs: []
  type: TYPE_NORMAL
- en: What kinds of types are there?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'F# is a hybrid language, so it has a mixture of types: some from its functional
    background, and some from its object-oriented background.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, the types in F# can be grouped into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common .NET types**. These are types that conform to the .NET Common Language
    Infrastructure (CLI), and which are easily portable to every .NET language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**F# specific types**. These are types that are part of the F# language and
    are designed for pure functional programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are familiar with C#, you will know all the CLI types. They include:'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in value types (int, bool, etc).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in reference types (string, etc).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-defined value types (enum and struct).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes and interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The F# specific types include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Function types](function-values-and-simple-values.html) (not the same as delegates
    or C# lambdas)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The unit type](how-types-work-with-functions.html#unit-type)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Tuples](tuples.html) (now part of .NET 4.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Records](records.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Discriminated Unions](discriminated-unions.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Option types](the-option-type.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists (not the same as the .NET List class)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I strongly recommend that when creating new types you stick with the F# specific
    types rather than using classes. They have a number of advantages over the CLI
    types, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: They are immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They cannot be null
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have built-in structural equality and comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have built-in pretty printing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sum and Product types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key to understanding the power of types in F# is that most new types are
    constructed by from other types using two basic operations: **sum** and **product**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, in F# you can define new types almost as if you were doing algebra:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I will hold off explaining what **sum** and **product** mean in practice until
    we get to the detailed discussion of tuples (products) and discriminated union
    (sum) types later in this series.
  prefs: []
  type: TYPE_NORMAL
- en: The key point is that an infinite number of new types can be made by combining
    existing types together using these "product" and "sum" methods in various ways.
    Collectively these are called "algebraic data types" or ADTs (not to be confused
    with *abstract data types*, also called ADTs). Algebraic data types can be used
    to model anything, including lists, trees, and other recursive types.
  prefs: []
  type: TYPE_NORMAL
- en: The sum or "union" types, in particular, are very valuable, and once you get
    used to them, you will find them indispensible!
  prefs: []
  type: TYPE_NORMAL
- en: How types are defined
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every type definition is similar, even though the specific details may vary.
    All type definitions start with a "`type`" keyword, followed by an identifier
    for the type, followed by any generic type parameters, followed by the definition.
    For example, here are some type definitions for a variety of types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we said in a [previous post](function-signatures.html), there is a special
    syntax for defining new types that is different from the normal expression syntax.
    So do be aware of this difference.
  prefs: []
  type: TYPE_NORMAL
- en: Types can *only* be declared in namespaces or modules. But that doesn't mean
    you always have to create them at the top level -- you can create types in nested
    modules if you need to hide them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Types *cannot* be declared inside functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Constructing and deconstructing types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After a type is defined, instances of the type are created using a "constructor"
    expression that often looks quite similar to the type definition itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What is interesting is that the *same* "constructor" syntax is also used to
    "deconstruct" the type when doing pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you read through this series, pay attention to how the constructors are used
    in both ways.
  prefs: []
  type: TYPE_NORMAL
- en: Field guide to the "type" keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The same "type" keyword is used to define all the F# types, so they can all
    look very similar if you are new to F#. Here is a quick list of these types and
    how to tell the difference between them.
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Example | Distinguishing features |'
  prefs: []
  type: TYPE_TB
- en: '| **Abbrev (Alias)** |'
  prefs: []
  type: TYPE_TB
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '| Uses equal sign only. |'
  prefs: []
  type: TYPE_TB
- en: '| **Tuple** |'
  prefs: []
  type: TYPE_TB
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| Always available to be used and are not explicitly defined with the `type`
    keyword. Usage indicated by comma (with optional parentheses). |'
  prefs: []
  type: TYPE_TB
- en: '| **Record** |'
  prefs: []
  type: TYPE_TB
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '| Curly braces. Uses semicolon to separate fields. |'
  prefs: []
  type: TYPE_TB
- en: '| **Discriminated Union** |'
  prefs: []
  type: TYPE_TB
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '| Vertical bar character. Uses "of" for types. |'
  prefs: []
  type: TYPE_TB
- en: '| **Enum** |'
  prefs: []
  type: TYPE_TB
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '| Similar to Unions, but uses equals and an int value |'
  prefs: []
  type: TYPE_TB
- en: '| **Class** |'
  prefs: []
  type: TYPE_TB
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '| Has function-style parameter list after name for use as constructor. Has
    "member" keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: Has "new" keyword for secondary constructors. |
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interface** |'
  prefs: []
  type: TYPE_TB
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '| Same as class but all members are abstract. Abstract members have colon and
    type signature rather than a concrete implementation. |'
  prefs: []
  type: TYPE_TB
- en: '| **Struct** |'
  prefs: []
  type: TYPE_TB
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '| Has "struct" keyword. Uses "val" to define fields.'
  prefs: []
  type: TYPE_NORMAL
- en: Can have constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Type abbreviations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type abbreviations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the simplest type definition, a type abbreviation or alias.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'where "existing type" can be any type: one of the basic types we have already
    seen, or one of the extended types we will be seeing soon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And so on -- pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Type abbreviations are useful to provide documentation and avoid writing a signature
    repeatedly. In the above examples, `ComplexNumber` and `AdditionFunction` demonstrate
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Another use is to provide some degree of decoupling between the usage of a type
    and the actual implementation of a type. In the above examples, `ProductCode`
    and `CustomerId` demonstrate this. I could easily change `CustomerId` to be a
    string without changing (most of) my code.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, one thing is to note is that this really is just an alias or abbreviation;
    you are not actually creating a new type. So if I define a function that I explicitly
    say is an `AdditionFunction`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: the compiler will erase the alias and return a plain `int->int->int` as the
    function signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, there is no true encapsulation. I could use an explicit `int`
    anywhere I used a `CustomerId` and the compiler would not complain. And if I had
    attempted to create safe versions of entity ids such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: then I would be disappointed. There would be nothing preventing me from using
    an `OrderId` in place of a `CustomerId` and vice versa. To get true encapsulated
    types like this, we will need to use single case union types, as described in
    a later post.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're ready for our first extended type -- the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by stepping back again and looking at a type such as "int". As we
    hinted at before, rather than thinking of "int" as a abstract thing, you can think
    of it as concrete collection of all its possible values, namely the set {...,-3,
    -2, -1, 0, 2, 3, ...}.
  prefs: []
  type: TYPE_NORMAL
- en: 'So next, imagine two copies of this "int" collection. We can "multiply" them
    together by taking the Cartesian product of them; that is, making a new list of
    objects by picking every possible combination of the two "int" lists, as shown
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![int*int tuple](tuple_int_int.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we have already seen, these pairs are called tuples in F#. And now you can
    see why they have the type signature that they do. In this example, the "int times
    int" type is called "`int * int`", and the star symbol means "multiply" of course!
    The valid instances of this new type are all the pairs: (-2,2),(-1,0), (2,2) and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how they might be used in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now if you evaluate the code above you will see that the types of t1 and t2
    are `int*int` as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This "product" approach can be used to make tuples out of any mixture of types.
    Here is one for "int times bool".
  prefs: []
  type: TYPE_NORMAL
- en: '![int*bool tuple](tuple_int_bool.png)'
  prefs: []
  type: TYPE_IMG
- en: And here is the usage in F#. The tuple type above has the signature "`int*bool`".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Strings can be used as well, of course. The universe of all possible strings
    is very large, but conceptually it is the same thing. The tuple type below has
    the signature "`string*int`".
  prefs: []
  type: TYPE_NORMAL
- en: '![string*int tuple](tuple_str_int.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Test the usage and signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: And there is no reason to stop at multiplying just two types together. Why not
    three? Or four? For example, here is the type `int * bool * string`.
  prefs: []
  type: TYPE_NORMAL
- en: '![int*bool*string tuple](tuple_int_bool_str.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Test the usage and signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Generic tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generics can be used in tuples too.
  prefs: []
  type: TYPE_NORMAL
- en: '![''a*''b tuple](tuple_a_b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The usage is normally associated with functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And the function signature is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: which means that "`genericTupleFn`" takes a generic tuple `('a * 'b)` and returns
    a `unit`
  prefs: []
  type: TYPE_NORMAL
- en: Tuples of complex types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any kind of type can be used in a tuple: other tuples, classes, function types,
    etc. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Key points about tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some key things to know about tuples are:'
  prefs: []
  type: TYPE_NORMAL
- en: A particular instance of a tuple type is a *single object*, similar to a two-element
    array in C#, say. When using them with functions they count as a *single* parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuple types cannot be given explicit names. The "name" of the tuple type is
    determined by the combination of types that are multiplied together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of the multiplication is important. So `int*string` is not the same
    tuple type as `string*int`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The comma is the critical symbol that defines tuples, not the parentheses. You
    can define tuples without the parentheses, although it can sometimes be confusing.
    In F#, if you see a comma, it is probably part of a tuple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These points are very important -- if you don't understand them you will get
    confused quite quickly!
  prefs: []
  type: TYPE_NORMAL
- en: 'And it is worth re-iterating the point made in [previous posts](defining-functions.html):
    *don''t mistake tuples for multiple parameters in a function*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Making and matching tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tuple types in F# are somewhat more primitive than the other extended types.
    As you have seen, you don't need to explicitly define them, and they have no name.
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to make a tuple -- just use a comma!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And as we have seen, to "deconstruct" a tuple, use the same syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When pattern matching like this, you must have the same number of elements,
    otherwise you will get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you don't need some of the values, you can use the "don't care" symbol (the
    underscore) as a placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you might guess, a two element tuple is commonly called a "pair" and a three
    element tuple is called a "triple" and so on. In the special case of pairs, there
    are functions `fst` and `snd` which extract the first and second element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: They only work on pairs. Trying to use `fst` on a triple will give an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Using tuples in practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tuples have a number of advantages over other more complex types. They can be
    used on the fly because they are always available without being defined, and thus
    are perfect for small, temporary, lightweight structures.
  prefs: []
  type: TYPE_NORMAL
- en: Using tuples for returning multiple values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a common scenario that you want to return two values from a function rather
    than just one. For example, in the `TryParse` style functions, you want to return
    (a) whether the value was parsed and (b) if parsed, what the parsed value was.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an implementation of `TryParse` for integers (assuming it did not already
    exist, of course):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s another simple example that returns a pair of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Creating tuples from other tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with most F# values, tuples are immutable and the elements within them cannot
    be assigned to. So how do you change a tuple? The short answer is that you can't
    -- you must always create a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say that you need to write a function that, given a tuple, adds one to each
    element. Here''s an obvious implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems a bit long winded -- is there a more compact way? Yes, because you
    can deconstruct a tuple directly in the parameters of a function, so that the
    function becomes a one liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Equality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tuples have an automatically defined equality operation: two tuples are equal
    if they have the same length and the values in each slot are equal.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to compare tuples of different lengths is a type error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And the types in each slot must be the same as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Tuples also have an automatically defined hash value based on the values in
    the tuple, so that tuples can be used as dictionary keys without problems.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Tuple representation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: And as noted in a [previous post](convenience-types.html), tuples have a nice
    default string representation, and can be serialized easily.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we noted in the previous post, plain tuples are useful in many cases. But
    they have some disadvantages too. Because all tuple types are pre-defined, you
    can't distinguish between a pair of floats used for geographic coordinates say,
    vs. a similar tuple used for complex numbers. And when tuples have more than a
    few elements, it is easy to get confused about which element is in which place.
  prefs: []
  type: TYPE_NORMAL
- en: In these situations, what you would like to do is *label* each slot in the tuple,
    which will both document what each element is for and force a distinction between
    tuples made from the same types.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the "record" type. A record type is exactly that, a tuple where each element
    is labeled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'A record type has the standard preamble: `type [typename] =` followed by curly
    braces. Inside the curly braces is a list of `label: type` pairs, separated by
    semicolons (remember, all lists in F# use semicolon separators -- commas are for
    tuples).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compare the "type syntax" for a record type with a tuple type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the record type, there is no "multiplication", just a list of labeled types.
  prefs: []
  type: TYPE_NORMAL
- en: Relational database theory uses a similar "record type" concept. In the relational
    model, a relation is a (possibly empty) finite set of tuples all having the same
    finite set of attributes. This set of attributes is familiarly referred to as
    the set of column names.
  prefs: []
  type: TYPE_NORMAL
- en: Making and matching records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a record value, use a similar format to the type definition, but using
    equals signs after the labels. This is called a "record expression."
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And to "deconstruct" a record, use the same syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As always, if you don't need some of the values, you can use the underscore
    as a placeholder; or more cleanly, just leave off the unwanted label altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you just need a single property, you can use dot notation rather than pattern
    matching.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you can leave a label off when deconstructing, but not when constructing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: One of the most noticeable features of record types is use of curly braces.
    Unlike C-style languages, curly braces are rarely used in F# -- only for records,
    sequences, computation expressions (of which sequences are a special case), and
    object expressions (creating implementations of interfaces on the fly). These
    other uses will be discussed later.
  prefs: []
  type: TYPE_NORMAL
- en: Label order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unlike tuples, the order of the labels is not important. So the following two
    values are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Naming conflicts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the examples above, we could construct a record by just using the label names
    "`lat`" and "`long`". Magically, the compiler knew what record type to create.
    (Well, in truth, it was not really that magical, as only one record type had those
    exact labels.)
  prefs: []
  type: TYPE_NORMAL
- en: 'But what happens if there are two record types with the same labels? How can
    the compiler know which one you mean? The answer is that it can''t -- it will
    use the most recently defined type, and in some cases, issue a warning. Try evaluating
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'What type is `p`? Answer: `Person2`, which was the last type defined with those
    labels.'
  prefs: []
  type: TYPE_NORMAL
- en: And if you try to deconstruct, you will get a warning about ambiguous field
    labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How can you fix this? Simply by adding the type name as a qualifier to at least
    one of the labels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If needed, you can even add a fully qualified name (with namespace). Here's
    an example using [modules](organizing-functions.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if you can ensure there is only one version in the local namespace,
    you can avoid having to do this at all.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The moral of the story is that when defining record types, you should try to
    use unique labels if possible, otherwise you will get ugly code at best, and unexpected
    behavior at worst.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in F#, unlike some other functional languages, two types with exactly
    the same structural definition are not the same type. This is called a "nominal"
    type system, where two types are only equal if they have the same name, as opposed
    to a "structural" type system, where definitions with identical structures will
    be the same type regardless of what they are called.
  prefs: []
  type: TYPE_NORMAL
- en: Using records in practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How can we use records? Let us count the ways...
  prefs: []
  type: TYPE_NORMAL
- en: Using records for function results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like tuples, records are useful for passing back multiple values from
    a function. Let''s revisit the tuple examples described earlier, rewritten to
    use records instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You can see that having explicit labels in the return value makes it much easier
    to understand (of course, in practice we would probably use an `Option` type,
    discussed later).
  prefs: []
  type: TYPE_NORMAL
- en: 'And here''s the word and letter count example using records rather than tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Creating records from other records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again, as with most F# values, records are immutable and the elements within
    them cannot be assigned to. So how do you change a record? Again the answer is
    that you can't -- you must always create a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say that you need to write a function that, given a `GeoCoord` record, adds
    one to each element. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'But again you can simplify by deconstructing directly in the parameters of
    a function, so that the function becomes a one liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'or depending on your taste, you can also use dot notation to get the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In many cases, you just need to tweak one or two fields and leave all the others
    alone. To make life easier, there is a special syntax for this common case, the
    "`with`" keyword. You start with the original value, followed by "with" and then
    the fields you want to change. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The technical term for "with" is a copy-and-update record expression.
  prefs: []
  type: TYPE_NORMAL
- en: Record equality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like tuples, records have an automatically defined equality operation: two
    records are equal if they have the same type and the values in each slot are equal.'
  prefs: []
  type: TYPE_NORMAL
- en: And records also have an automatically defined hash value based on the values
    in the record, so that records can be used as dictionary keys without problems.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Record representation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted in a [previous post](convenience-types.html), records have a nice default
    string representation, and can be serialized easily. But unlike tuples, the `ToString()`
    representation is unhelpful.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Sidebar: %A vs. %O in print format strings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just saw that print format specifiers `%A` and `%O` produce very different
    results for the same record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: So why the difference?
  prefs: []
  type: TYPE_NORMAL
- en: '`%A` prints the value using the same pretty printer that is used for interactive
    output. But `%O` uses `Object.ToString()`, which means that if the `ToString`
    method is not overridden, `%O` will give the default (and generally unhelpful)
    output. So in general, you should try to use `%A` to `%O` where possible, because
    the core F# types do have pretty-printing by default.'
  prefs: []
  type: TYPE_NORMAL
- en: But note that the F# "class" types do *not* have a standard pretty printed format,
    so `%A` and `%O` are equally uncooperative unless you override `ToString`.
  prefs: []
  type: TYPE_NORMAL
- en: Discriminated Unions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Discriminated Unions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tuples and records are examples of creating new types by "multiplying" existing
    types together. At the beginning of the series, I mentioned that the other way
    of creating new types was by "summing" existing types. What does this mean?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, let''s say that we want to define a function that works with integers
    OR booleans, maybe to convert them into strings. But we want to be strict and
    not accept any other type (such as floats or strings). Here''s a diagram of such
    as function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![function from int union bool](fun_int_union_bool.png)'
  prefs: []
  type: TYPE_IMG
- en: How could we represent the domain of this function?
  prefs: []
  type: TYPE_NORMAL
- en: What we need is a type that represents all possible integers PLUS all possible
    booleans.
  prefs: []
  type: TYPE_NORMAL
- en: '![int union bool](int_union_bool.png)'
  prefs: []
  type: TYPE_IMG
- en: In other words, a "sum" type. In this case the new type is the "sum" of the
    integer type plus the boolean type.
  prefs: []
  type: TYPE_NORMAL
- en: In F#, a sum type is called a "discriminated union" type. Each component type
    (called a *union case*) must be tagged with a label (called a *case identifier*
    or *tag*) so that they can be told apart ("discriminated"). The labels can be
    any identifier you like, but must start with an uppercase letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we might define the type above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The "I" and the "B" are just arbitrary labels; we could have used any other
    labels that were meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: 'For small types, we can put the definition on one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The component types can be any other type you like, including tuples, records,
    other union types, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You can even have types that are recursive, that is, they refer to themselves.
    This is typically how tree structures are defined. Recursive types will be discussed
    in more detail shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Sum types vs. C++ unions and VB variants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At first glance, a sum type might seem similar to a union type in C++ or a variant
    type in Visual Basic, but there is a key difference. The union type in C++ is
    not type-safe and the data stored in the type can be accessed using any of the
    possible tags. An F# discriminated union type is safe, and the data can only be
    accessed one way. It really is helpful to think of it as a sum of two types (as
    shown in the diagram), rather than as just an overlay of data.
  prefs: []
  type: TYPE_NORMAL
- en: Key points about union types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some key things to know about union types are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertical bar is optional before the first component, so that the following
    definitions are all equivalent, as you can see by examining the output of the
    interactive window:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The tags or labels must start with an uppercase letter. So the following will
    give an error:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Other named types (such as `Person` or `IntOrBool`) must be pre-defined outside
    the union type. You can''t define them "inline" and write something like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The labels can be any identifier, including the names of the component type
    themselves, which can be quite confusing if you are not expecting it. For example,
    if the `Int32` and `Boolean` types (from the `System` namespace) were used instead,
    and the labels were named the same, we would have this perfectly valid definition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This "duplicate naming" style is actually quite common, because it documents
    exactly what the component types are.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a value of a union type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a value of a union type, you use a "constructor" that refers to only
    one of the possible union cases. The constructor then follows the form of the
    definition, using the case label as if it were a function. In the `IntOrBool`
    example, you would write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting value is printed out with the label along with the component
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'If the case constructor has more than one "parameter", you construct it in
    the same way that you would call a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The case constructors for union types are normal functions, so you can use
    them anywhere a function is expected. For example, in `List.map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Naming conflicts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a particular case has a unique name, then the type to construct will be unambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: But what happens if you have two types which have cases with the same labels?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the last one defined is generally used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'But it is much better to explicitly qualify the type, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'And if the types come from different modules, you can use the module name as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Matching on union types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For tuples and records, we have seen that "deconstructing" a value uses the
    same model as constructing it. This is also true for union types, but we have
    a complication: which case should we deconstruct?'
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly what the "match" expression is designed for. As you should now
    realize, the match expression syntax has parallels to how a union type is defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze what is going on here:'
  prefs: []
  type: TYPE_NORMAL
- en: Each "branch" of the overall match expression is a pattern expression that is
    designed to match the corresponding case of the union type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pattern starts with the tag for the particular case, and then the rest of
    the pattern deconstructs the type for that case in the usual way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pattern is followed by an arrow "->" and then the code to execute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Empty cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The label for a union case does not have to have to have any type after it.
    The following are all valid union types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'If *all* the cases are empty, then we have an "enum style" union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Note that this "enum style" union is *not* the same as a true C# enum type,
    discussed later.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an empty case, just use the label as a constructor without any parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Single cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes it is useful to create union types with only one case. This might
    be seem useless, because you don't seem to be adding value. But in fact, this
    a very useful practice that can enforce type safety*.
  prefs: []
  type: TYPE_NORMAL
- en: '[* And in a future series we''ll see that, in conjuction with module signatures,
    single case unions can also help with data hiding and capability based security.]'
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say that we have customer ids and order ids which are both
    represented by integers, but that they should never be assigned to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw before, a type alias approach will not work, because an alias is
    just a synonym and doesn''t create a distinct type. Here''s how you might try
    to do it with aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: But even though I explicitly annotated the `orderId` parameter to be of type
    `OrderId`, I can't ensure that customer ids are not accidentally passed in.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we create simple union types, we can easily enforce the
    type distinctions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This approach is feasible in C# and Java as well, but is rarely used because
    of the overhead of creating and managing the special classes for each type. In
    F# this approach is lightweight and therefore quite common.
  prefs: []
  type: TYPE_NORMAL
- en: A convenient thing about single case union types is you can pattern match directly
    against a value without having to use a full `match-with` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: But a common "gotcha" is that in some cases, the pattern match must have parens
    around it, otherwise the compiler will think you are defining a function!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, if you ever do need to create an enum-style union type with a single
    case, you will have to start the case with a vertical bar in the type definition;
    otherwise the compiler will think you are creating an alias.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Union equality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like other core F# types, union types have an automatically defined equality
    operation: two unions are equal if they have the same type and the same case and
    the values for that case is equal.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Union representation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Union types have a nice default string representation, and can be serialized
    easily. But unlike tuples, the ToString() representation is unhelpful.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The Option type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Option type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's look at a particular union type, the Option type. It is so common
    and so useful that it is actually built into the language.
  prefs: []
  type: TYPE_NORMAL
- en: You have already seen the option type discussed in passing, but let's go back
    to basics and understand how it fits into the type system.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very common situation is when you want to represent missing or invalid values.
    Using a diagram, the domain would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![int option](int_option.png)'
  prefs: []
  type: TYPE_IMG
- en: Obviously this calls for some kind of union type!
  prefs: []
  type: TYPE_NORMAL
- en: 'In F#, it is called the `Option` type, and is defined as union type with two
    cases: `Some` and `None`. A similar type is common in functional languages: OCaml
    and Scala also call it `Option`, while Haskell calls it `Maybe`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'IMPORTANT: if you evaluate this in the interactive window, be sure to reset
    the session afterwards, so that the built-in type is restored.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The option type is used in the same way as any union type in construction,
    by specifying one of the two cases, the `Some` case or the `None` case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'and when pattern matching, as with any union type, you must always match all
    the cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'When defining a type that references the Option type, you must specify the
    generic type to use. You can do this in an explicit way, with angle brackets,
    or use the built-in "`option`" keyword which comes after the type. The following
    examples are identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Using the Option type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The option type is widely used in the F# libraries for values that might be
    missing or otherwise invalid.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `List.tryFind` function returns an option, with the `None`
    case used indicate that nothing matches the search predicate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s revisit the same example we used for tuples and records, and see how
    options might be used instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Of these three approaches, the "option" version is generally preferred; no new
    types need to be defined and for simple cases, the meaning of `None` is obvious
    from the context.
  prefs: []
  type: TYPE_NORMAL
- en: '*NOTE: The `tryParseOption` code is just an example. A similar function `tryParse`
    is built into the .NET core libraries and should be used instead.*'
  prefs: []
  type: TYPE_NORMAL
- en: Option equality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like other union types, option types have an automatically defined equality
    operation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Option representation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Option types have a nice default string representation, and unlike other union
    types, the `ToString()` representation is also nice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Options are not just for primitive types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The F# option is a true first class type (it's just a normal union type, after
    all). You can use it with *any* type. For example, you can have an option of a
    complex type like Person, or a tuple type like `int*int`, or a function type like
    `int->bool`, or even an option of an option type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: How the Option type should not be used
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The option type has functions such as `IsSome`, `IsNone` and `Value`, which
    allow you to access the "wrapped" value without doing pattern matching. Don't
    use them! Not only it is not idiomatic, but it is dangerous and can cause exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how not to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how to do it properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The pattern matching approach also forces you to think about and document what
    happens in the `None` case, which you might easily overlook when using `IsSome`.
  prefs: []
  type: TYPE_NORMAL
- en: The Option module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are doing a lot of pattern matching on options, look into the `Option`
    module, as it has some useful helper functions like `map`, `bind`, `iter` and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say that I want to multiply the value of an option by 2 if it
    is valid. Here''s the pattern matching way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s a more compact version written using `Option.map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Or perhaps I want to multiply the value of an option by 2 if it is valid but
    return 0 if it is `None`. Here''s the pattern matching way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the same thing as a one-liner using `Option.fold`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: In simple cases like the one above, the `defaultArg` function can be used as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Option vs. Null vs. Nullable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The option type often causes confusion to people who are used to dealing with
    nulls and nullables in C# and other languages. This section will try to clarify
    the differences.
  prefs: []
  type: TYPE_NORMAL
- en: Type safety of Option vs. null
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a language like C# or Java, "null" means a reference or pointer to an object
    that doesn't exist. The "null" has *exactly the same type* as the object, so you
    can't tell from the type system that you have a null.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the C# code below we create two string variables, one with a
    valid string and one with a null string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: This compiles perfectly, of course. The compiler cannot tell the difference
    between the two variables. The `null` is exactly the same type as the valid string,
    so all the `System.String` methods and properties can be used on it, including
    the `Length` property.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know that this code will fail by just looking at it, but the compiler
    can't help us. Instead, as we all know, you have to tediously test for nulls constantly.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at the nearest F# equivalent of the C# example above. In F#,
    to indicate missing data, you would use an option type and set it to `None`. (In
    this artificial example we have to use an ugly explicitly typed `None` -- normally
    this would not be necessary.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: In the F# version, we get a *compile-time* error immediately. The `None` is
    *not* a string, it's a different type altogether, so you can't call `Length` on
    it directly. And to be clear, `Some [string]` is *also* not the same type as `string`,
    so you can't call `Length` on it either!
  prefs: []
  type: TYPE_NORMAL
- en: So if `Option<string>` is not a string, but you want to do something with the
    string it (might) contain, you are forced to have to pattern match on it (assuming
    you don't do bad things as described earlier).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: You always have to pattern match, because given a value of type `Option<string>`,
    you can't tell whether it is Some or None.
  prefs: []
  type: TYPE_NORMAL
- en: In just the same way `Option<int>` is not the same type as `int`, `Option<bool>`
    is not the same type as `bool`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize the critical points:'
  prefs: []
  type: TYPE_NORMAL
- en: The type "`string option`" is not at all the same type as "`string`". You cannot
    cast from `string option` to `string` -- they do not have the same properties.
    A function that works with `string` will not work with `string option`, and vice
    versa. So the type system will prevent any errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, a "null string" in C# is exactly the same type as "string".
    You cannot tell them apart at compile time, only at run time. A "null string"
    appears to have all the same properties and functions as a valid string, except
    that your code will blow up when you try to use it!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nulls vs. missing data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A "null" as used in C# is completely different from the concept of "missing"
    data, which is a valid part of modeling any system in any language.
  prefs: []
  type: TYPE_NORMAL
- en: In a true functional language there can be a concept of missing data, but there
    can be no such thing as "null", because the concepts of "pointers" or "uninitialized
    variables" do not exist in the functional way of thinking.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a value bound to the result of an expression like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: How can that value ever be uninitialized, or become null, or even become any
    other value at all?
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, additional confusion has been caused because in some cases API
    designers have used null to indicate the concept of "missing" data as well! For
    example, the .NET library method `StreamReader.ReadLine` returns null to indicate
    that there is no more data in a file.
  prefs: []
  type: TYPE_NORMAL
- en: F# and null
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: F# is not a pure functional language, and has to interact with the .NET languages
    that *do* have the concept of null. Therefore, F# does include a `null` keyword
    in its design, but makes it hard to use and treats it as an abnormal value.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, nulls are never created in "pure" F#, but only by interacting
    with the .NET libraries or other external systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: In these cases, it is good practice to immediately check for nulls and convert
    them into an option type!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: And on occasion, you may need to pass a null to an external library. You can
    do this using the `null` keyword as well.
  prefs: []
  type: TYPE_NORMAL
- en: Option vs. Nullable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to null, C# has the concept of a Nullable type, such as `Nullable<int>`,
    which seems similar to the option type. So what's the difference?
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is the same, but Nullable is much weaker. It only works on value
    types such as `Int` and `DateTime`, not on reference types such as strings or
    classes or functions. You can't nest Nullables, and they don't have much special
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the F# option is a true first class type and can be used
    consistently across all types in the same way. (See the examples above in the
    "Options are not just for primitive types" section.)
  prefs: []
  type: TYPE_NORMAL
- en: Enum types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enum types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The enum type in F# is the same as the enum type in C#. Its definition is superficially
    just like that of a union type, but there are many non-obvious differences to
    be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: Defining enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To define an enum you use exactly the same syntax as a union type with empty
    cases, except that you must specify a constant value for each case, and the constants
    must all be of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings are not allowed, only ints or compatible types such bytes and chars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Union types require that their cases start with an uppercase letter. This is
    not required for enums.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as with C#, you can use the FlagsAttribute for bit flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Constructing enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike union types, to construct an enum you *must always* use a qualified
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also cast to and from the underlying int type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: You can even create values that are not on the enumerated list at all.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'And, unlike unions, you can use the BCL Enum functions to enumerate and parse
    values, just as with C#. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Matching enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To match an enum you must again *always* use a qualified name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Both unions and enums will warn if you have not covered all known cases when
    pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: One important difference between unions and enums is that can you make the compiler
    happy about exhaustive pattern matching by listing all the union types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not so for enums. It is possible to create an enum not on the predeclared list,
    and try to match with it, and get a runtime exception, so the compiler will warn
    you even if you have explicitly listed all the known enums:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The only way to fix this is to add a wildcard to the bottom of the cases, to
    handle enums outside the predeclared range.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In general, you should prefer discriminated union types over enums, unless you
    really need to have an `int` value associated with them, or you are writing types
    that need to be exposed to other .NET languages.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in .NET types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Built-in .NET types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this post we'll take a quick look at how F# handles the [standard types that
    are built into .NET](http://msdn.microsoft.com/en-us/library/hfa3fa08%28VS.80%29.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# uses the same syntax for literals that C# does, with a few exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ll divide the built-in types into the following groups:'
  prefs: []
  type: TYPE_NORMAL
- en: miscellaneous types (`bool`, `char`, etc. )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: string types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: integer types (`int`, `uint` and `byte`, etc)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: float types (`float`, `decimal`, etc)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pointer types (`IntPtr`, etc)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following tables list the primitive types, with their F# keywords, their
    suffixes if any, an example, and the corresponding .NET CLR type.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '|  | Object | Unit | Bool | Char (Unicode) | Char (Ascii) |'
  prefs: []
  type: TYPE_TB
- en: '| Keyword | obj | unit | bool | char | byte |'
  prefs: []
  type: TYPE_TB
- en: '| Suffix |  |  |  |  | B |'
  prefs: []
  type: TYPE_TB
- en: '| Example | let o = obj() | let u = () | true false | ''a'' | ''a''B |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Type | Object | (no equivalent) | Boolean | Char | Byte |'
  prefs: []
  type: TYPE_TB
- en: Object and unit are not really .NET primitive types, but I have included them
    for the sake of completeness.
  prefs: []
  type: TYPE_NORMAL
- en: String types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '|  | String (Unicode) | Verbatim string (Unicode) | Triple quoted string (Unicode)
    | String (Ascii) |'
  prefs: []
  type: TYPE_TB
- en: '| Keyword | string | string | string | byte[] |'
  prefs: []
  type: TYPE_TB
- en: '| Suffix |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Example | "first\nsecond line" | @"C:\name" | """can "contain"" special chars"""
    | "aaa"B |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Type | String | String | String | Byte[] |'
  prefs: []
  type: TYPE_TB
- en: 'The usual special characters can be used inside normal strings, such as `\n`,
    `\t`, `\\`, etc. Quotes must be escaped with a backslash: `\''` and `\"`.'
  prefs: []
  type: TYPE_NORMAL
- en: In verbatim strings, backslashes are ignored (good for Windows filenames and
    regex patterns). But quotes need to be doubled.
  prefs: []
  type: TYPE_NORMAL
- en: Triple-quoted strings are new in VS2012\. They are useful because special characters
    do not need to be escaped at all, and so they can handle embedded quotes nicely
    (great for XML).
  prefs: []
  type: TYPE_NORMAL
- en: Integer types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '|  | 8 bit (Signed) | 8 bit (Unsigned) | 16 bit (Signed) | 16 bit (Unsigned)
    | 32 bit (Signed) | 32 bit (Unsigned) | 64 bit (Signed) | 64 bit (Unsigned) |
    Unlimited precision |'
  prefs: []
  type: TYPE_TB
- en: '| Keyword | sbyte | byte | int16 | uint16 | int | uint32 | int64 | uint64 |
    bigint |'
  prefs: []
  type: TYPE_TB
- en: '| Suffix | y | uy | s | us |  | u | L | UL | I |'
  prefs: []
  type: TYPE_TB
- en: '| Example | 99y | 99uy | 99s | 99us | 99 | 99u | 99L | 99UL | 99I |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Type | SByte | Byte | Int16 | UInt16 | Int32 | UInt32 | Int64 | UInt64
    | BigInteger |'
  prefs: []
  type: TYPE_TB
- en: '`BigInteger` is available in all versions of F#. From .NET 4 it is included
    as part of the .NET base library.'
  prefs: []
  type: TYPE_NORMAL
- en: Integer types can also be written in hex and octal.
  prefs: []
  type: TYPE_NORMAL
- en: The hex prefix is `0x`. So `0xFF` is hex for 255\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The octal prefix is `0o`. So `0o377` is octal for 255.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating point types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '|  | 32 bit floating point | 64 bit (default) floating point | High precision
    floating point |'
  prefs: []
  type: TYPE_TB
- en: '| Keyword | float32, single | float, double | decimal |'
  prefs: []
  type: TYPE_TB
- en: '| Suffix | f |  | m |'
  prefs: []
  type: TYPE_TB
- en: '| Example | 123.456f | 123.456 | 123.456m |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Type | Single | Double | Decimal |'
  prefs: []
  type: TYPE_TB
- en: Note that F# natively uses `float` instead of `double`, but both can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Pointer types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '|  | Pointer/handle (signed) | Pointer/handle (unsigned) |'
  prefs: []
  type: TYPE_TB
- en: '| Keyword | nativeint | unativeint |'
  prefs: []
  type: TYPE_TB
- en: '| Suffix | n | un |'
  prefs: []
  type: TYPE_TB
- en: '| Example | 0xFFFFFFFFn | 0xFFFFFFFFun |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Type | IntPtr | UIntPtr |'
  prefs: []
  type: TYPE_TB
- en: Casting between built-in primitive types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Note: this section only covers casting of primitive types. For casting between
    classes see the series on [object-oriented programming](casting.md).*'
  prefs: []
  type: TYPE_NORMAL
- en: There is no direct "cast" syntax in F#, but there are helper functions to cast
    between types. These helper functions have the same name as the type (you can
    see them in the `Microsoft.FSharp.Core` namespace).
  prefs: []
  type: TYPE_NORMAL
- en: 'So for example, in C# you might write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'In F# the equivalent would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: In F# there are only casting functions for numeric types. In particular, there
    is no cast for bool, and you must use `Convert` or similar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Boxing and unboxing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as in C# and other .NET languages, the primitive int and float types are
    value objects, not classes. Although this is normally transparent, there are certain
    occasions where it can be an issue.
  prefs: []
  type: TYPE_NORMAL
- en: First, lets look at the transparent case. In the example below, we define a
    function that takes a parameter of type `Object`, and simply returns it. If we
    pass in an `int`, it is silently boxed into an object, as can be seen from the
    test code, which returns an `object` not an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The fact that `result` is an object, not an int, can cause type errors if you
    are not careful. For example, the result cannot be directly compared with the
    original value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'To work with this situation, and other similar ones, you can convert a primitive
    type to an object directly, by using the `box` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: To convert an object back to an primitive type, use the `unbox` keyword, but
    unlike `box`, you must either supply a specific type to unbox to, or be sure that
    the compiler has enough information to make an accurate type inference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: So the comparison example above could also be done with `unbox`. No explicit
    type annotation is needed because it is being compared with an int.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'A common problem occurs if you do not specify enough type information -- you
    will encounter the infamous "Value restriction" error, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: The solution is to reorder the code to help the type inference, or when all
    else fails, add an explicit type annotation. See [the post on type inference for
    more tips](type-inference.html#troubleshooting-summary).
  prefs: []
  type: TYPE_NORMAL
- en: Boxing in combination with type detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s say that you want to have a function that matches based on the type
    of the parameter, using the `:?` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this code will fail to compile, with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The message tells you the problem: "runtime type tests are not allowed on some
    types".'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is to "box" the value which forces it into a reference type, and
    then you can type check it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Units of measure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Units of measure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned [earlier in the "why use F#?" series](correctness-type-checking.html#units-of-measure),
    F# has a very cool feature which allows you to add extra unit-of-measure information
    to as metadata to numeric types.
  prefs: []
  type: TYPE_NORMAL
- en: The F# compiler will then make sure that only numerics with the same unit-of-measure
    can be combined. This can be very useful to stop accidental mismatches and to
    make your code safer.
  prefs: []
  type: TYPE_NORMAL
- en: Defining units of measure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A unit of measure definition consists of the attribute `[<Measure>]`, followed
    by the `type` keyword and then a name. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Often you will see the whole definition written on one line instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have a definition, you can associate a measure type with a numeric
    type by using angle brackets with measure name inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even combine measures within the angle brackets to create compound
    measures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Derived units of measure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you use certain combinations of units a lot, you can define a *derived* measure
    and use that instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: SI units and constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are using the units-of-measure for physics or other scientific applications,
    you will definitely want to use the SI units and related constants. You don''t
    need to define all these yourself! These are predefined for you and available
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In F# 3.0 and higher (which shipped with Visual Studio 2012), these are built
    into the core F# libraries in the `Microsoft.FSharp.Data.UnitSystems.SI` namespace
    (see the [MSDN page](http://msdn.microsoft.com/en-us/library/hh289707.aspx)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In F# 2.0 (which shipped with Visual Studio 2010), you will have to install
    the F# powerpack to get them. (The F# powerpack is on Codeplex at [http://fsharppowerpack.codeplex.com](http://fsharppowerpack.codeplex.com)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type checking and type inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The units-of-measure are just like proper types; you get static checking *and*
    type inference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'And of course, when using them, the type checking is strict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Type annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to be explicit in specifying a unit-of-measure type annotation,
    you can do so in the usual way. The numeric type must have angle brackets with
    the unit-of-measure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Combining units of measure with multiplication and division
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The compiler understands how units of measure transform when individual values
    are multiplied or divided.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the following, the `speed` value has been automatically given
    the measure `<m/sec>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Look at the types of the `acceleration` and `force` values above to see other
    examples of how this works.
  prefs: []
  type: TYPE_NORMAL
- en: Dimensionless values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A numeric value without any specific unit of measure is called *dimensionless*.
    If you want to be explicit that a value is dimensionless, you can use the measure
    called `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Mixing units of measure with dimensionless values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you cannot *add* a dimensionless value to a value with a unit of measure,
    but you can *multiply or divide* by dimensionless values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: But see the section on "generics" below for an alternative approach.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion between units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if you need to convert between units?
  prefs: []
  type: TYPE_NORMAL
- en: It's straightforward. You first need to define a conversion value that uses
    *both* units, and then multiply the source value by the conversion factor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example with feet and inches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s an example with temperature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: The compiler correctly inferred the signature of the conversion function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the constant `32.0<degF>` was explicitly annotated with the `degF`
    so that the result would be in `degF` as well. If you leave off this annotation,
    the result is a plain float, and the function signature changes to something much
    stranger! Try it and see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Conversion between dimensionless values and unit-of-measure values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To convert from a dimensionless numeric value to a value with a measure type,
    just multiply it by one, but with the one annotated with the appropriate unit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: And to convert the other way, either divide by one, or multiply with the inverse
    unit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: The above methods are type safe, and will cause errors if you try to convert
    the wrong type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t care about type checking, you can do the conversion with the
    standard casting functions instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Generic units of measure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, we want to write functions that will work with any value, no matter what
    unit of measure is associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, here is our old friend `square`. But when we try to use it with
    a unit of measure, we get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: What can we do? We don't want to specify a particular unit of measure, but on
    the other hand we must specify *something*, because the simple definition above
    doesn't work.
  prefs: []
  type: TYPE_NORMAL
- en: The answer is to use *generic* units of measure, indicated with an underscore
    where the measure name normally is.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Now the `square` function works as desired, and you can see that the function
    signature has used the letter `'u` to indicate a generic unit of measure. And
    also note that the compiler has inferred that the return value is of type "unit
    squared".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, you can specify the generic type using letters as well if you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'You may need to use letters sometimes to explicitly indicate that the units
    are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Using generic measures with lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You cannot always use a measure directly. For example, you cannot define a
    list of feet directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you have to use the "multiply by one" trick mentioned above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Using generic measures for constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multiplication by constants is OK (as we saw above), but if you try to do addition,
    you will get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'The fix is to add a generic type to the constant, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: A similar situation occurs when passing in constants to a higher order function
    such as `fold`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Issues with generic measures with functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are some cases where type inference fails us. For example, let's try to
    create a simple `add1` function that uses units.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: The warning message has the clue. The input parameter `n` has no measure, so
    the measure for `1<_>` will always be ignored. The `add1` function does not have
    a unit of measure so when you try to call it with a value that does have a measure,
    you get an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'So maybe the solution is to explicitly annotate the measure type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: But no, you get the same warning FS0064 again.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe we can replace the underscore with something more explicit such as `1.0<'u>`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: But this time we get a compiler error!
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is to use one of the helpful utility functions in the LanguagePrimitives
    module: `FloatWithMeasure`, `Int32WithMeasure`, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'And for generic ints, you can use the same approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Using generic measures with type definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That takes care of functions. What about when we need to use a unit of measure
    in a type definition?
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we want to define a generic coordinate record that works with an unit of
    measure. Let''s start with a naive approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'That didn''t work, so what about adding the measure as a type parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'That didn''t work either, but the error message tells us what to do. Here is
    the final, correct version, using the `Measure` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: In some cases, you might need to define more than one measure. In the following
    example, the currency exchange rate is defined as the ratio of two currencies,
    and so needs two generic measures to be defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: And of course, you can mix regular generic types with unit of measure types.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a product price might consist of a generic product type, plus
    a price with a currency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Units of measure at runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An issue that you may run into is that units of measure are not part of the
    .NET type system.
  prefs: []
  type: TYPE_NORMAL
- en: F# does stores extra metadata about them in the assembly, but this metadata
    is only understood by F#.
  prefs: []
  type: TYPE_NORMAL
- en: This means that there is no (easy) way at runtime to determine what unit of
    measure a value has, nor any way to dynamically assign a unit of measure at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: It also means that there is no way to expose units of measure as part of a public
    API to another .NET language (except other F# assemblies).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we finish with types, let''s revisit type inference: the magic that
    allows the F# compiler to deduce what types are used and where. We have seen this
    happen through all the examples so far, but how does it work and what can you
    do if it goes wrong?'
  prefs: []
  type: TYPE_NORMAL
- en: How does type inference work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It does seem to be magic, but the rules are mostly straightforward. The fundamental
    logic is based on an algorithm often called "Hindley-Milner" or "HM" (more accurately
    it should be called "Damas-Milner's Algorithm W"). If you want to know the details,
    go ahead and Google it.
  prefs: []
  type: TYPE_NORMAL
- en: I do recommend that you take some time to understand this algorithm so that
    you can "think like the compiler" and troubleshoot effectively when you need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the rules for determine the types of simple and function values:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at the literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at the functions and other values something interacts with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look at any explicit type constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are no constraints anywhere, automatically generalize to generic types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each of these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The literals give the compiler a clue to the context. As we have seen, the type
    checking is very strict; ints and floats are not automatically cast to the other.
    The benefit of this is that the compiler can deduce types by looking at the literals.
    If the literal is an `int` and you are adding "x" to it, then "x" must be an int
    as well. But if the literal is a `float` and you are adding "x" to it, then "x"
    must be a float as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples. Run them and see their signatures in the interactive
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Look at the functions and other values it interacts with
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If there are no literals anywhere, the compiler tries to work out the types
    by analyzing the functions and other values that they interact with. In the cases
    below, the "`indirect`" function calls a function that we do know the types for,
    which gives us the information to deduce the types for the "`indirect`" function
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: And of course assignment counts as an interaction too. If x is a certain type,
    and y is bound (assigned) to x, then y must be the same type as x.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Other interactions might be control structures, or external libraries
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Look at any explicit type constraints or annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If there are any explicit type constraints or annotations specified, then the
    compiler will use them. In the case below, we are explicitly telling the compiler
    that "`inferInt2`" takes an `int` parameter. It can then deduce that the return
    value for "`inferInt2`" is also an `int`, which in turn implies that "`inferIndirectInt2`"
    is of type int->int.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Note that the formatting codes in `printf` statements count as explicit type
    constraints too!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Automatic generalization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If after all this, there are no constraints found, the compiler just makes the
    types generic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: It works in all directions!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The type inference works top-down, bottom-up, front-to-back, back-to-front,
    middle-out, anywhere there is type information, it will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following example. The inner function has a literal, so we know
    that it returns an `int`. And the outer function has been explicitly told that
    it returns a `string`. But what is the type of the passed in "`action`" function
    in the middle?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'The type inference would work something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1` is an `int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore `x+1` must be an `int`, therefore `x` must be an `int`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore `innerFn` must be `int->int`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, `(innerFn 2)` returns an `int`, therefore "`action`" takes an `int` as
    input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output of `action` is the return value for `outerFn`, and therefore the
    output type of `action` is the same as the output type of `outerFn`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output type of `outerFn` has been explicitly constrained to `string`, therefore
    the output type of `action` is also `string`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting this together, we now know that the `action` function has signature
    `int->string`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And finally, therefore, the compiler deduces the type of `outerFn` as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Elementary, my dear Watson!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The compiler can do deductions worthy of Sherlock Holmes. Here's a tricky example
    that will test how well you have understood everything so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a `doItTwice` function that takes any input function (call
    it "`f`") and generates a new function that simply does the original function
    twice in a row. Here''s the code for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it composes `f` with itself. So in other words, it means: "do
    f", then "do f" on the result of that.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, what could the compiler possibly deduce about the signature of `doItTwice`?
  prefs: []
  type: TYPE_NORMAL
- en: Well, let's look at the signature of "`f`" first. The output of the first call
    to "`f`" is also the input to the second call to "`f`". So therefore the output
    and input of "`f`" must be the same type. So the signature of `f` must be `'a
    -> 'a`. The type is generic (written as 'a) because we have no other information
    about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So going back to `doItTwice` itself, we now know it takes a function parameter
    of `''a -> ''a`. But what does it return? Well, here''s how we deduce it, step
    by step:'
  prefs: []
  type: TYPE_NORMAL
- en: First, note that `doItTwice` generates a function, so must return a function
    type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input to the generated function is the same type as the input to first call
    to "`f`"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output of the generated function is the same type as the output of the second
    call to "`f`"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So the generated function must also have type `'a -> 'a`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting it all together, `doItTwice` has a domain of `'a -> 'a` and a range
    of `'a -> 'a`, so therefore its signature must be `('a -> 'a) -> ('a -> 'a)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is your head spinning yet? You might want to read it again until it sinks in.
  prefs: []
  type: TYPE_NORMAL
- en: Quite a sophisticated deduction for one line of code. Luckily the compiler does
    all this for us. But you will need to understand this kind of thing if you have
    problems and you have to determine what the compiler is doing.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test it! It's actually much simpler to understand in practice than it
    is in theory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, that makes more sense now.
  prefs: []
  type: TYPE_NORMAL
- en: Things that can go wrong with type inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The type inference isn''t perfect, alas. Sometimes the compiler just doesn''t
    have a clue what to do. Again, understanding what is happening will really help
    you stay calm instead of wanting to kill the compiler. Here are some of the main
    reasons for type errors:'
  prefs: []
  type: TYPE_NORMAL
- en: Declarations out of order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not enough information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overloaded methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quirks of generic numeric functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declarations out of order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A basic rule is that you must declare functions before they are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'But this is ok:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: And unlike C#, in F# the order of file compilation is important, so do make
    sure the files are being compiled in the right order. (In Visual Studio, you can
    change the order from the context menu).
  prefs: []
  type: TYPE_NORMAL
- en: Recursive or simultaneous declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A variant of the "out of order" problem occurs with recursive functions or definitions
    that have to refer to each other. No amount of reordering will help in this case
    -- we need to use additional keywords to help the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a function is being compiled, the function identifier is not available
    to the body. So if you define a simple recursive function, you will get a compiler
    error. The fix is to add the "rec" keyword as part of the function definition.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the fixed version with "rec fib" added to indicate it is recursive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: A similar "`let rec ? and`" syntax is used for two functions that refer to each
    other. Here is a very contrived example that fails if you do not have the "`rec`"
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: The "`and`" keyword can also be used to declare simultaneous types in a similar
    way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixed version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Not enough information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, the compiler just doesn't have enough information to determine a
    type. In the following example, the compiler doesn't know what type the `Length`
    method is supposed to work on. But it can't make it generic either, so it complains.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: These kinds of error can be fixed with explicit annotations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Occasionally there does appear to be enough information, but still the compiler
    doesn't seem to recognize it. For example, it's obvious to a human that the `List.map`
    function (below) is being applied to a list of strings, so why does `x.Length`
    cause an error?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: The reason is that the F# compiler is currently a one-pass compiler, and so
    information later in the program is ignored if it hasn't been parsed yet. (The
    F# team have said that it is possible to make the compiler more sophisticated,
    but it would work less well with Intellisense and might produce more unfriendly
    and obscure error messages. So for now, we will have to live with this limitation.)
  prefs: []
  type: TYPE_NORMAL
- en: 'So in cases like this, you can always explicitly annotate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: But another, more elegant way that will often fix the problem is to rearrange
    things so the known types come first, and the compiler can digest them before
    it moves to the next clause.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Functional programmers strive to avoid explicit type annotations, so this makes
    them much happier!
  prefs: []
  type: TYPE_NORMAL
- en: This technique can be used more generally in other areas as well; a rule of
    thumb is to try to put the things that have "known types" earlier than things
    that have "unknown types".
  prefs: []
  type: TYPE_NORMAL
- en: Overloaded methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When calling an external class or method in .NET, you will often get errors
    due to overloading.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, such as the concat example below, you will have to explicitly
    annotate the parameters of the external function so that the compiler knows which
    overloaded method to call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes the overloaded methods have different argument names, in which case
    you can also give the compiler a clue by naming the arguments. Here is an example
    for the `StreamReader` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Quirks of generic numeric functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Numeric functions can be somewhat confusing. There often appear generic, but
    once they are bound to a particular numeric type, they are fixed, and using them
    with a different numeric type will cause an error. The following example demonstrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: There is a way round this for numeric types using the "inline" keyword and "static
    type parameters". I won't discuss these concepts here, but you can look them up
    in the F# reference at MSDN.
  prefs: []
  type: TYPE_NORMAL
- en: '"Not enough information" troubleshooting summary'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So to summarize, the things that you can do if the compiler is complaining
    about missing types, or not enough information, are:'
  prefs: []
  type: TYPE_NORMAL
- en: Define things before they are used (this includes making sure the files are
    compiled in the right order)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put the things that have "known types" earlier than things that have "unknown
    types". In particular, you might be able reorder pipes and similar chained functions
    so that the typed objects come first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotate as needed. One common trick is to add annotations until everything
    works, and then take them away one by one until you have the minimum needed. Do
    try to avoid annotating if possible. Not only is it not aesthetically pleasing,
    but it makes the code more brittle. It is a lot easier to change types if there
    are no explicit dependencies on them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging type inference issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have ordered and annotated everything, you will probably still get
    type errors, or find that functions are less generic than expected. With what
    you have learned so far, you should have the tools to determine why this happened
    (although it can still be painful).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have a chain of functions. The bottom level function is
    definitely generic, but what about the top level one? Well often, we might expect
    it be generic but instead it is not. In this case we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: What went wrong? The answer is in the midlevel function. The `%s` on z forced
    it be a string, which forced y and then x to be strings too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now this is a pretty obvious example, but with thousands of lines of code,
    a single line might be buried away that causes an issue. One thing that can help
    is to look at all the signatures; in this case the signatures are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: When you find a signature that is unexpected you know that it is the guilty
    party. You can then drill down into it and repeat the process until you find the
    problem.
  prefs: []
  type: TYPE_NORMAL
