- en: Heaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *min-heap* is a complete binary tree that satisfies the min-heap property,
    which requires that every node is no bigger than its children. (*Max-heaps* are
    defined similarly).
  prefs: []
  type: TYPE_NORMAL
- en: 'The heap abstraction is defined for any element type that is ordered. For simplicity,
    however, we will work specifically with heaps of `Int`s, described by the type
    `Heap`; we will discuss more general, polymorphic Heap types below. The following
    type signatures define our `Heap` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Heaps as Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Heaps are often implemented as arrays. Recall the scheme (from Homework 2)
    for ordering nodes in a complete binary tree using breadth-first search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The nodes of a complete binary tree can be stored in breadth-first order in
    an array `a`...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And then navigating the parent and child edges for a node stored in `a[i]`
    is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: the parent is stored in `a[(i-1)//2]`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the left child (if any) is stored in `a[(2*i)+1]`, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the right child (if any) is stored in `a[(2*i)+2]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In imperative languages, retrieving an arbitrary element in an array takes *O(1)*
    time. In functional languages, purely functional arrays are often implemented
    in terms of balanced search trees, which typically provide *O(log n)* access to
    arbitrary elements.
  prefs: []
  type: TYPE_NORMAL
- en: Although we have not yet talked about how to implement balanced search trees,
    we will take as given an implementation of balanced search trees. In Elm, the
    [`Array`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Array) library
    is implemented with a data structure called [Relaxed Radix Trees](http://infoscience.epfl.ch/record/169879/files/RMTrees.pdf),
    which provides near constant-time performance in practice for getting and setting
    arbitrary indices.
  prefs: []
  type: TYPE_NORMAL
- en: Internal Representation vs. External Interface
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We will make use of the `Array` library (which we will qualify with an `A`)
    to implement the heap abstraction. If we choose to define and export
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: then clients of our module will be able to see that we have implemented `Heap`s
    using `Array`s and will have access to the `Array` values that we will use to
    represent `Heap`s. If we wish to hide the representation from clients, we can
    instead define a *new* type
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'and export only those functions that we want clients to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Because none of these API functions "reveal" the underlying representation of
    the `Heap` type to the client (there are no functions of type `Heap -> A.Array
    Int`), clients will not be able to manipulate `Heap`s directly with `Array` operators.
  prefs: []
  type: TYPE_NORMAL
- en: Creating abstraction boundaries like this facilitate the software engineering
    process, by preventing clients from (intentionally or accidentally) violating
    invariants that the correctness of the module implementation depends on, as well
    as facilitating changes to the implementation by limiting and making explicit
    the boundaries between modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the `Heap` abstraction, we will use the following `Array` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `A.push` function creates a new array that is the same as in the input array
    except that it contains an additional element at the end. For convenience, we
    will define an analagous function called `pop` that creates a new array with the
    last element removed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will start with the simple operators.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the definition of `isEmpty` uses pattern matching to, at once,
    deconstruct the argument value and bind the underlying array value to the variable
    `a`. This definition is equivalent to all of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Because values of type `Heap` can only be constructed by the `WrapHeap` data
    constructor, we can use patterns in bindings (rather than `case` expressions)
    and be sure that there will be no run-time pattern-match errors.
  prefs: []
  type: TYPE_NORMAL
- en: The `findMin` implementation is also straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Insertion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's now look at the first non-trivial operator, inserting an `Int` into a
    `Heap`. The idea is to add the element to the next position in the complete binary
    tree (conveniently represented as the last element in the array) and then "bubble"
    or "percolate" the element up the tree until it is no longer bigger than its parent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As we manipulate the underlying `Array` representations, we will make sure
    to always access elements within bounds. So we define an "unsafe" version of `get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We also define a helper function to swap two elements in an `Array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `bubbleUp` function is defined to swap node `i` with its parent node `(i-1)//2`
    if the parent is larger and, if so, recursively traverses up the tree. We use
    the type alias `InternalHeap` to refer to `A.Array Int` within our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's now consider the worst-case time cost of the insertion algorithm. The
    `insert` function computes the length of the `Array` representation (which runs
    in *O(1)* time, by looking at the documentation and implementation), `push`es
    an element on the end of it (which runs in worst-case *O(log n)* time) and calls
    `bubbleUp`.
  prefs: []
  type: TYPE_NORMAL
- en: The `bubbleUp` function makes use of `justGet` and `swap`. Because `A.get` runs
    in *O(log n)* time, so does the wrapper function `justGet`. The `swap` function
    makes several calls to `A.set` and `justGet`, each of which takes *O(log n)* time.
    Thus, `swap` takes *O(log n)* time. The `bubbleUp` function visits at most *O(log
    n)* elements because the index `i` is divided in half before each recursive call.
    Therefore, there are *O(log n)* calls to `bubbleUp`, each of which performs *O(log
    n)* work. So the running time of `bubbleUp`, and hence `insert`, is *O(log²n)*.
    In an imperative language, where array operations take worst-case *O(1)* time,
    the insertion algorithm runs in worst-case *O(log n)* time.
  prefs: []
  type: TYPE_NORMAL
- en: Deletion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**UPDATE**: The version of `deleteMin` [here](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/lectures/HeapsBuggy.html)
    is incorrect. Can you see why?'
  prefs: []
  type: TYPE_NORMAL
- en: To delete the minimum element, which is stored at index `0`, we first overwrite
    the root with the value currently stored in the last position (conveniently stored
    in the last element of the `Array`). We pop the last element because its value
    is now stored in the root and then "bubble" or "percolate" this value down as
    long as necessary. When recursively bubbling down, we choose the child tree whose
    root is smaller in order to maintain the heap order property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For a given index `i`, the index of the left child is `j = 2*i + 1` and of the
    right child as `k = 2*i + 2`. If the value at index `i` is smaller than both children,
    the output array is unchanged. Otherwise, the value at index `i` is swapped with
    the smaller root among the two subtrees and `bubbleDown` recurses on that subtree.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The analysis of `bubbleDown` and `deleteMin` is similar to the insertion algorithm,
    resulting in a *O(log²n)* worst-case time cost.
  prefs: []
  type: TYPE_NORMAL
- en: Merging
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There is a common algorithm, often called "heapify," for merging heaps that
    are represented as arrays. We will not go through this algorithm in this course,
    but you may curious to read about it if you have not seen it before.
  prefs: []
  type: TYPE_NORMAL
- en: In our Elm implementation, we will pretend that we implement the `merge` function
    faithfully, but instead we will always trigger a run-time error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The [`Heaps.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Heaps.elm)
    file contains the implementation above.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic Types for Heaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We defined the `Heap` type to store `Int`s, but the same abstraction exists
    for any kind of comparable values. And, of course, we don't want to duplicate
    the implementation for every different type of heap that we may want to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that Elm provides the special polymorphic type variable `comparable`
    to describe such types. So we can generalize the heap abstraction as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The [`PolyHeaps.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/PolyHeaps.elm)
    file contains the modifications required to implement this more general interface.
    It is worth noting that compared to [`Heaps.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Heaps.elm),
    type signatures are changed but no value definitions are changed.
  prefs: []
  type: TYPE_NORMAL
- en: Haskell-style Type Classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We may want to define interfaces in terms of types that come with operators
    besides those specified in the `comparable` "type class." But Elm does not provide
    a way for the programmer to define an interface that describes a set of types.
  prefs: []
  type: TYPE_NORMAL
- en: In Haskell, user-defined type classes can be used to specify the heap abstraction
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The second class definition says that a type `a` "is a" `Heap` if (1) `a` "is
    a" `Ord` and (2) the six functions specified can be defined for that type. Particular
    implementations are then defined to "implement" the `Heap` "interface".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For simplicity, the definition above does not mention the Haskell `Eq` type
    class.
  prefs: []
  type: TYPE_NORMAL
- en: ML-style Modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Standard ML and OCaml, *signatures* are used to describe *modules*, which
    are structures that contain values and types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: An implementation satisfies the `Heap` signature by defining a *functor* that
    takes a module as an argument and returns another module. Note that these ML functors
    are the not same thing as Haskell `Functor`s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
