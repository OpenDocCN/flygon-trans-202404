["```\n\n```", "```\n\n    In this chapter, we develop the fundamental theory of the Simply\n    Typed Lambda Calculus \u2014 in particular, the type safety\n    theorem.\n\n```", "```\nLemma canonical_forms_bool : \u2200t,\n\u00a0\u00a0empty \u22a2 t \u2208 TBool \u2192\n\u00a0\u00a0value t \u2192\n\u00a0\u00a0(t = ttrue) \u2228 (t = tfalse).\n\n    Proof.\n\u00a0\u00a0intros t HT HVal.\n\u00a0\u00a0inversion HVal; intros; subst; try inversion HT; auto.\n    Qed.\n\nLemma canonical_forms_fun : \u2200t T[1] T[2],\n\u00a0\u00a0empty \u22a2 t \u2208 (TArrow T[1] T[2]) \u2192\n\u00a0\u00a0value t \u2192\n\u00a0\u00a0\u2203x u, t = tabs x T[1] u.\n\n    Proof.\n\u00a0\u00a0intros t T[1] T[2] HT HVal.\n\u00a0\u00a0inversion HVal; intros; subst; try inversion HT; subst; auto.\n\u00a0\u00a0\u2203x[0]. \u2203t[0]. auto.\n    Qed.\n\n```", "```\nTheorem progress : \u2200t T,\n\u00a0\u00a0\u00a0\u00a0\u00a0empty \u22a2 t \u2208 T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0value t \u2228 \u2203t', t \u21d2 t'.\n\n```", "```\n\n    Proof with eauto.\n\u00a0\u00a0intros t T Ht.\n\u00a0\u00a0remember (@[empty](Maps.html#empty) [ty](Stlc.html#STLC.ty)) as \u0393.\n\u00a0\u00a0induction Ht; subst \u0393...\n\u00a0\u00a0- (*\u00a0T_Var\u00a0*)\n\u00a0\u00a0\u00a0\u00a0(*\u00a0contradictory:\u00a0variables\u00a0cannot\u00a0be\u00a0typed\u00a0in\u00a0an \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0empty\u00a0context\u00a0*)\n\u00a0\u00a0\u00a0\u00a0inversion H.\n\n\u00a0\u00a0- (*\u00a0T_App\u00a0*)\n\u00a0\u00a0\u00a0\u00a0(*\u00a0t\u00a0=\u00a0t[1] t[2].\u00a0\u00a0Proceed\u00a0by\u00a0cases\u00a0on\u00a0whether\u00a0t[1]\u00a0is\u00a0a \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value\u00a0or\u00a0steps...\u00a0*)\n\u00a0\u00a0\u00a0\u00a0right. destruct IHHt1...\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0t[1]\u00a0is\u00a0a\u00a0value\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct IHHt2...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0t[2]\u00a0is\u00a0also\u00a0a\u00a0value\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assert (\u2203x[0] t[0], t[1] = [tabs](Stlc.html#STLC.tabs) [x[0]](StlcProp.html#x<sub>0</sub>) T[11] [t[0]](StlcProp.html#t<sub>0</sub>)).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0eapply [canonical_forms_fun](StlcProp.html#STLCProp.canonical_forms_fun); eauto.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct H[1] as [x[0] [t[0] Heq]]. subst.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2203([x[0]:=t[2]]t[0])...\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0t[2]\u00a0steps\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion H[0] as [t[2]' Hstp]. \u2203([tapp](Stlc.html#STLC.tapp) t[1] t[2]')...\n\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0t[1]\u00a0steps\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion H as [t[1]' Hstp]. \u2203([tapp](Stlc.html#STLC.tapp) t[1]' t[2])...\n\n\u00a0\u00a0- (*\u00a0T_If\u00a0*)\n\u00a0\u00a0\u00a0\u00a0right. destruct IHHt1...\n\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0t[1]\u00a0is\u00a0a\u00a0value\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct ([canonical_forms_bool](StlcProp.html#STLCProp.canonical_forms_bool) t[1]); subst; eauto.\n\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0t[1]\u00a0also\u00a0steps\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion H as [t[1]' Hstp]. \u2203([tif](Stlc.html#STLC.tif) t[1]' t[2] t[3])...\n    Qed.\n\n```", "```\nTheorem progress' : \u2200t T,\n\u00a0\u00a0\u00a0\u00a0\u00a0empty \u22a2 t \u2208 T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0value t \u2228 \u2203t', t \u21d2 t'.\nProof.\n\u00a0\u00a0intros t.\n\u00a0\u00a0induction t; intros T Ht; auto.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n# Preservation\n\n    The other half of the type soundness property is the\n    preservation of types during reduction.  For this part, we'll need\n    to develop some technical machinery for reasoning about variables\n    and substitution.  Working from top to bottom (from the high-level\n    property we are actually interested in to the lowest-level\n    technical lemmas that are needed by various cases of the more\n    interesting proofs), the story goes like this:\n\n*   The *preservation theorem* is proved by induction on a typing derivation, pretty much as we did in the [Types](Types.html) chapter. The one case that is significantly different is the one for the ST_AppAbs rule, whose definition uses the substitution operation. To see that this step preserves typing, we need to know that the substitution itself does. So we prove a... \n\n*   *substitution lemma*, stating that substituting a (closed) term s for a variable x in a term t preserves the type of t. The proof goes by induction on the form of t and requires looking at all the different cases in the definition of substitition. This time, the tricky cases are the ones for variables and for function abstractions. In both, we discover that we need to take a term s that has been shown to be well-typed in some context \u0393 and consider the same term s in a slightly different context \u0393'. For this we prove a... \n\n*   *context invariance* lemma, showing that typing is preserved under \"inessential changes\" to the context \u0393 \u2014 in particular, changes that do not affect any of the free variables of the term. And finally, for this, we need a careful definition of... \n\n*   the *free variables* of a term \u2014 i.e., those variables mentioned in a term and not in the scope of an enclosing function abstraction binding a variable of the same name.\n\n    To make Coq happy, we need to formalize the story in the opposite\n   order...\n\n```", "```\nInductive appears_free_in : id \u2192 tm \u2192 Prop :=\n\u00a0\u00a0| afi_var : \u2200x,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x (tvar x)\n\u00a0\u00a0| afi_app1 : \u2200x t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[1] \u2192 appears_free_in x (tapp t[1] t[2])\n\u00a0\u00a0| afi_app2 : \u2200x t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[2] \u2192 appears_free_in x (tapp t[1] t[2])\n\u00a0\u00a0| afi_abs : \u2200x y T[11] t[12],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0y \u2260 x  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[12] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x (tabs y T[11] t[12])\n\u00a0\u00a0| afi_if[1] : \u2200x t[1] t[2] t[3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x (tif t[1] t[2] t[3])\n\u00a0\u00a0| afi_if[2] : \u2200x t[1] t[2] t[3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x (tif t[1] t[2] t[3])\n\u00a0\u00a0| afi_if[3] : \u2200x t[1] t[2] t[3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x t[3] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0appears_free_in x (tif t[1] t[2] t[3]).\n\nHint Constructors appears_free_in.\n\n```", "```\nDefinition closed (t:tm) :=\n\u00a0\u00a0\u2200x, \u00ac appears_free_in x t.\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n\n## Substitution\n\n    To prove that substitution preserves typing, we first need a\n    technical lemma connecting free variables and typing contexts: If\n    a variable x appears free in a term t, and if we know t is\n    well typed in context \u0393, then it must be the case that\n    \u0393 assigns a type to x.\n\n```", "```\n\n    *Proof*: We show, by induction on the proof that x appears free\n      in t, that, for all contexts \u0393, if t is well typed\n      under \u0393, then \u0393 assigns some type to x.\n\n*   If the last rule used is afi_var, then t = x, and from the assumption that t is well typed under \u0393 we have immediately that \u0393 assigns a type to x. \n\n*   If the last rule used is afi_app1, then t = t[1] t[2] and x appears free in t[1]. Since t is well typed under \u0393, we can see from the typing rules that t[1] must also be, and the IH then tells us that \u0393 assigns x a type. \n\n*   Almost all the other cases are similar: x appears free in a subterm of t, and since t is well typed under \u0393, we know the subterm of t in which x appears is well typed under \u0393 as well, and the IH gives us exactly the conclusion we want. \n\n*   The only remaining case is afi_abs. In this case t = \\y:T[11].t12 and x appears free in t[12], and we also know that x is different from y. The difference from the previous cases is that, whereas t is well typed under \u0393, its body t[12] is well typed under (\u0393, y:T[11]), so the IH allows us to conclude that x is assigned some type by the extended context (\u0393, y:T[11]). To conclude that \u0393 assigns a type to x, we appeal to lemma update_neq, noting that x and y are different variables.\n\n```", "```\n\n    Next, we'll need the fact that any term t that is well typed in\n    the empty context is closed (it has no free variables). \n\n#### Exercise: 2 stars, optional (typable_empty__closed)\n\n```", "```\nLemma context_invariance : \u2200\u0393 \u0393' t T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t \u2208 T  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0(\u2200x, appears_free_in x t \u2192 \u0393 x = \u0393' x) \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u0393' \u22a2 t \u2208 T.\n\n```", "```\n\n    Proof with eauto.\n\u00a0\u00a0intros.\n\u00a0\u00a0generalize dependent \u0393'.\n\u00a0\u00a0induction H; intros; auto.\n\u00a0\u00a0- (*\u00a0T_Var\u00a0*)\n\u00a0\u00a0\u00a0\u00a0apply [T_Var](Stlc.html#STLC.T_Var). rewrite \u2190 H[0]...\n\u00a0\u00a0- (*\u00a0T_Abs\u00a0*)\n\u00a0\u00a0\u00a0\u00a0apply [T_Abs](Stlc.html#STLC.T_Abs).\n\u00a0\u00a0\u00a0\u00a0apply IHhas_type. intros x[1] Hafi.\n\u00a0\u00a0\u00a0\u00a0(*\u00a0the\u00a0only\u00a0tricky\u00a0step...\u00a0the\u00a0\u0393'\u00a0we\u00a0use\u00a0to \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0instantiate\u00a0is\u00a0update \u0393 x T[11]\u00a0*)\n\u00a0\u00a0\u00a0\u00a0unfold [update](Maps.html#update). unfold [t_update](Maps.html#t_update). destruct ([beq_id](Maps.html#beq_id) x[0] x[1]) eqn: Hx0x[1]...\n\u00a0\u00a0\u00a0\u00a0rewrite [beq_id_false_iff](Maps.html#beq_id_false_iff) in Hx0x[1]. auto.\n\u00a0\u00a0- (*\u00a0T_App\u00a0*)\n\u00a0\u00a0\u00a0\u00a0apply [T_App](Stlc.html#STLC.T_App) with T[11]...\n    Qed.\n\n```", "```\nLemma substitution_preserves_typing : \u2200\u0393 x U t v T,\n\u00a0\u00a0\u00a0\u00a0\u00a0update \u0393 x U \u22a2 t \u2208 T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0empty \u22a2 v \u2208 U   \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 [x:=v]t \u2208 T.\n\n```", "```\n\n    Proof with eauto.\n\u00a0\u00a0intros \u0393 x U t v T Ht Ht'.\n\u00a0\u00a0generalize dependent \u0393. generalize dependent T.\n\u00a0\u00a0induction t; intros T \u0393 H;\n\u00a0\u00a0\u00a0\u00a0(*\u00a0in\u00a0each\u00a0case,\u00a0we'll\u00a0want\u00a0to\u00a0get\u00a0at\u00a0the\u00a0derivation\u00a0of\u00a0H\u00a0*)\n\u00a0\u00a0\u00a0\u00a0inversion H; subst; simpl...\n\u00a0\u00a0- (*\u00a0tvar\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rename i into y. destruct ([beq_idP](Maps.html#beq_idP) x y) as [Hxy|Hxy].\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0x=y\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subst.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite [update_eq](Maps.html#update_eq) in H[2].\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion H[2]; subst.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0eapply [context_invariance](StlcProp.html#STLCProp.context_invariance). eassumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [typable_empty__closed](StlcProp.html#STLCProp.typable_empty__closed) in Ht'. unfold [closed](StlcProp.html#STLCProp.closed) in Ht'.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intros. apply (Ht' x[0]) in H[0]. inversion H[0].\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0x<>y\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [T_Var](Stlc.html#STLC.T_Var). rewrite [update_neq](Maps.html#update_neq) in H[2]...\n\u00a0\u00a0- (*\u00a0tabs\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rename i into y. rename t into T. apply [T_Abs](Stlc.html#STLC.T_Abs).\n\u00a0\u00a0\u00a0\u00a0destruct ([beq_idP](Maps.html#beq_idP) x y) as [Hxy | Hxy].\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0x=y\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subst. rewrite [update_shadow](Maps.html#update_shadow) in H[5]. apply H[5].\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0x<>y\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHt. eapply [context_invariance](StlcProp.html#STLCProp.context_invariance)...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct ([beq_idP](Maps.html#beq_idP) y z) as [Hyz | Hyz]; subst; trivial.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite \u2190 [beq_id_false_iff](Maps.html#beq_id_false_iff) in Hxy.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite Hxy...\n    Qed.\n\n```", "```\nTheorem preservation : \u2200t t' T,\n\u00a0\u00a0\u00a0\u00a0\u00a0empty \u22a2 t \u2208 T  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0t \u21d2 t'  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0empty \u22a2 t' \u2208 T.\n\n```", "```\n\n    Proof with eauto.\n\u00a0\u00a0remember (@[empty](Maps.html#empty) [ty](Stlc.html#STLC.ty)) as \u0393.\n\u00a0\u00a0intros t t' T HT. generalize dependent t'.\n\u00a0\u00a0induction HT;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intros t' HE; subst \u0393; subst;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0try solve [inversion HE; subst; auto].\n\u00a0\u00a0- (*\u00a0T_App\u00a0*)\n\u00a0\u00a0\u00a0\u00a0inversion HE; subst...\n\u00a0\u00a0\u00a0\u00a0(*\u00a0Most\u00a0of\u00a0the\u00a0cases\u00a0are\u00a0immediate\u00a0by\u00a0induction, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0and\u00a0eauto\u00a0takes\u00a0care\u00a0of\u00a0them\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0ST_AppAbs\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply [substitution_preserves_typing](StlcProp.html#STLCProp.substitution_preserves_typing) with T[11]...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion HT[1]...\n    Qed.\n\n```", "```\n\n# Type Soundness\n\n#### Exercise: 2 stars, optional (type_soundness)\n\n    Put progress and preservation together and show that a well-typed\n    term can *never* reach a stuck state.\n\n```", "```\n\n    \u2610\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n\n# Additional Exercises\n\n#### Exercise: 1 starM (progress_preservation_statement)\n\n    Without peeking at their statements above, write down the progress\n    and preservation theorems for the simply typed lambda-calculus (as \n    Coq theorems).\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 starsM (stlc_variation1)\n\n    Suppose we add a new term zap with the following reduction rule\n\n           |\n\n                        (ST_Zap) \u00a0\n           |\n\n* * *\n\n           |\n\n                        t\u00a0\u21d2\u00a0zap\n           |\n\n                     |\n\n    and the following typing rule:\n\n           |\n\n                        (T_Zap) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0zap\u00a0:\u00a0T\n           |\n\n                     |\n\n    Which of the following properties of the STLC remain true in\n    the presence of these rules?  For each property, write either\n    \"remains true\" or \"becomes false.\" If a property becomes\n    false, give a counterexample.\n\n*   Determinism of step\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n*   Progress\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n*   Preservation\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610 \n\n#### Exercise: 2 starsM (stlc_variation2)\n\n    Suppose instead that we add a new term foo with the following \n    reduction rules:\n\n           |\n\n                        (ST_Foo1) \u00a0\n           |\n\n* * *\n\n           |\n\n                        (\u03bbx:A.\u00a0x)\u00a0\u21d2\u00a0foo\n           |\n\n                     |\n\n           |\n\n                        (ST_Foo2) \u00a0\n           |\n\n* * *\n\n           |\n\n                        foo\u00a0\u21d2\u00a0true\n           |\n\n                     |\n\n    Which of the following properties of the STLC remain true in\n    the presence of this rule?  For each one, write either\n    \"remains true\" or else \"becomes false.\" If a property becomes\n    false, give a counterexample.\n\n*   Determinism of step\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n*   Progress\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n*   Preservation\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610 \n\n#### Exercise: 2 starsM (stlc_variation3)\n\n    Suppose instead that we remove the rule ST_App1 from the step\n    relation. Which of the following properties of the STLC remain\n    true in the presence of this rule?  For each one, write either\n    \"remains true\" or else \"becomes false.\" If a property becomes\n    false, give a counterexample.\n\n*   Determinism of step\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n*   Progress\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n*   Preservation\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610 \n\n#### Exercise: 2 stars, optional (stlc_variation4)\n\n    Suppose instead that we add the following new rule to the \n    reduction relation:\n\n           |\n\n                        (ST_FunnyIfTrue) \u00a0\n           |\n\n* * *\n\n           |\n\n                        (if\u00a0true\u00a0then\u00a0t[1]\u00a0else\u00a0t[2])\u00a0\u21d2\u00a0true\n           |\n\n                     |\n\n    Which of the following properties of the STLC remain true in\n    the presence of this rule?  For each one, write either\n    \"remains true\" or else \"becomes false.\" If a property becomes\n    false, give a counterexample.\n\n*   Determinism of step\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n*   Progress\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n*   Preservation\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610 \n\n#### Exercise: 2 stars, optional (stlc_variation5)\n\n    Suppose instead that we add the following new rule to the typing \n    relation:\n\n                        \u0393\u00a0\u22a2\u00a0t[1]\u00a0\u2208\u00a0Bool->Bool->Bool\n           |\n\n                     |\n\n                        \u0393\u00a0\u22a2\u00a0t[2]\u00a0\u2208\u00a0Bool\n           |\n\n                        (T_FunnyApp) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0t[1]\u00a0t[2]\u00a0\u2208\u00a0Bool\n           |\n\n                     |\n\n    Which of the following properties of the STLC remain true in\n    the presence of this rule?  For each one, write either\n    \"remains true\" or else \"becomes false.\" If a property becomes\n    false, give a counterexample.\n\n*   Determinism of step\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n*   Progress\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n*   Preservation\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610 \n\n#### Exercise: 2 stars, optional (stlc_variation6)\n\n    Suppose instead that we add the following new rule to the typing \n    relation:\n\n                        \u0393\u00a0\u22a2\u00a0t[1]\u00a0\u2208\u00a0Bool\n           |\n\n                     |\n\n                        \u0393\u00a0\u22a2\u00a0t[2]\u00a0\u2208\u00a0Bool\n           |\n\n                        (T_FunnyApp') \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u0393\u00a0\u22a2\u00a0t[1]\u00a0t[2]\u00a0\u2208\u00a0Bool\n           |\n\n                     |\n\n    Which of the following properties of the STLC remain true in\n    the presence of this rule?  For each one, write either\n    \"remains true\" or else \"becomes false.\" If a property becomes\n    false, give a counterexample.\n\n*   Determinism of step\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n*   Progress\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n*   Preservation\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610 \n\n#### Exercise: 2 stars, optional (stlc_variation7)\n\n    Suppose we add the following new rule to the typing relation \n    of the STLC:\n\n           |\n\n                        (T_FunnyAbs) \u00a0\n           |\n\n* * *\n\n           |\n\n                        \u22a2\u00a0\\x:Bool.t\u00a0\u2208\u00a0Bool\n           |\n\n                     |\n\n    Which of the following properties of the STLC remain true in\n    the presence of this rule?  For each one, write either\n    \"remains true\" or else \"becomes false.\" If a property becomes\n    false, give a counterexample.\n\n*   Determinism of step\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n*   Progress\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n*   Preservation\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610\n\n```", "```\n\n## Exercise: STLC with Arithmetic\n\n    To see how the STLC might function as the core of a real\n    programming language, let's extend it with a concrete base\n    type of numbers and some constants and primitive\n    operators.\n\n```", "```\n\n    To types, we add a base type of natural numbers (and remove\n    booleans, for brevity).\n\n```", "```\n\n    To terms, we add natural number constants, along with\n    successor, predecessor, multiplication, and zero-testing.\n\n```", "```\n\n#### Exercise: 4 starsM (stlc_arith)\n\n    Finish formalizing the definition and properties of the STLC\n    extended with arithmetic.  Specifically:\n\n*   Copy the core definitions and theorems for STLC that we went through above (from the definition of values through the Preservation theorem, inclusive), and paste it into the file at this point. Do not copy examples, exercises, etc. (In particular, make sure you don't copy any of the \u2610 comments at the end of exercises, to avoid confusing the autograder.) \n\n*   Extend the definitions of the subst operation and the step relation to include appropriate clauses for the arithmetic operators. \n\n*   Extend the proofs of all the properties (up to preservation) of the original STLC to deal with the new syntactic forms. Make sure Coq accepts the whole file.\n\n```", "```\n\n    \u2610\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]