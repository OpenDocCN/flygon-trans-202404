- en: プロトタイプオブジェクト
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://jsprimer.net/basic/prototype-object/](https://jsprimer.net/basic/prototype-object/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 「[オブジェクト](../object/)」の章では、オブジェクトの処理方法について見てきました。 その中で、空のオブジェクトであっても`toString`メソッドなどを呼び出せていました。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: オブジェクトリテラルで空のオブジェクトを定義しただけなのに、`toString`メソッドを呼び出せています。 このメソッドはどこに実装されているのでしょうか？
  prefs: []
  type: TYPE_NORMAL
- en: また、JavaScriptには`toString`以外にも、オブジェクトに自動的に実装されるメソッドがあります。 これらのオブジェクトに組み込まれたメソッドをビルトインメソッドと呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: この章では、これらのビルトインメソッドがどこに実装され、なぜ`Object`のインスタンスから呼び出せるのかを確認していきます。 詳しい仕組みについては「[クラス](../class/)」の章で改めて解説するため、この章では大まかな動作の流れを理解することが目的です。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#object-is-origin)*`Object`はすべての元*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*`Object`には、他の`Array`、`String`、`Function`などのオブジェクトとは異なる特徴があります。 それは、他のオブジェクトはすべて`Object`を継承しているという点です。'
  prefs: []
  type: TYPE_NORMAL
- en: 正確には、ほとんどすべてのオブジェクトは`Object.prototype`プロパティに定義された`prototype`オブジェクトを継承しています。
    `prototype`オブジェクトとは、すべてのオブジェクトの作成時に自動的に追加される特殊なオブジェクトです。 `Object`の`prototype`オブジェクトは、すべてのオブジェクトから利用できるメソッドなどを提供するベースオブジェクトとも言えます。
  prefs: []
  type: TYPE_NORMAL
- en: '![すべてのオブジェクトは`Object`の`prototype`を継承している](../Images/a5724e6230250e26ed28c35e386f54c9.png)'
  prefs: []
  type: TYPE_IMG
- en: 具体的にどういうことかを見てみます。
  prefs: []
  type: TYPE_NORMAL
- en: 先ほども登場した`toString`メソッドは、`Object`の`prototype`オブジェクトに定義があります。 次のように、`Object.prototype.toString`メソッドの実装自体も参照できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: このような`prototype`オブジェクトに組み込まれているメソッドは**プロトタイプメソッド**と呼ばれます。 この書籍では`Object.prototype.toString`のようなプロトタイプメソッドを「Objectの`toString`メソッド」と短縮して呼ぶことがあります。
  prefs: []
  type: TYPE_NORMAL
- en: '`Object`のインスタンスは、この`Object.prototype`オブジェクトに定義されたメソッドやプロパティを継承します。 つまり、オブジェクトリテラルや`new
    Object`でインスタンス化したオブジェクトは、`Object.prototype`に定義されたものが利用できるということです。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、オブジェクトリテラルで作成（インスタンス化）したオブジェクトから、`Object.prototype.toString`メソッドを参照しています。
    このときに、インスタンスの`toString`メソッドと`Object.prototype.toString`は同じものとなることがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: このように`Object.prototype`に定義されている`toString`メソッドなどは、インスタンス作成時に自動的に継承されるため、`Object`のインスタンスから呼び出せます。
    これによりオブジェクトリテラルで作成した空のオブジェクトでも、`Object.prototype.toString`メソッドなどを呼び出せるようになっています。
  prefs: []
  type: TYPE_NORMAL
- en: このインスタンスから`prototype`オブジェクト上に定義されたメソッドを参照できる仕組みを**プロトタイプチェーン**と呼びます。 プロトタイプチェーンの仕組みについては「[クラス](../class/)」の章で扱うため、ここではインスタンスからプロトタイプメソッドを呼び出せるということがわかっていれば問題ありません。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#prototype-shorthand-syntax)*[コラム] `Object#toString`という短縮した表記について*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*この書籍では、`Object.prototype.toString`のように`prototype`を含めて毎回書くと冗長なため、「Objectの`toString`メソッド」と短縮して書く場合があります。
    この書籍以外の文章では、`Object.prototype.toString`を`Object#toString`のように`prototype`の代わりに`#`を利用して表しているケースがあります。'
  prefs: []
  type: TYPE_NORMAL
- en: '`#`が`prototype`の短縮表現として使われていたのは、`#`がJavaScriptの構文として使われていない記号でもあったためです。 詳細は「[クラス](../class/)」の章で解説しますが、ES2022では`#`がJavaScriptの構文として追加され、`#`という記号が意味をもつようになりました。
    ES2022以降では、説明のために`#`を`prototype`の短縮表現に使うと、人によっては異なる意味に見えてしまう可能性があります。'
  prefs: []
  type: TYPE_NORMAL
- en: そのため、この書籍は`Object.prototype.toString`を`Object#toString`のように`#`を使って表す短縮表記は利用していません。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#same-method-name-order)*プロトタイプメソッドとインスタンスメソッドの優先順位*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*プロトタイプメソッドと同じ名前のメソッドがインスタンスオブジェクトに定義されている場合もあります。 その場合には、インスタンスに定義したメソッドが優先して呼び出されます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`Object`のインスタンスである`customObject`に`toString`メソッドを定義しています。 実行してみると、プロトタイプメソッドよりも優先してインスタンスのメソッドが呼び出されていることがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: このように、インスタンスとプロトタイプオブジェクトで同じ名前のメソッドがある場合には、インスタンスのメソッドが優先されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#diff-in-operator-and-object-hasown)*`Object.hasOwn`静的メソッドと`in`演算子との違い*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*「[オブジェクト](../object/)」の章で学んだ`Object.hasOwn`静的メソッドと`in`演算子の挙動の違いについて見ていきます。
    2つの挙動の違いはこの章で紹介したプロトタイプオブジェクトに関係しています。'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.hasOwn`静的メソッドは、指定したオブジェクト自体が指定したプロパティを持っているかを判定します。 一方、`in`演算子はオブジェクト自身が持っていなければ、そのオブジェクトの継承元である`prototype`オブジェクトまで探索して持っているかを判定します。
    つまり、`in`演算子はインスタンスに実装されたメソッドなのか、プロトタイプオブジェクトに実装されたメソッドなのかを区別しません。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、空のオブジェクトが`toString`メソッドを持っているかを`Object.hasOwn`静的メソッドと`in`演算子でそれぞれ判定しています。
    `Object.hasOwn`静的メソッドは`false`を返し、`in`演算子は`toString`メソッドがプロトタイプオブジェクトに存在するため`true`を返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 次のように、インスタンスが`toString`メソッドを持っている場合は、`Object.hasOwn`静的メソッドも`true`を返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[](#create-method)*オブジェクトの継承元を明示する`Object.create`メソッド*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*`Object.create`メソッドを使うと、第一引数に指定した`prototype`オブジェクトを継承した新しいオブジェクトを作成できます。'
  prefs: []
  type: TYPE_NORMAL
- en: これまでの説明で、オブジェクトリテラルは`Object.prototype`オブジェクトを自動的に継承したオブジェクトを作成していることがわかりました。
    オブジェクトリテラルで作成する新しいオブジェクトは、`Object.create`メソッドを使うことで次のように書けます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[](#inherit-object)*ArrayもObjectを継承している*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*`Object`と`Object.prototype`の関係と同じように、ビルトインオブジェクト`Array`も`Array.prototype`を持っています。
    同じように、配列（`Array`）のインスタンスは`Array.prototype`を継承します。 さらに、`Array.prototype`は`Object.prototype`を継承しているため、`Array`のインスタンスは`Object.prototype`も継承しています。'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array`のインスタンス → `Array.prototype` → `Object.prototype`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Object.create`メソッドを使って`Array`と`Object`の関係をコードとして表現してみます。 この疑似コードは、`Array`コンストラクタの実装など、実際のものとは異なる部分があるため、あくまでイメージであることに注意してください。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: このように、`Array`のインスタンスも`Object.prototype`を継承しているため、 `Object.prototype`に定義されているメソッドを利用できます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`Array`のインスタンスから`Object.prototype.hasOwnProperty`メソッドが参照できていることがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: このような`hasOwnProperty`メソッドの参照が可能なのもプロトタイプチェーンという仕組みによるものです。
  prefs: []
  type: TYPE_NORMAL
- en: ここでは、`Object.prototype`はすべてのオブジェクトの親となるオブジェクトであることを覚えておくだけで問題ありません。 これにより、`Array`や`String`などのインスタンスも`Object.prototype`が持つメソッドを利用できる点を覚えておきましょう。
  prefs: []
  type: TYPE_NORMAL
- en: また、`Array.prototype`などもそれぞれ独自のメソッドを定義しています。 たとえば、`Array.prototype.toString`メソッドもそのひとつです。
    そのため、Arrayのインスタンスで`toString`メソッドを呼び出すと`Array.prototype.toString`が優先して呼び出されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[](#not-inherit-object)*`Object.prototype`を継承しないオブジェクト*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*`Object`はすべてのオブジェクトの親になるオブジェクトであると言いましたが、例外もあります。'
  prefs: []
  type: TYPE_NORMAL
- en: イディオム（慣習的な書き方）ですが、`Object.create(null)`とすることで`Object.prototype`を継承しないオブジェクトを作成できます。
    これにより、プロパティやメソッドをまったく持たない本当に**空のオブジェクト**を作れます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`Object.create`メソッドはES5から導入されました。 `Object.create`メソッドは`Object.create(null)`というイディオムで、一部ライブラリなどで`Map`オブジェクトの代わりとして利用されていました。
    Mapとはキーと値の組み合わせを保持するためのオブジェクトです。'
  prefs: []
  type: TYPE_NORMAL
- en: ただのオブジェクトもMapとよく似た性質を持っていますが、最初からいくつかのプロパティが存在しアクセスできてしまいます。 なぜなら、`Object`のインスタンスはデフォルトで`Object.prototype`を継承するので、`toString`などのプロパティ名がオブジェクトを作成した時点で存在するためです。
    そのため、`Object.create(null)`で`Object.prototype`を継承しないオブジェクトを作成し、そのオブジェクトが`Map`の代わりとして使われていました。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: しかし、ES2015からは本物の`Map`が利用できるため、`Object.create(null)`を`Map`の代わりに利用する必要はありません。
    `Map`については「[Map/Set](../map-and-set/)」の章で詳しく紹介します。
  prefs: []
  type: TYPE_NORMAL
- en: また`Object.create(null)`によって作成される空のオブジェクトは、`Object.hasOwn`静的メソッドがES2022で導入された理由でもあります。
  prefs: []
  type: TYPE_NORMAL
- en: 次のように、`Object.prototype`を継承しないオブジェクトは、`Object.prototype.hasOwnProperty`メソッドを呼び出せません。
    そのため、オブジェクトがプロパティを持っているかということを確認する際に、単純には`hasOwnProperty`メソッドが使えないという状況が出てきました。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: ES2022から導入された`Object.hasOwn`静的メソッドは、対象のオブジェクトが`Object.prototype`を継承していないかは関係なく利用できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: このように、対象となるオブジェクトに依存しない`Object.hasOwn`静的メソッドは、`hasOwnProperty`メソッドの欠点を修正しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#conclusion)*まとめ*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*この章では、プロトタイプオブジェクトについて学びました。'
  prefs: []
  type: TYPE_NORMAL
- en: プロトタイプオブジェクトはオブジェクトの作成時に自動的に作成される
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object`のプロトタイプオブジェクトには`toString`などのプロトタイプメソッドが定義されている'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ほとんどのオブジェクトは`Object.prototype`を継承することで`toString`メソッドなどを呼び出せる
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: プロトタイプメソッドとインスタンスメソッドではインスタンスメソッドが優先される
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.create`メソッドを使うことでプロトタイプオブジェクトを継承しないオブジェクトを作成できる'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: プロトタイプオブジェクトに定義されているメソッドがどのように参照されているかを確認しました。 このプロトタイプの詳しい仕組みについては「[クラス](../class/)」の章で改めて解説します。********
  prefs: []
  type: TYPE_NORMAL
