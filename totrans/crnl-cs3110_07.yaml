- en: 'Lecture 5: Polymorphism and Pattern Matching'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variant types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists are very useful, but it turns out they are not really as special as they
    look. We can implement our own lists, and other more interesting data structures,
    such as binary trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen some simple examples of **variant types** sometimes known
    as **algebraic datatypes** or just **datatypes**. Variant types provide some needed
    power: the ability to have a variable that contains more than one kind of value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike tuple types and function types, but like record types, variant types
    cannot be anonymous; they must be declared with their names. Suppose we wanted
    to have a variable that could contain one of three values: Yes, No, or Maybe,
    very much like an `enum` in Java. Its type could be declared as a variant type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `type` keyword declares a name for the new type.  The variant type is declared
    with a set of **constructors** that describe the possible ways to make a value
    of that type. In this case, we have three constructors: `Yes`, `No`, and `Maybe`.
    Constructor names must start with an uppercase letter, and all other names in
    OCaml must start with a lowercase letter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The different constructors can also carry other values with them. For example,
    suppose we want a type that can either be a 2D point or a 3D point. It can be
    declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Some examples of values of type `eitherPoint` are: `TwoD (2.1, 3.0)` and `ThreeD
    (1.0, 0.0, -1.0)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a value of type `eitherPoint`, which is either a `TwoD` of
    something or `ThreeD` of something. We need a way to extract the "something".
    This can be done with pattern matching. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Variant type syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use *X* as a metavariable to represent the name of a constructor, and *T*
    to represent the name of a type. Optional syntactic elements are indicated by
    brackets [ ]. Then a variant type declaration looks like this in general:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type`*T* = *X*[1][`of` *t*[1]] | ... | *X[n]* [`of` *t**[n]*]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Variant types introduce new syntax for terms *e*, patterns *p*, and values
    *v*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*e* ::= ... |  *X e* |  `match`* e *`with `*p*[1] `->` *e*[1]| ... | *p[n]*
    `->` *e[n]**p* ::=  *X  *|  *X*`(`*x*[1] : *t*[1], ...,  *x[n]* : *t[n]*`)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*v* ::= *c* | (*v*[1], ..., *v[n]*) | `fun` *p* `->` *e* | *X v*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that the vertical bars in the expression "`match`* e *`with `*p*[1] `->`
    *e*[1 ]| ... | *p[n]* `->` *e[n]*" are part the syntax of this construct; the
    other vertical bars (|) are part of the BNF notation.
  prefs: []
  type: TYPE_NORMAL
- en: We can use variant types to define many useful data structures.  In fact, the
    `bool` is really just a variant type with constructors named `true` and `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing integer lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can write our own version of lists using variant types. Suppose we want
    to define values that act like linked lists of integers. A linked list is either
    empty, or it has an integer followed by another list containing the rest of the
    list elements. This leads to a very natural variant type declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This type has two constructors, `Nil` and `Cons`. It is a **recursive type**
    because it mentions itself in its own definition (in the `Cons` constructor),
    just like a recursive function is one that mentions itself in its own definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any list of integers can be represented by using this type. For example, the
    empty list is just the constructor `Nil`, and `Cons` corresponds to the operator
    `::`. Here are some examples of lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So we can construct any lists we want. We can also take them apart using pattern
    matching. For example, our `length` function above can be written for `intlist`s
    by just translating the list patterns into the corresponding patterns using constructors. 
    Similarly, we can implement many other functions over lists, as shown in the following
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Representing trees with a recursive type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Trees are another very useful data structure. Unlike lists, they are not built
    into OCaml. A binary tree is either
  prefs: []
  type: TYPE_NORMAL
- en: the empty tree (no children), or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a node containing a value and two children that are binary trees.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just for variety, let''s use a record type to represent a tree node. In OCaml
    we have to define two mutually recursive types, one to represent a tree node,
    and one to represent a (possibly empty) tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The rule for when mutually recursive type declarations are legal is a little
    tricky. Essentially, any cycle of recursive types must include at least one record
    or variant type. Since the cycle between `inttree` and `node` includes both kinds
    of types, this declaration is legal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Because there are several things stored in a tree node, it's helpful to use
    a record rather than a tuple to keep them all straight. But a tuple would also
    have worked.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use pattern matching to write the usual algorithms for recursively traversing
    trees. For example, here is a recursive search over the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if we knew the tree obeyed the binary search tree invariant, we could
    have written a more efficient algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Representing natural numbers with a recursive type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can even define data structures that act like numbers, demonstrating that
    we don''t really have to have numbers built into OCaml either! A natural number
    is either the value zero or the *successor* of some other natural number. This
    definition leads naturally to the following definition for values that act like
    natural numbers `nat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how you might define the natural numbers in a mathematical logic course.
    We have defined a new type `nat`, and `Zero` and `Next` are constructors for values
    of this type. The type `nat` is a **recursive type**, which allows us to build
    expressions that have an arbitrary number of nested `Next` constructors. Such
    values act like natural numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When we ask the interpreter what *four* represents, we get
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The equivalent Java definitions would be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: And in fact the implementation is similar.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can write functions to manipulate values of this type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here we're pattern-matching a value with type `nat`. If the value is `Zero`
    we evaluate to `true`; otherwise we evaluate to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here we determine the predecessor of a number. If the value of `n` matches `Zero`
    then we raise an exception, since zero has no predecessor in the natural numbers.
    If the value matches `Next m` for some value `m` (which of course also must be
    of type `nat`), then we return `m`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly we can define a function to add two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to try evaluating `add four four`, the interpreter would respond
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: which is the `nat` representation of 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand the results of our computation, we would like to convert
    such values to type `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: That was pretty easy. Now we can write `toInt (add four four)` and get *8*.
    How about the inverse operation?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To determine whether a natural number is even or odd, we can write a pair of
    mutually recursive functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You have to use the keyword `and` to combine mutually recursive functions like
    this. Otherwise the compiler would give an error when you refer to `odd` before
    it has been defined.
  prefs: []
  type: TYPE_NORMAL
- en: Finally we can define multiplication in terms of addition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: which gives
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It turns out that the syntax of OCaml patterns is richer than what we saw in
    the last lecture. In addition to new kinds of terms for creating and projecting
    tuple and record values, and creating and examining variant type values, we also
    have the ability to match patterns against values to pull them apart into their
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: When used properly, pattern matching leads to concise, clear code.  This is
    because  OCaml pattern matching allows one pattern to appear as a subexpression
    of another pattern. For example, we see above that `Next n` is a pattern, but
    so is `Next (Next n)`. This second pattern matches only on a value that has the
    form `Next (Next` *v*`)` for some value *v* (that is, the successor of the successor
    of something), and binds the variable `n` to that something, *v*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, in our implementation of the `nth` function, earlier, a neat trick
    is to use pattern matching to do the `if n = 0` and the `match` at the same time.
    We pattern-match on the tuple `(lst, n)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've also added a clause to catch the empty list and raise an exception.
    We're also using the wildcard pattern `_` to match on the `n` component of the
    tuple, because we don't need to bind the value of `n` to another variable—we already
    have `n`. We can make this code even shorter; can you see how?
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Pattern matching on records'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All natural numbers are nonnegative, but we can simulate integers in terms
    of the naturals by using a representation consisting of a sign and magnitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we''ve defined *integer* to refer to a record type with two fields: *sign*
    and *mag*. Remember that records are unordered, so there is no concept of a "first"
    field.'
  prefs: []
  type: TYPE_NORMAL
- en: The declarations of `sign` and `integer` both create new types.  However, it
    is possible to write type declarations that simply introduce a new name for an
    existing type. For example, if we wrote `type number = int`, then the types `number`
    and `int` could be used interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the definition of `integer` to write some integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write a function to determine the successor of any integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here we're pattern-matching on a record type. Notice that in the third pattern
    we are doing pattern matching because the `mag` field is matched against a pattern
    itself, `Next n`. Remember that the patterns are tested in order. How does the
    meaning of this function change if the first two patterns are swapped?
  prefs: []
  type: TYPE_NORMAL
- en: The predecessor function is very similar, and it should be obvious that we could
    write functions to add, subtract, and multiply integers in this representation.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: OCaml syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Taking into account the ability to write complex patterns, we can now write
    down a more comprehensive syntax for OCaml.
  prefs: []
  type: TYPE_NORMAL
- en: '| syntactic class | syntactic variables and grammar rule(s) | examples |'
  prefs: []
  type: TYPE_TB
- en: '| **identifiers** | *x*,  *y* | `a`, `x`, `y`, `x_y`, `foo1000`, ... |'
  prefs: []
  type: TYPE_TB
- en: '| **datatypes, datatype constructors** | *X*, *Y* | `Nil`, `Cons`, `list` |'
  prefs: []
  type: TYPE_TB
- en: '| **constants** | *c* | ...`~2`, `~1`, `0`, `1`, `2` (integers) `1.0`, `~0.001`,
    `3.141` (floats)'
  prefs: []
  type: TYPE_NORMAL
- en: '`true`, `false` (booleans)'
  prefs: []
  type: TYPE_NORMAL
- en: '`"hello"`, `""`, `"!"` (strings)'
  prefs: []
  type: TYPE_NORMAL
- en: '`#"A"`, `#" "` (characters) |'
  prefs: []
  type: TYPE_NORMAL
- en: '| **unary operator** | *u* | `~`, `not`, `size`, ... |'
  prefs: []
  type: TYPE_TB
- en: '| **binary operators** | *b* | `+`, `*`, `-`, `>`, `<`, `>=`, `<=`, `^`, ...
    |'
  prefs: []
  type: TYPE_TB
- en: '| **expressions (terms)** | *e* ::-  *c * &#124; *x*  &#124;  *u e  &#124; 
    e*[1]* b e*[2] *&#124;*`if`* e*[1]`then`* e*[2] `else`* e*[3]*  &#124;  *`let` *d*[1]*...**d[n]*`in`*e*`end`  &#124;
     *e* `(`*e*[1]`,` ...`,` *e[n]*`)`  `&#124; (`*e*[1]`,`...`,`*e[n]*`)`  `&#124;
    #`*n e*  &#124;   `{`*x*[1]`=`*e*[1]`,` ...`,` *x[n]*`=`*e[n]*`}`  `&#124; #`*x
    e  *&#124;   *X*`(`*e*`)`  &#124;  `match`* e *`with `*p*[1]`->`*e*[1]&#124; ... &#124; *p[n]*`->`*e[n]*
    | `~0.001`, `foo`, `not` `b`, `2 + 2`, `Cons(2, Nil)` |'
  prefs: []
  type: TYPE_TB
- en: '| **patterns** | *p* ::= *c * &#124; *x*  &#124;  `(`*p*[1]`,`...`,` *p[n]*`)`*  &#124;
     *`{`*x*[1]`=` *p*[1]`,`...`,`*x[n]*`=`*p[n]*`}`  &#124;  *X*  &#124;  *X* `(`
    *p* `)` | `a:int`, `(x:int,y:int), I(x:int)` |'
  prefs: []
  type: TYPE_TB
- en: '| **declarations** | *d* ::= `val`*p* *=* *e  *&#124;`fun`* y p *`:` *t* - *e*  &#124;
     `da``tatype` *Y*- *X*[1]**[**`of `*t*[1]**]** `&#124;` ... `&#124;` *X[n ]***[**`of`
    *t**[n]***]** | `val one = 1 fun square(x: int):  int'
  prefs: []
  type: TYPE_NORMAL
- en: datatype d - N &#124; I of int` |
  prefs: []
  type: TYPE_NORMAL
- en: '| **types** | *t* ::= `int`  &#124;  `float`  &#124;  `bool`  &#124;  `string`
     &#124;  `char`  &#124;  *t*[1]`->`*t*[2]*  &#124;  **t*[1]`*`...`*`*t[n]*  &#124;
     `{`*x*[1]:*t*[1], *x*[2]:*t*[2],..., *x[n]*:*t[n]*`}`  &#124;  *Y* | `int`, `string`,
    `int->int`, `bool*int->bool` |'
  prefs: []
  type: TYPE_TB
- en: '| **values** | *v* ::= *c*  &#124;  `(`*v*[1]`,`...`,`*v[n]*`)` &#124;  `{`*x*[1]`=`*v*[1]`,` ...`,` *x[n]*`=`*v[n]*`}`  &#124;
     *X*`(`*v*`)` | `2`, `(2,"hello")`, `Cons(2,Nil)` |'
  prefs: []
  type: TYPE_TB
- en: '*Note:* pattern-matching floating point constants is inadvisable. Equality
    on floats is a dangerous thing to rely upon. It''s better to test whether one
    float is within some small distance epsilon of another float.'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a nice feature that allows us to avoid rewriting the same code over
    and over so that it works for different types. Suppose we want to write a function
    that swaps the position of values in an ordered pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is tedious, because we're writing exactly the same algorithm each time.
    It gets worse! What if the two pair elements have different types?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And so on. There is a better way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of writing explicit types for `x` and `y`, we write **type variables**`''a`
    and `''b`.  The type of `swap` is `''a * ''b` `->` `''b * ''a`*.* This means that
    we can use swap as if it had any type that we could get by *consistently* replacing
    `''a` and `''b` in its type with a type for `''a` and a type for `''b`. We can
    use the new swap in place of all the old definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, we can leave out the type declarations in the definition of `swap`,
    and OCaml will figure out the most general polymorphic type it can be given, automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The ability to use swap as though it had many different types is known as **polymorphism**,
    from the Greek for "many forms".
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the type variables must be substituted consistently in any use of
    a polymorphic expression. For example, it is impossible for `swap` to have the
    type `(int * float) -> (string * int)`, because that type would consistently substitute
    for the type variable `'a` but not for `'b`.
  prefs: []
  type: TYPE_NORMAL
- en: OCaml programmers typically read the types `'a` and `'b` as "alpha" and "beta".
    This is easier than saying "single quotation mark a" or "apostrophe a". They also
    they wish they could write Greek letters instead. A type variable may be any identifier
    preceded by a single quotation mark; for example, `'key` and `'value` are also
    legal type variables. The OCaml compiler needs to have these identifiers preceded
    by a single quotation mark so that it knows it is seeing a type variable.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that to be polymorphic in a parameter `x`, a function
    may not use `x` in any way that would identify its type. It must treat `x` as
    a black box. Note that `swap` doesn't use its arguments `x` or `y` in any interesting
    way, but treats them as black boxes. When the OCaml type checker is checking the
    definition of `swap`, all it knows is that `x` is of some arbitrary type `'a`.
    It doesn't allow any operation to be performed on `x` that couldn't be performed
    on an arbitrary type. This means that the code is guaranteed to work for any `x`
    and `y`. However, we can apply other polymorphic functions. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also define polymorphic datatypes. For example, we defined lists of integers
    as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can make this more general by using a **parameterized variant type**
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: A parameterized datatype is a recipe for creating a family of related datatypes. The
    name `'a` is a **type parameter** for which any other type may be supplied. For
    example, `int list_` is a list of integers, `float list_` is a list of float,
    and so on. However, `list_` itself is not a type. Notice also that we cannot use
    `list_` to create a list each of whose elements can be any type. All of the elements
    of a `T list_` must be `T`'s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice `list_` itself is *not* a type. We can think of `list_` as a function
    that, when applied to a type like `int`, produces another type (`int` `list_`).
    It is a **parameterized type constructor**: a function that takes in parameters
    and gives back a type. Other languages have parameterized type constructors. For
    example, in Java you can declare a **parameterized class**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In OCaml, we can define **polymorphic functions** that know how to manipulate
    any kind of list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: For trees,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use a record type for the nodes, the record type also must be parameterized,
    and instantiated on the same element type as the tree type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to have multiple type parameters on a parameterized type,
    in which case parentheses are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract syntax and variant types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier we noticed that there is a similarity between BNF declarations and
    variant type declarations. In fact, we can define variant types that act like
    the corresponding BNF declarations. The values of these variant types then represent
    legal expressions that can occur in the language. For example, consider a BNF
    definition of legal OCaml type expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| (base types)  | *b* ::= `int` &#124; `float` &#124; `string` &#124; `bool`
    &#124; `char` |'
  prefs: []
  type: TYPE_TB
- en: '| (types) | *t* ::= *b* &#124; *t* `->` *t* &#124; *t*[1] `*` *t*[2] `*`...`*`
    *t[n]* &#124; `{` *x*[1] `:` *t*[1]`;` ...`;` *x[n]* `:` *t[n]* `}` &#124; *X*
    |'
  prefs: []
  type: TYPE_TB
- en: 'This grammar has exactly the same structure as the following type declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Any legal OCaml type expression can be represented by a value of type `mlType`
    that contains all the information of the corresponding type expression. This value
    is known as the *abstract syntax* for that expression. It is abstract because
    it doesn''t contain any information about the actual symbols used to represent
    the expression in the program. For example, the abstract syntax for the expression
    `int * bool -> {name : string}` would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The abstract syntax would be exactly the same even for a more verbose version
    of the same type expression: `((int * bool) -> {name : string})`. Compilers typically
    use abstract syntax internally to represent the program that they are compiling.
    We will see a lot more abstract syntax later in the course when we see how OCaml
    works.'
  prefs: []
  type: TYPE_NORMAL
