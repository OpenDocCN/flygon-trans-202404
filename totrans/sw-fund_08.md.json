["```\n\n```", "```\n\n# Inductively Defined Propositions\n\n    In the [Logic](Logic.html) chapter, we looked at several ways of writing\n    propositions, including conjunction, disjunction, and quantifiers.\n    In this chapter, we bring a new tool into the mix: *inductive definitions*.\n\n    Recall that we have seen two ways of stating that a number n is\n    even: We can say (1) evenb n = true, or (2) \u2203 k, n = double k.  Yet another possibility is to say that n is even if\n    we can establish its evenness from the following rules:\n\n*   Rule ev_0: The number 0 is even.\n\n*   Rule ev_SS: If n is even, then S (S n) is even.\n\n    To illustrate how this definition of evenness works, let's\n    imagine using it to show that 4 is even. By rule ev_SS, it\n    suffices to show that 2 is even. This, in turn, is again\n    guaranteed by rule ev_SS, as long as we can show that 0 is\n    even. But this last fact follows directly from the ev_0 rule. \n\n    We will see many definitions like this one during the rest\n    of the course.  For purposes of informal discussions, it is\n    helpful to have a lightweight notation that makes them easy to\n    read and write.  *Inference rules* are one such notation: \n\n           |\n\n                        (ev_0) \u00a0\n           |\n\n* * *\n\n           |\n\n                        ev\u00a00\n           |\n\n                     |\n\n                        ev\u00a0n\n           |\n\n                        (ev_SS) \u00a0\n           |\n\n* * *\n\n           |\n\n                        ev\u00a0(S\u00a0(S\u00a0n))\n           |\n\n                     |\n\n    Each of the textual rules above is reformatted here as an\n    inference rule; the intended reading is that, if the *premises*\n    above the line all hold, then the *conclusion* below the line\n    follows.  For example, the rule ev_SS says that, if n\n    satisfies ev, then S (S n) also does.  If a rule has no\n    premises above the line, then its conclusion holds\n    unconditionally.\n\n    We can represent a proof using these rules by combining rule\n    applications into a *proof tree*. Here's how we might transcribe\n    the above proof that 4 is even: \n\n```", "```\nInductive ev : nat \u2192 Prop :=\n| ev_0 : ev 0\n| ev_SS : \u2200n : nat, ev n \u2192 ev (S (S n)).\n\n```", "```\nFail Inductive wrong_ev (n : nat) : Prop :=\n| wrong_ev_0 : wrong_ev 0\n| wrong_ev_SS : \u2200n, wrong_ev n \u2192 wrong_ev (S (S n)).\n(*\u00a0===>\u00a0Error:\u00a0A\u00a0parameter\u00a0of\u00a0an\u00a0inductive\u00a0type\u00a0n\u00a0is\u00a0not \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0allowed\u00a0to\u00a0be\u00a0used\u00a0as\u00a0a\u00a0bound\u00a0variable\u00a0in\u00a0the\u00a0type \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0of\u00a0its\u00a0constructor.\u00a0*)\n\n```", "```\nTheorem ev_4 : ev 4.\nProof. apply ev_SS. apply ev_SS. apply ev_0. Qed.\n\n```", "```\nTheorem ev_4' : ev 4.\nProof. apply (ev_SS 2 (ev_SS 0 ev_0)). Qed.\n\n```", "```\nTheorem ev_plus4 : \u2200n, ev n \u2192 ev (4 + n).\nProof.\n\u00a0\u00a0intros n. simpl. intros Hn.\n\u00a0\u00a0apply ev_SS. apply ev_SS. apply Hn.\nQed.\n\n```", "```\nTheorem ev_double : \u2200n,\n\u00a0\u00a0ev (double n).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n# Using Evidence in Proofs\n\n    Besides *constructing* evidence that numbers are even, we can also\n    *reason about* such evidence.\n\n    Introducing ev with an Inductive declaration tells Coq not\n    only that the constructors ev_0 and ev_SS are valid ways to\n    build evidence that some number is even, but also that these two\n    constructors are the *only* ways to build evidence that numbers\n    are even (in the sense of ev). \n\n    In other words, if someone gives us evidence E for the assertion\n    ev n, then we know that E must have one of two shapes:\n\n*   E is ev_0 (and n is O), or\n\n*   E is ev_SS n' E' (and n is S (S n'), where E' is evidence for ev n').\n\n    This suggests that it should be possible to analyze a hypothesis\n    of the form ev n much as we do inductively defined data\n    structures; in particular, it should be possible to argue by\n    *induction* and *case analysis* on such evidence.  Let's look at a\n    few examples to see what this means in practice. \n\n## Inversion on Evidence\n\n    Suppose we are proving some fact involving a number n, and we\n    are given ev n as a hypothesis.  We already know how to perform\n    case analysis on n using the inversion tactic, generating\n    separate subgoals for the case where n = O and the case where n = S n' for some n'.  But for some proofs we may instead want to\n    analyze the evidence that ev n *directly*.\n\n    By the definition of ev, there are two cases to consider:\n\n*   If the evidence is of the form ev_0, we know that n = 0. \n\n*   Otherwise, the evidence must have the form ev_SS n' E', where n = S (S n') and E' is evidence for ev n'.\n\n    We can perform this kind of reasoning in Coq, again using\n    the inversion tactic.  Besides allowing us to reason about\n    equalities involving constructors, inversion provides a\n    case-analysis principle for inductively defined propositions.\n    When used in this way, its syntax is similar to destruct: We\n    pass it a list of identifiers separated by | characters to name\n    the arguments to each of the possible constructors.\n\n```", "```\n\n    In words, here is how the inversion reasoning works in this proof:\n\n*   If the evidence is of the form ev_0, we know that n = 0. Therefore, it suffices to show that ev (pred (pred 0)) holds. By the definition of pred, this is equivalent to showing that ev 0 holds, which directly follows from ev_0. \n\n*   Otherwise, the evidence must have the form ev_SS n' E', where n = S (S n') and E' is evidence for ev n'. We must then show that ev (pred (pred (S (S n')))) holds, which, after simplification, follows directly from E'.\n\n    This particular proof also works if we replace inversion by\n    destruct:\n\n```", "```\n\n    The difference between the two forms is that inversion is more\n    convenient when used on a hypothesis that consists of an inductive\n    property applied to a complex expression (as opposed to a single\n    variable).  Here's is a concrete example.  Suppose that we wanted\n    to prove the following variation of ev_minus2:\n\n```", "```\n\n    Intuitively, we know that evidence for the hypothesis cannot\n    consist just of the ev_0 constructor, since O and S are\n    different constructors of the type nat; hence, ev_SS is the\n    only case that applies.  Unfortunately, destruct is not smart\n    enough to realize this, and it still generates two subgoals.  Even\n    worse, in doing so, it keeps the final goal unchanged, failing to\n    provide any useful information for completing the proof.\n\n```", "```\n\n    What happened, exactly?  Calling destruct has the effect of\n    replacing all occurrences of the property argument by the values\n    that correspond to each constructor.  This is enough in the case\n    of ev_minus2' because that argument, n, is mentioned directly\n    in the final goal. However, it doesn't help in the case of\n    evSS_ev since the term that gets replaced (S (S n)) is not\n    mentioned anywhere. \n\n    The inversion tactic, on the other hand, can detect (1) that the\n    first case does not apply, and (2) that the n' that appears on\n    the ev_SS case must be the same as n.  This allows us to\n    complete the proof:\n\n```", "```\n\n    By using inversion, we can also apply the principle of explosion\n    to \"obviously contradictory\" hypotheses involving inductive\n    properties. For example:\n\n```", "```\n\n#### Exercise: 1 star (inversion_practice)\n\n    Prove the following results using inversion.\n\n```", "```\n\n    \u2610 \n\n    The way we've used inversion here may seem a bit\n    mysterious at first.  Until now, we've only used inversion on\n    equality propositions, to utilize injectivity of constructors or\n    to discriminate between different constructors.  But we see here\n    that inversion can also be applied to analyzing evidence for\n    inductively defined propositions.\n\n    Here's how inversion works in general.  Suppose the name I\n    refers to an assumption P in the current context, where P has\n    been defined by an Inductive declaration.  Then, for each of the\n    constructors of P, inversion I generates a subgoal in which\n    I has been replaced by the exact, specific conditions under\n    which this constructor could have been used to prove P.  Some of\n    these subgoals will be self-contradictory; inversion throws\n    these away.  The ones that are left represent the cases that must\n    be proved to establish the original goal.  For those, inversion\n    adds all equations into the proof context that must hold of the\n    arguments given to P (e.g., S (S n') = n in the proof of\n    evSS_ev). \n\n    The ev_double exercise above shows that our new notion of\n    evenness is implied by the two earlier ones (since, by\n    even_bool_prop in chapter [Logic](Logic.html), we already know that\n    those are equivalent to each other). To show that all three\n    coincide, we just need the following lemma:\n\n```", "```\n\n    We could try to proceed by case analysis or induction on n.  But\n    since ev is mentioned in a premise, this strategy would probably\n    lead to a dead end, as in the previous section.  Thus, it seems\n    better to first try inversion on the evidence for ev.  Indeed,\n    the first case can be solved trivially.\n\n```", "```\n\n    Unfortunately, the second case is harder.  We need to show \u2203 k, S (S n') = double k, but the only available assumption is\n    E', which states that ev n' holds.  Since this isn't directly\n    useful, it seems that we are stuck and that performing case\n    analysis on E was a waste of time.\n\n    If we look more closely at our second goal, however, we can see\n    that something interesting happened: By performing case analysis\n    on E, we were able to reduce the original result to an similar\n    one that involves a *different* piece of evidence for ev: E'.\n    More formally, we can finish our proof by showing that\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0assert (I : (\u2203k', n' = double k') \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u2203k, S (S n') = double k)).\n\u00a0\u00a0\u00a0\u00a0{ intros [k' Hk']. rewrite Hk'. \u2203(S k'). reflexivity. }\n\u00a0\u00a0\u00a0\u00a0apply I. (*\u00a0reduce\u00a0the\u00a0original\u00a0goal\u00a0to\u00a0the\u00a0new\u00a0one\u00a0*)\n\nAdmitted.\n\n```", "```\nLemma ev_even : \u2200n,\n\u00a0\u00a0ev n \u2192 \u2203k, n = double k.\nProof.\n\u00a0\u00a0intros n E.\n\u00a0\u00a0induction E as [|n' E' IH].\n\u00a0\u00a0- (*\u00a0E\u00a0=\u00a0ev_0\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u22030\\. reflexivity.\n\u00a0\u00a0- (*\u00a0E\u00a0=\u00a0ev_SS\u00a0n'\u00a0E' \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0with\u00a0IH\u00a0:\u00a0exists\u00a0k',\u00a0n'\u00a0=\u00a0double\u00a0k'\u00a0*)\n\u00a0\u00a0\u00a0\u00a0destruct IH as [k' Hk'].\n\u00a0\u00a0\u00a0\u00a0rewrite Hk'. \u2203(S k'). reflexivity.\nQed.\n\n```", "```\nTheorem ev_even_iff : \u2200n,\n\u00a0\u00a0ev n \u2194 \u2203k, n = double k.\nProof.\n\u00a0\u00a0intros n. split.\n\u00a0\u00a0- (*\u00a0->\u00a0*) apply ev_even.\n\u00a0\u00a0- (*\u00a0<-\u00a0*) intros [k Hk]. rewrite Hk. apply ev_double.\nQed.\n\n```", "```\nTheorem ev_sum : \u2200n m, ev n \u2192 ev m \u2192 ev (n + m).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nInductive ev' : nat \u2192 Prop :=\n| ev'_0 : ev' 0\n| ev'_2 : ev' 2\n| ev'_sum : \u2200n m, ev' n \u2192 ev' m \u2192 ev' (n + m).\n\n```", "```\nTheorem ev'_ev : \u2200n, ev' n \u2194 ev n.\nProof.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem ev_ev__ev : \u2200n m,\n\u00a0\u00a0ev (n+m) \u2192 ev n \u2192 ev m.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem ev_plus_plus : \u2200n m p,\n\u00a0\u00a0ev (n+m) \u2192 ev (n+p) \u2192 ev (m+p).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n# Inductive Relations\n\n    A proposition parameterized by a number (such as ev)\n    can be thought of as a *property* \u2014 i.e., it defines\n    a subset of nat, namely those numbers for which the proposition\n    is provable.  In the same way, a two-argument proposition can be\n    thought of as a *relation* \u2014 i.e., it defines a set of pairs for\n    which the proposition is provable.\n\n```", "```\n\n    One useful example is the \"less than or equal to\" relation on\n    numbers. \n\n    The following definition should be fairly intuitive.  It\n    says that there are two ways to give evidence that one number is\n    less than or equal to another: either observe that they are the\n    same number, or give evidence that the first is less than or equal\n    to the predecessor of the second.\n\n```", "```\n\n    Proofs of facts about \u2264 using the constructors le_n and\n    le_S follow the same patterns as proofs about properties, like\n    ev above. We can apply the constructors to prove \u2264\n    goals (e.g., to show that 3\u22643 or 3\u22646), and we can use\n    tactics like inversion to extract information from \u2264\n    hypotheses in the context (e.g., to prove that (2 \u2264 1) \u2192 2+2=5.) \n\n    Here are some sanity checks on the definition.  (Notice that,\n    although these are the same kind of simple \"unit tests\" as we gave\n    for the testing functions we wrote in the first few lectures, we\n    must construct their proofs explicitly \u2014 simpl and\n    reflexivity don't do the job, because the proofs aren't just a\n    matter of simplifying computations.)\n\n```", "```\n\n    The \"strictly less than\" relation n < m can now be defined\n    in terms of le.\n\n```", "```\n\n    Here are a few more simple relations on numbers:\n\n```", "```\n\n#### Exercise: 2 stars, optional (total_relation)\n\n    Define an inductive binary relation total_relation that holds\n    between every pair of natural numbers.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 stars, optional (empty_relation)\n\n    Define an inductive binary relation empty_relation (on numbers)\n    that never holds.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 3 stars, optional (le_exercises)\n\n    Here are a number of facts about the \u2264 and < relations that\n    we are going to need later in the course.  The proofs make good\n    practice exercises.\n\n```", "```\n\n    Hint: The next one may be easiest to prove by induction on m.\n\n```", "```\n\n    Hint: This theorem can easily be proved without using induction.\n\n```", "```\n\n#### Exercise: 2 stars, optional (leb_iff)\n\n```", "```\n\n    \u2610\n\n```", "```\n\n#### Exercise: 3 stars, recommendedM (R_provability)\n\n    We can define three-place relations, four-place relations,\n    etc., in just the same way as binary relations.  For example,\n    consider the following three-place relation on numbers:\n\n```", "```\n\n*   Which of the following propositions are provable? \n\n    *   R 1 1 2\n\n    *   R 2 2 6 \n\n*   If we dropped constructor c[5] from the definition of R, would the set of provable propositions change? Briefly (1 sentence) explain your answer. \n\n*   If we dropped constructor c[4] from the definition of R, would the set of provable propositions change? Briefly (1 sentence) explain your answer.\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610 \n\n#### Exercise: 3 stars, optional (R_fact)\n\n    The relation R above actually encodes a familiar function.\n    Figure out which function; then state and prove this equivalence\n    in Coq?\n\n```", "```\n\n    \u2610\n\n```", "```\n\n#### Exercise: 4 stars, advanced (subsequence)\n\n    A list is a *subsequence* of another list if all of the elements\n    in the first list occur in the same order in the second list,\n    possibly with some extra elements in between. For example,\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1;2;3]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1;1;1;2;2;3]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[1;2;7;3]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[5;6;1;9;9;2;7;3;8]\n\n    but it is *not* a subsequence of any of the lists\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0Inductive\u00a0R\u00a0:\u00a0nat\u00a0\u2192\u00a0list\u00a0nat\u00a0\u2192\u00a0Prop\u00a0:=\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0c[1]\u00a0:\u00a0R\u00a00\u00a0[]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0c[2]\u00a0:\u00a0\u2200n\u00a0l,\u00a0R\u00a0n\u00a0l\u00a0\u2192\u00a0R\u00a0(S\u00a0n)\u00a0(n\u00a0::\u00a0l)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0c[3]\u00a0:\u00a0\u2200n\u00a0l,\u00a0R\u00a0(S\u00a0n)\u00a0l\u00a0\u2192\u00a0R\u00a0n\u00a0l.\n\n    Which of the following propositions are provable?\n\n*   R 2 [1;0]\n\n*   R 1 [1;2;1;0]\n\n*   R 6 [3;2;1;0]\n\n    \u2610\n\n```", "```\nInductive reg_exp (T : Type) : Type :=\n| EmptySet : reg_exp T\n| EmptyStr : reg_exp T\n| Char : T \u2192 reg_exp T\n| App : reg_exp T \u2192 reg_exp T \u2192 reg_exp T\n| Union : reg_exp T \u2192 reg_exp T \u2192 reg_exp T\n| Star : reg_exp T \u2192 reg_exp T.\n\nArguments EmptySet {T}.\nArguments EmptyStr {T}.\nArguments Char {T} _.\nArguments App {T} _ _.\nArguments Union {T} _ _.\nArguments Star {T} _.\n\n```", "```\nInductive exp_match {T} : list T \u2192 reg_exp T \u2192 Prop :=\n| MEmpty : exp_match [] EmptyStr\n| MChar : \u2200x, exp_match [x] (Char x)\n| MApp : \u2200s[1] re[1] s[2] re[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exp_match s[1] re[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exp_match s[2] re[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exp_match (s[1] ++ s[2]) (App re[1] re[2])\n| MUnionL : \u2200s[1] re[1] re[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exp_match s[1] re[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exp_match s[1] (Union re[1] re[2])\n| MUnionR : \u2200re[1] s[2] re[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exp_match s[2] re[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exp_match s[2] (Union re[1] re[2])\n| MStar0 : \u2200re, exp_match [] (Star re)\n| MStarApp : \u2200s[1] s[2] re,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exp_match s[1] re \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exp_match s[2] (Star re) \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exp_match (s[1] ++ s[2]) (Star re).\n\n```", "```\nNotation \"s =~ re\" := (exp_match s re) (at level 80).\n\n```", "```\nExample reg_exp_ex[1] : [1] =~ Char 1.\nProof.\n\u00a0\u00a0apply MChar.\nQed.\n\nExample reg_exp_ex[2] : [1; 2] =~ App (Char 1) (Char 2).\nProof.\n\u00a0\u00a0apply (MApp [1] _ [2]).\n\u00a0\u00a0- apply MChar.\n\u00a0\u00a0- apply MChar.\nQed.\n\n```", "```\nExample reg_exp_ex[3] : \u00ac ([1; 2] =~ Char 1).\nProof.\n\u00a0\u00a0intros H. inversion H.\nQed.\n\n```", "```\nFixpoint reg_exp_of_list {T} (l : list T) :=\n\u00a0\u00a0match l with\n\u00a0\u00a0| [] \u21d2 EmptyStr\n\u00a0\u00a0| x :: l' \u21d2 App (Char x) (reg_exp_of_list l')\n\u00a0\u00a0end.\n\nExample reg_exp_ex[4] : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3].\nProof.\n\u00a0\u00a0simpl. apply (MApp [1]).\n\u00a0\u00a0{ apply MChar. }\n\u00a0\u00a0apply (MApp [2]).\n\u00a0\u00a0{ apply MChar. }\n\u00a0\u00a0apply (MApp [3]).\n\u00a0\u00a0{ apply MChar. }\n\u00a0\u00a0apply MEmpty.\nQed.\n\n```", "```\nLemma MStar1 :\n\u00a0\u00a0\u2200T s (re : reg_exp T) ,\n\u00a0\u00a0\u00a0\u00a0s =~ re \u2192\n\u00a0\u00a0\u00a0\u00a0s =~ Star re.\nProof.\n\u00a0\u00a0intros T s re H.\n\u00a0\u00a0rewrite \u2190 (app_nil_r _ s).\n\u00a0\u00a0apply (MStarApp s [] re).\n\u00a0\u00a0- apply H.\n\u00a0\u00a0- apply MStar0.\nQed.\n\n```", "```\nLemma empty_is_empty : \u2200T (s : list T),\n\u00a0\u00a0\u00ac (s =~ EmptySet).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nLemma MUnion' : \u2200T (s : list T) (re[1] re[2] : reg_exp T),\n\u00a0\u00a0s =~ re[1] \u2228 s =~ re[2] \u2192\n\u00a0\u00a0s =~ Union re[1] re[2].\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nLemma MStar' : \u2200T (ss : list (list T)) (re : reg_exp T),\n\u00a0\u00a0(\u2200s, In s ss \u2192 s =~ re) \u2192\n\u00a0\u00a0fold app ss [] =~ Star re.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nLemma reg_exp_of_list_spec : \u2200T (s[1] s[2] : list T),\n\u00a0\u00a0s[1] =~ reg_exp_of_list s[2] \u2194 s[1] = s[2].\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nFixpoint re_chars {T} (re : reg_exp T) : list T :=\n\u00a0\u00a0match re with\n\u00a0\u00a0| EmptySet \u21d2 []\n\u00a0\u00a0| EmptyStr \u21d2 []\n\u00a0\u00a0| Char x \u21d2 [x]\n\u00a0\u00a0| App re[1] re[2] \u21d2 re_chars re[1] ++ re_chars re[2]\n\u00a0\u00a0| Union re[1] re[2] \u21d2 re_chars re[1] ++ re_chars re[2]\n\u00a0\u00a0| Star re \u21d2 re_chars re\n\u00a0\u00a0end.\n\n```", "```\nTheorem in_re_match : \u2200T (s : list T) (re : reg_exp T) (x : T),\n\u00a0\u00a0s =~ re \u2192\n\u00a0\u00a0In x s \u2192\n\u00a0\u00a0In x (re_chars re).\nProof.\n\u00a0\u00a0intros T s re x Hmatch Hin.\n\u00a0\u00a0induction Hmatch\n\u00a0\u00a0\u00a0\u00a0as [\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|x'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|s[1] re[1] s[2] re[2] Hmatch1 IH[1] Hmatch2 IH[2]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|s[1] re[1] re[2] Hmatch IH|re[1] s[2] re[2] Hmatch IH\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|re|s[1] s[2] re Hmatch1 IH[1] Hmatch2 IH[2]].\n\u00a0\u00a0(*\u00a0WORKED\u00a0IN\u00a0CLASS\u00a0*)\n\u00a0\u00a0- (*\u00a0MEmpty\u00a0*)\n\u00a0\u00a0\u00a0\u00a0apply Hin.\n\u00a0\u00a0- (*\u00a0MChar\u00a0*)\n\u00a0\u00a0\u00a0\u00a0apply Hin.\n\u00a0\u00a0- simpl. rewrite in_app_iff in *.\n\u00a0\u00a0\u00a0\u00a0destruct Hin as [Hin | Hin].\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0In\u00a0x\u00a0s[1]\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0left. apply (IH[1] Hin).\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0In\u00a0x\u00a0s[2]\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0right. apply (IH[2] Hin).\n\u00a0\u00a0- (*\u00a0MUnionL\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl. rewrite in_app_iff.\n\u00a0\u00a0\u00a0\u00a0left. apply (IH Hin).\n\u00a0\u00a0- (*\u00a0MUnionR\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl. rewrite in_app_iff.\n\u00a0\u00a0\u00a0\u00a0right. apply (IH Hin).\n\u00a0\u00a0- (*\u00a0MStar0\u00a0*)\n\u00a0\u00a0\u00a0\u00a0destruct Hin.\n\n```", "```\n\u00a0\u00a0- (*\u00a0MStarApp\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl. rewrite in_app_iff in Hin.\n\u00a0\u00a0\u00a0\u00a0destruct Hin as [Hin | Hin].\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0In\u00a0x\u00a0s[1]\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply (IH[1] Hin).\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0In\u00a0x\u00a0s[2]\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply (IH[2] Hin).\nQed.\n\n```", "```\nFixpoint re_not_empty {T : Type} (re : reg_exp T) : bool\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nLemma re_not_empty_correct : \u2200T (re : reg_exp T),\n\u00a0\u00a0(\u2203s, s =~ re) \u2194 re_not_empty re = true.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nLemma star_app: \u2200T (s[1] s[2] : list T) (re : reg_exp T),\n\u00a0\u00a0s[1] =~ Star re \u2192\n\u00a0\u00a0s[2] =~ Star re \u2192\n\u00a0\u00a0s[1] ++ s[2] =~ Star re.\nProof.\n\u00a0\u00a0intros T s[1] s[2] re H[1].\n\n```", "```\n\u00a0\u00a0induction H[1]\n\u00a0\u00a0\u00a0\u00a0as [|x'|s[1] re[1] s[2]' re[2] Hmatch1 IH[1] Hmatch2 IH[2]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|s[1] re[1] re[2] Hmatch IH|re[1] s[2]' re[2] Hmatch IH\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|re''|s[1] s[2]' re'' Hmatch1 IH[1] Hmatch2 IH[2]].\n\n```", "```\n\u00a0\u00a0- (*\u00a0MEmpty\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl. intros H. apply H.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0s[2]\u00a0=~\u00a0Char\u00a0x'\u00a0\u2192\u00a0x'\u00a0::\u00a0s[2]\u00a0=~\u00a0Char\u00a0x',\n\n    which is clearly impossible.\n\n```", "```\n\n    The problem is that induction over a Prop hypothesis only works\n    properly with hypotheses that are completely general, i.e., ones\n    in which all the arguments are variables, as opposed to more\n    complex expressions, such as Star re.\n\n    (In this respect, induction on evidence behaves more like\n    destruct than like inversion.)\n\n    We can solve this problem by generalizing over the problematic\n    expressions with an explicit equality:\n\n```", "```\n\n    We can now proceed by performing induction over evidence directly,\n    because the argument to the first hypothesis is sufficiently\n    general, which means that we can discharge most cases by inverting\n    the re' = Star re equality in the context.\n\n    This idiom is so common that Coq provides a tactic to\n    automatically generate such equations for us, avoiding thus the\n    need for changing the statements of our theorems. \n\n    Invoking the tactic remember e as x causes Coq to (1) replace\n    all occurrences of the expression e by the variable x, and (2)\n    add an equation x = e to the context.  Here's how we can use it\n    to show the above result:\n\n```", "```\n\n    We now have Heqre' : re' = Star re.\n\n```", "```\n\n    The Heqre' is contradictory in most cases, which allows us to\n    conclude immediately.\n\n```", "```\n\n    The interesting cases are those that correspond to Star.  Note\n    that the induction hypothesis IH[2] on the MStarApp case\n    mentions an additional premise Star re'' = Star re', which\n    results from the equality generated by remember.\n\n```", "```\n\n#### Exercise: 4 stars (exp_match_ex[2])\n\n    The MStar'' lemma below (combined with its converse, the\n    MStar' exercise above), shows that our definition of exp_match\n    for Star is equivalent to the informal one given previously.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 5 stars, advanced (pumping)\n\n    One of the first really interesting theorems in the theory of\n    regular expressions is the so-called *pumping lemma*, which\n    states, informally, that any sufficiently long string s matching\n    a regular expression re can be \"pumped\" by repeating some middle\n    section of s an arbitrary number of times to produce a new\n    string also matching re.\n\n    To begin, we need to define \"sufficiently long.\"  Since we are\n    working in a constructive logic, we actually need to be able to\n    calculate, for each regular expression re, the minimum length\n    for strings s to guarantee \"pumpability.\"\n\n```", "```\n\n    Next, it is useful to define an auxiliary function that repeats a\n    string (appends it to itself) some number of times.\n\n```", "```\n\n    Now, the pumping lemma itself says that, if s =~ re and if the\n    length of s is at least the pumping constant of re, then s\n    can be split into three substrings s[1] ++ s[2] ++ s[3] in such a way\n    that s[2] can be repeated any number of times and the result, when\n    combined with s[1] and s[3] will still match re.  Since s[2] is\n    also guaranteed not to be the empty string, this gives us\n    a (constructive!) way to generate strings matching re that are\n    as long as we like.\n\n```", "```\n\n    To streamline the proof (which you are to fill in), the omega\n    tactic, which is enabled by the following Require, is helpful in\n    several places for automatically completing tedious low-level\n    arguments involving equalities or inequalities over natural\n    numbers.  We'll return to omega in a later chapter, but feel\n    free to experiment with it now if you like.  The first case of the\n    induction gives an example of how it is used.\n\n```", "```\n\n    \u2610\n\n```", "```\nTheorem filter_not_empty_In : \u2200n l,\n\u00a0\u00a0filter (beq_nat n) l \u2260 [] \u2192\n\u00a0\u00a0In n l.\nProof.\n\u00a0\u00a0intros n l. induction l as [|m l' IHl'].\n\u00a0\u00a0- (*\u00a0l\u00a0=\u00a0\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl. intros H. apply H. reflexivity.\n\u00a0\u00a0- (*\u00a0l\u00a0=\u00a0m\u00a0::\u00a0l'\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl. destruct ([beq_nat](Basics.html#beq_nat) n m) eqn:H.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0beq_nat\u00a0n\u00a0m\u00a0=\u00a0true\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intros _. rewrite [beq_nat_true_iff](Logic.html#beq_nat_true_iff) in H. rewrite H.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0left. reflexivity.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0beq_nat\u00a0n\u00a0m\u00a0=\u00a0false\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intros H'. right. apply IHl'. apply H'.\nQed. \n```", "```\nModule FirstTry.\n\nInductive reflect : Prop \u2192 bool \u2192 Prop :=\n| ReflectT : \u2200(P:Prop), P \u2192 reflect P true\n| ReflectF : \u2200(P:Prop), \u00ac P \u2192 reflect P false.\n\n```", "```\nEnd FirstTry.\n\nInductive reflect (P : Prop) : bool \u2192 Prop :=\n| ReflectT : P \u2192 reflect P true\n| ReflectF : \u00ac P \u2192 reflect P false.\n\n```", "```\nTheorem iff_reflect : \u2200P b, (P \u2194 b = true) \u2192 reflect P b.\nProof.\n\u00a0\u00a0(*\u00a0WORKED\u00a0IN\u00a0CLASS\u00a0*)\n\u00a0\u00a0intros P b H. destruct b.\n\u00a0\u00a0- apply ReflectT. rewrite H. reflexivity.\n\u00a0\u00a0- apply ReflectF. rewrite H. intros H'. inversion H'.\nQed.\n\n```", "```\nTheorem reflect_iff : \u2200P b, reflect P b \u2192 (P \u2194 b = true).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nLemma beq_natP : \u2200n m, reflect (n = m) (beq_nat n m).\nProof.\n\u00a0\u00a0intros n m.\n\u00a0\u00a0apply iff_reflect. rewrite beq_nat_true_iff. reflexivity.\nQed.\n\n```", "```\nTheorem filter_not_empty_In' : \u2200n l,\n\u00a0\u00a0filter (beq_nat n) l \u2260 [] \u2192\n\u00a0\u00a0In n l.\nProof.\n\u00a0\u00a0intros n l. induction l as [|m l' IHl'].\n\u00a0\u00a0- (*\u00a0l\u00a0=\u00a0\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl. intros H. apply H. reflexivity.\n\u00a0\u00a0- (*\u00a0l\u00a0=\u00a0m\u00a0::\u00a0l'\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl. destruct ([beq_natP](IndProp.html#beq_natP) n m) as [H | H].\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0n\u00a0=\u00a0m\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intros _. rewrite H. left. reflexivity.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0n\u00a0<>\u00a0m\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intros H'. right. apply IHl'. apply H'.\nQed. \n```", "```\nFixpoint count n l :=\n\u00a0\u00a0match l with\n\u00a0\u00a0| [] \u21d2 0\n\u00a0\u00a0| m :: l' \u21d2 (if beq_nat n m then 1 else 0) + count n l'\n\u00a0\u00a0end.\n\nTheorem beq_natP_practice : \u2200n l,\n\u00a0\u00a0count n l = 0 \u2192 ~(In n l).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n# Additional Exercises\n\n#### Exercise: 3 stars, recommended (nostutter)\n\n    Formulating inductive definitions of properties is an important\n    skill you'll need in this course.  Try to solve this exercise\n    without any help at all.\n\n    We say that a list \"stutters\" if it repeats the same element\n    consecutively.  The property \"nostutter mylist\" means that\n    mylist does not stutter.  Formulate an inductive definition for\n    nostutter.  (This is different from the NoDup property in the\n    exercise above; the sequence 1;4;1 repeats but does not\n    stutter.)\n\n```", "```\n\n    Make sure each of these tests succeeds, but feel free to change\n    the suggested proof (in comments) if the given one doesn't work\n    for you.  Your definition might be different from ours and still\n    be correct, in which case the examples might need a different\n    proof.  (You'll notice that the suggested proofs use a number of\n    tactics we haven't talked about, to make them more robust to\n    different possible ways of defining nostutter.  You can probably\n    just uncomment and use them as-is, but you can also prove each\n    example with more basic tactics.)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 4 stars, advanced (filter_challenge)\n\n    Let's prove that our definition of filter from the Poly\n    chapter matches an abstract specification.  Here is the\n    specification, written out informally in English:\n\n    A list l is an \"in-order merge\" of l[1] and l[2] if it contains\n    all the same elements as l[1] and l[2], in the same order as l[1]\n    and l[2], but possibly interleaved.  For example,\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0[1;6;2]\n\n    and\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n    \u00a0\u00a0c\u00a0:\u00a0\u2200l,\u00a0l\u00a0=\u00a0rev\u00a0l\u00a0\u2192\u00a0pal\u00a0l\n\n     may seem obvious, but will not work very well.) \n\n    ```", "```\n    \u00a0\u2200l,\u00a0pal\u00a0(l\u00a0++\u00a0rev\u00a0l).\n\n    ```", "```\n    \u00a0\u2200l,\u00a0pal\u00a0l\u00a0\u2192\u00a0l\u00a0=\u00a0rev\u00a0l.\n\n    ```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u2200l,\u00a0l\u00a0=\u00a0rev\u00a0l\u00a0\u2192\u00a0pal\u00a0l.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 4 stars, advanced, optional (NoDup)\n\n    Recall the definition of the In property from the Logic\n    chapter, which asserts that a value x appears at least once in a\n    list l:\n\n```", "```\n\n    Your first task is to use In to define a proposition disjoint X l[1] l[2], which should be provable exactly when l[1] and l[2] are\n    lists (with elements of type X) that have no elements in\n    common.\n\n```", "```\n\n    Next, use In to define an inductive proposition NoDup X l, which should be provable exactly when l is a list (with\n    elements of type X) where every member is different from every\n    other.  For example, NoDup nat [1;2;3;4] and NoDup bool [] should be provable, while NoDup nat [1;2;1] and\n    NoDup bool [true;true] should not be.\n\n```", "```\n\n    Finally, state and prove one or more interesting theorems relating\n    disjoint, NoDup and ++ (list append).\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 4 stars, advanced, optional (pigeonhole principle)\n\n    The *pigeonhole principle* states a basic fact about counting: if\n   we distribute more than n items into n pigeonholes, some\n   pigeonhole must contain at least two items.  As often happens, this\n   apparently trivial fact about numbers requires non-trivial\n   machinery to prove, but we now have enough... \n\n    First prove an easy useful lemma.\n\n```", "```\n\n    Now define a property repeats such that repeats X l asserts\n    that l contains at least one repeated element (of type X).\n\n```", "```\n\n    Now, here's a way to formalize the pigeonhole principle.  Suppose\n    list l[2] represents a list of pigeonhole labels, and list l[1]\n    represents the labels assigned to a list of items.  If there are\n    more items than labels, at least two items must have the same\n    label \u2014 i.e., list l[1] must contain repeats.\n\n    This proof is much easier if you use the excluded_middle\n    hypothesis to show that In is decidable, i.e., \u2200 x l, (In x l) \u2228 \u00ac (In x l).  However, it is also possible to make the proof\n    go through *without* assuming that In is decidable; if you\n    manage to do this, you will not need the excluded_middle\n    hypothesis.\n\n```", "```\n\n    \u2610 \n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]