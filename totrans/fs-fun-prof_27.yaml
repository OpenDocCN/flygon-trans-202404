- en: The "Recursive types and folds" Series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this series, we'll look at recursive types and how to use them, and on the
    way, we'll look at catamorphisms, tail recursion, the difference between left
    and right folds, and more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '[Introduction to recursive types](recursive-types-and-folds1.html). Don''t
    fear the catamorphism....'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism examples](recursive-types-and-folds-1b.html). Applying the rules
    to other domains.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing Folds](recursive-types-and-folds-2.html). Threading state through
    a recursive data structure.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Understanding Folds](recursive-types-and-folds-2b.html). Recursion vs. iteration.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Generic recursive types](recursive-types-and-folds-3.html). Implementing a
    domain in three ways.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Trees in the real world](recursive-types-and-folds-3b.html). Examples using
    databases, JSON and error handling.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to recursive types
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to recursive types
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this series, we'll look at recursive types and how to use them, and on the
    way, we'll look at catamorphisms, tail recursion, the difference between left
    and right folds, and more.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the contents of this series:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: Catamorphism examples**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Introducing folds**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Understanding folds**'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: Generic recursive types**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Trees in the real world**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[定义通用的树类型](recursive-types-and-folds-3b.html#tree)'
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[现实世界中的树类型](recursive-types-and-folds-3b.html#reuse)'
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[映射树类型](recursive-types-and-folds-3b.html#map)'
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：创建目录列表](recursive-types-and-folds-3b.html#listing)'
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：并行grep](recursive-types-and-folds-3b.html#grep)'
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：将文件系统存储在数据库中](recursive-types-and-folds-3b.html#database)'
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：将树序列化为JSON](recursive-types-and-folds-3b.html#tojson)'
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：从JSON反序列化树](recursive-types-and-folds-3b.html#fromjson)'
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：从JSON反序列化树-带错误处理](recursive-types-and-folds-3b.html#json-with-error-handling)'
- en: '* * *'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: A basic recursive type
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个基本的递归类型
- en: Let's start with a simple example -- how to model a gift.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始--如何建模一个礼物。
- en: As it happens, I'm a very lazy gift-giver. I always give people a book or chocolates.
    I generally wrap them, and sometimes, if I'm feeling particularly extravagant,
    I put them in a gift box and add a card too.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 碰巧，我是一个非常懒惰的送礼者。我总是送人一本书或巧克力。我通常会包装它们，有时，如果我感觉格外慷慨，我会把它们放在礼品盒里，还会加上一张卡片。
- en: 'Let''s see how I might model this in types:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我如何在类型中建模这个：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see that three of the cases are "containers" that refer to another `Gift`.
    The `Wrapped` case has some paper and a inner gift, as does the `Boxed` case,
    as does the `WithACard` case. The two other cases, `Book` and `Chocolate`, do
    not refer to a gift and can be considered "leaf" nodes or terminals.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到三种情况是指向另一个`Gift`的“容器”。`Wrapped`情况有一些纸和一个内部礼物，`Boxed`情况也是如此，`WithACard`情况也是如此。另外两种情况，`Book`和`Chocolate`，不涉及礼物，可以被视为“叶”节点或终端。
- en: The presence of a reference to an inner `Gift` in those three cases makes `Gift`
    a *recursive type*. Note that, unlike functions, the `rec` keyword is *not* needed
    for defining recursive types.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种情况中引用内部`Gift`使`Gift`成为*递归类型*。请注意，与函数不同，定义递归类型时*不*需要使用`rec`关键字。
- en: 'Let''s create some example values:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些示例值：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Before we start working with these values, a word of advice...
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理这些值之前，给出一个建议...
- en: 'Guideline: Avoid infinitely recursive types'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指南：避免无限递归类型
- en: I suggest that, in F#, every recursive type should consist of a mix of recursive
    and non-recursive cases. If there were no non-recursive elements, such as `Book`,
    all values of the type would have to be infinitely recursive.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议，在F#中，每个递归类型都应该包含递归和非递归情况的混合。如果没有非递归元素，比如`Book`，那么该类型的所有值都必须是无限递归的。
- en: For example, in the `ImpossibleGift` type below, all the cases are recursive.
    To construct any one of the cases you need an inner gift, and that needs to be
    constructed too, and so on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的`ImpossibleGift`类型中，所有情况都是递归的。要构造任何一个情况，你需要一个内部礼物，而那也需要被构造，依此类推。
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is possible to create such types if you allow [laziness](https://wiki.haskell.org/Tying_the_Knot),
    mutation, or reflection. But in general, in a non-lazy language like F#, it's
    a good idea to avoid such types.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许[懒惰](https://wiki.haskell.org/Tying_the_Knot)、变异或反射，就可以创建这种类型。但一般来说，在像F#这样的非懒惰语言中，最好避免使用这种类型。
- en: Working with recursive types
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理递归类型
- en: End of public service announcement -- let's get coding!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 公共服务公告结束--让我们开始编码吧！
- en: 'First, say that we want a description of the gift. The logic will be:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们说我们想要一个礼物的描述。逻辑将是：
- en: For the two non-recursive cases, return a string describing that case.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于两种非递归情况，返回描述该情况的字符串。
- en: For the three recursive cases, return a string that describes the case, but
    also includes the description of the inner gift. This means that `description`
    function is going to refer to itself, and therefore it must be marked with the
    `rec` keyword.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于三种递归情况，返回描述该情况的字符串，但也包括内部礼物的描述。这意味着`description`函数将引用自身，因此必须用`rec`关键字标记。
- en: 'Here''s an example implementation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例实现：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note the recursive calls like this one in the `Boxed` case:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Boxed`情况中的递归调用，如下所示：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we try this with our example values, let''s see what we get:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试用我们的示例值来做这个，让我们看看我们会得到什么：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That looks pretty good to me. Things like `HappyHolidays` look a bit funny without
    spaces, but it's good enough to demonstrate the idea.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: What about creating another function? For example, what is the total cost of
    a gift?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'For `totalCost`, the logic will be:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Books and chocolate capture the price in the case-specific data, so use that.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping adds `0.5` to the cost.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A box adds `1.0` to the cost.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A card adds `2.0` to the cost.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And here are the costs for the two examples:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Sometimes, people ask what is inside the box or wrapping paper. A `whatsInside`
    function is easy to implement -- just ignore the container cases and return something
    for the non-recursive cases.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And the results:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So that's a good start -- three functions, all quite easy to write.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Parameterize all the things
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: However, these three functions have some duplicate code. In addition to the
    unique application logic, each function is doing its own pattern matching and
    its own logic for recursively visiting the inner gift.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: How can we separate the navigation logic from the application logic?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: Parameterize all the things!'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: As always, we can parameterize the application logic by passing in functions.
    In this case, we will need *five* functions, one for each case.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Here is the new, parameterized version -- I'll explain why I have called it
    `cataGift` shortly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can see this function is created using a purely mechanical process:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Each function parameter (`fBook`, `fChocolate`, etc) corresponds to a case.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the two non-recursive cases, the function parameter is passed all the data
    associated with that case.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the three recursive cases, there are two steps:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, the `cataGift` function is called recursively on the `innerGift` to get
    an `innerGiftResult`
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then the appropriate handler is passed all the data associated with that case,
    but with `innerGiftResult` replacing `innerGift`.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's rewrite total cost using the generic `cataGift` function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The `innerGiftResult` is now the total cost of the inner gift, so I have renamed
    it to `innerCost`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `totalCostUsingCata` function itself is not recursive, because it uses the
    `cataGift` function, and so no longer needs the `rec` keyword.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And this function gives the same result as before:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can rewrite the `description` function using `cataGift` in the same way,
    changing `innerGiftResult` to `innerText`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And the results are the same as before:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Introducing catamorphisms
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `cataGift` function we wrote above is called a "[catamorphism](https://en.wikipedia.org/wiki/Catamorphism)",
    from the Greek components "down + shape". In normal usage, a catamorphism is a
    function that "collapses" a recursive type into a new value based on its *structure*.
    In fact, you can think of a catamorphism as a sort of "visitor pattern".
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: A catamorphism is very powerful concept, because it is the most fundamental
    function that you can define for a structure like this. *Any other function* can
    be defined in terms of it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: That is, if we want to create a function with signature `Gift -> string` or
    `Gift -> int`, we can use a catamorphism to create it by specifying a function
    for each case in the `Gift` structure.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: We saw above how we could rewrite `totalCost` as `totalCostUsingCata` using
    the catamorphism, and we'll see lots of other examples later.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Catamorphisms and folds
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Catamorphisms are often called "folds", but there is more than one kind of fold,
    so I will tend to use "catamorphism" to refer the *concept* and "fold" to refer
    to a specific kind of implementation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: I will talk in detail about the various kinds of folds in a [subsequent post](recursive-types-and-folds-2.html),
    so for the rest of this post I will just use "catamorphism".
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Tidying up the implementation
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `cataGift` implementation above was deliberately long-winded so that you
    could see each step. Once you understand what is going on though, you can simplify
    it somewhat.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `cataGift fBook fChocolate fWrapped fBox fCard` crops up three times,
    once for each recursive case. Let''s assign it a name like `recurse`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `recurse` function has the simple signature `Gift -> 'a` -- that is, it
    converts a `Gift` to the return type we need, and so we can use it to work with
    the various `innerGift` values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The other thing is to replace `innerGift` with just `gift` in the recursive
    cases -- this is called "shadowing". The benefit is that the "outer" `gift` is
    no longer visible to the case-handling code, and so we can't accidentally recurse
    into it, which would cause an infinite loop.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Generally I avoid shadowing, but this is one case where it actually is a good
    practice, because it eliminates a particularly nasty kind of bug.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the version after the clean up:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: One more thing. I'm going to explicitly annotate the return type and call it
    `'r`. Later on in this series we'll be dealing with other generic types such as
    `'a` and `'b`, so it will be helpful to be consistent and always have a standard
    name for the return type.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s the final version:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It's much simpler than the original implementation, and also demonstrates the
    symmetry between a case constructor like `Wrapped (gift,style)` and the corresponding
    handler `fWrapped (recurse gift,style)`. Which leads us nicely to...
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The relationship between the type constructors and the handlers
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is the signature for the `cataGift` function. You can see that each case
    handler function (`fBook`, `fBox`, etc.) has the same pattern: an input which
    contains all the data for that case, and a common output type `''r`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Another way to think about this is that: everywhere that there is a `Gift`
    type in the constructor, it has been replaced with an `''r`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The `Gift.Book` constructor takes a `Book` and returns a `Gift`. The `fBook`
    handler takes a `Book` and returns an `'r`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Gift.Wrapped` constructor takes a `Gift * WrappingPaperStyle` and returns
    a `Gift`. The `fWrapped` handler takes an `'r * WrappingPaperStyle` as input and
    returns an `'r`.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is that relationship expressed through type signatures:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里通过类型签名表达了这种关系：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: and so on for all of the rest.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，其他的都是一样的。
- en: Benefits of catamorphisms
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范畴折叠的好处
- en: There is a lot of theory behind catamorphisms, but what are the benefits in
    practice?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多关于范畴折叠的理论，但实践中有什么好处呢？
- en: Why bother to create a special function like `cataGift`? Why not just leave
    the original functions alone?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要创建像`cataGift`这样的特殊函数？为什么不只是保留原始函数？
- en: 'There are number of reasons, including:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 包括以下原因：
- en: '**Reuse**. Later, we will be creating quite complex catamorphisms. It''s nice
    if you only have to get the logic right once.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重用**。稍后，我们将创建相当复杂的范畴折叠。如果你只需一次正确地处理逻辑就好了。'
- en: '**Encapsulation**. By exposing functions only, you hide the internal structure
    of the data type.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**。通过仅暴露函数，你隐藏了数据类型的内部结构。'
- en: '**Flexibility**. Functions are more flexible than pattern matching -- they
    can be composed, partially applied, etc.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**。函数比模式匹配更灵活 -- 它们可以组合，部分应用等。'
- en: '**Mapping**. With a catamorphism in hand you can easily create functions that
    map the various cases to new structures.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**。有了范畴折叠，你可以轻松地创建将各种情况映射到新结构的函数。'
- en: It's true that most of these benefits apply to non-recursive types as well,
    but recursive types tend to be more complex so the benefits of encapsulation,
    flexibility, etc. are correspondingly stronger.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数这些好处也适用于非递归类型，但递归类型往往更复杂，因此封装、灵活性等好处相应更强。
- en: In the following sections, we'll look at the last three points in more detail.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更详细地看一下最后三点。
- en: Using function parameters to hide internal structure
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用函数参数隐藏内部结构
- en: The first benefit is that a catamorphism abstracts out the internal design.
    By using functions, the client code is somewhat isolated from the internal structure.
    Again, you can think of the Visitor pattern as analogous in the OO world.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个好处是范畴折叠将内部设计抽象出来。通过使用函数，客户端代码与内部结构有些隔离。同样，你可以将访问者模式视为面向对象世界中的类比。
- en: For example, if all the clients used the catamorphism function rather than pattern
    matching, I could safely rename cases, and even, with a bit of care, add or remove
    cases.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果所有客户端都使用范畴折叠函数而不是模式匹配，我可以安全地重命名情况，甚至在小心的情况下添加或删除情况。
- en: 'Here''s an example. Let''s say that I had a earlier design for `Gift` that
    didn''t have the `WithACard` case. I''ll call it version 1:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子。假设我之前为`Gift`设计了一个没有`WithACard`情况的版本。我将其称为版本1：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And say that we built and published a catamorphism function for that structure:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们构建并发布了针对该结构的范畴折叠函数：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that this has only *four* function parameters.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这只有*四*个函数参数。
- en: 'Now suppose that version 2 of `Gift` comes along, which adds the `WithACard`
    case:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设`Gift`的第2个版本出现，添加了`WithACard`情况：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: and now there are five cases.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有五种情况。
- en: Often, when we add a new case, we *want* to break all the clients and force
    them to deal with the new case.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，当我们添加一个新情况时，*希望*打破所有客户端，强迫他们处理新情况。
- en: 'But sometimes, we don''t. And so we can stay compatible with the original `cataGift`
    by handling the extra case silently, like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时候，我们不这样做。因此，我们可以通过默默处理额外情况来保持与原始`cataGift`的兼容性，就像这样：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function still has only four function parameters -- there is no special
    behavior for the `WithACard` case.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数仍然只有四个函数参数 -- 对于`WithACard`情况没有特殊行为。
- en: There are a number of alternative ways of being compatible, such as returning
    a default value. The important point is that the clients are not aware of the
    change.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他兼容的替代方法，比如返回一个默认值。重要的是客户端不知道这个变化。
- en: '**Aside: Using active patterns to hide data**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**另外：使用活动模式隐藏数据**'
- en: While we're on the topic of hiding the structure of a type, I should mention
    that you can also use active patterns to do this.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到隐藏类型结构时，我应该提到你也可以使用活动模式来做到这一点。
- en: For example, we could create a active pattern for the first four cases, and
    ignore the `WithACard` case.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以为前四种情况创建一个活动模式，并忽略`WithACard`情况。
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The clients can pattern match on the four cases without knowing that the new
    case even exists:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可以在不知道新情况存在的情况下对这四种情况进行模式匹配：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Case-handling functions vs. pattern matching
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理情况的函数 vs. 模式匹配
- en: Catamorphisms use function parameters, and as noted above, functions are more
    flexible than pattern matching due to tools such composition, partial application,
    etc.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Catamorphisms使用函数参数，正如上面所述，函数比模式匹配更灵活，因为可以使用组合、部分应用等工具。
- en: Here's an example where all the "container" cases are ignored, and only the
    "content" cases are handled.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，其中所有“容器”情况都被忽略，只处理“内容”情况。
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And here it is in use, with the two remaining cases handled "inline" using
    piping:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的使用方式，剩下的两种情况使用管道“内联”处理：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Of course this could be done with pattern matching, but being able to work with
    the existing `cataGift` function directly makes life easier.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这也可以通过模式匹配来完成，但直接使用现有的`cataGift`函数可以让生活更轻松。
- en: Using catamorphisms for mapping
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用catamorphisms进行映射
- en: I said above that a catamorphism is a function that "collapses" a recursive
    type into a new value. For example, in `totalCost`, the recursive gift structure
    was collapsed into a single cost value.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过，catamorphism是一个将递归类型“折叠”为新值的函数。例如，在`totalCost`中，递归的礼物结构被折叠成一个单一的成本值。
- en: But a "single value" can be more than just a primitive -- it can be a complicated
    structure too, such as a another recursive structure.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但是“单一值”不仅仅是一个原始值 -- 它也可以是一个复杂的结构，比如另一个递归结构。
- en: In fact, catamorphisms are great for mapping one kind of structure onto another,
    especially if they are very similar.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，catamorphisms非常适合将一种结构映射到另一种结构，特别是它们非常相似的情况。
- en: For example, let's say that I have a chocolate-loving room-mate who will stealthily
    remove and devour any chocolate in a gift, leaving the wrapping untouched, but
    discarding the box and gift card.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我有一个喜欢巧克力的室友，他会偷偷拿走并吃掉礼物中的任何巧克力，留下包装不动，但丢弃盒子和礼品卡。
- en: 'What''s left at the end is a "gift minus chocolate" that we can model as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后剩下的是一个“减去巧克力的礼物”，我们可以这样建模：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can easily map from a `Gift` to a `GiftMinusChocolate`, because the cases
    are almost parallel.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地从`礼物`映射到`减去巧克力的礼物`，因为这些情况几乎是平行的。
- en: A `Book` is passed through untouched.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`书`被保持不变地传递。
- en: '`Chocolate` is eaten and replaced with an `Apology`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 巧克力被吃掉，然后用一个`道歉`替换。
- en: The `Wrapped` case is passed through untouched.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`包装`情况被保持不变地传递。'
- en: The `Box` and `WithACard` cases are ignored.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`盒子`和`带卡片`的情况被忽略。'
- en: 'Here''s the code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: And if we test...
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们测试...
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Deep copying
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深度复制
- en: One more thing. Remember that each case-handling function takes the data associated
    with that case? That means that we can just use *the original case constructors*
    as the functions!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事。记住每个情况处理函数都带有与该情况相关联的数据吗？这意味着我们可以直接使用*原始情况构造函数*作为函数！
- en: 'To see what I mean, let''s define a function called `deepCopy` that clones
    the original value. Each case handler is just the corresponding case constructor:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解我的意思，让我们定义一个名为`deepCopy`的函数，它克隆原始值。每个情况处理程序只是相应的情况构造函数：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can simplify this further by removing the redundant parameters for each
    handler:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过删除每个处理程序的冗余参数进一步简化这个过程：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can test that this works yourself:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己测试这个是否有效：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So that leads to another way of thinking about a catamorphism:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了另一种思考catamorphism的方式：
- en: A catamorphism is a function for a recursive type such that when you pass in
    the type's case constructors, you get a "clone" function.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Catamorphism是适用于递归类型的函数，当您传入类型的情况构造函数时，您会得到一个“克隆”函数。
- en: Mapping and transforming in one pass
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在一次遍历中进行映射和转换
- en: A slight variant on `deepCopy` allows us to recurse through an object and change
    bits of it as we do so.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对`deepCopy`进行轻微变体，允许我们递归遍历对象并在此过程中更改其中的位。
- en: For example, let's say I don't like milk chocolate. Well, I can write a function
    that upgrades the gift to better quality chocolate and leaves all the other cases
    alone.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我不喜欢牛奶巧克力。好吧，我可以编写一个函数，将礼物升级为更好质量的巧克力，同时保持所有其他情况不变。
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And here it is in use:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用的示例：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you are thinking that this is beginning to smell like a `map`, you'd be right.
    We'll look at generic maps in the [sixth post, as part of a discussion of generic
    recursive types](recursive-types-and-folds-3b.html#map).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这开始有点像`map`，那么你是对的。我们将在[第六篇文章中看到通用映射，作为对通用递归类型讨论的一部分](recursive-types-and-folds-3b.html#map)。
- en: Rules for creating catamorphisms
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建catamorphisms的规则
- en: 'We saw above that creating a catamorphism is a mechanical process:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到创建catamorphism是一个机械过程：
- en: Create a function parameter to handle each case in the structure.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个函数参数来处理结构中的每种情况。
- en: For non-recursive cases, pass the function parameter all the data associated
    with that case.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For recursive cases, perform two steps:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, call the catamorphism recursively on the nested value.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then pass the handler all the data associated with that case, but with the result
    of the catamorphism replacing the original nested value.
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now see if we can apply these rules to create catamorphisms in other domains.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen in this post how to define a recursive type, and been introduced
    to catamorphisms.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: In the [next post](recursive-types-and-folds-1b.html) we'll uses these rules
    to create catamorphisms for some other domains.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: See you then!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this post is available at [this gist](https://gist.github.com/swlaschin/60938b4417d12cfa0a97).*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Catamorphism examples
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Catamorphism examples
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This post is the second in a series.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: In the [previous post](recursive-types-and-folds1.html), I introduced "catamorphisms",
    a way of creating functions for recursive types, and listed some rules which can
    be used to implement them mechanically. In this post, we'll use these rules to
    implement catamorphisms for some other domains.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the contents of this series:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: Catamorphism examples**'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Introducing folds**'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Understanding folds**'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: Generic recursive types**'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Trees in the real world**'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Rules for creating catamorphisms
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw in the previous post that creating a catamorphism is a mechanical process,
    and the rules were:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Create a function parameter to handle each case in the structure.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For non-recursive cases, pass the function parameter all the data associated
    with that case.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For recursive cases, perform two steps:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, call the catamorphism recursively on the nested value.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then pass the handler all the data associated with that case, but with the result
    of the catamorphism replacing the original nested value.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now see if we can apply these rules to create catamorphisms in other domains.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Catamorphism example: File system domain'
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with a very crude model of a file system:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Each file has a name and a size.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each directory has a name and a size and a list of subitems.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s how I might model that:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I admit it's a pretty bad model, but it's just good enough for this example!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, here are some sample files and directories:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Time to create the catamorphism!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at the signatures to figure out what we need.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The `File` constructor takes a `File` and returns a `FileSystemItem`. Using
    the guidelines above, the handler for the `File` case needs to have the signature
    `File -> 'r`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'That''s simple enough. Let''s put together an initial skeleton of `cataFS`,
    as I''ll call it:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `Directory` case is more complicated. If we naively applied the guidelines
    above, the handler for the `Directory` case would have the signature `Directory
    -> 'r`, but that would be incorrect, because the `Directory` record itself contains
    a `FileSystemItem` that needs to be replaced with an `'r` too. How can we do this?
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: One way is to "explode" the `Directory` record into a tuple of `(string,int,FileSystemItem
    list)`, and then replace the `FileSystemItem` with `'r` in there too.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, we have this sequence of transformations:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Another issue is that the data associated with the Directory case is a *list*
    of `FileSystemItem`s. How can we convert that into a list of `'r`s?
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Well, the `recurse` helper turns a `FileSystemItem` into an `'r`, so we can
    just use `List.map` passing in `recurse` as the mapping function, and that will
    give us the list of `'r`s we need!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting it all together, we get this implementation:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'and if we look at the type signature, we can see that it is just what we want:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: So we're done. It's a bit complicated to set up, but once built, we have a nice
    reusable function that can be the basis for many others.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'File system domain: `totalSize` example'
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alrighty then, let's use it in practice.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we can easily define a `totalSize` function that returns the
    total size of an item and all its subitems:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And here are the results:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'File system domain: `largestFile` example'
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How about a more complicated function, such as "what is the largest file in
    the tree?"
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Before we start this one, let's think about what it should return. That is,
    what is the `'r`?
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: You might think that it's just a `File`. But what if the subdirectory is empty
    and there *are* no files?
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: So let's make `'r` a `File option` instead.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'The function for the `File` case should return `Some file` then:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The function for the `Directory` case needs more thought:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: If list of subfiles is empty, then return `None`
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If list of subfiles is non-empty, then return the largest one
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: But remember that `'r` is not a `File` but a `File option`. So that means that
    `subfiles` is not a list of files, but a list of `File option`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Now, how can we find the largest one of these? We probably want to use `List.maxBy`
    and pass in the size. But what is the size of a `File option`?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a helper function to provide the size of a `File option`, using
    this logic:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: If the `File option` is `None`, return 0
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Else return the size of the file inside the option
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Putting it all together then, we have our `largestFile` function:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If we test it, we get the results we expect:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Again, a little bit tricky to set up, but no more than if we had to write it
    from scratch without using a catamorphism at all.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Catamorphism example: Product domain'
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s work with a slightly more complicated domain. This time, imagine that
    we make and sell products of some kind:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Some products are bought, with an optional vendor.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some products are made on our premises, built from subcomponents, where a subcomponent
    is some quantity of another product.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the domain modelled as types:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that the types are mutally recursive. `Product` references `MadeProduct`
    which references `Component` which in turn references `Product` again.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some example products:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now to design the catamorphism, we need to do is replace the `Product` type
    with `'r` in all the constructors.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with the previous example, the `Bought` case is easy:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `Made` case is trickier. We need to expand the `MadeProduct` into a tuple.
    But that tuple contains a `Component`, so we need to expand that as well. Finally
    we get to the inner `Product`, and we can then mechanically replace that with
    `'r`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the sequence of transformations:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是转换的顺序：
- en: '[PRE54]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When implementing the `cataProduct` function we need to the same kind of mapping
    as before, turning a list of `Component` into a list of `(int,'r)`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`cataProduct`函数时，我们需要与之前相同类型的映射，将`Component`的列表转换为`(int,'r)`的列表。
- en: 'We''ll need a helper for that:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个辅助函数：
- en: '[PRE55]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can see that this uses the `recurse` function to turn the inner product
    (`comp.product`) into an `'r` and then make a tuple `int * 'r`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里使用`recurse`函数将内部产品（`comp.product`）转换为`'r`，然后制作一个元组`int * 'r`。
- en: 'With `convertComponentToTuple` available, we can convert all the components
    to tuples using `List.map`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`convertComponentToTuple`可用，我们可以使用`List.map`将所有组件转换为元组：
- en: '[PRE56]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`componentTuples` is a list of `(int * ''r)`, which is just what we need for
    the `fMade` function.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentTuples`是一个`(int * ''r)`的列表，这正是我们需要的`fMade`函数。'
- en: 'The complete implementation of `cataProduct` looks like this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`cataProduct`的完整实现如下：'
- en: '[PRE57]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Product domain: `productWeight` example'
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 产品领域：`productWeight`示例
- en: We can now use `cataProduct` to calculate the weight, say.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`cataProduct`来计算权重，比如说。
- en: '[PRE58]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s test it interactively to make sure it works:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行交互式测试以确保它能正常工作：
- en: '[PRE59]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: That's as we expect.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这正如我们所期望的。
- en: Try implementing `productWeight` from scratch, without using a helper function
    like `cataProduct`. Again, it's do-able, but you'll probably waste quite bit of
    time getting the recursion logic right.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从头开始实现`productWeight`，而不使用像`cataProduct`这样的辅助函数。再次强调，这是可行的，但你可能会浪费相当多的时间来理清递归逻辑。
- en: 'Product domain: `mostUsedVendor` example'
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 产品领域：`mostUsedVendor`示例
- en: Let's do a more complex function now. What is the most used vendor?
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们做一个更复杂的函数。谁是最常用的供应商？
- en: 'The logic is simple: each time a product references a vendor, we''ll give that
    vendor one point, and the vendor with the highest score wins.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑很简单：每当一个产品引用一个供应商，我们就给该供应商一个点，得分最高的供应商获胜。
- en: Again, let's think about what it should return. That is, what is the `'r`?
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们考虑它应该返回什么。也就是说，`'r`是什么？
- en: You might think that it's just a score of some kind, but we also need to know
    the vendor name. Ok, a tuple then. But what if there are no vendors?
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这只是某种得分，但我们还需要知道供应商的名称。好的，那就是一个元组。但如果没有供应商呢？
- en: So let's make `'r` a `VendorScore option`, where we are going to create a little
    type `VendorScore`, rather than using a tuple.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 因此让我们将`'r`设为`VendorScore option`，我们将创建一个小类型`VendorScore`，而不���使用元组。
- en: '[PRE60]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We''ll also define some helpers to get data from a `VendorScore` easily:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义一些辅助函数，以便轻松从`VendorScore`中获取数据：
- en: '[PRE61]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now, you can't determine the most used vendor over until you have results from
    the entire tree, so both the `Bought` case and the `Made` case need to return
    a list which can added to as we recurse up the tree. And then, after getting *all*
    the scores, we'll sort descending to find the vendor with the highest one.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在获得整个树的结果之前，你无法确定最常用的供应商，因此`Bought`情况和`Made`情况都需要返回一个列表，当我们递归遍历树时可以添加到其中。然后，在获取*所有*分数之后，我们将按降序排序以找到得分最高的供应商。
- en: So we have to make `'r` a `VendorScore list`, not just an option!
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们必须将`'r`变为`VendorScore list`，而不仅仅是一个选项！
- en: 'The logic for the `Bought` case is then:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bought`情况的逻辑是：'
- en: If the vendor is present, return a `VendorScore` with score = 1, but as a one-element
    list rather than as a single item.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果供应商存在，则返回一个得分为1的`VendorScore`，但作为一个元素列表而不是单个项目。
- en: If the vendor is missing, return an empty list.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果供应商缺失，则返回一个空列表。
- en: '[PRE62]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The function for the `Made` case is more complicated.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`Made`情况的函数更复杂。'
- en: If list of subscores is empty, then return an empty list.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果子分数列表为空，则返回一个空列表。
- en: If list of subscores is non-empty, we sum them by vendor and then return the
    new list.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果子分数列表非空，则按供应商对它们求和，然后返回新列表。
- en: But the list of subresults passed into the `fMade` function will not be a list
    of subscores, it will be a list of tuples, `qty * 'r` where `'r` is `VendorScore
    list`. Complicated!
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 但传递给`fMade`函数的子结果列表将不是子分数列表，而是一个元组列表，`qty * 'r`其中`'r`是`VendorScore list`。复杂！
- en: 'What we need to do then is:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们需要做的是：
- en: Turn `qty * 'r` into just `'r` because we don't care about the qty in this case.
    We now have a list of `VendorScore list`. We can use `List.map snd` to do this.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`qty * 'r`转换为`'r`，因为在这种情况下我们不关心数量。现在我们有一个`VendorScore list`的列表。我们可以使用`List.map
    snd`来做这个。
- en: But now we would have a list of `VendorScore list`. We can flatten a list of
    lists into a simple list using `List.collect`. And in fact, using `List.collect
    snd` can do both steps in one go.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group this list by vendor so that we have a list of `key=vendor; values=VendorScore
    list` tuples.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sum up the scores for each vendor (`values=VendorScore list`) into a single
    value, so that we have a list of `key=vendor; values=VendorScore` tuples.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point the `cata` function will return a `VendorScore list`. To get the
    highest score, use `List.sortByDescending` then `List.tryHead`. Note that `maxBy`
    won't work because the list could be empty.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the complete `mostUsedVendor` function:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now let''s test it:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This isn't the only possible implementation of `fMade`, of course. I could have
    used `List.fold` and done the whole thing in one pass, but this version seems
    like the most obvious and readable implementation.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: It's also true that I could have avoided using `cataProduct` altogether and
    written `mostUsedVendor` from scratch. If performance is an issue, then that might
    be a better approach, because the generic catamorphism creates intermediate values
    (such as the list of `qty * VendorScore option`) which are over general and potentially
    wasteful.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: On other hand, by using the catamorphism, I could focus on the counting logic
    only and ignore the recursion logic.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: So as always, you should consider the pros and cons of reuse vs. creating from
    scratch; the benefits of writing common code once and using it in a standardized
    way, versus the performance but extra effort (and potential bugginess) of custom
    code.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen in this post how to define a recursive type, and been introduced
    to catamorphisms.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'And we have also seen some uses for catamorphisms:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Any function that "collapses" a recursive type, such as `Gift -> 'r`, can be
    written in terms of the catamorphism for that type.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catamorphisms can be used to hide the internal structure of the type.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catamorphisms can be used to create mappings from one type to another by tweaking
    the functions that handle each case.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catamorphisms can be used to create a clone of the original value by passing
    in the type's case constructors.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But all is not perfect in the land of catamorphisms. In fact, all the catamorphism
    implementations on this page have a potentially serious flaw.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: In the [next post](recursive-types-and-folds-2.html) we'll see what can go wrong
    with them, how to fix them, and in the process look at the various kinds of "fold".
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: See you then!
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this post is available at [this gist](https://gist.github.com/swlaschin/dc2b3fcdca319ca8be60).*'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '*UPDATE: Fixed logic error in `mostUsedVendor` as pointed out by Paul Schnapp
    in comments. Thanks, Paul!*'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Folds
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing Folds
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This post is the third in a series.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: In the [first post](recursive-types-and-folds1.html), I introduced "catamorphisms",
    a way of creating functions for recursive types, and in the [second post](recursive-types-and-folds-1b.html),
    we created a few catamorphism implementations.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: But at the end of the previous post, I noted that all the catamorphism implementations
    so far have had a potentially serious flaw.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we'll look at the flaw and how to work around it, and in the process
    look at folds, tail-recursion and the difference between "left fold" and "right
    fold".
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the contents of this series:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: Catamorphism examples**'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Introducing folds**'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Understanding folds**'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: Generic recursive types**'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Trees in the real world**'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: A flaw in our catamorphism implementation
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we look at the flaw, let's first review the recursive type `Gift` and
    the associated catamorphism `cataGift` that we created for it.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the domain:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Here are some example values that we''ll be using in this post:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here''s the catamorphism:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'and here is a `totalCostUsingCata` function built using `cataGift`:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: What's the flaw?
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So what is wrong with this implementation? Let's stress test it and find out!
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: What we'll do is create a `Box` inside a `Box` inside a `Box` a very large number
    of times, and see what happens.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a little helper function to create nested boxes:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let''s try it to make sure it works:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now try running `totalCostUsingCata` with these deeply nested boxes:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: So far so good.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we use much larger numbers, we soon run into a stack overflow exception:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The exact number which causes an error depends on the environment, available
    memory, and so on. But it is a certainty that you will run into it when you start
    using largish numbers.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Why is this happening?
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: The problem with deep recursion
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall that the definition of the cost for the Boxed case (`fBox`) was `innerCost
    + 1.0m`. And what is the inner cost? That''s another box too, so we end up with
    a chain of calculations looking like this:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In other words, `innerCost1000` has to be calculated before `innerCost999` can
    be calculated, and 999 other inner costs have to be calculated before the top
    level `innerCost` can be calculated.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Every level is waiting for its inner cost to be calculated before doing the
    calculation for that level.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: All these unfinished calculations are stacked up waiting for the inner one to
    complete. And when you have too many? Boom! Stack overflow!
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: The solution to stack overflows
  id: totrans-493
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The solution to this problem is simple. Rather than each level waiting for the
    inner cost to be calculated, each level calculates the cost so far, using an accumulator,
    and passes that down to the next inner level. When we get to the bottom level,
    we have the final answer.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The big advantange of this approach is that all calculations at a particular
    level are *completely finished* before the next lowel level is called. Which means
    that the level and its associated data can be safely discarded from the stack.
    Which means no stack overflow!
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: An implementation like this, where the higher levels can be safely discarded,
    is called *tail recursive*.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementating the `totalCost` function with an accumulator
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s rewrite the total cost function from scratch, using an accumulator called
    `costSoFar`:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'A few things to note:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: The new version of the function has an extra parameter (`costSoFar`). We will
    have to provide an initial value for this (such as zero) when we call it at the
    top level.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The non-recursive cases (`Book` and `Chocolate`) are the end points. The take
    the cost so far and add it to their price, and then that is the final result.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recursive cases calculate a new `costSoFar` based on the parameter that
    is passed in. The new `costSoFar` is then passed down to the next lower level,
    just as in the example above.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s stress test this version:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Excellent. Up to one million nested levels without a hiccup.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: Introducing "fold"
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's apply the same design principle to the catamorphism implementation.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a new function `foldGift`. We'll introduce an accumulator `acc`
    that we will thread through each level, and the non-recursive cases will return
    the final accumulator.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: If we look at the type signature, we can see that it is subtly different. The
    type of the accumulator `'a` is being used everywhere now. The only time where
    the final return type is used is in the two non-recursive cases (`fBook` and `fChocolate`).
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Let's look at this more closely, and compare the signatures of the original
    catamorphism from the last post with the signatures of the new `fold` function.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, the non-recursive cases:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As you can see, with "fold", the non-recursive cases take an extra parameter
    (the accumulator) and return the `'r` type.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very important point: *the type of the accumulator does not need
    to be the same as the return type.* We will need to take advantage of this shortly.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: What about the recursive cases? How did their signature change?
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: For the recursive cases, the structure is identical but all use of the `'r`
    type has been replaced with the `'a` type. The recursive cases do not use the
    `'r` type at all.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementating the `totalCost` function using fold
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once again, we can reimplement the total cost function, but this time using
    the `foldGift` function:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'And again, we can process very large numbers of nested boxes without a stack
    overflow:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Problems with fold
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So using fold solves all our problems, right?
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, no.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Yes, there are no more stack overflows, but we have another problem now.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementation of the `description` function
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see what the problem is, let's revisit the `description` function that we
    created in the first post.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: The original one was not tail-recursive, so let's make it safer and reimplement
    it using `foldGift`.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Let''s see what the output is:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: These outputs are wrong! The order of the decorations has been mixed up.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: It's supposed to be a wrapped book with a card, not a book and a card wrapped
    together. And it's supposed to be chocolate in a box, then wrapped, not wrapped
    chocolate in a box!
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: What has gone wrong?
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that the correct description for each layer depends on the description
    of the layer below. We can't "pre-calculate" the description for a layer and pass
    it down to the next layer using a `descriptionSoFar` accumulator.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: 'But now we have a dilemma: a layer depends on information from the layer below,
    but we want to avoid a stack overflow.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: Using functions as accumulators
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that the accumulator type does not have to be the same as the return
    type. We can use anything as an accumulator, even a function!
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: So what we'll do is, rather than passing a `descriptionSoFar` as the accumulator,
    we'll pass a function (`descriptionGenerator` say) that will build the appropriate
    description given the value of the next layer down.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the implementation for the non-recursive cases:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The implementation for recursive cases is a bit more complicated:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: We are given an accumulator (`descriptionGenerator`) as a parameter.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to create a new accumulator (a new `descriptionGenerator`) to pass down
    to the next lower layer.
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *input* to the description generator will be all the data accumulated from
    the lower layers. We manipulate that to make a new description and then call the
    `descriptionGenerator` passed in from the higher layer.
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s more complicated to talk about than to demonstrate, so here are implementations
    for two of the cases:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We can simplify that code a little by using a lambda directly:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We could continue to make it more compact using piping and other things, but
    I think that what we have here is a good balance between conciseness and obscurity.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the entire function:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Again, I'm using overly descriptive intermediate values to make it clear what
    is going on.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try `descriptionUsingFoldWithGenerator` now, we get the correct answers
    again:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Introducing "foldback"
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we understand what to do, let''s make a generic version that that
    handles the generator function logic for us. This one we will call "foldback":'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '*By the way, I''m going to use term "generator" here. In other places, it is
    commonly referred to as a "continuation" function, often abbreviated to just "k".*'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the implementation:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: You can see that it is just like the `descriptionUsingFoldWithGenerator` implementation,
    except that we are using generic `newInnerVal` and `generator` values.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: The type signatures are similar to the original catamorphism, except that every
    case works with `'a` only now. The only time `'r` is used is in the generator
    function itself!
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '*The `foldback` implementation above is written from scratch. If you want a
    fun exercise, see if you can write `foldback` in terms of `fold`.*'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the `description` function using `foldback`:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'And the results are still correct:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Comparing `foldback` to the original catamorphism
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implementation of `descriptionUsingFoldBack` is almost identical to the
    version in the last post that used the original catamorphism `cataGift`.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the version using `cataGift`:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'And here''s the version using `foldbackGift`:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: All the handler functions are basically identical. The only change is the addition
    of an initial generator function, which is just `id` in this case.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: However, although the code looks the same in both cases, they differ in their
    recursion safety. The `foldbackGift` version is still tail recursive, and can
    handle very large nesting depths, unlike the `cataGift` version.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: But this implementation is not perfect either. The chain of nested functions
    can get very slow and generate a lot of garbage, and for this particular example,
    there is an even faster way, which we'll look at in the next post.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: Changing the type signature of `foldback` to avoid a mixup
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In `foldGift` the signature for `fWrapped` is:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'But in `foldbackGift` the signature for `fWrapped` is:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Can you spot the difference? No, me neither.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: The two functions are very similar, yet work very differently. In the `foldGift`
    version, the first parameter is the accumulator from the *outer* levels, while
    in `foldbackGift` version, the first parameter is the accumulator from the *inner*
    levels. Quite an important distinction!
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: It is therefore common to change the signature of the `foldBack` version so
    that the accumulator always comes *last*, while in the normal `fold` function,
    the accumulator always comes *first*.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This change shows up in the type signature. The `Gift` value comes before the
    accumulator now:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: and now we *can* tell the two versions apart easily.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Rules for creating a fold
  id: totrans-597
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To finish up this post, let's summarize the rules for creating a fold.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first post we saw that creating a catamorphism is a mechanical process
    that [follows rules](recursive-types-and-folds1.html#rules). The same is true
    for creating a iterative top-down fold. The process is:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: Create a function parameter to handle each case in the structure.
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an additional parameter as an accumulator.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For non-recursive cases, pass the function parameter the accumulator plus all
    the data associated with that case.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For recursive cases, perform two steps:'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, pass the handler the accumulator plus all the data associated with that
    case (except the inner recursive data). The result is a new accumulator value.
  id: totrans-604
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, call the fold recursively on the nested value using the new accumulator
    value.
  id: totrans-605
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that each handler only "sees" (a) the data for that case, and (b) the accumulator
    passed to it from the outer level. It does not have access to the results from
    the inner levels.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen in this post how to define a tail-recursive implementation of a catamorphism,
    called "fold" and the reverse version "foldback".
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: In the [next post](recursive-types-and-folds-2b.html) we'll step back a bit
    and spend some time understanding what "fold" really means, and at some guidelines
    for choosing between `fold`, `foldback` and `cata`.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: We'll then see if we can apply these rules to another domain.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this post is available at [this gist](https://gist.github.com/swlaschin/df4427d0043d7146e592).*'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Folds
  id: totrans-613
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Folds
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This post is the fourth in a series.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: In the [previous post](recursive-types-and-folds1.html), I introduced "folds",
    a way of creating top-down iterative functions for recursive types.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we'll spend some time understanding folds in more detail.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  id: totrans-618
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the contents of this series:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  id: totrans-621
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  id: totrans-622
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  id: totrans-623
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  id: totrans-624
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  id: totrans-625
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: Catamorphism examples**'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  id: totrans-627
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  id: totrans-628
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Introducing folds**'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  id: totrans-630
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  id: totrans-631
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  id: totrans-632
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  id: totrans-633
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  id: totrans-634
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  id: totrans-635
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Understanding folds**'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  id: totrans-637
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  id: totrans-638
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  id: totrans-639
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: Generic recursive types**'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  id: totrans-641
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  id: totrans-642
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  id: totrans-643
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  id: totrans-644
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  id: totrans-645
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Trees in the real world**'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  id: totrans-647
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  id: totrans-648
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  id: totrans-649
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  id: totrans-650
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  id: totrans-651
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  id: totrans-652
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  id: totrans-653
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  id: totrans-654
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  id: totrans-655
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: Iteration vs. recursion
  id: totrans-657
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have *three* different functions -- `cata`, `fold` and `foldback`.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: So what exactly are the differences between them? We've seen that something
    that doesn't work with `fold` will work with `foldBack`, but is there an easy
    way to remember the difference?
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to differentiate the three approaches is by remembering this:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '`fold` is top-down *iteration*'
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cata` is bottom-up *recursion*'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foldBack` is bottom-up *iteration*'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does this mean?
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: Well, for in `fold`, the accumulator was initialized at the top level, and was
    passed down to each lower level until the lowest and last level was reached.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: 'In code terms, each level did this:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: In an imperative language, this is exactly a "for loop" with a mutable variable
    storing the accumulator.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: So, this kind of top-to-bottom folding can be thought of as iteration (and in
    fact, the F# compiler will turn a tail-recursive function like this into an iteration
    behind the scenes).
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, in `cata`, the accumulator started at the bottom level, and
    was passed up to each higher level until the top level was reached.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: 'In code terms, each level did this:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This is exactly a recursive loop:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Finally, `foldback` can be thought of as "reverse iteration". The accumulator
    is threaded through all the levels, but starting at the bottom rather than at
    the top. It has the benefits of `cata` in that the inner values are calculated
    first and passed back up, but because it is iterative, there cannot be a stack
    overflow.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the concepts we have discussed so far become clear when expressed in
    terms of iteration vs. recursion. For example:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: The iterative versions (`fold` and `foldback`) have no stack, and cannot cause
    a stack overflow.
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "total cost" function needed no inner data, and so the top-down iterative
    version (`fold`) worked without problems.
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "description" function though, needed inner text for correct formatting,
    and so the recursive version (`cata`) or bottom up iteration (`foldback`) was
    more suitable.
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fold example: File system domain'
  id: totrans-681
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last post, we described some rules for creating folds. Let's see if we
    can apply these rules to create a fold in another domain, the "File System" domain
    from the [second post in the series](recursive-types-and-folds-1b.html#file-system).
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, here is the crude "file system" domain from that post:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Note that each directory contains a *list* of subitems, so this is not a linear
    structure like `Gift`, but a tree-like structure. Out implementation of fold will
    have to take this into account.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some sample values:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'We want to create a fold, `foldFS`, say. So, following the rules, let''s add
    an extra accumulator parameter `acc` and pass it to the `File` case:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The `Directory` case is trickier. We are not supposed to know about the subitems,
    so that means that the only data we can use is the `name`, `dirSize`, and the
    accumulator passed in from a higher level. These are combined to make a new accumulator.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '*NOTE: I''m keeping the `name` and `dirSize` as a tuple for grouping purposes,
    but of course you could pass them in as separate parameters.*'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to pass this new accumulator down to each subitem in turn, but
    each subitem will return a new accumulator of its own, so we need to use the following
    approach:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: Take the newly created accumulator and pass it to the first subitem.
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take the output of that (another accumulator) and pass it to the second subitem.
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take the output of that (another accumulator) and pass it to the third subitem.
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And so on. The output of the last subitem is the final result.
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That approach is already available to us though. It''s exactly what `List.fold`
    does! So here''s the code for the Directory case:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'And here''s the entire `foldFS` function:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: With this in place, we can rewrite the same two functions we implemented in
    the last post.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `totalSize` function, which just sums up all the sizes:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'And if we test it we get the same results as before:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'File system domain: `largestFile` example'
  id: totrans-707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also reimplement the "what is the largest file in the tree?" function.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: As before it will return a `File option`, because the tree might be empty. This
    means that the accumulator will be a `File option` too.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: 'This time it is the `File` case handler which is tricky:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: If the accumulator being passed in is `None`, then this current file becomes
    the new accumulator.
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the accumulator being passed in is `Some file`, then compare the size of
    that file with this file. Whichever is bigger becomes the new accumulator.
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: On the other hand, the `Directory` handler is trivial -- just pass the "largest
    so far" accumulator down to the next level
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Here''s the complete implementation:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'And if we test it we get the same results as before:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: It is interesting to compare this implementation with the [recursive version
    in the second post](recursive-types-and-folds-1b.html#file-system). I think that
    this one is easier to implement, myself.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: Tree traversal types
  id: totrans-722
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The various fold functions discussed so far correspond to various kinds of
    tree traversals:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: A `fold` function (as implemented here) is more properly called a "pre-order
    depth-first" tree traversal.
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `foldback` function would be a "post-order depth-first" tree traversal.
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `cata` function would not be a "traversal" at all, because each internal node
    deals with a list of all the subresults at once.
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By tweaking the logic, you can make other variants.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: For a description of the various kinds of tree traversals, see [Wikipedia](https://en.wikipedia.org/wiki/Tree_traversal).
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: Do we need `foldback`?
  id: totrans-729
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do we need to implement a `foldback` function for the FileSystem domain?
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: I don't think so. If we need access to the inner data, we can just use the original
    "naive" catamorphism implementation in the previous post.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: But, hey wait, didn't I say at the beginning that we had to watch out for stack
    overflows?
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, if the recursive type is deeply nested. But consider a file system with
    only two subdirectories per directory. How many directories would there be if
    there were 64 nested levels? (Hint: you may be familiar with a similar problem.
    Something to do with [grains on a chessboard](https://en.wikipedia.org/wiki/Wheat_and_chessboard_problem)).'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: We saw earlier that the stack overflow issue only occurs with more than 1000
    nested levels, and that level of nesting generally only occurs with *linear* recursive
    types, not trees like the FileSystem domain.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: Common questions about "fold"
  id: totrans-735
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point you might be getting overwhelmed! All these different implementations
    with different advantages and disadvantages.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: So let's take a short break and address some common questions.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: What's the difference between "left fold" and "right fold"
  id: totrans-738
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is often quite a lot of confusion around the terminology of folds: "left"
    vs. "right", "forward" vs. "backwards", etc.'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: A *left fold* or *forward fold* is what I have just called `fold` -- the top-down
    iterative approach.
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *right fold* or *backward fold* is what I have called `foldBack` -- the bottom-up
    iterative approach.
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These terms, though, really only apply to linear recursive structures like
    `Gift`. When it comes to more complex tree-like structures, these distinctions
    are too simple, because there are many ways to traverse them: breadth-first, depth-first,
    pre-order and post-order, and so on.'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: Which type of fold function should I use?
  id: totrans-743
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some guidelines:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: If your recursive type is not going to be too deeply nested (less than 100 levels
    deep, say), then the naive `cata` catamorphism we described in the first post
    is fine. It's really easy to implement mechanically -- just replace the main recursive
    type with `'r`.
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your recursive type is going to be deeply nested and you want to prevent
    stack overflows, use the iterative `fold`.
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using an iterative fold but you need to have access to the inner
    data, pass a continuation function as an accumulator.
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the iterative approach is generally faster and uses less memory than
    the recursive approach (but that advantage is lost if you pass around too many
    nested continuations).
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another way to think about it is to look at your "combiner" function. At each
    step, you are combining data from the different levels:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'If your combiner function is "left associative" like this:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'then use the iterative approach, but if your combiner function is "right associative"
    like this:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: then use the `cata` or `foldback` approach.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: And if your combiner function doesn't care (like addition, for example), use
    whichever one is more convenient.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: How can I know whether code is tail-recursive or not?
  id: totrans-757
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's not always obvious whether an implementation is tail-recursive or not.
    The easiest way to be sure is to look at the very last expression for each case.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: If the call to "recurse" is the very last expression, then it is tail-recursive.
    If there is any other work after that, then it is not tail-recursive.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: See for yourself with the three implementations that we have discussed.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here''s the code for the `WithACard` case in the original `cataGift`
    implementation:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The `cataGift` implementation is *not* tail-recursive.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code from the `foldGift` implementation:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The `foldGift` implementation *is* tail-recursive.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: 'And here''s the code from the `foldbackGift` implementation:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The `foldbackGift` implementation is also tail-recursive.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: How do I short-circuit a fold?
  id: totrans-770
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a language like C#, you can exit a iterative loop early using `break` like
    this:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: So how do you do the same thing with a fold?
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: The short answer is, you can't! A fold is designed to visit all elements in
    turn. The Visitor Pattern has the same constraint.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: There are three workarounds.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is to not use `fold` at all and create your own recursive function
    that terminates on the required condition:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the loop exits when the sum is larger than 100:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The second approach is to use `fold` but to add some kind of "ignore" flag to
    the accumulator that is passed around. Once this flag is set, the remaining iterations
    do nothing.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of calculating the sum, but the accumulator is actually
    a tuple with an `ignoreFlag` in addition to the `sumSoFar`:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The third version is a variant of the second -- create a special value to signal
    that the remaining data should be ignored, but wrap it in a computation expression
    so that it looks more natural.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is documented on [Tomas Petricek''s blog](http://tomasp.net/blog/imperative-ii-break.aspx/)
    and the code looks like this:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '* * *'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-786
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of this post was to help you understand folds better, and to show how
    they could be applied to a tree structure like the file system. I hope it was
    helpful!
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point in the series all the examples have been very concrete; we
    have implemented custom folds for each domain we have encountered. Can we be a
    bit more generic and build some reusable fold implementations?
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: In the [next post](recursive-types-and-folds-3.html) we'll look at generic recursive
    types, and how to work with them.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this post is available at [this gist](https://gist.github.com/swlaschin/e065b0e99dd68cd35846).*'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: Generic recursive types
  id: totrans-791
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generic recursive types
  id: totrans-792
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This post is the fifth in a series.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: In the [previous post](recursive-types-and-folds-2b.html), we spent some time
    understanding folds for specific domain types.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we'll broaden our horizons and look at how to use generic recursive
    types.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  id: totrans-796
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the contents of this series:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  id: totrans-799
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  id: totrans-800
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  id: totrans-801
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  id: totrans-802
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  id: totrans-803
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: Catamorphism examples**'
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  id: totrans-805
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  id: totrans-806
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Introducing folds**'
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  id: totrans-808
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  id: totrans-809
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  id: totrans-810
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  id: totrans-811
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  id: totrans-812
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  id: totrans-813
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Understanding folds**'
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  id: totrans-815
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  id: totrans-816
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  id: totrans-817
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: Generic recursive types**'
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  id: totrans-819
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  id: totrans-820
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  id: totrans-821
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  id: totrans-822
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  id: totrans-823
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Trees in the real world**'
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  id: totrans-825
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  id: totrans-826
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  id: totrans-827
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  id: totrans-828
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  id: totrans-829
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  id: totrans-830
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  id: totrans-831
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  id: totrans-832
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  id: totrans-833
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: 'LinkedList: A generic recursive type'
  id: totrans-835
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a question: if you only have algebraic types, and you can only combine
    them as products ([tuples](tuples.html), [records](records.html)) or sums ([discriminated
    unions](discriminated-unions.html)), then how can you make a list type just by
    using these operations?'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: The answer is, of course, recursion!
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the most basic recursive type: the list.'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: I'm going to call my version `LinkedList`, but it is basically the same as the
    `list` type in F#.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: So, how do you define a list in a recursive way?
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, it''s either empty, or it consists of an element plus another list. In
    other words we can define it as a choice type ("discriminated union") like this:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The `Empty` case represents an empty list. The `Cons` case has a tuple: the
    head element, and the tail, which is another list.'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then define a particular `LinkedList` value like this:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Using the native F# list type, the equivalent definition would be:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: which is just `[1; 2; 3]`
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: '`cata` for LinkedList'
  id: totrans-849
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Following the rules in the [first post in this series](recursive-types-and-folds1.html#rules),
    we can mechanically create a `cata` function by replacing `Empty` and `Cons` with
    `fEmpty` and `fCons`:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '*Note: We will be putting all the functions associated with `LinkedList<''a>`
    in a module called `LinkedList`. One nice thing about using generic types is that
    the type name does not clash with a similar module name!*'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: As always, the signatures of the case handling functions are parallel to the
    signatures of the type constructors, with `LinkedList` replaced by `'r`.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '`fold` for LinkedList'
  id: totrans-855
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also create a top-down iterative `fold` function using the rules in the
    [earlier post](recursive-types-and-folds-2.html#rules).
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'This `foldWithEmpty` function is not quite the same as the standard `List.fold`
    function, because it has an extra function parameter for the empty case (`fEmpty`).
    However, if we eliminate that parameter and just return the accumulator we get
    this variant:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'If we compare the signature with the [List.fold documentation](https://msdn.microsoft.com/en-us/library/ee353894.aspx)
    we can see that they are equivalent, with `''State` replaced by `''r` and `''T
    list` replaced by `LinkedList<''a>`:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Let''s test that `fold` works by doing a small sum:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '`foldBack` for LinkedList'
  id: totrans-864
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally we can create a `foldBack` function, using the "function accumulator"
    approach described in the previous post:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Again, if we compare the signature with the [List.foldBack documentation](https://msdn.microsoft.com/en-us/library/ee353846.aspx),
    they are also equivalent, with `''State` replaced by `''r` and `''T list` replaced
    by `LinkedList<''a>`:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Using `foldBack` to convert between list types
  id: totrans-869
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the [first post](recursive-types-and-folds1.html#benefits) we noted that
    catamorphisms could be used for converting between types of similar structure.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: Let's demonstrate that now by creating some functions that convert from `LinkedList`
    to the native `list` type and back again.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert a `LinkedList` to a native `list` all we need to do is replace `Cons`
    with `::` and `Empty` with `[]`:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'To convert the other way, we need to replace `::` with `Cons` and `[]` with
    `Empty`:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Simple! Let''s test `toList`:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'and `ofList`:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Both work as expected.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: Using `foldBack` to implement other functions
  id: totrans-881
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I said earlier that a catamorphism function (for linear lists, `foldBack`) is
    the most basic function available for a recursive type, and in fact is the *only*
    function you need!
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: Let's see for ourselves by implementing some other common functions using `foldBack`.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s `map` defined in terms of `foldBack`:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'And here''s a test:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Here''s `filter` defined in terms of `foldBack`:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'And here''s a test:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Finally, here''s `rev` defined in terms of `fold`:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'And here''s a test:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: So, I hope you're convinced!
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding generator functions
  id: totrans-897
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I mentioned earlier that there was an alternative and (sometimes) more efficient
    way to implement `foldBack` without using generators or continuations.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, `foldBack` is reverse iteration, which means that it is the
    same as `fold` applied to a reversed list!
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: 'So we could implement it like this:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: It involves making an extra copy of the list, but on the other hand there is
    no longer a large set of pending continuations. It might be worth comparing the
    profile of the two versions in your environment if performance is an issue.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: Making the Gift domain generic
  id: totrans-903
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the rest of this post, we'll look at the `Gift` type and see if we can make
    it more generic.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, here is the original design:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Three of the cases are recursive and two are non-recursive.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: Now, the focus of this particular design was on modelling the domain, which
    is why there are so many separate cases.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: But if we want to focus on *reusability* instead of domain modelling, then we
    should simplify the design to the essentials, and all these special cases now
    become a hindrance.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this ready for reuse, then, let''s collapse all the non-recursive cases
    into one case, say `GiftContents`, and all the recursive cases into another case,
    say `GiftDecoration`, like this:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'The main `Gift` type has only two cases now: the non-recursive one and the
    recursive one.'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: Defining a generic Container type
  id: totrans-913
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the type is simplified, we can "genericize" it by allowing *any* kind
    of contents *and* any kind of decoration.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'And as before, we can mechanically create a `cata` and `fold` and `foldBack`
    for it, using the standard process:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Converting the gift domain to use the Container type
  id: totrans-918
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s convert the gift type to this generic Container type:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Now we need some helper methods to construct values while hiding the "real"
    cases of the generic type:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Finally we can create some test values:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The `totalCost` function using the Container type
  id: totrans-925
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The "total cost" function can be written using `fold`, since it doesn't need
    any inner data.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the earlier implementations, we only have two function parameters, `fContents`
    and `fDecoration`, so each of these will need some pattern matching to get at
    the "real" data.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'And the code works as expected:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: The `description` function using the Container type
  id: totrans-932
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The "description" function needs to be written using `foldBack`, since it *does*
    need the inner data. As with the code above, we need some pattern matching to
    get at the "real" data for each case.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'And again the code works as we want:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: A third way to implement the gift domain
  id: totrans-937
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That all looks quite nice, doesn't it?
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: But I have to confess that I have been holding something back.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: None of that code above was strictly necessary, because it turns out that there
    is yet *another* way to model a `Gift`, without creating any new generic types
    at all!
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Gift` type is basically a linear sequence of decorations, with some content
    as the final step. We can just model this as a pair -- a `Content` and a list
    of `Decoration`. Or to make it a little friendlier, a record with two fields:
    one for the content and one for the decorations.'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: That's it! No other new types needed!
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: Building values using the record type
  id: totrans-944
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As before, let''s create some helpers to construct values using this type:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: With these helper functions, the way the values are constructed is *identical*
    to the previous version. This is why it is good to hide your raw constructors,
    folks!
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: The `totalCost` function using the record type
  id: totrans-949
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `totalCost` function is even easier to write now.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: The `description` function using the record type
  id: totrans-952
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similarly, the `description` function is also easy to write.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Abstract or concrete? Comparing the three designs
  id: totrans-955
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are confused by this plethora of designs, I don't blame you!
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: 'But as it happens, the three different definitions are actually interchangable:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: '**The original version**'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '**The generic container version**'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '**The record version**'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: If this is not obvious, it might be helpful to read my post on [data type sizes](type-size-and-design.html).
    It explains how two types can be "equivalent", even though they appear to be completely
    different at first glance.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: Picking a design
  id: totrans-965
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So which design is best? The answer is, as always, "it depends".
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: For modelling and documenting a domain, I like the first design with the five
    explicit cases. Being easy for other people to understand is more important to
    me than introducing abstraction for the sake of reusability.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: If I wanted a reusable model that was applicable in many situations, I'd probably
    choose the second ("Container") design. It seems to me that this type does represent
    a commonly encountered situation, where the contents are one kind of thing and
    the wrappers are another kind of thing. This abstraction is therefore likely to
    get some use.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: The final "pair" model is fine, but by separating the two components, we've
    over-abstracted the design for this scenario. In other situations, this design
    might be a great fit (e.g. the decorator pattern), but not here, in my opinion.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: There is one further choice which gives you the best of all worlds.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: As I noted above, all the designs are logically equivalent, which means there
    are "lossless" mappings between them. In that case, your "public" design can be
    the domain-oriented one, like the first one, but behind the scenes you can map
    it to a more efficient and reusable "private" type.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: Even the F# list implementation itself does this. For example, some of the functions
    in the `List` module, such `foldBack` and `sort`, convert the list into an array,
    do the operations, and then convert it back to a list again.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-974
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post we looked at some ways of modelling the `Gift` as a generic type,
    and the pros and cons of each approach.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: In the [next post](recursive-types-and-folds-3b.html) we'll look at real-world
    examples of using a generic recursive type.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this post is available at [this gist](https://gist.github.com/swlaschin/c423a0f78b22496a0aff).*'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: Trees in the real world
  id: totrans-978
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Trees in the real world
  id: totrans-979
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This post is the sixth in a series.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: In the [previous post](recursive-types-and-folds-3.html), we briefly looked
    at some generic types.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we'll do some deeper dives into some real-world examples of using
    trees and folds.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  id: totrans-983
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the contents of this series:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  id: totrans-985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  id: totrans-986
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  id: totrans-987
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  id: totrans-988
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  id: totrans-989
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  id: totrans-990
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: Catamorphism examples**'
  id: totrans-991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  id: totrans-992
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  id: totrans-993
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Introducing folds**'
  id: totrans-994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  id: totrans-995
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  id: totrans-996
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  id: totrans-997
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  id: totrans-998
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  id: totrans-999
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  id: totrans-1000
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Understanding folds**'
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  id: totrans-1002
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  id: totrans-1003
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  id: totrans-1004
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: Generic recursive types**'
  id: totrans-1005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  id: totrans-1006
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  id: totrans-1007
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  id: totrans-1008
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  id: totrans-1009
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  id: totrans-1010
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Trees in the real world**'
  id: totrans-1011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  id: totrans-1012
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  id: totrans-1013
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  id: totrans-1014
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  id: totrans-1015
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  id: totrans-1016
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  id: totrans-1017
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  id: totrans-1018
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  id: totrans-1019
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  id: totrans-1020
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: Defining a generic Tree type
  id: totrans-1022
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post, we'll be working with a generic `Tree` inspired by the `FileSystem`
    domain that we explored earlier.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: 'Here was the original design:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'We can separate out the data from the recursion, and create a generic `Tree`
    type like this:'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Notice that I have used `seq` to represent the subitems rather than `list`.
    The reason for this will become apparent shortly.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: 'The file system domain can then be modelled using `Tree` by specifying `FileInfo`
    as data associated with a leaf node and `DirectoryInfo` as data associated with
    an internal node:'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '`cata` and `fold` for Tree'
  id: totrans-1031
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can define `cata` and `fold` in the usual way:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Note that I am *not* going to implement `foldBack` for the `Tree` type, because
    it's unlikely that the tree will get so deep as to cause a stack overflow. Functions
    that need inner data can use `cata`.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: Modelling the File System domain with Tree
  id: totrans-1035
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s test it with the same values that we used before:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'The `totalSize` function is almost identical to the one in the previous post:'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'And so is the `largestFile` function:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: The source code for this section is available at [this gist](https://gist.github.com/swlaschin/1ef784481bae91b63a36).
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: The Tree type in the real world
  id: totrans-1043
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the `Tree` to model the *real* file system too! To do this, just
    set the leaf node type to `System.IO.FileInfo` and the internal node type to `System.IO.DirectoryInfo`.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'And let''s create some helper methods to create the various nodes:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Now you can see why I used `seq` rather than `list` for the subitems. The `seq`
    is lazy, which means that we can create nodes without actually hitting the disk.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `totalSize` function again, this time using the real file information:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Let''s see what the size of the current directory is:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Similarly, we can get the largest file:'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: So that's one big benefit of using generic recursive types. If we can turn a
    real-world hierarchy into our tree structure, we can get all the benefits of fold
    "for free".
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: Mapping with generic types
  id: totrans-1056
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One other advantage of using generic types is that you can do things like `map`
    -- converting every element to a new type without changing the structure.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: We can see this in action with the real world file system. But first we need
    to define `map` for the `Tree` type!
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of `map` can also be done mechanically, using the following
    rules:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: Create a function parameter to handle each case in the structure.
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For non-recursive cases
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, use the function parameter to transform the non-recursive data associated
    with that case
  id: totrans-1062
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then wrap the result in the same case constructor
  id: totrans-1063
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For recursive cases, perform two steps:'
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, use the function parameter to transform the non-recursive data associated
    with that case
  id: totrans-1065
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, recursively `map` the nested values.
  id: totrans-1066
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, wrap the results in the same case constructor
  id: totrans-1067
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the implementation of `map` for `Tree`, created by following those
    rules:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: If we look at the signature of `Tree.map`, we can see that all the leaf data
    is transformed to type `'a`, all the node data is transformed to type `'b`, and
    the final result is a `Tree<'a,'b>`.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'We can define `Tree.iter` in a similar way:'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-1073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '* * *'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Creating a directory listing'
  id: totrans-1075
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say we want to use `map` to transform the file system into a directory
    listing - a tree of strings where each string has information about the corresponding
    file or directory. Here''s how we could do it:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'And then we can print the strings out like this:'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'The results will look something like this:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/77fadc19acb8cc850276).*'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Creating a parallel grep'
  id: totrans-1084
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at a more complex example. I'll demonstrate how to create a parallel
    "grep" style search using `fold`.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic will be like this:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: Use `fold` to iterate through the files.
  id: totrans-1087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each file, if its name doesn't match the desired file pattern, return `None`.
  id: totrans-1088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the file is to be processed, then return an async that returns all the line
    matches in the file.
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, all these asyncs -- the output of the fold -- are aggregated into a sequence.
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sequence of asyncs is transformed into a single one using `Async.Parallel`
    which returns a list of results.
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start writing the main code, we'll need some helper functions.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: First, a generic function that folds over the lines in a file asynchronously.
    This will be the basis of the pattern matching.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Next, a little helper that allows us to `map` over `Async` values:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Now for the central logic. We will create a function that, given a `textPattern`
    and a `FileInfo`, will return a list of lines that match the textPattern, but
    asynchronously:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'And now for the `grep` function itself:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Let's test it!
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'The result will look something like this:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: That's not bad for about 40 lines of code. This conciseness is because we are
    using various kinds of `fold` and `map` which hide the recursion, allowing us
    to focus on the pattern matching logic itself.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is not at all efficient or optimized (an async for every line!),
    and so I wouldn't use it as a real implementation, but it does give you an idea
    of the power of fold.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/137c322b5a46b97cc8be).*'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Storing the file system in a database'
  id: totrans-1109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the next example, let's look at how to store a file system tree in a database.
    I don't really know why you would want to do that, but the principles would work
    equally well for storing any hierarchical structure, so I will demonstrate it
    anyway!
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: 'To model the file system hierarchy in the database, say that we have four tables:'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: '`DbDir` stores information about each directory.'
  id: totrans-1112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DbFile` stores information about each file.'
  id: totrans-1113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DbDir_File` stores the relationship between a directory and a file.'
  id: totrans-1114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DbDir_Dir` stores the relationship between a parent directory and a child
    directory.'
  id: totrans-1115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the database table definitions:'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: That's simple enough. But note that in order to save a directory completely
    along with its relationships to its child items, we first need the ids of all
    its children, and each child directory needs the ids of its children, and so on.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: This implies that we should use `cata` instead of `fold`, so that we have access
    to the data from the lower levels of the hierarchy.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the database functions
  id: totrans-1120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''re not wise enough to be using the [SQL Provider](https://fsprojects.github.io/SQLProvider/)
    and so we have written our own table insertion functions, like this dummy one:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'In a real database, the identity column would be automatically generated for
    you, but for this example, I''ll use a little helper function `nextIdentity`:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Now in order to insert a directory, we need to first know all the ids of the
    files in the directory. This implies that the `insertDbFile` function should return
    the id that was generated.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'But that logic applies to the directories too:'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: But that's still not good enough. When the child ids are passed to the parent
    directory, it needs to distinguish between files and directories, because the
    relations are stored in different tables.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: No problem -- we'll just use a choice type to distinguish between them!
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'With this in place, we can complete the implementation of the database functions:'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Working with the catamorphism
  id: totrans-1134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted above, we need to use `cata` instead of `fold`, because we need the
    inner ids at each step.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: The function to handle the `File` case is easy -- just insert it and return
    the `PrimaryKey`.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: The function to handle the `Directory` case will be passed the `DirectoryInfo`
    and a sequence of `PrimaryKey`s from the children that have already been inserted.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: 'It should insert the main directory record, then insert the children, and then
    return the `PrimaryKey` for the next higher level:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: After inserting the directory record and getting its id, for each child id,
    we insert either into the `DbDir_File` table or the `DbDir_Dir`, depending on
    the type of the `childId`.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Note that I've also created a little helper function `pkToInt` that extracts
    the integer id from the `PrimaryKey` type.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is all the code in one chunk:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Now let''s test it:'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'The output should look something like this:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: You can see that the ids are being generated as the files are iterated over,
    and that each `DbFile` insert is followed by a `DbDir_File` insert.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/3a416f26d873faa84cde).*'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Serializing a Tree to JSON'
  id: totrans-1153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at another common challenge: serializing and deserializing a tree
    to JSON, XML, or some other format.'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the Gift domain again, but this time, we'll model the `Gift` type
    as a tree. That means we get to put more than one thing in a box!
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: Modelling the Gift domain as a tree
  id: totrans-1156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the main types again, but notice that the final `Gift` type is defined
    as a tree:'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-1158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'As usual, we can create some helper functions to assist with constructing a
    `Gift`:'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'And we can create some sample data:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Functions like `description` now need to handle a *list* of inner texts, rather
    than one. We''ll just concat the strings together with an `&` separator:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Finally, we can check that the function still works as before, and that multiple
    items are handled correctly:'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-1166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'Step 1: Defining `GiftDto`'
  id: totrans-1167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our `Gift` type consists of many discriminated unions. In my experience, these
    do not serialize well. In fact, most complex types do not serialize well!
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: 'So what I like to do is define [DTO](https://en.wikipedia.org/wiki/Data_transfer_object)
    types that are explicitly designed to be serialized well. In practice this means
    that the DTO types are constrained as follows:'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: Only record types should be used.
  id: totrans-1170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The record fields should consist only primitive values such as `int`, `string`
    and `bool`.
  id: totrans-1171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By doing this, we also get some other advantages:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: '**We gain control of the serialization output.** These kinds of data types
    are handled the same by most serializers, while "strange" things such as unions
    can be interpreted differently by different libraries.'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: '**We have better control of error handling.** My number one rule when dealing
    with serialized data is "trust no one". It''s very common that the data is structured
    correctly but is invalid for the domain: supposedly non-null strings are null,
    strings are too long, integers are outside the correct bounds, and so on.'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: By using DTOs, we can be sure that the deserialization step itself will work.
    Then, when we convert the DTO to a domain type, we can do proper validation.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s define some DTO types for out domain. Each DTO type will correspond
    to a domain type, so let''s start with `GiftContents`. We''ll define a corresponding
    DTO type called `GiftContentsDto` as follows:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'Obviously, this quite different from the original `GiftContents`, so let''s
    look at the differences:'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: First, it has the `CLIMutableAttribute`, which allows deserializers to construct
    them using reflection.
  id: totrans-1179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, it has a `discriminator` which indicates which case of the original
    union type is being used. Obviously, this string could be set to anything, so
    when converting from the DTO back to the domain type, we'll have to check that
    carefully!
  id: totrans-1180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is a series of fields, one for every possible item of data that needs to
    be stored. For example, in the `Book` case, we need a `bookTitle`, while in the
    `Chocolate` case, we need the chocolate type. And finally the `price` field which
    is in both types. Note that the chocolate type is stored as a string as well,
    and so will also need special treatment when we convert from DTO to domain.
  id: totrans-1181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GiftDecorationDto` type is created in the same way, with a discriminator
    and strings rather than unions.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Finally, we can define a `GiftDto` type as being a tree that is composed of
    the two DTO types:'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'Step 2: Transforming a `Gift` to a `GiftDto`'
  id: totrans-1186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have this DTO type, all we need to do is use `Tree.map` to convert
    from a `Gift` to a `GiftDto`. And in order to do that, we need to create two functions:
    one that converts from `GiftContents` to `GiftContentsDto` and one that converts
    from `GiftDecoration` to `GiftDecorationDto`.'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the complete code for `giftToDto`, which should be self-explanatory:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: You can see that the case (`Book`, `Chocolate`, etc.) is turned into a `discriminator`
    string and the `chocolateType` is also turned into a string, just as explained
    above.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Defining a `TreeDto`'
  id: totrans-1191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I said above that a good DTO should be a record type. Well we have converted
    the nodes of the tree, but the tree *itself* is a union type! We need to transform
    the `Tree` type as well, into say a `TreeDto` type.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: How can we do this? Just as for the gift DTO types, we will create a record
    type which contains all the data for both cases. We could use a discriminator
    field as we did before, but this time, since there are only two choices, leaf
    and internal node, I'll just check whether the values are null or not when deserializing.
    If the leaf value is not null, then the record must represent the `LeafNode` case,
    otherwise the record must represent the `InternalNode` case.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the definition of the data type:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: As before, the type has the `CLIMutableAttribute`. And as before, the type has
    fields to store the data from all possible choices. The `subtrees` are stored
    as an array rather than a seq -- this makes the serializer happy!
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: To create a `TreeDto`, we use our old friend `cata` to assemble the record from
    a regular `Tree`.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Note that in F#, records are not nullable, so I am using `Unchecked.defaultof<'NodeData>`
    rather than `null` to indicate missing data.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: Note also that I am assuming that `LeafData` or `NodeData` are reference types.
    If `LeafData` or `NodeData` are ever value types like `int` or `bool`, then this
    approach will break down, because you won't be able to tell the difference between
    a default value and a missing value. In which case, I'd switch to a discriminator
    field as before.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, I could have used an `IDictionary`. That would be less convenient
    to deserialize, but would avoid the need for null-checking.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Serializing a `TreeDto`'
  id: totrans-1202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally we can serialize the `TreeDto` using a JSON serializer.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: For this example, I am using the built-in `DataContractJsonSerializer` so that
    I don't need to take a dependency on a NuGet package. There are other JSON serializers
    that might be better for a serious project.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-1205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'Step 5: Assembling the pipeline'
  id: totrans-1206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, putting it all together, we have the following pipeline:'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: Transform `Gift` to `GiftDto` using `giftToDto`,
  id: totrans-1208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: that is, use `Tree.map` to go from `Tree<GiftContents,GiftDecoration>` to `Tree<GiftContentsDto,GiftDecorationDto>`
  id: totrans-1209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Transform `Tree` to `TreeDto` using `treeToDto`,
  id: totrans-1210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: that is, use `Tree.cata` to go from `Tree<GiftContentsDto,GiftDecorationDto>`
    to `TreeDto<GiftContentsDto,GiftDecorationDto>`
  id: totrans-1211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serialize `TreeDto` to a JSON string
  id: totrans-1212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s some example code:'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'And here is what the JSON output looks like:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: The ugly `@` signs on the field names are an artifact of serializing the F#
    record type. This can be corrected with a bit of effort, but I'm not going to
    bother right now!
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/bbe70c768215b209c06c)*'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Deserializing a Tree from JSON'
  id: totrans-1220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have created the JSON, what about going the other way and loading
    it into a `Gift`?
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple! We just need to reverse the pipeline:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: Deserialize a JSON string into a `TreeDto`.
  id: totrans-1223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform a `TreeDto` into a `Tree` to using `dtoToTree`,
  id: totrans-1224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: that is, go from `TreeDto<GiftContentsDto,GiftDecorationDto>` to `Tree<GiftContentsDto,GiftDecorationDto>`.
    We can't use `cata` for this -- we'll have to create a little recursive loop.
  id: totrans-1225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Transform `GiftDto` to `Gift` using `dtoToGift`,
  id: totrans-1226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: that is, use `Tree.map` to go from `Tree<GiftContentsDto,GiftDecorationDto>`
    to `Tree<GiftContents,GiftDecoration>`.
  id: totrans-1227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Step 1: Deserializing a `TreeDto`'
  id: totrans-1228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can deserialize the `TreeDto` using a JSON serializer.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: What if the deserialization fails? For now, we will ignore any error handling
    and let the exception propagate.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Transforming a `TreeDto` into a `Tree`'
  id: totrans-1232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To transform a `TreeDto` into a `Tree` we recursively loop through the record
    and its subtrees, turning each one into a `InternalNode` or a `LeafNode`, based
    on whether the appropriate field is null or not.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-1234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'As you can see, a number of things could go wrong:'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: What if the `leafData` and `nodeData` fields are both null?
  id: totrans-1236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if the `nodeData` field is not null but the `subtrees` field *is* null?
  id: totrans-1237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, we will ignore any error handling and just throw exceptions (for now).
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: '*Question: Could we create a `cata` for `TreeDto` that would make this code
    simpler? Would it be worth it?*'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Transforming a `GiftDto` into `Gift`'
  id: totrans-1240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we have a proper tree, we can use `Tree.map` again to convert each leaf
    and internal node from a DTO to the proper domain type.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: That means we need functions that map a `GiftContentsDto` into a `GiftContents`
    and a `GiftDecorationDto` into a `GiftDecoration`.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: Here's the complete code -- it's a lot more complicated than going in the other
    direction!
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: 'The code can be grouped as follows:'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: Helper methods (such as `strToChocolateType`) that convert a string into a proper
    domain type and throw an exception if the input is invalid.
  id: totrans-1245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case converter methods (such as `bookFromDto`) that convert an entire DTO into
    a case.
  id: totrans-1246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally, the `dtoToGift` function itself. It looks at the `discriminator`
    field to see which case converter to call, and throws an exception if the discriminator
    value is not recognized.
  id: totrans-1247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-1248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'Step 4: Assembling the pipeline'
  id: totrans-1249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can now assemble the pipeline that takes a JSON string and creates a `Gift`.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-1251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: This works fine, but the error handling is terrible!
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: 'Look what happens if we corrupt the JSON a little:'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-1254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: We get an ugly exception.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: Or what if a discriminator is wrong?
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: or one of the values for the WrappingPaperStyle DU?
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-1259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: We get lots of exceptions, and as as functional programmers, we should try to
    remove them whenever we can.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: How we can do that will be discussed in the next section.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/bbe70c768215b209c06c).*'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Deserializing a Tree from JSON - with error handling'
  id: totrans-1264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To address the error handling issue, we''re going use the `Result` type shown
    below:'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-1266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: I'm not going to explain how it works here. If you are not familar with this
    approach, please [read my post](recipe-part2.html) or [watch my talk](http://fsharpforfunandprofit.com/rop/)
    on the topic of functional error handling.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: Let's revisit all the steps from the previous section, and use `Result` rather
    than throwing exceptions.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Deserializing a `TreeDto`'
  id: totrans-1269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we deserialize the `TreeDto` using a JSON serializer we will trap exceptions
    and turn them into a `Result`.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-1271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: The signature of `fromJson` is now `string -> Result<'a>`.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Transforming a `TreeDto` into a `Tree`'
  id: totrans-1273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As before, we transform a `TreeDto` into a `Tree` by recursively looping through
    the record and its subtrees, turning each one into a `InternalNode` or a `LeafNode`.
    This time, though, we use `Result` to handle any errors.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-1275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'But uh-oh, we now have a `Tree` where every internal node and leaf is wrapped
    in a `Result`. It''s a tree of `Results`! The actual ugly signature is this: `Tree<Result<''Leaf>,Result<''Node>>`.'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: But this type is useless as it stands -- what we *really* want is to merge all
    the errors together and return a `Result` containing a `Tree`.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: How can we transform a Tree of Results into a Result of Tree?
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: The answer is to use a `sequence` function which "swaps" the two types. You
    can read much more about `sequence` in [my series on elevated worlds](elevated-world-4.html#sequence).
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: '*Note that we could also use the slightly more complicated `traverse` variant
    to combine the `map` and `sequence` into one step, but for the purposes of this
    demonstration, it''s easier to understand if the steps are kept separate.*'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create our own `sequence` function for the Tree/Result combination.
    Luckily the creation of a sequence function is a mechanical process:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: For the lower type (`Result`) we need to define `apply` and `return` functions.
    See [here for more details](elevated-world.html#apply) on what `apply` means.
  id: totrans-1282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the higher type (`Tree`) we need to have a `cata` function, which we do.
  id: totrans-1283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the catamorphism, each constructor of the higher type (`LeafNode` and `InternalNode`
    in this case) is replaced by an equivalent that is "lifted" to the `Result` type
    (e.g. `retn LeafNode <*> data`)
  id: totrans-1284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here is the actual code -- don't worry if you can't understand it immediately.
    Luckily, we only need to write it once for each combination of types, so for any
    kind of Tree/Result combination in the future, we're set!
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-1286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Finally, the actual `dtoToTree` function is simple -- just send the `treeDto`
    through `dtoToTreeOfResults` and then use `sequenceTreeOfResult` to convert the
    final result into a `Result<Tree<..>>`, which is just what we need.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-1288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'Step 3: Transforming a `GiftDto` into a `Gift`'
  id: totrans-1289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again we can use `Tree.map` to convert each leaf and internal node from a DTO
    to the proper domain type.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: But our functions will handle errors, so they need to map a `GiftContentsDto`
    into a `Result<GiftContents>` and a `GiftDecorationDto` into a `Result<GiftDecoration>`.
    This results in a Tree of Results again, and so we'll have to use `sequenceTreeOfResult`
    again to get it back into the correct `Result<Tree<..>>` shape.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the helper methods (such as `strToChocolateType`) that convert
    a string into a proper domain type. This time, they return a `Result` rather than
    throwing an exception.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-1293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: The case converter methods have to build a `Book` or `Chocolate` from parameters
    that are `Result`s rather than normal values. This is where lifting functions
    like `Result.lift2` can help. For details on how this works, see [this post on
    lifting](elevated-world.html#lift) and [this one on validation with applicatives](elevated-world-3.html#validation).
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-1295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: And finally, the `dtoToGift` function itself is changed to return a `Result`
    if the `discriminator` is invalid.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: As before, this mapping creates a Tree of Results, so we pipe the output of
    the `Tree.map` through `sequenceTreeOfResult` ...
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-1298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '... to return a Result of Tree.'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the complete code for `dtoToGift`:'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-1301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: The type signature of `dtoToGift` has changed -- it now returns a `Result<Gift>`
    rather than just a `Gift`.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'Step 4: Assembling the pipeline'
  id: totrans-1304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can now reassemble the pipeline that takes a JSON string and creates a `Gift`.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: 'But changes are needed to work with the new error handling code:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: The `fromJson` function returns a `Result<TreeDto>` but the next function in
    the pipeline (`dtoToTree`) expects a regular `TreeDto` as input.
  id: totrans-1307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly `dtoToTree` returns a `Result<Tree>` but the next function in the
    pipeline (`dtoToGift`) expects a regular `Tree` as input.
  id: totrans-1308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both case, `Result.bind` can be used to solve that problem of mis-matched
    output/input. See [here for a more detailed discussion of bind](elevated-world-2.html#bind).
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: Ok, let's try deserializing the `goodJson` string we created earlier.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-1311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: That's fine.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see if the error handling has improved now. We''ll corrupt the JSON
    again:'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-1314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: Great! We get an nice `Failure` case.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: Or what if a discriminator is wrong?
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-1317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: or one of the values for the WrappingPaperStyle DU?
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-1319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: Again, nice `Failure` cases.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: What's very nice (and this is something that the exception handling approach
    can't offer) is that if there is more than one error, the various errors can be
    aggregated so that we get a list of *all* the things that went wrong, rather than
    just one error at a time.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this in action by introducing two errors into the JSON string:'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-1323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: So overall, I'd say that's a success!
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/2b06fe266e3299a656c1).*'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-1327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen in this series how to define catamorphisms, folds, and in this post
    in particular, how to use them to solve real world problems. I hope these posts
    have been useful, and have provided you with some tips and insights that you can
    apply to your own code.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: This series turned out to be a lot longer that I intended, so thanks for making
    it to the end! Cheers!
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
