- en: The "Recursive types and folds" Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this series, we'll look at recursive types and how to use them, and on the
    way, we'll look at catamorphisms, tail recursion, the difference between left
    and right folds, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '[Introduction to recursive types](recursive-types-and-folds1.html). Don''t
    fear the catamorphism....'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism examples](recursive-types-and-folds-1b.html). Applying the rules
    to other domains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing Folds](recursive-types-and-folds-2.html). Threading state through
    a recursive data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Understanding Folds](recursive-types-and-folds-2b.html). Recursion vs. iteration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Generic recursive types](recursive-types-and-folds-3.html). Implementing a
    domain in three ways.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Trees in the real world](recursive-types-and-folds-3b.html). Examples using
    databases, JSON and error handling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to recursive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to recursive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this series, we'll look at recursive types and how to use them, and on the
    way, we'll look at catamorphisms, tail recursion, the difference between left
    and right folds, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the contents of this series:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: Catamorphism examples**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Introducing folds**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Understanding folds**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: Generic recursive types**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Trees in the real world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: A basic recursive type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with a simple example -- how to model a gift.
  prefs: []
  type: TYPE_NORMAL
- en: As it happens, I'm a very lazy gift-giver. I always give people a book or chocolates.
    I generally wrap them, and sometimes, if I'm feeling particularly extravagant,
    I put them in a gift box and add a card too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how I might model this in types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can see that three of the cases are "containers" that refer to another `Gift`.
    The `Wrapped` case has some paper and a inner gift, as does the `Boxed` case,
    as does the `WithACard` case. The two other cases, `Book` and `Chocolate`, do
    not refer to a gift and can be considered "leaf" nodes or terminals.
  prefs: []
  type: TYPE_NORMAL
- en: The presence of a reference to an inner `Gift` in those three cases makes `Gift`
    a *recursive type*. Note that, unlike functions, the `rec` keyword is *not* needed
    for defining recursive types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create some example values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Before we start working with these values, a word of advice...
  prefs: []
  type: TYPE_NORMAL
- en: 'Guideline: Avoid infinitely recursive types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I suggest that, in F#, every recursive type should consist of a mix of recursive
    and non-recursive cases. If there were no non-recursive elements, such as `Book`,
    all values of the type would have to be infinitely recursive.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the `ImpossibleGift` type below, all the cases are recursive.
    To construct any one of the cases you need an inner gift, and that needs to be
    constructed too, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to create such types if you allow [laziness](https://wiki.haskell.org/Tying_the_Knot),
    mutation, or reflection. But in general, in a non-lazy language like F#, it's
    a good idea to avoid such types.
  prefs: []
  type: TYPE_NORMAL
- en: Working with recursive types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: End of public service announcement -- let's get coding!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, say that we want a description of the gift. The logic will be:'
  prefs: []
  type: TYPE_NORMAL
- en: For the two non-recursive cases, return a string describing that case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the three recursive cases, return a string that describes the case, but
    also includes the description of the inner gift. This means that `description`
    function is going to refer to itself, and therefore it must be marked with the
    `rec` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the recursive calls like this one in the `Boxed` case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try this with our example values, let''s see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That looks pretty good to me. Things like `HappyHolidays` look a bit funny without
    spaces, but it's good enough to demonstrate the idea.
  prefs: []
  type: TYPE_NORMAL
- en: What about creating another function? For example, what is the total cost of
    a gift?
  prefs: []
  type: TYPE_NORMAL
- en: 'For `totalCost`, the logic will be:'
  prefs: []
  type: TYPE_NORMAL
- en: Books and chocolate capture the price in the case-specific data, so use that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping adds `0.5` to the cost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A box adds `1.0` to the cost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A card adds `2.0` to the cost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And here are the costs for the two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, people ask what is inside the box or wrapping paper. A `whatsInside`
    function is easy to implement -- just ignore the container cases and return something
    for the non-recursive cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So that's a good start -- three functions, all quite easy to write.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterize all the things
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: However, these three functions have some duplicate code. In addition to the
    unique application logic, each function is doing its own pattern matching and
    its own logic for recursively visiting the inner gift.
  prefs: []
  type: TYPE_NORMAL
- en: How can we separate the navigation logic from the application logic?
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: Parameterize all the things!'
  prefs: []
  type: TYPE_NORMAL
- en: As always, we can parameterize the application logic by passing in functions.
    In this case, we will need *five* functions, one for each case.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the new, parameterized version -- I'll explain why I have called it
    `cataGift` shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see this function is created using a purely mechanical process:'
  prefs: []
  type: TYPE_NORMAL
- en: Each function parameter (`fBook`, `fChocolate`, etc) corresponds to a case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the two non-recursive cases, the function parameter is passed all the data
    associated with that case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the three recursive cases, there are two steps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, the `cataGift` function is called recursively on the `innerGift` to get
    an `innerGiftResult`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then the appropriate handler is passed all the data associated with that case,
    but with `innerGiftResult` replacing `innerGift`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's rewrite total cost using the generic `cataGift` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Notes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `innerGiftResult` is now the total cost of the inner gift, so I have renamed
    it to `innerCost`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `totalCostUsingCata` function itself is not recursive, because it uses the
    `cataGift` function, and so no longer needs the `rec` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And this function gives the same result as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can rewrite the `description` function using `cataGift` in the same way,
    changing `innerGiftResult` to `innerText`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And the results are the same as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Introducing catamorphisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `cataGift` function we wrote above is called a "[catamorphism](https://en.wikipedia.org/wiki/Catamorphism)",
    from the Greek components "down + shape". In normal usage, a catamorphism is a
    function that "collapses" a recursive type into a new value based on its *structure*.
    In fact, you can think of a catamorphism as a sort of "visitor pattern".
  prefs: []
  type: TYPE_NORMAL
- en: A catamorphism is very powerful concept, because it is the most fundamental
    function that you can define for a structure like this. *Any other function* can
    be defined in terms of it.
  prefs: []
  type: TYPE_NORMAL
- en: That is, if we want to create a function with signature `Gift -> string` or
    `Gift -> int`, we can use a catamorphism to create it by specifying a function
    for each case in the `Gift` structure.
  prefs: []
  type: TYPE_NORMAL
- en: We saw above how we could rewrite `totalCost` as `totalCostUsingCata` using
    the catamorphism, and we'll see lots of other examples later.
  prefs: []
  type: TYPE_NORMAL
- en: Catamorphisms and folds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Catamorphisms are often called "folds", but there is more than one kind of fold,
    so I will tend to use "catamorphism" to refer the *concept* and "fold" to refer
    to a specific kind of implementation.
  prefs: []
  type: TYPE_NORMAL
- en: I will talk in detail about the various kinds of folds in a [subsequent post](recursive-types-and-folds-2.html),
    so for the rest of this post I will just use "catamorphism".
  prefs: []
  type: TYPE_NORMAL
- en: Tidying up the implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `cataGift` implementation above was deliberately long-winded so that you
    could see each step. Once you understand what is going on though, you can simplify
    it somewhat.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `cataGift fBook fChocolate fWrapped fBox fCard` crops up three times,
    once for each recursive case. Let''s assign it a name like `recurse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `recurse` function has the simple signature `Gift -> 'a` -- that is, it
    converts a `Gift` to the return type we need, and so we can use it to work with
    the various `innerGift` values.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing is to replace `innerGift` with just `gift` in the recursive
    cases -- this is called "shadowing". The benefit is that the "outer" `gift` is
    no longer visible to the case-handling code, and so we can't accidentally recurse
    into it, which would cause an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: Generally I avoid shadowing, but this is one case where it actually is a good
    practice, because it eliminates a particularly nasty kind of bug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the version after the clean up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: One more thing. I'm going to explicitly annotate the return type and call it
    `'r`. Later on in this series we'll be dealing with other generic types such as
    `'a` and `'b`, so it will be helpful to be consistent and always have a standard
    name for the return type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the final version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It's much simpler than the original implementation, and also demonstrates the
    symmetry between a case constructor like `Wrapped (gift,style)` and the corresponding
    handler `fWrapped (recurse gift,style)`. Which leads us nicely to...
  prefs: []
  type: TYPE_NORMAL
- en: The relationship between the type constructors and the handlers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is the signature for the `cataGift` function. You can see that each case
    handler function (`fBook`, `fBox`, etc.) has the same pattern: an input which
    contains all the data for that case, and a common output type `''r`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to think about this is that: everywhere that there is a `Gift`
    type in the constructor, it has been replaced with an `''r`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Gift.Book` constructor takes a `Book` and returns a `Gift`. The `fBook`
    handler takes a `Book` and returns an `'r`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Gift.Wrapped` constructor takes a `Gift * WrappingPaperStyle` and returns
    a `Gift`. The `fWrapped` handler takes an `'r * WrappingPaperStyle` as input and
    returns an `'r`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is that relationship expressed through type signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: and so on for all of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of catamorphisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a lot of theory behind catamorphisms, but what are the benefits in
    practice?
  prefs: []
  type: TYPE_NORMAL
- en: Why bother to create a special function like `cataGift`? Why not just leave
    the original functions alone?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are number of reasons, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reuse**. Later, we will be creating quite complex catamorphisms. It''s nice
    if you only have to get the logic right once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulation**. By exposing functions only, you hide the internal structure
    of the data type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**. Functions are more flexible than pattern matching -- they
    can be composed, partially applied, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping**. With a catamorphism in hand you can easily create functions that
    map the various cases to new structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's true that most of these benefits apply to non-recursive types as well,
    but recursive types tend to be more complex so the benefits of encapsulation,
    flexibility, etc. are correspondingly stronger.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we'll look at the last three points in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Using function parameters to hide internal structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first benefit is that a catamorphism abstracts out the internal design.
    By using functions, the client code is somewhat isolated from the internal structure.
    Again, you can think of the Visitor pattern as analogous in the OO world.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if all the clients used the catamorphism function rather than pattern
    matching, I could safely rename cases, and even, with a bit of care, add or remove
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example. Let''s say that I had a earlier design for `Gift` that
    didn''t have the `WithACard` case. I''ll call it version 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And say that we built and published a catamorphism function for that structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that this has only *four* function parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose that version 2 of `Gift` comes along, which adds the `WithACard`
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: and now there are five cases.
  prefs: []
  type: TYPE_NORMAL
- en: Often, when we add a new case, we *want* to break all the clients and force
    them to deal with the new case.
  prefs: []
  type: TYPE_NORMAL
- en: 'But sometimes, we don''t. And so we can stay compatible with the original `cataGift`
    by handling the extra case silently, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This function still has only four function parameters -- there is no special
    behavior for the `WithACard` case.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of alternative ways of being compatible, such as returning
    a default value. The important point is that the clients are not aware of the
    change.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aside: Using active patterns to hide data**'
  prefs: []
  type: TYPE_NORMAL
- en: While we're on the topic of hiding the structure of a type, I should mention
    that you can also use active patterns to do this.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we could create a active pattern for the first four cases, and
    ignore the `WithACard` case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The clients can pattern match on the four cases without knowing that the new
    case even exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Case-handling functions vs. pattern matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Catamorphisms use function parameters, and as noted above, functions are more
    flexible than pattern matching due to tools such composition, partial application,
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: Here's an example where all the "container" cases are ignored, and only the
    "content" cases are handled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And here it is in use, with the two remaining cases handled "inline" using
    piping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Of course this could be done with pattern matching, but being able to work with
    the existing `cataGift` function directly makes life easier.
  prefs: []
  type: TYPE_NORMAL
- en: Using catamorphisms for mapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I said above that a catamorphism is a function that "collapses" a recursive
    type into a new value. For example, in `totalCost`, the recursive gift structure
    was collapsed into a single cost value.
  prefs: []
  type: TYPE_NORMAL
- en: But a "single value" can be more than just a primitive -- it can be a complicated
    structure too, such as a another recursive structure.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, catamorphisms are great for mapping one kind of structure onto another,
    especially if they are very similar.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say that I have a chocolate-loving room-mate who will stealthily
    remove and devour any chocolate in a gift, leaving the wrapping untouched, but
    discarding the box and gift card.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s left at the end is a "gift minus chocolate" that we can model as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We can easily map from a `Gift` to a `GiftMinusChocolate`, because the cases
    are almost parallel.
  prefs: []
  type: TYPE_NORMAL
- en: A `Book` is passed through untouched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chocolate` is eaten and replaced with an `Apology`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Wrapped` case is passed through untouched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Box` and `WithACard` cases are ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: And if we test...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Deep copying
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One more thing. Remember that each case-handling function takes the data associated
    with that case? That means that we can just use *the original case constructors*
    as the functions!
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what I mean, let''s define a function called `deepCopy` that clones
    the original value. Each case handler is just the corresponding case constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simplify this further by removing the redundant parameters for each
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test that this works yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'So that leads to another way of thinking about a catamorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: A catamorphism is a function for a recursive type such that when you pass in
    the type's case constructors, you get a "clone" function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping and transforming in one pass
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A slight variant on `deepCopy` allows us to recurse through an object and change
    bits of it as we do so.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say I don't like milk chocolate. Well, I can write a function
    that upgrades the gift to better quality chocolate and leaves all the other cases
    alone.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And here it is in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If you are thinking that this is beginning to smell like a `map`, you'd be right.
    We'll look at generic maps in the [sixth post, as part of a discussion of generic
    recursive types](recursive-types-and-folds-3b.html#map).
  prefs: []
  type: TYPE_NORMAL
- en: Rules for creating catamorphisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw above that creating a catamorphism is a mechanical process:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function parameter to handle each case in the structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For non-recursive cases, pass the function parameter all the data associated
    with that case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For recursive cases, perform two steps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, call the catamorphism recursively on the nested value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then pass the handler all the data associated with that case, but with the result
    of the catamorphism replacing the original nested value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now see if we can apply these rules to create catamorphisms in other domains.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen in this post how to define a recursive type, and been introduced
    to catamorphisms.
  prefs: []
  type: TYPE_NORMAL
- en: In the [next post](recursive-types-and-folds-1b.html) we'll uses these rules
    to create catamorphisms for some other domains.
  prefs: []
  type: TYPE_NORMAL
- en: See you then!
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this post is available at [this gist](https://gist.github.com/swlaschin/60938b4417d12cfa0a97).*'
  prefs: []
  type: TYPE_NORMAL
- en: Catamorphism examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Catamorphism examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This post is the second in a series.
  prefs: []
  type: TYPE_NORMAL
- en: In the [previous post](recursive-types-and-folds1.html), I introduced "catamorphisms",
    a way of creating functions for recursive types, and listed some rules which can
    be used to implement them mechanically. In this post, we'll use these rules to
    implement catamorphisms for some other domains.
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the contents of this series:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: Catamorphism examples**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Introducing folds**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Understanding folds**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: Generic recursive types**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Trees in the real world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Rules for creating catamorphisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw in the previous post that creating a catamorphism is a mechanical process,
    and the rules were:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function parameter to handle each case in the structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For non-recursive cases, pass the function parameter all the data associated
    with that case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For recursive cases, perform two steps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, call the catamorphism recursively on the nested value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then pass the handler all the data associated with that case, but with the result
    of the catamorphism replacing the original nested value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now see if we can apply these rules to create catamorphisms in other domains.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Catamorphism example: File system domain'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with a very crude model of a file system:'
  prefs: []
  type: TYPE_NORMAL
- en: Each file has a name and a size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each directory has a name and a size and a list of subitems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s how I might model that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: I admit it's a pretty bad model, but it's just good enough for this example!
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, here are some sample files and directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Time to create the catamorphism!
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at the signatures to figure out what we need.
  prefs: []
  type: TYPE_NORMAL
- en: The `File` constructor takes a `File` and returns a `FileSystemItem`. Using
    the guidelines above, the handler for the `File` case needs to have the signature
    `File -> 'r`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s simple enough. Let''s put together an initial skeleton of `cataFS`,
    as I''ll call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `Directory` case is more complicated. If we naively applied the guidelines
    above, the handler for the `Directory` case would have the signature `Directory
    -> 'r`, but that would be incorrect, because the `Directory` record itself contains
    a `FileSystemItem` that needs to be replaced with an `'r` too. How can we do this?
  prefs: []
  type: TYPE_NORMAL
- en: One way is to "explode" the `Directory` record into a tuple of `(string,int,FileSystemItem
    list)`, and then replace the `FileSystemItem` with `'r` in there too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, we have this sequence of transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Another issue is that the data associated with the Directory case is a *list*
    of `FileSystemItem`s. How can we convert that into a list of `'r`s?
  prefs: []
  type: TYPE_NORMAL
- en: Well, the `recurse` helper turns a `FileSystemItem` into an `'r`, so we can
    just use `List.map` passing in `recurse` as the mapping function, and that will
    give us the list of `'r`s we need!
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting it all together, we get this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'and if we look at the type signature, we can see that it is just what we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: So we're done. It's a bit complicated to set up, but once built, we have a nice
    reusable function that can be the basis for many others.
  prefs: []
  type: TYPE_NORMAL
- en: 'File system domain: `totalSize` example'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alrighty then, let's use it in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we can easily define a `totalSize` function that returns the
    total size of an item and all its subitems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And here are the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'File system domain: `largestFile` example'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How about a more complicated function, such as "what is the largest file in
    the tree?"
  prefs: []
  type: TYPE_NORMAL
- en: Before we start this one, let's think about what it should return. That is,
    what is the `'r`?
  prefs: []
  type: TYPE_NORMAL
- en: You might think that it's just a `File`. But what if the subdirectory is empty
    and there *are* no files?
  prefs: []
  type: TYPE_NORMAL
- en: So let's make `'r` a `File option` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function for the `File` case should return `Some file` then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The function for the `Directory` case needs more thought:'
  prefs: []
  type: TYPE_NORMAL
- en: If list of subfiles is empty, then return `None`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If list of subfiles is non-empty, then return the largest one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: But remember that `'r` is not a `File` but a `File option`. So that means that
    `subfiles` is not a list of files, but a list of `File option`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how can we find the largest one of these? We probably want to use `List.maxBy`
    and pass in the size. But what is the size of a `File option`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a helper function to provide the size of a `File option`, using
    this logic:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `File option` is `None`, return 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Else return the size of the file inside the option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting it all together then, we have our `largestFile` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If we test it, we get the results we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Again, a little bit tricky to set up, but no more than if we had to write it
    from scratch without using a catamorphism at all.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Catamorphism example: Product domain'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s work with a slightly more complicated domain. This time, imagine that
    we make and sell products of some kind:'
  prefs: []
  type: TYPE_NORMAL
- en: Some products are bought, with an optional vendor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some products are made on our premises, built from subcomponents, where a subcomponent
    is some quantity of another product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the domain modelled as types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note that the types are mutally recursive. `Product` references `MadeProduct`
    which references `Component` which in turn references `Product` again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some example products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now to design the catamorphism, we need to do is replace the `Product` type
    with `'r` in all the constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with the previous example, the `Bought` case is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `Made` case is trickier. We need to expand the `MadeProduct` into a tuple.
    But that tuple contains a `Component`, so we need to expand that as well. Finally
    we get to the inner `Product`, and we can then mechanically replace that with
    `'r`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the sequence of transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When implementing the `cataProduct` function we need to the same kind of mapping
    as before, turning a list of `Component` into a list of `(int,'r)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need a helper for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You can see that this uses the `recurse` function to turn the inner product
    (`comp.product`) into an `'r` and then make a tuple `int * 'r`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `convertComponentToTuple` available, we can convert all the components
    to tuples using `List.map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`componentTuples` is a list of `(int * ''r)`, which is just what we need for
    the `fMade` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete implementation of `cataProduct` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Product domain: `productWeight` example'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can now use `cataProduct` to calculate the weight, say.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test it interactively to make sure it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: That's as we expect.
  prefs: []
  type: TYPE_NORMAL
- en: Try implementing `productWeight` from scratch, without using a helper function
    like `cataProduct`. Again, it's do-able, but you'll probably waste quite bit of
    time getting the recursion logic right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Product domain: `mostUsedVendor` example'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's do a more complex function now. What is the most used vendor?
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic is simple: each time a product references a vendor, we''ll give that
    vendor one point, and the vendor with the highest score wins.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, let's think about what it should return. That is, what is the `'r`?
  prefs: []
  type: TYPE_NORMAL
- en: You might think that it's just a score of some kind, but we also need to know
    the vendor name. Ok, a tuple then. But what if there are no vendors?
  prefs: []
  type: TYPE_NORMAL
- en: So let's make `'r` a `VendorScore option`, where we are going to create a little
    type `VendorScore`, rather than using a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also define some helpers to get data from a `VendorScore` easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can't determine the most used vendor over until you have results from
    the entire tree, so both the `Bought` case and the `Made` case need to return
    a list which can added to as we recurse up the tree. And then, after getting *all*
    the scores, we'll sort descending to find the vendor with the highest one.
  prefs: []
  type: TYPE_NORMAL
- en: So we have to make `'r` a `VendorScore list`, not just an option!
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic for the `Bought` case is then:'
  prefs: []
  type: TYPE_NORMAL
- en: If the vendor is present, return a `VendorScore` with score = 1, but as a one-element
    list rather than as a single item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the vendor is missing, return an empty list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The function for the `Made` case is more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: If list of subscores is empty, then return an empty list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If list of subscores is non-empty, we sum them by vendor and then return the
    new list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But the list of subresults passed into the `fMade` function will not be a list
    of subscores, it will be a list of tuples, `qty * 'r` where `'r` is `VendorScore
    list`. Complicated!
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do then is:'
  prefs: []
  type: TYPE_NORMAL
- en: Turn `qty * 'r` into just `'r` because we don't care about the qty in this case.
    We now have a list of `VendorScore list`. We can use `List.map snd` to do this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But now we would have a list of `VendorScore list`. We can flatten a list of
    lists into a simple list using `List.collect`. And in fact, using `List.collect
    snd` can do both steps in one go.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group this list by vendor so that we have a list of `key=vendor; values=VendorScore
    list` tuples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sum up the scores for each vendor (`values=VendorScore list`) into a single
    value, so that we have a list of `key=vendor; values=VendorScore` tuples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point the `cata` function will return a `VendorScore list`. To get the
    highest score, use `List.sortByDescending` then `List.tryHead`. Note that `maxBy`
    won't work because the list could be empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the complete `mostUsedVendor` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This isn't the only possible implementation of `fMade`, of course. I could have
    used `List.fold` and done the whole thing in one pass, but this version seems
    like the most obvious and readable implementation.
  prefs: []
  type: TYPE_NORMAL
- en: It's also true that I could have avoided using `cataProduct` altogether and
    written `mostUsedVendor` from scratch. If performance is an issue, then that might
    be a better approach, because the generic catamorphism creates intermediate values
    (such as the list of `qty * VendorScore option`) which are over general and potentially
    wasteful.
  prefs: []
  type: TYPE_NORMAL
- en: On other hand, by using the catamorphism, I could focus on the counting logic
    only and ignore the recursion logic.
  prefs: []
  type: TYPE_NORMAL
- en: So as always, you should consider the pros and cons of reuse vs. creating from
    scratch; the benefits of writing common code once and using it in a standardized
    way, versus the performance but extra effort (and potential bugginess) of custom
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen in this post how to define a recursive type, and been introduced
    to catamorphisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'And we have also seen some uses for catamorphisms:'
  prefs: []
  type: TYPE_NORMAL
- en: Any function that "collapses" a recursive type, such as `Gift -> 'r`, can be
    written in terms of the catamorphism for that type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catamorphisms can be used to hide the internal structure of the type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catamorphisms can be used to create mappings from one type to another by tweaking
    the functions that handle each case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catamorphisms can be used to create a clone of the original value by passing
    in the type's case constructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But all is not perfect in the land of catamorphisms. In fact, all the catamorphism
    implementations on this page have a potentially serious flaw.
  prefs: []
  type: TYPE_NORMAL
- en: In the [next post](recursive-types-and-folds-2.html) we'll see what can go wrong
    with them, how to fix them, and in the process look at the various kinds of "fold".
  prefs: []
  type: TYPE_NORMAL
- en: See you then!
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this post is available at [this gist](https://gist.github.com/swlaschin/dc2b3fcdca319ca8be60).*'
  prefs: []
  type: TYPE_NORMAL
- en: '*UPDATE: Fixed logic error in `mostUsedVendor` as pointed out by Paul Schnapp
    in comments. Thanks, Paul!*'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Folds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing Folds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This post is the third in a series.
  prefs: []
  type: TYPE_NORMAL
- en: In the [first post](recursive-types-and-folds1.html), I introduced "catamorphisms",
    a way of creating functions for recursive types, and in the [second post](recursive-types-and-folds-1b.html),
    we created a few catamorphism implementations.
  prefs: []
  type: TYPE_NORMAL
- en: But at the end of the previous post, I noted that all the catamorphism implementations
    so far have had a potentially serious flaw.
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we'll look at the flaw and how to work around it, and in the process
    look at folds, tail-recursion and the difference between "left fold" and "right
    fold".
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the contents of this series:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: Catamorphism examples**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Introducing folds**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Understanding folds**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: Generic recursive types**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Trees in the real world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: A flaw in our catamorphism implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we look at the flaw, let's first review the recursive type `Gift` and
    the associated catamorphism `cataGift` that we created for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some example values that we''ll be using in this post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the catamorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'and here is a `totalCostUsingCata` function built using `cataGift`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: What's the flaw?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So what is wrong with this implementation? Let's stress test it and find out!
  prefs: []
  type: TYPE_NORMAL
- en: What we'll do is create a `Box` inside a `Box` inside a `Box` a very large number
    of times, and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a little helper function to create nested boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try it to make sure it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try running `totalCostUsingCata` with these deeply nested boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: So far so good.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we use much larger numbers, we soon run into a stack overflow exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The exact number which causes an error depends on the environment, available
    memory, and so on. But it is a certainty that you will run into it when you start
    using largish numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this happening?
  prefs: []
  type: TYPE_NORMAL
- en: The problem with deep recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall that the definition of the cost for the Boxed case (`fBox`) was `innerCost
    + 1.0m`. And what is the inner cost? That''s another box too, so we end up with
    a chain of calculations looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In other words, `innerCost1000` has to be calculated before `innerCost999` can
    be calculated, and 999 other inner costs have to be calculated before the top
    level `innerCost` can be calculated.
  prefs: []
  type: TYPE_NORMAL
- en: Every level is waiting for its inner cost to be calculated before doing the
    calculation for that level.
  prefs: []
  type: TYPE_NORMAL
- en: All these unfinished calculations are stacked up waiting for the inner one to
    complete. And when you have too many? Boom! Stack overflow!
  prefs: []
  type: TYPE_NORMAL
- en: The solution to stack overflows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The solution to this problem is simple. Rather than each level waiting for the
    inner cost to be calculated, each level calculates the cost so far, using an accumulator,
    and passes that down to the next inner level. When we get to the bottom level,
    we have the final answer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The big advantange of this approach is that all calculations at a particular
    level are *completely finished* before the next lowel level is called. Which means
    that the level and its associated data can be safely discarded from the stack.
    Which means no stack overflow!
  prefs: []
  type: TYPE_NORMAL
- en: An implementation like this, where the higher levels can be safely discarded,
    is called *tail recursive*.
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementating the `totalCost` function with an accumulator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s rewrite the total cost function from scratch, using an accumulator called
    `costSoFar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'A few things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: The new version of the function has an extra parameter (`costSoFar`). We will
    have to provide an initial value for this (such as zero) when we call it at the
    top level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The non-recursive cases (`Book` and `Chocolate`) are the end points. The take
    the cost so far and add it to their price, and then that is the final result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recursive cases calculate a new `costSoFar` based on the parameter that
    is passed in. The new `costSoFar` is then passed down to the next lower level,
    just as in the example above.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s stress test this version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Excellent. Up to one million nested levels without a hiccup.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing "fold"
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's apply the same design principle to the catamorphism implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a new function `foldGift`. We'll introduce an accumulator `acc`
    that we will thread through each level, and the non-recursive cases will return
    the final accumulator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the type signature, we can see that it is subtly different. The
    type of the accumulator `'a` is being used everywhere now. The only time where
    the final return type is used is in the two non-recursive cases (`fBook` and `fChocolate`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at this more closely, and compare the signatures of the original
    catamorphism from the last post with the signatures of the new `fold` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, the non-recursive cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, with "fold", the non-recursive cases take an extra parameter
    (the accumulator) and return the `'r` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very important point: *the type of the accumulator does not need
    to be the same as the return type.* We will need to take advantage of this shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: What about the recursive cases? How did their signature change?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: For the recursive cases, the structure is identical but all use of the `'r`
    type has been replaced with the `'a` type. The recursive cases do not use the
    `'r` type at all.
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementating the `totalCost` function using fold
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once again, we can reimplement the total cost function, but this time using
    the `foldGift` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'And again, we can process very large numbers of nested boxes without a stack
    overflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Problems with fold
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So using fold solves all our problems, right?
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, no.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, there are no more stack overflows, but we have another problem now.
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementation of the `description` function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see what the problem is, let's revisit the `description` function that we
    created in the first post.
  prefs: []
  type: TYPE_NORMAL
- en: The original one was not tail-recursive, so let's make it safer and reimplement
    it using `foldGift`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what the output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: These outputs are wrong! The order of the decorations has been mixed up.
  prefs: []
  type: TYPE_NORMAL
- en: It's supposed to be a wrapped book with a card, not a book and a card wrapped
    together. And it's supposed to be chocolate in a box, then wrapped, not wrapped
    chocolate in a box!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: What has gone wrong?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that the correct description for each layer depends on the description
    of the layer below. We can't "pre-calculate" the description for a layer and pass
    it down to the next layer using a `descriptionSoFar` accumulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'But now we have a dilemma: a layer depends on information from the layer below,
    but we want to avoid a stack overflow.'
  prefs: []
  type: TYPE_NORMAL
- en: Using functions as accumulators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that the accumulator type does not have to be the same as the return
    type. We can use anything as an accumulator, even a function!
  prefs: []
  type: TYPE_NORMAL
- en: So what we'll do is, rather than passing a `descriptionSoFar` as the accumulator,
    we'll pass a function (`descriptionGenerator` say) that will build the appropriate
    description given the value of the next layer down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the implementation for the non-recursive cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation for recursive cases is a bit more complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: We are given an accumulator (`descriptionGenerator`) as a parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to create a new accumulator (a new `descriptionGenerator`) to pass down
    to the next lower layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *input* to the description generator will be all the data accumulated from
    the lower layers. We manipulate that to make a new description and then call the
    `descriptionGenerator` passed in from the higher layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s more complicated to talk about than to demonstrate, so here are implementations
    for two of the cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simplify that code a little by using a lambda directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: We could continue to make it more compact using piping and other things, but
    I think that what we have here is a good balance between conciseness and obscurity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the entire function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Again, I'm using overly descriptive intermediate values to make it clear what
    is going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try `descriptionUsingFoldWithGenerator` now, we get the correct answers
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Introducing "foldback"
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we understand what to do, let''s make a generic version that that
    handles the generator function logic for us. This one we will call "foldback":'
  prefs: []
  type: TYPE_NORMAL
- en: '*By the way, I''m going to use term "generator" here. In other places, it is
    commonly referred to as a "continuation" function, often abbreviated to just "k".*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: You can see that it is just like the `descriptionUsingFoldWithGenerator` implementation,
    except that we are using generic `newInnerVal` and `generator` values.
  prefs: []
  type: TYPE_NORMAL
- en: The type signatures are similar to the original catamorphism, except that every
    case works with `'a` only now. The only time `'r` is used is in the generator
    function itself!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '*The `foldback` implementation above is written from scratch. If you want a
    fun exercise, see if you can write `foldback` in terms of `fold`.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the `description` function using `foldback`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'And the results are still correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Comparing `foldback` to the original catamorphism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implementation of `descriptionUsingFoldBack` is almost identical to the
    version in the last post that used the original catamorphism `cataGift`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the version using `cataGift`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the version using `foldbackGift`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: All the handler functions are basically identical. The only change is the addition
    of an initial generator function, which is just `id` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: However, although the code looks the same in both cases, they differ in their
    recursion safety. The `foldbackGift` version is still tail recursive, and can
    handle very large nesting depths, unlike the `cataGift` version.
  prefs: []
  type: TYPE_NORMAL
- en: But this implementation is not perfect either. The chain of nested functions
    can get very slow and generate a lot of garbage, and for this particular example,
    there is an even faster way, which we'll look at in the next post.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the type signature of `foldback` to avoid a mixup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In `foldGift` the signature for `fWrapped` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'But in `foldbackGift` the signature for `fWrapped` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Can you spot the difference? No, me neither.
  prefs: []
  type: TYPE_NORMAL
- en: The two functions are very similar, yet work very differently. In the `foldGift`
    version, the first parameter is the accumulator from the *outer* levels, while
    in `foldbackGift` version, the first parameter is the accumulator from the *inner*
    levels. Quite an important distinction!
  prefs: []
  type: TYPE_NORMAL
- en: It is therefore common to change the signature of the `foldBack` version so
    that the accumulator always comes *last*, while in the normal `fold` function,
    the accumulator always comes *first*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This change shows up in the type signature. The `Gift` value comes before the
    accumulator now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: and now we *can* tell the two versions apart easily.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Rules for creating a fold
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To finish up this post, let's summarize the rules for creating a fold.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first post we saw that creating a catamorphism is a mechanical process
    that [follows rules](recursive-types-and-folds1.html#rules). The same is true
    for creating a iterative top-down fold. The process is:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function parameter to handle each case in the structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an additional parameter as an accumulator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For non-recursive cases, pass the function parameter the accumulator plus all
    the data associated with that case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For recursive cases, perform two steps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, pass the handler the accumulator plus all the data associated with that
    case (except the inner recursive data). The result is a new accumulator value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, call the fold recursively on the nested value using the new accumulator
    value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that each handler only "sees" (a) the data for that case, and (b) the accumulator
    passed to it from the outer level. It does not have access to the results from
    the inner levels.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen in this post how to define a tail-recursive implementation of a catamorphism,
    called "fold" and the reverse version "foldback".
  prefs: []
  type: TYPE_NORMAL
- en: In the [next post](recursive-types-and-folds-2b.html) we'll step back a bit
    and spend some time understanding what "fold" really means, and at some guidelines
    for choosing between `fold`, `foldback` and `cata`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll then see if we can apply these rules to another domain.
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this post is available at [this gist](https://gist.github.com/swlaschin/df4427d0043d7146e592).*'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Folds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Folds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This post is the fourth in a series.
  prefs: []
  type: TYPE_NORMAL
- en: In the [previous post](recursive-types-and-folds1.html), I introduced "folds",
    a way of creating top-down iterative functions for recursive types.
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we'll spend some time understanding folds in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the contents of this series:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: Catamorphism examples**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Introducing folds**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Understanding folds**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: Generic recursive types**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Trees in the real world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Iteration vs. recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have *three* different functions -- `cata`, `fold` and `foldback`.
  prefs: []
  type: TYPE_NORMAL
- en: So what exactly are the differences between them? We've seen that something
    that doesn't work with `fold` will work with `foldBack`, but is there an easy
    way to remember the difference?
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to differentiate the three approaches is by remembering this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fold` is top-down *iteration*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cata` is bottom-up *recursion*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foldBack` is bottom-up *iteration*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does this mean?
  prefs: []
  type: TYPE_NORMAL
- en: Well, for in `fold`, the accumulator was initialized at the top level, and was
    passed down to each lower level until the lowest and last level was reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'In code terms, each level did this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: In an imperative language, this is exactly a "for loop" with a mutable variable
    storing the accumulator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: So, this kind of top-to-bottom folding can be thought of as iteration (and in
    fact, the F# compiler will turn a tail-recursive function like this into an iteration
    behind the scenes).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, in `cata`, the accumulator started at the bottom level, and
    was passed up to each higher level until the top level was reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'In code terms, each level did this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly a recursive loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Finally, `foldback` can be thought of as "reverse iteration". The accumulator
    is threaded through all the levels, but starting at the bottom rather than at
    the top. It has the benefits of `cata` in that the inner values are calculated
    first and passed back up, but because it is iterative, there cannot be a stack
    overflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of the concepts we have discussed so far become clear when expressed in
    terms of iteration vs. recursion. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: The iterative versions (`fold` and `foldback`) have no stack, and cannot cause
    a stack overflow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "total cost" function needed no inner data, and so the top-down iterative
    version (`fold`) worked without problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "description" function though, needed inner text for correct formatting,
    and so the recursive version (`cata`) or bottom up iteration (`foldback`) was
    more suitable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fold example: File system domain'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last post, we described some rules for creating folds. Let's see if we
    can apply these rules to create a fold in another domain, the "File System" domain
    from the [second post in the series](recursive-types-and-folds-1b.html#file-system).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, here is the crude "file system" domain from that post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Note that each directory contains a *list* of subitems, so this is not a linear
    structure like `Gift`, but a tree-like structure. Out implementation of fold will
    have to take this into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some sample values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to create a fold, `foldFS`, say. So, following the rules, let''s add
    an extra accumulator parameter `acc` and pass it to the `File` case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The `Directory` case is trickier. We are not supposed to know about the subitems,
    so that means that the only data we can use is the `name`, `dirSize`, and the
    accumulator passed in from a higher level. These are combined to make a new accumulator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '*NOTE: I''m keeping the `name` and `dirSize` as a tuple for grouping purposes,
    but of course you could pass them in as separate parameters.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to pass this new accumulator down to each subitem in turn, but
    each subitem will return a new accumulator of its own, so we need to use the following
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Take the newly created accumulator and pass it to the first subitem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take the output of that (another accumulator) and pass it to the second subitem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take the output of that (another accumulator) and pass it to the third subitem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And so on. The output of the last subitem is the final result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That approach is already available to us though. It''s exactly what `List.fold`
    does! So here''s the code for the Directory case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the entire `foldFS` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we can rewrite the same two functions we implemented in
    the last post.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `totalSize` function, which just sums up all the sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we test it we get the same results as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'File system domain: `largestFile` example'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also reimplement the "what is the largest file in the tree?" function.
  prefs: []
  type: TYPE_NORMAL
- en: As before it will return a `File option`, because the tree might be empty. This
    means that the accumulator will be a `File option` too.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time it is the `File` case handler which is tricky:'
  prefs: []
  type: TYPE_NORMAL
- en: If the accumulator being passed in is `None`, then this current file becomes
    the new accumulator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the accumulator being passed in is `Some file`, then compare the size of
    that file with this file. Whichever is bigger becomes the new accumulator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, the `Directory` handler is trivial -- just pass the "largest
    so far" accumulator down to the next level
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the complete implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we test it we get the same results as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: It is interesting to compare this implementation with the [recursive version
    in the second post](recursive-types-and-folds-1b.html#file-system). I think that
    this one is easier to implement, myself.
  prefs: []
  type: TYPE_NORMAL
- en: Tree traversal types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The various fold functions discussed so far correspond to various kinds of
    tree traversals:'
  prefs: []
  type: TYPE_NORMAL
- en: A `fold` function (as implemented here) is more properly called a "pre-order
    depth-first" tree traversal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `foldback` function would be a "post-order depth-first" tree traversal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `cata` function would not be a "traversal" at all, because each internal node
    deals with a list of all the subresults at once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By tweaking the logic, you can make other variants.
  prefs: []
  type: TYPE_NORMAL
- en: For a description of the various kinds of tree traversals, see [Wikipedia](https://en.wikipedia.org/wiki/Tree_traversal).
  prefs: []
  type: TYPE_NORMAL
- en: Do we need `foldback`?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do we need to implement a `foldback` function for the FileSystem domain?
  prefs: []
  type: TYPE_NORMAL
- en: I don't think so. If we need access to the inner data, we can just use the original
    "naive" catamorphism implementation in the previous post.
  prefs: []
  type: TYPE_NORMAL
- en: But, hey wait, didn't I say at the beginning that we had to watch out for stack
    overflows?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, if the recursive type is deeply nested. But consider a file system with
    only two subdirectories per directory. How many directories would there be if
    there were 64 nested levels? (Hint: you may be familiar with a similar problem.
    Something to do with [grains on a chessboard](https://en.wikipedia.org/wiki/Wheat_and_chessboard_problem)).'
  prefs: []
  type: TYPE_NORMAL
- en: We saw earlier that the stack overflow issue only occurs with more than 1000
    nested levels, and that level of nesting generally only occurs with *linear* recursive
    types, not trees like the FileSystem domain.
  prefs: []
  type: TYPE_NORMAL
- en: Common questions about "fold"
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point you might be getting overwhelmed! All these different implementations
    with different advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: So let's take a short break and address some common questions.
  prefs: []
  type: TYPE_NORMAL
- en: What's the difference between "left fold" and "right fold"
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is often quite a lot of confusion around the terminology of folds: "left"
    vs. "right", "forward" vs. "backwards", etc.'
  prefs: []
  type: TYPE_NORMAL
- en: A *left fold* or *forward fold* is what I have just called `fold` -- the top-down
    iterative approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *right fold* or *backward fold* is what I have called `foldBack` -- the bottom-up
    iterative approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These terms, though, really only apply to linear recursive structures like
    `Gift`. When it comes to more complex tree-like structures, these distinctions
    are too simple, because there are many ways to traverse them: breadth-first, depth-first,
    pre-order and post-order, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Which type of fold function should I use?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: If your recursive type is not going to be too deeply nested (less than 100 levels
    deep, say), then the naive `cata` catamorphism we described in the first post
    is fine. It's really easy to implement mechanically -- just replace the main recursive
    type with `'r`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your recursive type is going to be deeply nested and you want to prevent
    stack overflows, use the iterative `fold`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using an iterative fold but you need to have access to the inner
    data, pass a continuation function as an accumulator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the iterative approach is generally faster and uses less memory than
    the recursive approach (but that advantage is lost if you pass around too many
    nested continuations).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another way to think about it is to look at your "combiner" function. At each
    step, you are combining data from the different levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'If your combiner function is "left associative" like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'then use the iterative approach, but if your combiner function is "right associative"
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: then use the `cata` or `foldback` approach.
  prefs: []
  type: TYPE_NORMAL
- en: And if your combiner function doesn't care (like addition, for example), use
    whichever one is more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: How can I know whether code is tail-recursive or not?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's not always obvious whether an implementation is tail-recursive or not.
    The easiest way to be sure is to look at the very last expression for each case.
  prefs: []
  type: TYPE_NORMAL
- en: If the call to "recurse" is the very last expression, then it is tail-recursive.
    If there is any other work after that, then it is not tail-recursive.
  prefs: []
  type: TYPE_NORMAL
- en: See for yourself with the three implementations that we have discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here''s the code for the `WithACard` case in the original `cataGift`
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: The `cataGift` implementation is *not* tail-recursive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code from the `foldGift` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The `foldGift` implementation *is* tail-recursive.
  prefs: []
  type: TYPE_NORMAL
- en: 'And here''s the code from the `foldbackGift` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The `foldbackGift` implementation is also tail-recursive.
  prefs: []
  type: TYPE_NORMAL
- en: How do I short-circuit a fold?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a language like C#, you can exit a iterative loop early using `break` like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: So how do you do the same thing with a fold?
  prefs: []
  type: TYPE_NORMAL
- en: The short answer is, you can't! A fold is designed to visit all elements in
    turn. The Visitor Pattern has the same constraint.
  prefs: []
  type: TYPE_NORMAL
- en: There are three workarounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is to not use `fold` at all and create your own recursive function
    that terminates on the required condition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the loop exits when the sum is larger than 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The second approach is to use `fold` but to add some kind of "ignore" flag to
    the accumulator that is passed around. Once this flag is set, the remaining iterations
    do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of calculating the sum, but the accumulator is actually
    a tuple with an `ignoreFlag` in addition to the `sumSoFar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The third version is a variant of the second -- create a special value to signal
    that the remaining data should be ignored, but wrap it in a computation expression
    so that it looks more natural.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is documented on [Tomas Petricek''s blog](http://tomasp.net/blog/imperative-ii-break.aspx/)
    and the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of this post was to help you understand folds better, and to show how
    they could be applied to a tree structure like the file system. I hope it was
    helpful!
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point in the series all the examples have been very concrete; we
    have implemented custom folds for each domain we have encountered. Can we be a
    bit more generic and build some reusable fold implementations?
  prefs: []
  type: TYPE_NORMAL
- en: In the [next post](recursive-types-and-folds-3.html) we'll look at generic recursive
    types, and how to work with them.
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this post is available at [this gist](https://gist.github.com/swlaschin/e065b0e99dd68cd35846).*'
  prefs: []
  type: TYPE_NORMAL
- en: Generic recursive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generic recursive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This post is the fifth in a series.
  prefs: []
  type: TYPE_NORMAL
- en: In the [previous post](recursive-types-and-folds-2b.html), we spent some time
    understanding folds for specific domain types.
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we'll broaden our horizons and look at how to use generic recursive
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the contents of this series:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: Catamorphism examples**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Introducing folds**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Understanding folds**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: Generic recursive types**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Trees in the real world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'LinkedList: A generic recursive type'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a question: if you only have algebraic types, and you can only combine
    them as products ([tuples](tuples.html), [records](records.html)) or sums ([discriminated
    unions](discriminated-unions.html)), then how can you make a list type just by
    using these operations?'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is, of course, recursion!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the most basic recursive type: the list.'
  prefs: []
  type: TYPE_NORMAL
- en: I'm going to call my version `LinkedList`, but it is basically the same as the
    `list` type in F#.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do you define a list in a recursive way?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, it''s either empty, or it consists of an element plus another list. In
    other words we can define it as a choice type ("discriminated union") like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Empty` case represents an empty list. The `Cons` case has a tuple: the
    head element, and the tail, which is another list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then define a particular `LinkedList` value like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the native F# list type, the equivalent definition would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: which is just `[1; 2; 3]`
  prefs: []
  type: TYPE_NORMAL
- en: '`cata` for LinkedList'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Following the rules in the [first post in this series](recursive-types-and-folds1.html#rules),
    we can mechanically create a `cata` function by replacing `Empty` and `Cons` with
    `fEmpty` and `fCons`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '*Note: We will be putting all the functions associated with `LinkedList<''a>`
    in a module called `LinkedList`. One nice thing about using generic types is that
    the type name does not clash with a similar module name!*'
  prefs: []
  type: TYPE_NORMAL
- en: As always, the signatures of the case handling functions are parallel to the
    signatures of the type constructors, with `LinkedList` replaced by `'r`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '`fold` for LinkedList'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also create a top-down iterative `fold` function using the rules in the
    [earlier post](recursive-types-and-folds-2.html#rules).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'This `foldWithEmpty` function is not quite the same as the standard `List.fold`
    function, because it has an extra function parameter for the empty case (`fEmpty`).
    However, if we eliminate that parameter and just return the accumulator we get
    this variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compare the signature with the [List.fold documentation](https://msdn.microsoft.com/en-us/library/ee353894.aspx)
    we can see that they are equivalent, with `''State` replaced by `''r` and `''T
    list` replaced by `LinkedList<''a>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test that `fold` works by doing a small sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '`foldBack` for LinkedList'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally we can create a `foldBack` function, using the "function accumulator"
    approach described in the previous post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, if we compare the signature with the [List.foldBack documentation](https://msdn.microsoft.com/en-us/library/ee353846.aspx),
    they are also equivalent, with `''State` replaced by `''r` and `''T list` replaced
    by `LinkedList<''a>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Using `foldBack` to convert between list types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the [first post](recursive-types-and-folds1.html#benefits) we noted that
    catamorphisms could be used for converting between types of similar structure.
  prefs: []
  type: TYPE_NORMAL
- en: Let's demonstrate that now by creating some functions that convert from `LinkedList`
    to the native `list` type and back again.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert a `LinkedList` to a native `list` all we need to do is replace `Cons`
    with `::` and `Empty` with `[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert the other way, we need to replace `::` with `Cons` and `[]` with
    `Empty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple! Let''s test `toList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'and `ofList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Both work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Using `foldBack` to implement other functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I said earlier that a catamorphism function (for linear lists, `foldBack`) is
    the most basic function available for a recursive type, and in fact is the *only*
    function you need!
  prefs: []
  type: TYPE_NORMAL
- en: Let's see for ourselves by implementing some other common functions using `foldBack`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s `map` defined in terms of `foldBack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s `filter` defined in terms of `foldBack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here''s `rev` defined in terms of `fold`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: So, I hope you're convinced!
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding generator functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I mentioned earlier that there was an alternative and (sometimes) more efficient
    way to implement `foldBack` without using generators or continuations.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, `foldBack` is reverse iteration, which means that it is the
    same as `fold` applied to a reversed list!
  prefs: []
  type: TYPE_NORMAL
- en: 'So we could implement it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: It involves making an extra copy of the list, but on the other hand there is
    no longer a large set of pending continuations. It might be worth comparing the
    profile of the two versions in your environment if performance is an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Making the Gift domain generic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the rest of this post, we'll look at the `Gift` type and see if we can make
    it more generic.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, here is the original design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Three of the cases are recursive and two are non-recursive.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the focus of this particular design was on modelling the domain, which
    is why there are so many separate cases.
  prefs: []
  type: TYPE_NORMAL
- en: But if we want to focus on *reusability* instead of domain modelling, then we
    should simplify the design to the essentials, and all these special cases now
    become a hindrance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this ready for reuse, then, let''s collapse all the non-recursive cases
    into one case, say `GiftContents`, and all the recursive cases into another case,
    say `GiftDecoration`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'The main `Gift` type has only two cases now: the non-recursive one and the
    recursive one.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a generic Container type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the type is simplified, we can "genericize" it by allowing *any* kind
    of contents *and* any kind of decoration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'And as before, we can mechanically create a `cata` and `fold` and `foldBack`
    for it, using the standard process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Converting the gift domain to use the Container type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s convert the gift type to this generic Container type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need some helper methods to construct values while hiding the "real"
    cases of the generic type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally we can create some test values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: The `totalCost` function using the Container type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The "total cost" function can be written using `fold`, since it doesn't need
    any inner data.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the earlier implementations, we only have two function parameters, `fContents`
    and `fDecoration`, so each of these will need some pattern matching to get at
    the "real" data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'And the code works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: The `description` function using the Container type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The "description" function needs to be written using `foldBack`, since it *does*
    need the inner data. As with the code above, we need some pattern matching to
    get at the "real" data for each case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'And again the code works as we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: A third way to implement the gift domain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That all looks quite nice, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: But I have to confess that I have been holding something back.
  prefs: []
  type: TYPE_NORMAL
- en: None of that code above was strictly necessary, because it turns out that there
    is yet *another* way to model a `Gift`, without creating any new generic types
    at all!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Gift` type is basically a linear sequence of decorations, with some content
    as the final step. We can just model this as a pair -- a `Content` and a list
    of `Decoration`. Or to make it a little friendlier, a record with two fields:
    one for the content and one for the decorations.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: That's it! No other new types needed!
  prefs: []
  type: TYPE_NORMAL
- en: Building values using the record type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As before, let''s create some helpers to construct values using this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: With these helper functions, the way the values are constructed is *identical*
    to the previous version. This is why it is good to hide your raw constructors,
    folks!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: The `totalCost` function using the record type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `totalCost` function is even easier to write now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: The `description` function using the record type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similarly, the `description` function is also easy to write.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Abstract or concrete? Comparing the three designs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are confused by this plethora of designs, I don't blame you!
  prefs: []
  type: TYPE_NORMAL
- en: 'But as it happens, the three different definitions are actually interchangable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The original version**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '**The generic container version**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '**The record version**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: If this is not obvious, it might be helpful to read my post on [data type sizes](type-size-and-design.html).
    It explains how two types can be "equivalent", even though they appear to be completely
    different at first glance.
  prefs: []
  type: TYPE_NORMAL
- en: Picking a design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So which design is best? The answer is, as always, "it depends".
  prefs: []
  type: TYPE_NORMAL
- en: For modelling and documenting a domain, I like the first design with the five
    explicit cases. Being easy for other people to understand is more important to
    me than introducing abstraction for the sake of reusability.
  prefs: []
  type: TYPE_NORMAL
- en: If I wanted a reusable model that was applicable in many situations, I'd probably
    choose the second ("Container") design. It seems to me that this type does represent
    a commonly encountered situation, where the contents are one kind of thing and
    the wrappers are another kind of thing. This abstraction is therefore likely to
    get some use.
  prefs: []
  type: TYPE_NORMAL
- en: The final "pair" model is fine, but by separating the two components, we've
    over-abstracted the design for this scenario. In other situations, this design
    might be a great fit (e.g. the decorator pattern), but not here, in my opinion.
  prefs: []
  type: TYPE_NORMAL
- en: There is one further choice which gives you the best of all worlds.
  prefs: []
  type: TYPE_NORMAL
- en: As I noted above, all the designs are logically equivalent, which means there
    are "lossless" mappings between them. In that case, your "public" design can be
    the domain-oriented one, like the first one, but behind the scenes you can map
    it to a more efficient and reusable "private" type.
  prefs: []
  type: TYPE_NORMAL
- en: Even the F# list implementation itself does this. For example, some of the functions
    in the `List` module, such `foldBack` and `sort`, convert the list into an array,
    do the operations, and then convert it back to a list again.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post we looked at some ways of modelling the `Gift` as a generic type,
    and the pros and cons of each approach.
  prefs: []
  type: TYPE_NORMAL
- en: In the [next post](recursive-types-and-folds-3b.html) we'll look at real-world
    examples of using a generic recursive type.
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this post is available at [this gist](https://gist.github.com/swlaschin/c423a0f78b22496a0aff).*'
  prefs: []
  type: TYPE_NORMAL
- en: Trees in the real world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Trees in the real world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This post is the sixth in a series.
  prefs: []
  type: TYPE_NORMAL
- en: In the [previous post](recursive-types-and-folds-3.html), we briefly looked
    at some generic types.
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we'll do some deeper dives into some real-world examples of using
    trees and folds.
  prefs: []
  type: TYPE_NORMAL
- en: Series contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the contents of this series:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Introduction to recursive types and catamorphisms**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A simple recursive type](recursive-types-and-folds1.html#basic-recursive-type)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parameterize all the things](recursive-types-and-folds1.html#parameterize)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing catamorphisms](recursive-types-and-folds1.html#catamorphisms)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Benefits of catamorphisms](recursive-types-and-folds1.html#benefits)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a catamorphism](recursive-types-and-folds1.html#rules)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 2: Catamorphism examples**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: File system domain](recursive-types-and-folds-1b.html#file-system)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Catamorphism example: Product domain](recursive-types-and-folds-1b.html#product)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 3: Introducing folds**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A flaw in our catamorphism implementation](recursive-types-and-folds-2.html#flaw)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `fold`](recursive-types-and-folds-2.html#fold)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Problems with fold](recursive-types-and-folds-2.html#problems)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using functions as accumulators](recursive-types-and-folds-2.html#functions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Introducing `foldback`](recursive-types-and-folds-2.html#foldback)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rules for creating a fold](recursive-types-and-folds-2.html#rules)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 4: Understanding folds**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Iteration vs. recursion](recursive-types-and-folds-2b.html#iteration)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fold example: File system domain](recursive-types-and-folds-2b.html#file-system)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Common questions about "fold"](recursive-types-and-folds-2b.html#questions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 5: Generic recursive types**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[LinkedList: A generic recursive type](recursive-types-and-folds-3.html#linkedlist)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Making the Gift domain generic](recursive-types-and-folds-3.html#revisiting-gift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Container type](recursive-types-and-folds-3.html#container)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A third way to implement the gift domain](recursive-types-and-folds-3.html#another-gift)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstract or concrete? Comparing the three designs](recursive-types-and-folds-3.html#compare)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Part 6: Trees in the real world**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining a generic Tree type](recursive-types-and-folds-3b.html#tree)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Tree type in the real world](recursive-types-and-folds-3b.html#reuse)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mapping the Tree type](recursive-types-and-folds-3b.html#map)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Creating a directory listing](recursive-types-and-folds-3b.html#listing)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: A parallel grep](recursive-types-and-folds-3b.html#grep)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Storing the file system in a database](recursive-types-and-folds-3b.html#database)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Serializing a Tree to JSON](recursive-types-and-folds-3b.html#tojson)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON](recursive-types-and-folds-3b.html#fromjson)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example: Deserializing a Tree from JSON - with error handling](recursive-types-and-folds-3b.html#json-with-error-handling)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a generic Tree type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post, we'll be working with a generic `Tree` inspired by the `FileSystem`
    domain that we explored earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here was the original design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'We can separate out the data from the recursion, and create a generic `Tree`
    type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I have used `seq` to represent the subitems rather than `list`.
    The reason for this will become apparent shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file system domain can then be modelled using `Tree` by specifying `FileInfo`
    as data associated with a leaf node and `DirectoryInfo` as data associated with
    an internal node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '`cata` and `fold` for Tree'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can define `cata` and `fold` in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Note that I am *not* going to implement `foldBack` for the `Tree` type, because
    it's unlikely that the tree will get so deep as to cause a stack overflow. Functions
    that need inner data can use `cata`.
  prefs: []
  type: TYPE_NORMAL
- en: Modelling the File System domain with Tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s test it with the same values that we used before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'The `totalSize` function is almost identical to the one in the previous post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'And so is the `largestFile` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: The source code for this section is available at [this gist](https://gist.github.com/swlaschin/1ef784481bae91b63a36).
  prefs: []
  type: TYPE_NORMAL
- en: The Tree type in the real world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the `Tree` to model the *real* file system too! To do this, just
    set the leaf node type to `System.IO.FileInfo` and the internal node type to `System.IO.DirectoryInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s create some helper methods to create the various nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Now you can see why I used `seq` rather than `list` for the subitems. The `seq`
    is lazy, which means that we can create nodes without actually hitting the disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `totalSize` function again, this time using the real file information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what the size of the current directory is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can get the largest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: So that's one big benefit of using generic recursive types. If we can turn a
    real-world hierarchy into our tree structure, we can get all the benefits of fold
    "for free".
  prefs: []
  type: TYPE_NORMAL
- en: Mapping with generic types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One other advantage of using generic types is that you can do things like `map`
    -- converting every element to a new type without changing the structure.
  prefs: []
  type: TYPE_NORMAL
- en: We can see this in action with the real world file system. But first we need
    to define `map` for the `Tree` type!
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of `map` can also be done mechanically, using the following
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function parameter to handle each case in the structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For non-recursive cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, use the function parameter to transform the non-recursive data associated
    with that case
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then wrap the result in the same case constructor
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For recursive cases, perform two steps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, use the function parameter to transform the non-recursive data associated
    with that case
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, recursively `map` the nested values.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, wrap the results in the same case constructor
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the implementation of `map` for `Tree`, created by following those
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the signature of `Tree.map`, we can see that all the leaf data
    is transformed to type `'a`, all the node data is transformed to type `'b`, and
    the final result is a `Tree<'a,'b>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define `Tree.iter` in a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Creating a directory listing'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say we want to use `map` to transform the file system into a directory
    listing - a tree of strings where each string has information about the corresponding
    file or directory. Here''s how we could do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we can print the strings out like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'The results will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/77fadc19acb8cc850276).*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Creating a parallel grep'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at a more complex example. I'll demonstrate how to create a parallel
    "grep" style search using `fold`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `fold` to iterate through the files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each file, if its name doesn't match the desired file pattern, return `None`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the file is to be processed, then return an async that returns all the line
    matches in the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, all these asyncs -- the output of the fold -- are aggregated into a sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sequence of asyncs is transformed into a single one using `Async.Parallel`
    which returns a list of results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start writing the main code, we'll need some helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: First, a generic function that folds over the lines in a file asynchronously.
    This will be the basis of the pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, a little helper that allows us to `map` over `Async` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the central logic. We will create a function that, given a `textPattern`
    and a `FileInfo`, will return a list of lines that match the textPattern, but
    asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'And now for the `grep` function itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Let's test it!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: That's not bad for about 40 lines of code. This conciseness is because we are
    using various kinds of `fold` and `map` which hide the recursion, allowing us
    to focus on the pattern matching logic itself.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is not at all efficient or optimized (an async for every line!),
    and so I wouldn't use it as a real implementation, but it does give you an idea
    of the power of fold.
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/137c322b5a46b97cc8be).*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Storing the file system in a database'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the next example, let's look at how to store a file system tree in a database.
    I don't really know why you would want to do that, but the principles would work
    equally well for storing any hierarchical structure, so I will demonstrate it
    anyway!
  prefs: []
  type: TYPE_NORMAL
- en: 'To model the file system hierarchy in the database, say that we have four tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DbDir` stores information about each directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DbFile` stores information about each file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DbDir_File` stores the relationship between a directory and a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DbDir_Dir` stores the relationship between a parent directory and a child
    directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the database table definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: That's simple enough. But note that in order to save a directory completely
    along with its relationships to its child items, we first need the ids of all
    its children, and each child directory needs the ids of its children, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This implies that we should use `cata` instead of `fold`, so that we have access
    to the data from the lower levels of the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the database functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''re not wise enough to be using the [SQL Provider](https://fsprojects.github.io/SQLProvider/)
    and so we have written our own table insertion functions, like this dummy one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'In a real database, the identity column would be automatically generated for
    you, but for this example, I''ll use a little helper function `nextIdentity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Now in order to insert a directory, we need to first know all the ids of the
    files in the directory. This implies that the `insertDbFile` function should return
    the id that was generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'But that logic applies to the directories too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: But that's still not good enough. When the child ids are passed to the parent
    directory, it needs to distinguish between files and directories, because the
    relations are stored in different tables.
  prefs: []
  type: TYPE_NORMAL
- en: No problem -- we'll just use a choice type to distinguish between them!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can complete the implementation of the database functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Working with the catamorphism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted above, we need to use `cata` instead of `fold`, because we need the
    inner ids at each step.
  prefs: []
  type: TYPE_NORMAL
- en: The function to handle the `File` case is easy -- just insert it and return
    the `PrimaryKey`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: The function to handle the `Directory` case will be passed the `DirectoryInfo`
    and a sequence of `PrimaryKey`s from the children that have already been inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should insert the main directory record, then insert the children, and then
    return the `PrimaryKey` for the next higher level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: After inserting the directory record and getting its id, for each child id,
    we insert either into the `DbDir_File` table or the `DbDir_Dir`, depending on
    the type of the `childId`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Note that I've also created a little helper function `pkToInt` that extracts
    the integer id from the `PrimaryKey` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is all the code in one chunk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the ids are being generated as the files are iterated over,
    and that each `DbFile` insert is followed by a `DbDir_File` insert.
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/3a416f26d873faa84cde).*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Serializing a Tree to JSON'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at another common challenge: serializing and deserializing a tree
    to JSON, XML, or some other format.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the Gift domain again, but this time, we'll model the `Gift` type
    as a tree. That means we get to put more than one thing in a box!
  prefs: []
  type: TYPE_NORMAL
- en: Modelling the Gift domain as a tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the main types again, but notice that the final `Gift` type is defined
    as a tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we can create some helper functions to assist with constructing a
    `Gift`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can create some sample data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions like `description` now need to handle a *list* of inner texts, rather
    than one. We''ll just concat the strings together with an `&` separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can check that the function still works as before, and that multiple
    items are handled correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 1: Defining `GiftDto`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our `Gift` type consists of many discriminated unions. In my experience, these
    do not serialize well. In fact, most complex types do not serialize well!
  prefs: []
  type: TYPE_NORMAL
- en: 'So what I like to do is define [DTO](https://en.wikipedia.org/wiki/Data_transfer_object)
    types that are explicitly designed to be serialized well. In practice this means
    that the DTO types are constrained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Only record types should be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The record fields should consist only primitive values such as `int`, `string`
    and `bool`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By doing this, we also get some other advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**We gain control of the serialization output.** These kinds of data types
    are handled the same by most serializers, while "strange" things such as unions
    can be interpreted differently by different libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: '**We have better control of error handling.** My number one rule when dealing
    with serialized data is "trust no one". It''s very common that the data is structured
    correctly but is invalid for the domain: supposedly non-null strings are null,
    strings are too long, integers are outside the correct bounds, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: By using DTOs, we can be sure that the deserialization step itself will work.
    Then, when we convert the DTO to a domain type, we can do proper validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s define some DTO types for out domain. Each DTO type will correspond
    to a domain type, so let''s start with `GiftContents`. We''ll define a corresponding
    DTO type called `GiftContentsDto` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, this quite different from the original `GiftContents`, so let''s
    look at the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it has the `CLIMutableAttribute`, which allows deserializers to construct
    them using reflection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, it has a `discriminator` which indicates which case of the original
    union type is being used. Obviously, this string could be set to anything, so
    when converting from the DTO back to the domain type, we'll have to check that
    carefully!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is a series of fields, one for every possible item of data that needs to
    be stored. For example, in the `Book` case, we need a `bookTitle`, while in the
    `Chocolate` case, we need the chocolate type. And finally the `price` field which
    is in both types. Note that the chocolate type is stored as a string as well,
    and so will also need special treatment when we convert from DTO to domain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GiftDecorationDto` type is created in the same way, with a discriminator
    and strings rather than unions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can define a `GiftDto` type as being a tree that is composed of
    the two DTO types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 2: Transforming a `Gift` to a `GiftDto`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have this DTO type, all we need to do is use `Tree.map` to convert
    from a `Gift` to a `GiftDto`. And in order to do that, we need to create two functions:
    one that converts from `GiftContents` to `GiftContentsDto` and one that converts
    from `GiftDecoration` to `GiftDecorationDto`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the complete code for `giftToDto`, which should be self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the case (`Book`, `Chocolate`, etc.) is turned into a `discriminator`
    string and the `chocolateType` is also turned into a string, just as explained
    above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Defining a `TreeDto`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I said above that a good DTO should be a record type. Well we have converted
    the nodes of the tree, but the tree *itself* is a union type! We need to transform
    the `Tree` type as well, into say a `TreeDto` type.
  prefs: []
  type: TYPE_NORMAL
- en: How can we do this? Just as for the gift DTO types, we will create a record
    type which contains all the data for both cases. We could use a discriminator
    field as we did before, but this time, since there are only two choices, leaf
    and internal node, I'll just check whether the values are null or not when deserializing.
    If the leaf value is not null, then the record must represent the `LeafNode` case,
    otherwise the record must represent the `InternalNode` case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the definition of the data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: As before, the type has the `CLIMutableAttribute`. And as before, the type has
    fields to store the data from all possible choices. The `subtrees` are stored
    as an array rather than a seq -- this makes the serializer happy!
  prefs: []
  type: TYPE_NORMAL
- en: To create a `TreeDto`, we use our old friend `cata` to assemble the record from
    a regular `Tree`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Note that in F#, records are not nullable, so I am using `Unchecked.defaultof<'NodeData>`
    rather than `null` to indicate missing data.
  prefs: []
  type: TYPE_NORMAL
- en: Note also that I am assuming that `LeafData` or `NodeData` are reference types.
    If `LeafData` or `NodeData` are ever value types like `int` or `bool`, then this
    approach will break down, because you won't be able to tell the difference between
    a default value and a missing value. In which case, I'd switch to a discriminator
    field as before.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, I could have used an `IDictionary`. That would be less convenient
    to deserialize, but would avoid the need for null-checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Serializing a `TreeDto`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally we can serialize the `TreeDto` using a JSON serializer.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, I am using the built-in `DataContractJsonSerializer` so that
    I don't need to take a dependency on a NuGet package. There are other JSON serializers
    that might be better for a serious project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 5: Assembling the pipeline'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, putting it all together, we have the following pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: Transform `Gift` to `GiftDto` using `giftToDto`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: that is, use `Tree.map` to go from `Tree<GiftContents,GiftDecoration>` to `Tree<GiftContentsDto,GiftDecorationDto>`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Transform `Tree` to `TreeDto` using `treeToDto`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: that is, use `Tree.cata` to go from `Tree<GiftContentsDto,GiftDecorationDto>`
    to `TreeDto<GiftContentsDto,GiftDecorationDto>`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Serialize `TreeDto` to a JSON string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s some example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is what the JSON output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: The ugly `@` signs on the field names are an artifact of serializing the F#
    record type. This can be corrected with a bit of effort, but I'm not going to
    bother right now!
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/bbe70c768215b209c06c)*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Deserializing a Tree from JSON'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have created the JSON, what about going the other way and loading
    it into a `Gift`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple! We just need to reverse the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: Deserialize a JSON string into a `TreeDto`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transform a `TreeDto` into a `Tree` to using `dtoToTree`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: that is, go from `TreeDto<GiftContentsDto,GiftDecorationDto>` to `Tree<GiftContentsDto,GiftDecorationDto>`.
    We can't use `cata` for this -- we'll have to create a little recursive loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Transform `GiftDto` to `Gift` using `dtoToGift`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: that is, use `Tree.map` to go from `Tree<GiftContentsDto,GiftDecorationDto>`
    to `Tree<GiftContents,GiftDecoration>`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Step 1: Deserializing a `TreeDto`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can deserialize the `TreeDto` using a JSON serializer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: What if the deserialization fails? For now, we will ignore any error handling
    and let the exception propagate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Transforming a `TreeDto` into a `Tree`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To transform a `TreeDto` into a `Tree` we recursively loop through the record
    and its subtrees, turning each one into a `InternalNode` or a `LeafNode`, based
    on whether the appropriate field is null or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, a number of things could go wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: What if the `leafData` and `nodeData` fields are both null?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if the `nodeData` field is not null but the `subtrees` field *is* null?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, we will ignore any error handling and just throw exceptions (for now).
  prefs: []
  type: TYPE_NORMAL
- en: '*Question: Could we create a `cata` for `TreeDto` that would make this code
    simpler? Would it be worth it?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Transforming a `GiftDto` into `Gift`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we have a proper tree, we can use `Tree.map` again to convert each leaf
    and internal node from a DTO to the proper domain type.
  prefs: []
  type: TYPE_NORMAL
- en: That means we need functions that map a `GiftContentsDto` into a `GiftContents`
    and a `GiftDecorationDto` into a `GiftDecoration`.
  prefs: []
  type: TYPE_NORMAL
- en: Here's the complete code -- it's a lot more complicated than going in the other
    direction!
  prefs: []
  type: TYPE_NORMAL
- en: 'The code can be grouped as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Helper methods (such as `strToChocolateType`) that convert a string into a proper
    domain type and throw an exception if the input is invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case converter methods (such as `bookFromDto`) that convert an entire DTO into
    a case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally, the `dtoToGift` function itself. It looks at the `discriminator`
    field to see which case converter to call, and throws an exception if the discriminator
    value is not recognized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 4: Assembling the pipeline'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can now assemble the pipeline that takes a JSON string and creates a `Gift`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: This works fine, but the error handling is terrible!
  prefs: []
  type: TYPE_NORMAL
- en: 'Look what happens if we corrupt the JSON a little:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: We get an ugly exception.
  prefs: []
  type: TYPE_NORMAL
- en: Or what if a discriminator is wrong?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: or one of the values for the WrappingPaperStyle DU?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: We get lots of exceptions, and as as functional programmers, we should try to
    remove them whenever we can.
  prefs: []
  type: TYPE_NORMAL
- en: How we can do that will be discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/bbe70c768215b209c06c).*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Deserializing a Tree from JSON - with error handling'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To address the error handling issue, we''re going use the `Result` type shown
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: I'm not going to explain how it works here. If you are not familar with this
    approach, please [read my post](recipe-part2.html) or [watch my talk](http://fsharpforfunandprofit.com/rop/)
    on the topic of functional error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Let's revisit all the steps from the previous section, and use `Result` rather
    than throwing exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Deserializing a `TreeDto`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we deserialize the `TreeDto` using a JSON serializer we will trap exceptions
    and turn them into a `Result`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: The signature of `fromJson` is now `string -> Result<'a>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Transforming a `TreeDto` into a `Tree`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As before, we transform a `TreeDto` into a `Tree` by recursively looping through
    the record and its subtrees, turning each one into a `InternalNode` or a `LeafNode`.
    This time, though, we use `Result` to handle any errors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'But uh-oh, we now have a `Tree` where every internal node and leaf is wrapped
    in a `Result`. It''s a tree of `Results`! The actual ugly signature is this: `Tree<Result<''Leaf>,Result<''Node>>`.'
  prefs: []
  type: TYPE_NORMAL
- en: But this type is useless as it stands -- what we *really* want is to merge all
    the errors together and return a `Result` containing a `Tree`.
  prefs: []
  type: TYPE_NORMAL
- en: How can we transform a Tree of Results into a Result of Tree?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is to use a `sequence` function which "swaps" the two types. You
    can read much more about `sequence` in [my series on elevated worlds](elevated-world-4.html#sequence).
  prefs: []
  type: TYPE_NORMAL
- en: '*Note that we could also use the slightly more complicated `traverse` variant
    to combine the `map` and `sequence` into one step, but for the purposes of this
    demonstration, it''s easier to understand if the steps are kept separate.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create our own `sequence` function for the Tree/Result combination.
    Luckily the creation of a sequence function is a mechanical process:'
  prefs: []
  type: TYPE_NORMAL
- en: For the lower type (`Result`) we need to define `apply` and `return` functions.
    See [here for more details](elevated-world.html#apply) on what `apply` means.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the higher type (`Tree`) we need to have a `cata` function, which we do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the catamorphism, each constructor of the higher type (`LeafNode` and `InternalNode`
    in this case) is replaced by an equivalent that is "lifted" to the `Result` type
    (e.g. `retn LeafNode <*> data`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here is the actual code -- don't worry if you can't understand it immediately.
    Luckily, we only need to write it once for each combination of types, so for any
    kind of Tree/Result combination in the future, we're set!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the actual `dtoToTree` function is simple -- just send the `treeDto`
    through `dtoToTreeOfResults` and then use `sequenceTreeOfResult` to convert the
    final result into a `Result<Tree<..>>`, which is just what we need.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 3: Transforming a `GiftDto` into a `Gift`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again we can use `Tree.map` to convert each leaf and internal node from a DTO
    to the proper domain type.
  prefs: []
  type: TYPE_NORMAL
- en: But our functions will handle errors, so they need to map a `GiftContentsDto`
    into a `Result<GiftContents>` and a `GiftDecorationDto` into a `Result<GiftDecoration>`.
    This results in a Tree of Results again, and so we'll have to use `sequenceTreeOfResult`
    again to get it back into the correct `Result<Tree<..>>` shape.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the helper methods (such as `strToChocolateType`) that convert
    a string into a proper domain type. This time, they return a `Result` rather than
    throwing an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: The case converter methods have to build a `Book` or `Chocolate` from parameters
    that are `Result`s rather than normal values. This is where lifting functions
    like `Result.lift2` can help. For details on how this works, see [this post on
    lifting](elevated-world.html#lift) and [this one on validation with applicatives](elevated-world-3.html#validation).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: And finally, the `dtoToGift` function itself is changed to return a `Result`
    if the `discriminator` is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: As before, this mapping creates a Tree of Results, so we pipe the output of
    the `Tree.map` through `sequenceTreeOfResult` ...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '... to return a Result of Tree.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the complete code for `dtoToGift`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: The type signature of `dtoToGift` has changed -- it now returns a `Result<Gift>`
    rather than just a `Gift`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 4: Assembling the pipeline'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can now reassemble the pipeline that takes a JSON string and creates a `Gift`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But changes are needed to work with the new error handling code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `fromJson` function returns a `Result<TreeDto>` but the next function in
    the pipeline (`dtoToTree`) expects a regular `TreeDto` as input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly `dtoToTree` returns a `Result<Tree>` but the next function in the
    pipeline (`dtoToGift`) expects a regular `Tree` as input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both case, `Result.bind` can be used to solve that problem of mis-matched
    output/input. See [here for a more detailed discussion of bind](elevated-world-2.html#bind).
  prefs: []
  type: TYPE_NORMAL
- en: Ok, let's try deserializing the `goodJson` string we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: That's fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see if the error handling has improved now. We''ll corrupt the JSON
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: Great! We get an nice `Failure` case.
  prefs: []
  type: TYPE_NORMAL
- en: Or what if a discriminator is wrong?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: or one of the values for the WrappingPaperStyle DU?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: Again, nice `Failure` cases.
  prefs: []
  type: TYPE_NORMAL
- en: What's very nice (and this is something that the exception handling approach
    can't offer) is that if there is more than one error, the various errors can be
    aggregated so that we get a list of *all* the things that went wrong, rather than
    just one error at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this in action by introducing two errors into the JSON string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: So overall, I'd say that's a success!
  prefs: []
  type: TYPE_NORMAL
- en: '*The source code for this example is available at [this gist](https://gist.github.com/swlaschin/2b06fe266e3299a656c1).*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen in this series how to define catamorphisms, folds, and in this post
    in particular, how to use them to solve real world problems. I hope these posts
    have been useful, and have provided you with some tips and insights that you can
    apply to your own code.
  prefs: []
  type: TYPE_NORMAL
- en: This series turned out to be a lot longer that I intended, so thanks for making
    it to the end! Cheers!
  prefs: []
  type: TYPE_NORMAL
