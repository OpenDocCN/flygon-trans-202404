- en: Specifics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具体内容
- en: Specifics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具体内容
- en: This section provides some more specific advice on various Java language features
    and gotchas.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了有关各种Java语言特性和陷阱的一些更具体的建议。
- en: A lot of what is covered in this section can be automated by tools such as FindBugs,
    PMD, Checkstyle and Sonar.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本节所涵盖的内容很大程度上可以由诸如FindBugs、PMD、Checkstyle和Sonar等工具自动化。
- en: Know How To Implement Hashcode And Equals
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 知道如何实现HashCode和Equals方法
- en: Know How to Implement Hashcode and Equals
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 知道如何实现HashCode和Equals方法
- en: Summary
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Implementing `hashCode` and `equals` is not straightforward. Do not implement
    them unless it is necessary to do so. If you do implement them, make sure you
    know what you are doing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 实现hashCode和equals方法并不简单。除非必须这样做，否则不要实现它们。如果实现了它们，请确保知道自己在做什么。
- en: Details
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详细信息
- en: It is well known that if you override equals then you must also override the
    `hashCode` method (see Effective Java item 9).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，如果重写equals方法，则必须同时重写`hashCode`方法（请参阅《Effective Java》条目9）。
- en: If logically-equal objects do not have the same `hashCode` they will behave
    in a surprising manner if placed in a hash based collection such as `HashMap`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果逻辑上相等的对象的`hashCode`不相同，它们在放入`HashMap`等基于哈希的集合中将表现出令人惊讶的行为。
- en: By "surprising", we mean your program will behave incorrectly in a fashion that
    is very difficult to debug.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过“令人惊讶”，我们指的是您的程序将以非常难以调试的方式表现出不正确的行为。
- en: Unfortunately, implementing `equals` is surprisingly hard to do correctly. Effective
    Java item 8 spends about 12 pages discussing the topic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，实现equals方法实际上很难做到正确。《Effective Java》条目8花了大约12页来讨论这个主题。
- en: The contract for equals is handily stated in the Javadoc of `java.lang.Object`.
    We will not repeat it here or repeat the discussion of what it means, that can
    be found in Effective Java and large swathes of the internet. Instead we will
    look at strategies for implementing it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: equals的合同在`java.lang.Object`的Javadoc中方便地说明了。我们将不在此重复或重复讨论其含义，这可以在《Effective
    Java》和互联网的大部分区域找到。相反，我们将看看实现它的策略。
- en: Whichever strategy you adopt, it is important that you first write tests for
    your implementation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 无论采用哪种策略，都很重要，您首先要为您的实现编写测试。
- en: It is easy for an equals method to cause hard-to-diagnose bugs if the code changes
    (e.g. if fields are added or their type changes). Writing tests for equals methods
    used to be a painful and time-consuming procedure, but libraries now exist that
    make it trivial to specify the common cases (see Testing FAQs).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码更改（例如添加字段或更改字段类型），equals方法很容易导致难以诊断的错误。编写equals方法的测试曾经是一项痛苦而耗时的过程，但现在存在着使其变得微不足道的库，可以规定常见情况（请参阅测试FAQ）。
- en: Don't
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要
- en: This is the simplest strategy and the one you should adopt by default in the
    interests of keeping your codebase small.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的策略，也是您应该默认采用的策略，以保持代码库的精简。
- en: Most classes do not need an equals method. Unless your class represents some
    sort of value it makes little sense to compare it with another so stick with the
    inherited implementation from Object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类不需要equals方法。除非您的类代表某种值，否则将其与另一个进行比较是毫无意义的，因此请使用从Object继承的实现。
- en: An irritating gray area are classes where the production code never has a requirement
    to compare equality but the test code does. The dilemma here is whether to implement
    the methods purely for the benefit of the tests or to complicate the test code
    with custom equality checks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个令人恼火的灰色区域是，生产代码从未要求比较相等性的类，但测试代码却需要。在这种情况下的困境是，是纯粹为了测试的利益而实现方法，还是为了测试代码而复杂化自定义相等性检查。
- en: There is, of course, no right answer here; we would suggest first trying the
    compare-it-in-the test approach before falling back to providing a custom equals
    method.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里没有正确答案；我们建议首先尝试测试比较方法，然后再提供自定义equals方法。
- en: The custom equality checks can be cleanly shared by implementing a custom assertion
    using a library such as AssertJ or Hamcrest.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用诸如AssertJ或Hamcrest之类的库实现自定义相等性检查可以干净地共享。
- en: Effective Java tentatively suggests having your class throw an error if equals
    is unexpectedly called
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 《Effective Java》暂时建议，如果意外调用了equals方法，则让您的类抛出错误。
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This seems like a good idea but, unfortunately, it will confuse most static
    analysis tools. On balance, it probably creates more problems than it solves.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是一个好主意，但不幸的是，它将使大多数静态分析工具混淆。总的来说，这可能带来更多问题。
- en: Auto-Generate With an IDE
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用IDE自动生成
- en: 'Most IDEs provide some method of auto-generating `hashCode` and `equals` methods.
    This is an easily-accessible approach, but the resulting methods are (depending
    on the IDE and its settings) often ugly and complex such as the ones generated
    by Eclipse shown below:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 IDE 都提供了一些自动生成 `hashCode` 和 `equals` 方法的方法。这是一种易于访问的方法，但是生成的方法（取决于 IDE 及其设置）通常很丑陋且复杂，例如下面
    Eclipse 生成的方法所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Unless your IDE can be configured to produce clean methods (as discussed below)
    we do not generally recommend this approach. It is easy for bugs to be introduced
    into this code by hand editing over time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您的 IDE 可以配置为生成清理的方法（如下所讨论），我们通常不建议使用此方法。随着时间的推移，手动编辑可能会在此代码中引入错误。
- en: Hand Roll Clean Methods
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动编写清理方法
- en: Java 7 introduced the `java.util.Objects` class that makes implementing `hashCode`
    trivial. Guava provides the similar `com.google.common.base.Objects` class which
    may be used with earlier versions of Java.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7 引入了 `java.util.Objects` 类，使得实现 `hashCode` 变得简单。Guava 提供了类似的 `com.google.common.base.Objects`
    类，可以与较早版本的 Java 一起使用。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Objects` class also simplifies implementing equals a little by pushing
    most null checks into the `Objects.equals` method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Objects` 类还通过将大多数空检查推送到 `Objects.equals` 方法中，稍微简化了实现 equals 的过程。'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first `if` statement is not logically required and could be safely omitted;
    it may, however, provide performance benefits.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `if` 语句在逻辑上并不是必需的，可以安全地省略；但是，它可能会提供性能优势。
- en: Usually, we would recommend that such micro-optimizations are not included unless
    they have been proven to provide a benefit. In the case of equals methods, we
    suggest that the optimization is left in place. It is likely to justify itself
    in at least some of your classes and there is value in having all methods follow
    an identical template.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们建议不要包含这种微小的优化，除非已经证明其具有益处。在 equals 方法的情况下，我们建议保留优化。在您的某些类中，这很可能是合理的，并且拥有所有方法遵循相同模板是有价值的。
- en: The example above uses `getClass` to check that objects are of the same type.
    An alternative is to use `instanceof` as follows
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例使用 `getClass` 检查对象是否是相同类型。另一种选择是使用 `instanceof`，如下所示
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This results in a behavioral difference - comparing instances of `MyClass` with
    its subclasses will return true with `instanceof` but false with `getClass`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了行为上的不同 - 使用 `instanceof` 比较 `MyClass` 及其子类的实例将返回 true，而使用 `getClass` 将返回
    false。
- en: In Effective Java Josh Bloch argues in favor of `instanceof` as the `getClass`
    implementation violates a strict interpretation of the Liskov substitution principle.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在《Effective Java》中，Josh Bloch 提倡使用 `instanceof`，因为 `getClass` 的实现违反了 Liskov
    替换原则的严格解释。
- en: 'However, if `instanceof` is used, it is easy for the symmetric property of
    the equals contract to be violated if a subclass overrides equals. i.e.:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果使用 `instanceof`，那么如果子类重写 equals，很容易违反 equals 合同的对称性。即：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you find yourself in a situation where you need to consider the nuances of
    whether subclasses are equal to their parents then we strongly suggest you reconsider
    your design.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己处于需要考虑子类是否等于其父类的情况下，请重新考虑您的设计。
- en: Having to think about maintaining the equals contract in a class hierarchy is
    painful and you shouldn't need to put yourself, or your team, through this for
    normal server-side coding tasks.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在类层次结构中考虑维护 equals 合同是痛苦的，您不应该需要为正常的服务器端编码任务而自己或您的团队这样做。
- en: In the majority of cases, if you think it makes sense for your class to implement
    `hashCode` and `equals`, we strongly suggest you make your class final so hierarchies
    do not need to be considered.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，如果您认为您的类实现 `hashCode` 和 `equals` 是有意义的，我们强烈建议您将类声明为 final，以便不需要考虑层次结构。
- en: If you believe you have a case where it makes sense for subclasses to be treated
    as equivalent to their parent, use `instanceof` but ensure that the parent equals
    method is made final.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为有必要将子类视为与其父类等价的情况，请使用 `instanceof`，但确保父类的 equals 方法被声明为 final。
- en: Avoid relationships that are more complex than this.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 避免比这更复杂的关系。
- en: Commons EqualsBuilder and HashCodeBuilder
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Commons EqualsBuilder 和 HashCodeBuilder
- en: The Apache commons hashcode and equals builders were once a popular way of generating
    these methods. We do not recommend their use in new code as most of what they
    achieved is now provided by `java.util.Objects` without bringing in a 3rd party
    library, or by the Guava equivalent.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Apache commons的hashcode和equals构建器曾经是生成这些方法的一种流行方式。我们不建议在新代码中使用它们，因为它们的大部分功能现在已由`java.util.Objects`提供，而不需要引入第三方库，或者通过Guava等价物提供。
- en: These classes do provide the option of a single line reflection based implementation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类确实提供了基于单行反射的选项实现。
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The brevity of these implementations is attractive, but their performance is
    measurably poorer than others discussed so far. Good performance tests and regular
    profiling can help determine whether a poorly performing method genuinely leads
    to performance bottlenecks in your application. If you are confident that you
    would detect such adverse impacts then using these methods as initial placeholder
    implementations may be a reasonable approach. But in general we suggest you avoid
    them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实现的简洁性是有吸引力的，但其性能明显较差。良好的性能测试和定期的分析可以帮助确定一个性能较差的方法是否真正导致了应用程序的性能瓶颈。如果您确信您会检测到这些不利影响，那么使用这些方法作为初始占位符实现可能是一个合理的方法。但总的来说，我们建议您避免使用它们。
- en: Code Generators
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码生成器
- en: 'A number of projects exist that can auto-generate value objects at build-time.
    Two of the better known options are :'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多项目可以在构建时自动生成值对象。其中两个较为知名的选项是：
- en: '[Google auto](https://github.com/google/auto/tree/master/value)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Google auto](https://github.com/google/auto/tree/master/value)'
- en: '[Project Lombok](https://projectlombok.org/)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Project Lombok](https://projectlombok.org/)'
- en: But many others are available.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有许多其他的选择。
- en: Google Auto
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Google Auto
- en: Google *Auto* will create a subclass with the *obvious* implementation of an
    abstract class annotated with `@AutoValue`. This implementation will include functioning
    `hashcode` and `equals` methods.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Google *Auto* 将创建一个带有`@AutoValue`注解的抽象类的*明显*实现的子类。此实现将包括功能性的`hashcode`和`equals`方法。
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is clearly far less effort than hand crafting a complete `Animal` class,
    but there are some downsides.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然比手工制作一个完整的`Animal`类要少努力，但也有一些缺点。
- en: Some of the issues with code generators are discussed in "Consider Code Generators
    Carefully", which categorized them into *friction* and *surprise*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一些与代码生成器相关的问题在 "谨慎考虑代码生成器" 中进行了讨论，将其分类为*摩擦*和*意外*。
- en: Here, Google Auto introduces some *friction* as the code shown above will not
    compile within an IDE until the generator has run to produce the `AutoValue_Animal`
    class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Google Auto引入了一些*摩擦*，因为上面显示的代码在IDE中无法编译，直到生成器运行以产生`AutoValue_Animal`类为止。
- en: There is also some *surprise*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些*意外*。
- en: Because it is a value, Animal would normally be implemented as a final class
    - but we have been forced to make it abstract. The team behind *Auto* recommend
    you add a package-private constructor to prevent other child classes being created.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是一个值，Animal通常会被实现为一个final类 - 但我们被迫将其设置为抽象类。 *Auto* 团队建议您添加一个包私有的构造函数以防止其他子类被创建。
- en: Unlike normal Java, the order in which accessors are declared is important because
    it is used by the generator to define the order of the constructor parameters.
    Re-ordering the accessors can, therefore, have the surprising effect of introducing
    a bug.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通的Java不同，访问器的声明顺序很重要，因为生成器使用它来定义构造函数参数的顺序。因此，重新排序访问器可能会产生引入错误的令人惊讶的效果。
- en: Lombok
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Lombok
- en: Lombok can also (amongst other things) generate full implementations of value
    objects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Lombok也可以（除其他事项外）生成值对象的完整实现。
- en: It takes a different approach to Google auto.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它采用了与Google auto不同的方法。
- en: 'Given an annotated class such as:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个如下所示的带注解的类：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It will alter the class at build-time to produce an implementation along the
    lines of:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在构建时修改类以生成一个类似以下的实现：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While Google *Value* asks the programmer to provide a valid public API for a
    class, *Lombok* creates the public API based on a description of its internal
    state. The description is valid Java syntax but has a different meaning when interpreted
    by Lombok.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Google *Value* 要求程序员为一个类提供一个有效的公共API，但*Lombok* 根据其内部状态的描述创建了公共API。该描述是有效的Java语法，但在Lombok解释时具有不同的含义。
- en: '*Lombok* causes some friction. It is not practical to use *Lombok* without
    an IDE that understands it - code using the autogenerated api will appear to be
    invalid. An IDE plugin must be installed.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lombok*会引起一些摩擦。在没有理解它的IDE的情况下，使用*Lombok*是不现实的 - 使用自动生成的API的代码将看起来是无效的。必须安装一个IDE插件。'
- en: While it (arguably) introduces less friction than auto once the IDE plugin is
    installed, the behavior of *Lombok* is much more surprising. It is easy to explain
    what *Auto* does - it generates a class at build-time that implements an interface
    you define. It is much harder to predict or explain what *Lombok* will do.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了IDE插件，它（可以说）比auto引入的摩擦更小，但*Lombok*的行为更加令人惊讶。解释*Auto*的作用很容易 - 它在构建时生成一个实现您定义的接口的类。预测或解释*Lombok*将做什么要困难得多。
- en: Although *Lombok* requires the programmer to write less code than solutions
    such as *Auto*, it deviates further from normal Java.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*Lombok*要求程序员编写的代码比*Auto*等解决方案少，但它与普通Java的偏离更大。
- en: If you consider using a code generator for Value classes, we would recommend
    you consider approaches such as *Auto* before *Lombok*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果考虑使用代码生成器生成Value类，我们建议您在考虑*Lombok*之前考虑*Auto*等方法。
- en: To its credit *Lombok* does provide an escape route (see "Prefer reversible
    decisions") in the form of delombok which allows you to output the generated classes.
    These can then be used to replace the annotated originals.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 值得称赞的是，*Lombok*提供了一个逃生通道（见“更喜欢可逆决策”），即`delombok`，它允许你输出生成的类。然后可以用这些类替换被注解的原始类。
- en: Removing *Auto* is similarly straightforward - the generated classes can be
    checked into the source tree. The artificial abstract class/implementation split
    can then be removed via simple refactorings.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，去除*Auto*也很简单 - 生成的类可以检入源代码树。然后可以通过简单的重构来删除人为的抽象类/实现分离。
- en: Do Not Reassign Parameters
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要重新分配参数
- en: Do Not Re-Assign Parameters
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要重新分配参数
- en: Summary
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Parameters to methods should never be re-assigned.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的参数不应该被重新分配。
- en: Detail
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详情
- en: Reassigning to parameters makes code harder to understand and provides no meaningful
    advantage over creating a new variable.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重新分配参数会使代码难以理解，并且与创建新变量相比没有任何有意义的优势。
- en: If the method is large, it can be difficult to track the lifecycle of a parameter.
    Even within short methods, re-using parameters will cause problem. As the variable
    is being used to represent two separate concepts, it is often not possible to
    name it meaningfully.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法很大，跟踪参数的生命周期可能会很困难。即使在短方法中，重复使用参数也会导致问题。由于变量用于表示两个不同的概念，通常无法有意义地命名它。
- en: If another variable of the same type as a parameter is needed, it should be
    declared locally.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要另一个与参数相同类型的变量，应该在本地声明。
- en: '**Bad**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**糟糕**'
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Better**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好**'
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Parameters may be declared final so that the reader can tell at a glance that
    its value will not change.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以声明为final，以便读者一眼就能看出其值不会改变。
- en: Limit Scope
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制作用域
- en: Limit Variables to the Smallest Possible Scope
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将变量限制在尽可能小的作用域内
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Variables should be declared as late as possible so that they have the narrowest
    possible scope.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 变量应该尽可能晚声明，以便它们具有尽可能狭窄的作用域。
- en: Details
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详情
- en: '*Bad*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*糟糕*'
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Better*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*更好*'
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Better still*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*更好*'
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Sometimes, assigning to well-named, temporary variables will result in more
    readable code than calling a method inline because it helps the reader follow
    the data and logical flow.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将值赋给命名良好的临时变量会比内联调用方法产生更易读的代码，因为它有助于读者跟踪数据和逻辑流程。
- en: As a rule of thumb, if you are unable to come up with a name for a variable
    that does little more than mirror a method from which its value was retrieved,
    then the variable should be eliminated.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，如果你无法为一个变量想出一个名字，而这个变量几乎只是从一个方法中获取值，那么这个变量应该被消除。
- en: Prefer For Each Loops To For Loops
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更喜欢使用`for each`循环而不是`for`循环
- en: Prefer For-Each Loops to For Loops
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更喜欢使用`for each`循环而不是`for`循环
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Use `for each` loops in preference to indexed for loops.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 更喜欢使用`for each`循环而不是索引`for`循环。
- en: Details
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详情
- en: The `for each` loop introduced with Java 5 avoids the potential out-by-one errors
    of indexed for loops and is more concise than code using iterators.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Java 5引入的`for each`循环避免了索引for循环可能出现的偏差问题，并且比使用迭代器的代码更简洁。
- en: '*Bad*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*糟糕*'
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*A little better*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*稍微好一点*'
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Prefer Maps And Filters To Imperative Loops
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更喜欢使用Maps和Filters而不是命令式循环
- en: Prefer Maps and Filters to Imperative Loops
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更喜欢使用Maps和Filters而不是命令式循环
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Imperative loops hide application logic inside boilerplate code - prefer maps
    and filters as these separate the logic from the implementation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式循环将应用程序逻辑隐藏在样板代码中 - 更喜欢映射和过滤器，因为它们将逻辑与实现分离。
- en: Details
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 细节
- en: Most loop based code can be re-written in a more declarative style using filters
    and maps.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基于循环的代码可以使用过滤器和映射以更声明式的方式重写。
- en: Java 8 made this easy by introducing lambdas and the streams API, but the same
    style can be applied in Java 7 using anonymous inner classes and third party libraries
    such as Guava.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8通过引入lambda和streams API使这变得容易，但是在Java 7中也可以使用匿名内部类和第三方库（如Guava）来应用相同的风格。
- en: Filters and maps highlight what the code is intended to achieve. This is less
    clear in the imperative implementation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器和映射突出了代码的预期目标。这在命令式实现中不太明显。
- en: '**Bad**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**糟糕**'
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Better (Java 8)**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好（Java 8）**'
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Better (Java 7 using Guava)**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好（Java 7使用Guava）**'
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that, although the Java 7 version requires more lines of code (in the form
    of the ugly boilerplate for the anonymous inner class), the logic of the `selectValues`
    method is clearer. If the logic required in the Predicate or mapping Function
    is required in multiple places then it is straightforward to move this to a common
    location. This is harder to achieve with the imperative version.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管Java 7版本需要更多的代码行数（以丑陋的匿名内部类的形式出现），但`selectValues`方法的逻辑更清晰。如果在多个地方需要Predicate或mapping
    Function中的逻辑，则可以轻松将其移至公共位置。这在命令式版本中更难实现。
- en: Also note that the method that creates the Predicate has been made static. It
    is a good idea to do this, where possible, when returning an anonymous class to
    prevent a long lived instance preventing the parent class from being garbage collected.
    Although the Predicate is only short-lived in this instance, applying static dogmatically
    in all cases avoids the overhead of thinking.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，创建Predicate的方法已经被设为静态的。在返回匿名类时，将其设为静态是一个好主意，以防止长时间的实例阻止父类被垃圾回收。虽然在这个例子中Predicate只是短暂存在，但在所有情况下都敷衍地应用静态可以避免思考的开销。
- en: Avoid Apis From Prehistory
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用史前的API
- en: Avoid APIs from Pre-History
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用史前的API
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Do not use `Vector`, `StringBuffer` and other archaic parts of the JDK.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用`Vector`，`StringBuffer`和JDK的其他过时部分。
- en: Details
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 细节
- en: Java has been around for over 20 years. In order to maintain backwards compatibility,
    it has hoarded all manner of APIs that no longer make sense to use. Some of them
    are handily marked with @Deprecated annotation, others are not.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Java已经存在了20多年。为了保持向后兼容性，它积累了各种各样的API，这些API现在不再合理使用。其中一些方便地标有@Deprecated注解，其他则没有。
- en: 'Unfortunately, many are still used in university courses and online examples.
    New Java programmers may not be aware they have been replaced - a few to watch
    out for include:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，许多人仍然在大学课程和在线示例中使用它们。新的Java程序员可能不知道它们已经被替换了 - 一些需要注意的包括：
- en: '`java.util.Vector` - use `ArrayList` instead'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Vector` - 使用`ArrayList`代替'
- en: '`java.lang.StringBuffer` - use `StringBuilder` instead'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.StringBuffer` - 使用`StringBuilder`代替'
- en: '`java.util.Stack` - use a `Dequeue` (e.g. `ArrayDeqeue`)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Stack` - 使用`Dequeue`（例如`ArrayDeqeue`）'
- en: '`java.util.Hashtable` - use a `Map` (e.g. `HashMap`)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Hashtable` - 使用`Map`（例如`HashMap`）'
- en: '`java.util.Enumeration` - use an `Iterator` or an `Iterable`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.Enumeration` - 使用`Iterator`或`Iterable`'
- en: Each of these replacements (except `Enumeration`) differ from the originals
    by not being synchronized. If you think you need a synchronized collection go
    away somewhere quiet and think again.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些替换（除了`Enumeration`）与原始内容不同，因为它们没有同步。如果你认为你需要一个同步的集合，请找个安静的地方思考一下。
- en: Beware Casts And Generics Warnings
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意转换和泛型警告
- en: Beware Casts and Generics Warnings
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注意转换和泛型警告
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Casts dilute the benefit of Java's type system, making code both less readable
    and less safe.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 转换削弱了Java类型系统的好处，使代码既不易读也不安全。
- en: Avoid casts wherever possible.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能避免转换。
- en: If you find yourself writing one, stop and ask yourself why you are writing
    it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己正在编写一个，请停下来问问自己为什么要写它。
- en: What would need to be changed in your code so you did not need to write that
    cast?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中需要做哪些改变，以便你不需要编写该转换？
- en: Why can't you make that change?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你不能做出那个改变？
- en: Detail
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 细节
- en: Java's type system is there to help us - it catches bugs at compile-time and
    documents our code, making it easier to understand and navigate.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Java的类型系统是为了帮助我们 - 它在编译时捕获错误并记录我们的代码，使其更容易理解和导航。
- en: When we add a cast to our code, we lose both these benefits.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向代码添加转换时，我们失去了这两个好处。
- en: 'Casts get introduced into code for three main reasons:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 强制转换会出现在代码中的三个主要原因：
- en: We have reached the limits of Java's type system and the programmer must take
    control
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经达到了Java类型系统的极限，程序员必须控制
- en: The overall design of the code is poor
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的整体设计很差
- en: The code uses raw generic types
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码使用原始泛型类型
- en: We'll look at these in reverse order.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以相反的顺序查看这些问题。
- en: Code with Raw Types
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 具有原始类型的代码
- en: If code contains raw generic types (either because the code pre-dates Java 5
    or the programmer is not familiar with Java) then it will create the need to cast.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码包含原始泛型类型（要么是因为代码早于Java 5，要么是因为程序员不熟悉Java），那么将需要进行强制转换。
- en: 'For example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The compiler will not be happy that we have failed to fully declare the type
    of `List` we are dealing with and will (depending on how it's been configured)
    generate an error or warning on the line where `list` is declared e.g.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不会高兴我们未能完全声明我们正在处理的`List`类型，并且将（取决于如何配置）在声明`list`的行上生成错误或警告，例如。
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Similarly, for errant code such as:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于错误的代码，例如：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The compiler will issue:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将发出：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Make sure that all such warnings are addressed, either by imposing a zero compiler
    warnings policy or by configuring the compiler to treat them as errors.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 确保所有这些警告都得到解决，可以通过实施零编译器警告政策或通过配置编译器��其视为错误来解决。
- en: 'In this case, removing both the cast and the warning is straight forward:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，移除强制转换和警告都很简单：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Poor Design
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设计不佳
- en: Sometimes, removing a cast or fixing a warning is non-trivial. We have bumped
    into issue two - poor design.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，移除强制转换或修复警告并不是一件简单的事情。我们遇到了第二个问题 - 设计不佳。
- en: 'For example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Normally, objects placed into a collection should be of a single type or of
    multiple types related by a common superclass or interface.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，放入集合中的对象应该是单一类型或由共同的超类或接口相关的多种类型。
- en: Here, unrelated types have been placed into the same list with a String used
    to communicate some sort of information about how "processing" of a widget has
    failed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，不相关的类型被放入同一个列表中，使用字符串来传达有关如何“处理”小部件失败的某种信息。
- en: The classic OO fix for this code would be to introduce a `ProcessResult` interface
    with two concrete implementations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的经典OO修复方法是引入一个具有两个具体实现的`ProcessResult`接口。
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The original code can then be fixed as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以修复原始代码如下：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or, more concisely in Java 8:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在Java 8中更简洁地表示为：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It may also sometimes make sense to use a disjoint union type aka `Either`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有时使用不相交联合类型，也称为`Either`，也是有道理的。
- en: This technique can be particularly useful as an interim step when reworking
    legacy code that uses mixed type raw collections, but can also be a sensible approach
    when dealing with error conditions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在重新处理使用混合类型原始集合的遗留代码时可以特别有用，但在处理错误条件时也是一个明智的方法。
- en: 'Unfortunately, Java does not provide an `Either` type out of the box but at
    its simplest it looks something like:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Java没有提供一个内置的`Either`类型，但在其最简单的形式下看起来是这样的：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Libraries such as Atlassian's Fugue provide implementations with much richer
    functionality.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Atlassian的Fugue等库提供了功能更丰富的实现。
- en: 'Using the simplistic form of `Either` with Java 7 the code could be re-written
    as:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java 7中简单形式的`Either`，代码可以重写为：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'While most Java programmers will prefer the earlier OO version, this version
    has two advantages:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数Java程序员更喜欢早期的OO版本，但这个版本有两个优点：
- en: It requires no change to the *structure* of the original code - all we have
    really done is make the types document what is happening
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这不需要改变原始代码的*结构* - 我们实际上所做的只是让类型记录正在发生的事情
- en: It requires less code
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它需要更少的代码
- en: This pattern can help quickly tame a legacy code base that is difficult to comprehend.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可以帮助快速驯服难以理解的遗留代码库。
- en: Limits of the Type System
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 类型系统的限制
- en: Sometimes we do reach the limits of Java's type system and need to cast.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们确实会达到Java类型系统的极限，需要进行强制转换。
- en: Before we do this, we must make certain that the cast is safe and there is no
    better solution to our problem.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此操作之前，我们必须确保强制转换是安全的，并且没有更好的解决方案。
- en: Similarly, we may need to sometimes suppress a Generics warning, this can be
    done by annotating with `@SuppressWarnings` e.g.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，有时我们可能需要抑制泛型警告，可以通过使用`@SuppressWarnings`进行注释来实现，例如。
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, the compiler has no way of knowing what type has been serialized to the
    String. Hopefully the programmer does or else a runtime error will occur.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，编译器无法知道已将什么类型序列化为字符串。希望程序员知道，否则将会发生运行时错误。
- en: Do Not Use Magic Numbers
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要使用魔法数字
- en: Do Not Use Magic Numbers
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要使用魔法数字
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Magic numbers should be replaced with well-named constants that describe their
    meaning.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法数字应该替换为描述其含义的良好命名的常量。
- en: Detail
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 详细
- en: 'Placing numeric or string literals directly into source code causes two problems:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字或字符串字面量直接放入源代码中会引起两个问题：
- en: It is unlikely that the **meaning** of the literal will be clear
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文字的**意义**很可能不会清晰。
- en: If the value changes updates are required where ever the literal has been duplicated
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果值发生变化，则需要更新所有重复了文字的地方。
- en: Literals should therefore be replaced with well-named constants and Enums.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，文字应该用良好命名的常量和枚举替换。
- en: '**Bad**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**不好**'
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Better**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好的**'
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**You''ve missed the point**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**你误解了重点**'
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If the constants you extract relate to an identifiable concept, create an Enum
    instead:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您提取的常量与可识别的概念相关，请改用枚举：
- en: '**Good**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**好的**'
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Some coding standards make statements such as "0 and 1 are exceptions to this
    rule". This is, however, an oversimplification.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编码标准会说出诸如“0和1是此规则的例外”的声明。然而，这是一个过于简化了的说法。
- en: 'Sometimes 0 and 1 will have a clear local meaning as they are being used as
    part of low level code e.g.:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，0和1会作为低级代码的一部分具有清晰的局部含义，例如：
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: But 0 and 1 may also have domain-specific values that should be extracted into
    constants like any other literal.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，0和1也可能具有特定于域的值，应该像任何其他文字一样提取为常量。
- en: 'Server-side Java can also often be re-written in a cleaner fashion without
    the use of numeric literals, e.g.:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端Java通常也可以以更清晰的方式进行重写，而无需使用数字字面量，例如：
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Do Not Use The Assert Keyword
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要使用Assert关键字
- en: Don't Use the Assert Keyword
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要使用Assert关键字
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Assertions are a useful coding technique that can provide many benefits but
    in most circumstances it is better to implement them using third party libraries
    rather than the `assert` keyword.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是一种有用的编码技术，可以提供许多好处，但在大多数情况下，最好使用第三方库而不是`assert`关键字来实现它们。
- en: Details
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详细信息
- en: Assertions written with the assert keyword are only enabled when the `-ea` JVM
    flag is set.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`assert`关键字编写的断言仅在设置了`-ea` JVM标志时启用。
- en: The intent of this flag is to allow the assertions to be enabled in development
    and testing but disabled in production to avoid the performance overhead of assertion
    logic. This is usually a premature optimization and increases the opportunity
    for mistakes as the code will behave differently in development vs production.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此标志的意图是允许在开发和测试中启用断言，但在生产中禁用以避免断言逻辑的性能开销。这通常是一种过早的优化，并增加了错误的机会，因为代码在开发和生产中的行为将有所不同。
- en: Switching off assertions in production also greatly dilutes their value. If
    a coding error has been made assertions ensure that it is reported early, close
    to the bug. If assertions are turned off in production bugs may propagate silently.
    This may make their consequences more severe and will certainly make the issue
    harder to diagnose.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中关闭断言也会大大削弱它们的价值。如果出现编码错误，断言可确保其尽早报告，接近错误。如果在生产中关闭断言，则错误可能会悄悄传播。这可能会使其后果更严重，并且肯定会使问题更难以诊断。
- en: So for these reasons, unless you are working in a very performance sensitive
    domain, assertions should always be enabled.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，出于这些原因，除非您正在处理非常注重性能的域，否则应始终启用断言。
- en: For always-on assertions third party libraries such as Guava's preconditions
    provide a better solution than the `assert` keyword.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用诸如Guava的前置条件等第三方库提供的解决方案比`assert`关键字更好。
- en: A separate issue is the use of the `assert` keyword in tests. This is usually
    the result of a lack of familiarity with Java and JUnit.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是在测试中使用`assert`关键字。这通常是对Java和JUnit不熟悉的结果。
- en: In codebases found in the wild where `assert` has been used in tests the `-ea`
    flag is rarely set, meaning that the tests can never fail. For tests JUnit's built
    in assertions or modern test focused assertion libraries such as AssertJ should
    always be used.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在野外找到的代码库中，如果在测试中使用了`assert`，则很少设置`-ea`标志，这意味着测试永远不会失败。对于测试，应始终使用JUnit的内置断言或现代面向测试的断言库，例如AssertJ。
- en: Avoid Floats And Doubles
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用浮点数和双精度数
- en: Avoid Floats and Doubles
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用浮点数和双精度数
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Avoid using floats and doubles (both the primitives and their wrappers).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用浮点数和双精度数（原始数据类型和其包装器）。
- en: Detail
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详细信息
- en: Floats and doubles introduce a minefield of rounding and comparison issues.
    While they are a sensible choice for some domains where you do not care about
    rounding errors integers or `BigDecimal` are usually a better choice for server-side
    business code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数和双精度数引入了一系列舍入和比较问题。虽然它们对于一些领域是明智的选择，其中你不关心舍入误差，但对于服务器端业务代码来说，整数或`BigDecimal`通常是更好的选择。
- en: The core issue is that floating point numbers are not able to represent many
    numbers (e.g. `0.1`).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 核心问题在于浮点数无法表示许多数字（例如`0.1`）。
- en: This leads to unexpected results that may not be caught by simple test cases
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致意想不到的结果，可能不会被简单的测试用例捕捉到。
- en: '[PRE40]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: But
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 但是
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The simplest solution in this case would be to replace the floats with integer
    values (i.e. track the balance in units of cents rather than dollars).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下最简单的解决方案是用整数值替换浮点数（即以分为单位跟踪余额，而不是以美元为单位）。
- en: In situations where floats can't be replaced by integers code can be re-written
    to use `BigDecimal`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在无法用整数替换浮点数的情况下，代码可以重写以使用`BigDecimal`。
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that although `BigDecimal` can be constructed from a float this would take
    us back to where we started.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管`BigDecimal`可以从浮点数构造，但这会让我们回到起点。
- en: '[PRE43]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When to use floats and doubles
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时使用浮点数和双精度数
- en: Floats and doubles clearly can't be all bad or it is unlikely that they would
    have been included in the Java language.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数和双精度数显然不可能全都是坏的，否则它们不太可能被包含在Java语言中。
- en: The primitive floating point types have performance advantages over `BigDecimal`
    that can be significant in highly numerical domains such as machine learning,
    physics engines, scientific applications etc. In these domains the performance
    benefit may greatly out-weigh the additional risk of error.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 原始浮点类型在高度数值领域（如机器学习、物理引擎、科学应用等）比`BigDecimal`具有性能优势，这些领域中性能优势可能远远超过额外错误风险。
- en: Code using `BigDecimal` is also inherently more verbose and clumsy than code
    that uses primitives. If you are working in a domain where the imprecision of
    floating point types is acceptable you might prefer the cleaner code they allow,
    but be sure you are making this choice consciously with an understanding of the
    pitfalls involved.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BigDecimal`的代码也本质上比使用基本类型的代码更冗长和笨拙。如果你在一个可以接受浮点类型不精确的领域工作，你可能更喜欢它们允许的更干净的代码，但请确保你在理解相关风险的情况下有意识地做出这个选择。
- en: Do Not Use Reflection
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要使用反射。
- en: Don't use Reflection
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要使用反射。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Do not use reflection in your code (i.e. anything from the `java.lang.reflect`
    package).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在你的代码中使用反射（即`java.lang.reflect`包中的任何内容）。
- en: Details
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详情
- en: Reflection is a powerful tool; it allows Java to do things that would otherwise
    be either impossible or require large amounts of boilerplate code.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是一个强大的工具；它使Java能够做一些否则要么是不可能的，要么需要大量样板代码的事情。
- en: But, while it is sometimes useful when creating a framework or library it is
    unlikely to be a good way to solve the types of problem we encounter in normal
    server-side application code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，虽然在创建框架或库时有时很有用，但它不太可能是解决我们在正常服务器端应用代码中遇到的问题的好方法。
- en: So why would we want to avoid using a powerful tool that Java provides?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们要避免使用Java提供的强大工具呢？
- en: 'Reflection has three main drawbacks:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 反射有三个主要缺点：
- en: Loss of Compile Time Safety
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编译时安全性的丧失
- en: Reflection moves errors from compile time to runtime - this is a Bad Thing ™
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 反射将错误从编译时移至运行时 - 这是一件坏事™。
- en: The compiler is our first form of defense against defects and the type system
    is one of the most effective tools we have to document our code. We should not
    throw these things away lightly.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器是我们防范缺陷的第一道防线，类型系统是我们用来记录代码的最有效工具之一。我们不应该轻易放弃这些东西。
- en: Loss of Refactor Safety
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重构安全性的丧失
- en: Refactoring and code analysis tools are blind to reflection.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 重构和代码分析工具对反射是盲目的。
- en: Although they may make some attempt to take it into account, the additional
    possibilities reflection creates for how a program might behave means the tools
    can no longer provide rigorous guarantees that they have understood the program.
    In the presence of reflection refactorings that would otherwise be safe may change
    program and analysis tools may report incorrect results.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们可能会尝试考虑到这一点，反射为程序可能的行为方式带来的额外可能性意味着工具不再能提供对程序理解的严格保证。在存在反射的情况下，否则安全的重构可能会改变程序，分析工具可能会报告不正确的结果。
- en: Harder Code Comprehension
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更难理解的代码
- en: In the same way that Reflection makes it harder for automated tools to understand
    code, it also makes it harder for humans to understand code.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 就像反射使得自动化工具更难理解代码一样，它也使得人类更难理解代码。
- en: Reflection introduces surprises.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 反射会带来意外。
- en: '*This method is never called, I can safely delete it.* Oh. Reflection.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个方法从未被调用，我可以安全地删除它。* 哦。反射。'
- en: '*I can safely change the behavior of this private method as I know where it
    is called from.* Oh. Reflection.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*我可以安全地更改这个私有方法的行为，因为我知道它是从哪里调用的。* 哦。反射。'
- en: Know The JDK One Liners
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 JDK 的一行代码
- en: Know common one liners
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解常见的一行代码
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: The JDK contains a number of utility functions that should be used to replace
    more verbose code.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 包含了一些应该用来替换更冗长代码的实用函数。
- en: Details
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详情
- en: As discussed in "Optimize for Readability not Performance" we should prefer
    simple code to more complex code that we think might be more efficient (unless
    we have demonstrated that the more complex code has a real benefit via profiling
    and performance testing).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如“优化可读性而非性能”中所讨论的，我们应该更倾向于简单的代码而不是我们认为可能更高效的复杂代码（除非我们通过分析和性能测试证明更复杂的代码确实有真正的好处）。
- en: Sometimes however we find ourself in the happy situation where we do not need
    to make a trade off between the clarity of our code and (presumed) performance.
    Sometimes there is also reason to believe that cleanest version of the code might
    also be slightly more efficient.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们会发现自己处于一种幸福的情况，我们不需要在代码的清晰度和（假定的）性能之间做出权衡。有时候，也有理由相信代码的最清晰版本可能也稍微更高效。
- en: There are a number of small functions scattered around the JDK that are both
    cleaner than the code they are commonly used to replace, and also possible slightly
    more efficient. These should be used whenever possible, and once you know they
    are there any code that doesn't use them looks will look slightly wrong.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 中散布着许多小函数，它们比通常用来替代的代码更清晰，可能稍微更高效。应尽可能使用这些函数，一旦您知道它们的存在，任何不使用它们的代码看起来都会有些不对劲。
- en: Most IDEs will prompt you to use some or all of these one liners.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数集成开发环境（IDEs）都会提示您使用这些一行代码中的一部分或全部。
- en: java.util.Arrays.asList
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: java.util.Arrays.asList
- en: For when you need to convert an array to a fixed size list.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要将数组转换为固定大小列表时。
- en: List <string class="hljs-class">ss = Arrays.asList(“1”, “2”);</string>
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: List <string class="hljs-class">ss = Arrays.asList(“1”, “2”);</string>
- en: 'This is cleaner and more efficient than the commonly seen alternatives such
    as:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这比通常见到的替代方法更清晰、更高效，比如：
- en: List <string class="hljs-class">ss = new ArrayList<>(); ss.add(“1”); ss.sdd(“2”);</string>
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: List <string class="hljs-class">ss = new ArrayList<>(); ss.add(“1”); ss.sdd(“2”);</string>
- en: The list implementation returned by `asList` is specialized and may consume
    slightly less memory than an ArrayList.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`asList` 返回的列表实现是专门的，可能比 ArrayList 消耗稍微更少的内存。'
- en: Be aware that the lists created by this method are not fully immutable. They
    are fixed size and will throw a java.lang.UnsupportedOperation if you try to add
    or remove members, but modifying methods such as `set` will succeed.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此方法创建的列表并非完全不可变。它们是固定大小的，如果尝试添加或删除成员，将抛出 java.lang.UnsupportedOperation，但修改方法如
    `set` 将成功。
- en: If you are working with Java 9 the `List.of` methods provide a superior alternative.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Java 9，`List.of` 方法提供了一个更优越的替代方案。
- en: java.util.Collections.empty*
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: java.util.Collections.empty*
- en: The `java.util.Collections` class contains methods that create unmodifiable
    versions of the common collections classes specialized to contain either no entries
    or single entries.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Collections` 类包含了创建不可修改版本的常见集合类的方法，专门用于包含零个条目或单个条目。'
- en: 'The most common ones are:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的是：
- en: '`emptyMap`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emptyMap`'
- en: '`emptyList`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emptyList`'
- en: '`emptySet`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emptySet`'
- en: '`singletonList`'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`singletonList`'
- en: '`singletonMap`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`singletonMap`'
- en: '`singletonSet`'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`singletonSet`'
- en: But there are other more specialized methods there as well.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 但也有其他更专业的方法。
- en: Again, using these results in cleaner more descriptive code compared to the
    common alternatives and the specialized data structures returned may have a slightly
    smaller footprint.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，与常见的替代方法和返回的专用数据结构相比，使用这些方法会产生更清晰、更描述性的代码，而且可能具有稍微更小的占用空间。
- en: If you are working with Java 9 the static `of` methods provide a superior alternative
    to the single entry methods.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Java 9，静态的 `of` 方法提供了一个更优越的替代方案来替代单个条目的方法。
- en: valueOf
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: valueOf
- en: 'The form:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 形式：
- en: '[PRE44]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Is slightly more efficient than the subjectively uglier:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在主观上更丑陋的情况下，这比稍微更高效：
- en: '[PRE45]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`valueOf` will return one of two fixed Boolean instances while calling the
    constructor will always allocate a new object.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`valueOf`将返回两个固定的布尔实例之一，而调用构造函数将始终分配一个新对象。'
- en: Similarly for Integers `valueOf` will return a shared instance for values between
    -128 and 127.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于整数，`valueOf`将为-128到127之间的值返回一个共享实例。
- en: '`Long.valueOf` will similarly return objects from a cache.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`Long.valueOf`同样会从缓存中返回对象。'
- en: The Oracle JDK does not currently look to use a cache for Floats or Doubles
    when calling `valueOf`. So using `valueOf` in preference to new for floating points
    might not have an advantage, but it has no disadvantage either.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle JDK目前在调用`valueOf`时不使用缓存来存储浮点数或双精度数。因此，与为浮点数使用`new`相比，使用`valueOf`可能没有优势，但也没有劣势。
- en: Overloaded versions of the `valueOf` methods construct their desired types from
    Strings. If you need to create a boxed primitive from a String, this is the way
    to do it.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`valueOf`方法的重载版本从字符串构造所需的类型。如果您需要从字符串创建装箱的原始类型，这就是方法。'
- en: It is worth noting that, although it is not guaranteed by the spec, in practice
    Java compilers implement auto boxing by calling `valueOf`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，尽管规范没有保证，但实际上Java编译器通过调用`valueOf`来实现自动装箱。
- en: 'So:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 因此：
- en: '[PRE46]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: and
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 并且
- en: '[PRE47]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Are equivalent.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 是等价的。
- en: As of Java 9 the boxed primitive constructors are deprecated in favour of the
    `valueOf` and parse methods (see below).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java 9开始，装箱的原始类型构造函数已被弃用，而是推荐使用`valueOf`和解析方法（见下文）。
- en: parseXXX
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: parseXXX
- en: Similar to `valueOf` the `parseXXX` methods convert a string to a primitive,
    only in this case the primitive is not boxed.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 与`valueOf`类似，`parseXXX`方法将字符串转换为原始类型，只是在这种情况下，原始类型没有被装箱。
- en: '[PRE48]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This does exactly what the method says, and compared to the commonly seen alternative:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是方法所说的，与常见的替代方法相比：
- en: '[PRE49]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It avoids the construction and unboxing of a Float object.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 它避免了构造和拆箱浮点对象。
- en: Similar methods exist for Boolean, Double, Integer and the other primitive types.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的方法也适用于布尔值、双精度浮点数、整数和其他原始类型。
- en: isEmpty
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: isEmpty
- en: 'A common clumsy idiom is to check if a Collection is empty by checking its
    size:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的笨拙习语是通过检查其大小来检查集合是否为空：
- en: '[PRE50]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The clearer and more concise:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 更清晰和更简洁：
- en: '[PRE51]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: May also be more computationally efficient, depending on the data structure
    it is being called on.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 取决于调用它的数据结构，它也可能更具计算效率。
- en: Often there is no performance difference, but for a large `ConcurrentLinkedQueue`
    the difference can be significant.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 通常没有性能差异，但对于大型`ConcurrentLinkedQueue`，差异可能很大。
- en: Java 9 factory methods
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 9工厂方法
- en: Java 9 added static factory `of` methods to the List, Set and Map interfaces.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9为List、Set和Map接口添加了静态工厂`of`方法。
- en: These allow us to construct the collections cleanly e.g.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这些允许我们干净地构造集合，例如。
- en: '[PRE52]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `of` methods are overloaded to up to 10 values.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`of`方法被重载为最多10个值。'
- en: The code reads slightly better than the Java 8 `Arrays.asList` version and returns
    a fully structurally immutable list that does not allow elements to be replaced.
    It may also be slightly more efficient as it avoids allocating an array.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码比Java 8的`Arrays.asList`版本稍微更易读，并返回一个完全结构不可变的列表，不允许替换元素。它也可能稍微更有效率，因为它避免了分配数组。
- en: Although `of` is overloaded to take no parameters this expressed intent less
    well than `emptyList` etc which may therefore still be preferred.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`of`被重载为不带参数，但这种表达意图不如`emptyList`等清晰，因此可能仍然更受青睐。
