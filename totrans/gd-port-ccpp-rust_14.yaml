- en: Porting from C/C++ to Rust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 C/C++ 到 Rust 的移植。
- en: Fixing Problems in C/C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C/C++ 中修复问题。
- en: This section is not so much concerned with *the correct* way code should be
    written but what with the C/C++ languages allow. Successive versions of these
    languages have attempted to retrofit good practice, but not by eliminating the
    bad one!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节不是关于*代码应该如何正确编写，而是关于 C/C++ 语言允许什么。 连续版本的这些语言试图通过淘汰不好的一种来改良良好的实践！
- en: 'All of these things should be considered bad and any construct in the language
    that enables them is also bad:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些事情都应该被视为不好的，语言中任何使它们成为可能的构造也都不好：
- en: Calling a pure virtual function in a constructor / destructor of a base class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基类的构造函数/析构函数中调用纯虚拟函数。
- en: Calling a dangling pointer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用悬空指针。
- en: Freeing memory more than once
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放内存超过一次。
- en: Using default copy constructors or assignment operators without following the
    rule of three
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不遵循三大原则的情况下使用默认复制构造函数或赋值运算符。
- en: Overflowing a buffer, e.g. being off by one with some string operation or not
    testing a boundary condition
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 溢出缓冲区，例如某些字符串操作的偏移量错误或者未测试边界条件。
- en: Memory leaks due to memory allocation / ownership issues
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存泄漏是由于内存分配/所有权问题。
- en: Heap corruption
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆破坏。
- en: The C++ programming language is a very large specification, one that only grows
    and gets more nuanced and qualified with each release.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 编程语言是一个非常庞大的规范，每个版本都会变得越来越微妙和有限。
- en: The problem from a programmer's perspective is understanding what things C++
    allows them to do as oppose to what things they should do.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序员的角度看，问题在于理解 C++ 允许他们做什么，而不是他们应该做什么。
- en: In each case we'll see how Rust might have stopped us getting into this situation
    in the first place.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，我们将看到 Rust 如何可能阻止我们首先陷入这种情况。
- en: What about C?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C 怎么样？
- en: C++ will come in for most of the criticism in this section. Someone might be
    inclined to think that therefore C does not suffer from problems.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，C++ 将受到大部分批评。 有人可能倾向于认为，因此 C 不会遭受问题。
- en: Yes that is true to some extent, but it is akin to arguing we don't need shoes
    because we have no legs. C++ exists and is popular because it is perceived as
    a step up from C.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，在某种程度上是真的，但这相当于辩称我们不需要鞋子，因为我们没有腿。 C++ 的存在和流行是因为它被认为是从 C 进步的一步。
- en: Namespaces
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间。
- en: Improved type checking
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的类型检查。
- en: Classes and inheritance
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和继承。
- en: Exception handling
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理。
- en: More useful runtime library including collections, managed pointers, file io
    etc.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更有用的运行时库，包括集合、托管指针、文件 IO 等。
- en: The ability to model classes and bind methods to them is a major advance. The
    ability to write RAII style code does improve the software's chances of keeping
    its memory and resource use under control.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟类并将方法绑定到它们是一项重大进步。 编写 RAII 风格代码的能力确实提高了软件保持其内存和资源使用受控制的机会。
- en: Compilers Will Catch Some Errors
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译器将捕获一些错误。
- en: Modern C/C++ compilers can spot some of the errors mentioned in this section.
    But usually they'll just throw a warning out. Large code bases always generate
    warnings, many of which are innocuous and it's easy to see why some people become
    numb to them as they scroll past.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 C/C++ 编译器可以发现本节中提到的一些错误。 但通常它们只会抛出一个警告。 大型代码库总是会生成警告，其中许多是无害的，很容易理解为什么有些人在滚动时会对它们感到麻木。
- en: The simplest way to protect C / C++ from dumb errors is to elevate serious warnings
    to be errors. While it is not going to protect against every error it is still
    better than nothing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 保护 C/C++ 免受愚蠢错误的最简单方法是将严重警告提升为错误。 尽管它不会保护免受每一种错误的影响，但仍然胜过什么都不做。
- en: In Microsoft VC++ enable a high warning level, e.g. /W4 and possibly /WX to
    warnings into errors.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Microsoft VC++ 中启用高警告级别，例如 /W4，并可能使用 /WX 将警告转换为错误。
- en: In GCC enable -Wall, -pedantic-errors and possibly -Werror to turn warnings
    into errors. The pedantic flag rejects code that doesn't follow ISO C and C++
    standards. There are a lot of errors that can be [configured](https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#Warning-Options).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GCC 中启用 -Wall，-pedantic-errors，并可能使用 -Werror 将警告转换为错误。 pedantic 标志拒绝不遵循 ISO
    C 和 C++ 标准的代码。 可以[配置](https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#Warning-Options)许多错误。
- en: However this will probably throw up a lot of noise in your compilation process
    and some of these errors may be beyond your means to control.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这可能会在编译过程中产生大量噪音，并且其中一些错误可能超出了您控制的范围。
- en: In addition it is a good to run a source code analysis tool or linter. However
    these tend to be expensive and in many cases can be extremely unwieldy.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，最好运行源代码分析工具或代码检查工具。然而，这些工具往往价格昂贵，在许多情况下可能非常笨重。
- en: Copy Constructor / Assignment Operators
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制构造函数/赋值运算符
- en: Copy Constructor / Assignment Operators
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制构造函数/赋值运算符
- en: 'In C++ you can construct one instance from another via a constructor and also
    by an assignment operator. In some cases a constructor will be used instead of
    an assignment:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，您可以通过构造函数和赋值运算符从一个实例构造另一个实例。在某些情况下，构造函数将被用来代替赋值：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By default C++ generates all the code to copy and assign the bytes in one class
    to another without any effort. Lucky us!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，C++会生成所有代码，将一个类中的字节复制到另一个类中，而无需任何努力。我们真是幸运！
- en: 'So our class PersonList might look like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`PersonList`类可能如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Except we're not lucky, we just got slimed. The default byte copy takes the
    pointer in `personList_` and makes a copy of it. Now if we copy `x` to `y`, or
    assign `x` to `z` we have three classes pointing to the same private data! On
    top of that, `z` allocated its own `personList_` during its default constructor
    but the byte copy assignment overwrote it with the one from `x` so its old `personList_`
    value just leaks.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们很幸运，我们只是被弄脏了。默认的字节复制会获取`personList_`中的指针并复制它。现在，如果我们将`x`复制到`y`，或者将`x`分配给`z`，我们将有三个指向相同私有数据的类！更糟糕的是，`z`在其默认构造函数中分配了自己的`personList_`，但字节复制赋值却用`x`的那个覆盖了它，所以它的旧`personList_`值就泄漏了。
- en: Of course we might be able to use a `std::unique_ptr` to hold our pointer. In
    which case the compiler would generate an error. But it might not always be that
    simple. `personList_` may have been opaquely allocated by an external library
    so have no choice but to manage its lifetime through the constructor and destructor.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可能可以使用`std::unique_ptr`来持有我们的指针。在这种情况下，编译器会生成一个错误。但情况可能并不总是那么简单。`personList_`可能是由外部库不透明地分配的，因此我们别无选择，只能通过构造函数和析构函数来管理其生命周期。
- en: The Rule of Three
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三法则
- en: This is such a terrible bug enabling problem in C++ that it has given rise to
    the so-called the Rule of Three^([1](#fn_1)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是C++中一个如此可怕的bug问题，导致了所谓的三法则^([1](#fn_1))。
- en: The rule says that if we explicitly declare a destructor, copy constructor or
    copy assignment operator in a C++ class then we probably need to implement all
    three of them to safely handle assignment and construction. In other words the
    burden for fixing C++'s default and dangerous behaviour falls onto the developer.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则表示，如果我们在C++类中显式声明了析构函数、复制构造函数或复制赋值运算符，那么我们可能需要实现所有三者来安全地处理赋值和构造。换句话说，修复C++的默认和危险行为的负担落在开发人员身上。
- en: 'So let''s fix the class:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们修复这个类：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What a mess!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 真是一团糟！
- en: We've added a copy constructor and an assignment operator to the class to handle
    copying safely. The code even had to check if it was being assigned to itself
    in case someone wrote `x = x`. Without that test, the receiving instance would
    clear itself in preparation to adding elements from itself which would of course
    wipe out all its contents.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为该类添加了一个复制构造函数和一个赋值运算符，以安全地处理复制。代码甚至还必须检查是否正在分配给自身，以防有人写了`x = x`。如果没有进行这个测试，接收实例将清除自身，准备从自身添加元素，这当然会清除其所有内容。
- en: 'Alternatively we might disable copy / assignments by creating private constructors
    that prevents them being called by external code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以通过创建私有构造函数来禁用复制/赋值，防止外部代码调用它们：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Another alternative would be to use noncopyable types within the class itself.
    For example, the copy would fail if the pointer were managed with a C++11 `std::unique_ptr`
    (or Boost's `boost::scoped_ptr`).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是在类内部使用不可复制类型。例如，如果指针是由C++11的`std::unique_ptr`（或Boost的`boost::scoped_ptr`）管理，则复制将失败。
- en: Boost also provides a `boost::noncopyable` class which provides yet another
    option. Classes may inherit from noncopyable which implements a private copy constructor
    and assignment operator so any code that tries to copy will generate a compile
    error.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Boost还提供了一个`boost::noncopyable`类，提供了另一种选择。类可以继承自noncopyable，它实现了一个私有的复制构造函数和赋值运算符，因此任何试图复制的代码都会生成一个编译错误。
- en: The Rule of Five
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 五法则
- en: The Rule of Three has become the Rule of Five(!) in C++11 because of the introduction
    of move semantics.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，由于引入了移动语义，三法则已经变成了五法则！
- en: If you have a class that can benefit from move semantics, the Rule of Five essentially
    says that the existence of the user-defined destructor, copy constructor and copy
    assignment operator requires you to also implement a move constructor and a move
    assignment operator. So in addition to the code we wrote above we must also write
    two more methods.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个类可以受益于移动语义，那么“五大法则”基本上表示，用户定义的析构函数、复制构造函数和复制赋值运算符的存在要求你还必须实现一个移动构造函数和一个移动赋值运算符。所以除了我们上面写的代码之外，我们还必须写两个方法。
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How Rust helps
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 如何帮助
- en: Move is the default
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动是默认值
- en: Rust helps by making move semantics the default. i.e. unless you need to copy
    data from one instance to another, you don't. If you assign a struct from one
    variable to another, ownership moves with it. The old variable is marked invalid
    by the compiler and it is an error to access it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 通过使移动语义成为默认来提供帮助。也就是说，除非你需要将数据从一个实例复制到另一个实例，否则不需要。如果你将一个结构体从一个变量赋给另一个变量，所有权就会随之移动。旧变量被编译器标记为无效，访问它是一个错误。
- en: But if you do want to copy data from one instance to another then you have two
    choices.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你确实想要从一个实例复制数据到另一个实例，那么你有两个选择。
- en: Implement the `Clone` trait. Your struct will have an explicit `clone()` function
    you can call to make a copy of the data.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `Clone` trait。你的结构体将有一个显式的 `clone()` 函数，你可以调用它来复制数据。
- en: Implement the `Copy` trait. Your struct will now implicitly copy on assignment
    instead of move. Implementing `Copy` also implies implementing `Clone` so you
    can still explicitly call `clone()` if you prefer.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `Copy` trait。你的结构体现在将在赋值时隐式复制而不是移动。实现 `Copy` 也意味着你仍然可以显式调用 `clone()`。
- en: Primitive types such as integers, chars, bools etc. implement `Copy` so you
    can just assign one to another
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型，如整数、字符、布尔等，实现了 `Copy`，所以你可以将一个赋给另一个
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But a `String` cannot be copied this way. A string has an internal heap allocated
    pointer so copying is a more expensive operation. So `String` only implements
    the `Clone` trait which requires you to explicitly duplicate it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 `String` 不能以这种方式被复制。字符串有一个内部的堆分配指针，所以复制是一种更昂贵的操作。因此，`String` 只实现了 `Clone`
    trait，它要求你显式复制它：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The default for any struct is that it can neither be copied nor cloned.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 任何结构体的默认情况是既不能被复制也不能被克隆。
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code will create a `Person` object, assigns it to `person1`.
    And when `person1` is assigned to `person2`, ownership of the data also moves:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将创建一个 `Person` 对象，将其赋给 `person1`。当 `person1` 赋给 `person2` 时，数据的所有权也移动了：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Attempting to use `person1` after ownership moves to `person2` will generate
    a compile error:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有权移动到 `person2` 后尝试使用 `person1` 将生成一个编译错误：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To illustrate consider this Rust which is equivalent to the PersonList we saw
    in C++
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明问题，考虑一下这个 Rust 示例，它等同于我们在 C++ 中看到的 PersonList
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see that `PersonList` has a `Vec` vector of `Person` objects. Under the
    covers the `Vec` will allocate space in the heap to store its data.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `PersonList` 有一个 `Vec` 向量的 `Person` 对象。在内部，`Vec` 将分配空间在堆中存储它的数据。
- en: Now let's use it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来使用它。
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The variable `x` is on the stack and is a `PersonList` but the persons member
    is partly allocated from the heap.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `x` 在堆栈上，是一个 `PersonList`，但 persons 成员部分分配在堆上。
- en: The variable `x` is bound to a PersonList on the stack. The vector is created
    in the heap. If we assign `x` to `y` then we could have two stack objects sharing
    the same pointer on the heap in the same way we did in C++.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `x` 绑定到堆栈上的 PersonList。向量在堆中创建。如果我们将 `x` 赋给 `y`，那么我们可能会有两个堆栈对象共享相同的指针在堆中，就像我们在
    C++ 中所做的那样。
- en: But Rust stops that from happening. When we assign `x` to `y`, the compiler
    will do a bitwise copy of the data in x, but it will bind ownership to `y`. When
    we try to access the in the old var Rust generates a compile error.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 Rust 阻止了这种情况的发生。当我们将 `x` 赋给 `y` 时，编译器将对 x 中的数据进行按位复制，但将所有权绑定到 `y`。当我们尝试访问旧变量时，Rust
    生成一个编译错误。
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Rust has stopped the problem that we saw in C++. Not only stopped it but told
    us why it stopped it - the value moved from x to y and so we can't use x any more.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 已经阻止了我们在 C++ 中看到的问题。不仅阻止了它，还告诉我们为什么阻止了它——值从 x 移动到 y，所以我们不能再使用 x 了。
- en: Implementing the Copy trait
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 Copy trait
- en: The `Copy` trait allows us to do direct assignment between variables. The trait
    has no functions, and acts as a marker in the code to denote data that should
    be duplicated on assignment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Copy` trait 允许我们在变量之间进行直接赋值。该 trait 没有函数，并在代码中充当标记，表示应该在赋值时复制的数据。'
- en: 'You can implement the `Copy` trait by deriving it, or implementing it. But
    you can only do so if all the members of the struct also derive the trait:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过派生它或实现它来实现`Copy` trait。但只有结构体的所有成员也派生了该 trait，才能这样做：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So `PersonKey` is copyable because types `u32` and `u8` are also copyable and
    the compiler will take the `#[derive(Copy)]` directive and modify the move / copy
    semantics for the struct.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 `PersonKey` 是可复制的，因为类型 `u32` 和 `u8` 也是可复制的，编译器会接受 `#[derive(Copy)]` 指令并修改结构体的移动/复制语义。
- en: But when a struct contains a a type that does not implement `Copy` you will
    get a compiler error. So this struct `Person` will cause a compiler error because
    `String` does not implement `Copy:`
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当一个结构体包含一个不实现`Copy`的类型时，你会得到一个编译器错误。所以这个结构体 `Person` 会导致编译器错误，因为 `String`
    没有实现`Copy`：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Implementing the Clone trait
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 Clone trait
- en: 'The `Clone` trait adds a `clone()` function to your struct that produces an
    independent copy of it. We can derive it if every member of the struct can be
    cloned which in the case of `Person` it can:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clone` trait 为你的结构体添加了一个 `clone()` 函数，用于生成它的一个独立副本。如果结构体的每个成员都可以被克隆，我们可以派生它，而在
    `Person` 的情况下，它可以：'
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that Person derives `Clone`, we can do the same for PersonList because
    all its member types implement that trait - a Person can be cloned, a Vec can
    be cloned, and a Box can be cloned:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Person` 派生了`Clone`，我们可以对 `PersonList` 做同样的事情，因为它的所有成员类型都实现了这个 trait - 一个
    `Person` 可以被克隆，一个 `Vec` 可以被克隆，一个 `Box` 可以被克隆：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: And now we can clone `x` into `y` and we have two independent copies.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将 `x` 克隆到 `y`，我们有了两个独立的副本。
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In summary, Rust stops us from getting into trouble by treated assigns as moves
    when a non-copyable variable is assigned from one to another. But if we want to
    be able to clone / copy we can make our intent explicit and do that too.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Rust 通过将赋值视为移动来防止我们陷入麻烦，当一个不可复制的变量从一个变量赋值到另一个变量时。但如果我们想要克隆/复制，我们可以明确地表达我们的意图并这样做。
- en: C++ just lets us dig a hole and fills the dirt in on top of us.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 只是让我们挖了一个坑，然后把土填在我们头上。
- en: Missing Braces in Conditionals
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句中缺少大括号
- en: Missing Braces in Conditionals
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句中缺少大括号
- en: Every programmer eventually encounters an error like this and spends hours trying
    to figure out why it wasn't working.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序员最终都会遇到这样的错误，并花费数小时试图弄清楚为什么它不起作用。
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The reason of course was the else statement wasn't enclosed in braces so the
    wrong code was executed. The compiler might spot dead code in this instance but
    that may not always be the case. Even if it did, it might only issue a warning
    instead of an error.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，原因是 else 语句没有被大括号括起来，因此执行了错误的代码。编译器可能会在这种情况下发现死代码，但情况并不总是如此。即使它这样做了，它可能只发出警告而不是错误。
- en: 'The problem can be especially annoying in deeply nested conditions where a
    misplaced brace can attach to the wrong level. This problem has lead real-world
    security issues. For example here is the infamous ["goto fail"](https://www.imperialviolet.org/2014/02/22/applebug.html)
    bug that occured in some Apple products. This (intentional?) bug occured during
    an SSL handshake and was exploitable. :'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 深度嵌套条件中特别容易出现问题，一个放错位置的大括号可能会附加到错误的级别上。这个问题导致了真实世界的安全问题。例如，这里就有一个臭名昭著的["goto
    fail"](https://www.imperialviolet.org/2014/02/22/applebug.html) bug，发生在一些苹果产品中。这个（故意的？）bug发生在SSL握手期间，是可以利用的：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note how the "goto fail" is repeated twice and not bound to the condition but
    is indented as if it was. The code would jump straight into the fail label and
    return with an err indicating success (since the prior SHA1 update had succeeded).
    If conditionals
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 "goto fail" 出现了两次，并且没有绑定到条件，而是缩进了，就好像它是。代码会直接跳转到失败标签，并返回一个指示成功的错误（因为之前的 SHA1
    更新成功了）。如果条件
- en: How Rust helps
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 如何帮助
- en: Rust requires if-else expressions and loops to be associated with blocks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 要求 if-else 表达式和循环与块相关联。
- en: 'So this code won''t compile:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这段代码无法编译：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you try you will get an error like this.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试，你会得到这样的错误。
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Assignment in Conditionals
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句中的赋值
- en: Assignment in Conditionals
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句中的赋值
- en: 'The omission of an `=` in an `==` condition turns it into an assignment that
    evaluates to true:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `==` 条件中省略 `=` 将其转换为一个赋值，该赋值计算为 true：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So here, result was assigned the value 200 rather than compared to the value
    200\. Compilers should issue a warning for these cases, but an error would be
    better.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在这里，结果被赋值了值200，而不是与值200进行比较。编译器应该对这些情况发出警告，但是出错会更好。
- en: 'Developers might also try to reverse the left and right hand side to mitigate
    the issue:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员也可能尝试交换左右手边来减轻问题：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now the compiler will complain because the value of result is being assigned
    to a constant which makes no sense. This may work if a variable is compared to
    a constant but arguably it makes the code less readable and wouldn't help if the
    left and right hand sides were both assignable so their order didn't matter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译器会抱怨，因为结果的值被分配给了一个常量，这没有任何意义。如果一个变量与一个常量进行比较可能会有用，但可以说这使得代码的可读性降低了，并且如果左右两边都是可分配的，则不会有帮助，因此它们的顺序并不重要。
- en: 'The `goto fail` example that we saw in section "Missing braces in conditionals"
    also demonstrates a real world dangers combining assignment and comparison into
    a single line:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“条件语句中缺少大括号”一节中看到的`goto fail`示例还演示了将赋值和比较结合成一行的现实世界危险：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This line is not broken for other reasons, but it's easy to see how might be,
    especially if this pattern were repeated all over the place. The programmer might
    have saved a few lines of code to combine everything in this way but at a greater
    risk. In this case, the risk might be inadvertantly turning the `=` into an `==`,
    i.e. comparing err to the function call and then comparing that to 0.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此行之所以没有其他原因而中断，但易于看出可能存在的原因，特别是如果这种模式重复出现。程序员可能通过以这种方式组合一切来节省几行代码，但风险更大。在这种情况下，风险可能是无意中将`=`变成`==`，即将错误与函数调用进行比较，然后将其与0进行比较。
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How Rust helps
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 如何帮助
- en: 'This code just won''t compile:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码根本无法编译：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The only form of assignment inside a conditional is the specialised and explicit
    `if let` and `while let` forms which are explained elsewhere.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句中唯一的赋值形式是专门的和显式的`if let`和`while let`形式，其他地方有解释。
- en: Class Member Initialisation
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类成员初始化
- en: Class Member Initialisation
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类成员初始化
- en: C++ does not require that you initialise all variables in every constructor.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: C++不要求在每个构造函数中初始化所有变量。
- en: A member that is a C++ class with its own default constructor doesn't need to
    be initialised
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++类成员如果具有自己的默认构造函数，则不需要初始化。
- en: A member that is a C++ class without a default constructor must be explicitly
    initialised.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++类成员如果没有默认构造函数，则必须显式初始化。
- en: A member that is a reference must be explicitly initialised
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型的成员必须显式初始化。
- en: Primitive types, including pointers do not have to be initialised although the
    compiler may warn if they are not
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型，包括指针，不需要初始化，尽管编译器可能会警告。
- en: Members do not have to be initialised in the order they are declared
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员不必按照声明的顺序初始化
- en: Some compilers may issue warnings if you forget to initialise members or their
    ordering, but they will still compile the code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果忘记初始化成员或它们的顺序，一些编译器可能会发出警告，但它们仍然会编译代码。
- en: 'C++11 allows classes to have default member initializers which are used in
    the absence of a constructor setting the value to something else:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: C++11允许类具有默认成员初始化器，如果没有构造函数设置值，则使用该初始化器将值设置为其他值：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is obviously a lot easier to read and ensures that if we have multiple
    constructors that we don't have to initialize members if the default value will
    do.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然更容易阅读，并确保如果我们有多个构造函数，那么如果默认值足够，我们就不必初始化成员。
- en: How Rust helps
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 如何帮助
- en: You MUST initialise all members of a struct. If your code does not initialise
    a struct you will get a compiler error.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 必须初始化结构体的所有成员。如果你的代码没有初始化结构体，你将得到一个编译器错误。
- en: 'This will not compile:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将无法编译：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you try you will get an error like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试，会得到如下错误：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Forcing you to initialise the members of the struct ensures the struct is always
    in a consistent predictable state.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 强制你初始化结构体的成员确保结构体始终处于一种一致可预测的状态。
- en: Ordering of initialisation does not matter providing all of the fields are set.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化的顺序并不重要，只要所有字段都被设置。
- en: Structs often implement a `new()` function which encapsulates this initialisation
    and acts like a constructor in C++, e.g.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体通常实现一个`new()`函数，它封装了这个初始化过程，并在C++中充当构造函数，例如：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Alternatively the struct might implement one or more `From<>` traits:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 或者结构体可能会实现一个或多个`From<>`特性：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There can be multiple `From` trait implementations so we can implement a form
    of polymorphism.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 可以有多个`From`特性实现，因此我们可以实现一种多态形式。
- en: Headers and Sources
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头文件和源文件
- en: Headers and Sources
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头文件和源文件
- en: 'A header file contains definitions of classes, types, macros etc that other
    files need to #include in order to resolve their use of those things.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件包含了类、类型、宏等的定义，其他文件需要在`#include`中包含以解析它们对这些东西的使用。
- en: Splitting the implementation and definition across different files is an added
    burden for maintaining code but it can also lead to some serious errors.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将实现和定义拆分到不同的文件中是维护代码的额外负担，但也可能导致一些严重的错误。
- en: Headers used across multiple projects that have different compiler settings
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个项目中使用的头文件可能具有不同的编译器设置
- en: Issues with pragmas and alignment
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `#pragma` 和对齐时可能会出现的问题
- en: 'Issues with different #definitions that affect byte length'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '不同的 # 定义可能会影响字节长度'
- en: Issues with different typedefs that affect byte length
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的 typedef 可能会影响字节长度
- en: Each consumer of the header must do so with the exact same settings that affect
    the size of every type, struct and class in the file plus any issues with packing
    / alignment. If these settings are not the same, it can cause instability, corruption
    or problems that only manifest themselves at at runtime.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件的每个使用者都必须使用影响文件中每个类型、结构和类大小的确切相同设置，并解决任何影响打包/对齐的问题。如果这些设置不同，可能会导致不稳定性、损坏或仅在运行时出现的问题。
- en: Headers also make the compiler slower because source that consumes the header
    inevitably pulls in other headers which pull in other headers.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件还会使编译器变慢，因为消费头文件的源码不可避免地会引入其他头文件，而其他头文件又会引入其他头文件。
- en: 'Guard blocks / #pragma once'
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 守卫块 / `#pragma once`
- en: Headers will also be expanded as many times as they are `#include`'d. To prevent
    the expansion happening more than once per source file, they're usually protected
    by guard blocks.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件每次被 `#include` 时都会被展开多次。为了防止每个源文件扩展超过一次，它们通常都受到守卫块的保护。
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If the same header is included more than once, the second time through it is
    preprocessed into nothing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同一个头文件被多次包含，则第二次通过时会被预处理成空。
- en: '#pragma once'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`#pragma once`'
- en: Most modern compilers also support a `#pragma once` directive. This allows the
    compiler to completely ignore an `#include` which it knows it has already included
    at least once before per source file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代编译器也支持 `#pragma once` 指令。这允许编译器完全忽略已经在每个源文件中至少包含一次的 `#include`。
- en: This is more efficient than guard blocks because the compile doesn't even bother
    opening or processing the file again and just skips over it. There may be situations
    where this is not suitable, but usually it results in faster compilation.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这比守卫块更有效，因为编译器甚至都不会再次打开或处理文件，而是直接跳过。可能会有不适合的情况，但通常会导致更快的编译速度。
- en: Precompiled Headers
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预编译头文件
- en: Some compilers also support precompiled headers to speed up compilation. The
    compiler builds a database lookup when compiling a single source file and subsequent
    source compiles with reference to that database. This solution can speed up compilation
    but it complicates the build process since one file has flags to generate the
    precompiled header file and other sources have flags to reference it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器还支持预编译头文件以加快编译速度。编译器在编译单个源文件时建立一个数据库查找，并在后续源文件编译中引用该数据库。这种解决方案可以加快编译速度，但会使构建过程变得复杂，因为一个文件具有生成预编译头文件的标志，其他源文件具有引用它的标志。
- en: Pimpl pattern
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pimpl 模式
- en: A popular workaround for header issues is the Pimpl pattern. It is a way to
    separate a class into a public part and a private implementation part.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件问题的一种流行解决方法是 Pimpl 模式。这是一种将类分成公共部分和私有实现部分的方式。
- en: 'The public class is almost an interface definition in its purity that can be
    defined in the header with minimal dependencies. It forward references the implementation
    class and stores it as a member:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类几乎是一个纯粹的接口定义，可以在头文件中以最小的依赖关系进行定义。它向前引用了实现类，并将其存储为成员：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The constructor for the outer class would allocate the implementation class
    and method calls would call through to the inner.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 外部类的构造函数将分配实现类，方法调用将通过内部调用。
- en: The private implementation class is defined in the source file and can pull
    in as many extra headers as it needs, pragmas whatever without hurting consumers
    or compile times of the header.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 私有实现类在源文件中定义，可以引入任意数量的额外头文件，`#pragma` 或其他内容，而不会影响头文件的消费者或编译时间。
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This solution is known as Pimpl (private implementation) pattern and while it
    can work to protect consumers and speed up builds it also adds complexity and
    overhead to development. Instead of 2 definitions of a class to maintain (header
    / source) you now have 4(!) because there is a public and private impl class.
    Changing the signature of a method means changing it in potentially 4 places,
    plus the line in the public class that invokes the private counterpart.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案被称为 Pimpl（private implementation）模式，虽然它可以用来保护消费者并加快构建速度，但也增加了开发的复杂性和开销。现在不再是维护类的
    2 个定义（头文件 / 源文件），而是有 4 个(!)，因为有一个公共的和一个私有的 impl 类。改变方法的签名意味着在潜在的 4 个地方进行更改，加上在公共类中调用私有对应方法的那一行。
- en: One danger for Pimpl is that the private class is allocated from the heap. Code
    that uses a lot of temporary Pimpl objects could contribute to heap fragmentation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Pimpl 的一个危险在于私有类是从堆中分配的。使用大量临时 Pimpl 对象的代码可能会导致堆碎片化。
- en: 'Note 1: Remember the rule of three? That applies to this object too. The example
    doesn''t show it but if we copy constructed or assigned ComplexThing to another
    instance we''d be in a heap of trouble. So on top of the issues with making PImpl
    work we also have to prevent the other ones. The easiest way to lock it down would
    be to derive from `boost::noncopyable` if you were using boost or make the copy
    constructor `private`, or use delete it in C++11.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注1：记得三大法则吗？这也适用于这个对象。示例没有显示出来，但如果我们将 ComplexThing 复制构造或赋值给另一个实例，我们将陷入麻烦之中。所以除了解决
    PImpl 的问题之外，我们还必须防止其他问题。最简单的锁定方法是从 `boost::noncopyable` 派生，如果你使用 boost，或者将复制构造函数设为
    `private`，或在 C++11 中使用 delete。
- en: How Rust helps
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 如何帮助
- en: In Rust the definition and the implementation are the same thing. So immediately
    we have exactly one thing to maintain.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，定义和实现是同一回事。所以我们立即有一个要维护的东西。
- en: Writing a function defines the function. Let's assume we have a functions.rs
    file
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 编写函数定义了该函数。假设我们有一个 functions.rs 文件
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Anyone can call it as `functions::create_directory_structure()`. The compiler
    will validate the call is correct.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人都可以将其称为 `functions::create_directory_structure()`。编译器将验证调用是否正确。
- en: A struct's definition and its implementation are also written once. e.g. `directory.rs`
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的定义及其实现也只写一次。例如 `directory.rs`
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Implementations can be defined in a private Rust module and only public structs
    exposed to consumers.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可以在私有 Rust 模块中定义，只有公共结构体对消费者可见。
- en: If we were a library crate (which we'll call `file_utils`) wishing to expose
    these objects to consumers we would write a top-level `lib.rs` which says what
    files our lib comprises of and we want to expose.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们是一个库 crate（我们将其称为 `file_utils`），希望将这些对象暴露给消费者，我们将编写一个顶级 `lib.rs`，说明我们的 lib
    由哪些文件组成，并且我们想要暴露哪些文件。
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now a consumer can use our crate easily:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在消费者可以轻松使用我们的 crate：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Forward Declarations
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前向声明
- en: Forward Declarations
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前向声明
- en: C++ prevents us from referring to a class or function which has not been defined
    yet. The compiler will complain even if the class or function is in the same file
    it is referenced from.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 防止我们引用尚未定义的类或函数。即使类或函数位于引用它的同一文件中，编译器也会抱怨。
- en: This means ordering matters. If our function or class is used by other files,
    we have to declare the function in a header. If our function is private to a source
    file, we have to declare it in the source file, and possibly make it static.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着顺序很重要。如果我们的函数或类被其他文件使用，我们必须在头文件中声明函数。如果我们的函数对一个源文件是私有的，我们必须在源文件中声明它，并可能将其设为
    static。
- en: For classes we can make a forward reference. This acts as a hint to compiler
    to say a class does exist with this name and it will be told about it shortly.
    But it's a hack and it imposes limits on how we can use the forward declared class.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类，我们可以进行前向引用。这作为一个提示，告诉编译器说类名存在，并且它会很快知道这一点。但这是一个 hack，它会限制我们如何使用前向声明的类。
- en: For example, DataManager below can hand out Data objects but the Data object
    has a reference to the DataManager. Since each class refers to each other there
    is no simple way to make the compiler happy except with a forward declaration.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的 DataManager 可以分发 Data 对象，但 Data 对象引用了 DataManager。由于每个类相互引用，没有简单的方法让编译器满意，除了使用前向声明。
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'But forward declaration compromises the design of the code. For example we
    couldn''t hold the Data objects in a collection class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但前向声明损害了代码的设计。例如，我们不能将 Data 对象保存在集合类中：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The compiler would complain because it doesn't know anything about the constructors
    or size of Data. So instantly the design has to change because of a dumb compiler
    restriction. e.g. we might store a pointer to Data instead in the map but then
    we'd have to remember to delete it. So forward references increase the potential
    for bugs.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会抱怨，因为它不知道 Data 的构造函数或大小。因此，设计立即因为愚蠢的编译器限制而改变。例如，我们可以在 map 中存储对 Data 的指针，但然后我们就必须记得删除它。因此，前向引用增加了错误的潜在可能性。
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How Rust helps
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 如何帮助
- en: In Rust forward declarations are unnecessary. The struct and function’s definition
    reside in a .rs and can be referenced with a use directive.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，前向声明是不必要的。结构体和函数的定义位于 .rs 文件中，并且可以通过 `use` 指令引用。
- en: Namespace Collisions
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间冲突
- en: Namespace Collisions
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间冲突
- en: C code has no namespaces at all and namespaces in C++ are optional.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: C 代码根本没有命名空间，C++ 中的命名空间是可选的。
- en: C has learned to live without namespaces. Most C code uses prefixes on functions
    and structs to avoid collisions, e.g `sqlite3_exec()` is a function belonging
    to SQLite3\. The prefix stops the function colliding with `exec()` which is a
    standard POSIX function that got there first. So the prefix acts as a pseudo namespace.
    But it adds noise to our code and would not be necessary if namespaces were supported
    and enforced.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 已经学会了没有命名空间的生活。大多数 C 代码都使用函数和结构体的前缀来避免冲突，例如 `sqlite3_exec()` 是属于 SQLite3 的函数。前缀可以防止该函数与
    `exec()` 发生冲突，而 `exec()` 是一个标准 POSIX 函数，它首先被引入了。因此，前缀充当了伪命名空间。但是它给我们的代码增加了噪音，并且如果支持和强制执行命名空间，则不需要它。
- en: C++ makes them easy to declare but there is no compunction for any code to bother
    or to do so in anything but the most perfunctory way.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 让它们易于声明，但是没有任何代码必须费心或者只是以一种非常敷衍的方式去做。
- en: Macros are not affected by namespaces. For example, if `TRUE` and `FALSE` are
    defined by some header they taint everything that `#include`'s those definitions.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏不受命名空间的影响。例如，如果某个头文件定义了 `TRUE` 和 `FALSE`，那么它们会污染所有包含了这些定义的内容。
- en: 'By default all C++ code resides in a global namespace:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有的 C++ 代码都位于全局命名空间中：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The function `hello()` is part of the global namespace. The call to it within
    `main` could be replaced with calls to `::hello()`. The problem of course is that
    the more code we write into the global namespace, or the more libraries we pull
    in that have no namespaces, the more chance there is of collisions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `hello()` 属于全局命名空间。在 `main` 中对它的调用可以替换为对 `::hello()` 的调用。当然，问题在于我们往全局命名空间中写入的代码越多，或者我们引入的没有命名空间的库越多，就越有可能发生冲突。
- en: Namespacing requires code enclose the namespaced portion in a block.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间要求将命名空间部分置于块中。
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It is also easy to abuse namespaces, for example this happens sometimes and
    is NOT a good idea:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 滥用命名空间也很容易，例如有时会发生这种情况，而且并不是一个好主意：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Any file that says `#include "foo.h"` will inadvertently tell the compiler to
    automatically look up unscoped types and functions against std which may not be
    what the code wants at all.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 任何包含 `#include "foo.h"` 的文件都会不经意地告诉编译器自动在 std 中查找未作用域限定的类型和函数，这可能根本不是代码想要的。
- en: Nested namespacing is also possible but it can look messy.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套命名空间也是可能的，但可能会显得混乱。
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If we forget to close a brace when nesting headers it becomes very easy to make
    C++ throw up a wall of incoherent errors.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记了在嵌套头文件中关闭大括号，那么很容易使 C++ 抛出一堆不连贯的错误。
- en: How Rust helps
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 如何帮助
- en: In Rust every file is implicitly a module (equivalent to a namespace). You cannot
    NOT use modules because you get them automatically.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，每个文件都隐式地是一个模块（等同于一个命名空间）。你不能不使用模块，因为它们会自动创建。
- en: If you have a collision between the names of crates or modules y
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 crates 或 modules 的名称之间发生了冲突
- en: Macros
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏
- en: Macros
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏
- en: Macros in C/C++ are basically little rules that are defined by a preprocessor
    and substituted into the code that the compiler ultimately attempts to compile.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C/C++ 中，宏基本上是由预处理器定义的一些规则，并且替换到编译器最终尝试编译的代码中。
- en: Modern coding practice these days is to use inline functions and constants instead
    of macros.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现代编码实践通常使用内联函数和常量来替代宏。
- en: But the reality is they can still be (ab)used and code often does. For example
    code might insert debug statements or logging which is compiled away in release
    mode.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 但事实是它们仍然可以被（滥）用，并且代码经常这样做。例如，代码可能会插入调试语句或记录日志，在发布模式下会被编译掉。
- en: Another common use is on Windows where the type `TCHAR` compiles to be either
    `char` or `wchar_t` depending on `#define UNICODE` being present or not. Along
    with it go macros like `USES_CONVERSION`, `A2CT`, `T2CW` etc. Code should compile
    cleanly either way but the reality is usually it doesn't.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见用法是在Windows上，类型`TCHAR`根据`#define UNICODE`的存在与否编译为`char`或`wchar_t`。随之而来的还有宏，如`USES_CONVERSION`、`A2CT`、`T2CW`等等。代码应该能够两种方式都能干净地编译，但现实往往并非如此。
- en: 'A classic problem would be something like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典的问题可能是这样的：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: So the value in result would be wrong and the value in x would be incremented
    twice.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，结果中的值将是错误的，x中的值将增加两次。
- en: Compilation errors
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译错误
- en: 'Consider we are compiling this structure:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们正在编译这个结构：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: And in C++
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 而在C++中
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If we fail to define `TOOLTIP_VERSION` to the same value in the implementation
    as in the caller, then this code may stomp all over memory because it thinks the
    struct is 128 bytes in one place and 64 bytes in another.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在实现中未定义`TOOLTIP_VERSION`为与调用方相同的值，则该代码可能会覆盖整个内存，因为它认为在一个地方结构体有128字节，而在另一个地方有64字节。
- en: Namespace issues
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间问题
- en: Macros aren't namespaced and in some cases this leads to problems where a macro
    definition collides with a well qualified symbol. For example code that `#include
    <windows.h>` gets a `#define TRUE 1`. But that excludes any other code that expects
    to compile on Windows from ever using `TRUE` as a const no matter how well they
    qualify it. Consequently code has to do workarounds such as `#undef` macros to
    make code work or using another value.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 宏没有命名空间，在某些情况下，这会导致问题，其中宏定义与一个良好限定的符号发生冲突。例如，`#include <windows.h>`的代码会得到一个`#define
    TRUE 1`。但这排除了任何其他期望在Windows上编译的代码使用`TRUE`作为const的代码，无论它们如何合格。因此，代码必须进行一些解决方案，例如`#undef`宏来使代码工作或者使用另一个值。
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Ugh. But more likely we'll rename myapp::TRUE to something like myapp::MYAPP_TRUE
    to avoid the conflict. It's still an ugly workaround for a problem caused by inconsiderate
    use of macros.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 唉。但更有可能的是我们会将myapp::TRUE重命名为类似myapp::MYAPP_TRUE的东西，以避免冲突。这仍然是对宏不周到使用造成的问题的一个丑陋的解决方法。
- en: Commonly used words like TRUE, FALSE, ERROR, OK, SUCCESS, FAIL are more or less
    unusable thanks to macros.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 常用单词如TRUE、FALSE、ERROR、OK、SUCCESS、FAIL等多多少少都因为宏而无法使用。
- en: How Rust helps
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust如何帮助
- en: Rust provides developers with consts, inline attributes, and platform / architecture
    attributes for the purpose of conditional compilation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Rust为开发者提供了常量、内联属性以及用于条件编译的平台/架构属性。
- en: Rust offers macros but they consist of a set of matching rules than must generate
    syntactically Rust. Macro expansion is performed by the compiler so it is capable
    of generating errors on the macro if the macro is in error.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Rust提供了宏，但它们由一组匹配规则组成，必须生成语法上的Rust。宏扩展是由编译器执行的，因此如果宏有错误，它就能在宏上生成错误。
- en: Type Mismatching
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型不匹配
- en: Type Mismatching
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型不匹配
- en: Consider two methods. Both are called evaluate() and they are overloaded. The
    main() method calls evaluate("Hello world"). What version is called in the compiled
    code?
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两种方法。两者都被称为evaluate()，并且它们是重载的。主方法调用evaluate("Hello world")。在编译代码中调用哪个版本？
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It may surprise you to know that the bool version is called and the compiler
    doesn''t even complain about it either:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 也许让你吃惊的是，布尔版本被调用了，而且编译器甚至都没有抱怨：
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is an example of bad type inference. A string literal (a char *) should
    be turned into a std::string (a C++ string has a constructor that takes char*
    ) but the compiler chose to treat it as a bool instead.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个糟糕类型推断的例子。字符串字面值（char *）应该转换为std::string（C++字符串有一个接受char *的构造函数），但编译器选择将其视为布尔值。
- en: 'On other occasions the compiler might spot ambiguity and complain but the blurred
    lines between types in C++ combined with overloading lead to errors: Here is another
    example where the compiler is a little more useful by generating an error, but
    in doing so it demonstrates the limits of overloading'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，编译器可能会发现歧义并投诉，但C++中类型之间的模糊界线以及重载导致了错误：这是另一个例子，编译器更加有用，通过生成一个错误来演示重载的限制
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: These overloaded methods should be distinct but they're not distinct enough
    as far as the compiler is concerned.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这些重载的方法应该是不同的，但对于编译器而言，它们不够不同。
- en: In summary, blurred and confusing rules about types in C++ can cause unexpected
    errors that can propagate to runtime.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在C++中关于类型的模糊和混乱规则可能导致意想不到的错误，并可能传播到运行时。
- en: How Rust helps
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust如何帮助
- en: In Rust the functions cannot be overloaded in this manner.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rust中，函数不能以这种方式重载。
- en: Rust is also more strict about type coercion - if you have a bool you cannot
    pass it to a function that takes an integer.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 也更严格地对待类型强制转换 - 如果您有一个布尔值，您不能将其传递给接受整数的函数。
- en: Nor can you pass an integer of one size to a function taking an integer of another
    size.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您也不能将一个大小的整数传递给接受另一个大小的整数的函数。
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will yield an error:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致错误：
- en: '[PRE54]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You must use an explicit numeric cast to turn the value into the type the function
    expects:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须使用显式的数字转换来将值转换为函数期望的类型：
- en: '[PRE55]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Explicit / Implicit Class Constructors
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式 / 隐式类构造函数
- en: Explicit / Implicit Class Constructors
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式 / 隐式类构造函数
- en: It's not just overloading that can be a mess. C++ has a bunch of rules about
    implicit / explicit type conversion for single argument constructors.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 混乱不止是重载可能出现的问题。C++ 对于单参数构造函数的隐式 / 显式类型转换有许多规则。
- en: 'For example:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE56]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The function `magic()` takes a `const MagicNumber &` yet we called it with `2016`
    and it still compiled. How did it do that? Well our `MagicNumber` class has a
    constructor that takes an `int` so the compiler implicitly called that constructor
    and used the `MagicNumber` it yielded.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `magic()` 接受一个 `const MagicNumber &`，然而我们却用 `2016` 调用它，而它仍然编译通过了。它是如何做到的？好吧，我们的
    `MagicNumber` 类有一个接受 `int` 的构造函数，所以编译器隐式调用了那个构造函数，并使用了它生成的 `MagicNumber`。
- en: If we didn't want the implicit conversion (e.g. maybe it's horribly expensive
    to do this without knowing), then we'd have to tack an `explicit` keyword to the
    constructor to negate the behaviour.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想要隐式转换（例如，也许在不知道的情况下这样做非常昂贵），那么我们就必须在构造函数中添加一个 `explicit` 关键字来否定这种行为。
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It demonstrates an instance where the default behavior is probably wrong. The
    default *should* be `explicit` and if programmers want implicit they should be
    required to say it.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 它展示了默认行为可能是错误的一个例子。默认情况下应该是 `explicit`，如果程序员想要隐式，则应该被要求明确说明。
- en: C++11 adds to the confusion by allowing classes to declare deleted constructors
    which are anti-constructors that generate an error instead of code if they match.
    For example, perhaps we only want implicit `int` constructors to match but we
    want to stop somebody passing in a `double`. In that case we can make a constructor
    for `double` and then delete it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: C++11通过允许类声明被删除的构造函数增加了混乱，这些构造函数是反构造函数，如果它们匹配，会生成一个错误而不是代码。例如，也许我们只想让隐式的 `int`
    构造函数匹配，但我们想阻止某人传递一个 `double`。在这种情况下，我们可以制作一个 `double` 的构造函数，然后将其删除。
- en: '[PRE58]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How Rust helps
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 如何帮助
- en: Rust does not have constructors and so there is no implicit conversion during
    construction. And since there is no implicit conversion there is no reason to
    have C++11 style function delete operators either.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 没有构造函数，因此在构造过程中没有隐式转换。由于没有隐式转换，因此也没有理由使用 C++11 风格的函数删除操作符。
- en: You must write explicit write "constructor" functions and call them explicitly.
    If you want to overload the function you can use `Into<>` patterns to achieve
    it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须编写显式的写入“构造函数”函数并显式调用它们。如果您想要重载函数，可以使用 `Into<>` 模式来实现它。
- en: 'For example we might write our `MagicNumber` constructor like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能会像这样编写我们的 `MagicNumber` 构造函数：
- en: '[PRE59]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We have said here that the `new()` function takes as its argument anything that
    type `T` which implements the trait `Into<MagicNumber>`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里说 `new()` 函数的参数是任何实现特性 `Into<MagicNumber>` 的类型 `T`。
- en: 'So we could implement it for `i32`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以为 `i32` 实现它：
- en: '[PRE60]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now our client code can just call `new` and providing it provides a type which
    implements that trait our constructor will work:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的客户端代码只需调用 `new`，并提供实现该特性的类型，我们的构造函数就会起作用：
- en: '[PRE61]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Poor Lifetime Enforcement
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弱生命周期实施
- en: Poor Lifetime Enforcement
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弱生命周期实施
- en: 'A function like is completely legal and dangerous:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数是完全合法且危险的：
- en: '[PRE62]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This function returns a reference to a temporary variable. Whoever calls it
    will get a reference to garbage on the stack. Even if it appears to work (e.g.
    if we called the reference immediately) it is only through luck that it does.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回一个临时变量的引用。调用它的人将获得栈上的垃圾引用。即使它看起来工作正常（例如，如果我们立即调用了引用），也只是侥幸而已。
- en: Our compiler will probably issue a warning for this trivial example but it won't
    stop us from compiling it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的例子，我们的编译器可能会发出警告，但它不会阻止我们编译它。
- en: How Rust helps
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 如何帮助
- en: Rust tracks the lifetime of all objects and knows when their lifetime begins
    and ends. It tracks references to the object, knows when it is being borrowed
    (being passed to a function / scope).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 跟踪所有对象的生命周期，并知道它们的生命周期何时开始和结束。它跟踪对对象的引用，知道它何时被借用（传递给函数 / 作用域）。
- en: It generate a compiler error if it detects any violations of its lifetime /
    borrowing rules. So the above code would fail to compile.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检测到违反其生命周期/借用规则的任何违规行为，它会生成一个编译器错误。因此，上述代码将无法编译通过。
- en: Memory Allocation
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存分配
- en: Memory Allocation
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存分配
- en: Allocated memory is memory that is requested from a portion of memory called
    a heap, used for some purpose and returned to the free space when it is no longer
    required.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 已分配的内存是从称为堆的一部分内存中请求的内存，用于某些目的，并在不再需要时返回到自由空间。
- en: 'In C memory is allocated and freed through a relatively simple API:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中，内存通过一个相对简单的 API 进行分配和释放：
- en: '`malloc` and `calloc` allocate memory and `free` destroys it.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`malloc` 和 `calloc` 分配内存，`free` 销毁内存。'
- en: However C++ also needs allocates that call the appropriate constructors and
    destructors so in addition to C's memory allocation functions, there are keywords
    for allocation / free.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C++ 也需要调用适当的构造函数和析构函数的分配，因此除了 C 的内存分配函数外，还有分配/释放的关键字。
- en: '`new` / `delete` for C++ class instances'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 C++ 类实例分配/释放内存
- en: '`new[]` and `delete[]` for arrays of classes'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于类数组的 `new[]` 和 `delete[]`
- en: The above but through scoped / shared pointer classes that take ownership of
    the pointer and free it when appropriate.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述代码通过带有作用域/共享指针类，它们接管指针的所有权，并在适当时释放它。
- en: If we fail to free / delete memory that we've allocated, the program will leak
    memory. If we free / delete memory we've already deallocated, the program may
    crash. If we free a C++ class with a C `free()` the program may leak memory because
    any member variables will not be destroyed properly. If we fail to call the correct
    constructor and destructor pair the program may leak / crash.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们未能释放/删除已分配的内存，程序将泄漏内存。如果我们释放/删除已经释放的内存，程序可能会崩溃。如果我们使用 C 的 `free()` 释放一个
    C++ 类，程序可能会泄漏内存，因为任何成员变量将不会被正确销毁。如果我们未能调用正确的构造函数和析构函数对，程序可能会泄漏/崩溃。
- en: A cottage industry of tools has sprung up just to try and debug issues with
    memory leaks, crashes and so forth. Tools like Valgrind etc. specialise in trying
    to figure out who allocated something without freeing it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小型产业的工具涌现出来，专门用于尝试调试内存泄漏、崩溃等问题。像 Valgrind 等工具专门用于尝试找出谁分配了某些东西而没有释放它。
- en: For example, what's wrong with this?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个有什么问题吗？
- en: '[PRE63]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Oops we allocated an array of strings with `new[]` but called `delete` instead
    of `delete[]`. So instead of deleting an array of strings we called delete on
    the first member. 99 of those string''s destructors will never be called. We should
    have written:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕，我们用 `new[]` 分配了一个字符串数组，但调用了 `delete` 而不是 `delete[]`。因此，我们没有删除一个字符串数组，而是对第一个成员调用了
    delete。其中 99 个字符串的析构函数将永远不会被调用。我们应该这样写：
- en: '[PRE64]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: But the compiler doesn't care and so we have created a potentially hard-to-find
    bug.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 但是编译器并不关心，因此我们可能产生了一个潜在的难以发现的错误。
- en: Some of the problems with memory allocation can be mitigated by wrapping pointers
    with scoped or shared pointer classes. But there are even problems which can prevent
    them from working.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一些与内存分配相关的问题可以通过使用带有作用域或共享指针类来缓解。但是甚至有些问题可能会阻止它们正常工作。
- en: It's not a good idea to allow memory allocation to cross a library boundary.
    So many libraries provide new / free functions through their API. Issues about
    balancing calls apply to them too.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 允许内存分配跨越库边界并不是一个好主意。因此，许多库通过它们的 API 提供新的/释放函数。关于平衡调用的问题也适用于它们。
- en: How Rust helps
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 如何帮助
- en: During normal safe programming Rust has no explicit memory allocation or deallocation.
    We simply declare an object and it continues to exist until its lifetime goes
    out of scope (i.e. nothing refers to it any more).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常安全的编程过程中，Rust 没有显式的内存分配或释放。我们只需声明一个对象，它将持续存在，直到它的生命周期结束（即没有任何引用指向它了）。
- en: This is NOT garbage collection. The compiler tracks the lifetime of the object
    and generates code to automatically delete it at the point it is no longer used.
    The compiler also knows if we enclose an object's declaration inside a cell, box,
    rc or similar construct that the object should be allocated on the heap and otherwise
    it should go on the stack.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是垃圾回收。编译器跟踪对象的生命周期，并生成代码，在不再使用该对象时自动删除它。编译器还知道，如果我们将对象的声明放在 cell、box、rc 或类似的结构中，该对象应该分配在堆上，否则应该放在堆栈上。
- en: Allocation / deallocation is only available in unsafe programming. We would
    not only ordinarily do this except when we are interacting with an external library
    or function call and explicitly tag the section as unsafe.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 分配/释放只能在不安全编程中使用。除非我们与外部库或函数调用进行交互并明确将该部分标记为不安全，否则我们通常不会这样做。
- en: Null Pointers
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空指针
- en: Null Pointers
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空指针
- en: The need to test a pointer for NULL, or blindly call a pointer that might be
    NULL has caused so many errors that it has even been called the [billion dollar
    mistake](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare)
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 需要测试指针是否为NULL，或者盲目调用可能为NULL的指针已经导致了如此多的错误，以至于甚至被称为[十亿美元的错误](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare)。
- en: TODO
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 待办事项
- en: Virtual Destructors
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟析构函数
- en: Virtual Destructors
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟析构函数
- en: C++ allows classes to inherit from other classes.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许类继承其他类。
- en: 'In some cases, such as this example, this can lead to memory leaks:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，例如本例中，这可能导致内存泄漏：
- en: '[PRE65]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: So here we allocate a pointer to A, assign it to "instance" which is of type
    `ABase`, do something with it and finally delete it. It looks fine but we just
    leaked memory! When we called "delete instance" the code invoked the destructor
    `~ABase()` and NOT the destructor `~A()` . And `value_` was not deleted and the
    memory leaked. Even if we'd used a scoped pointer to wrap `value_` it would still
    have leaked.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这里我们分配了一个指向A的指针，将其赋值给类型为`ABase`的"instance"，对其进行操作，最后删除它。看起来没问题，但我们却泄漏了内存！当我们调用"delete
    instance"时，代码调用了析构函数`~ABase()`而不是析构函数`~A()`。而`value_`没有被删除，内存泄漏了。即使我们使用了作用域指针来包装`value_`，它仍然会泄漏。
- en: The code should have said
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应该这样说
- en: '[PRE66]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The compiler didn't care our code was in error. It just allowed us to leak for
    the sake of a missing keyword.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不关心我们的代码有错误。它只是为了缺少关键字而允许我们泄漏。
- en: How Rust helps
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust如何帮助
- en: Rust also does not use inheritance so problems like ABase above cannot exist.
    In Rust `ABase` would be declared as a trait that A implements.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Rust也不使用继承，因此像上面的`ABase`那样的问题是不存在的。在Rust中，`ABase`将被声明为A实现的trait。
- en: '[PRE67]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Rust also allows our struct to implement another trait called `Drop` which is
    equivalent to a C++ destructor.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Rust还允许我们的结构实现另一个称为`Drop`的trait，它相当于C++的析构函数。
- en: '[PRE68]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It allows our code to do something during destruction such as to free an open
    resource, log a message or whatever.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许我们的代码在销毁期间执行某些操作，例如释放开放资源，记录消息或其他操作。
- en: Exception Handling / Safety
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理/安全
- en: Exception Handling / Safety
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理/安全
- en: There are no hard and fast rules for when a function in C++ should throw an
    exception and when it should return a code. So one codebase may have a tendency
    to throw lots of exceptions while another might throw none at all.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，何时应该抛出异常何时应该返回代码没有硬性规定。因此，一个代码库可能有倾向于抛出大量异常，而另一个则根本不抛出。
- en: Aside from that, code may or may not be exception safe. That is, it may or may
    not free up its resources if it suffers an exception.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，代码可能是异常安全的，也可能不是。也就是说，如果遇到异常，它可能会释放或不释放其资源。
- en: Articles have been written to describe the levels of guarantees that code can
    aim for with [exception safety](http://www.boost.org/community/exception_safety.html).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 已经撰写了文章来描述代码可以以何种级别的保证来进行[异常安全](http://www.boost.org/community/exception_safety.html)。
- en: Constructors
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: You may also be advised to throw exceptions in constructors because there is
    no easy way to signal the object is an error otherwise except to set the new object
    into some kind of zombie / dead state via a flag that has to be tested.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可能被建议在构造函数中抛出异常，因为除了通过必须进行测试的标志将新对象设置为某种僵尸/死亡状态之外，否则没有简单的方法来表示对象是否出错。
- en: '[PRE69]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: But if DatabaseConn() had allocated some memory before throwing an exception,
    this would NOT be recovered and so ~DatabaseConn would have to clean it up.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果`DatabaseConn()`在抛出异常之前分配了一些内存，那么这些内存就不会被回收，因此`~DatabaseConn`将不得不清理它。
- en: '[PRE70]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: But if we waited until after the exception throwing to allocate memory then
    maybe buffer_ is not set to NULL, so we'd have to ensure we initialised it to
    NULL.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们等到异常抛出后才分配内存，那么`buffer_`可能就不会被设置为NULL，因此我们必须确保将其初始化为NULL。
- en: '[PRE71]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Destructors
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 析构函数
- en: But you will be advised NOT to throw exceptions in destructors because throwing
    an exception during a stack unwind from handling another exception is fatal.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 但您将被建议不要在析构函数中抛出异常，因为在处理另一个异常时从堆栈展开期间抛出异常是致命的。
- en: '[PRE72]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How Rust helps
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust如何帮助
- en: The recommended way of dealing with errors is to use the `Option` and `Result`
    types to formally pass errors to your caller.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误的推荐方式是使用`Option`和`Result`类型将错误正式传递给调用者。
- en: For irregular errors your code can choose to invoke `panic!()` which is a little
    like an exception in that it will cause the entire thread to unwind. If the main
    thread panics then the process terminates.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不规则的错误，你的代码可以选择调用`panic!()`，这有点像异常，因为它会导致整个线程解开。如果主线程发生panic，那么进程将终止。
- en: A `panic!()` can be caught and recovered from in some scenarios but it is the
    nuclear option.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`panic!()`在某些情况下可以被捕获并恢复，但这是一种核心选项。'
- en: Lacking exceptions might seem a bad idea but C++ demonstrates that they come
    with a whole raft of considerations of their own.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少异常可能看起来是一个坏主意，但C++证明它们带来了许多考虑因素。
- en: Templates vs Generics
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板与泛型
- en: Templates vs Generics
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板与泛型
- en: What's a template?
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是模板？
- en: C++ provides a way of substituting types and values into inline classes and
    functions called templates. Think of it as a sophisicated substitution macro -
    you specify a type T in the template and this can substitute for a type `int`
    or something else at compile time. During compilation you'll be told if there
    are any errors with the type you supply. This is a very powerful feature since
    it allows a class to be reused for many different types.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了一种将类型和值替换为内联类和函数的方法，称为模板。将其视为一种复杂的替换宏 - 你在模板中指定一个类型T，这可以在编译时替换为类型`int`或其他类型。在编译过程中，如果提供的类型存在任何错误，你将收到通知。这是一个非常强大的功能，因为它允许一个类被多种不同的类型重复使用。
- en: Templates are used extensively in the C++ library, Boost and in other places.
    Collections, strings, algorithms and various other piece of code use templates
    in one form or another.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 模板广泛用于C++库、Boost和其他地方。集合、字符串、算法和各种其他代码都以一种形式或另一种形式使用模板。
- en: However, templates only expand into code when something actually calls the inline
    function. Then, if the template calls other templates, the inline code is expanded
    again and again until there is a large body of code which can be compiled. A small
    error in our code can propogate into an enormous wall of noise in the middle of
    some expanded template.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，模板只有在实际调用内联函数时才会展开为代码。然后，如果模板调用其他模板，内联代码将一次又一次地展开，直到有一个大量的代码可以被编译。我们代码中的一个小错误可能会在一些展开的模板中产生一个巨大的错误堆栈。
- en: For example a vector takes a type it holds as a template parameter. So we can
    create a vector of PatientRecords.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个向量以它保存的类型作为模板参数。因此，我们可以创建一个`PatientRecords`的向量。
- en: '[PRE73]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'So far so good. So let''s add a record:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止一切顺利。所以让我们添加一条记录：
- en: '[PRE74]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'That works too! Now let''s try to erase the record we just added:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 那也可以！现在让我们尝试删除我们刚刚添加的记录：
- en: '[PRE75]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Boom!
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 砰！
- en: '[PRE76]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: If you wade through that noise to the bottom we can see the erase() function
    wanted to call the assignment operator on PatientRecord, but couldn't because
    it was private.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览到底部，我们可以看到`erase()`函数想要调用`PatientRecord`的赋值运算符，但由于它是私有的，所以无法调用。
- en: But why did vector allow us to declare a vector with a class which didn't meet
    its requirements?
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为什么向量允许我们声明一个不符合其要求的类的向量？
- en: We were able to declare the vector, use the std::vector::push_back() function
    but when we called std::vector::erase() the compiler discovered some deeply nested
    error and threw these errors back at us.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够声明向量，使用`std::vector::push_back()`函数，但当我们调用`std::vector::erase()`时，编译器发现了一些深层嵌套的错误，并将这些错误抛回给我们。
- en: The reason is that C++ only generates code for templates when it is called.
    So the declaration was not in violation, the push_back() was not in violation
    but the erase was.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是C++只有在调用模板时才会生成代码。因此，声明没有违规，`push_back()`也没有违规，但`erase`有。
- en: How Rust helps
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust如何帮助
- en: Rust has a concept similar to templates called generics. A generics is a struct
    or trait that takes type parameters just like a template.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Rust有一个类似于模板的概念，称为泛型。泛型是一个接受类型参数的结构或特性，就像模板一样。
- en: However but the type can be enforced by saying the traits that it must implement.
    In addition any errors are meaningful.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 但是类型可以通过指定必须实现的特性来强制执行。此外，任何错误都是有意义的。
- en: 'Say we want to write a generic function that clones the input value:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要编写一个通用函数，克隆输入值：
- en: '[PRE77]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We haven't even called the function yet, merely defined it. When we compile
    this, we'll instantly get an error in Rust.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至还没有调用这个函数，只是定义了它。当我们编译这个时，我们会立即在Rust中得到一个错误。
- en: 'error: no method named `clone` found for type `T` in the current scope'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：在当前范围内找不到类型`T`的名为`clone`的方法
- en: '[PRE78]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Rust is saying we never said what T was and because some-random-type has no
    method called clone() we got an error. So we''ll modify the function to add a
    trait bound to T. This binding says T must implement Clone:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 表示我们从未说明T是什么，因为某个随机类型没有名为clone()的方法，所以我们得到了一个错误。因此，我们将修改函数以添加一个对T的特质约束。这个约束表示T必须实现Clone：
- en: '[PRE79]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now the compiler knows T must have implement Clone it is able to resolve clone()
    and be happy. Next we actually call it to see what happens:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译器知道T必须实现Clone，它能够解析clone()并且很高兴。接下来我们实际调用它看看会发生什么：
- en: '[PRE80]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We can clone the integer 10 because integers implement the Clone trait, but
    our empty struct WhatHappensToMe does not implement Clone trait. So when we compile
    it we get an error.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以克隆整数10，因为整数实现了Clone特质，但我们的空结构WhatHappensToMe没有实现Clone特质。因此当我们编译它时会得到一个错误。
- en: '[PRE81]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In summary, Rust improves on templates by TODO
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Rust通过TODO改进了模板
- en: Compiling generic functions / structs even when they are unused and offer meaningful
    errors immediately.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它们未被使用并立即提供有意义的错误，也要编译泛型函数/结构。
- en: Allow us to bind traits to generic types to constrain what we can pass into
    them.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 允许我们将特质绑定到泛型类型，以限制我们可以传递给它们的内容。
- en: Offer meaningful errors if we violate the requirements of the trait bounds
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们违反特质约束的要求，会提供有意义的错误
- en: Multiple Inheritance
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承
- en: Multiple Inheritance
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承
- en: C++ allows code to inherit from multiple classes and they in turn could inherit
    from other classes. This gives rise to the dreaded *diamond pattern*.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许代码从多个类继承，它们反过来可能会从其他类继承。这就导致了可怕的*菱形模式*。
- en: e.g. D inherits from B and C but B and C both inherit from A. So does D have
    two instances of A or one?
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，D继承自B和C，但B和C都继承自A。那么D有两个A的实例还是一个？
- en: This can cause compiler errors which are only partially solved by using something
    called "virtual inheritance" to convince the compiler to share A between B and
    C.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致编译器错误，只能部分地通过使用称为“虚拟继承”来说服编译器在B和C之间共享A来解决。
- en: 'i.e if we knew B and C could potentially be multiply inherited we might declare
    them with a virtual keyword in their inheritance:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，如果我们知道B和C可能会被多重继承，我们可能会在它们的继承中声明一个虚拟关键字：
- en: '[PRE82]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: When D inherits from B and C, both share the same instance of A. But that assumes
    the authors of A, B and C were aware of this problem arising and coded themselves
    with the assumption that A could be shared.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当D继承自B和C时，两者共享A的同一实例。但这假设A、B和C的作者意识到这个问题的出现并编码时假设A可以被共享。
- en: The more usual normal solution for diamond patterns is "don't do it". i.e use
    composition or something to avoid the problem.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 针对菱形模式的更常见的解决方案是“不要这样做”。即使用组合或其他方法来避免这个问题。
- en: How Rust helps
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 如何帮助
- en: Rust also does not use class inheritance so problems like diamond patterns cannot
    exist.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 也不使用类继承，因此像菱形模式这样的问题是不存在的。
- en: However traits in Rust can inherit from other traits, so potentially it could
    have diamond-like issues. But to ensure it doesn't, the base trait is implemented
    separately from any traits that inherit from it.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在Rust中，特质可以继承自其他特质，因此可能会出现类似菱形的问题。但为了确保它不会出现，基本特质是单独实现的，而不是与继承自它的任何特质一起实现。
- en: So if struct D implements traits B & C and they inherit from A, then A, B and
    C must have impl blocks.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果结构体D实现了特质B和C，并且它们继承自A，那么A、B和C必须有impl块。
- en: '[PRE83]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Linker Errors
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接器错误
- en: Linker Errors
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接器错误
- en: C and C++ requires you supply a list of all the .obj files that form part of
    your library or executable.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++要求你提供构成库或可执行文件一部分的所有.obj文件的列表。
- en: If you omit a file by accident you will get undefined or missing references.
    Maintaining this list of files is an additional burden of development, ensuring
    to update your makefile or solution every time you add a file to your project.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你意外地省略了一个文件，你将得到未定义或缺失的引用。维护这个文件列表是开发的额外负担，确保每次向项目添加文件时更新你的makefile或解决方案。
- en: How Rust Helps
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust 如何帮助
- en: Rust includes everything in your library / executable that is directly or indirectly
    referenced by mod commands, starting from your toplevel lib.rs or main.rs and
    working all the way down.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: Rust包括你的库/可执行文件中直接或间接被mod命令引用的所有内容，从你的顶层lib.rs或main.rs开始，一直向下工作。
- en: Providing you reference a module, it will be automatically built and linked
    into your binary.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 提供你引用一个模块，它将自动构建并链接到你的二进制文件中。
- en: 'If you use the `cargo` command, then the above also applies for external crates
    that you link with. The cargo command will also check for version conflicts between
    external libraries. If you find your cargo generating errors about compatibility
    conflicts between crates you may be able to resolve them by updating the Cargo.lock
    file like so:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`cargo`命令，那么上述内容也适用于你链接的外部 crate。`cargo`命令还会检查外部库之间的版本冲突。如果你发现 cargo 生成关于
    crate 之间兼容性冲突的错误，你可以通过更新 Cargo.lock 文件来解决这些问题，方法如下：
- en: '[PRE84]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
