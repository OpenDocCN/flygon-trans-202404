["```\n(define (eval-1 exp)\n  (cond ((constant? exp) exp)\n        ((symbol? exp) (eval exp))      ; use underlying Scheme's EVAL                        \n        ((quote-exp? exp) (cadr exp))\n        ((if-exp? exp)\n         (if (eval-1 (cadr exp))\n             (eval-1 (caddr exp))\n             (eval-1 (cadddr exp))))\n        ((lambda-exp? exp) exp)\n        ((pair? exp) (apply-1 (eval-1 (car exp))      ; eval the operator                     \n                              (map eval-1 (cdr exp))))\n        (else (error \"bad expr: \" exp)))) \n```", "```\n(define (mc-eval exp env)\n  (cond ((self-evaluating? exp) exp)\n  ((variable? exp) (lookup-variable-value exp env))\n  ((quoted? exp) (text-of-quotation exp))\n  ((assignment? exp) (eval-assignment exp env))\n  ((definition? exp) (eval-definition exp env))\n  ((if? exp) (eval-if exp env))\n  ((lambda? exp)\n    (make-procedure (lambda-parameters exp)\n      (lambda-body exp)\n      env))\n  ((begin? exp) \n  (eval-sequence (begin-actions exp) env))\n  ((cond? exp) (mc-eval (cond->if exp) env))\n  ((application? exp)\n    (mc-apply (mc-eval (operator exp) env)\n      (list-of-values (operands exp) env)))\n  (else\n    (error \"Unknown expression type -- EVAL\" exp)))) \n```", "```\n(define (list-of-values exps env)\n  (if (no-operands? exps)\n      '()\n      (cons (mc-eval (first-operand exps) env)\n        (list-of-values (rest-operands exps) env)))) \n```", "```\n(define (quoted? exp)\n  (tagged-list? exp 'quote))\n\n(define (text-of-quotation exp) (cadr exp))  ;returns just the text as a list that will print to output \n```", "```\n(define (tagged-list? exp tag)\n  (if (pair? exp)\n      (eq? (car exp) tag)\n      false)) \n```", "```\n(define (lambda? exp) (tagged-list? exp 'lambda))\n(define (lambda-parameters exp) (cadr exp))\n(define (lambda-body exp) (cddr exp)) \n```", "```\n(define (make-lambda parameters body)\n  (cons 'lambda (cons parameters body))) \n```", "```\n(define (sequence->exp seq)\n  (cond ((null? seq) seq)\n        ((last-exp? seq) (first-exp seq))\n        (else (make-begin seq))))\n(define (make-begin seq) (cons 'begin seq)) \n```", "```\n(define (true? x)\n  (not (eq? x false)))\n(define (false? x)\n  (eq? x false)) \n```", "```\n(define (make-if predicate consequent alternative)\n  (list 'if predicate consequent alternative)) \n```", "```\n(cond ((> x 0) x)\n      ((= x 0) (display 'zero) 0)\n      (else (- x))) \n```", "```\n(if (> x 0)\n    x\n    (if (= x 0)\n        (begin (display 'zero)\n               0)\n        (- x))) \n```", "```\n(define (cond? exp) (tagged-list? exp 'cond))\n(define (cond-clauses exp) (cdr exp))\n(define (cond-else-clause? clause)\n  (eq? (cond-predicate clause) 'else))\n(define (cond-predicate clause) (car clause))\n(define (cond-actions clause) (cdr clause))\n(define (cond->if exp)\n  (expand-clauses (cond-clauses exp)))\n\n(define (expand-clauses clauses)\n  (if (null? clauses)\n      'false                          ; no else clause\n      (let ((first (car clauses))\n            (rest (cdr clauses)))\n        (if (cond-else-clause? first)\n            (if (null? rest)\n                (sequence->exp (cond-actions first))\n                (error \"ELSE clause isn't last -- COND->IF\"\n                       clauses))\n            (make-if (cond-predicate first)\n                     (sequence->exp (cond-actions first))\n                     (expand-clauses rest)))))) \n```", "```\n(define (eval-assignment exp env)\n  (set-variable-value! (assignment-variable exp)\n                       (mc-eval (assignment-value exp) env)\n                       env)\n  'ok) \n```", "```\n(define (eval-definition exp env)\n  (define-variable! (definition-variable exp)\n                    (mc-eval (definition-value exp) env)\n                    env)\n  'ok) \n```", "```\n(define (assignment? exp)\n  (tagged-list? exp 'set!))\n(define (assignment-variable exp) (cadr exp))\n(define (assignment-value exp) (caddr exp)) \n```", "```\n(define (var parameter1 ... parametern)\n  body) \n```", "```\n(define var\n  (lambda (parameter1 ... parametern)\n          body)) \n```", "```\n(define (definition? exp)\n  (tagged-list? exp 'define))\n(define (definition-variable exp)\n  (if (symbol? (cadr exp))\n      (cadr exp)\n      (caadr exp)))\n(define (definition-value exp)\n  (if (symbol? (cadr exp))\n      (caddr exp)\n      (make-lambda (cdadr exp)   ; formal parameters\n                   (cddr exp)))) ; body \n```", "```\n(define (mc-eval exp env)\n  (cond ((self-evaluating? exp) exp)\n  ((variable? exp) (lookup-variable-value exp env))\n  ((quoted? exp) (text-of-quotation exp))\n  ((assignment? exp) (eval-assignment exp env))\n  ((definition? exp) (eval-definition exp env))\n  ((if? exp) (eval-if exp env))\n  ((lambda? exp)\n    (make-procedure (lambda-parameters exp)\n      (lambda-body exp)\n      env))\n  ((begin? exp) \n    (eval-sequence (begin-actions exp) env))\n  ((cond? exp) (mc-eval (cond->if exp) env))\n  ((application? exp)\n    (mc-apply (mc-eval (operator exp) env)\n      (list-of-values (operands exp) env)))\n  (else\n    (error \"Unknown expression type -- EVAL\" exp)))) \n```"]