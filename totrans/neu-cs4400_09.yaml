- en: Note on TypesTuesday, January 17th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Types can become interesting when dealing with higher-order functions. For
    example, `map` receives a function and a list of some type, and applies the function
    over this list to accumulate its output, so its type is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, `map` can use more than a single list, it will apply the function
    on the first element in all lists, then the second and so on. So the type of `map`
    with two lists can be described as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a hairy example — what is the type of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Begin by what we know — both `map`s, call them `map1` and `map2`, have the
    double- and single-list types of `map` respectively, here they are, with different
    names for types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we know that `map2` is the first argument to `map1`, so the type of `map1`s
    first argument should be the type of `map2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: From here we can conclude that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use these equations in `map1`’s type, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `foo`’s two arguments are the 2nd and 3rd arguments of `map1`, and its
    result is `map1`s result, so we can now write the type of `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This should help you understand why, for example, this will cause a type error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'and why this is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Side-note: Names are importantTuesday, January 17th'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An important “discovery” in computer science is that we *don’t* need names
    for every intermediate sub-expression — for example, in almost any language we
    can write the equivalent of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: instead of
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Such languages are put in contrast to assembly languages, and were all put under
    the generic label of “high level languages”.
  prefs: []
  type: TYPE_NORMAL
- en: (Here’s an interesting idea — why not do the same for function values?)
  prefs: []
  type: TYPE_NORMAL
