["```\n/// map for Options\nlet mapOption f opt =\n    match opt with\n    | None -> \n        None\n    | Some x -> \n        Some (f x)\n// has type : ('a -> 'b) -> 'a option -> 'b option\n\n/// map for Lists\nlet rec mapList f list =\n    match list with\n    | [] -> \n        []  \n    | head::tail -> \n        // new head + new tail\n        (f head) :: (mapList f tail)\n// has type : ('a -> 'b) -> 'a list -> 'b list \n```", "```\n// Define a function in the normal world\nlet add1 x = x + 1\n// has type : int -> int\n\n// A function lifted to the world of Options\nlet add1IfSomething = Option.map add1\n// has type : int option -> int option\n\n// A function lifted to the world of Lists\nlet add1ToEachElement = List.map add1\n// has type : int list -> int list \n```", "```\nSome 2 |> add1IfSomething    // Some 3 \n[1;2;3] |> add1ToEachElement // [2; 3; 4] \n```", "```\nSome 2 |> Option.map add1    // Some 3 \n[1;2;3] |> List.map add1     // [2; 3; 4] \n```", "```\n// A value lifted to the world of Options\nlet returnOption x = Some x\n// has type : 'a -> 'a option\n\n// A value lifted to the world of Lists\nlet returnList x  = [x]\n// has type : 'a -> 'a list \n```", "```\nmodule Option =\n\n    // The apply function for Options\n    let apply fOpt xOpt = \n        match fOpt,xOpt with\n        | Some f, Some x -> Some (f x)\n        | _ -> None\n\nmodule List =\n\n    // The apply function for lists\n    // [f;g] apply [x;y] becomes [f x; f y; g x; g y]\n    let apply (fList: ('a->'b) list) (xList: 'a list)  = \n        [ for f in fList do\n          for x in xList do\n              yield f x ] \n```", "```\nlet resultOption =  \n    let (<*>) = Option.apply\n    (Some add) <*> (Some 2) <*> (Some 3)\n// resultOption = Some 5\n\nlet resultList =  \n    let (<*>) = List.apply\n    [add] <*> [1;2] <*> [10;20]\n// resultList = [11; 21; 12; 22] \n```", "```\nlet resultOption2 =  \n    let (<!>) = Option.map\n    let (<*>) = Option.apply\n\n    add <!> (Some 2) <*> (Some 3)\n// resultOption2 = Some 5\n\nlet resultList2 =  \n    let (<!>) = List.map\n    let (<*>) = List.apply\n\n    add <!> [1;2] <*> [10;20]\n// resultList2 = [11; 21; 12; 22] \n```", "```\nlet batman = \n    let (<!>) = List.map\n    let (<*>) = List.apply\n\n    // string concatenation using +\n    (+) <!> [\"bam\"; \"kapow\"; \"zap\"] <*> [\"!\"; \"!!\"]  \n\n// result =\n// [\"bam!\"; \"bam!!\"; \"kapow!\"; \"kapow!!\"; \"zap!\"; \"zap!!\"] \n```", "```\nmodule Option = \n    let (<*>) = apply \n    let (<!>) = Option.map\n\n    let lift2 f x y = \n        f <!> x <*> y\n\n    let lift3 f x y z = \n        f <!> x <*> y <*> z\n\n    let lift4 f x y z w = \n        f <!> x <*> y <*> z <*> w \n```", "```\n// define a two-parameter function to test with\nlet addPair x y = x + y \n\n// lift a two-param function\nlet addPairOpt = Option.lift2 addPair\n\n// call as normal\naddPairOpt (Some 1) (Some 2) \n// result => Some 3 \n```", "```\n// define a three-parameter function to test with\nlet addTriple x y z = x + y + z\n\n// lift a three-param function\nlet addTripleOpt = Option.lift3 addTriple\n\n// call as normal\naddTripleOpt (Some 1) (Some 2) (Some 3)   \n// result => Some 6 \n```", "```\nOption.lift2 (+) (Some 2) (Some 3)   // Some 5\nOption.lift2 (*) (Some 2) (Some 3)   // Some 6 \n```", "```\n// define a tuple creation function\nlet tuple x y = x,y\n\n// create a generic combiner of options\n// with the tuple constructor baked in\nlet combineOpt x y = Option.lift2 tuple x y \n\n// create a generic combiner of lists\n// with the tuple constructor baked in\nlet combineList x y = List.lift2 tuple x y \n```", "```\ncombineOpt (Some 1) (Some 2)        \n// Result => Some (1, 2)\n\ncombineList [1;2] [100;200]         \n// Result => [(1, 100); (1, 200); (2, 100); (2, 200)] \n```", "```\ncombineOpt (Some 2) (Some 3)        \n|> Option.map (fun (x,y) -> x + y)  \n// Result => // Some 5\n\ncombineList [1;2] [100;200]         \n|> List.map (fun (x,y) -> x + y)    \n// Result => [101; 201; 102; 202] \n```", "```\ncombineOpt (Some 2) (Some 3)        \n|> Option.map (fun (x,y) -> x * y)  \n// Result => Some 6\n\ncombineList [1;2] [100;200]         \n|> List.map (fun (x,y) -> x * y)    \n// Result => [100; 200; 200; 400] \n```", "```\nmodule Option = \n\n    /// define lift2 from scratch\n    let lift2 f xOpt yOpt = \n        match xOpt,yOpt with\n        | Some x,Some y -> Some (f x y)\n        | _ -> None\n\n    /// define apply in terms of lift2\n    let apply fOpt xOpt = \n        lift2 (fun f x -> f x) fOpt xOpt \n```", "```\ncombineOpt (Some 2) None    \n|> Option.map (fun (x,y) -> x + y)    \n// Result => None\n\ncombineList [1;2] []         \n|> List.map (fun (x,y) -> x * y)    \n// Result => Empty list \n```", "```\nlet ( <* ) x y = \n    List.lift2 (fun left right -> left) x y \n\nlet ( *> ) x y = \n    List.lift2 (fun left right -> right) x y \n```", "```\n[1;2] <* [3;4;5]   // [1; 1; 1; 2; 2; 2]\n[1;2] *> [3;4;5]   // [3; 4; 5; 3; 4; 5] \n```", "```\nlet repeat n pattern =\n    [1..n] *> pattern \n\nlet replicate n x =\n    [1..n] *> [x]\n\nrepeat 3 [\"a\";\"b\"]  \n// [\"a\"; \"b\"; \"a\"; \"b\"; \"a\"; \"b\"]\n\nreplicate 5 \"A\"\n// [\"A\"; \"A\"; \"A\"; \"A\"; \"A\"] \n```", "```\nlet readQuotedString =\n   readQuoteChar *> readNonQuoteChars <* readQuoteChar \n```", "```\n// alternate \"zip\" implementation\n// [f;g] apply [x;y] becomes [f x; g y]\nlet rec zipList fList xList  = \n    match fList,xList with\n    | [],_ \n    | _,[] -> \n        // either side empty, then done\n        []  \n    | (f::fTail),(x::xTail) -> \n        // new head + new tail\n        (f x) :: (zipList fTail xTail)\n// has type : ('a -> 'b) -> 'a list -> 'b list \n```", "```\nlet add10 x = x + 10\nlet add20 x = x + 20\nlet add30 x = x + 30\n\nlet result =  \n    let (<*>) = zipList \n    [add10; add20; add30] <*> [1; 2; 3] \n// result => [11; 22; 33] \n```", "```\nlet add x y = x + y\n\nlet resultAdd =  \n    let (<*>) = zipList \n    [add;add] <*> [1;2] <*> [10;20]\n// resultAdd = [11; 22]\n// [ (add 1 10); (add 2 20) ] \n```", "```\nmodule ZipSeq =\n\n    // define \"return\" for ZipSeqWorld\n    let retn x = Seq.initInfinite (fun _ -> x)\n\n    // define \"apply\" for ZipSeqWorld\n    // (where we can define apply in terms of \"lift2\", aka \"map2\")\n    let apply fSeq xSeq  = \n        Seq.map2 (fun f x -> f x)  fSeq xSeq  \n    // has type : ('a -> 'b) seq -> 'a seq -> 'b seq\n\n    // define a sequence that is a combination of two others\n    let triangularNumbers = \n        let (<*>) = apply\n\n        let addAndDivideByTwo x y = (x + y) / 2\n        let numbers = Seq.initInfinite id\n        let squareNumbers = Seq.initInfinite (fun i -> i * i)\n        (retn addAndDivideByTwo) <*> numbers <*> squareNumbers \n\n    // evaulate first 10 elements \n    // and display result \n    triangularNumbers |> Seq.take 10 |> List.ofSeq |> printfn \"%A\"\n    // Result =>\n    // [0; 1; 3; 6; 10; 15; 21; 28; 36; 45] \n```", "```\nmodule Option = \n\n    // The bind function for Options\n    let bind f xOpt = \n        match xOpt with\n        | Some x -> f x\n        | _ -> None\n    // has type : ('a -> 'b option) -> 'a option -> 'b option\n\nmodule List = \n\n    // The bind function for lists\n    let bindList (f: 'a->'b list) (xList: 'a list)  = \n        [ for x in xList do \n          for y in f x do \n              yield y ]\n    // has type : ('a -> 'b list) -> 'a list -> 'b list \n```", "```\nlet parseInt str = \n    match str with\n    | \"-1\" -> Some -1\n    | \"0\" -> Some 0\n    | \"1\" -> Some 1\n    | \"2\" -> Some 2\n    // etc\n    | _ -> None\n\n// signature is string -> int option \n```", "```\ntype OrderQty = OrderQty of int\n\nlet toOrderQty qty = \n    if qty >= 1 then \n        Some (OrderQty qty)\n    else\n        // only positive numbers allowed\n        None\n\n// signature is int -> OrderQty option \n```", "```\nlet parseOrderQty str =\n    parseInt str\n    |> Option.bind toOrderQty\n// signature is string -> OrderQty option \n```", "```\nlet parseOrderQty_alt str =\n    str |> parseInt >>= toOrderQty \n```", "```\nexpression1 >>= \nexpression2 >>= \nexpression3 >>= \nexpression4 \n```", "```\nstatement1; \nstatement2;\nstatement3;\nstatement4; \n```", "```\ninitialExpression >>= (fun x ->\nexpressionUsingX  >>= (fun y ->\nexpressionUsingY  >>= (fun z ->\nx+y+z )))             // return \n```", "```\nelevated {\n    let! x = initialExpression \n    let! y = expressionUsingX x\n    let! z = expressionUsingY y\n    return x+y+z } \n```", "```\ndo\n    x <- initialExpression \n    y <- expressionUsingX x\n    z <- expressionUsingY y\n    return x+y+z \n```", "```\nfor {\n    x <- initialExpression \n    y <- expressionUsingX(x)\n    z <- expressionUsingY(y)\n} yield {    \n    x+y+z\n} \n```", "```\n// map defined in terms of bind and return (Some)\nlet map f = \n    Option.bind (f >> Some) \n\n// apply defined in terms of bind and return (Some)\nlet apply fOpt xOpt = \n    fOpt |> Option.bind (fun f -> \n        let map = Option.bind (f >> Some)\n        map xOpt) \n```", "```\nlet groupFromTheLeft = (a |> f) |> g\nlet groupFromTheRight = a |> (f >> g) \n```", "```\nlet groupFromTheLeft = (a >>= f) >>= g\nlet groupFromTheRight = a >>= (fun x -> f x >>= g) \n```", "```\ntype CustomerId = CustomerId of int\ntype EmailAddress = EmailAddress of string\ntype CustomerInfo = {\n    id: CustomerId\n    email: EmailAddress\n    } \n```", "```\ntype Result<'a> = \n    | Success of 'a\n    | Failure of string list \n```", "```\nlet createCustomerId id =\n    if id > 0 then\n        Success (CustomerId id)\n    else\n        Failure [\"CustomerId must be positive\"]\n// int -> Result<CustomerId>\n\nlet createEmailAddress str =\n    if System.String.IsNullOrEmpty(str) then\n        Failure [\"Email must not be empty\"]\n    elif str.Contains(\"@\") then\n        Success (EmailAddress str)\n    else\n        Failure [\"Email must contain @-sign\"]\n// string -> Result<EmailAddress> \n```", "```\nmodule Result = \n\n    let map f xResult = \n        match xResult with\n        | Success x ->\n            Success (f x)\n        | Failure errs ->\n            Failure errs\n    // Signature: ('a -> 'b) -> Result<'a> -> Result<'b>\n\n    // \"return\" is a keyword in F#, so abbreviate it\n    let retn x = \n        Success x\n    // Signature: 'a -> Result<'a>\n\n    let apply fResult xResult = \n        match fResult,xResult with\n        | Success f, Success x ->\n            Success (f x)\n        | Failure errs, Success x ->\n            Failure errs\n        | Success f, Failure errs ->\n            Failure errs\n        | Failure errs1, Failure errs2 ->\n            // concat both lists of errors\n            Failure (List.concat [errs1; errs2])\n    // Signature: Result<('a -> 'b)> -> Result<'a> -> Result<'b>\n\n    let bind f xResult = \n        match xResult with\n        | Success x ->\n            f x\n        | Failure errs ->\n            Failure errs\n    // Signature: ('a -> Result<'b>) -> Result<'a> -> Result<'b> \n```", "```\nlet createCustomer customerId email = \n    { id=customerId;  email=email }\n// CustomerId -> EmailAddress -> CustomerInfo \n```", "```\nlet (<!>) = Result.map\nlet (<*>) = Result.apply\n\n// applicative version\nlet createCustomerResultA id email = \n    let idResult = createCustomerId id\n    let emailResult = createEmailAddress email\n    createCustomer <!> idResult <*> emailResult\n// int -> string -> Result<CustomerInfo> \n```", "```\nlet goodId = 1\nlet badId = 0\nlet goodEmail = \"test@example.com\"\nlet badEmail = \"example.com\"\n\nlet goodCustomerA =\n    createCustomerResultA goodId goodEmail\n// Result<CustomerInfo> =\n//   Success {id = CustomerId 1; email = EmailAddress \"test@example.com\";}\n\nlet badCustomerA =\n    createCustomerResultA badId badEmail\n// Result<CustomerInfo> =\n//   Failure [\"CustomerId must be positive\"; \"Email must contain @-sign\"] \n```", "```\nlet (>>=) x f = Result.bind f x\n\n// monadic version\nlet createCustomerResultM id email = \n    createCustomerId id >>= (fun customerId ->\n    createEmailAddress email >>= (fun emailAddress ->\n    let customer = createCustomer customerId emailAddress \n    Success customer\n    ))\n// int -> string -> Result<CustomerInfo> \n```", "```\nlet goodCustomerM =\n    createCustomerResultM goodId goodEmail\n// Result<CustomerInfo> =\n//   Success {id = CustomerId 1; email = EmailAddress \"test@example.com\";}\n\nlet badCustomerM =\n    createCustomerResultM badId badEmail\n// Result<CustomerInfo> =\n//   Failure [\"CustomerId must be positive\"] \n```", "```\nmodule Result = \n\n    type ResultBuilder() =\n        member this.Return x = retn x\n        member this.Bind(x,f) = bind f x\n\n    let result = new ResultBuilder() \n```", "```\nlet createCustomerResultCE id email = result {\n    let! customerId = createCustomerId id \n    let! emailAddress = createEmailAddress email  \n    let customer = createCustomer customerId emailAddress \n    return customer } \n```", "```\ntype CustomerId = CustomerId of int\ntype EmailAddress = EmailAddress of string\n\ntype CustomerInfo = {\n    id: CustomerId\n    name: string  // New!\n    email: EmailAddress\n    } \n```", "```\nlet createCustomer customerId name email = \n    { id=customerId; name=name; email=email }\n// CustomerId -> String -> EmailAddress -> CustomerInfo \n```", "```\nlet (<!>) = Result.map\nlet (<*>) = Result.apply\n\nlet createCustomerResultA id name email = \n    let idResult = createCustomerId id\n    let emailResult = createEmailAddress email\n    createCustomer <!> idResult <*> name <*> emailResult\n// ERROR                            ~~~~ \n```", "```\nlet createCustomerResultA id name email = \n    let idResult = createCustomerId id\n    let emailResult = createEmailAddress email\n    let nameResult = Success name  // lift name to Result\n    createCustomer <!> idResult <*> nameResult <*> emailResult \n```", "```\nlet (<*>) = Option.apply\nlet retn = Some\n\nlet rec mapOption f list =\n    let cons head tail = head :: tail\n    match list with\n    | [] -> \n        retn []\n    | head::tail ->\n        retn cons <*> (f head) <*> (mapOption f tail) \n```", "```\nlet parseInt str =\n    match (System.Int32.TryParse str) with\n    | true,i -> Some i\n    | false,_ -> None\n// string -> int option\n\nlet good = [\"1\";\"2\";\"3\"] |> mapOption parseInt\n// Some [1; 2; 3]\n\nlet bad = [\"1\";\"x\";\"y\"] |> mapOption parseInt\n// None \n```", "```\nlet (<*>) = Result.apply\nlet retn = Success\n\nlet rec mapResult f list =\n    let cons head tail = head :: tail\n    match list with\n    | [] -> \n        retn []\n    | head::tail ->\n        retn cons <*> (f head) <*> (mapResult f tail) \n```", "```\nlet parseInt str =\n    match (System.Int32.TryParse str) with\n    | true,i -> Success i\n    | false,_ -> Failure [str + \" is not an int\"] \n```", "```\nlet good = [\"1\";\"2\";\"3\"] |> mapResult parseInt\n// Success [1; 2; 3]\n\nlet bad = [\"1\";\"x\";\"y\"] |> mapResult parseInt\n// Failure [\"x is not an int\"; \"y is not an int\"] \n```", "```\nlet rec mapE (retn,ap) f list =\n    let cons head tail = head :: tail\n    let (<*>) = ap \n\n    match list with\n    | [] -> \n        retn []\n    | head::tail ->\n        (retn cons) <*> (f head) <*> (mapE retn ap f tail) \n```", "```\ntype Applicative<'a,'b> = {\n    retn: 'a -> E<'a>\n    apply: E<'a->'b> -> E<'a> -> E<'b>\n    }            \n\n// functions for applying Option \nlet applOption = {retn = Option.Some; apply=Option.apply}\n\n// functions for applying Result\nlet applResult = {retn = Result.Success; apply=Result.apply} \n```", "```\nlet rec mapE appl f list =\n    let cons head tail = head :: tail\n    let (<*>) = appl.apply\n    let retn = appl.retn\n\n    match list with\n    | [] -> \n        retn []\n    | head::tail ->\n        (retn cons) <*> (f head) <*> (mapE retn ap f tail) \n```", "```\n// build an Option specific version...\nlet mapOption = mapE applOption    \n\n// ...and use it\nlet good = [\"1\";\"2\";\"3\"] |> mapOption parseInt \n```", "```\nmodule List =\n\n    /// Map a Result producing function over a list to get a new Result \n    /// using applicative style\n    /// ('a -> Result<'b>) -> 'a list -> Result<'b list>\n    let rec traverseResultA f list =\n\n        // define the applicative functions\n        let (<*>) = Result.apply\n        let retn = Result.Success\n\n        // define a \"cons\" function\n        let cons head tail = head :: tail\n\n        // loop through the list\n        match list with\n        | [] -> \n            // if empty, lift [] to a Result\n            retn []\n        | head::tail ->\n            // otherwise lift the head to a Result using f\n            // and cons it with the lifted version of the remaining list\n            retn cons <*> (f head) <*> (traverseResultA f tail)\n\n    /// Map a Result producing function over a list to get a new Result \n    /// using monadic style\n    /// ('a -> Result<'b>) -> 'a list -> Result<'b list>\n    let rec traverseResultM f list =\n\n        // define the monadic functions\n        let (>>=) x f = Result.bind f x\n        let retn = Result.Success\n\n        // define a \"cons\" function\n        let cons head tail = head :: tail\n\n        // loop through the list\n        match list with\n        | [] -> \n            // if empty, lift [] to a Result\n            retn []\n        | head::tail ->\n            // otherwise lift the head to a Result using f\n            // then lift the tail to a Result using traverse\n            // then cons the head and tail and return it\n            f head                 >>= (fun h -> \n            traverseResultM f tail >>= (fun t ->\n            retn (cons h t) )) \n```", "```\n/// parse an int and return a Result\n/// string -> Result<int>\nlet parseInt str =\n    match (System.Int32.TryParse str) with\n    | true,i -> Result.Success i\n    | false,_ -> Result.Failure [str + \" is not an int\"] \n```", "```\n// pass in strings wrapped in a List\n// (applicative version)\nlet goodA = [\"1\"; \"2\"; \"3\"] |> List.traverseResultA parseInt\n// get back a Result containing a list of ints\n// Success [1; 2; 3]\n\n// pass in strings wrapped in a List\n// (monadic version)\nlet goodM = [\"1\"; \"2\"; \"3\"] |> List.traverseResultM parseInt\n// get back a Result containing a list of ints\n// Success [1; 2; 3] \n```", "```\n// pass in strings wrapped in a List\n// (applicative version)\nlet badA = [\"1\"; \"x\"; \"y\"] |> List.traverseResultA parseInt\n// get back a Result containing a list of ints\n// Failure [\"x is not an int\"; \"y is not an int\"]\n\n// pass in strings wrapped in a List\n// (monadic version)\nlet badM = [\"1\"; \"x\"; \"y\"] |> List.traverseResultM parseInt\n// get back a Result containing a list of ints\n// Failure [\"x is not an int\"] \n```", "```\n/// Map a Result producing function over a list to get a new Result \n/// using applicative style\n/// ('a -> Result<'b>) -> 'a list -> Result<'b list>\nlet traverseResultA f list =\n\n    // define the applicative functions\n    let (<*>) = Result.apply\n    let retn = Result.Success\n\n    // define a \"cons\" function\n    let cons head tail = head :: tail\n\n    // right fold over the list\n    let initState = retn []\n    let folder head tail = \n        retn cons <*> (f head) <*> tail\n\n    List.foldBack folder list initState \n\n/// Map a Result producing function over a list to get a new Result \n/// using monadic style\n/// ('a -> Result<'b>) -> 'a list -> Result<'b list>\nlet traverseResultM f list =\n\n    // define the monadic functions\n    let (>>=) x f = Result.bind f x\n    let retn = Result.Success\n\n    // define a \"cons\" function\n    let cons head tail = head :: tail\n\n    // right fold over the list\n    let initState = retn []\n    let folder head tail = \n        f head >>= (fun h -> \n        tail >>= (fun t ->\n        retn (cons h t) ))\n\n    List.foldBack folder list initState \n```", "```\nmodule Option = \n\n    /// Map a Result producing function over an Option to get a new Result \n    /// ('a -> Result<'b>) -> 'a option -> Result<'b option>\n    let traverseResultA f opt =\n\n        // define the applicative functions\n        let (<*>) = Result.apply\n        let retn = Result.Success\n\n        // loop through the option\n        match opt with\n        | None -> \n            // if empty, lift None to an Result\n            retn None\n        | Some x -> \n            // lift value to an Result\n            (retn Some) <*> (f x) \n```", "```\n// pass in an string wrapped in an Option\nlet good = Some \"1\" |> Option.traverseResultA parseInt\n// get back a Result containing an Option\n// Success (Some 1) \n```", "```\n// pass in an string wrapped in an Option\nlet bad = Some \"x\" |> Option.traverseResultA parseInt\n// get back a Result containing an Option\n// Failure [\"x is not an int\"] \n```", "```\n// pass in an string wrapped in an Option\nlet goodNone = None |> Option.traverseResultA parseInt\n// get back a Result containing an Option\n// Success (None) \n```", "```\nmodule List =   \n\n    /// Transform a \"list<Result>\" into a \"Result<list>\"\n    /// and collect the results using apply\n    /// Result<'a> list -> Result<'a list>\n    let sequenceResultA x = traverseResultA id x\n\n    /// Transform a \"list<Result>\" into a \"Result<list>\" \n    /// and collect the results using bind.\n    /// Result<'a> list -> Result<'a list>\n    let sequenceResultM x = traverseResultM id x \n```", "```\nlet goodSequenceA = \n    [\"1\"; \"2\"; \"3\"] \n    |> List.map parseInt\n    |> List.sequenceResultA\n// Success [1; 2; 3]\n\nlet badSequenceA = \n    [\"1\"; \"x\"; \"y\"] \n    |> List.map parseInt\n    |> List.sequenceResultA\n// Failure [\"x is not an int\"; \"y is not an int\"] \n```", "```\nlet goodSequenceM = \n    [\"1\"; \"2\"; \"3\"] \n    |> List.map parseInt\n    |> List.sequenceResultM\n// Success [1; 2; 3]\n\nlet badSequenceM = \n    [\"1\"; \"x\"; \"y\"] \n    |> List.map parseInt\n    |> List.sequenceResultM\n// Failure [\"x is not an int\"] \n```", "```\nlet tuples = [Some (1,2); Some (3,4); None; Some (7,8);]\n// List<Option<Tuple<int>>> \n```", "```\nlet desiredOutput = [Some 1; Some 3; None; Some 7],[Some 2; Some 4; None; Some 8]\n// Tuple<List<Option<int>>> \n```", "```\nlet tupleReturn x = (x, x)\nlet tupleApply (f,g) (x,y) = (f x, g y) \n```", "```\nlet listSequenceTuple list =\n    // define the applicative functions\n    let (<*>) = tupleApply \n    let retn = tupleReturn \n\n    // define a \"cons\" function\n    let cons head tail = head :: tail\n\n    // right fold over the list\n    let initState = retn []\n    let folder head tail = retn cons <*> head <*> tail\n\n    List.foldBack folder list initState \n```", "```\n[ (1,2); (3,4)] |> listSequenceTuple    \n// Result => ([1; 3], [2; 4]) \n```", "```\nlet optionSequenceTuple opt =\n    // define the applicative functions\n    let (<*>) = tupleApply \n    let retn = tupleReturn \n\n    // right fold over the option\n    let initState = retn None\n    let folder x _ = (retn Some) <*> x \n\n    Option.foldBack folder opt initState \n```", "```\nSome (1,2) |> optionSequenceTuple\n// Result => (Some 1, Some 2) \n```", "```\nlet convert input =\n    input\n\n    // from List<Option<Tuple<int>>> to List<Tuple<Option<int>>>\n    |> List.map optionSequenceTuple\n\n    // from List<Tuple<Option<int>>> to Tuple<List<Option<int>>>\n    |> listSequenceTuple \n```", "```\nlet output = convert tuples\n// ( [Some 1; Some 3; None; Some 7], [Some 2; Some 4; None; Some 8] )\n\noutput = desiredOutput |> printfn \"Is output correct? %b\"\n// Is output correct? true \n```", "```\n[\"1\"; \"2\"; \"3\"] \n|> List.map parseInt\n|> List.sequenceResultM \n```", "```\n[\"1\"; \"2\"; \"3\"] \n|> List.traverseResultM parseInt \n```", "```\n// define a millisecond Unit of Measure\ntype [<Measure>] ms\n\n/// Custom implementation of WebClient with settable timeout\ntype WebClientWithTimeout(timeout:int<ms>) =\n    inherit System.Net.WebClient()\n\n    override this.GetWebRequest(address) =\n        let result = base.GetWebRequest(address)\n        result.Timeout <- int timeout \n        result \n```", "```\n// The content of a downloaded page \ntype UriContent = \n    UriContent of System.Uri * string\n\n// The content size of a downloaded page \ntype UriContentSize = \n    UriContentSize of System.Uri * int \n```", "```\n/// Get the contents of the page at the given Uri\n/// Uri -> Async<Result<UriContent>>\nlet getUriContent (uri:System.Uri) = \n    async {\n        use client = new WebClientWithTimeout(1000<ms>) // 1 sec timeout\n        try\n            printfn \"  [%s] Started ...\" uri.Host\n            let! html = client.AsyncDownloadString(uri) \n            printfn \"  [%s] ... finished\" uri.Host\n            let uriContent = UriContent (uri, html)\n            return (Result.Success uriContent)\n        with\n        | ex -> \n            printfn \"  [%s] ... exception\" uri.Host\n            let err = sprintf \"[%s] %A\" uri.Host ex.Message\n            return Result.Failure [err ]\n        } \n```", "```\nlet showContentResult result =\n    match result with\n    | Success (UriContent (uri, html)) -> \n        printfn \"SUCCESS: [%s] First 100 chars: %s\" uri.Host (html.Substring(0,100)) \n    | Failure errs -> \n        printfn \"FAILURE: %A\" errs \n```", "```\nSystem.Uri (\"http://google.com\") \n|> getUriContent \n|> Async.RunSynchronously \n|> showContentResult \n\n//  [google.com] Started ...\n//  [google.com] ... finished\n// SUCCESS: [google.com] First 100 chars: <!doctype html><html itemscope=\"\" itemtype=\"http://schema.org/WebPage\" lang=\"en-GB\"><head><meta cont \n```", "```\nSystem.Uri (\"http://example.bad\") \n|> getUriContent \n|> Async.RunSynchronously \n|> showContentResult \n\n//  [example.bad] Started ...\n//  [example.bad] ... exception\n// FAILURE: [\"[example.bad] \"The remote name could not be resolved: 'example.bad'\"\"] \n```", "```\nmodule Async = \n\n    let map f xAsync = async {\n        // get the contents of xAsync \n        let! x = xAsync \n        // apply the function and lift the result\n        return f x\n        }\n\n    let retn x = async {\n        // lift x to an Async\n        return x\n        }\n\n    let apply fAsync xAsync = async {\n        // start the two asyncs in parallel\n        let! fChild = Async.StartChild fAsync\n        let! xChild = Async.StartChild xAsync\n\n        // wait for the results\n        let! f = fChild\n        let! x = xChild \n\n        // apply the function to the results\n        return f x \n        }\n\n    let bind f xAsync = async {\n        // get the contents of xAsync \n        let! x = xAsync \n        // apply the function but don't lift the result\n        // as f will return an Async\n        return! f x\n        } \n```", "```\n/// Make a UriContentSize from a UriContent\n/// UriContent -> Result<UriContentSize>\nlet makeContentSize (UriContent (uri, html)) = \n    if System.String.IsNullOrEmpty(html) then\n        Result.Failure [\"empty page\"]\n    else\n        let uriContentSize = UriContentSize (uri, html.Length)\n        Result.Success uriContentSize \n```", "```\n/// Get the size of the contents of the page at the given Uri\n/// Uri -> Async<Result<UriContentSize>>\nlet getUriContentSize uri =\n    getUriContent uri \n    |> Async.map (Result.bind makeContentSize) \n```", "```\nlet showContentSizeResult result =\n    match result with\n    | Success (UriContentSize (uri, len)) -> \n        printfn \"SUCCESS: [%s] Content size is %i\" uri.Host len \n    | Failure errs -> \n        printfn \"FAILURE: %A\" errs \n```", "```\nSystem.Uri (\"http://google.com\") \n|> getUriContentSize \n|> Async.RunSynchronously \n|> showContentSizeResult \n\n//  [google.com] Started ...\n//  [google.com] ... finished\n//SUCCESS: [google.com] Content size is 44293 \n```", "```\nSystem.Uri (\"http://example.bad\") \n|> getUriContentSize\n|> Async.RunSynchronously \n|> showContentSizeResult \n\n//  [example.bad] Started ...\n//  [example.bad] ... exception\n//FAILURE: [\"[example.bad] \"The remote name could not be resolved: 'example.bad'\"\"] \n```", "```\n/// Get the largest UriContentSize from a list\n/// UriContentSize list -> UriContentSize\nlet maxContentSize list = \n\n    // extract the len field from a UriContentSize \n    let contentSize (UriContentSize (_, len)) = len\n\n    // use maxBy to find the largest \n    list |> List.maxBy contentSize \n```", "```\n/// Get the largest page size from a list of websites\nlet largestPageSizeA urls = \n    urls\n    // turn the list of strings into a list of Uris\n    // (In F# v4, we can call System.Uri directly!)\n    |> List.map (fun s -> System.Uri(s))   \n\n    // turn the list of Uris into a \"Async<Result<UriContentSize>> list\" \n    |> List.map getUriContentSize\n\n    // turn the \"Async<Result<UriContentSize>> list\" \n    //   into an \"Async<Result<UriContentSize> list>\"\n    |> List.sequenceAsyncA\n\n    // turn the \"Async<Result<UriContentSize> list>\" \n    //   into a \"Async<Result<UriContentSize list>>\"\n    |> Async.map List.sequenceResultA\n\n    // find the largest in the inner list to get \n    //   a \"Async<Result<UriContentSize>>\"\n    |> Async.map (Result.map maxContentSize) \n```", "```\nmodule List =\n\n    /// Map a Async producing function over a list to get a new Async \n    /// using applicative style\n    /// ('a -> Async<'b>) -> 'a list -> Async<'b list>\n    let rec traverseAsyncA f list =\n\n        // define the applicative functions\n        let (<*>) = Async.apply\n        let retn = Async.retn\n\n        // define a \"cons\" function\n        let cons head tail = head :: tail\n\n        // right fold over the list\n        let initState = retn []\n        let folder head tail = \n            retn cons <*> (f head) <*> tail\n\n        List.foldBack folder list initState \n\n    /// Transform a \"list<Async>\" into a \"Async<list>\" \n    /// and collect the results using apply.\n    let sequenceAsyncA x = traverseAsyncA id x\n\n    /// Map a Result producing function over a list to get a new Result \n    /// using applicative style\n    /// ('a -> Result<'b>) -> 'a list -> Result<'b list>\n    let rec traverseResultA f list =\n\n        // define the applicative functions\n        let (<*>) = Result.apply\n        let retn = Result.Success\n\n        // define a \"cons\" function\n        let cons head tail = head :: tail\n\n        // right fold over the list\n        let initState = retn []\n        let folder head tail = \n            retn cons <*> (f head) <*> tail\n\n        List.foldBack folder list initState \n\n    /// Transform a \"list<Result>\" into a \"Result<list>\" \n    /// and collect the results using apply.\n    let sequenceResultA x = traverseResultA id x \n```", "```\n/// Do countN repetitions of the function f and print the time per run\nlet time countN label f  = \n\n    let stopwatch = System.Diagnostics.Stopwatch()\n\n    // do a full GC at the start but not thereafter\n    // allow garbage to collect for each iteration\n    System.GC.Collect()  \n\n    printfn \"=======================\"         \n    printfn \"%s\" label \n    printfn \"=======================\"         \n\n    let mutable totalMs = 0L\n\n    for iteration in [1..countN] do\n        stopwatch.Restart() \n        f()\n        stopwatch.Stop() \n        printfn \"#%2i elapsed:%6ims \" iteration stopwatch.ElapsedMilliseconds \n        totalMs <- totalMs + stopwatch.ElapsedMilliseconds\n\n    let avgTimePerRun = totalMs / int64 countN\n    printfn \"%s: Average time per run:%6ims \" label avgTimePerRun \n```", "```\nlet goodSites = [\n    \"http://google.com\"\n    \"http://bbc.co.uk\"\n    \"http://fsharp.org\"\n    \"http://microsoft.com\"\n    ]\n\nlet badSites = [\n    \"http://example.com/nopage\"\n    \"http://bad.example.com\"\n    \"http://verybad.example.com\"\n    \"http://veryverybad.example.com\"\n    ] \n```", "```\nlet f() = \n    largestPageSizeA goodSites\n    |> Async.RunSynchronously \n    |> showContentSizeResult \ntime 10 \"largestPageSizeA_Good\" f \n```", "```\n[google.com] Started ...\n[bbc.co.uk] Started ...\n[fsharp.org] Started ...\n[microsoft.com] Started ...\n[bbc.co.uk] ... finished\n[fsharp.org] ... finished\n[google.com] ... finished\n[microsoft.com] ... finished\n\nSUCCESS: [bbc.co.uk] Content size is 108983\nlargestPageSizeA_Good: Average time per run:   533ms \n```", "```\nlet f() = \n    largestPageSizeA badSites\n    |> Async.RunSynchronously \n    |> showContentSizeResult \ntime 10 \"largestPageSizeA_Bad\" f \n```", "```\n[example.com] Started ...\n[bad.example.com] Started ...\n[verybad.example.com] Started ...\n[veryverybad.example.com] Started ...\n[verybad.example.com] ... exception\n[veryverybad.example.com] ... exception\n[example.com] ... exception\n[bad.example.com] ... exception\n\nFAILURE: [\n \"[example.com] \"The remote server returned an error: (404) Not Found.\"\";\n \"[bad.example.com] \"The remote name could not be resolved: 'bad.example.com'\"\";\n \"[verybad.example.com] \"The remote name could not be resolved: 'verybad.example.com'\"\";\n \"[veryverybad.example.com] \"The remote name could not be resolved: 'veryverybad.example.com'\"\"]\n\nlargestPageSizeA_Bad: Average time per run:  2252ms \n```", "```\nlet largestPageSizeA urls = \n    urls\n    |> List.map (fun s -> System.Uri(s))   \n    |> List.map getUriContentSize\n    |> List.sequenceAsyncA\n    |> Async.map List.sequenceResultA\n    |> Async.map (Result.map maxContentSize) \n```", "```\nlet largestPageSizeA urls = \n    urls\n    |> List.map (fun s -> System.Uri(s) |> getUriContentSize)   \n    |> List.sequenceAsyncA\n    |> Async.map List.sequenceResultA\n    |> Async.map (Result.map maxContentSize) \n```", "```\nlet largestPageSizeA urls = \n    urls\n    |> List.traverseAsyncA (fun s -> System.Uri(s) |> getUriContentSize)   \n    |> Async.map List.sequenceResultA\n    |> Async.map (Result.map maxContentSize) \n```", "```\nlet largestPageSizeA urls = \n    urls\n    |> List.traverseAsyncA (fun s -> System.Uri(s) |> getUriContentSize)   \n    |> Async.map (List.sequenceResultA >> Result.map maxContentSize) \n```", "```\nlet largestPageSizeM urls = \n    urls\n    |> List.map (fun s -> System.Uri(s))\n    |> List.map getUriContentSize\n    |> List.sequenceAsyncM              // <= \"M\" version\n    |> Async.map List.sequenceResultM   // <= \"M\" version\n    |> Async.map (Result.map maxContentSize) \n```", "```\nlet f() = \n    largestPageSizeM goodSites\n    |> Async.RunSynchronously \n    |> showContentSizeResult \ntime 10 \"largestPageSizeM_Good\" f \n```", "```\n [google.com] Started ...\n  [google.com] ... finished\n  [bbc.co.uk] Started ...\n  [bbc.co.uk] ... finished\n  [fsharp.org] Started ...\n  [fsharp.org] ... finished\n  [microsoft.com] Started ...\n  [microsoft.com] ... finished\n\nSUCCESS: [bbc.co.uk] Content size is 108695\nlargestPageSizeM_Good: Average time per run:   955ms \n```", "```\nlet f() = \n    largestPageSizeM badSites\n    |> Async.RunSynchronously \n    |> showContentSizeResult \ntime 10 \"largestPageSizeM_Bad\" f \n```", "```\n[example.com] Started ...\n[example.com] ... exception\n[bad.example.com] Started ...\n[bad.example.com] ... exception\n[verybad.example.com] Started ...\n[verybad.example.com] ... exception\n[veryverybad.example.com] Started ...\n[veryverybad.example.com] ... exception\n\nFAILURE: [\"[example.com] \"The remote server returned an error: (404) Not Found.\"\"]\nlargestPageSizeM_Bad: Average time per run:  2371ms \n```", "```\n/// type alias (optional)\ntype AsyncResult<'a> = Async<Result<'a>>\n\n/// functions for AsyncResult \nmodule AsyncResult =\nmodule AsyncResult =\n\n    let map f = \n        f |> Result.map |> Async.map \n\n    let retn x = \n        x |> Result.retn |> Async.retn\n\n    let apply fAsyncResult xAsyncResult = \n        fAsyncResult |> Async.bind (fun fResult -> \n        xAsyncResult |> Async.map (fun xResult -> \n        Result.apply fResult xResult))\n\n    let bind f xAsyncResult = async {\n        let! xResult = xAsyncResult \n        match xResult with\n        | Success x -> return! f x\n        | Failure err -> return (Failure err)\n        } \n```", "```\nmodule List =\n\n    /// Map an AsyncResult producing function over a list to get a new AsyncResult\n    /// using monadic style\n    /// ('a -> AsyncResult<'b>) -> 'a list -> AsyncResult<'b list>\n    let rec traverseAsyncResultM f list =\n\n        // define the monadic functions\n        let (>>=) x f = AsyncResult.bind f x\n        let retn = AsyncResult.retn\n\n        // define a \"cons\" function\n        let cons head tail = head :: tail\n\n        // right fold over the list\n        let initState = retn []\n        let folder head tail = \n            f head >>= (fun h -> \n            tail >>= (fun t ->\n            retn (cons h t) ))\n\n        List.foldBack folder list initState \n\n    /// Transform a \"list<AsyncResult>\" into a \"AsyncResult<list>\"\n    /// and collect the results using bind.\n    let sequenceAsyncResultM x = traverseAsyncResultM id x \n```", "```\nlet largestPageSizeM_AR urls = \n    urls\n    |> List.map (fun s -> System.Uri(s) |> getUriContentSize)\n    |> List.sequenceAsyncResultM \n    |> AsyncResult.map maxContentSize \n```", "```\nlet f() = \n    largestPageSizeM_AR goodSites\n    |> Async.RunSynchronously \n    |> showContentSizeResult \ntime 10 \"largestPageSizeM_AR_Good\" f \n```", "```\n[google.com] Started ...\n[google.com] ... finished\n[bbc.co.uk] Started ...\n[bbc.co.uk] ... finished\n[fsharp.org] Started ...\n[fsharp.org] ... finished\n[microsoft.com] Started ...\n[microsoft.com] ... finished\n\nSUCCESS: [bbc.co.uk] Content size is 108510\nlargestPageSizeM_AR_Good: Average time per run:  1026ms \n```", "```\nlet f() = \n    largestPageSizeM_AR badSites\n    |> Async.RunSynchronously \n    |> showContentSizeResult \ntime 10 \"largestPageSizeM_AR_Bad\" f \n```", "```\n [example.com] Started ...\n  [example.com] ... exception\n\nFAILURE: [\"[example.com] \"The remote server returned an error: (404) Not Found.\"\"]\nlargestPageSizeM_AR_Bad: Average time per run:   117ms \n```", "```\nOpen API connection\nGet product ids purchased by customer id using the API\nFor each product id:\n    get the product info for that id using the API\nClose API connection\nReturn the list of product infos \n```", "```\ntype CustId = CustId of string\ntype ProductId = ProductId of string\ntype ProductInfo = {ProductName: string; } \n```", "```\ntype ApiClient() =\n    // static storage\n    static let mutable data = Map.empty<string,obj>\n\n    /// Try casting a value\n    /// Return Success of the value or Failure on failure\n    member private this.TryCast<'a> key (value:obj) =\n        match value with\n        | :? 'a as a ->\n            Result.Success a \n        | _  ->                 \n            let typeName = typeof<'a>.Name\n            Result.Failure [sprintf \"Can't cast value at %s to %s\" key typeName]\n\n    /// Get a value\n    member this.Get<'a> (id:obj) = \n        let key =  sprintf \"%A\" id\n        printfn \"[API] Get %s\" key\n        match Map.tryFind key data with\n        | Some o -> \n            this.TryCast<'a> key o\n        | None -> \n            Result.Failure [sprintf \"Key %s not found\" key]\n\n    /// Set a value\n    member this.Set (id:obj) (value:obj) = \n        let key =  sprintf \"%A\" id\n        printfn \"[API] Set %s\" key\n        if key = \"bad\" then  // for testing failure paths\n            Result.Failure [sprintf \"Bad Key %s \" key]\n        else\n            data <- Map.add key value data \n            Result.Success ()\n\n    member this.Open() =\n        printfn \"[API] Opening\"\n\n    member this.Close() =\n        printfn \"[API] Closing\"\n\n    interface System.IDisposable with\n        member this.Dispose() =\n            printfn \"[API] Disposing\" \n```", "```\ndo\n    use api = new ApiClient()\n    api.Get \"K1\" |> printfn \"[K1] %A\"\n\n    api.Set \"K2\" \"hello\" |> ignore\n    api.Get<string> \"K2\" |> printfn \"[K2] %A\"\n\n    api.Set \"K3\" \"hello\" |> ignore\n    api.Get<int> \"K3\" |> printfn \"[K3] %A\" \n```", "```\n[API] Get \"K1\"\n[K1] Failure [\"Key \"K1\" not found\"]\n[API] Set \"K2\"\n[API] Get \"K2\"\n[K2] Success \"hello\"\n[API] Set \"K3\"\n[API] Get \"K3\"\n[K3] Failure [\"Can't cast value at \"K3\" to Int32\"]\n[API] Disposing \n```", "```\nlet getPurchaseInfo (custId:CustId) : Result<ProductInfo list> =\n\n    // Open api connection \n    use api = new ApiClient()\n    api.Open()\n\n    // Get product ids purchased by customer id\n    let productIdsResult = api.Get<ProductId list> custId\n\n    let productInfosResult = ??\n\n    // Close api connection\n    api.Close()\n\n    // Return the list of product infos\n    productInfosResult \n```", "```\nlet getPurchaseInfo (custId:CustId) : Result<ProductInfo list> =\n\n    // Open api connection \n    use api = new ApiClient()\n    api.Open()\n\n    // Get product ids purchased by customer id\n    let productIdsResult = api.Get<ProductId list> custId\n\n    let productInfosResult =\n        match productIdsResult with\n        | Success productIds -> \n            let productInfos = ResizeArray()  // Same as .NET List<T>\n            for productId in productIds do\n                let productInfo = api.Get<ProductInfo> productId\n                productInfos.Add productInfo  // mutation! \n            Success productInfos\n        | Failure err ->    \n            Failure err \n\n    // Close api connection\n    api.Close()\n\n    // Return the list of product infos\n    productInfosResult \n```", "```\nlet getPurchaseInfo (custId:CustId) : Result<ProductInfo list> =\n\n    // Open api connection \n    use api = new ApiClient()\n    api.Open()\n\n    // Get product ids purchased by customer id\n    let productIdsResult = api.Get<ProductId list> custId\n\n    let productInfosResult =\n        match productIdsResult with\n        | Success productIds -> \n            let productInfos = ResizeArray()  // Same as .NET List<T>\n            let mutable anyFailures = false\n            for productId in productIds do\n                let productInfoResult = api.Get<ProductInfo> productId\n                match productInfoResult with\n                | Success productInfo ->\n                    productInfos.Add productInfo \n                | Failure err ->    \n                    Failure err \n            Success productInfos\n        | Failure err ->    \n            Failure err \n\n    // Close api connection\n    api.Close()\n\n    // Return the list of product infos\n    productInfosResult \n```", "```\n/// CustId -> Result<ProductInfo list>\nlet getPurchaseInfo (custId:CustId) : Result<ProductInfo list> =\n\n    // Open api connection \n    use api = new ApiClient()\n    api.Open()\n\n    let productInfosResult = Result.result {\n\n        // Get product ids purchased by customer id\n        let! productIds = api.Get<ProductId list> custId\n\n        let productInfos = ResizeArray()  // Same as .NET List<T>\n        for productId in productIds do\n            let! productInfo = api.Get<ProductInfo> productId\n            productInfos.Add productInfo \n        return productInfos |> List.ofSeq\n        }\n\n    // Close api connection\n    api.Close()\n\n    // Return the list of product infos\n    productInfosResult \n```", "```\nmodule Result = \n\n    let bind f xResult = ...\n\n    type ResultBuilder() =\n        member this.Return x = retn x\n        member this.ReturnFrom(m: Result<'T>) = m\n        member this.Bind(x,f) = bind f x\n\n        member this.Zero() = Failure []\n        member this.Combine (x,f) = bind f x\n        member this.Delay(f: unit -> _) = f\n        member this.Run(f) = f()\n\n        member this.TryFinally(m, compensation) =\n            try this.ReturnFrom(m)\n            finally compensation()\n\n        member this.Using(res:#System.IDisposable, body) =\n            this.TryFinally(body res, fun () -> \n            match res with \n            | null -> () \n            | disp -> disp.Dispose())\n\n        member this.While(guard, f) =\n            if not (guard()) then \n                this.Zero() \n            else\n                this.Bind(f(), fun _ -> this.While(guard, f))\n\n        member this.For(sequence:seq<_>, body) =\n            this.Using(sequence.GetEnumerator(), fun enum -> \n                this.While(enum.MoveNext, this.Delay(fun () -> \n                    body enum.Current)))\n\n    let result = new ResultBuilder() \n```", "```\nlet executeApiAction apiAction  =\n\n    // Open api connection \n    use api = new ApiClient()\n    api.Open()\n\n    // do something with it\n    let result = apiAction api\n\n    // Close api connection\n    api.Close()\n\n    // return result\n    result \n```", "```\n/// CustId -> ApiClient -> Result<ProductInfo list>\nlet getPurchaseInfo (custId:CustId) (api:ApiClient) =\n\n    let productInfosResult = Result.result {\n        let! productIds = api.Get<ProductId list> custId\n\n        let productInfos = ResizeArray()  // Same as .NET List<T>\n        for productId in productIds do\n            let! productInfo = api.Get<ProductInfo> productId\n            productInfos.Add productInfo \n        return productInfos |> List.ofSeq\n        }\n\n    // return result\n    productInfosResult \n```", "```\nlet action = getPurchaseInfo (CustId \"C1\")  // partially apply\nexecuteApiAction action \n```", "```\n/// CustId -> ApiClient -> Result<ProductId list>\nlet getPurchaseIds (custId:CustId) (api:ApiClient) =\n    api.Get<ProductId list> custId\n\n/// ProductId -> ApiClient -> Result<ProductInfo>\nlet getProductInfo (productId:ProductId) (api:ApiClient) =\n    api.Get<ProductInfo> productId\n\n/// CustId -> ApiClient -> Result<ProductInfo list>\nlet getPurchaseInfo (custId:CustId) (api:ApiClient) =\n\n    let result = Result.result {\n        let! productIds = getPurchaseIds custId api \n\n        let productInfos = ResizeArray()  \n        for productId in productIds do\n            let! productInfo = getProductInfo productId api\n            productInfos.Add productInfo \n        return productInfos |> List.ofSeq\n        }\n\n    // return result\n    result \n```", "```\nlet getPurchaseInfo (custId:CustId) =\n    custId \n    |> getPurchaseIds \n    |> List.map getProductInfo \n```", "```\ntype ApiAction<'a> = (ApiClient -> 'a) \n```", "```\ntype ApiAction<'a> = ApiAction of (ApiClient -> 'a) \n```", "```\n// CustId -> ApiAction<Result<ProductId list>>\nlet getPurchaseIds (custId:CustId) =\n\n    // create the api-consuming function\n    let action (api:ApiClient) = \n        api.Get<ProductId list> custId\n\n    // wrap it in the single case\n    ApiAction action \n```", "```\n// ProductId -> ApiAction<Result<ProductInfo>>\nlet getProductInfo (productId:ProductId) =\n\n    // create the api-consuming function\n    let action (api:ApiClient) = \n        api.Get<ProductInfo> productId\n\n    // wrap it in the single case\n    ApiAction action \n```", "```\nmodule ApiAction = \n\n    /// Evaluate the action with a given api\n    /// ApiClient -> ApiAction<'a> -> 'a\n    let run api (ApiAction action) = \n        let resultOfAction = action api\n        resultOfAction\n\n    /// ('a -> 'b) -> ApiAction<'a> -> ApiAction<'b>\n    let map f action = \n        let newAction api =\n            let x = run api action \n            f x\n        ApiAction newAction\n\n    /// 'a -> ApiAction<'a>\n    let retn x = \n        let newAction api =\n            x\n        ApiAction newAction\n\n    /// ApiAction<('a -> 'b)> -> ApiAction<'a> -> ApiAction<'b>\n    let apply fAction xAction = \n        let newAction api =\n            let f = run api fAction \n            let x = run api xAction \n            f x\n        ApiAction newAction\n\n    /// ('a -> ApiAction<'b>) -> ApiAction<'a> -> ApiAction<'b>\n    let bind f xAction = \n        let newAction api =\n            let x = run api xAction \n            run api (f x)\n        ApiAction newAction\n\n    /// Create an ApiClient and run the action on it\n    /// ApiAction<'a> -> 'a\n    let execute action =\n        use api = new ApiClient()\n        api.Open()\n        let result = run api action\n        api.Close()\n        result \n```", "```\nmodule ApiActionResult = \n\n    let map f  = \n        ApiAction.map (Result.map f)\n\n    let retn x = \n        ApiAction.retn (Result.retn x)\n\n    let apply fActionResult xActionResult = \n        let newAction api =\n            let fResult = ApiAction.run api fActionResult \n            let xResult = ApiAction.run api xActionResult \n            Result.apply fResult xResult \n        ApiAction newAction\n\n    let bind f xActionResult = \n        let newAction api =\n            let xResult = ApiAction.run api xActionResult \n            // create a new action based on what xResult is\n            let yAction = \n                match xResult with\n                | Success x -> \n                    // Success? Run the function\n                    f x\n                | Failure err -> \n                    // Failure? wrap the error in an ApiAction\n                    (Failure err) |> ApiAction.retn\n            ApiAction.run api yAction  \n        ApiAction newAction \n```", "```\nlet getPurchaseInfo =\n    let getProductInfo1 = traverse getProductInfo\n    let getProductInfo2 = ApiActionResult.bind getProductInfo1 \n    getPurchaseIds >> getProductInfo2 \n```", "```\nlet getPurchaseInfo =\n    let getProductInfoLifted =\n        getProductInfo\n        |> traverse \n        |> ApiActionResult.bind \n    getPurchaseIds >> getProductInfoLifted \n```", "```\nlet getPurchaseInfo (custId:CustId) (api:ApiClient) =\n\n    let result = Result.result {\n        let! productIds = getPurchaseIds custId api \n\n        let productInfos = ResizeArray()  \n        for productId in productIds do\n            let! productInfo = getProductInfo productId api\n            productInfos.Add productInfo \n        return productInfos |> List.ofSeq\n        }\n\n    // return result\n    result \n```", "```\nlet traverse f list =\n    // define the applicative functions\n    let (<*>) = ApiActionResult.apply\n    let retn = ApiActionResult.retn\n\n    // define a \"cons\" function\n    let cons head tail = head :: tail\n\n    // right fold over the list\n    let initState = retn []\n    let folder head tail = \n        retn cons <*> f head <*> tail\n\n    List.foldBack folder list initState \n```", "```\nlet showResult result =\n    match result with\n    | Success (productInfoList) -> \n        printfn \"SUCCESS: %A\" productInfoList\n    | Failure errs -> \n        printfn \"FAILURE: %A\" errs \n```", "```\nlet setupTestData (api:ApiClient) =\n    //setup purchases\n    api.Set (CustId \"C1\") [ProductId \"P1\"; ProductId \"P2\"] |> ignore\n    api.Set (CustId \"C2\") [ProductId \"PX\"; ProductId \"P2\"] |> ignore\n\n    //setup product info\n    api.Set (ProductId \"P1\") {ProductName=\"P1-Name\"} |> ignore\n    api.Set (ProductId \"P2\") {ProductName=\"P2-Name\"} |> ignore\n    // P3 missing\n\n// setupTestData is an api-consuming function\n// so it can be put in an ApiAction \n// and then that apiAction can be executed\nlet setupAction = ApiAction setupTestData\nApiAction.execute setupAction \n```", "```\nCustId \"C1\"\n|> getPurchaseInfo\n|> ApiAction.execute\n|> showResult \n```", "```\n[API] Opening\n[API] Get CustId \"C1\"\n[API] Get ProductId \"P1\"\n[API] Get ProductId \"P2\"\n[API] Closing\n[API] Disposing\nSUCCESS: [{ProductName = \"P1-Name\";}; {ProductName = \"P2-Name\";}] \n```", "```\nCustId \"CX\"\n|> getPurchaseInfo\n|> ApiAction.execute\n|> showResult \n```", "```\n[API] Opening\n[API] Get CustId \"CX\"\n[API] Closing\n[API] Disposing\nFAILURE: [\"Key CustId \"CX\" not found\"] \n```", "```\nCustId \"C2\"\n|> getPurchaseInfo\n|> ApiAction.execute\n|> showResult \n```", "```\n[API] Opening\n[API] Get CustId \"C2\"\n[API] Get ProductId \"PX\"\n[API] Get ProductId \"P2\"\n[API] Closing\n[API] Disposing\nFAILURE: [\"Key ProductId \"PX\" not found\"] \n```", "```\nmodule ApiActionResult = \n\n    let map = ...\n    let retn =  ...\n    let apply = ...\n    let bind = ...\n\n    let either onSuccess onFailure xActionResult = \n        let newAction api =\n            let xResult = ApiAction.run api xActionResult \n            let yAction = \n                match xResult with\n                | Result.Success x -> onSuccess x \n                | Result.Failure err -> onFailure err\n            ApiAction.run api yAction  \n        ApiAction newAction \n```", "```\nlet bind f = \n    either \n        // Success? Run the function\n        (fun x -> f x)\n        // Failure? wrap the error in an ApiAction\n        (fun err -> (Failure err) |> ApiAction.retn) \n```", "```\nlet traverseWithLog log f list =\n    // define the applicative functions\n    let (<*>) = ApiActionResult.apply\n    let retn = ApiActionResult.retn\n\n    // define a \"cons\" function\n    let cons head tail = head :: tail\n\n    // right fold over the list\n    let initState = retn []\n    let folder head tail = \n        (f head) \n        |> ApiActionResult.either \n            (fun h -> retn cons <*> retn h <*> tail)\n            (fun errs -> log errs; tail)\n    List.foldBack folder list initState \n```", "```\nlet folder head tail = \n    (f head) \n    |> ApiActionResult.either \n        (fun h -> retn cons <*> retn h <*> tail)\n        (fun errs -> log errs; tail) \n```", "```\nlet getPurchasesInfoWithLog =\n    let log errs = printfn \"SKIPPED %A\" errs \n    let getProductInfoLifted =\n        getProductInfo \n        |> traverseWithLog log \n        |> ApiActionResult.bind \n    getPurchaseIds >> getProductInfoLifted\n\nCustId \"C2\"\n|> getPurchasesInfoWithLog\n|> ApiAction.execute\n|> showResult \n```", "```\n[API] Opening\n[API] Get CustId \"C2\"\n[API] Get ProductId \"PX\"\nSKIPPED [\"Key ProductId \"PX\" not found\"]\n[API] Get ProductId \"P2\"\n[API] Closing\n[API] Disposing\nSUCCESS: [{ProductName = \"P2-Name\";}] \n```", "```\ntype ApiAction<'anything,'a> = ApiAction of ('anything -> 'a) \n```", "```\ntype Reader<'environment,'a> = Reader of ('environment -> 'a) \n```", "```\ntype ApiAction<'a> = Reader<ApiClient,'a> \n```", "```\nmodule Reader = \n\n    /// Evaluate the action with a given environment\n    /// 'env -> Reader<'env,'a> -> 'a\n    let run environment (Reader action) = \n        let resultOfAction = action environment\n        resultOfAction\n\n    /// ('a -> 'b) -> Reader<'env,'a> -> Reader<'env,'b>\n    let map f action = \n        let newAction environment =\n            let x = run environment action \n            f x\n        Reader newAction\n\n    /// 'a -> Reader<'env,'a>\n    let retn x = \n        let newAction environment =\n            x\n        Reader newAction\n\n    /// Reader<'env,('a -> 'b)> -> Reader<'env,'a> -> Reader<'env,'b>\n    let apply fAction xAction = \n        let newAction environment =\n            let f = run environment fAction \n            let x = run environment xAction \n            f x\n        Reader newAction\n\n    /// ('a -> Reader<'env,'b>) -> Reader<'env,'a> -> Reader<'env,'b>\n    let bind f xAction = \n        let newAction environment =\n            let x = run environment xAction \n            run environment (f x)\n        Reader newAction \n```"]