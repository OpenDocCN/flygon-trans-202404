["```\nfuns =\n  for map(i from range(0, 10)):\n    lam(): i end\n  end\n\ncheck:\n  map(lam(c): c() end, funs)\n    is range(0, 10)\nend\n```", "```\nfuns =\n  map(\n    lam(i):\n      lam():\n        i\n      end\n    end,\n    range(0, 10))\n```", "```\ndata ExprC:\n  | numC(n :: Number)\n  | plusC(l :: ExprC, r :: ExprC)\n  | multC(l :: ExprC, r :: ExprC)\n  | idC(s :: String)\n  | appC(f :: ExprC, a :: ExprC)\n  | fdC(arg :: String, body :: ExprC)\n  | boxC(v :: ExprC)\n  | unboxC(b :: ExprC)\n  | setboxC(b :: ExprC, v :: ExprC)\n  | seqC(b1 :: ExprC, b2 :: ExprC)\nend\n```", "```\ndata Binding:\n  | bind(name :: String, location :: Number)\nend\n\ntype Env = List<Binding>\nmt-env = empty\nxtnd-env = link\n\ndata Storage:\n  | cell(location :: Number, value :: Value)\nend\n\ntype Store = List<Storage>\nmt-sto = empty\nxtnd-sto = link\n```", "```\nfun lookup(s :: String, nv :: Env) -> Number: ...\nfun fetch(n :: Number, st :: Store) -> Value: ...\n```", "```\nfun ret(v :: Value, st :: Store): {v : v, st : st} end\n```", "```\nnew-loc = mk-counter()\n```", "```\ndata ExprC:\n  | numC(n :: Number)\n  | plusC(l :: ExprC, r :: ExprC)\n  | multC(l :: ExprC, r :: ExprC)\n  | varC(s :: String)\n  | appC(f :: ExprC, a :: ExprC)\n  | fdC(arg :: String, body :: ExprC)\n  | setC(v :: String, b :: ExprC)\n  | seqC(b1 :: ExprC, b2 :: ExprC)\nend\n```", "```\ndata Value:\n  | numV (n :: Number)\n  | closV (f :: ExprC, e :: List<Binding>)\nend\n```", "```\n> > fun f(x):\n> >   x := 3\n> > end\n> > \n> > var y = 5\n> > f(y)\n> > ```", "```\n    fun f(g):\n      var x = 10\n      g(x)\n      ...\n    end\n    ```", "```\nbox<T> :: T -> Box(T)\nunbox<T> :: Box(T) -> T\nset-box<T> :: Box(T), T -> Box(T)\n```", "```\nlet f = box(lam(x): x end):\n  set-box(f, lam(x): x + 5 end)\n  unbox(f)(true)\nend\n```"]