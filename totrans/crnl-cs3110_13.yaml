- en: 'Recitation 8: Functional stacks and queues, dictionaries, fractions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional data structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recitation, we look at examples of structures and signatures that implement
    data structures. We show that stacks and queues can be implemented efficiently
    in a functional style.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is a functional stack, or a functional queue? It is a data structure for
    which the operations do not *change* the data structure, but rather create a new
    data structure, with the appropriate modifications, instead of changing it in-place.
    In imperative languages, data operations generally support *destructive update*
    — “destructive” in the sense that after the update is done, the original data
    structure is gone. Functional abstractions support *nondestructive updates*: the
    original value is still around, unmodified, so code that was using it is unaffected.
    For efficiency, it is important to implement nondestructive updates not by creating
    an entirely new data structure, but by sharing as much as possible with the original
    data structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall a stack: a last-in first-out (LIFO) queue. Just like lists, the stack
    operations fundamentally do not care about the type of the values stored, so it
    is a naturally polymorphic data structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a possible signature for functional stacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This signature specifies a parameterized abstract type for stack. Notice the
    type variable `'a`. The signature also specifies the empty stack value, and functions
    to check if a stack is empty, and to perform push, pop and top operations on the
    stack. Moreover, we specify functions map and app to walk over the values of the
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: We also declare an exception `EmptyStack` to be raised by top and pop operations
    when the stack is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the simplest implementation of stacks that matches the above signature.
    It is implemented in terms of lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Up until now, we have been defining exceptions solely in order to raise them
    and interrupt the executing program. Just like in Java, it is also possible to
    catch exceptions, which is termed 'handling an exception' in OCaml.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following example. In the above code, we have implemented
    top and pop respectively as functions that return the first element of the list
    and the rest of the list. OCaml already defines functions to do just that, namely
    `List.hd` and `List.tl` (for head and tail). The function `hd` takes a list as
    argument and returns the first element of the list, or raises the exception `Failure`
    if the list is empty. Similarly for `tl`. One would like to simply be able to
    write in `Stack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if passed an empty stack, `top` and `pop` should raise the `EmptyStack`
    exception. As written above, the exception `Failure` would be raised. What we
    need to do is intercept (or handle) the exception, and raise the right one. Here''s
    one way to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax for handling exceptions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: where `e` is the expression to evaluate, and if `e` raises an exception that
    matches `exn`, then expression `e'` is evaluated instead. The type of `e` and
    `e'` must be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us write an example more interesting than stacks. After all, from the above,
    one can see that they are just lists. Consider the queue data structure, a first-in
    first-out data structure. Again, we consider functional queues. Here is a possible
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplest possible implementation for queues is to represent a queue via
    two stacks: one stack A on which to enqueue elements, and one stack B from which
    to dequeue elements. When dequeuing, if stack B is empty, then we reverse stack
    A and consider it the new stack B.'
  prefs: []
  type: TYPE_NORMAL
- en: Here is an implementation for such queues. It uses the stack structure `Stack`,
    which is rebound to the name `S` inside the structure to avoid long identifier
    names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We learned about folding last week. In the above implementation, the stack reversal
    could have been done using fold. However, since the Stack module does not specify
    a fold operation, and the implementation of the Stack as a list is hidden from
    the Queue module, we need something more. The Stack signature should specify a
    fold operation that will help its users to iterate over its elements.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A very useful abstraction is a *dictionary*: a mapping from strings to other
    values. A more general dictionary that maps from one arbitrary key type to another
    is usually called a *map* or an *associative array*, although sometimes “dictionary”
    is used for these as well. In any case, the implementation techniques are similar.
    Here''s an interface for dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here is an implementation using *association lists* `[(key1, x1); ...; (keyn,
    xn)]`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here's another implementation using higher-order functions as dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This next implementation seems a little better for looking up values. Also note
    that the abstraction function does not need to specify what duplicate keys mean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here is another implementation of dictionaries. This one uses a binary tree
    to keep the data. The hope is that inserts or lookups will be proportional to
    log n, where n is the number of items in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Fractions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another simple data type is a fraction, a ratio of two integers. Here is a
    possible interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here's one implementation of fractions -- what can go wrong here?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are some weaknesses with this implementation. It would probably be better
    to check the denominator. Second, we're not reducing to smallest form. So we could
    overflow faster than we need to. And maybe we don't want to allow negative denominators.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should pick a representation invariant that describes how we''re going to
    represent legal fractions. Here is one choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
