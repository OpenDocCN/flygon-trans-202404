- en: Chapter 6\. Operations on Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter describes the operations on objects, including lists, numbers,
    characters, strings, vectors, bytevectors, symbols, booleans, hashtables, and
    enumerations. The first section covers constant objects and quotation. The second
    section describes generic equivalence predicates for comparing two objects and
    predicates for determining the type of an object. Later sections describe procedures
    that deal primarily with one of the object types mentioned above. There is no
    section treating operations on procedures, since the only operation defined specifically
    for procedures is application, and this is described in Chapter [5](control.html#g96).
    Operations on ports are covered in the more general discussion of input and output
    in Chapter [7](io.html#g121). A mechanism for defining new data types is described
    in Chapter [9](records.html#g138).
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.1\. Constants and Quotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**syntax**: `*constant*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*constant*`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*constant*` is any self-evaluating constant, i.e., a number, boolean, character,
    string, or bytevector. Constants are immutable; see the note in the description
    of `quote` below.'
  prefs: []
  type: TYPE_NORMAL
- en: '`3.2 ![<graphic>](ch6_0.gif) 3.2'
  prefs: []
  type: TYPE_NORMAL
- en: '#f ![<graphic>](ch6_0.gif) #f'
  prefs: []
  type: TYPE_NORMAL
- en: '#\c ![<graphic>](ch6_0.gif) #\c'
  prefs: []
  type: TYPE_NORMAL
- en: '"hi" ![<graphic>](ch6_0.gif) "hi"'
  prefs: []
  type: TYPE_NORMAL
- en: '#vu8(3 4 5) ![<graphic>](ch6_0.gif) #vu8(3 4 5)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(quote *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `''*obj*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*obj*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`''*obj*` is equivalent to `(quote *obj*)`. The abbreviated form is converted
    into the longer form by the Scheme reader (see `read`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`quote` inhibits the normal evaluation rule for `*obj*`, allowing `*obj*` to
    be employed as data. Although any Scheme object may be quoted, quotation is not
    necessary for self-evaluating constants, i.e., numbers, booleans, characters,
    strings, and bytevectors.'
  prefs: []
  type: TYPE_NORMAL
- en: Quoted and self-evaluating constants are immutable. That is, programs should
    not alter a constant via `set-car!`, `string-set!`, etc., and implementations
    are permitted to raise an exception with condition type `&assertion` if such an
    alteration is attempted. If an attempt to alter an immutable object is undetected,
    the behavior of the program is unspecified. An implementation may choose to share
    storage among different constants to save space.
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 2 3) ![<graphic>](ch6_0.gif) 5'
  prefs: []
  type: TYPE_NORMAL
- en: '''(+ 2 3) ![<graphic>](ch6_0.gif) (+ 2 3)'
  prefs: []
  type: TYPE_NORMAL
- en: (quote (+ 2 3)) ![<graphic>](ch6_0.gif) (+ 2 3)
  prefs: []
  type: TYPE_NORMAL
- en: '''a ![<graphic>](ch6_0.gif) a'
  prefs: []
  type: TYPE_NORMAL
- en: '''cons ![<graphic>](ch6_0.gif) cons'
  prefs: []
  type: TYPE_NORMAL
- en: '''() ![<graphic>](ch6_0.gif) ()'
  prefs: []
  type: TYPE_NORMAL
- en: '''7 ![<graphic>](ch6_0.gif) 7`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(quasiquote *obj* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: ``*obj*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(unquote *obj* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `,*obj*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(unquote-splicing *obj* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `,@*obj*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '``*obj*` is equivalent to `(quasiquote *obj*)`, `,*obj*` is equivalent to `(unquote *obj*)`,
    and `,@*obj*` is equivalent to `(unquote-splicing *obj*)`. The abbreviated forms
    are converted into the longer forms by the Scheme reader (see `read`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`quasiquote` is similar to `quote`, but it allows parts of the quoted text
    to be "unquoted." Within a `quasiquote` expression, `unquote` and `unquote-splicing`
    subforms are evaluated, and everything else is quoted, i.e., left unevaluated.
    The value of each `unquote` subform is inserted into the output in place of the
    `unquote` form, while the value of each `unquote-splicing` subform is spliced
    into the surrounding list or vector structure. `unquote` and `unquote-splicing`
    are valid only within `quasiquote` expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: '`quasiquote` expressions may be nested, with each `quasiquote` introducing
    a new level of quotation and each `unquote` or `unquote-splicing` taking away
    a level of quotation. An expression nested within *n* `quasiquote` expressions
    must be within *n* `unquote` or `unquote-splicing` expressions to be evaluated.'
  prefs: []
  type: TYPE_NORMAL
- en: '``(+ 2 3) ![<graphic>](ch6_0.gif) (+ 2 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 2 ,(* 3 4)) ![<graphic>](ch6_0.gif) (+ 2 12)'
  prefs: []
  type: TYPE_NORMAL
- en: '`(a b (,(+ 2 3) c) d) ![<graphic>](ch6_0.gif) (a b (5 c) d)'
  prefs: []
  type: TYPE_NORMAL
- en: '`(a b ,(reverse ''(c d e)) f g) ![<graphic>](ch6_0.gif) (a b (e d c) f g)'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([a 1] [b 2])
  prefs: []
  type: TYPE_NORMAL
- en: '`(,a . ,b)) ![<graphic>](ch6_0.gif) (1 . 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ ,@(cdr ''(* 2 3))) ![<graphic>](ch6_0.gif) (+ 2 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`(a b ,@(reverse ''(c d e)) f g) ![<graphic>](ch6_0.gif) (a b e d c f g)'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([a 1] [b 2])
  prefs: []
  type: TYPE_NORMAL
- en: '`(,a ,@b)) ![<graphic>](ch6_0.gif) (1 . 2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`#(,@(list 1 2 3)) ![<graphic>](ch6_0.gif) #(1 2 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '''`,(cons ''a ''b) ![<graphic>](ch6_0.gif) `,(cons ''a ''b)'
  prefs: []
  type: TYPE_NORMAL
- en: '`'',(cons ''a ''b) ![<graphic>](ch6_0.gif) ''(a . b)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`unquote` and `unquote-splicing` forms with zero or more than one subform are
    valid only in splicing (list or vector) contexts. `(unquote *obj* ...)` is equivalent
    to `(unquote *obj*) ...`, and `(unquote-splicing *obj* ...)` is equivalent to
    `(unquote-splicing *obj*) ...`. These forms are primarily useful as intermediate
    forms in the output of the `quasiquote` expander. They support certain useful
    nested quasiquotation idioms [[3](bibliography.html#g221)], such as `,@,@`, which
    has the effect of a doubly indirect splicing when used within a doubly nested
    and doubly evaluated `quasiquote` expression.'
  prefs: []
  type: TYPE_NORMAL
- en: '``(a (unquote) b) ![<graphic>](ch6_0.gif) (a b)'
  prefs: []
  type: TYPE_NORMAL
- en: '`(a (unquote (+ 3 3)) b) ![<graphic>](ch6_0.gif) (a 6 b)'
  prefs: []
  type: TYPE_NORMAL
- en: '`(a (unquote (+ 3 3) (* 3 3)) b) ![<graphic>](ch6_0.gif) (a 6 9 b)'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x '(m n)]) ``(a ,@,@x f)) ![<graphic>](ch6_0.gif) `(a (unquote-splicing m n) f)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x '(m n)])
  prefs: []
  type: TYPE_NORMAL
- en: (eval `(let ([m '(b c)] [n '(d e)]) `(a ,@,@x f))
  prefs: []
  type: TYPE_NORMAL
- en: (environment '(rnrs)))) ![<graphic>](ch6_0.gif) (a b c d e f)`
  prefs: []
  type: TYPE_NORMAL
- en: '`unquote` and `unquote-splicing` are auxiliary keywords for `quasiquote`. It
    is a syntax violation to reference these identifiers except in contexts where
    they are recognized as auxiliary keywords.'
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.2\. Generic Equivalence and Type Predicates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section describes the basic Scheme predicates (procedures returning one
    of the boolean values `#t` or `#f`) for determining the type of an object or the
    equivalence of two objects. The equivalence predicates `eq?`, `eqv?`, and `equal?`
    are discussed first, followed by the type predicates.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(eq? *obj[1]* *obj[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj[1]*` and `*obj[2]*` are identical, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: In most Scheme systems, two objects are considered identical if they are represented
    internally by the same pointer value and distinct (not identical) if they are
    represented internally by different pointer values, although other criteria, such
    as time-stamping, are possible.
  prefs: []
  type: TYPE_NORMAL
- en: Although the particular rules for object identity vary somewhat from system
    to system, the following rules always hold.
  prefs: []
  type: TYPE_NORMAL
- en: Two objects of different types (booleans, the empty list, pairs, numbers, characters,
    strings, vectors, symbols, and procedures) are distinct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two objects of the same type with different contents or values are distinct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The boolean object `#t` is identical to itself wherever it appears, and `#f`
    is identical to itself wherever it appears, but `#t` and `#f` are distinct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The empty list `()` is identical to itself wherever it appears.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two symbols are identical if and only if they have the same name (by `string=?`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constant pair, vector, string, or bytevector is identical to itself, as is
    a pair, vector, string, or bytevector created by an application of `cons`, `vector`,
    `string`, `make-bytevector`, etc. Two pairs, vectors, strings, or bytevectors
    created by different applications of `cons`, `vector`, `string`, `make-bytevector`,
    etc., are distinct. One consequence is that `cons`, for example, may be used to
    create a unique object distinct from all other objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two procedures that may behave differently are distinct. A procedure created
    by an evaluation of a `lambda` expression is identical to itself. Two procedures
    created by the same `lambda` expression at different times, or by similar `lambda`
    expressions, may or may not be distinct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eq?` cannot be used to compare numbers and characters reliably. Although every
    inexact number is distinct from every exact number, two exact numbers, two inexact
    numbers, or two characters with the same value may or may not be identical.'
  prefs: []
  type: TYPE_NORMAL
- en: Since constant objects are immutable, i.e., programs should not modify them
    via `vector-set!`, `set-car!`, or any other structure mutation operation, all
    or portions of different quoted constants or self-evaluating literals may be represented
    internally by the same object. Thus, `eq?` may return `#t` when applied to equal
    parts of different immutable constants.
  prefs: []
  type: TYPE_NORMAL
- en: '`eq?` is most often used to compare symbols or to check for pointer equivalence
    of allocated objects, e.g., pairs, vectors, or record instances.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(eq? ''a 3) ![<graphic>](ch6_0.gif) #f'
  prefs: []
  type: TYPE_NORMAL
- en: (eq? #t 't) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? "abc" 'abc) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? "hi" '(hi)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? #f '()) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 9/2 7/2) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 3.4 53344) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 3 3.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 1/3 #i1/3) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 9/2 9/2) ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 3.4 (+ 3.0 .4)) ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (* 12345678987654321 2)])
  prefs: []
  type: TYPE_NORMAL
- en: (eq? x x)) ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (eq? #\a #\b) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? #\a #\a) ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (string-ref "hi" 0)])
  prefs: []
  type: TYPE_NORMAL
- en: (eq? x x)) ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (eq? #t #t) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eq? #f #f) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eq? #t #f) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (null? '()) #t) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (null? '(a)) #f) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (cdr '(a)) '()) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 'a 'a) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 'a 'b) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 'a (string->symbol "a")) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eq? '(a) '(b)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? '(a) '(a)) ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x '(a . b)]) (eq? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (cons 'a 'b)])
  prefs: []
  type: TYPE_NORMAL
- en: (eq? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (cons 'a 'b) (cons 'a 'b)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? "abc" "cba") ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? "abc" "abc") ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x "hi"]) (eq? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (string #\h #\i)]) (eq? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (string #\h #\i)
  prefs: []
  type: TYPE_NORMAL
- en: (string #\h #\i)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? '#vu8(1) '#vu8(1)) ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (eq? '#vu8(1) '#vu8(2)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (make-bytevector 10 0)])
  prefs: []
  type: TYPE_NORMAL
- en: (eq? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (make-bytevector 10 0)])
  prefs: []
  type: TYPE_NORMAL
- en: (eq? x (make-bytevector 10 0))) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? '#(a) '#(b)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? '#(a) '#(a)) ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x '#(a)]) (eq? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (vector 'a)])
  prefs: []
  type: TYPE_NORMAL
- en: (eq? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (vector 'a) (vector 'a)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? car car) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eq? car cdr) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda (x) x)])
  prefs: []
  type: TYPE_NORMAL
- en: (eq? f f)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda () (lambda (x) x))])
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (f) (f))) ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (lambda (x) x) (lambda (y) y)) ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (set! x (+ x 1))
  prefs: []
  type: TYPE_NORMAL
- en: x))])
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (f 0) (f 0))) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(eqv? *obj[1]* *obj[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj[1]*` and `*obj[2]*` are equivalent, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`eqv?` is similar to `eq?` except `eqv?` is guaranteed to return `#t` for two
    characters that are considered equal by `char=?` and two numbers that are (a)
    considered equal by `=` and (b) cannot be distinguished by any other operation
    besides `eq?` and `eqv?`. A consequence of (b) is that `(eqv? -0.0 +0.0)` is `#f`
    even though `(= -0.0 +0.0)` is `#t` in systems that distinguish `-0.0` and `+0.0`,
    such as those based on IEEE floating-point arithmetic. This is because operations
    such as `/` can expose the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(/ 1.0 -0.0) ![<graphic>](ch6_0.gif) -inf.0'
  prefs: []
  type: TYPE_NORMAL
- en: (/ 1.0 +0.0) ![<graphic>](ch6_0.gif) +inf.0`
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, although 3.0 and 3.0+0.0i are considered numerically equal, they
    are not considered equivalent by `eqv?` if -0.0 and 0.0 have different representations.
  prefs: []
  type: TYPE_NORMAL
- en: '`(= 3.0+0.0i 3.0) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? 3.0+0.0i 3.0) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: The boolean value returned by `eqv?` is not specified when the arguments are
    NaNs.
  prefs: []
  type: TYPE_NORMAL
- en: '`(eqv? +nan.0 (/ 0.0 0.0)) ![<graphic>](ch6_0.gif) *unspecified*`'
  prefs: []
  type: TYPE_NORMAL
- en: '`eqv?` is less implementation-dependent but generally more expensive than `eq?`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(eqv? ''a 3) ![<graphic>](ch6_0.gif) #f'
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? #t 't) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? "abc" 'abc) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? "hi" '(hi)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? #f '()) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? 9/2 7/2) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? 3.4 53344) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? 3 3.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? 1/3 #i1/3) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? 9/2 9/2) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? 3.4 (+ 3.0 .4)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (* 12345678987654321 2)])
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? #\a #\b) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? #\a #\a) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (string-ref "hi" 0)])
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? #t #t) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? #f #f) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? #t #f) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? (null? '()) #t) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? (null? '(a)) #f) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? (cdr '(a)) '()) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? 'a 'a) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? 'a 'b) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? 'a (string->symbol "a")) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? '(a) '(b)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? '(a) '(a)) ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x '(a . b)]) (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (cons 'a 'b)])
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? (cons 'a 'b) (cons 'a 'b)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? "abc" "cba") ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? "abc" "abc") ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x "hi"]) (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (string #\h #\i)]) (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? (string #\h #\i)
  prefs: []
  type: TYPE_NORMAL
- en: (string #\h #\i)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? '#vu8(1) '#vu8(1)) ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? '#vu8(1) '#vu8(2)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (make-bytevector 10 0)])
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (make-bytevector 10 0)])
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? x (make-bytevector 10 0))) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? '#(a) '#(b)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? '#(a) '#(a)) ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x '#(a)]) (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (vector 'a)])
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? (vector 'a) (vector 'a)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? car car) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? car cdr) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda (x) x)])
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? f f)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda () (lambda (x) x))])
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? (f) (f))) ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? (lambda (x) x) (lambda (y) y)) ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (set! x (+ x 1))
  prefs: []
  type: TYPE_NORMAL
- en: x))])
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? (f 0) (f 0))) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(equal? *obj[1]* *obj[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj[1]*` and `*obj[2]*` have the same structure and
    contents, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: Two objects are equal if they are equivalent according to `eqv?`, strings that
    are `string=?`, bytevectors that are `bytevector=?`, pairs whose cars and cdrs
    are equal, or vectors of the same length whose corresponding elements are equal.
  prefs: []
  type: TYPE_NORMAL
- en: '`equal?` is required to terminate even for cyclic arguments and return `#t`
    "if and only if the (possibly infinite) unfoldings of its arguments into regular
    trees are equal as ordered trees" [[24](bibliography.html#g242)]. In essence,
    two values are equivalent, in the sense of `equal?`, if the structure of the two
    objects cannot be distinguished by any composition of pair and vector accessors
    along with the `eqv?`, `string=?`, and `bytevector=?` procedures for comparing
    data at the leaves.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing `equal?` efficiently is tricky [[1](bibliography.html#g219)], and
    even with a good implementation, it is likely to be more expensive than either
    `eqv?` or `eq?`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(equal? ''a 3) ![<graphic>](ch6_0.gif) #f'
  prefs: []
  type: TYPE_NORMAL
- en: (equal? #t 't) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (equal? "abc" 'abc) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (equal? "hi" '(hi)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (equal? #f '()) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (equal? 9/2 7/2) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (equal? 3.4 53344) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (equal? 3 3.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (equal? 1/3 #i1/3) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (equal? 9/2 9/2) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? 3.4 (+ 3.0 .4)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (* 12345678987654321 2)])
  prefs: []
  type: TYPE_NORMAL
- en: (equal? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? #\a #\b) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (equal? #\a #\a) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (string-ref "hi" 0)])
  prefs: []
  type: TYPE_NORMAL
- en: (equal? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? #t #t) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? #f #f) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? #t #f) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (equal? (null? '()) #t) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? (null? '(a)) #f) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? (cdr '(a)) '()) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? 'a 'a) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? 'a 'b) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (equal? 'a (string->symbol "a")) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? '(a) '(b)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (equal? '(a) '(a)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x '(a . b)]) (equal? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (cons 'a 'b)])
  prefs: []
  type: TYPE_NORMAL
- en: (equal? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? (cons 'a 'b) (cons 'a 'b)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? "abc" "cba") ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (equal? "abc" "abc") ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x "hi"]) (equal? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (string #\h #\i)]) (equal? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? (string #\h #\i)
  prefs: []
  type: TYPE_NORMAL
- en: (string #\h #\i)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? '#vu8(1) '#vu8(1)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? '#vu8(1) '#vu8(2)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (make-bytevector 10 0)])
  prefs: []
  type: TYPE_NORMAL
- en: (equal? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (make-bytevector 10 0)])
  prefs: []
  type: TYPE_NORMAL
- en: (equal? x (make-bytevector 10 0))) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? '#(a) '#(b)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (equal? '#(a) '#(a)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x '#(a)]) (equal? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (vector 'a)])
  prefs: []
  type: TYPE_NORMAL
- en: (equal? x x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? (vector 'a) (vector 'a)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? car car) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (equal? car cdr) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda (x) x)])
  prefs: []
  type: TYPE_NORMAL
- en: (equal? f f)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda () (lambda (x) x))])
  prefs: []
  type: TYPE_NORMAL
- en: (equal? (f) (f))) ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (equal? (lambda (x) x) (lambda (y) y)) ![<graphic>](ch6_0.gif) *unspecified*
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (set! x (+ x 1))
  prefs: []
  type: TYPE_NORMAL
- en: x))])
  prefs: []
  type: TYPE_NORMAL
- en: (equal? (f 0) (f 0))) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (equal?
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (cons 'x 'x)])
  prefs: []
  type: TYPE_NORMAL
- en: (set-car! x x)
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! x x)
  prefs: []
  type: TYPE_NORMAL
- en: x)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (cons 'x 'x)])
  prefs: []
  type: TYPE_NORMAL
- en: (set-car! x x)
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! x x)
  prefs: []
  type: TYPE_NORMAL
- en: (cons x x))) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(boolean? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is either `#t` or `#f`, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean?` is equivalent to `(lambda (x) (or (eq? x #t) (eq? x #f)))`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(boolean? #t) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (boolean? #f) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (or (boolean? 't) (boolean? '())) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(null? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is the empty list, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`null?` is equivalent to `(lambda (x) (eq? x ''()))`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(null? ''()) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (null? '(a)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (null? (cdr '(a))) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (null? 3) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (null? #f) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(pair? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a pair, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(pair? ''(a b c)) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (pair? '(3 . 4)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (pair? '()) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (pair? '#(a b)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (pair? 3) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(number? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a number object, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(complex? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a complex number object, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(real? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a real number object, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(rational? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a rational number object, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(integer? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is an integer object, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'These predicates form a hierarchy: any integer is rational, any rational is
    real, any real is complex, and any complex is numeric. Most implementations do
    not provide internal representations for irrational numbers, so all real numbers
    are typically rational as well.'
  prefs: []
  type: TYPE_NORMAL
- en: The `real?`, `rational?`, and `integer?` predicates do not recognize as real,
    rational, or integer complex numbers with inexact zero imaginary parts.
  prefs: []
  type: TYPE_NORMAL
- en: '`(integer? 1901) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (rational? 1901) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (real? 1901) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (complex? 1901) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (number? 1901) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (integer? -3.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (rational? -3.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (real? -3.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (complex? -3.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (number? -3.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (integer? 7+0i) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (rational? 7+0i) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (real? 7+0i) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (complex? 7+0i) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (number? 7+0i) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (integer? -2/3) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (rational? -2/3) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (real? -2/3) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (complex? -2/3) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (number? -2/3) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (integer? -2.345) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (rational? -2.345) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (real? -2.345) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (complex? -2.345) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (number? -2.345) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (integer? 7.0+0.0i) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (rational? 7.0+0.0i) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (real? 7.0+0.0i) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (complex? 7.0+0.0i) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (number? 7.0+0.0i) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (integer? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (rational? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (real? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (complex? 3.2-2.01i) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (number? 3.2-2.01i) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (integer? 'a) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (rational? '(a b c)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (real? "3") ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (complex? '#(1 2)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (number? #\a) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(real-valued? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a real number, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(rational-valued? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a rational number, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(integer-valued? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is an integer, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: These predicates are similar to `real?`, `rational?`, and `integer?`, but treat
    as real, rational, or integral complex numbers with inexact zero imaginary parts.
  prefs: []
  type: TYPE_NORMAL
- en: '`(integer-valued? 1901) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (rational-valued? 1901) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (real-valued? 1901) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (integer-valued? -3.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (rational-valued? -3.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (real-valued? -3.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (integer-valued? 7+0i) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (rational-valued? 7+0i) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (real-valued? 7+0i) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (integer-valued? -2/3) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (rational-valued? -2/3) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (real-valued? -2/3) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (integer-valued? -2.345) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (rational-valued? -2.345) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (real-valued? -2.345) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (integer-valued? 7.0+0.0i) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (rational-valued? 7.0+0.0i) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (real-valued? 7.0+0.0i) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (integer-valued? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (rational-valued? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (real-valued? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: As with `real?`, `rational?`, and `integer?`, these predicates return `#f` for
    all non-numeric values.
  prefs: []
  type: TYPE_NORMAL
- en: '`(integer-valued? ''a) ![<graphic>](ch6_0.gif) #f'
  prefs: []
  type: TYPE_NORMAL
- en: (rational-valued? '(a b c)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (real-valued? "3") ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a character, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(char? ''a) ![<graphic>](ch6_0.gif) #f'
  prefs: []
  type: TYPE_NORMAL
- en: (char? 97) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (char? #\a) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (char? "a") ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (char? (string-ref (make-string 1) 0)) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a string, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(string? "hi") ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (string? 'hi) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (string? #\h) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a vector, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(vector? ''#()) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (vector? '#(a b c)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (vector? (vector 'a 'b 'c)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (vector? '()) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (vector? '(a b c)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (vector? "abc") ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(symbol? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a symbol, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(symbol? ''t) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (symbol? "t") ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (symbol? '(t)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (symbol? #\t) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (symbol? 3) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (symbol? #t) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(procedure? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a procedure, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(procedure? car) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (procedure? 'car) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (procedure? (lambda (x) x)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (procedure? '(lambda (x) x)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc procedure?) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a bytevector, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector? #vu8()) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector? '#()) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector? "abc") ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a hashtable, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(hashtable? (make-eq-hashtable)) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable? '(not a hash table)) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.3\. Lists and Pairs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pair, or *cons cell*, is the most fundamental of Scheme's structured object
    types. The most common use for pairs is to build lists, which are ordered sequences
    of pairs linked one to the next by the *cdr* field. The elements of the list occupy
    the *car* fields of the pairs. The cdr of the last pair in a *proper list* is
    the empty list, `()`; the cdr of the last pair in an *improper list* can be anything
    other than `()`.
  prefs: []
  type: TYPE_NORMAL
- en: Pairs may be used to construct binary trees. Each pair in the tree structure
    is an internal node of the binary tree; its car and cdr are the children of the
    node.
  prefs: []
  type: TYPE_NORMAL
- en: Proper lists are printed as sequences of objects separated by whitespace and
    enclosed in parentheses. Matching pairs of brackets ( `[` `]` ) may be used in
    place of parentheses. For example, `(1 2 3)` and `(a [nested list])` are proper
    lists. The empty list is written as `()`.
  prefs: []
  type: TYPE_NORMAL
- en: Improper lists and trees require a slightly more complex syntax. A single pair
    is written as two objects separated by whitespace and a dot, e.g., `(a . b)`.
    This is referred to as *dotted-pair notation*. Improper lists and trees are also
    written in dotted-pair notation; the dot appears wherever necessary, e.g., `(1 2 3 . 4)`
    or `((1 . 2) . 3)`. Proper lists may be written in dotted-pair notation as well.
    For example, `(1 2 3)` may be written as `(1 . (2 . (3 . ())))`.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to create a circular list or a cyclic graph by destructively
    altering the car or cdr field of a pair, using `set-car!` or `set-cdr!`. Such
    lists are not considered proper lists.
  prefs: []
  type: TYPE_NORMAL
- en: Procedures that accept a `*list*` argument are required to detect that the list
    is improper only to the extent that they actually traverse the list far enough
    either (a) to attempt to operate on a non-list tail or (b) to loop indefinitely
    due to a circularity. For example, `member` need not detect that a list is improper
    if it actually finds the element being sought, and `list-ref` need never detect
    circularities, because its recursion is bounded by the index argument.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(cons *obj[1]* *obj[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new pair whose car and cdr are `*obj[1]*` and `*obj[2]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`cons` is the pair constructor procedure. `*obj[1]*` becomes the car and `*obj[2]*`
    becomes the cdr of the new pair.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(cons ''a ''()) ![<graphic>](ch6_0.gif) (a)'
  prefs: []
  type: TYPE_NORMAL
- en: (cons 'a '(b c)) ![<graphic>](ch6_0.gif) (a b c)
  prefs: []
  type: TYPE_NORMAL
- en: (cons 3 4) ![<graphic>](ch6_0.gif) (3 . 4)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(car *pair*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the car of `*pair*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The empty list is not a pair, so the argument must not be the empty list.
  prefs: []
  type: TYPE_NORMAL
- en: '`(car ''(a)) ![<graphic>](ch6_0.gif) a'
  prefs: []
  type: TYPE_NORMAL
- en: (car '(a b c)) ![<graphic>](ch6_0.gif) a
  prefs: []
  type: TYPE_NORMAL
- en: (car (cons 3 4)) ![<graphic>](ch6_0.gif) 3`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(cdr *pair*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the cdr of `*pair*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The empty list is not a pair, so the argument must not be the empty list.
  prefs: []
  type: TYPE_NORMAL
- en: '`(cdr ''(a)) ![<graphic>](ch6_0.gif) ()'
  prefs: []
  type: TYPE_NORMAL
- en: (cdr '(a b c)) ![<graphic>](ch6_0.gif) (b c)
  prefs: []
  type: TYPE_NORMAL
- en: (cdr (cons 3 4)) ![<graphic>](ch6_0.gif) 4`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(set-car! *pair* *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs mutable-pairs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`set-car!` changes the car of `*pair*` to `*obj*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x (list ''a ''b ''c)])'
  prefs: []
  type: TYPE_NORMAL
- en: (set-car! x 1)
  prefs: []
  type: TYPE_NORMAL
- en: x) ![<graphic>](ch6_0.gif) (1 b c)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(set-cdr! *pair* *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs mutable-pairs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`set-cdr!` changes the cdr of `*pair*` to `*obj*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x (list ''a ''b ''c)])'
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! x 1)
  prefs: []
  type: TYPE_NORMAL
- en: x) ![<graphic>](ch6_0.gif) (a . 1)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(caar *pair*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(cadr *pair*)` ![<graphic>](ch6_3.gif)'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(cddddr *pair*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the caar, cadr, ..., or cddddr of `*pair*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: These procedures are defined as the composition of up to four `car`s and `cdr`s.
    The `a`'s and `d`'s between the `c` and `r` represent the application of `car`
    or `cdr` in order from right to left. For example, the procedure `cadr` applied
    to a pair yields the `car` of the `cdr` of the pair and is equivalent to `(lambda (x) (car (cdr x)))`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(caar ''((a))) ![<graphic>](ch6_0.gif) a'
  prefs: []
  type: TYPE_NORMAL
- en: (cadr '(a b c)) ![<graphic>](ch6_0.gif) b
  prefs: []
  type: TYPE_NORMAL
- en: (cdddr '(a b c d)) ![<graphic>](ch6_0.gif) (d)
  prefs: []
  type: TYPE_NORMAL
- en: (cadadr '(a (b c))) ![<graphic>](ch6_0.gif) c`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(list *obj* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a list of `*obj* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`list` is equivalent to `(lambda x x)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(list) ![<graphic>](ch6_0.gif) ()'
  prefs: []
  type: TYPE_NORMAL
- en: (list 1 2 3) ![<graphic>](ch6_0.gif) (1 2 3)
  prefs: []
  type: TYPE_NORMAL
- en: (list 3 2 1) ![<graphic>](ch6_0.gif) (3 2 1)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(cons* *obj* ... *final-obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a list of `*obj* ...` terminated by `*final-obj*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If the objects `*obj* ...` are omitted, the result is simply `*final-obj*`.
    Otherwise, a list of `*obj* ...` is constructed, as with `list`, except that the
    final cdr field is `*final-obj*` instead of `()`. If `*final-obj*` is not a list,
    the result is an improper list.
  prefs: []
  type: TYPE_NORMAL
- en: '`(cons* ''()) ![<graphic>](ch6_0.gif) ()'
  prefs: []
  type: TYPE_NORMAL
- en: (cons* '(a b)) ![<graphic>](ch6_0.gif) (a b)
  prefs: []
  type: TYPE_NORMAL
- en: (cons* 'a 'b 'c) ![<graphic>](ch6_0.gif) (a b . c)
  prefs: []
  type: TYPE_NORMAL
- en: (cons* 'a 'b '(c d)) ![<graphic>](ch6_0.gif) (a b c d)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(list? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a proper list, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`list?` must return `#f` for all improper lists, including cyclic lists. A
    definition of `list?` is shown on page [67](further.html#defn:list?).'
  prefs: []
  type: TYPE_NORMAL
- en: '`(list? ''()) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (list? '(a b c)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (list? 'a) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (list? '(3 . 4)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (list? 3) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (list 'a 'b 'c)])
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! (cddr x) x)
  prefs: []
  type: TYPE_NORMAL
- en: (list? x)) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(length *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the number of elements in `*list*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` may be defined as follows, using an adaptation of the hare and tortoise
    algorithm used for the definition of `list?` on page [67](further.html#defn:list?).'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define length'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (define improper-list
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (assertion-violation 'length "not a proper list" x)))
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([h x] [t x] [n 0])
  prefs: []
  type: TYPE_NORMAL
- en: (if (pair? h)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([h (cdr h)])
  prefs: []
  type: TYPE_NORMAL
- en: (if (pair? h)
  prefs: []
  type: TYPE_NORMAL
- en: (if (eq? h t)
  prefs: []
  type: TYPE_NORMAL
- en: (improper-list)
  prefs: []
  type: TYPE_NORMAL
- en: (f (cdr h) (cdr t) (+ n 2)))
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? h)
  prefs: []
  type: TYPE_NORMAL
- en: (+ n 1)
  prefs: []
  type: TYPE_NORMAL
- en: (improper-list))))
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? h)
  prefs: []
  type: TYPE_NORMAL
- en: n
  prefs: []
  type: TYPE_NORMAL
- en: (improper-list))))))
  prefs: []
  type: TYPE_NORMAL
- en: (length '()) ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (length '(a b c)) ![<graphic>](ch6_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (length '(a b . c)) ![<graphic>](ch6_0.gif) *exception*
  prefs: []
  type: TYPE_NORMAL
- en: (length
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls (list 'a 'b)])
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! (cdr ls) ls) ![<graphic>](ch6_0.gif) *exception*
  prefs: []
  type: TYPE_NORMAL
- en: ls))
  prefs: []
  type: TYPE_NORMAL
- en: (length
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls (list 'a 'b)])
  prefs: []
  type: TYPE_NORMAL
- en: (set-car! (cdr ls) ls) ![<graphic>](ch6_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: ls))`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(list-ref *list* *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the `*n*`th element (zero-based) of `*list*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than the length of `*list*`.
    `list-ref` may be defined without error checks as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define list-ref'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls n)
  prefs: []
  type: TYPE_NORMAL
- en: (if (= n 0)
  prefs: []
  type: TYPE_NORMAL
- en: (car ls)
  prefs: []
  type: TYPE_NORMAL
- en: (list-ref (cdr ls) (- n 1)))))
  prefs: []
  type: TYPE_NORMAL
- en: (list-ref '(a b c) 0) ![<graphic>](ch6_0.gif) a
  prefs: []
  type: TYPE_NORMAL
- en: (list-ref '(a b c) 1) ![<graphic>](ch6_0.gif) b
  prefs: []
  type: TYPE_NORMAL
- en: (list-ref '(a b c) 2) ![<graphic>](ch6_0.gif) c`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(list-tail *list* *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the `*n*`th tail (zero-based) of `*list*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than or equal to the length
    of `*list*`. The result is not a copy; the tail is `eq?` to the `*n*`th cdr of
    `*list*` (or to `*list*` itself, if `*n*` is zero).'
  prefs: []
  type: TYPE_NORMAL
- en: '`list-tail` may be defined without error checks as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define list-tail'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls n)
  prefs: []
  type: TYPE_NORMAL
- en: (if (= n 0)
  prefs: []
  type: TYPE_NORMAL
- en: ls
  prefs: []
  type: TYPE_NORMAL
- en: (list-tail (cdr ls) (- n 1)))))
  prefs: []
  type: TYPE_NORMAL
- en: (list-tail '(a b c) 0) ![<graphic>](ch6_0.gif) (a b c)
  prefs: []
  type: TYPE_NORMAL
- en: (list-tail '(a b c) 2) ![<graphic>](ch6_0.gif) (c)
  prefs: []
  type: TYPE_NORMAL
- en: (list-tail '(a b c) 3) ![<graphic>](ch6_0.gif) ()
  prefs: []
  type: TYPE_NORMAL
- en: (list-tail '(a b c . d) 2) ![<graphic>](ch6_0.gif) (c . d)
  prefs: []
  type: TYPE_NORMAL
- en: (list-tail '(a b c . d) 3) ![<graphic>](ch6_0.gif) d
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (list 1 2 3)])
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (list-tail x 2)
  prefs: []
  type: TYPE_NORMAL
- en: (cddr x))) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(append)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(append *list* ... *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the concatenation of the input lists'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`append` returns a new list consisting of the elements of the first list followed
    by the elements of the second list, the elements of the third list, and so on.
    The new list is made from new pairs for all arguments but the last; the last (which
    need not be a list) is merely placed at the end of the new structure. `append`
    may be defined without error checks as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define append'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda args
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([ls '()] [args args])
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? args)
  prefs: []
  type: TYPE_NORMAL
- en: ls
  prefs: []
  type: TYPE_NORMAL
- en: (let g ([ls ls])
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: (f (car args) (cdr args))
  prefs: []
  type: TYPE_NORMAL
- en: (cons (car ls) (g (cdr ls)))))))))
  prefs: []
  type: TYPE_NORMAL
- en: (append '(a b c) '()) ![<graphic>](ch6_0.gif) (a b c)
  prefs: []
  type: TYPE_NORMAL
- en: (append '() '(a b c)) ![<graphic>](ch6_0.gif) (a b c)
  prefs: []
  type: TYPE_NORMAL
- en: (append '(a b) '(c d)) ![<graphic>](ch6_0.gif) (a b c d)
  prefs: []
  type: TYPE_NORMAL
- en: (append '(a b) 'c) ![<graphic>](ch6_0.gif) (a b . c)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (list 'b)])
  prefs: []
  type: TYPE_NORMAL
- en: (eq? x (cdr (append '(a) x)))) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(reverse *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new list containing the elements of `*list*` in reverse order'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`reverse` may be defined without error checks as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define reverse'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (let rev ([ls ls] [new '()])
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: (rev (cdr ls) (cons (car ls) new))))))
  prefs: []
  type: TYPE_NORMAL
- en: (reverse '()) ![<graphic>](ch6_0.gif) ()
  prefs: []
  type: TYPE_NORMAL
- en: (reverse '(a b c)) ![<graphic>](ch6_0.gif) (c b a)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(memq *obj* *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(memv *obj* *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(member *obj* *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the first tail of `*list*` whose car is equivalent to `*obj*`,
    or `#f`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: These procedures traverse the argument `*list*` in order, comparing the elements
    of `*list*` against `*obj*`. If an object equivalent to `*obj*` is found, the
    tail of the list whose first element is that object is returned. If the list contains
    more than one object equivalent to `*obj*`, the first tail whose first element
    is equivalent to `*obj*` is returned. If no object equivalent to `*obj*` is found,
    `#f` is returned. The equivalence test for `memq` is `eq?`, for `memv` is `eqv?`,
    and for `member` is `equal?`.
  prefs: []
  type: TYPE_NORMAL
- en: These procedures are most often used as predicates, but their names do not end
    with a question mark because they return a useful true value in place of `#t`.
    `memq` may be defined without error checks as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define memq'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x ls)
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(null? ls) #f]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(eq? (car ls) x) ls]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (memq x (cdr ls))])))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`memv` and `member` may be defined similarly, with `eqv?` and `equal?` in place
    of `eq?`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(memq ''a ''(b c a d e)) ![<graphic>](ch6_0.gif) (a d e)'
  prefs: []
  type: TYPE_NORMAL
- en: (memq 'a '(b c d e g)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (memq 'a '(b a c a d a)) ![<graphic>](ch6_0.gif) (a c a d a)
  prefs: []
  type: TYPE_NORMAL
- en: (memv 3.4 '(1.2 2.3 3.4 4.5)) ![<graphic>](ch6_0.gif) (3.4 4.5)
  prefs: []
  type: TYPE_NORMAL
- en: (memv 3.4 '(1.3 2.5 3.7 4.9)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls (list 'a 'b 'c)])
  prefs: []
  type: TYPE_NORMAL
- en: (set-car! (memv 'b ls) 'z)
  prefs: []
  type: TYPE_NORMAL
- en: ls) ![<graphic>](ch6_0.gif) (a z c)
  prefs: []
  type: TYPE_NORMAL
- en: (member '(b) '((a) (b) (c))) ![<graphic>](ch6_0.gif) ((b) (c))
  prefs: []
  type: TYPE_NORMAL
- en: (member '(d) '((a) (b) (c))) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (member "b" '("a" "b" "c")) ![<graphic>](ch6_0.gif) ("b" "c")
  prefs: []
  type: TYPE_NORMAL
- en: (let ()
  prefs: []
  type: TYPE_NORMAL
- en: (define member?
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x ls)
  prefs: []
  type: TYPE_NORMAL
- en: (and (member x ls) #t)))
  prefs: []
  type: TYPE_NORMAL
- en: (member? '(b) '((a) (b) (c)))) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (define count-occurrences
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x ls)
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(memq x ls) =>'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (+ (count-occurrences x (cdr ls)) 1))]
  prefs: []
  type: TYPE_NORMAL
- en: '[else 0])))'
  prefs: []
  type: TYPE_NORMAL
- en: (count-occurrences 'a '(a b c d a)) ![<graphic>](ch6_0.gif) 2`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(memp *procedure* *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the first tail of `*list*` for whose car `*procedure*` returns
    true, or `#f`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*procedure*` should accept one argument and return a single value. It should
    not modify `*list*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(memp odd? ''(1 2 3 4)) ![<graphic>](ch6_0.gif) (1 2 3 4)'
  prefs: []
  type: TYPE_NORMAL
- en: (memp even? '(1 2 3 4)) ![<graphic>](ch6_0.gif) (2 3 4)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls (list 1 2 3 4)])
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (memp odd? ls) ls)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls (list 1 2 3 4)])
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (memp even? ls) (cdr ls))) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (memp odd? '(2 4 6 8)) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(remq *obj* *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(remv *obj* *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(remove *obj* *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a list containing the elements of `*list*` with all occurrences
    of `*obj*` removed'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: These procedures traverse the argument `*list*`, removing any objects that are
    equivalent to `*obj*`. The elements remaining in the output list are in the same
    order as they appear in the input list. If a tail of `*list*` (including `*list*`
    itself) contains no occurrences of `*obj*`, the corresponding tail of the result
    list may be the same (by `eq?`) as the tail of the input list.
  prefs: []
  type: TYPE_NORMAL
- en: The equivalence test for `remq` is `eq?`, for `remv` is `eqv?`, and for `remove`
    is `equal?`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(remq ''a ''(a b a c a d)) ![<graphic>](ch6_0.gif) (b c d)'
  prefs: []
  type: TYPE_NORMAL
- en: (remq 'a '(b c d)) ![<graphic>](ch6_0.gif) (b c d)
  prefs: []
  type: TYPE_NORMAL
- en: (remv 1/2 '(1.2 1/2 0.5 3/2 4)) ![<graphic>](ch6_0.gif) (1.2 0.5 3/2 4)
  prefs: []
  type: TYPE_NORMAL
- en: (remove '(b) '((a) (b) (c))) ![<graphic>](ch6_0.gif) ((a) (c))`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(remp *procedure* *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a list of the elements of `*list*` for which `*procedure*` returns
    `#f`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*procedure*` should accept one argument and return a single value. It should
    not modify `*list*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`remp` applies `*procedure*` to each element of `*list*` and returns a list
    containing only the elements for which `*procedure*` returns `#f`. The elements
    of the returned list appear in the same order as they appeared in the original
    list.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(remp odd? ''(1 2 3 4)) ![<graphic>](ch6_0.gif) (2 4)'
  prefs: []
  type: TYPE_NORMAL
- en: (remp
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x) (and (> x 0) (< x 10)))
  prefs: []
  type: TYPE_NORMAL
- en: '''(-5 15 3 14 -20 6 0 -9)) ![<graphic>](ch6_0.gif) (-5 15 14 -20 0 -9)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(filter *procedure* *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a list of the elements of `*list*` for which `*procedure*` returns
    true'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*procedure*` should accept one argument and return a single value. It should
    not modify `*list*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter` applies `*procedure*` to each element of `*list*` and returns a new
    list containing only the elements for which `*procedure*` returns true. The elements
    of the returned list appear in the same order as they appeared in the original
    list.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(filter odd? ''(1 2 3 4)) ![<graphic>](ch6_0.gif) (1 3)'
  prefs: []
  type: TYPE_NORMAL
- en: (filter
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x) (and (> x 0) (< x 10)))
  prefs: []
  type: TYPE_NORMAL
- en: '''(-5 15 3 14 -20 6 0 -9)) ![<graphic>](ch6_0.gif) (3 6)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(partition *procedure* *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*procedure*` should accept one argument and return a single value. It should
    not modify `*list*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`partition` applies `*procedure*` to each element of `*list*` and returns two
    values: a new list containing only the elements for which `*procedure*` returns
    true, and a new list containing only the elements for which `*procedure*` returns
    `#f`. The elements of the returned lists appear in the same order as they appeared
    in the original list.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(partition odd? ''(1 2 3 4)) ![<graphic>](ch6_0.gif) (1 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) (2 4)'
  prefs: []
  type: TYPE_IMG
- en: (partition
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x) (and (> x 0) (< x 10)))
  prefs: []
  type: TYPE_NORMAL
- en: '''(-5 15 3 14 -20 6 0 -9)) ![<graphic>](ch6_0.gif) (3 6)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) (-5 15 14 -20 0 -9)`'
  prefs: []
  type: TYPE_NORMAL
- en: The values returned by `partition` can be obtained by calling `filter` and `remp`
    separately, but this would require two calls to `*procedure*` for each element
    of `*list*`.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(find *procedure* *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the first element of `*list*` for which `*procedure*` returns
    true, or `#f`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*procedure*` should accept one argument and return a single value. It should
    not modify `*list*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`find` traverses the argument `*list*` in order, applying `*procedure*` to
    each element in turn. If `*procedure*` returns a true value for a given element,
    `find` returns that element without applying `*procedure*` to the remaining elements.
    If `*procedure*` returns `#f` for each element of `*list*`, `find` returns `#f`.'
  prefs: []
  type: TYPE_NORMAL
- en: If a program must distinguish between finding `#f` in the list and finding no
    element at all, `memp` should be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: '`(find odd? ''(1 2 3 4)) ![<graphic>](ch6_0.gif) 1'
  prefs: []
  type: TYPE_NORMAL
- en: (find even? '(1 2 3 4)) ![<graphic>](ch6_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (find odd? '(2 4 6 8)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (find not '(1 a #f 55)) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(assq *obj* *alist*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(assv *obj* *alist*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(assoc *obj* *alist*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** first element of `*alist*` whose car is equivalent to `*obj*`,
    or `#f`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The argument `*alist*` must be an *association list*. An association list is
    a proper list whose elements are key-value pairs of the form `(key . value)`.
    Associations are useful for storing information (values) associated with certain
    objects (keys).
  prefs: []
  type: TYPE_NORMAL
- en: These procedures traverse the association list, testing each key for equivalence
    with `*obj*`. If an equivalent key is found, the key-value pair is returned. Otherwise,
    `#f` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The equivalence test for `assq` is `eq?`, for `assv` is `eqv?`, and for `assoc`
    is `equal?`. `assq` may be defined without error checks as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define assq'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x ls)
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(null? ls) #f]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(eq? (caar ls) x) (car ls)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (assq x (cdr ls))])))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`assv` and `assoc` may be defined similarly, with `eqv?` and `equal?` in place
    of `eq?`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(assq ''b ''((a . 1) (b . 2))) ![<graphic>](ch6_0.gif) (b . 2)'
  prefs: []
  type: TYPE_NORMAL
- en: (cdr (assq 'b '((a . 1) (b . 2)))) ![<graphic>](ch6_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (assq 'c '((a . 1) (b . 2))) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (assv 2/3 '((1/3 . 1) (2/3 . 2))) ![<graphic>](ch6_0.gif) (2/3 . 2)
  prefs: []
  type: TYPE_NORMAL
- en: (assv 2/3 '((1/3 . a) (3/4 . b))) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (assoc '(a) '(((a) . a) (-1 . b))) ![<graphic>](ch6_0.gif) ((a) . a)
  prefs: []
  type: TYPE_NORMAL
- en: (assoc '(a) '(((b) . b) (a . c))) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (let ([alist (list (cons 2 'a) (cons 3 'b))])
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! (assv 3 alist) 'c)
  prefs: []
  type: TYPE_NORMAL
- en: alist) ![<graphic>](ch6_0.gif) ((2 . a) (3 . c))`
  prefs: []
  type: TYPE_NORMAL
- en: The interpreter given in Section [12.7](examples.html#g187) represents environments
    as association lists and uses `assq` for both variable lookup and assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(assp *procedure* *alist*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** first element of `*alist*` for whose car `*procedure*` returns
    true, or `#f`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*alist*` must be an *association list*. An association list is a proper list
    whose elements are key-value pairs of the form `(key . value)`. `*procedure*`
    should accept one argument and return a single value. It should not modify `*list*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(assp odd? ''((1 . a) (2 . b))) ![<graphic>](ch6_0.gif) (1 . a)'
  prefs: []
  type: TYPE_NORMAL
- en: (assp even? '((1 . a) (2 . b))) ![<graphic>](ch6_0.gif) (2 . b)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls (list (cons 1 'a) (cons 2 'b))])
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (assp odd? ls) (car ls))) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls (list (cons 1 'a) (cons 2 'b))])
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (assp even? ls) (cadr ls))) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (assp odd? '((2 . b))) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(list-sort *predicate* *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a list containing the elements of `*list*` sorted according to
    `*predicate*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs sorting)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*predicate*` should be a procedure that expects two arguments and returns
    `#t` if its first argument must precede its second in the sorted list. That is,
    if `*predicate*` is applied to two elements `*x*` and `*y*`, where `*x*` appears
    after `*y*` in the input list, it should return true only if `*x*` should appear
    before `*y*` in the output list. If this constraint is met, `list-sort` performs
    a stable sort, i.e., two elements are reordered only when necessary according
    to `*predicate*`. Duplicate elements are not removed. This procedure may call
    predicate up to *n*log*n* times, where *n* is the length of `*list*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(list-sort < ''(3 4 2 1 2 5)) ![<graphic>](ch6_0.gif) (1 2 2 3 4 5)'
  prefs: []
  type: TYPE_NORMAL
- en: (list-sort > '(0.5 1/2)) ![<graphic>](ch6_0.gif) (0.5 1/2)
  prefs: []
  type: TYPE_NORMAL
- en: (list-sort > '(1/2 0.5)) ![<graphic>](ch6_0.gif) (1/2 0.5)
  prefs: []
  type: TYPE_NORMAL
- en: (list->string
  prefs: []
  type: TYPE_NORMAL
- en: (list-sort char>?
  prefs: []
  type: TYPE_NORMAL
- en: (string->list "hello"))) ![<graphic>](ch6_0.gif) "ollhe"`
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.4\. Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scheme numbers may be classified as integers, rational numbers, real numbers,
    or complex numbers. This classification is hierarchical, in that all integers
    are rational, all rational numbers are real, and all real numbers are complex.
    The predicates `integer?`, `rational?`, `real?`, and `complex?` described in Section [6.2](objects.html#g108)
    are used to determine into which of these classes a number falls.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Scheme number may also be classified as *exact* or *inexact*, depending upon
    the quality of operations used to derive the number and the inputs to these operations.
    The predicates `exact?` and `inexact?` may be used to determine the exactness
    of a number. Most operations on numbers in Scheme are *exactness preserving*:
    if given exact operands they return exact values, and if given inexact operands
    or a combination of exact and inexact operands they return inexact values.'
  prefs: []
  type: TYPE_NORMAL
- en: Exact integer and rational arithmetic is typically supported to arbitrary precision;
    the size of an integer or of the denominator or numerator of a ratio is limited
    only by system storage constraints. Although other representations are possible,
    inexact numbers are typically represented by *floating-point* numbers supported
    by the host computer's hardware or by system software. Complex numbers are typically
    represented as ordered pairs (`*real-part*`, `*imag-part*`), where `*real-part*`
    and `*imag-part*` are exact integers, exact rationals, or floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Scheme numbers are written in a straightforward manner not much different from
    ordinary conventions for writing numbers. An exact integer is normally written
    as a sequence of numerals preceded by an optional sign. For example, `3`, `+19`,
    `-100000`, and `208423089237489374` all represent exact integers.
  prefs: []
  type: TYPE_NORMAL
- en: An exact rational number is normally written as two sequences of numerals separated
    by a slash (`/`) and preceded by an optional sign. For example, `3/4`, `-6/5`,
    and `1/1208203823` are all exact rational numbers. A ratio is reduced immediately
    to lowest terms when it is read and may in fact reduce to an exact integer.
  prefs: []
  type: TYPE_NORMAL
- en: Inexact real numbers are normally written in either floating-point or scientific
    notation. Floating-point notation consists of a sequence of numerals followed
    by a decimal point and another sequence of numerals, all preceded by an optional
    sign. Scientific notation consists of an optional sign, a sequence of numerals,
    an optional decimal point followed by a second string of numerals, and an exponent;
    an exponent is written as the letter `e` followed by an optional sign and a sequence
    of numerals. For example, `1.0` and `-200.0` are valid inexact integers, and `1.5`,
    `0.034`, `-10e-10` and `1.5e-5` are valid inexact rational numbers. The exponent
    is the power of ten by which the number preceding the exponent should be scaled,
    so that `2e3` is equivalent to `2000.0`.
  prefs: []
  type: TYPE_NORMAL
- en: A mantissa width `|*w*` may appear as the suffix of a real number or the real
    components of a complex number written in floating-point or scientific notation.
    The mantissa width `*m*` represents the number of significant bits in the representation
    of the number. The mantissa width defaults to 53, the number of significant bits
    in a normalized IEEE double floating-point number, or more. For denormalized IEEE
    double floating-point numbers, the mantissa width is less than 53. If an implementation
    cannot represent a number with the mantissa width specified, it uses a representation
    with at least as many significant bits as requested if possible, otherwise it
    uses its representation with the largest mantissa width.
  prefs: []
  type: TYPE_NORMAL
- en: Exact and inexact real numbers are written as exact or inexact integers or rational
    numbers; no provision is made in the syntax of Scheme numbers for nonrational
    real numbers, i.e., irrational numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Complex numbers may be written in either rectangular or polar form. In rectangular
    form, a complex number is written as `*x*+*y*i` or `*x*-*y*i`, where `*x*` is
    an integer, rational, or real number and `*y*` is an unsigned integer, rational,
    or real number. The real part, *x*, may be omitted, in which case it is assumed
    to be zero. For example, `3+4i`, `3.2-3/4i`, `+i`, and `-3e-5i` are complex numbers
    written in rectangular form. In polar form, a complex number is written as `*x*@*y*`,
    where `*x*` and `*y*` are integer, rational, or real numbers. For example, `1.1@1.764`
    and `-1@-1/2` are complex numbers written in polar form.
  prefs: []
  type: TYPE_NORMAL
- en: The syntaxes `+inf.0` and `-inf.0` represent inexact real numbers that represent
    positive and negative infinity. The syntaxes `+nan.0` and `-nan.0` represent an
    inexact "not-a-number" (NaN) value. Infinities may be produced by dividing inexact
    positive and negative values by inexact zero, and NaNs may also be produced by
    dividing inexact zero by inexact zero, among other ways.
  prefs: []
  type: TYPE_NORMAL
- en: The exactness of a numeric representation may be overridden by preceding the
    representation by either `#e` or `#i`. `#e` forces the number to be exact, and
    `#i` forces it to be inexact. For example, `1`, `#e1`, 1/1, `#e1/1`, `#e1.0`,
    and `#e1e0` all represent the exact integer 1, and `#i3/10`, `0.3`, `#i0.3`, and
    `3e-1` all represent the inexact rational 0.3.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers are written by default in base 10, although the special prefixes `#b`
    (binary), `#o` (octal), `#d` (decimal), and `#x` (hexadecimal) can be used to
    specify base 2, base 8, base 10, or base 16. For radix 16, the letters `a` through
    `f` or `A` through `F` serve as the additional numerals required to express digit
    values 10 through 15. For example, `#b10101` is the binary equivalent of 21[10],
    `#o72` is the octal equivalent of 58[10], and `#xC7` is the hexadecimal equivalent
    of 199[10]. Numbers written in floating-point and scientific notations are always
    written in base 10.
  prefs: []
  type: TYPE_NORMAL
- en: If both are present, radix and exactness prefixes may appear in either order.
  prefs: []
  type: TYPE_NORMAL
- en: A Scheme implementation may support more than one size of internal representation
    for inexact quantities. The exponent markers `s` (*short*), `f` (*single*), `d`
    (*double*), and `l` (*long*) may appear in place of the default exponent marker
    `e` to override the default size for numbers written in scientific notation. In
    implementations that support multiple representations, the default size has at
    least as much precision as *double*.
  prefs: []
  type: TYPE_NORMAL
- en: A precise grammar for Scheme numbers is given on page [459](grammar.html#grammar:numbers).
  prefs: []
  type: TYPE_NORMAL
- en: Any number can be written in a variety of different ways, but the system printer
    (invoked by `put-datum`, `write`, and `display`) and `number->string` express
    numbers in a compact form, using the fewest number of digits necessary to retain
    the property that, when read, the printed number is identical to the original
    number.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of this section describes "generic arithmetic" procedures that
    operate on numbers. The two sections that follow this section describe operations
    specific to *fixnums* and *flonums*, which are representations of exact, fixed-precision
    integer values and inexact real values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The types of numeric arguments accepted by the procedures in this section are
    implied by the names given to the arguments: `*num*` for complex numbers (that
    is, all numbers), `*real*` for real numbers, `*rat*` for rational numbers, and
    `*int*` for integers. If a `*real*`, `*rat*`, or `*int*` is required, the argument
    must be considered real, rational, or integral by `real?`, `rational?`, or `integer?`,
    i.e., the imaginary part of the number must be exactly zero. Where exact integers
    are required, the name `*exint*` is used. In each case, a suffix may appear on
    the name, e.g., `*int[2]*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(exact? *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*num*` is exact, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(exact? 1) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (exact? -15/16) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (exact? 2.01) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (exact? #i77) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (exact? #i2/3) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (exact? 1.0-2i) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(inexact? *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*num*` is inexact, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(inexact? -123) ![<graphic>](ch6_0.gif) #f'
  prefs: []
  type: TYPE_NORMAL
- en: (inexact? #i123) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (inexact? 1e23) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (inexact? +i) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(= *num[1]* *num[2]* *num[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(< *real[1]* *real[2]* *real[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(> *real[1]* *real[2]* *real[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(<= *real[1]* *real[2]* *real[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(>= *real[1]* *real[2]* *real[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the relation holds, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The predicate `=` returns `#t` if its arguments are equal. The predicate `<`
    returns `#t` if its arguments are monotonically increasing, i.e., each argument
    is greater than the preceding ones, while `>` returns `#t` if its arguments are
    monotonically decreasing. The predicate `<=` returns `#t` if its arguments are
    monotonically nondecreasing, i.e., each argument is not less than the preceding
    ones, while `>=` returns `#t` if its arguments are monotonically nonincreasing.
  prefs: []
  type: TYPE_NORMAL
- en: As implied by the names of the arguments, `=` is defined for complex arguments
    while the other relational predicates are defined only for real arguments. Two
    complex numbers are considered equal if their real and imaginary parts are equal.
    Comparisons involving NaNs always return `#f`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(= 7 7) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (= 7 9) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (< 2e3 3e2) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (<= 1 2 3 3 4 5) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (<= 1 2 3 4 5) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (> 1 2 2 3 3 4) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (>= 1 2 2 3 3 4) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (= -1/2 -0.5) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (= 2/3 .667) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (= 7.2+0i 7.2) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (= 7.2-3i 7) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (< 1/2 2/3 3/4) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (> 8 4.102 2/3 -5) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x 0.218723452])
  prefs: []
  type: TYPE_NORMAL
- en: (< 0.210 x 0.220)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([i 1] [v (vector 'a 'b 'c)])
  prefs: []
  type: TYPE_NORMAL
- en: (< -1 i (vector-length v))) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (apply < '(1 2 3 4)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (apply > '(4 3 3 2)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (= +nan.0 +nan.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (< +nan.0 +nan.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (> +nan.0 +nan.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (>= +inf.0 +nan.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (>= +nan.0 -inf.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (> +nan.0 0.0) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(+ *num* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the sum of the arguments `*num* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: When called with no arguments, `+` returns 0.
  prefs: []
  type: TYPE_NORMAL
- en: '`(+) ![<graphic>](ch6_0.gif) 0'
  prefs: []
  type: TYPE_NORMAL
- en: (+ 1 2) ![<graphic>](ch6_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (+ 1/2 2/3) ![<graphic>](ch6_0.gif) 7/6
  prefs: []
  type: TYPE_NORMAL
- en: (+ 3 4 5) ![<graphic>](ch6_0.gif) 12
  prefs: []
  type: TYPE_NORMAL
- en: (+ 3.0 4) ![<graphic>](ch6_0.gif) 7.0
  prefs: []
  type: TYPE_NORMAL
- en: (+ 3+4i 4+3i) ![<graphic>](ch6_0.gif) 7+7i
  prefs: []
  type: TYPE_NORMAL
- en: (apply + '(1 2 3 4 5)) ![<graphic>](ch6_0.gif) 15`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(- *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the additive inverse of `*num*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(- *num[1]* *num[2]* *num[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the difference between `*num[1]*` and the sum of `*num[2]* *num[3]* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(- 3) ![<graphic>](ch6_0.gif) -3'
  prefs: []
  type: TYPE_NORMAL
- en: (- -2/3) ![<graphic>](ch6_0.gif) 2/3
  prefs: []
  type: TYPE_NORMAL
- en: (- 4 3.0) ![<graphic>](ch6_0.gif) 1.0
  prefs: []
  type: TYPE_NORMAL
- en: (- 3.25+4.25i 1/4+1/4i) ![<graphic>](ch6_0.gif) 3.0+4.0i
  prefs: []
  type: TYPE_NORMAL
- en: (- 4 3 2 1) ![<graphic>](ch6_0.gif) -2`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(* *num* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the product of the arguments `*num* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: When called with no arguments, `*` returns 1.
  prefs: []
  type: TYPE_NORMAL
- en: '`(*) ![<graphic>](ch6_0.gif) 1'
  prefs: []
  type: TYPE_NORMAL
- en: (* 3.4) ![<graphic>](ch6_0.gif) 3.4
  prefs: []
  type: TYPE_NORMAL
- en: (* 1 1/2) ![<graphic>](ch6_0.gif) 1/2
  prefs: []
  type: TYPE_NORMAL
- en: (* 3 4 5.5) ![<graphic>](ch6_0.gif) 66.0
  prefs: []
  type: TYPE_NORMAL
- en: (* 1+2i 3+4i) ![<graphic>](ch6_0.gif) -5+10i
  prefs: []
  type: TYPE_NORMAL
- en: (apply * '(1 2 3 4 5)) ![<graphic>](ch6_0.gif) 120`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(/ *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the multiplicative inverse of `*num*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(/ *num[1]* *num[2]* *num[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the result of dividing `*num[1]*` by the product of `*num[2]* *num[3]* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(/ -17) ![<graphic>](ch6_0.gif) -1/17'
  prefs: []
  type: TYPE_NORMAL
- en: (/ 1/2) ![<graphic>](ch6_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (/ .5) ![<graphic>](ch6_0.gif) 2.0
  prefs: []
  type: TYPE_NORMAL
- en: (/ 3 4) ![<graphic>](ch6_0.gif) 3/4
  prefs: []
  type: TYPE_NORMAL
- en: (/ 3.0 4) ![<graphic>](ch6_0.gif) .75
  prefs: []
  type: TYPE_NORMAL
- en: (/ -5+10i 3+4i) ![<graphic>](ch6_0.gif) 1+2i
  prefs: []
  type: TYPE_NORMAL
- en: (/ 60 5 4 3 2) ![<graphic>](ch6_0.gif) 1/2`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(zero? *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*num*` is zero, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`zero?` is equivalent to `(lambda (x) (= x 0))`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(zero? 0) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (zero? 1) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (zero? (- 3.0 3.0)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (zero? (+ 1/2 1/2)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (zero? 0+0i) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (zero? 0.0-0.0i) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(positive? *real*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*real*` is greater than zero, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`positive?` is equivalent to `(lambda (x) (> x 0))`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(positive? 128) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (positive? 0.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (positive? 1.8e-15) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (positive? -2/3) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (positive? .001-0.0i) ![<graphic>](ch6_0.gif) *exception: not a real number*`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(negative? *real*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*real*` is less than zero, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`negative?` is equivalent to `(lambda (x) (< x 0))`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(negative? -65) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (negative? 0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (negative? -0.0121) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (negative? 15/16) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (negative? -7.0+0.0i) ![<graphic>](ch6_0.gif) *exception: not a real number*`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(even? *int*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*int*` is even, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(odd? *int*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*int*` is odd, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(even? 0) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (even? 1) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (even? 2.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (even? -120762398465) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (even? 2.0+0.0i) ![<graphic>](ch6_0.gif) *exception: not an integer*
  prefs: []
  type: TYPE_NORMAL
- en: (odd? 0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (odd? 1) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (odd? 2.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (odd? -120762398465) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (odd? 2.0+0.0i) ![<graphic>](ch6_0.gif) *exception: not an integer*`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(finite? *real*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*real*` is finite, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(infinite? *real*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*real*` is infinite, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(nan? *real*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*real*` is a NaN, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(finite? 2/3) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (infinite? 2/3) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (nan? 2/3) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (finite? 3.1415) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (infinite? 3.1415) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (nan? 3.1415) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (finite? +inf.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (infinite? -inf.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (nan? -inf.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (finite? +nan.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (infinite? +nan.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (nan? +nan.0) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(quotient *int[1]* *int[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer quotient of `*int[1]*` and `*int[2]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(remainder *int[1]* *int[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer remainder of `*int[1]*` and `*int[2]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(modulo *int[1]* *int[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer modulus of `*int[1]*` and `*int[2]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs r5rs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The result of `remainder` has the same sign as `*int[1]*`, while the result
    of `modulo` has the same sign as `*int[2]*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(quotient 45 6) ![<graphic>](ch6_0.gif) 7'
  prefs: []
  type: TYPE_NORMAL
- en: (quotient 6.0 2.0) ![<graphic>](ch6_0.gif) 3.0
  prefs: []
  type: TYPE_NORMAL
- en: (quotient 3.0 -2) ![<graphic>](ch6_0.gif) -1.0
  prefs: []
  type: TYPE_NORMAL
- en: (remainder 16 4) ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (remainder 5 2) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (remainder -45.0 7) ![<graphic>](ch6_0.gif) -3.0
  prefs: []
  type: TYPE_NORMAL
- en: (remainder 10.0 -3.0) ![<graphic>](ch6_0.gif) 1.0
  prefs: []
  type: TYPE_NORMAL
- en: (remainder -17 -9) ![<graphic>](ch6_0.gif) -8
  prefs: []
  type: TYPE_NORMAL
- en: (modulo 16 4) ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (modulo 5 2) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (modulo -45.0 7) ![<graphic>](ch6_0.gif) 4.0
  prefs: []
  type: TYPE_NORMAL
- en: (modulo 10.0 -3.0) ![<graphic>](ch6_0.gif) -2.0
  prefs: []
  type: TYPE_NORMAL
- en: (modulo -17 -9) ![<graphic>](ch6_0.gif) -8`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(div *x[1]* *x[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(mod *x[1]* *x[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(div-and-mod *x[1]* *x[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*x[1]*` and `*x[2]*` are exact, `*x[2]*` must not be zero. These procedures
    implement number-theoretic integer division, with the `div` operation being related
    to `quotient` and the `mod` operation being related to `remainder` or `modulo`,
    but in both cases extended to handle real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The value `*n[d]*` of `(div *x[1]* *x[2]*)` is an integer, and the value `*x[m]*`
    of `(mod *x[1]* *x[2]*)` is a real number such that *x*[1] = *n*[d] · *x*[2] +
    *x*[m] and 0 ≤ *x*[m] < |*x*[2]|. In situations where the implementation cannot
    represent the mathematical results prescribed by these equations as a number object,
    `div` and `mod` return an unspecified number or raise an exception with condition
    type `&implementation-restriction`.
  prefs: []
  type: TYPE_NORMAL
- en: The `div-and-mod` procedure behaves as if defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (div-and-mod x1 x2) (values (div x1 x2) (mod x1 x2)))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, unless it raises an exception in the circumstance described above,
    it returns two values: the result of calling `div` on the two arguments and the
    result of calling `mod` on the two arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(div 17 3) ![<graphic>](ch6_0.gif) 5'
  prefs: []
  type: TYPE_NORMAL
- en: (mod 17 3) ![<graphic>](ch6_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (div -17 3) ![<graphic>](ch6_0.gif) -6
  prefs: []
  type: TYPE_NORMAL
- en: (mod -17 3) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (div 17 -3) ![<graphic>](ch6_0.gif) -5
  prefs: []
  type: TYPE_NORMAL
- en: (mod 17 -3) ![<graphic>](ch6_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (div -17 -3) ![<graphic>](ch6_0.gif) 6
  prefs: []
  type: TYPE_NORMAL
- en: (mod -17 -3) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (div-and-mod 17.5 3) ![<graphic>](ch6_0.gif) 5.0
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) 2.5`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(div0 *x[1]* *x[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(mod0 *x[1]* *x[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(div0-and-mod0 *x[1]* *x[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*x[1]*` and `*x[2]*` are exact, `*x[2]*` must not be zero. These procedures
    are similar to `div`, `mod`, and `div-and-mod`, but constrain the "mod" value
    differently, which also affects the "div" value. The value `*n[d]*` of `(div0 *x[1]* *x[2]*)`
    is an integer, and the value `*x[m]*` of `(mod0 *x[1]* *x[2]*)` is a real number
    such that *x*[1] = *n*[d] · *x*[2] + *x*[m] and -|*x*[2]/2| ≤ *x*[m] < |*x*[2]/2|.
    In situations where the implementation cannot represent the mathematical results
    prescribed by these equations as a number object, `div0` and `mod0` return an
    unspecified number or raise an exception with condition type `&implementation-restriction`.
  prefs: []
  type: TYPE_NORMAL
- en: The `div0-and-mod0` procedure behaves as if defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (div0-and-mod0 x1 x2) (values (div0 x1 x2) (mod0 x1 x2)))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, unless it raises an exception in the circumstance described above,
    it returns two values: the result of calling `div0` on the two arguments and the
    result of calling `mod0` on the two arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(div0 17 3) ![<graphic>](ch6_0.gif) 6'
  prefs: []
  type: TYPE_NORMAL
- en: (mod0 17 3) ![<graphic>](ch6_0.gif) -1
  prefs: []
  type: TYPE_NORMAL
- en: (div0 -17 3) ![<graphic>](ch6_0.gif) -6
  prefs: []
  type: TYPE_NORMAL
- en: (mod0 -17 3) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (div0 17 -3) ![<graphic>](ch6_0.gif) -6
  prefs: []
  type: TYPE_NORMAL
- en: (mod0 17 -3) ![<graphic>](ch6_0.gif) -1
  prefs: []
  type: TYPE_NORMAL
- en: (div0 -17 -3) ![<graphic>](ch6_0.gif) 6
  prefs: []
  type: TYPE_NORMAL
- en: (mod0 -17 -3) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (div0-and-mod0 17.5 3) ![<graphic>](ch6_0.gif) 6.0
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) -0.5`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(truncate *real*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer closest to `*real*` toward zero'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*real*` is an infinity or NaN, `truncate` returns `*real*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(truncate 19) ![<graphic>](ch6_0.gif) 19'
  prefs: []
  type: TYPE_NORMAL
- en: (truncate 2/3) ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (truncate -2/3) ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (truncate 17.3) ![<graphic>](ch6_0.gif) 17.0
  prefs: []
  type: TYPE_NORMAL
- en: (truncate -17/2) ![<graphic>](ch6_0.gif) -8`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(floor *real*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer closest to `*real*` toward ![<graphic>](ch6_11.gif)'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*real*` is an infinity or NaN, `floor` returns `*real*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(floor 19) ![<graphic>](ch6_0.gif) 19'
  prefs: []
  type: TYPE_NORMAL
- en: (floor 2/3) ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (floor -2/3) ![<graphic>](ch6_0.gif) -1
  prefs: []
  type: TYPE_NORMAL
- en: (floor 17.3) ![<graphic>](ch6_0.gif) 17.0
  prefs: []
  type: TYPE_NORMAL
- en: (floor -17/2) ![<graphic>](ch6_0.gif) -9`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(ceiling *real*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer closest to `*real*` toward ![<graphic>](ch6_12.gif)'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*real*` is an infinity or NaN, `ceiling` returns `*real*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(ceiling 19) ![<graphic>](ch6_0.gif) 19'
  prefs: []
  type: TYPE_NORMAL
- en: (ceiling 2/3) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (ceiling -2/3) ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (ceiling 17.3) ![<graphic>](ch6_0.gif) 18.0
  prefs: []
  type: TYPE_NORMAL
- en: (ceiling -17/2) ![<graphic>](ch6_0.gif) -8`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(round *real*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer closest to `*real*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*real*` is exactly between two integers, the closest even integer is returned.
    If `*real*` is an infinity or NaN, `round` returns `*real*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(round 19) ![<graphic>](ch6_0.gif) 19'
  prefs: []
  type: TYPE_NORMAL
- en: (round 2/3) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (round -2/3) ![<graphic>](ch6_0.gif) -1
  prefs: []
  type: TYPE_NORMAL
- en: (round 17.3) ![<graphic>](ch6_0.gif) 17.0
  prefs: []
  type: TYPE_NORMAL
- en: (round -17/2) ![<graphic>](ch6_0.gif) -8
  prefs: []
  type: TYPE_NORMAL
- en: (round 2.5) ![<graphic>](ch6_0.gif) 2.0
  prefs: []
  type: TYPE_NORMAL
- en: (round 3.5) ![<graphic>](ch6_0.gif) 4.0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(abs *real*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the absolute value of `*real*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`abs` is equivalent to `(lambda (x) (if (< x 0) (- x) x))`. `abs` and `magnitude`
    (see page [183](objects.html#page:magnitude)) are identical for real inputs.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(abs 1) ![<graphic>](ch6_0.gif) 1'
  prefs: []
  type: TYPE_NORMAL
- en: (abs -3/4) ![<graphic>](ch6_0.gif) 3/4
  prefs: []
  type: TYPE_NORMAL
- en: (abs 1.83) ![<graphic>](ch6_0.gif) 1.83
  prefs: []
  type: TYPE_NORMAL
- en: (abs -0.093) ![<graphic>](ch6_0.gif) 0.093`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(max *real[1]* *real[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the maximum of `*real[1]* *real[2]* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(max 4 -7 2 0 -6) ![<graphic>](ch6_0.gif) 4'
  prefs: []
  type: TYPE_NORMAL
- en: (max 1/2 3/4 4/5 5/6 6/7) ![<graphic>](ch6_0.gif) 6/7
  prefs: []
  type: TYPE_NORMAL
- en: (max 1.5 1.3 -0.3 0.4 2.0 1.8) ![<graphic>](ch6_0.gif) 2.0
  prefs: []
  type: TYPE_NORMAL
- en: (max 5 2.0) ![<graphic>](ch6_0.gif) 5.0
  prefs: []
  type: TYPE_NORMAL
- en: (max -5 -2.0) ![<graphic>](ch6_0.gif) -2.0
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls '(7 3 5 2 9 8)])
  prefs: []
  type: TYPE_NORMAL
- en: (apply max ls)) ![<graphic>](ch6_0.gif) 9`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(min *real[1]* *real[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the minimum of `*real[1]* *real[2]* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(min 4 -7 2 0 -6) ![<graphic>](ch6_0.gif) -7'
  prefs: []
  type: TYPE_NORMAL
- en: (min 1/2 3/4 4/5 5/6 6/7) ![<graphic>](ch6_0.gif) 1/2
  prefs: []
  type: TYPE_NORMAL
- en: (min 1.5 1.3 -0.3 0.4 2.0 1.8) ![<graphic>](ch6_0.gif) -0.3
  prefs: []
  type: TYPE_NORMAL
- en: (min 5 2.0) ![<graphic>](ch6_0.gif) 2.0
  prefs: []
  type: TYPE_NORMAL
- en: (min -5 -2.0) ![<graphic>](ch6_0.gif) -5.0
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls '(7 3 5 2 9 8)])
  prefs: []
  type: TYPE_NORMAL
- en: (apply min ls)) ![<graphic>](ch6_0.gif) 2`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(gcd *int* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the greatest common divisor of its arguments `*int* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The result is always nonnegative, i.e., factors of -1 are ignored. When called
    with no arguments, `gcd` returns 0.
  prefs: []
  type: TYPE_NORMAL
- en: '`(gcd) ![<graphic>](ch6_0.gif) 0'
  prefs: []
  type: TYPE_NORMAL
- en: (gcd 34) ![<graphic>](ch6_0.gif) 34
  prefs: []
  type: TYPE_NORMAL
- en: (gcd 33.0 15.0) ![<graphic>](ch6_0.gif) 3.0
  prefs: []
  type: TYPE_NORMAL
- en: (gcd 70 -42 28) ![<graphic>](ch6_0.gif) 14`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(lcm *int* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the least common multiple of its arguments `*int* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The result is always nonnegative, i.e., common multiples of -1 are ignored.
    Although `lcm` should probably return ![<graphic>](ch6_13.gif) when called with
    no arguments, it is defined to return 1. If one or more of the arguments is 0,
    `lcm` returns 0.
  prefs: []
  type: TYPE_NORMAL
- en: '`(lcm) ![<graphic>](ch6_0.gif) 1'
  prefs: []
  type: TYPE_NORMAL
- en: (lcm 34) ![<graphic>](ch6_0.gif) 34
  prefs: []
  type: TYPE_NORMAL
- en: (lcm 33.0 15.0) ![<graphic>](ch6_0.gif) 165.0
  prefs: []
  type: TYPE_NORMAL
- en: (lcm 70 -42 28) ![<graphic>](ch6_0.gif) 420
  prefs: []
  type: TYPE_NORMAL
- en: (lcm 17.0 0) ![<graphic>](ch6_0.gif) 0.0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(expt *num[1]* *num[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*num[1]*` raised to the `*num[2]*` power'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If both arguments are 0, `expt` returns 1.
  prefs: []
  type: TYPE_NORMAL
- en: '`(expt 2 10) ![<graphic>](ch6_0.gif) 1024'
  prefs: []
  type: TYPE_NORMAL
- en: (expt 2 -10) ![<graphic>](ch6_0.gif) 1/1024
  prefs: []
  type: TYPE_NORMAL
- en: (expt 2 -10.0) ![<graphic>](ch6_0.gif) 9.765625e-4
  prefs: []
  type: TYPE_NORMAL
- en: (expt -1/2 5) ![<graphic>](ch6_0.gif) -1/32
  prefs: []
  type: TYPE_NORMAL
- en: (expt 3.0 3) ![<graphic>](ch6_0.gif) 27.0
  prefs: []
  type: TYPE_NORMAL
- en: (expt +i 2) ![<graphic>](ch6_0.gif) -1`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(inexact *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** an inexact representation of `*num*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*num*` is already inexact, it is returned unchanged. If no inexact representation
    for `*num*` is supported by the implementation, an exception with condition type
    `&implementation-violation` may be raised. `inexact` may also return `+inf.0`
    or `-inf.0` for inputs whose magnitude exceeds the range of the implementation's
    inexact number representations.
  prefs: []
  type: TYPE_NORMAL
- en: '`(inexact 3) ![<graphic>](ch6_0.gif) 3.0'
  prefs: []
  type: TYPE_NORMAL
- en: (inexact 3.0) ![<graphic>](ch6_0.gif) 3.0
  prefs: []
  type: TYPE_NORMAL
- en: (inexact -1/4) ![<graphic>](ch6_0.gif) -.25
  prefs: []
  type: TYPE_NORMAL
- en: (inexact 3+4i) ![<graphic>](ch6_0.gif) 3.0+4.0i
  prefs: []
  type: TYPE_NORMAL
- en: (inexact (expt 10 20)) ![<graphic>](ch6_0.gif) 1e20`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(exact *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** an exact representation of `*num*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*num*` is already exact, it is returned unchanged. If no exact representation
    for `*num*` is supported by the implementation, an exception with condition type
    `&implementation-violation` may be raised.
  prefs: []
  type: TYPE_NORMAL
- en: '`(exact 3.0) ![<graphic>](ch6_0.gif) 3'
  prefs: []
  type: TYPE_NORMAL
- en: (exact 3) ![<graphic>](ch6_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (exact -.25) ![<graphic>](ch6_0.gif) -1/4
  prefs: []
  type: TYPE_NORMAL
- en: (exact 3.0+4.0i) ![<graphic>](ch6_0.gif) 3+4i
  prefs: []
  type: TYPE_NORMAL
- en: (exact 1e20) ![<graphic>](ch6_0.gif) 100000000000000000000`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(exact->inexact *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** an inexact representation of `*num*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(inexact->exact *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** an exact representation of `*num*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs r5rs)`'
  prefs: []
  type: TYPE_NORMAL
- en: These are alternative names for `inexact` and `exact`, supported for compatibility
    with the Revised⁵ Report.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(rationalize *real[1]* *real[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`rationalize` returns the simplest rational number that differs from `*real[1]*`
    by no more than `*real[2]*`. A rational number *q*[1] = *n*[1]/*m*[1] is simpler
    than another rational number *q*[2] = *n*[2]/*m*[2] if |*n*[1]| ≤ |*n*[2]| and
    |*m*[1]| ≤ |*m*[2]| and either |*n*[1]| < |*n*[2]| or |*m*[1]| < |*m*[2]|.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(rationalize 3/10 1/10) ![<graphic>](ch6_0.gif) 1/3'
  prefs: []
  type: TYPE_NORMAL
- en: (rationalize .3 1/10) ![<graphic>](ch6_0.gif) 0.3333333333333333
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? (rationalize .3 1/10) #i1/3) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(numerator *rat*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the numerator of `*rat*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*rat*` is an integer, the numerator is `*rat*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(numerator 9) ![<graphic>](ch6_0.gif) 9'
  prefs: []
  type: TYPE_NORMAL
- en: (numerator 9.0) ![<graphic>](ch6_0.gif) 9.0
  prefs: []
  type: TYPE_NORMAL
- en: (numerator 0.0) ![<graphic>](ch6_0.gif) 0.0
  prefs: []
  type: TYPE_NORMAL
- en: (numerator 2/3) ![<graphic>](ch6_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (numerator -9/4) ![<graphic>](ch6_0.gif) -9
  prefs: []
  type: TYPE_NORMAL
- en: (numerator -2.25) ![<graphic>](ch6_0.gif) -9.0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(denominator *rat*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the denominator of `*rat*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*rat*` is an integer, including zero, the denominator is one.
  prefs: []
  type: TYPE_NORMAL
- en: '`(denominator 9) ![<graphic>](ch6_0.gif) 1'
  prefs: []
  type: TYPE_NORMAL
- en: (denominator 9.0) ![<graphic>](ch6_0.gif) 1.0
  prefs: []
  type: TYPE_NORMAL
- en: (denominator 0) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (denominator 0.0) ![<graphic>](ch6_0.gif) 1.0
  prefs: []
  type: TYPE_NORMAL
- en: (denominator 2/3) ![<graphic>](ch6_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (denominator -9/4) ![<graphic>](ch6_0.gif) 4
  prefs: []
  type: TYPE_NORMAL
- en: (denominator -2.25) ![<graphic>](ch6_0.gif) 4.0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(real-part *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the real component of `*num*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*num*` is real, `real-part` returns `*num*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(real-part 3+4i) ![<graphic>](ch6_0.gif) 3'
  prefs: []
  type: TYPE_NORMAL
- en: (real-part -2.3+0.7i) ![<graphic>](ch6_0.gif) -2.3
  prefs: []
  type: TYPE_NORMAL
- en: (real-part -i) ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (real-part 17.2) ![<graphic>](ch6_0.gif) 17.2
  prefs: []
  type: TYPE_NORMAL
- en: (real-part -17/100) ![<graphic>](ch6_0.gif) -17/100`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(imag-part *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the imaginary component of `*num*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*num*` is real, `imag-part` returns exact zero.
  prefs: []
  type: TYPE_NORMAL
- en: '`(imag-part 3+4i) ![<graphic>](ch6_0.gif) 4'
  prefs: []
  type: TYPE_NORMAL
- en: (imag-part -2.3+0.7i) ![<graphic>](ch6_0.gif) 0.7
  prefs: []
  type: TYPE_NORMAL
- en: (imag-part -i) ![<graphic>](ch6_0.gif) -1
  prefs: []
  type: TYPE_NORMAL
- en: (imag-part -2.5) ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (imag-part -17/100) ![<graphic>](ch6_0.gif) 0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-rectangular *real[1]* *real[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a complex number with real component `*real[1]*` and imaginary
    component `*real[2]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(make-rectangular -2 7) ![<graphic>](ch6_0.gif) -2+7i'
  prefs: []
  type: TYPE_NORMAL
- en: (make-rectangular 2/3 -1/2) ![<graphic>](ch6_0.gif) 2/3-1/2i
  prefs: []
  type: TYPE_NORMAL
- en: (make-rectangular 3.2 5.3) ![<graphic>](ch6_0.gif) 3.2+5.3i`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-polar *real[1]* *real[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a complex number with magnitude `*real[1]*` and angle `*real[2]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(make-polar 2 0) ![<graphic>](ch6_0.gif) 2'
  prefs: []
  type: TYPE_NORMAL
- en: (make-polar 2.0 0.0) ![<graphic>](ch6_0.gif) 2.0+0.0i
  prefs: []
  type: TYPE_NORMAL
- en: (make-polar 1.0 (asin -1.0)) ![<graphic>](ch6_0.gif) 0.0-1.0i
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? (make-polar 7.2 -0.588) 7.2@-0.588) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(angle *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the angle part of the polar representation of `*num*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The range of the result is ![<graphic>](ch6_14.gif) (exclusive) to ![<graphic>](ch6_15.gif)
    (inclusive).
  prefs: []
  type: TYPE_NORMAL
- en: '`(angle 7.3@1.5708) ![<graphic>](ch6_0.gif) 1.5708'
  prefs: []
  type: TYPE_NORMAL
- en: (angle 5.2) ![<graphic>](ch6_0.gif) 0.0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(magnitude *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the magnitude of `*num*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`magnitude` and `abs` (see page [178](objects.html#page:abs)) are identical
    for real arguments. The magnitude of a complex number *x* + *yi* is ![<graphic>](ch6_16.gif).'
  prefs: []
  type: TYPE_NORMAL
- en: '`(magnitude 1) ![<graphic>](ch6_0.gif) 1'
  prefs: []
  type: TYPE_NORMAL
- en: (magnitude -3/4) ![<graphic>](ch6_0.gif) 3/4
  prefs: []
  type: TYPE_NORMAL
- en: (magnitude 1.83) ![<graphic>](ch6_0.gif) 1.83
  prefs: []
  type: TYPE_NORMAL
- en: (magnitude -0.093) ![<graphic>](ch6_0.gif) 0.093
  prefs: []
  type: TYPE_NORMAL
- en: (magnitude 3+4i) ![<graphic>](ch6_0.gif) 5
  prefs: []
  type: TYPE_NORMAL
- en: (magnitude 7.25@1.5708) ![<graphic>](ch6_0.gif) 7.25`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(sqrt *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the principal square root of `*num*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: Implementations are encouraged, but not required, to return exact results for
    exact inputs to `sqrt` whenever feasible.
  prefs: []
  type: TYPE_NORMAL
- en: '`(sqrt 16) ![<graphic>](ch6_0.gif) 4'
  prefs: []
  type: TYPE_NORMAL
- en: (sqrt 1/4) ![<graphic>](ch6_0.gif) 1/2
  prefs: []
  type: TYPE_NORMAL
- en: (sqrt 4.84) ![<graphic>](ch6_0.gif) 2.2
  prefs: []
  type: TYPE_NORMAL
- en: (sqrt -4.84) ![<graphic>](ch6_0.gif) 0.0+2.2i
  prefs: []
  type: TYPE_NORMAL
- en: (sqrt 3+4i) ![<graphic>](ch6_0.gif) 2+1i
  prefs: []
  type: TYPE_NORMAL
- en: (sqrt -3.0-4.0i) ![<graphic>](ch6_0.gif) 1.0-2.0i`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(exact-integer-sqrt *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: This procedure returns two nonnegative exact integers *s* and *r* where *n*
    = *s*² + *r* and *n* < (*s* + 1)².
  prefs: []
  type: TYPE_NORMAL
- en: '`(exact-integer-sqrt 0) ![<graphic>](ch6_0.gif) 0'
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) 0'
  prefs: []
  type: TYPE_NORMAL
- en: (exact-integer-sqrt 9) ![<graphic>](ch6_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch6_0.gif) 0'
  prefs: []
  type: TYPE_NORMAL
- en: (exact-integer-sqrt 19) ![<graphic>](ch6_0.gif) 4
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch6_0.gif) 3`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(exp *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** *e* to the `*num*` power'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(exp 0.0) ![<graphic>](ch6_0.gif) 1.0'
  prefs: []
  type: TYPE_NORMAL
- en: (exp 1.0) ![<graphic>](ch6_0.gif) 2.7182818284590455
  prefs: []
  type: TYPE_NORMAL
- en: (exp -.5) ![<graphic>](ch6_0.gif) 0.6065306597126334`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(log *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the natural logarithm of `*num*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(log *num[1]* *num[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the base-`*num[2]*` logarithm of `*num[1]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(log 1.0) ![<graphic>](ch6_0.gif) 0.0'
  prefs: []
  type: TYPE_NORMAL
- en: (log (exp 1.0)) ![<graphic>](ch6_0.gif) 1.0
  prefs: []
  type: TYPE_NORMAL
- en: (/ (log 100) (log 10)) ![<graphic>](ch6_0.gif) 2.0
  prefs: []
  type: TYPE_NORMAL
- en: (log (make-polar (exp 2.0) 1.0)) ![<graphic>](ch6_0.gif) 2.0+1.0i
  prefs: []
  type: TYPE_NORMAL
- en: (log 100.0 10.0) ![<graphic>](ch6_0.gif) 2.0
  prefs: []
  type: TYPE_NORMAL
- en: (log .125 2.0) ![<graphic>](ch6_0.gif) -3.0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(sin *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(cos *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(tan *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the sine, cosine, or tangent of `*num*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The argument is specified in radians.
  prefs: []
  type: TYPE_NORMAL
- en: '`(sin 0.0) ![<graphic>](ch6_0.gif) 0.0'
  prefs: []
  type: TYPE_NORMAL
- en: (cos 0.0) ![<graphic>](ch6_0.gif) 1.0
  prefs: []
  type: TYPE_NORMAL
- en: (tan 0.0) ![<graphic>](ch6_0.gif) 0.0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(asin *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(acos *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the arc sine or the arc cosine of `*num*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The result is in radians. The arc sine and arc cosine of a complex number *z*
    are defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch6_17.gif)'
  prefs: []
  type: TYPE_IMG
- en: '![<graphic>](ch6_18.gif)'
  prefs: []
  type: TYPE_IMG
- en: '`(define pi (* (asin 1) 2))'
  prefs: []
  type: TYPE_NORMAL
- en: (= (* (acos 0) 2) pi) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(atan *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(atan *real[1]* *real[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: When passed a single complex argument `*num*` (the first form), `atan` returns
    the arc tangent of `*num*`. The arc tangent of a complex number *z* is defined
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch6_19.gif)'
  prefs: []
  type: TYPE_IMG
- en: When passed two real arguments (the second form), `atan` is equivalent to `(lambda (y x) (angle (make-rectangular x y)))`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define pi (* (atan 1) 4))'
  prefs: []
  type: TYPE_NORMAL
- en: (= (* (atan 1.0 0.0) 2) pi) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-not *exint*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the bitwise not of `*exint*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-and *exint* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the bitwise and of `*exint* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-ior *exint* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the bitwise inclusive or of `*exint* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-xor *exint* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the bitwise exclusive or of `*exint* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The inputs are treated as if represented in two's complement, even if they are
    not represented that way internally.
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-not 0) ![<graphic>](ch6_0.gif) -1'
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-not 3) ![<graphic>](ch6_0.gif) -4
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-and #b01101 #b00111) ![<graphic>](ch6_0.gif) #b00101
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-ior #b01101 #b00111) ![<graphic>](ch6_0.gif) #b01111
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-xor #b01101 #b00111) ![<graphic>](ch6_0.gif) #b01010`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-if *exint[1]* *exint[2]* *exint[3]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the bitwise "if" of its arguments'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The inputs are treated as if represented in two's complement, even if they are
    not represented that way internally.
  prefs: []
  type: TYPE_NORMAL
- en: For each bit set in `*exint[1]*`, the corresponding bit of the result is taken
    from `*exint[2]*`, and for each bit not set in `*exint[1]*`, the corresponding
    bit of the result is taken from `*x[3]*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-if #b101010 #b111000 #b001100) ![<graphic>](ch6_0.gif) #b101100`'
  prefs: []
  type: TYPE_NORMAL
- en: '`bitwise-if` might be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define bitwise-if'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (exint1 exint2 exint3)
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-ior
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-and exint1 exint2)
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-and (bitwise-not exint1) exint3))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-bit-count *exint*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: For nonnegative inputs, `bitwise-bit-count` returns the number of bits set in
    the two's complement representation of `*exint*`. For negative inputs, it returns
    a negative number whose magnitude is one greater than the number of bits not set
    in the two's complement representation of `*exint*`, which is equivalent to `(bitwise-not (bitwise-bit-count (bitwise-not *exint*)))`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-bit-count #b00000) ![<graphic>](ch6_0.gif) 0'
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-count #b00001) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-count #b00100) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-count #b10101) ![<graphic>](ch6_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-count -1) ![<graphic>](ch6_0.gif) -1
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-count -2) ![<graphic>](ch6_0.gif) -2
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-count -4) ![<graphic>](ch6_0.gif) -3`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-length *exint*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: This procedure returns the number of bits of the smallest two's complement representation
    of `*exint*`, not including the sign bit for negative numbers. For 0 `bitwise-length`
    returns 0.
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-length #b00000) ![<graphic>](ch6_0.gif) 0'
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-length #b00001) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-length #b00100) ![<graphic>](ch6_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-length #b00110) ![<graphic>](ch6_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-length -1) ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-length -6) ![<graphic>](ch6_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-length -9) ![<graphic>](ch6_0.gif) 4`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-first-bit-set *exint*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the index of the least significant bit set in `*exint*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The input is treated as if represented in two's complement, even if it is not
    represented that way internally.
  prefs: []
  type: TYPE_NORMAL
- en: If `*exint*` is 0, `bitwise-first-bit-set` returns -1.
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-first-bit-set #b00000) ![<graphic>](ch6_0.gif) -1'
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-first-bit-set #b00001) ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-first-bit-set #b01100) ![<graphic>](ch6_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-first-bit-set -1) ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-first-bit-set -2) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-first-bit-set -3) ![<graphic>](ch6_0.gif) 0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-bit-set? *exint[1]* *exint[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if bit `*exint[2]*` of `*exint[1]*` is set, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*exint[2]*` is taken as a zero-based index for the bits in the two''s complement
    representation of `*exint[1]*`. The two''s complement representation of a nonnegative
    number conceptually extends to the left (toward more significant bits) with an
    infinite number of zero bits, and the two''s complement representation of a negative
    number conceptually extends to the left with an infinite number of one bits. Thus,
    exact integers can be used to represent arbitrarily large sets, where 0 is the
    empty set, -1 is the universe, and `bitwise-bit-set?` is used to test for membership.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-bit-set? #b01011 0) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-set? #b01011 2) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-set? -1 0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-set? -1 20) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-set? -3 1) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-set? 0 5000) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-set? -1 5000) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-copy-bit *exint[1]* *exint[2]* *exint[3]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*exint[1]*` with bit `*exint[2]*` replaced by `*exint[3]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*exint[2]*` is taken as a zero-based index for the bits in the two''s complement
    representation of `*exint[1]*`. `*exint[3]*` must be 0 or 1. This procedure effectively
    clears or sets the specified bit depending on the value of `*exint[3]*`. `*exint[1]*`
    is treated as if represented in two''s complement, even if it is not represented
    that way internally.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-copy-bit #b01110 0 1) ![<graphic>](ch6_0.gif) #b01111'
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-copy-bit #b01110 2 0) ![<graphic>](ch6_0.gif) #b01010`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-bit-field *exint[1]* *exint[2]* *exint[3]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*exint[2]*` and `*exint[3]*` must be nonnegative, and `*exint[2]*` must not
    be greater than `*exint[3]*`. This procedure returns the number represented by
    extracting from `*exint[1]*` the sequence of bits from `*exint[2]*` (inclusive)
    to `*exint[3]*` (exclusive). `*exint[1]*` is treated as if represented in two''s
    complement, even if it is not represented that way internally.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-bit-field #b10110 0 3) ![<graphic>](ch6_0.gif) #b00110'
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-field #b10110 1 3) ![<graphic>](ch6_0.gif) #b00011
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-field #b10110 2 3) ![<graphic>](ch6_0.gif) #b00001
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-field #b10110 3 3) ![<graphic>](ch6_0.gif) #b00000`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-copy-bit-field *exint[1]* *exint[2]* *exint[3]* *exint[4]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*exint[2]*` and `*exint[3]*` must be nonnegative, and `*exint[2]*` must not
    be greater than `*exint[3]*`. This procedure returns `*exint[1]*` with the `*n*`
    bits from `*exint[2]*` (inclusive) to `*exint[3]*` (exclusive) replaced by the
    low-order `*n*` bits of `*exint[4]*`. `*exint[1]*` and `*exint[4]*` are treated
    as if represented in two''s complement, even if they are not represented that
    way internally.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-copy-bit-field #b10000 0 3 #b10101) ![<graphic>](ch6_0.gif) #b10101'
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-copy-bit-field #b10000 1 3 #b10101) ![<graphic>](ch6_0.gif) #b10010
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-copy-bit-field #b10000 2 3 #b10101) ![<graphic>](ch6_0.gif) #b10100
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-copy-bit-field #b10000 3 3 #b10101) ![<graphic>](ch6_0.gif) #b10000`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-arithmetic-shift-right *exint[1]* *exint[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*exint[1]*` arithmetically shifted right by `*exint[2]*` bits'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-arithmetic-shift-left *exint[1]* *exint[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*exint[1]*` shifted left by `*exint[2]*` bits'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*exint[2]*` must be nonnegative. `*exint[1]*` is treated as if represented
    in two''s complement, even if it is not represented that way internally.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-arithmetic-shift-right #b10000 3) ![<graphic>](ch6_0.gif) #b00010'
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift-right -1 1) ![<graphic>](ch6_0.gif) -1
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift-right -64 3) ![<graphic>](ch6_0.gif) -8
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift-left #b00010 2) ![<graphic>](ch6_0.gif) #b01000
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift-left -1 2) ![<graphic>](ch6_0.gif) -4`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-arithmetic-shift *exint[1]* *exint[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*exint[2]*` is negative, `bitwise-arithmetic-shift` returns the result of
    arithmetically shifting `*exint[1]*` right by `*exint[2]*` bits. Otherwise, `bitwise-arithmetic-shift`
    returns the result of shifting `*exint[1]*` left by `*exint[2]*` bits. `*exint[1]*`
    is treated as if represented in two's complement, even if it is not represented
    that way internally.
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-arithmetic-shift #b10000 -3) ![<graphic>](ch6_0.gif) #b00010'
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift -1 -1) ![<graphic>](ch6_0.gif) -1
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift -64 -3) ![<graphic>](ch6_0.gif) -8
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift #b00010 2) ![<graphic>](ch6_0.gif) #b01000
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift -1 2) ![<graphic>](ch6_0.gif) -4`
  prefs: []
  type: TYPE_NORMAL
- en: Thus, `bitwise-arithmetic-shift` behaves as if defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define bitwise-arithmetic-shift'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (exint1 exint2)
  prefs: []
  type: TYPE_NORMAL
- en: (if (< exint2 0)
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift-right exint1 (- exint2))
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift-left exint1 exint2))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-rotate-bit-field *exint[1]* *exint[2]* *exint[3]* *exint[4]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*exint[2]*`, `*exint[3]*`, and `*exint[4]*` must be nonnegative, and `*exint[2]*`
    must not be greater than `*exint[3]*`. This procedure returns the result of shifting
    the bits of `*exint[1]*` from bit `*exint[2]*` (inclusive) through bit `*exint[3]*`
    (exclusive) left by `(mod *exint[4]* (- *exint[3]* *exint[2]*))` bits, with the
    bits shifted out of the range inserted at the bottom end of the range. `*exint[1]*`
    is treated as if represented in two''s complement, even if it is not represented
    that way internally.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-rotate-bit-field #b00011010 0 5 3) ![<graphic>](ch6_0.gif) #b00010110'
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-rotate-bit-field #b01101011 2 7 3) ![<graphic>](ch6_0.gif) #b01011011`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-reverse-bit-field *exint[1]* *exint[2]* *exint[3]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*exint[2]*` and `*exint[3]*` must be nonnegative, and `*exint[2]*` must not
    be greater than `*exint[3]*`. This procedure returns the result of reversing the
    bits of `*exint[1]*` from bit `*exint[2]*` (inclusive) through bit `*exint[3]*`
    (exclusive). `*exint[1]*` is treated as if represented in two''s complement, even
    if it is not represented that way internally.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-reverse-bit-field #b00011010 0 5) ![<graphic>](ch6_0.gif) #b00001011'
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-reverse-bit-field #b01101011 2 7) ![<graphic>](ch6_0.gif) #b00101111`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string->number *string*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string->number *string* *radix*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the number represented by `*string*`, or `#f`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*string*` is a valid representation of a number, that number is returned,
    otherwise `#f` is returned. The number is interpreted in radix `*radix*`, which
    must be an exact integer in the set {2,8,10,16}. If not specified, `*radix*` defaults
    to 10. Any radix specifier within `*string*`, e.g., `#x`, overrides the `*radix*`
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: '`(string->number "0") ![<graphic>](ch6_0.gif) 0'
  prefs: []
  type: TYPE_NORMAL
- en: (string->number "3.4e3") ![<graphic>](ch6_0.gif) 3400.0
  prefs: []
  type: TYPE_NORMAL
- en: (string->number "#x#e-2e2") ![<graphic>](ch6_0.gif) -738
  prefs: []
  type: TYPE_NORMAL
- en: (string->number "#e-2e2" 16) ![<graphic>](ch6_0.gif) -738
  prefs: []
  type: TYPE_NORMAL
- en: (string->number "#i15/16") ![<graphic>](ch6_0.gif) 0.9375
  prefs: []
  type: TYPE_NORMAL
- en: (string->number "10" 16) ![<graphic>](ch6_0.gif) 16`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(number->string *num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(number->string *num* *radix*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(number->string *num* *radix* *precision*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** an external representation of `*num*` as a string'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The num is expressed in radix `*radix*`, which must be an exact integer in the
    set {2,8,10,16}. If not specified, `*radix*` defaults to 10. In any case, no radix
    specifier appears in the resulting string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The external representation is such that, when converted back into a number
    using `string->number`, the resulting numeric value is equivalent to `*num*`.
    That is, for all inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(eqv? (string->number'
  prefs: []
  type: TYPE_NORMAL
- en: (number->string *num* *radix*)
  prefs: []
  type: TYPE_NORMAL
- en: '*radix*)'
  prefs: []
  type: TYPE_NORMAL
- en: '*num*)`'
  prefs: []
  type: TYPE_NORMAL
- en: returns `#t`. An exception with condition type `&implementation-restriction`
    is raised if this is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: If `*precision*` is provided, it must be an exact positive integer, `*num*`
    must be inexact, and `*radix*` must be 10. In this case, the real part and, if
    present, the imaginary part of the number are each printed with an explicit mantissa
    width `*m*`, where `*m*` is the least possible value greater than or equal to
    `*precision*` that makes the expression above true.
  prefs: []
  type: TYPE_NORMAL
- en: If `*radix*` is 10, inexact values of `*num*` are expressed using the fewest
    number of significant digits possible [[5](bibliography.html#g223)] without violating
    the above restriction.
  prefs: []
  type: TYPE_NORMAL
- en: '`(number->string 3.4) ![<graphic>](ch6_0.gif) "3.4"'
  prefs: []
  type: TYPE_NORMAL
- en: (number->string 1e2) ![<graphic>](ch6_0.gif) "100.0"
  prefs: []
  type: TYPE_NORMAL
- en: (number->string 1e-23) ![<graphic>](ch6_0.gif) "1e-23"
  prefs: []
  type: TYPE_NORMAL
- en: (number->string -7/2) ![<graphic>](ch6_0.gif) "-7/2"
  prefs: []
  type: TYPE_NORMAL
- en: (number->string 220/9 16) ![<graphic>](ch6_0.gif) "DC/9"`
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.5\. Fixnums
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Fixnums* represent exact integers in the fixnum range, which is required to
    be a closed range [-2^(*w*-1),2^(*w*-2) - 1], where *w* (the *fixnum width*) is
    at least 24. The implementation-specific value of *w* may be determined via the
    procedure `fixnum-width`, and the endpoints of the range may be determined via
    the procedures `least-fixnum` and `greatest-fixnum`.'
  prefs: []
  type: TYPE_NORMAL
- en: The names of arithmetic procedures that operate only on fixnums begin with the
    prefix "`fx`" to set them apart from their generic counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Procedure arguments required to be fixnums are named `*fx*`, possibly with a
    suffix, e.g., `*fx[2]*`.
  prefs: []
  type: TYPE_NORMAL
- en: Unless otherwise specified, the numeric values of fixnum-specific procedures
    are fixnums. If the value of a fixnum operation should be a fixnum, but the mathematical
    result would be outside the fixnum range, an exception with condition type `&implementation-restriction`
    is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Bit and shift operations on fixnums assume that fixnums are represented in two's
    complement, even if they are not represented that way internally.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fixnum? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a fixnum, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fixnum? 0) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (fixnum? -1) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (fixnum? (- (expt 2 23))) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (fixnum? (- (expt 2 23) 1)) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(least-fixnum)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the least (most negative) fixnum supported by the implementation'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(greatest-fixnum)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the greatest (most positive) fixnum supported by the implementation'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fixnum? (- (least-fixnum) 1)) ![<graphic>](ch6_0.gif) #f'
  prefs: []
  type: TYPE_NORMAL
- en: (fixnum? (least-fixnum)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (fixnum? (greatest-fixnum)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (fixnum? (+ (greatest-fixnum) 1)) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fixnum-width)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the implementation-dependent *fixnum width*'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: As described in the lead-in to this section, the fixnum width determines the
    size of the fixnum range and must be at least 24.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define w (fixnum-width))'
  prefs: []
  type: TYPE_NORMAL
- en: (= (least-fixnum) (- (expt 2 (- w 1)))) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (= (greatest-fixnum) (- (expt 2 (- w 1)) 1)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (>= w 24) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx=? *fx[1]* *fx[2]* *fx[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx<? *fx[1]* *fx[2]* *fx[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx>? *fx[1]* *fx[2]* *fx[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx<=? *fx[1]* *fx[2]* *fx[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx>=? *fx[1]* *fx[2]* *fx[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the relation holds, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The predicate `fx=?` returns `#t` if its arguments are equal. The predicate
    `fx<?` returns `#t` if its arguments are monotonically increasing, i.e., each
    argument is greater than the preceding ones, while `fx>?` returns `#t` if its
    arguments are monotonically decreasing. The predicate `fx<=?` returns `#t` if
    its arguments are monotonically nondecreasing, i.e., each argument is not less
    than the preceding ones, while `fx>=?` returns `#t` if its arguments are monotonically
    nonincreasing.
  prefs: []
  type: TYPE_NORMAL
- en: '`(fx=? 0 0) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (fx=? -1 1) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fx<? (least-fixnum) 0 (greatest-fixnum)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x 3]) (fx<=? 0 x 9)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (fx>? 5 4 3 2 1) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (fx<=? 1 3 2) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fx>=? 0 0 (least-fixnum)) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxzero? *fx*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fx*` is zero, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxpositive? *fx*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fx*` is greater than zero, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxnegative? *fx*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fx*` is less than zero, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`fxzero?` is equivalent to `(lambda (x) (fx=? x 0))`, `fxpositive?` is equivalent
    to `(lambda (x) (fx>? x 0))`, and `fxnegative?` to `(lambda (x) (fx<? x 0))`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxzero? 0) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (fxzero? 1) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fxpositive? 128) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (fxpositive? 0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fxpositive? -1) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fxnegative? -65) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (fxnegative? 0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fxnegative? 1) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxeven? *fx*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fx*` is even, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxodd? *fx*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fx*` is odd, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxeven? 0) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (fxeven? 1) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fxeven? -1) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fxeven? -10) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (fxodd? 0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fxodd? 1) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (fxodd? -1) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (fxodd? -10) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxmin *fx[1]* *fx[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the minimum of `*fx[1]*` `*fx[2]*` ...'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxmax *fx[1]* *fx[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the maximum of `*fx[1]*` `*fx[2]*` ...'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxmin 4 -7 2 0 -6) ![<graphic>](ch6_0.gif) -7'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls '(7 3 5 2 9 8)])
  prefs: []
  type: TYPE_NORMAL
- en: (apply fxmin ls)) ![<graphic>](ch6_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (fxmax 4 -7 2 0 -6) ![<graphic>](ch6_0.gif) 4
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls '(7 3 5 2 9 8)])
  prefs: []
  type: TYPE_NORMAL
- en: (apply fxmax ls)) ![<graphic>](ch6_0.gif) 9`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx+ *fx[1]* *fx[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the sum of `*fx[1]*` and `*fx[2]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fx+ -3 4) ![<graphic>](ch6_0.gif) 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx- *fx*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the additive inverse of `*fx*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx- *fx[1]* *fx[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the difference between `*fx[1]*` and `*fx[2]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fx- 3) ![<graphic>](ch6_0.gif) -3'
  prefs: []
  type: TYPE_NORMAL
- en: (fx- -3 4) ![<graphic>](ch6_0.gif) -7`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx* *fx[1]* *fx[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the product of `*fx[1]*` and `*fx[2]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fx* -3 4) ![<graphic>](ch6_0.gif) -12`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxdiv *fx[1]* *fx[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxmod *fx[1]* *fx[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxdiv-and-mod *fx[1]* *fx[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*` must not be zero. These are fixnum-specific versions of the generic
    `div`, `mod`, and `div-and-mod`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxdiv 17 3) ![<graphic>](ch6_0.gif) 5'
  prefs: []
  type: TYPE_NORMAL
- en: (fxmod 17 3) ![<graphic>](ch6_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (fxdiv -17 3) ![<graphic>](ch6_0.gif) -6
  prefs: []
  type: TYPE_NORMAL
- en: (fxmod -17 3) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (fxdiv 17 -3) ![<graphic>](ch6_0.gif) -5
  prefs: []
  type: TYPE_NORMAL
- en: (fxmod 17 -3) ![<graphic>](ch6_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (fxdiv -17 -3) ![<graphic>](ch6_0.gif) 6
  prefs: []
  type: TYPE_NORMAL
- en: (fxmod -17 -3) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (fxdiv-and-mod 17 3) ![<graphic>](ch6_0.gif) 5
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) 2`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxdiv0 *fx[1]* *fx[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxmod0 *fx[1]* *fx[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxdiv0-and-mod0 *fx[1]* *fx[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*` must not be zero. These are fixnum-specific versions of the generic
    `div0`, `mod0`, and `div0-and-mod0`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxdiv0 17 3) ![<graphic>](ch6_0.gif) 6'
  prefs: []
  type: TYPE_NORMAL
- en: (fxmod0 17 3) ![<graphic>](ch6_0.gif) -1
  prefs: []
  type: TYPE_NORMAL
- en: (fxdiv0 -17 3) ![<graphic>](ch6_0.gif) -6
  prefs: []
  type: TYPE_NORMAL
- en: (fxmod0 -17 3) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (fxdiv0 17 -3) ![<graphic>](ch6_0.gif) -6
  prefs: []
  type: TYPE_NORMAL
- en: (fxmod0 17 -3) ![<graphic>](ch6_0.gif) -1
  prefs: []
  type: TYPE_NORMAL
- en: (fxdiv0 -17 -3) ![<graphic>](ch6_0.gif) 6
  prefs: []
  type: TYPE_NORMAL
- en: (fxmod0 -17 -3) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (fxdiv0-and-mod0 17 3) ![<graphic>](ch6_0.gif) 6
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) -1`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx+/carry *fx[1]* *fx[2]* *fx[3]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx-/carry *fx[1]* *fx[2]* *fx[3]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx*/carry *fx[1]* *fx[2]* *fx[3]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: When an ordinary fixnum addition, subtraction, or multiplication operation overflows,
    an exception is raised. These alternative procedures instead return a carry and
    also allow the carry to be propagated to the next operation. They can be used
    to implement portable code for multiple-precision arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: 'These procedures return the two fixnum values of the following computations.
    For `fx+/carry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let* ([s (+ *fx[1]* *fx[2]* *fx[3]*)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[s0 (mod0 s (expt 2 (fixnum-width)))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[s1 (div0 s (expt 2 (fixnum-width)))])'
  prefs: []
  type: TYPE_NORMAL
- en: (values s0 s1))`
  prefs: []
  type: TYPE_NORMAL
- en: 'for `fx-/carry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let* ([d (- *fx[1]* *fx[2]* *fx[3]*)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[d0 (mod0 d (expt 2 (fixnum-width)))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[d1 (div0 d (expt 2 (fixnum-width)))])'
  prefs: []
  type: TYPE_NORMAL
- en: (values d0 d1))`
  prefs: []
  type: TYPE_NORMAL
- en: 'and for `fx*/carry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let* ([s (+ (* *fx[1]* *fx[2]*) *fx[3]*)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[s0 (mod0 s (expt 2 (fixnum-width)))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[s1 (div0 s (expt 2 (fixnum-width)))])'
  prefs: []
  type: TYPE_NORMAL
- en: (values s0 s1))`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxnot *fx*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the bitwise not of `*fx*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxand *fx* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the bitwise and of `*fx* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxior *fx* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the bitwise inclusive or of `*fx* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxxor *fx* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the bitwise exclusive or of `*fx* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxnot 0) ![<graphic>](ch6_0.gif) -1'
  prefs: []
  type: TYPE_NORMAL
- en: (fxnot 3) ![<graphic>](ch6_0.gif) -4
  prefs: []
  type: TYPE_NORMAL
- en: (fxand #b01101 #b00111) ![<graphic>](ch6_0.gif) #b00101
  prefs: []
  type: TYPE_NORMAL
- en: (fxior #b01101 #b00111) ![<graphic>](ch6_0.gif) #b01111
  prefs: []
  type: TYPE_NORMAL
- en: (fxxor #b01101 #b00111) ![<graphic>](ch6_0.gif) #b01010`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxif *fx[1]* *fx[2]* *fx[3]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the bitwise "if" of its arguments'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: For each bit set in `*fx[1]*`, the corresponding bit of the result is taken
    from `*fx[2]*`, and for each bit not set in `*fx[1]*`, the corresponding bit of
    the result is taken from `*x[3]*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxif #b101010 #b111000 #b001100) ![<graphic>](ch6_0.gif) #b101100`'
  prefs: []
  type: TYPE_NORMAL
- en: '`fxif` might be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define fxif'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (fx1 fx2 fx3)
  prefs: []
  type: TYPE_NORMAL
- en: (fxior (fxand fx1 fx2)
  prefs: []
  type: TYPE_NORMAL
- en: (fxand (fxnot fx1) fx3))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxbit-count *fx*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: For nonnegative inputs, `fxbit-count` returns the number of bits set in the
    two's complement representation of `*fx*`. For negative inputs, it returns a negative
    number whose magnitude is one greater than the number of bits not set in `*fx*`,
    which is equivalent to `(fxnot (fxbit-count (fxnot *fx*)))`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxbit-count #b00000) ![<graphic>](ch6_0.gif) 0'
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-count #b00001) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-count #b00100) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-count #b10101) ![<graphic>](ch6_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-count -1) ![<graphic>](ch6_0.gif) -1
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-count -2) ![<graphic>](ch6_0.gif) -2
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-count -4) ![<graphic>](ch6_0.gif) -3`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxlength *fx*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: This procedure returns the number of bits of the smallest two's complement representation
    of `*fx*`, not including the sign bit for negative numbers. For 0 `fxlength` returns
    0.
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxlength #b00000) ![<graphic>](ch6_0.gif) 0'
  prefs: []
  type: TYPE_NORMAL
- en: (fxlength #b00001) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (fxlength #b00100) ![<graphic>](ch6_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (fxlength #b00110) ![<graphic>](ch6_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (fxlength -1) ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (fxlength -6) ![<graphic>](ch6_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (fxlength -9) ![<graphic>](ch6_0.gif) 4`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxfirst-bit-set *fx*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the index of the least significant bit set in `*fx*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*fx*` is 0, `fxfirst-bit-set` returns -1.
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxfirst-bit-set #b00000) ![<graphic>](ch6_0.gif) -1'
  prefs: []
  type: TYPE_NORMAL
- en: (fxfirst-bit-set #b00001) ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (fxfirst-bit-set #b01100) ![<graphic>](ch6_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (fxfirst-bit-set -1) ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (fxfirst-bit-set -2) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (fxfirst-bit-set -3) ![<graphic>](ch6_0.gif) 0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxbit-set? *fx[1]* *fx[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if bit `*fx[2]*` of `*fx[1]*` is set, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*` must be nonnegative. It is taken as a zero-based index for the bits
    in the two''s complement representation of `*fx[1]*`, with the sign bit virtually
    replicated an infinite number of positions to the left.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxbit-set? #b01011 0) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-set? #b01011 2) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-set? -1 0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-set? -1 20) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-set? -3 1) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-set? 0 (- (fixnum-width) 1)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-set? -1 (- (fixnum-width) 1)) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxcopy-bit *fx[1]* *fx[2]* *fx[3]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*fx[1]*` with bit `*fx[2]*` replaced by `*fx[3]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*` must be nonnegative and less than the value of `(- (fixnum-width) 1)`.
    `*fx[3]*` must be 0 or 1. This procedure effectively clears or sets the specified
    bit depending on the value of `*fx[3]*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxcopy-bit #b01110 0 1) ![<graphic>](ch6_0.gif) #b01111'
  prefs: []
  type: TYPE_NORMAL
- en: (fxcopy-bit #b01110 2 0) ![<graphic>](ch6_0.gif) #b01010`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxbit-field *fx[1]* *fx[2]* *fx[3]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*` and `*fx[3]*` must be nonnegative and less than the value of `(fixnum-width)`,
    and `*fx[2]*` must not be greater than `*fx[3]*`. This procedure returns the number
    represented by extracting from `*fx[1]*` the sequence of bits from `*fx[2]*` (inclusive)
    to `*fx[3]*` (exclusive).'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxbit-field #b10110 0 3) ![<graphic>](ch6_0.gif) #b00110'
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-field #b10110 1 3) ![<graphic>](ch6_0.gif) #b00011
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-field #b10110 2 3) ![<graphic>](ch6_0.gif) #b00001
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-field #b10110 3 3) ![<graphic>](ch6_0.gif) #b00000`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxcopy-bit-field *fx[1]* *fx[2]* *fx[3]* *fx[4]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*` and `*fx[3]*` must be nonnegative and less than the value of `(fixnum-width)`,
    and `*fx[2]*` must not be greater than `*fx[3]*`. This procedure returns `*fx[1]*`
    with `*n*` bits from `*fx[2]*` (inclusive) to `*fx[3]*` (exclusive) replaced by
    the low-order `*n*` bits of `*x[4]*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxcopy-bit-field #b10000 0 3 #b10101) ![<graphic>](ch6_0.gif) #b10101'
  prefs: []
  type: TYPE_NORMAL
- en: (fxcopy-bit-field #b10000 1 3 #b10101) ![<graphic>](ch6_0.gif) #b10010
  prefs: []
  type: TYPE_NORMAL
- en: (fxcopy-bit-field #b10000 2 3 #b10101) ![<graphic>](ch6_0.gif) #b10100
  prefs: []
  type: TYPE_NORMAL
- en: (fxcopy-bit-field #b10000 3 3 #b10101) ![<graphic>](ch6_0.gif) #b10000`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxarithmetic-shift-right *fx[1]* *fx[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*fx[1]*` arithmetically shifted right by `*fx[2]*` bits'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxarithmetic-shift-left *fx[1]* *fx[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*fx[1]*` shifted left by `*fx[2]*` bits'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*` must be nonnegative and less than the value of `(fixnum-width)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxarithmetic-shift-right #b10000 3) ![<graphic>](ch6_0.gif) #b00010'
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift-right -1 1) ![<graphic>](ch6_0.gif) -1
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift-right -64 3) ![<graphic>](ch6_0.gif) -8
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift-left #b00010 2) ![<graphic>](ch6_0.gif) #b01000
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift-left -1 2) ![<graphic>](ch6_0.gif) -4`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxarithmetic-shift *fx[1]* *fx[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The absolute value of `*fx[2]*` must be less than the value of `(fixnum-width)`.
    If `*fx[2]*` is negative, `fxarithmetic-shift` returns the result of arithmetically
    shifting `*fx[1]*` right by `*fx[2]*` bits. Otherwise, `fxarithmetic-shift` returns
    the result of shifting `*fx[1]*` left by `*fx[2]*` bits.
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxarithmetic-shift #b10000 -3) ![<graphic>](ch6_0.gif) #b00010'
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift -1 -1) ![<graphic>](ch6_0.gif) -1
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift -64 -3) ![<graphic>](ch6_0.gif) -8
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift #b00010 2) ![<graphic>](ch6_0.gif) #b01000
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift -1 2) ![<graphic>](ch6_0.gif) -4`
  prefs: []
  type: TYPE_NORMAL
- en: Thus, `fxarithmetic-shift` behaves as if defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define fxarithmetic-shift'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (fx1 fx2)
  prefs: []
  type: TYPE_NORMAL
- en: (if (fx<? fx2 0)
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift-right fx1 (fx- fx2))
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift-left fx1 fx2))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxrotate-bit-field *fx[1]* *fx[2]* *fx[3]* *fx[4]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*`, `*fx[3]*`, and `*fx[4]*` must be nonnegative and less than the value
    of `(fixnum-width)`, `*fx[2]*` must not be greater than `*fx[3]*`, and `*fx[4]*`
    must not be greater than the difference between `*fx[3]*` and `*fx[2]*`.'
  prefs: []
  type: TYPE_NORMAL
- en: This procedure returns the result of shifting the bits of `*fx[1]*` from bit
    `*fx[2]*` (inclusive) through bit `*fx[3]*` (exclusive) left by `*fx[4]*` bits,
    with the bits shifted out of the range inserted at the bottom end of the range.
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxrotate-bit-field #b00011010 0 5 3) ![<graphic>](ch6_0.gif) #b00010110'
  prefs: []
  type: TYPE_NORMAL
- en: (fxrotate-bit-field #b01101011 2 7 3) ![<graphic>](ch6_0.gif) #b01011011`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxreverse-bit-field *fx[1]* *fx[2]* *fx[3]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*` and `*fx[3]*` must be nonnegative and less than the value of `(fixnum-width)`,
    and `*fx[2]*` must not be greater than `*fx[3]*`. This procedure returns the result
    of reversing the bits of `*fx[1]*` from bit `*fx[2]*` (inclusive) through bit
    `*fx[3]*` (exclusive).'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxreverse-bit-field #b00011010 0 5) ![<graphic>](ch6_0.gif) #b00001011'
  prefs: []
  type: TYPE_NORMAL
- en: (fxreverse-bit-field #b01101011 2 7) ![<graphic>](ch6_0.gif) #b00101111`
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.6\. Flonums
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Flonums* represent inexact real numbers. Implementations are required to represent
    as a flonum any inexact real number whose lexical syntax contains no vertical
    bar and no exponent marker other than `e`, but are not required to represent any
    other inexact real number as a flonum.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementations typically use the IEEE double-precision floating-point representation
    for flonums, but implementations are not required to do so or even to use a floating-point
    representation of any sort, despite the name "flonum."
  prefs: []
  type: TYPE_NORMAL
- en: This section describes operations on flonums. Flonum-specific procedure names
    begin with the prefix "`fl`" to set them apart from their generic counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Procedure arguments required to be flonums are named `*fl*`, possibly with suffix,
    e.g., `*fl[2]*`. Unless otherwise specified, the numeric values of flonum-specific
    procedures are flonums.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flonum? *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a flonum, otherwise `#f`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(flonum? 0) ![<graphic>](ch6_0.gif) #f'
  prefs: []
  type: TYPE_NORMAL
- en: (flonum? 3/4) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flonum? 3.5) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (flonum? .02) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (flonum? 1e10) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (flonum? 3.0+0.0i) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl=? *fl[1]* *fl[2]* *fl[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl<? *fl[1]* *fl[2]* *fl[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl>? *fl[1]* *fl[2]* *fl[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl<=? *fl[1]* *fl[2]* *fl[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl>=? *fl[1]* *fl[2]* *fl[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the relation holds, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The predicate `fl=?` returns `#t` if its arguments are equal. The predicate
    `fl<?` returns `#t` if its arguments are monotonically increasing, i.e., each
    argument is greater than the preceding ones, while `fl>?` returns `#t` if its
    arguments are monotonically decreasing. The predicate `fl<=?` returns `#t` if
    its arguments are monotonically nondecreasing, i.e., each argument is not less
    than the preceding ones, while `fl>=?` returns `#t` if its arguments are monotonically
    nonincreasing. When passed only one argument, each of these predicates returns
    `#t`.
  prefs: []
  type: TYPE_NORMAL
- en: Comparisons involving NaNs always return `#f`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(fl=? 0.0 0.0) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (fl<? -1.0 0.0 1.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (fl>? -1.0 0.0 1.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fl<=? 0.0 3.0 3.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (fl>=? 4.0 3.0 3.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (fl<? 7.0 +inf.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (fl=? +nan.0 0.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fl=? +nan.0 +nan.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fl<? +nan.0 +nan.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fl<=? +nan.0 +inf.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fl>=? +nan.0 +inf.0) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flzero? *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl*` is zero, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flpositive? *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl*` is greater than zero, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flnegative? *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl*` is less than zero, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`flzero?` is equivalent to `(lambda (x) (fl=? x 0.0))`, `flpositive?` is equivalent
    to `(lambda (x) (fl>? x 0.0))`, and `flnegative?` to `(lambda (x) (fl<? x 0.0))`.'
  prefs: []
  type: TYPE_NORMAL
- en: Even if the flonum representation distinguishes -0.0 from +0.0, -0.0 is considered
    both zero and nonnegative.
  prefs: []
  type: TYPE_NORMAL
- en: '`(flzero? 0.0) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (flzero? 1.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flpositive? 128.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (flpositive? 0.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flpositive? -1.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flnegative? -65.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (flnegative? 0.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flnegative? 1.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flzero? -0.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (flnegative? -0.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flnegative? +nan.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flzero? +nan.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flpositive? +nan.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flnegative? +inf.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flnegative? -inf.0) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flinteger? *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl*` is integer, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(flinteger? 0.0) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (flinteger? -17.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (flinteger? +nan.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flinteger? +inf.0) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flfinite? *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl*` is finite, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flinfinite? *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl*` is infinite, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flnan? *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl*` is a NaN, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(flfinite? 3.1415) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (flinfinite? 3.1415) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flnan? 3.1415) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flfinite? +inf.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flinfinite? -inf.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (flnan? -inf.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flfinite? +nan.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flinfinite? +nan.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flnan? +nan.0) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fleven? *fl-int*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl-int*` is even, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flodd? *fl-int*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl-int*` is odd, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*fl-int*` must be an integer-valued flonum.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fleven? 0.0) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (fleven? 1.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fleven? -1.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (fleven? -10.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (flodd? 0.0) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flodd? 1.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (flodd? -1.0) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (flodd? -10.0) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flmin *fl[1]* *fl[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the minimum of `*fl[1]*` `*fl[2]*` ...'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flmax *fl[1]* *fl[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the maximum of `*fl[1]*` `*fl[2]*` ...'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(flmin 4.2 -7.5 2.0 0.0 -6.4) ![<graphic>](ch6_0.gif) -7.5'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])
  prefs: []
  type: TYPE_NORMAL
- en: (apply flmin ls)) ![<graphic>](ch6_0.gif) 2.6
  prefs: []
  type: TYPE_NORMAL
- en: (flmax 4.2 -7.5 2.0 0.0 -6.4) ![<graphic>](ch6_0.gif) 4.2
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])
  prefs: []
  type: TYPE_NORMAL
- en: (apply flmax ls)) ![<graphic>](ch6_0.gif) 8.0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl+ *fl* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the sum of the arguments `*fl* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: When called with no arguments, `fl+` returns `0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(fl+) ![<graphic>](ch6_0.gif) 0.0'
  prefs: []
  type: TYPE_NORMAL
- en: (fl+ 1.0 2.5) ![<graphic>](ch6_0.gif) 3.25
  prefs: []
  type: TYPE_NORMAL
- en: (fl+ 3.0 4.25 5.0) ![<graphic>](ch6_0.gif) 12.25
  prefs: []
  type: TYPE_NORMAL
- en: (apply fl+ '(1.0 2.0 3.0 4.0 5.0)) ![<graphic>](ch6_0.gif) 15.0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl- *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the additive inverse of `*fl*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl- *fl[1]* *fl[2]* *fl[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the difference between `*fl[1]*` and the sum of `*fl[2]* *fl[3]* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: With an IEEE floating-point representation of flonums, the single-argument `fl-`
    is equivalent to
  prefs: []
  type: TYPE_NORMAL
- en: '`(lambda (x) (fl* -1.0 x))`'
  prefs: []
  type: TYPE_NORMAL
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '`(lambda (x) (fl- -0.0 x))`'
  prefs: []
  type: TYPE_NORMAL
- en: but not
  prefs: []
  type: TYPE_NORMAL
- en: '`(lambda (x) (fl- 0.0 x))`'
  prefs: []
  type: TYPE_NORMAL
- en: since the latter returns `0.0` rather than `-0.0` for `0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(fl- 0.0) ![<graphic>](ch6_0.gif) -0.0'
  prefs: []
  type: TYPE_NORMAL
- en: (fl- 3.0) ![<graphic>](ch6_0.gif) -3.0
  prefs: []
  type: TYPE_NORMAL
- en: (fl- 4.0 3.0) ![<graphic>](ch6_0.gif) 1.0
  prefs: []
  type: TYPE_NORMAL
- en: (fl- 4.0 3.0 2.0 1.0) ![<graphic>](ch6_0.gif) -2.0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl* *fl* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the product of the arguments `*fl* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: When called with no arguments, `fl*` returns `1.0`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(fl*) ![<graphic>](ch6_0.gif) 1.0'
  prefs: []
  type: TYPE_NORMAL
- en: (fl* 1.5 2.5) ![<graphic>](ch6_0.gif) 3.75
  prefs: []
  type: TYPE_NORMAL
- en: (fl* 3.0 -4.0 5.0) ![<graphic>](ch6_0.gif) -60.0
  prefs: []
  type: TYPE_NORMAL
- en: (apply fl* '(1.0 -2.0 3.0 -4.0 5.0)) ![<graphic>](ch6_0.gif) 120.0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl/ *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the multiplicative inverse of `*fl*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl/ *fl[1]* *fl[2]* *fl[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the result of dividing `*fl[1]*` by the product of `*fl[2]* *fl[3]* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fl/ -4.0) ![<graphic>](ch6_0.gif) -0.25'
  prefs: []
  type: TYPE_NORMAL
- en: (fl/ 8.0 -2.0) ![<graphic>](ch6_0.gif) -4.0
  prefs: []
  type: TYPE_NORMAL
- en: (fl/ -9.0 2.0) ![<graphic>](ch6_0.gif) -4.5
  prefs: []
  type: TYPE_NORMAL
- en: (fl/ 60.0 5.0 3.0 2.0) ![<graphic>](ch6_0.gif) 2.0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fldiv *fl[1]* *fl[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flmod *fl[1]* *fl[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fldiv-and-mod *fl[1]* *fl[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: These are flonum-specific versions of the generic `div`, `mod`, and `div-and-mod`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(fldiv 17.0 3.0) ![<graphic>](ch6_0.gif) 5.0'
  prefs: []
  type: TYPE_NORMAL
- en: (flmod 17.0 3.0) ![<graphic>](ch6_0.gif) 2.0
  prefs: []
  type: TYPE_NORMAL
- en: (fldiv -17.0 3.0) ![<graphic>](ch6_0.gif) -6.0
  prefs: []
  type: TYPE_NORMAL
- en: (flmod -17.0 3.0) ![<graphic>](ch6_0.gif) 1.0
  prefs: []
  type: TYPE_NORMAL
- en: (fldiv 17.0 -3.0) ![<graphic>](ch6_0.gif) -5.0
  prefs: []
  type: TYPE_NORMAL
- en: (flmod 17.0 -3.0) ![<graphic>](ch6_0.gif) 2.0
  prefs: []
  type: TYPE_NORMAL
- en: (fldiv -17.0 -3.0) ![<graphic>](ch6_0.gif) 6.0
  prefs: []
  type: TYPE_NORMAL
- en: (flmod -17.0 -3.0) ![<graphic>](ch6_0.gif) 1.0
  prefs: []
  type: TYPE_NORMAL
- en: (fldiv-and-mod 17.5 3.75) ![<graphic>](ch6_0.gif) 4.0
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) 2.5`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fldiv0 *fl[1]* *fl[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flmod0 *fl[1]* *fl[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fldiv0-and-mod0 *fl[1]* *fl[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: These are flonum-specific versions of the generic `div0`, `mod0`, and `div0-and-mod0`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(fldiv0 17.0 3.0) ![<graphic>](ch6_0.gif) 6.0'
  prefs: []
  type: TYPE_NORMAL
- en: (flmod0 17.0 3.0) ![<graphic>](ch6_0.gif) -1.0
  prefs: []
  type: TYPE_NORMAL
- en: (fldiv0 -17.0 3.0) ![<graphic>](ch6_0.gif) -6.0
  prefs: []
  type: TYPE_NORMAL
- en: (flmod0 -17.0 3.0) ![<graphic>](ch6_0.gif) 1.0
  prefs: []
  type: TYPE_NORMAL
- en: (fldiv0 17.0 -3.0) ![<graphic>](ch6_0.gif) -6.0
  prefs: []
  type: TYPE_NORMAL
- en: (flmod0 17.0 -3.0) ![<graphic>](ch6_0.gif) -1.0
  prefs: []
  type: TYPE_NORMAL
- en: (fldiv0 -17.0 -3.0) ![<graphic>](ch6_0.gif) 6.0
  prefs: []
  type: TYPE_NORMAL
- en: (flmod0 -17.0 -3.0) ![<graphic>](ch6_0.gif) 1.0
  prefs: []
  type: TYPE_NORMAL
- en: (fldiv0-and-mod0 17.5 3.75) ![<graphic>](ch6_0.gif) 5.0
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) -1.25`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flround *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer closest to `*fl*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fltruncate *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer closest to `*fl*` toward zero'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flfloor *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer closest to `*fl*` toward ![<graphic>](ch6_11.gif)'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flceiling *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer closest to `*fl*` toward ![<graphic>](ch6_12.gif)'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*fl*` is an integer, NaN, or infinity, each of these procedures returns
    `*fl*`. If `*fl*` is exactly between two integers, `flround` returns the closest
    even integer.
  prefs: []
  type: TYPE_NORMAL
- en: '`(flround 17.3) ![<graphic>](ch6_0.gif) 17.0'
  prefs: []
  type: TYPE_NORMAL
- en: (flround -17.3) ![<graphic>](ch6_0.gif) -17.0
  prefs: []
  type: TYPE_NORMAL
- en: (flround 2.5) ![<graphic>](ch6_0.gif) 2.0
  prefs: []
  type: TYPE_NORMAL
- en: (flround 3.5) ![<graphic>](ch6_0.gif) 4.0
  prefs: []
  type: TYPE_NORMAL
- en: (fltruncate 17.3) ![<graphic>](ch6_0.gif) 17.0
  prefs: []
  type: TYPE_NORMAL
- en: (fltruncate -17.3) ![<graphic>](ch6_0.gif) -17.0
  prefs: []
  type: TYPE_NORMAL
- en: (flfloor 17.3) ![<graphic>](ch6_0.gif) 17.0
  prefs: []
  type: TYPE_NORMAL
- en: (flfloor -17.3) ![<graphic>](ch6_0.gif) -18.0
  prefs: []
  type: TYPE_NORMAL
- en: (flceiling 17.3) ![<graphic>](ch6_0.gif) 18.0
  prefs: []
  type: TYPE_NORMAL
- en: (flceiling -17.3) ![<graphic>](ch6_0.gif) -17.0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flnumerator *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the numerator of `*fl*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fldenominator *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the denominator of `*fl*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*fl*` is an integer, including 0.0, or infinity, the numerator is `*fl*`
    and the denominator is 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: '`(flnumerator -9.0) ![<graphic>](ch6_0.gif) -9.0'
  prefs: []
  type: TYPE_NORMAL
- en: (fldenominator -9.0) ![<graphic>](ch6_0.gif) 1.0
  prefs: []
  type: TYPE_NORMAL
- en: (flnumerator 0.0) ![<graphic>](ch6_0.gif) 0.0
  prefs: []
  type: TYPE_NORMAL
- en: (fldenominator 0.0) ![<graphic>](ch6_0.gif) 1.0
  prefs: []
  type: TYPE_NORMAL
- en: (flnumerator -inf.0) ![<graphic>](ch6_0.gif) -inf.0
  prefs: []
  type: TYPE_NORMAL
- en: (fldenominator -inf.0) ![<graphic>](ch6_0.gif) 1.0`
  prefs: []
  type: TYPE_NORMAL
- en: The following hold for IEEE floats, but not necessarily other flonum representations.
  prefs: []
  type: TYPE_NORMAL
- en: '`(flnumerator 3.5) ![<graphic>](ch6_0.gif) 7.0'
  prefs: []
  type: TYPE_NORMAL
- en: (fldenominator 3.5) ![<graphic>](ch6_0.gif) 2.0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flabs *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** absolute value of `*fl*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(flabs 3.2) ![<graphic>](ch6_0.gif) 3.2'
  prefs: []
  type: TYPE_NORMAL
- en: (flabs -2e-20) ![<graphic>](ch6_0.gif) 2e-20`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flexp *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** *e* to the `*fl*` power'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fllog *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the natural logarithm of `*fl*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fllog *fl[1]* *fl[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the base-`*fl[2]*` logarithm of `*fl[1]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(flexp 0.0) ![<graphic>](ch6_0.gif) 1.0'
  prefs: []
  type: TYPE_NORMAL
- en: (flexp 1.0) ![<graphic>](ch6_0.gif) 2.7182818284590455
  prefs: []
  type: TYPE_NORMAL
- en: (fllog 1.0) ![<graphic>](ch6_0.gif) 0.0
  prefs: []
  type: TYPE_NORMAL
- en: (fllog (exp 1.0)) ![<graphic>](ch6_0.gif) 1.0
  prefs: []
  type: TYPE_NORMAL
- en: (fl/ (fllog 100.0) (fllog 10.0)) ![<graphic>](ch6_0.gif) 2.0
  prefs: []
  type: TYPE_NORMAL
- en: (fllog 100.0 10.0) ![<graphic>](ch6_0.gif) 2.0
  prefs: []
  type: TYPE_NORMAL
- en: (fllog .125 2.0) ![<graphic>](ch6_0.gif) -3.0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flsin *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the sine of `*fl*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flcos *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the cosine of `*fl*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fltan *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the tangent of `*fl*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flasin *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the arc sine of `*fl*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flacos *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the arc cosine of `*fl*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flatan *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the arc tangent of `*fl*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flatan *fl[1]* *fl[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the arc tangent of `*fl[1]*`/`*fl[2]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flsqrt *fl*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the principal square root of `*fl*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the principal square root of `*fl*`. The square root of -0.0 should
    be -0.0. The result for other negative numbers may be a NaN or some other unspecified
    flonum.
  prefs: []
  type: TYPE_NORMAL
- en: '`(flsqrt 4.0) ![<graphic>](ch6_0.gif) 2.0'
  prefs: []
  type: TYPE_NORMAL
- en: (flsqrt 0.0) ![<graphic>](ch6_0.gif) 0.0
  prefs: []
  type: TYPE_NORMAL
- en: (flsqrt -0.0) ![<graphic>](ch6_0.gif) -0.0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flexpt *fl[1]* *fl[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*fl[1]*` raised to the `*fl[2]*` power'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*fl[1]*` is negative and `*fl[2]*` is not an integer, the result may be
    a NaN or some other unspecified flonum. If `*fl[1]*` and `*fl[2]*` are both zero,
    the result is 1.0\. If `*fl[1]*` is zero and `*fl[2]*` is positive, the result
    is zero. In other cases where `*fl[1]*` is zero, the result may be a NaN or some
    other unspecified flonum.
  prefs: []
  type: TYPE_NORMAL
- en: '`(flexpt 3.0 2.0) ![<graphic>](ch6_0.gif) 9.0'
  prefs: []
  type: TYPE_NORMAL
- en: (flexpt 0.0 +inf.0) ![<graphic>](ch6_0.gif) 0.0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fixnum->flonum *fx*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the flonum representation closest to `*fx*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(real->flonum *real*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the flonum representation closest to `*real*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`fixnum->flonum` is a restricted variant of `inexact`. `real->flonum` is a
    restricted variant of `inexact` when the input is an exact real; when it is an
    inexact non-flonum real, it coverts the inexact non-flonum real into the closest
    flonum.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fixnum->flonum 0) ![<graphic>](ch6_0.gif) 0.0'
  prefs: []
  type: TYPE_NORMAL
- en: (fixnum->flonum 13) ![<graphic>](ch6_0.gif) 13.0
  prefs: []
  type: TYPE_NORMAL
- en: (real->flonum -1/2) ![<graphic>](ch6_0.gif) -0.5
  prefs: []
  type: TYPE_NORMAL
- en: (real->flonum 1s3) ![<graphic>](ch6_0.gif) 1000.0`
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.7\. Characters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Characters are atomic objects representing letters, digits, special symbols
    such as `$` or `-`, and certain nongraphic control characters such as space and
    newline. Characters are written with a `#\` prefix. For most characters, the prefix
    is followed by the character itself. The written character representation of the
    letter `A`, for example, is `#\A`. The characters newline, space, and tab may
    be written in this manner as well, but they can be written more clearly as `#\newline`,
    `#\space`, and `#\tab`. Other character names are supported as well, as defined
    by the grammar for character objects on page [457](grammar.html#grammar:characters).
    Any Unicode character may be written with the syntax `#\x*n*`, where `*n*` consists
    of one or more hexadecimal digits and represents a valid Unicode scalar value.
  prefs: []
  type: TYPE_NORMAL
- en: This section describes the operations that deal primarily with characters. See
    also the following section on strings and Chapter [7](io.html#g121) on input and
    output for other operations relating to characters.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char=? *char[1]* *char[2]* *char[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char<? *char[1]* *char[2]* *char[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char>? *char[1]* *char[2]* *char[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char<=? *char[1]* *char[2]* *char[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char>=? *char[1]* *char[2]* *char[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the relation holds, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: These predicates behave in a similar manner to the numeric predicates `=`, `<`,
    `>`, `<=`, and `>=`. For example, `char=?` returns `#t` when its arguments are
    equivalent characters, and `char<?` returns `#t` when its arguments are monotonically
    increasing character (Unicode scalar) values.
  prefs: []
  type: TYPE_NORMAL
- en: '`(char>? #\a #\b) ![<graphic>](ch6_0.gif) #f'
  prefs: []
  type: TYPE_NORMAL
- en: (char<? #\a #\b) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (char<? #\a #\b #\c) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([c #\r])
  prefs: []
  type: TYPE_NORMAL
- en: (char<=? #\a c #\z)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (char<=? #\Z #\W) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (char=? #\+ #\+) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-ci=? *char[1]* *char[2]* *char[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-ci<? *char[1]* *char[2]* *char[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-ci>? *char[1]* *char[2]* *char[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-ci<=? *char[1]* *char[2]* *char[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-ci>=? *char[1]* *char[2]* *char[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the relation holds, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: These predicates are identical to the predicates `char=?`, `char<?`, `char>?`,
    `char<=?`, and `char>=?` except that they are case-insensitive, i.e., compare
    the case-folded versions of their arguments. For example, `char=?` considers `#\a`
    and `#\A` to be distinct values; `char-ci=?` does not.
  prefs: []
  type: TYPE_NORMAL
- en: '`(char-ci<? #\a #\B) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (char-ci=? #\W #\w) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (char-ci=? #\= #\+) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (let ([c #\R])
  prefs: []
  type: TYPE_NORMAL
- en: (list (char<=? #\a c #\z)
  prefs: []
  type: TYPE_NORMAL
- en: (char-ci<=? #\a c #\z))) ![<graphic>](ch6_0.gif) (#f #t)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-alphabetic? *char*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*char*` is a letter, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-numeric? *char*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*char*` is a digit, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-whitespace? *char*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*char*` is whitespace, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: A character is alphabetic if it has the Unicode "Alphabetic" property, numeric
    if it has the Unicode "Numeric" property, and whitespace if has the Unicode "White_Space"
    property.
  prefs: []
  type: TYPE_NORMAL
- en: '`(char-alphabetic? #\a) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (char-alphabetic? #\T) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (char-alphabetic? #\8) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (char-alphabetic? #\$) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (char-numeric? #\7) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (char-numeric? #\2) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (char-numeric? #\X) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (char-numeric? #\space) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (char-whitespace? #\space) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (char-whitespace? #\newline) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (char-whitespace? #\Z) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-lower-case? *char*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*char*` is lower case, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-upper-case? *char*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*char*` is upper case, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-title-case? *char*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*char*` is title case, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: A character is upper-case if it has the Unicode "Uppercase" property, lower-case
    if it has the "Lowercase" property, and title-case if it is in the Lt general
    category.
  prefs: []
  type: TYPE_NORMAL
- en: '`(char-lower-case? #\r) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (char-lower-case? #\R) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (char-upper-case? #\r) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (char-upper-case? #\R) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (char-title-case? #\I) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (char-title-case? #\x01C5) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-general-category *char*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a symbol representing the Unicode general category of `*char*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The return value is one of the symbols `Lu`, `Ll`, `Lt`, `Lm`, `Lo`, `Mn`, `Mc`,
    `Me`, `Nd`, `Nl`, `No`, `Ps`, `Pe`, `Pi`, `Pf`, `Pd`, `Pc`, `Po`, `Sc`, `Sm`,
    `Sk`, `So`, `Zs`, `Zp`, `Zl`, `Cc`, `Cf`, `Cs`, `Co`, or `Cn`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(char-general-category #\a) ![<graphic>](ch6_0.gif) Ll'
  prefs: []
  type: TYPE_NORMAL
- en: (char-general-category #\space) ![<graphic>](ch6_0.gif) Zs
  prefs: []
  type: TYPE_NORMAL
- en: (char-general-category #\x10FFFF) ![<graphic>](ch6_0.gif) Cn  `
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-upcase *char*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the upper-case character counterpart of `*char*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*char*` is a lower- or title-case character and has a single upper-case
    counterpart, `char-upcase` returns the upper-case counterpart. Otherwise `char-upcase`
    returns `*char*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(char-upcase #\g) ![<graphic>](ch6_0.gif) #\G'
  prefs: []
  type: TYPE_NORMAL
- en: (char-upcase #\G) ![<graphic>](ch6_0.gif) #\G
  prefs: []
  type: TYPE_NORMAL
- en: (char-upcase #\7) ![<graphic>](ch6_0.gif) #\7
  prefs: []
  type: TYPE_NORMAL
- en: (char-upcase #\![<graphic>](ch6_20.gif)) ![<graphic>](ch6_0.gif) #\![<graphic>](ch6_21.gif)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-downcase *char*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the lower-case character equivalent of `*char*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*char*` is an upper- or title-case character and has a single lower-case
    counterpart, `char-downcase` returns the lower-case counterpart. Otherwise `char-downcase`
    returns `*char*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(char-downcase #\g) ![<graphic>](ch6_0.gif) #\g'
  prefs: []
  type: TYPE_NORMAL
- en: (char-downcase #\G) ![<graphic>](ch6_0.gif) #\g
  prefs: []
  type: TYPE_NORMAL
- en: (char-downcase #\7) ![<graphic>](ch6_0.gif) #\7
  prefs: []
  type: TYPE_NORMAL
- en: (char-downcase #\![<graphic>](ch6_20.gif)) ![<graphic>](ch6_0.gif) #\![<graphic>](ch6_20.gif)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-titlecase *char*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the title-case character equivalent of `*char*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*char*` is an upper- or lower-case character and has a single title-case
    counterpart, `char-titlecase` returns the title-case counterpart. Otherwise, if
    it is not a title-case character, has no single title-case counterpart, but does
    have a single upper-case counterpart, `char-titlecase` returns the upper-case
    counterpart. Otherwise `char-titlecase` returns `*char*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(char-titlecase #\g) ![<graphic>](ch6_0.gif) #\G'
  prefs: []
  type: TYPE_NORMAL
- en: (char-titlecase #\G) ![<graphic>](ch6_0.gif) #\G
  prefs: []
  type: TYPE_NORMAL
- en: (char-titlecase #\7) ![<graphic>](ch6_0.gif) #\7
  prefs: []
  type: TYPE_NORMAL
- en: (char-titlecase #\![<graphic>](ch6_20.gif)) ![<graphic>](ch6_0.gif) #\![<graphic>](ch6_21.gif)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-foldcase *char*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the case-folded character equivalent of `*char*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*char*` has a case-folded counterpart, `char-foldcase` returns the case-folded
    counterpart. Otherwise, `char-foldcase` returns `*char*`. For most characters,
    `(char-foldcase *char*)` is equivalent to `(char-downcase (char-upcase *char*))`,
    but for Turkic İ and ı, `char-foldcase` acts as the identity.
  prefs: []
  type: TYPE_NORMAL
- en: '`(char-foldcase #\g) ![<graphic>](ch6_0.gif) #\g'
  prefs: []
  type: TYPE_NORMAL
- en: (char-foldcase #\G) ![<graphic>](ch6_0.gif) #\g
  prefs: []
  type: TYPE_NORMAL
- en: (char-foldcase #\7) ![<graphic>](ch6_0.gif) #\7
  prefs: []
  type: TYPE_NORMAL
- en: (char-foldcase #\![<graphic>](ch6_20.gif)) ![<graphic>](ch6_0.gif) #\![<graphic>](ch6_22.gif)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char->integer *char*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the Unicode scalar value of `*char*` as an exact integer'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(char->integer #\newline) ![<graphic>](ch6_0.gif) 10'
  prefs: []
  type: TYPE_NORMAL
- en: (char->integer #\space) ![<graphic>](ch6_0.gif) 32
  prefs: []
  type: TYPE_NORMAL
- en: (- (char->integer #\Z) (char->integer #\A)) ![<graphic>](ch6_0.gif) 25`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(integer->char *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the character corresponding to the Unicode scalar value `*n*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact integer and a valid Unicode scalar value, i.e., ![<graphic>](ch6_23.gif)
    or ![<graphic>](ch6_24.gif).'
  prefs: []
  type: TYPE_NORMAL
- en: '`(integer->char 48) ![<graphic>](ch6_0.gif) #\0'
  prefs: []
  type: TYPE_NORMAL
- en: (integer->char #x3BB) ![<graphic>](ch6_0.gif) #\![<graphic>](ch6_25.gif)`
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.8\. Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Strings are sequences of characters and are often used as messages, character
    buffers, or containers for blocks of text. Scheme provides operations for creating
    strings, extracting characters from strings, obtaining substrings, concatenating
    strings, and altering the contents of strings.
  prefs: []
  type: TYPE_NORMAL
- en: A string is written as a sequence of characters enclosed in double quotes, e.g.,
    `"hi there"`. A double quote may be introduced into a string by preceding it by
    a backward slash, e.g., `"two \"quotes\" within"`. A backward slash may also be
    included by preceding it with a backward slash, e.g., `"a \\slash"`. Various special
    characters can be inserted with other two-character sequences, e.g., `\n` for
    newline, `\r` for carriage return, and `\t` for tab. Any Unicode character may
    be inserted with the syntax `#\x*n*;`, where `*n*` consists of one or more hexadecimal
    digits and represents a valid Unicode scalar value. A grammar defining the precise
    syntax of strings is given on page [458](grammar.html#grammar:strings).
  prefs: []
  type: TYPE_NORMAL
- en: Strings are indexed by exact nonnegative integers, and the index of the first
    element of any string is 0. The highest valid index for a given string is one
    less than its length.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string=? *string[1]* *string[2]* *string[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string<? *string[1]* *string[2]* *string[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string>? *string[1]* *string[2]* *string[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string<=? *string[1]* *string[2]* *string[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string>=? *string[1]* *string[2]* *string[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the relation holds, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: As with `=`, `<`, `>`, `<=`, and `>=`, these predicates express relationships
    among all of the arguments. For example, `string>?` determines if the lexicographic
    ordering of its arguments is monotonically decreasing.
  prefs: []
  type: TYPE_NORMAL
- en: The comparisons are based on the character predicates `char=?` and `char<?`.
    Two strings are lexicographically equivalent if they are the same length and consist
    of the same sequence of characters according to `char=?`. If two strings differ
    only in length, the shorter string is considered to be lexicographically less
    than the longer string. Otherwise, the first character position at which the strings
    differ (by `char=?`) determines which string is lexicographically less than the
    other, according to `char<?`.
  prefs: []
  type: TYPE_NORMAL
- en: Two-argument `string=?` may be defined without error checks as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define string=?'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s1 s2)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([n (string-length s1)])
  prefs: []
  type: TYPE_NORMAL
- en: (and (= (string-length s2) n)
  prefs: []
  type: TYPE_NORMAL
- en: (let loop ([i 0])
  prefs: []
  type: TYPE_NORMAL
- en: (or (= i n)
  prefs: []
  type: TYPE_NORMAL
- en: (and (char=? (string-ref s1 i) (string-ref s2 i))
  prefs: []
  type: TYPE_NORMAL
- en: (loop (+ i 1)))))))))`
  prefs: []
  type: TYPE_NORMAL
- en: Two-argument `string<?` may be defined without error checks as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define string<?'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s1 s2)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([n1 (string-length s1)] [n2 (string-length s2)])
  prefs: []
  type: TYPE_NORMAL
- en: (let loop ([i 0])
  prefs: []
  type: TYPE_NORMAL
- en: (and (not (= i n2))
  prefs: []
  type: TYPE_NORMAL
- en: (or (= i n1)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([c1 (string-ref s1 i)] [c2 (string-ref s2 i)])
  prefs: []
  type: TYPE_NORMAL
- en: (or (char<? c1 c2)
  prefs: []
  type: TYPE_NORMAL
- en: (and (char=? c1 c2)
  prefs: []
  type: TYPE_NORMAL
- en: (loop (+ i 1)))))))))))`
  prefs: []
  type: TYPE_NORMAL
- en: These definitions may be extended straightforwardly to support three or more
    arguments. `string<=?`, `string>?`, and `string>=?` may be defined similarly.
  prefs: []
  type: TYPE_NORMAL
- en: '`(string=? "mom" "mom") ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (string<? "mom" "mommy") ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (string>? "Dad" "Dad") ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (string=? "Mom and Dad" "mom and dad") ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (string<? "a" "b" "c") ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-ci=? *string[1]* *string[2]* *string[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-ci<? *string[1]* *string[2]* *string[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-ci>? *string[1]* *string[2]* *string[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-ci<=? *string[1]* *string[2]* *string[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-ci>=? *string[1]* *string[2]* *string[3]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the relation holds, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: These predicates are identical to `string=?`, `string<?`, `string>?`, `string<=?`,
    and `string>=?` except that they are case-sensitive, i.e., compare the case-folded
    versions of their arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '`(string-ci=? "Mom and Dad" "mom and dad") ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (string-ci<=? "say what" "Say What!?") ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (string-ci>? "N" "m" "L" "k") ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (string-ci=? "Stra\sse" "Strasse") ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string *char* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a string containing the characters `*char* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(string) ![<graphic>](ch6_0.gif) ""'
  prefs: []
  type: TYPE_NORMAL
- en: (string #\a #\b #\c) ![<graphic>](ch6_0.gif) "abc"
  prefs: []
  type: TYPE_NORMAL
- en: (string #\H #\E #\Y #\!) ![<graphic>](ch6_0.gif) "HEY!"`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-string *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-string *n* *char*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a string of length `*n*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer. If `*char*` is supplied, the string
    is filled with `*n*` occurrences of `*char*`, otherwise the characters contained
    in the string are unspecified.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(make-string 0) ![<graphic>](ch6_0.gif) ""'
  prefs: []
  type: TYPE_NORMAL
- en: (make-string 0 #\x) ![<graphic>](ch6_0.gif) ""
  prefs: []
  type: TYPE_NORMAL
- en: (make-string 5 #\x) ![<graphic>](ch6_0.gif) "xxxxx"`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-length *string*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the number of characters in `*string*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The length of a string is always an exact nonnegative integer.
  prefs: []
  type: TYPE_NORMAL
- en: '`(string-length "abc") ![<graphic>](ch6_0.gif) 3'
  prefs: []
  type: TYPE_NORMAL
- en: (string-length "") ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (string-length "hi there") ![<graphic>](ch6_0.gif) 8
  prefs: []
  type: TYPE_NORMAL
- en: (string-length (make-string 1000000)) ![<graphic>](ch6_0.gif) 1000000`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-ref *string* *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the `*n*`th character (zero-based) of `*string*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than the length of `*string*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(string-ref "hi there" 0) ![<graphic>](ch6_0.gif) #\h'
  prefs: []
  type: TYPE_NORMAL
- en: (string-ref "hi there" 5) ![<graphic>](ch6_0.gif) #\e`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-set! *string* *n* *char*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs mutable-strings)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than the length of `*string*`.
    `string-set!` changes the `*n*`th element of `*string*` to `*char*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([str (string-copy "hi three")])'
  prefs: []
  type: TYPE_NORMAL
- en: (string-set! str 5 #\e)
  prefs: []
  type: TYPE_NORMAL
- en: (string-set! str 6 #\r)
  prefs: []
  type: TYPE_NORMAL
- en: str) ![<graphic>](ch6_0.gif) "hi there"`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-copy *string*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new copy of `*string*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: This procedure creates a new string with the same length and contents as `*string*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(string-copy "abc") ![<graphic>](ch6_0.gif) "abc"'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([str "abc"])
  prefs: []
  type: TYPE_NORMAL
- en: (eq? str (string-copy str))) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-append *string* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new string formed by concatenating the strings `*string* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(string-append) ![<graphic>](ch6_0.gif) ""'
  prefs: []
  type: TYPE_NORMAL
- en: (string-append "abc" "def") ![<graphic>](ch6_0.gif) "abcdef"
  prefs: []
  type: TYPE_NORMAL
- en: (string-append "Hey " "you " "there!") ![<graphic>](ch6_0.gif) "Hey you there!"`
  prefs: []
  type: TYPE_NORMAL
- en: The following implementation of `string-append` recurs down the list of strings
    to compute the total length, then allocates the new string, then fills it up as
    it unwinds the recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define string-append'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda args
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([ls args] [n 0])
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: (make-string n)
  prefs: []
  type: TYPE_NORMAL
- en: (let* ([s1 (car ls)]
  prefs: []
  type: TYPE_NORMAL
- en: '[m (string-length s1)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[s2 (f (cdr ls) (+ n m))])'
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i 0 (+ i 1)] [j n (+ j 1)])
  prefs: []
  type: TYPE_NORMAL
- en: ((= i m) s2)
  prefs: []
  type: TYPE_NORMAL
- en: (string-set! s2 j (string-ref s1 i))))))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(substring *string* *start* *end*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a copy of `*string*` from `*start*` (inclusive) to `*end*` (exclusive)'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*start*` and `*end*` must be exact nonnegative integers; `*start*` must be
    less than the length of `*string*`, while `*end*` may be less than or equal to
    the length of `*string*`. If `*end*` ≤ `*start*`, a string of length zero is returned.
    `substring` may be defined without error checks as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define substring'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s1 m n)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([s2 (make-string (- n m))])
  prefs: []
  type: TYPE_NORMAL
- en: (do ([j 0 (+ j 1)] [i m (+ i 1)])
  prefs: []
  type: TYPE_NORMAL
- en: ((= i n) s2)
  prefs: []
  type: TYPE_NORMAL
- en: (string-set! s2 j (string-ref s1 i))))))
  prefs: []
  type: TYPE_NORMAL
- en: (substring "hi there" 0 1) ![<graphic>](ch6_0.gif) "h"
  prefs: []
  type: TYPE_NORMAL
- en: (substring "hi there" 3 6) ![<graphic>](ch6_0.gif) "the"
  prefs: []
  type: TYPE_NORMAL
- en: (substring "hi there" 5 5) ![<graphic>](ch6_0.gif) ""
  prefs: []
  type: TYPE_NORMAL
- en: (let ([str "hi there"])
  prefs: []
  type: TYPE_NORMAL
- en: (let ([end (string-length str)])
  prefs: []
  type: TYPE_NORMAL
- en: (substring str 0 end))) ![<graphic>](ch6_0.gif) "hi there"`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-fill! *string* *char*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs mutable-strings)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`string-fill!` sets every character in `*string*` to `*char*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([str (string-copy "sleepy")])'
  prefs: []
  type: TYPE_NORMAL
- en: (string-fill! str #\Z)
  prefs: []
  type: TYPE_NORMAL
- en: str) ![<graphic>](ch6_0.gif) "ZZZZZZ"`
  prefs: []
  type: TYPE_NORMAL
- en: '`string-fill!` might be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define string-fill!'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s c)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([n (string-length s)])
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i 0 (+ i 1)])
  prefs: []
  type: TYPE_NORMAL
- en: ((= i n))
  prefs: []
  type: TYPE_NORMAL
- en: (string-set! s i c)))))`
  prefs: []
  type: TYPE_NORMAL
- en: An alternative definition is given on page [276](io.html#backdoor-string-fill).
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-upcase *string*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the upper-case equivalent of `*string*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-downcase *string*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the lower-case equivalent of `*string*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-foldcase *string*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the case-folded equivalent of `*string*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-titlecase *string*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the title-case equivalent of `*string*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: These procedures implement Unicode's locale-independent case mappings from scalar-value
    sequences to scalar-value sequences. These mappings do not always map single characters
    to single characters, so the length of the result string may differ from the length
    of `*string*`. If the result string is the same as `*string*` (by `string=?`),
    `*string*` or a copy of `*string*` may be returned. Otherwise, the result string
    is newly allocated. `string-foldcase` does not use the special mappings for Turkic
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: '`string-titlecase` converts the first cased character of each word in `*string*`
    to its title-case counterpart and converts each other character to its lower-case
    counterpart. Word breaks are recognized as specified in Unicode Standard Annex #29 [[8](bibliography.html#g226)].'
  prefs: []
  type: TYPE_NORMAL
- en: '`(string-upcase "Hi") ![<graphic>](ch6_0.gif) "HI"'
  prefs: []
  type: TYPE_NORMAL
- en: (string-downcase "Hi") ![<graphic>](ch6_0.gif) "hi"
  prefs: []
  type: TYPE_NORMAL
- en: (string-foldcase "Hi") ![<graphic>](ch6_0.gif) "hi"
  prefs: []
  type: TYPE_NORMAL
- en: (string-upcase "Straße") ![<graphic>](ch6_0.gif) "STRASSE"
  prefs: []
  type: TYPE_NORMAL
- en: (string-downcase "Straße") ![<graphic>](ch6_0.gif) "straße"
  prefs: []
  type: TYPE_NORMAL
- en: (string-foldcase "Straße") ![<graphic>](ch6_0.gif) "strasse"
  prefs: []
  type: TYPE_NORMAL
- en: (string-downcase "STRASSE")  ![<graphic>](ch6_0.gif) "strasse"
  prefs: []
  type: TYPE_NORMAL
- en: (string-downcase "![<graphic>](ch6_21.gif)") ![<graphic>](ch6_0.gif) "![<graphic>](ch6_22.gif)"
  prefs: []
  type: TYPE_NORMAL
- en: (string-titlecase "kNock KNoCK") ![<graphic>](ch6_0.gif) "Knock Knock"
  prefs: []
  type: TYPE_NORMAL
- en: (string-titlecase "who's there?") ![<graphic>](ch6_0.gif) "Who's There?"
  prefs: []
  type: TYPE_NORMAL
- en: (string-titlecase "r6rs") ![<graphic>](ch6_0.gif) "R6rs"
  prefs: []
  type: TYPE_NORMAL
- en: (string-titlecase "R6RS") ![<graphic>](ch6_0.gif) "R6rs"`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-normalize-nfd *string*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the Unicode normalized form D of `*string*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-normalize-nfkd *string*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the Unicode normalized form KD of `*string*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-normalize-nfc *string*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the Unicode normalized form C of `*string*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-normalize-nfkc *string*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the Unicode normalized form KC of `*string*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If the result string is the same as `*string*` (by `string=?`), `*string*` or
    a copy of `*string*` may be returned. Otherwise, the result string is newly allocated.
  prefs: []
  type: TYPE_NORMAL
- en: '`(string-normalize-nfd "\xE9;") ![<graphic>](ch6_0.gif) "e\x301;"'
  prefs: []
  type: TYPE_NORMAL
- en: (string-normalize-nfc "\xE9;") ![<graphic>](ch6_0.gif) "\xE9;"
  prefs: []
  type: TYPE_NORMAL
- en: (string-normalize-nfd "\x65;\x301;") ![<graphic>](ch6_0.gif) "e\x301;"
  prefs: []
  type: TYPE_NORMAL
- en: (string-normalize-nfc "\x65;\x301;") ![<graphic>](ch6_0.gif) "\xE9;"`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string->list *string*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a list of the characters in `*string*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`string->list` allows a string to be converted into a list, so that Scheme''s
    list-processing operations may be applied to the processing of strings. `string->list`
    may be defined without error checks as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define string->list'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s)
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i (- (string-length s) 1) (- i 1)]
  prefs: []
  type: TYPE_NORMAL
- en: '[ls ''() (cons (string-ref s i) ls)])'
  prefs: []
  type: TYPE_NORMAL
- en: ((< i 0) ls))))
  prefs: []
  type: TYPE_NORMAL
- en: (string->list "") ![<graphic>](ch6_0.gif) ()
  prefs: []
  type: TYPE_NORMAL
- en: (string->list "abc") ![<graphic>](ch6_0.gif) (#\a #\b #\c)
  prefs: []
  type: TYPE_NORMAL
- en: (apply char<? (string->list "abc")) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (map char-upcase (string->list "abc")) ![<graphic>](ch6_0.gif) (#\A #\B #\C)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(list->string *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a string of the characters in `*list*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*list*` must consist entirely of characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '`list->string` is the functional inverse of `string->list`. A program might
    use both procedures together, first converting a string into a list, then operating
    on this list to produce a new list, and finally converting the new list back into
    a string.'
  prefs: []
  type: TYPE_NORMAL
- en: '`list->string` may be defined without error checks as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define list->string'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([s (make-string (length ls))])
  prefs: []
  type: TYPE_NORMAL
- en: (do ([ls ls (cdr ls)] [i 0 (+ i 1)])
  prefs: []
  type: TYPE_NORMAL
- en: ((null? ls) s)
  prefs: []
  type: TYPE_NORMAL
- en: (string-set! s i (car ls))))))
  prefs: []
  type: TYPE_NORMAL
- en: (list->string '()) ![<graphic>](ch6_0.gif) ""
  prefs: []
  type: TYPE_NORMAL
- en: (list->string '(#\a #\b #\c)) ![<graphic>](ch6_0.gif) "abc"
  prefs: []
  type: TYPE_NORMAL
- en: (list->string
  prefs: []
  type: TYPE_NORMAL
- en: (map char-upcase
  prefs: []
  type: TYPE_NORMAL
- en: (string->list "abc"))) ![<graphic>](ch6_0.gif) "ABC"`
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.9\. Vectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vectors are more convenient and efficient than lists for some applications.
    Whereas accessing an arbitrary element in a list requires a linear traversal of
    the list up to the selected element, arbitrary vector elements are accessed in
    constant time. The *length* of a vector is the number of elements it contains.
    Vectors are indexed by exact nonnegative integers, and the index of the first
    element of any vector is 0. The highest valid index for a given vector is one
    less than its length.
  prefs: []
  type: TYPE_NORMAL
- en: As with lists, the elements of a vector can be of any type, and a single vector
    can hold more than one type of object.
  prefs: []
  type: TYPE_NORMAL
- en: A vector is written as a sequence of objects separated by whitespace, preceded
    by the prefix `#(` and followed by `)`. For example, a vector consisting of the
    elements `a`, `b`, and `c` would be written `#(a b c)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector *obj* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a vector of the objects `*obj* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(vector) ![<graphic>](ch6_0.gif) #()'
  prefs: []
  type: TYPE_NORMAL
- en: (vector 'a 'b 'c) ![<graphic>](ch6_0.gif) #(a b c)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-vector *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-vector *n* *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a vector of length `*n*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer. If `*obj*` is supplied, each element
    of the vector is filled with `*obj*`; otherwise, the elements are unspecified.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(make-vector 0) ![<graphic>](ch6_0.gif) #()'
  prefs: []
  type: TYPE_NORMAL
- en: (make-vector 0 '#(a)) ![<graphic>](ch6_0.gif) #()
  prefs: []
  type: TYPE_NORMAL
- en: (make-vector 5 '#(a)) ![<graphic>](ch6_0.gif) #(#(a) #(a) #(a) #(a) #(a))`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector-length *vector*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the number of elements in `*vector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The length of a vector is always an exact nonnegative integer.
  prefs: []
  type: TYPE_NORMAL
- en: '`(vector-length ''#()) ![<graphic>](ch6_0.gif) 0'
  prefs: []
  type: TYPE_NORMAL
- en: (vector-length '#(a b c)) ![<graphic>](ch6_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (vector-length (vector 1 '(2) 3 '#(4 5))) ![<graphic>](ch6_0.gif) 4
  prefs: []
  type: TYPE_NORMAL
- en: (vector-length (make-vector 300)) ![<graphic>](ch6_0.gif) 300`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector-ref *vector* *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the `*n*`th element (zero-based) of `*vector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than the length of `*vector*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(vector-ref ''#(a b c) 0) ![<graphic>](ch6_0.gif) a'
  prefs: []
  type: TYPE_NORMAL
- en: (vector-ref '#(a b c) 1) ![<graphic>](ch6_0.gif) b
  prefs: []
  type: TYPE_NORMAL
- en: (vector-ref '#(x y z w) 3) ![<graphic>](ch6_0.gif) w`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector-set! *vector* *n* *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than the length of `*vector*`.
    `vector-set!` changes the `*n*`th element of `*vector*` to `*obj*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([v (vector ''a ''b ''c ''d ''e)])'
  prefs: []
  type: TYPE_NORMAL
- en: (vector-set! v 2 'x)
  prefs: []
  type: TYPE_NORMAL
- en: v) ![<graphic>](ch6_0.gif) #(a b x d e)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector-fill! *vector* *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`vector-fill!` replaces each element of `*vector*` with `*obj*`. It may be
    defined without error checks as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define vector-fill!'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (v x)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([n (vector-length v)])
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i 0 (+ i 1)])
  prefs: []
  type: TYPE_NORMAL
- en: ((= i n))
  prefs: []
  type: TYPE_NORMAL
- en: (vector-set! v i x)))))
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v (vector 1 2 3)])
  prefs: []
  type: TYPE_NORMAL
- en: (vector-fill! v 0)
  prefs: []
  type: TYPE_NORMAL
- en: v) ![<graphic>](ch6_0.gif) #(0 0 0)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector->list *vector*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a list of the elements of `*vector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`vector->list` provides a convenient method for applying list-processing operations
    to vectors. It may be defined without error checks as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define vector->list'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s)
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i (- (vector-length s) 1) (- i 1)]
  prefs: []
  type: TYPE_NORMAL
- en: '[ls ''() (cons (vector-ref s i) ls)])'
  prefs: []
  type: TYPE_NORMAL
- en: ((< i 0) ls))))
  prefs: []
  type: TYPE_NORMAL
- en: (vector->list (vector)) ![<graphic>](ch6_0.gif) ()
  prefs: []
  type: TYPE_NORMAL
- en: (vector->list '#(a b c)) ![<graphic>](ch6_0.gif) (a b c)
  prefs: []
  type: TYPE_NORMAL
- en: (let ((v '#(1 2 3 4 5)))
  prefs: []
  type: TYPE_NORMAL
- en: (apply * (vector->list v))) ![<graphic>](ch6_0.gif) 120`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(list->vector *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a vector of the elements of `*list*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`list->vector` is the functional inverse of `vector->list`. The two procedures
    are often used in combination to take advantage of a list-processing operation.
    A vector may be converted to a list with `vector->list`, this list processed in
    some manner to produce a new list, and the new list converted back into a vector
    with `list->vector`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`list->vector` may be defined without error checks as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define list->vector'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([s (make-vector (length ls))])
  prefs: []
  type: TYPE_NORMAL
- en: (do ([ls ls (cdr ls)] [i 0 (+ i 1)])
  prefs: []
  type: TYPE_NORMAL
- en: ((null? ls) s)
  prefs: []
  type: TYPE_NORMAL
- en: (vector-set! s i (car ls))))))
  prefs: []
  type: TYPE_NORMAL
- en: (list->vector '()) ![<graphic>](ch6_0.gif) #()
  prefs: []
  type: TYPE_NORMAL
- en: (list->vector '(a b c)) ![<graphic>](ch6_0.gif) #(a b c)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v '#(1 2 3 4 5)])
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls (vector->list v)])
  prefs: []
  type: TYPE_NORMAL
- en: (list->vector (map * ls ls)))) ![<graphic>](ch6_0.gif) #(1 4 9 16 25)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector-sort *predicate* *vector*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a vector containing the elements of `*vector*`, sorted according
    to `*predicate*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector-sort! *predicate* *vector*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs sorting)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*predicate*` should be a procedure that expects two arguments and returns
    `#t` if its first argument must precede its second in the sorted vector. That
    is, if `*predicate*` is applied to two elements `*x*` and `*y*`, where `*x*` appears
    after `*y*` in the input vector, the predicate should return true only if `*x*`
    should appear before `*y*` in the output vector. If this constraint is met, `vector-sort`
    performs a stable sort, i.e., two elements are reordered only when necessary according
    to `*predicate*`. `vector-sort!` performs the sort destructively and does not
    necessarily perform a stable sort. Duplicate elements are not removed. `*predicate*`
    should not have any side effects.'
  prefs: []
  type: TYPE_NORMAL
- en: '`vector-sort` may call `*predicate*` up to *n*log*n* times, where *n* is the
    length of `*vector*`, while `vector-sort!` may call the predicate up to *n*² times.
    The looser bound for `vector-sort!` allows an implementation to use a quicksort
    algorithm, which may be faster in some cases than algorithms that have the tighter
    *n*log*n* bound.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(vector-sort < ''#(3 4 2 1 2 5)) ![<graphic>](ch6_0.gif) #(1 2 2 3 4 5)'
  prefs: []
  type: TYPE_NORMAL
- en: (vector-sort > '#(0.5 1/2)) ![<graphic>](ch6_0.gif) #(0.5 1/2)
  prefs: []
  type: TYPE_NORMAL
- en: (vector-sort > '#(1/2 0.5)) ![<graphic>](ch6_0.gif) #(1/2 0.5)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v (vector 3 4 2 1 2 5)])
  prefs: []
  type: TYPE_NORMAL
- en: (vector-sort! < v)
  prefs: []
  type: TYPE_NORMAL
- en: v) ![<graphic>](ch6_0.gif) #(1 2 2 3 4 5)`
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.10\. Bytevectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bytevectors are vectors of raw binary data. Although nominally organized as
    a sequence of exact unsigned 8-bit integers, a bytevector can be interpreted as
    a sequence of exact signed 8-bit integers, exact signed or unsigned 16-bit, 32-bit,
    64-bit, or arbitrary-precision integers, IEEE single or double floating-point
    numbers, or arbitrary combinations of the above.
  prefs: []
  type: TYPE_NORMAL
- en: The length of a bytevector is the number of 8-bit bytes it stores, and indices
    into a bytevector are always given as byte offsets. Any data element may be aligned
    at any byte offset, regardless of the underlying hardware's alignment requirements,
    and may be represented using a specified endianness (see below) that differs from
    that prescribed by the hardware. Special, typically more efficient operators are
    provided for 16-, 32-, and 64-bit integers and single and double floats that are
    in their *native* format, i.e,. with the endianness of the underlying hardware
    and stored at an index that is a multiple of the size in bytes of the integer
    or float.
  prefs: []
  type: TYPE_NORMAL
- en: The endianness of a multi-byte data value determines how it is laid out in memory.
    In *big-endian* format, the value is laid out with the more significant bytes
    at lower indices, while in *little-endian* format, the value is laid out with
    the more significant bytes at higher indices. When a bytevector procedure accepts
    an endianness argument, the argument may be the symbol `big`, representing the
    big-endian format, or the symbol `little`, representing the little-endian format.
    Implementations may extend these procedures to accept other endianness symbols.
    The native endianness of the implementation may be obtained via the procedure
    `native-endianness`.
  prefs: []
  type: TYPE_NORMAL
- en: Bytevectors are written with the `#vu8(` prefix in place of the `#(` prefix
    for vectors, e.g., `#vu8(1 2 3)`. The elements of a bytevector specified in this
    manner are always given as 8-bit unsigned exact integers, i.e., integers from
    0 to 255 inclusive, written using any valid syntax for such numbers. Like strings,
    bytevectors are self-evaluating, so they need not be quoted.
  prefs: []
  type: TYPE_NORMAL
- en: '`''#vu8(1 2 3) ![<graphic>](ch6_0.gif) #vu8(1 2 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '#vu8(1 2 3) ![<graphic>](ch6_0.gif) #vu8(1 2 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '#vu8(#x3f #x7f #xbf #xff) ![<graphic>](ch6_0.gif) #vu8(63 127 191 255)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(endianness *symbol*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*symbol*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*symbol*` must be the symbol `little`, the symbol `big`, or some other symbol
    recognized by the implementation as an endianness symbol. It is a syntax violation
    if `*symbol*` is not a symbol or if it is not recognized by the implementation
    as an endianness symbol.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(endianness little) ![<graphic>](ch6_0.gif) little'
  prefs: []
  type: TYPE_NORMAL
- en: (endianness big) ![<graphic>](ch6_0.gif) big
  prefs: []
  type: TYPE_NORMAL
- en: (endianness "spam") ![<graphic>](ch6_0.gif) *exception*`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(native-endianness)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a symbol naming the implementation''s native endianness'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The return value is the symbol `little`, the symbol `big`, or some other endianness
    symbol recognized by the implementation. It typically reflects the endianness
    of the underlying hardware.
  prefs: []
  type: TYPE_NORMAL
- en: '`(symbol? (native-endianness)) ![<graphic>](ch6_0.gif) #t`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-bytevector *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-bytevector *n* *fill*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new bytevector of length `*n*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*fill*` is supplied, each element of the bytevector is initialized to `*fill*`;
    otherwise, the elements are unspecified. The `*fill*` value must be a signed or
    unsigned 8-bit value, i.e., a value in the range -128 to 255 inclusive. A negative
    fill value is treated as its two's complement equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '`(make-bytevector 0) ![<graphic>](ch6_0.gif) #vu8()'
  prefs: []
  type: TYPE_NORMAL
- en: (make-bytevector 0 7) ![<graphic>](ch6_0.gif) #vu8()
  prefs: []
  type: TYPE_NORMAL
- en: (make-bytevector 5 7) ![<graphic>](ch6_0.gif) #vu8(7 7 7 7 7)
  prefs: []
  type: TYPE_NORMAL
- en: (make-bytevector 5 -7) ![<graphic>](ch6_0.gif) #vu8(249 249 249 249 249)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-length *bytevector*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the length of `*bytevector*` in 8-bit bytes'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector-length #vu8()) ![<graphic>](ch6_0.gif) 0'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-length #vu8(1 2 3)) ![<graphic>](ch6_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-length (make-bytevector 300)) ![<graphic>](ch6_0.gif) 300`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector=? *bytevector[1]* *bytevector[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the relation holds, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: Two bytevectors are equal by `bytevector=?` if and only if they have the same
    length and same contents.
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector=? #vu8() #vu8()) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector=? (make-bytevector 3 0) #vu8(0 0 0)) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector=? (make-bytevector 5 0) #vu8(0 0 0)) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector=? #vu8(1 127 128 255) #vu8(255 128 127 1)) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-fill! *bytevector* *fill*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The `*fill*` value must be a signed or unsigned 8-bit value, i.e., a value in
    the range -128 to 255 inclusive. A negative fill value is treated as its two's
    complement equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '`bytevector-fill!` replaces each element of `*bytevector*` with `*fill*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([v (make-bytevector 6)])'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-fill! v 255)
  prefs: []
  type: TYPE_NORMAL
- en: v) ![<graphic>](ch6_0.gif) #vu8(255 255 255 255 255 255)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v (make-bytevector 6)])
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-fill! v -128)
  prefs: []
  type: TYPE_NORMAL
- en: v) ![<graphic>](ch6_0.gif) #vu8(128 128 128 128 128 128)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-copy *bytevector*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new bytevector that is a copy of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`bytevector-copy` creates a new bytevector with the same length and contents
    as `*bytevector*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector-copy #vu8(1 127 128 255)) ![<graphic>](ch6_0.gif) #vu8(1 127 128 255)'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v #vu8(1 127 128 255)])
  prefs: []
  type: TYPE_NORMAL
- en: (eq? v (bytevector-copy v))) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-copy! *src* *src-start* *dst* *dst-start* *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*src*` and `*dst*` must be bytevectors. `*src-start*`, `*dst-start*`, and
    `*n*` must be exact nonnegative integers. The sum of `*src-start*` and `*n*` must
    not exceed the length of `*src*`, and the sum of `*dst-start*` and `*n*` must
    not exceed the length of `*dst*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`bytevector-copy!` overwrites the `*n*` bytes of `*dst*` starting at `*dst-start*`
    with the `*n*` bytes of `*dst*` starting at `*src-start*`. This works even if
    `*dst*` is the same bytevector as `*src*` and the source and destination locations
    overlap. That is, the destination is filled with the bytes that appeared at the
    source before the operation began.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v1 #vu8(31 63 95 127 159 191 223 255))'
  prefs: []
  type: TYPE_NORMAL
- en: (define v2 (make-bytevector 10 0))
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-copy! v1 2 v2 1 4)
  prefs: []
  type: TYPE_NORMAL
- en: v2 ![<graphic>](ch6_0.gif) #vu8(0 95 127 159 191 0 0 0 0 0)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-copy! v1 5 v2 7 3)
  prefs: []
  type: TYPE_NORMAL
- en: v2 ![<graphic>](ch6_0.gif) #vu8(0 95 127 159 191 0 0 191 223 255)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-copy! v2 3 v2 0 6)
  prefs: []
  type: TYPE_NORMAL
- en: v2 ![<graphic>](ch6_0.gif) #vu8(159 191 0 0 191 223 0 191 223 255)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-copy! v2 0 v2 1 9)
  prefs: []
  type: TYPE_NORMAL
- en: v2 ![<graphic>](ch6_0.gif) #vu8(159 159 191 0 0 191 223 0 191 223)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u8-ref *bytevector* *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 8-bit unsigned byte at index `*n*` (zero-based) of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than the length of `*bytevector*`.'
  prefs: []
  type: TYPE_NORMAL
- en: The value is returned as an exact 8-bit unsigned integer, i.e., a value in the
    range 0 to 255 inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector-u8-ref #vu8(1 127 128 255) 0) ![<graphic>](ch6_0.gif) 1'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u8-ref #vu8(1 127 128 255) 2) ![<graphic>](ch6_0.gif) 128
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u8-ref #vu8(1 127 128 255) 3) ![<graphic>](ch6_0.gif) 255`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s8-ref *bytevector* *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 8-bit signed byte at index `*n*` (zero-based) of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than the length of `*bytevector*`.'
  prefs: []
  type: TYPE_NORMAL
- en: The value returned is an exact 8-bit signed integer, i.e., a value in the range
    -128 to 127 inclusive, and is the equivalent of the stored value treated as a
    two's complement value.
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector-s8-ref #vu8(1 127 128 255) 0) ![<graphic>](ch6_0.gif) 1'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s8-ref #vu8(1 127 128 255) 1) ![<graphic>](ch6_0.gif) 127
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s8-ref #vu8(1 127 128 255) 2) ![<graphic>](ch6_0.gif) -128
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s8-ref #vu8(1 127 128 255) 3) ![<graphic>](ch6_0.gif) -1`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u8-set! *bytevector* *n* *u8*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than the length of `*bytevector*`.
    `*u8*` must be an 8-bit unsigned value, i.e., a value in the range 0 to 255 inclusive.'
  prefs: []
  type: TYPE_NORMAL
- en: '`bytevector-u8-set!` changes the 8-bit value at index `*n*` (zero-based) of
    `*bytevector*` to `*u8*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([v (make-bytevector 5 -1)])'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u8-set! v 2 128)
  prefs: []
  type: TYPE_NORMAL
- en: v) ![<graphic>](ch6_0.gif) #vu8(255 255 128 255 255)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s8-set! *bytevector* *n* *s8*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than the length of `*bytevector*`.
    `*s8*` must be an 8-bit signed value, i.e., a value in the range -128 to 127 inclusive.'
  prefs: []
  type: TYPE_NORMAL
- en: '`bytevector-s8-set!` changes the 8-bit value at index `*n*` (zero-based) of
    `*bytevector*` to the two''s complement equivalent of `*s8*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([v (make-bytevector 4 0)])'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s8-set! v 1 100)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s8-set! v 2 -100)
  prefs: []
  type: TYPE_NORMAL
- en: v) ![<graphic>](ch6_0.gif) #vu8(0 100 156 0)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector->u8-list *bytevector*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a list of the 8-bit unsigned elements of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector->u8-list (make-bytevector 0)) ![<graphic>](ch6_0.gif) ()'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector->u8-list #vu8(1 127 128 255)) ![<graphic>](ch6_0.gif) (1 127 128 255)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v #vu8(1 2 3 255)])
  prefs: []
  type: TYPE_NORMAL
- en: (apply * (bytevector->u8-list v))) ![<graphic>](ch6_0.gif) 1530`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(u8-list->bytevector *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new bytevector of the elements of `*list*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*list*` must consist entirely of exact 8-bit unsigned integers, i.e., values
    in the range 0 to 255 inclusive.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(u8-list->bytevector ''()) ![<graphic>](ch6_0.gif) #vu8()'
  prefs: []
  type: TYPE_NORMAL
- en: (u8-list->bytevector '(1 127 128 255)) ![<graphic>](ch6_0.gif) #vu8(1 127 128 255)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v #vu8(1 2 3 4 5)])
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls (bytevector->u8-list v)])
  prefs: []
  type: TYPE_NORMAL
- en: (u8-list->bytevector (map * ls ls)))) ![<graphic>](ch6_0.gif) #vu8(1 4 9 16 25)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u16-native-ref *bytevector* *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 16-bit unsigned integer at index `*n*` (zero-based) of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s16-native-ref *bytevector* *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 16-bit signed integer at index `*n*` (zero-based) of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u32-native-ref *bytevector* *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 32-bit unsigned integer at index `*n*` (zero-based) of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s32-native-ref *bytevector* *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 32-bit signed integer at index `*n*` (zero-based) of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u64-native-ref *bytevector* *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 64-bit unsigned integer at index `*n*` (zero-based) of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s64-native-ref *bytevector* *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 64-bit signed integer at index `*n*` (zero-based) of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer. It indexes the starting byte of
    the value and must be a multiple of the number of bytes occupied by the value:
    2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of
    `*n*` and the number of bytes occupied by the value must not exceed the length
    of `*bytevector*`. The native endianness is assumed.'
  prefs: []
  type: TYPE_NORMAL
- en: The return value is an exact integer in the appropriate range for the number
    of bytes occupied by the value. Signed values are the equivalent of the stored
    value treated as a two's complement value.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If native endianness is big:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector-u16-native-ref v 2) ![<graphic>](ch6_0.gif) #xfe56'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-native-ref v 2) ![<graphic>](ch6_0.gif) #x-1aa
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-native-ref v 6) ![<graphic>](ch6_0.gif) #x7898
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u32-native-ref v 0) ![<graphic>](ch6_0.gif) #x1234fe56
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-native-ref v 0) ![<graphic>](ch6_0.gif) #x1234fe56
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-native-ref v 4) ![<graphic>](ch6_0.gif) #x-23458768
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u64-native-ref v 0) ![<graphic>](ch6_0.gif) #x1234fe56dcba7898
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s64-native-ref v 0) ![<graphic>](ch6_0.gif) #x1234fe56dcba7898`
  prefs: []
  type: TYPE_NORMAL
- en: 'If native endianness is little:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector-u16-native-ref v 2) ![<graphic>](ch6_0.gif) #x56fe'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-native-ref v 2) ![<graphic>](ch6_0.gif) #x56fe
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-native-ref v 6) ![<graphic>](ch6_0.gif) #x-6788
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u32-native-ref v 0) ![<graphic>](ch6_0.gif) #x56fe3412
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-native-ref v 0) ![<graphic>](ch6_0.gif) #x56fe3412
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-native-ref v 4) ![<graphic>](ch6_0.gif) #x-67874524
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u64-native-ref v 0) ![<graphic>](ch6_0.gif) #x9878badc56fe3412
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s64-native-ref v 0) ![<graphic>](ch6_0.gif) #x-67874523a901cbee`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u16-native-set! *bytevector* *n* *u16*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s16-native-set! *bytevector* *n* *s16*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u32-native-set! *bytevector* *n* *u32*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s32-native-set! *bytevector* *n* *s32*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u64-native-set! *bytevector* *n* *u64*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s64-native-set! *bytevector* *n* *s64*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer. It indexes the starting byte of
    the value and must be a multiple of the number of bytes occupied by the value:
    2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of
    `*n*` and the number of bytes occupied by the value must not exceed the length
    `*bytevector*`. `*u16*` must be a 16-bit unsigned value, i.e., a value in the
    range 0 to 2^(16) - 1 inclusive; `*s16*` must be a 16-bit signed value, i.e.,
    a value in the range -2^(15) to 2^(15) - 1 inclusive; `*u32*` must be a 32-bit
    unsigned value, i.e., a value in the range 0 to 2^(32) - 1 inclusive; `*s32*`
    must be a 32-bit signed value, i.e., a value in the range -2^(31) to 2^(31) -
    1 inclusive; `*u64*` must be a 64-bit unsigned value, i.e., a value in the range
    0 to 2^(64) - 1 inclusive; and `*s64*` must be a 64-bit signed value, i.e., a
    value in the range -2^(63) to 2^(63) - 1 inclusive. The native endianness is assumed.'
  prefs: []
  type: TYPE_NORMAL
- en: These procedures store the given value in the 2, 4, or 8 bytes starting at index
    `*n*` (zero-based) of `*bytevector*`. Negative values are stored as their two's
    complement equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v (make-bytevector 8 0))'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u16-native-set! v 0 #xfe56)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-native-set! v 2 #x-1aa)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-native-set! v 4 #x7898)`
  prefs: []
  type: TYPE_NORMAL
- en: 'If native endianness is big:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v ![<graphic>](ch6_0.gif) #vu8(#xfe #x56 #xfe #x56 #x78 #x98 #x00 #x00)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If native endianness is little:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v ![<graphic>](ch6_0.gif) #vu8(#x56 #xfe #x56 #xfe #x98 #x78 #x00 #x00)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v (make-bytevector 16 0))'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u32-native-set! v 0 #x1234fe56)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-native-set! v 4 #x1234fe56)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-native-set! v 8 #x-23458768)`
  prefs: []
  type: TYPE_NORMAL
- en: 'If native endianness is big:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v ![<graphic>](ch6_0.gif) #vu8(#x12 #x34 #xfe #x56 #x12 #x34 #xfe #x56'
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #xdc #xba #x78 #x98 #x00 #x00 #x00 #x00)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If native endianness is little:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v ![<graphic>](ch6_0.gif) #vu8(#x56 #xfe #x34 #x12 #x56 #xfe #x34 #x12'
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x98 #x78 #xba #xdc #x00 #x00 #x00 #x00)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v (make-bytevector 24 0))'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u64-native-set! v 0 #x1234fe56dcba7898)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s64-native-set! v 8 #x1234fe56dcba7898)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s64-native-set! v 16 #x-67874523a901cbee)`
  prefs: []
  type: TYPE_NORMAL
- en: 'If native endianness is big:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v ![<graphic>](ch6_0.gif) #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98'
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98'
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If native endianness is little:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v ![<graphic>](ch6_0.gif) #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12'
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12'
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u16-ref *bytevector* *n* *eness*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 16-bit unsigned integer at index `*n*` (zero-based) of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s16-ref *bytevector* *n* *eness*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 16-bit signed integer at index `*n*` (zero-based) of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u32-ref *bytevector* *n* *eness*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 32-bit unsigned integer at index `*n*` (zero-based) of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s32-ref *bytevector* *n* *eness*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 32-bit signed integer at index `*n*` (zero-based) of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u64-ref *bytevector* *n* *eness*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 64-bit unsigned integer at index `*n*` (zero-based) of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s64-ref *bytevector* *n* *eness*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 64-bit signed integer at index `*n*` (zero-based) of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer and indexes the starting byte of
    the value. The sum of `*n*` and the number of bytes occupied by the value (2 for
    16-bit values, 4 for 32-bit values, and 8 for 32-bit values) must not exceed the
    length of `*bytevector*`. `*n*` need *not* be a multiple of the number of bytes
    occupied by the value. `*eness*` must be a valid endianness symbol naming the
    endianness.'
  prefs: []
  type: TYPE_NORMAL
- en: The return value is an exact integer in the appropriate range for the number
    of bytes occupied by the value. Signed values are the equivalent of the stored
    value treated as a two's complement value.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u16-ref v 0 (endianness big)) ![<graphic>](ch6_0.gif) #x1234
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-ref v 1 (endianness big)) ![<graphic>](ch6_0.gif) #x34fe
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-ref v 5 (endianness big)) ![<graphic>](ch6_0.gif) #x-4588
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u32-ref v 2 'big) ![<graphic>](ch6_0.gif) #xfe56dcba
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-ref v 3 'big) ![<graphic>](ch6_0.gif) #x56dcba78
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-ref v 4 'big) ![<graphic>](ch6_0.gif) #x-23458768
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u64-ref v 0 'big) ![<graphic>](ch6_0.gif) #x1234fe56dcba7898
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s64-ref v 1 'big) ![<graphic>](ch6_0.gif) #x34fe56dcba78989a
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u16-ref v 0 (endianness little)) ![<graphic>](ch6_0.gif) #x3412
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-ref v 1 (endianness little)) ![<graphic>](ch6_0.gif) #x-1cc
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-ref v 5 (endianness little)) ![<graphic>](ch6_0.gif) #x78ba
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u32-ref v 2 'little) ![<graphic>](ch6_0.gif) #xbadc56fe
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-ref v 3 'little) ![<graphic>](ch6_0.gif) #x78badc56
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-ref v 4 'little) ![<graphic>](ch6_0.gif) #x-67874524
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u64-ref v 0 'little) ![<graphic>](ch6_0.gif) #x9878badc56fe3412
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s64-ref v 1 'little) ![<graphic>](ch6_0.gif) #x-6567874523a901cc`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u16-set! *bytevector* *n* *u16* *eness*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s16-set! *bytevector* *n* *s16* *eness*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u32-set! *bytevector* *n* *u32* *eness*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s32-set! *bytevector* *n* *s32* *eness*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u64-set! *bytevector* *n* *u64* *eness*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s64-set! *bytevector* *n* *s64* *eness*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer and indexes the starting byte of
    the value. The sum of `*n*` and the number of bytes occupied by the value must
    not exceed the length of `*bytevector*`. `*n*` need *not* be a multiple of the
    number of bytes occupied by the value. `*u16*` must be a 16-bit unsigned value,
    i.e., a value in the range 0 to 2^(16) - 1 inclusive; `*s16*` must be a 16-bit
    signed value, i.e., a value in the range -2^(15) to 2^(15) - 1 inclusive; `*u32*`
    must be a 32-bit unsigned value, i.e., a value in the range 0 to 2^(32) - 1 inclusive;
    `*s32*` must be a 32-bit signed value, i.e., a value in the range -2^(31) to 2^(31)
    - 1 inclusive; `*u64*` must be a 64-bit unsigned value, i.e., a value in the range
    0 to 2^(64) - 1 inclusive; and `*s64*` must be a 64-bit signed value, i.e., a
    value in the range -2^(63) to 2^(63) - 1 inclusive. `*eness*` must be a valid
    endianness symbol naming the endianness.'
  prefs: []
  type: TYPE_NORMAL
- en: These procedures store the given value in the 2, 4, or 8 bytes starting at index
    `*n*` (zero-based) of `*bytevector*`. Negative values are stored as their two's
    complement equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v (make-bytevector 8 0))'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u16-set! v 0 #xfe56 (endianness big))
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-set! v 3 #x-1aa (endianness little))
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-set! v 5 #x7898 (endianness big))
  prefs: []
  type: TYPE_NORMAL
- en: v ![<graphic>](ch6_0.gif) #vu8(#xfe #x56 #x0 #x56 #xfe #x78 #x98 #x0)
  prefs: []
  type: TYPE_NORMAL
- en: (define v (make-bytevector 16 0))
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u32-set! v 0 #x1234fe56 'little)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-set! v 6 #x1234fe56 'big)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-set! v 11 #x-23458768 'little)
  prefs: []
  type: TYPE_NORMAL
- en: v ![<graphic>](ch6_0.gif) #vu8(#x56 #xfe #x34 #x12 #x0 #x0
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x12 #x34 #xfe #x56 #x0'
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x98 #x78 #xba #xdc #x0)'
  prefs: []
  type: TYPE_IMG
- en: (define v (make-bytevector 28 0))
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u64-set! v 0 #x1234fe56dcba7898 'little)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s64-set! v 10 #x1234fe56dcba7898 'big)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s64-set! v 19 #x-67874523a901cbee 'big)
  prefs: []
  type: TYPE_NORMAL
- en: v ![<graphic>](ch6_0.gif) #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0 #x0
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x0'
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-uint-ref *bytevector* *n* *eness* *size*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the `*size*`-byte unsigned integer at index `*n*` (zero-based)
    of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-sint-ref *bytevector* *n* *eness* *size*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the `*size*`-byte signed integer at index `*n*` (zero-based) of
    `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer and indexes the starting byte of
    the value. `*size*` must be an exact positive integer and specifies the number
    of bytes occupied by the value. The sum of `*n*` and `*size*` must not exceed
    the length of `*bytevector*`. `*n*` need *not* be a multiple of the number of
    bytes occupied by the value. `*eness*` must be a valid endianness symbol naming
    the endianness.'
  prefs: []
  type: TYPE_NORMAL
- en: The return value is an exact integer in the appropriate range for the number
    of bytes occupied by the value. Signed values are the equivalent of the stored
    value treated as a two's complement value.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-uint-ref v 0 'big 1) ![<graphic>](ch6_0.gif) #x12
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-uint-ref v 0 'little 1) ![<graphic>](ch6_0.gif) #x12
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-uint-ref v 1 'big 3) ![<graphic>](ch6_0.gif) #x34fe56
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-uint-ref v 2 'little 7) ![<graphic>](ch6_0.gif) #x9a9878badc56fe
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-sint-ref v 2 'big 1) ![<graphic>](ch6_0.gif) #x-02
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-sint-ref v 1 'little 6) ![<graphic>](ch6_0.gif) #x78badc56fe34
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-sint-ref v 2 'little 7) ![<graphic>](ch6_0.gif) #x-6567874523a902
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-sint-ref (make-bytevector 1000 -1) 0 'big 1000) ![<graphic>](ch6_0.gif) -1`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-uint-set! *bytevector* *n* *uint* *eness* *size*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-sint-set! *bytevector* *n* *sint* *eness* *size*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer and indexes the starting byte of
    the value. `*size*` must be an exact positive integer and specifies the number
    of bytes occupied by the value. The sum of `*n*` and `*size*` must not exceed
    the length of `*bytevector*`. `*n*` need *not* be a multiple of the number of
    bytes occupied by the value. `*uint*` must be an exact integer in the range 0
    to 2^(*size*·8) - 1 inclusive. `*sint*` must be an exact integer in the range
    -2^(*size*·8-1) to 2^(*size*·8-1) - 1 inclusive. `*eness*` must be a valid endianness
    symbol naming the endianness.'
  prefs: []
  type: TYPE_NORMAL
- en: These procedures store the given value in the `*size*` bytes starting at index
    `*n*` (zero-based) of `*bytevector*`. Negative values are stored as their two's
    complement equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v (make-bytevector 5 0))'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-uint-set! v 1 #x123456 (endianness big) 3)
  prefs: []
  type: TYPE_NORMAL
- en: v ![<graphic>](ch6_0.gif) #vu8(0 #x12 #x34 #x56 0)
  prefs: []
  type: TYPE_NORMAL
- en: (define v (make-bytevector 7 -1))
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-sint-set! v 1 #x-8000000000 (endianness little) 5)
  prefs: []
  type: TYPE_NORMAL
- en: v ![<graphic>](ch6_0.gif) #vu8(#xff 0 0 0 0 #x80 #xff)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector->uint-list *bytevector* *eness* *size*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new list of the `*size*`-bit unsigned elements of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector->sint-list *bytevector* *eness* *size*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new list of the `*size*`-bit signed elements of `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*eness*` must be a valid endianness symbol naming the endianness. `*size*`
    must be an exact positive integer and specifies the number of bytes occupied by
    the value. It must be a value that evenly divides the length of `*bytevector*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector->uint-list (make-bytevector 0) ''little 3) ![<graphic>](ch6_0.gif) ()'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v #vu8(1 2 3 4 5 6)])
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector->uint-list v 'big 3)) ![<graphic>](ch6_0.gif) (#x010203 #x040506)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v (make-bytevector 80 -1)])
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector->sint-list v 'big 20)) ![<graphic>](ch6_0.gif) (-1 -1 -1 -1)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(uint-list->bytevector *list* *eness* *size*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(sint-list->bytevector *list* *eness* *size*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new bytevector of the elements of `*list*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*eness*` must be a valid endianness symbol naming the endianness. `*size*`
    must be an exact positive integer and specifies the number of bytes occupied by
    the value. For `uint-list->bytevector`, `*list*` must consist entirely of `*size*`-byte
    exact unsigned integers, i.e., values in the range 0 to 2^(*size*·8) - 1 inclusive.
    For `sint-list->bytevector`, `*list*` must consist entirely of `*size*`-byte exact
    signed integers, i.e., values in the range -2^(*size*·8-1) to 2^(*size*·8-1) -
    1 inclusive. Each value occupies `*size*` bytes in the resulting bytevector, whose
    length is thus `*size*` times the length of `*list*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(uint-list->bytevector ''() ''big 25) ![<graphic>](ch6_0.gif) #vu8()'
  prefs: []
  type: TYPE_NORMAL
- en: (sint-list->bytevector '(0 -1) 'big 3) ![<graphic>](ch6_0.gif) #vu8(0 0 0 #xff #xff #xff)
  prefs: []
  type: TYPE_NORMAL
- en: (define (f size)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls (list (- (expt 2 (- (* 8 size) 1)))
  prefs: []
  type: TYPE_NORMAL
- en: (- (expt 2 (- (* 8 size) 1)) 1))])
  prefs: []
  type: TYPE_NORMAL
- en: (sint-list->bytevector ls 'little size)))
  prefs: []
  type: TYPE_NORMAL
- en: (f 6) ![<graphic>](ch6_0.gif) #vu8(#x00 #x00 #x00 #x00 #x00 #x80
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #xff #xff #xff #xff #xff #x7f)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-ieee-single-native-ref *bytevector* *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the single floating-point value at index `*n*` (zero-based) of
    `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-ieee-double-native-ref *bytevector* *n*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the double floating-point value at index `*n*` (zero-based) of
    `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer. It indexes the starting byte of
    the value and must be a multiple of the number of bytes occupied by the value:
    4 for single floats, 8 for double. The sum of `*n*` and the number of bytes occupied
    by the value must not exceed the length of `*bytevector*`. The native endianness
    is assumed.'
  prefs: []
  type: TYPE_NORMAL
- en: The return value is an inexact real number. Examples appear after the mutation
    operators below.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-ieee-single-native-set! *bytevector* *n* *x*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-ieee-double-native-set! *bytevector* *n* *x*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer. It indexes the starting byte of
    the value and must be a multiple of the number of bytes occupied by the value:
    4 for single floats, 8 for double. The sum of `*n*` and the number of bytes occupied
    by the value must not exceed the length of `*bytevector*`. The native endianness
    is assumed.'
  prefs: []
  type: TYPE_NORMAL
- en: These procedures store the given value as an IEEE-754 single or double floating-point
    value at index `*n*` (zero-based) of `*bytevector*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v (make-bytevector 8 0))'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-single-native-set! v 0 .125)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-single-native-set! v 4 -3/2)
  prefs: []
  type: TYPE_NORMAL
- en: (list
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-single-native-ref v 0)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-single-native-ref v 4)) ![<graphic>](ch6_0.gif) (0.125 -1.5)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-double-native-set! v 0 1e23)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-double-native-ref v 0) ![<graphic>](ch6_0.gif) 1e23`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-ieee-single-ref *bytevector* *n* *eness*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the single floating-point value at index `*n*` (zero-based) of
    `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-ieee-double-ref *bytevector* *n* *eness*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the double floating-point value at index `*n*` (zero-based) of
    `*bytevector*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer and indexes the starting byte of
    the value. The sum of `*n*` and the number of bytes occupied by the value (4 for
    a single float, 8 for a double) must not exceed the length of `*bytevector*`.
    `*n*` need *not* be a multiple of the number of bytes occupied by the value. `*eness*`
    must be a valid endianness symbol naming the endianness.'
  prefs: []
  type: TYPE_NORMAL
- en: The return value is an inexact real number. Examples appear after the mutation
    operators below.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-ieee-single-set! *bytevector* *n* *x* *eness*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-ieee-double-set! *bytevector* *n* *x* *eness*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer and indexes the starting byte of
    the value. The sum of `*n*` and the number of bytes occupied by the value (4 for
    a single float, 8 for a double) must not exceed the length of `*bytevector*`.
    `*n*` need *not* be a multiple of the number of bytes occupied by the value. `*eness*`
    must be a valid endianness symbol naming the endianness.'
  prefs: []
  type: TYPE_NORMAL
- en: These procedures store the given value as an IEEE-754 single or double floating-point
    value at index `*n*` (zero-based) of `*bytevector*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v (make-bytevector 10 #xc7))'
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-single-set! v 1 .125 'little)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-single-set! v 6 -3/2 'big)
  prefs: []
  type: TYPE_NORMAL
- en: (list
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-single-ref v 1 'little)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-single-ref v 6 'big)) ![<graphic>](ch6_0.gif) (0.125 -1.5)
  prefs: []
  type: TYPE_NORMAL
- en: v ![<graphic>](ch6_0.gif) #vu8(#xc7 #x0 #x0 #x0 #x3e #xc7 #xbf #xc0 #x0 #x0)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-double-set! v 1 1e23 'big)
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-double-ref v 1 'big) ![<graphic>](ch6_0.gif) 1e23`
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.11\. Symbols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Symbols are used for a variety of purposes as symbolic names in Scheme programs.
    Strings could be used for most of the same purposes, but an important characteristic
    of symbols makes comparisons between symbols much more efficient. This characteristic
    is that two symbols with the same name are identical in the sense of `eq?`. The
    reason is that the Scheme reader (invoked by `get-datum` and `read`) and the procedure
    `string->symbol` catalog symbols in an internal symbol table and always return
    the same symbol whenever the same name is encountered. Thus, no character-by-character
    comparison is needed, as would be needed to compare two strings.
  prefs: []
  type: TYPE_NORMAL
- en: The property that two symbols may be compared quickly for equivalence makes
    them ideally suited for use as identifiers in the representation of programs,
    allowing fast comparison of identifiers. This property also makes symbols useful
    for a variety of other purposes. For example, symbols might be used as messages
    passed between procedures, labels for list-structured records, or names for objects
    stored in an association list (see `assq` in Section [6.3](objects.html#g109)).
  prefs: []
  type: TYPE_NORMAL
- en: Symbols are written without double quotes or other bracketing characters. Parentheses,
    double quotes, spaces, and most other characters with a special meaning to the
    Scheme reader are not allowed within the printed representation of a symbol. These
    and any other Unicode character may appear anywhere within the printed representation
    of a symbol with the syntax `#\x*n*;`, where `*n*` consists of one or more hexadecimal
    digits and represents a valid Unicode scalar value.
  prefs: []
  type: TYPE_NORMAL
- en: The grammar for symbols on page [458](grammar.html#grammar:symbols) gives a
    precise definition of the syntax of symbols.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(symbol=? *symbol[1]* *symbol[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the two symbols are the same, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: Symbols can also be compared with `eq?`, which is typically more efficient than
    `symbol=?`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(symbol=? ''a ''a) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (symbol=? 'a (string->symbol "a")) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (symbol=? 'a 'b) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string->symbol *string*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a symbol whose name is `*string*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`string->symbol` records all symbols it creates in an internal table that it
    shares with the system reader. If a symbol whose name is equivalent to string
    (according to the predicate `string=?`) already exists in the table, this symbol
    is returned. Otherwise, a new symbol is created with `*string*` as its name; this
    symbol is entered into the table and returned.'
  prefs: []
  type: TYPE_NORMAL
- en: The effect of modifying a string after it is used as an argument to `string->symbol`
    is unspecified.
  prefs: []
  type: TYPE_NORMAL
- en: '`(string->symbol "x") ![<graphic>](ch6_0.gif) x'
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (string->symbol "x") 'x) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (string->symbol "X") 'x) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (string->symbol "x")
  prefs: []
  type: TYPE_NORMAL
- en: (string->symbol "x")) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (string->symbol "()") ![<graphic>](ch6_0.gif) \x28;\x29;`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(symbol->string *symbol*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a string, the name of `*symbol*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The string returned by `symbol->string` should be treated as immutable. Unpredictable
    behavior can result if a string passed to `string->symbol` is altered with `string-set!`
    or by any other means.
  prefs: []
  type: TYPE_NORMAL
- en: '`(symbol->string ''xyz) ![<graphic>](ch6_0.gif) "xyz"'
  prefs: []
  type: TYPE_NORMAL
- en: (symbol->string 'Hi) ![<graphic>](ch6_0.gif) "Hi"
  prefs: []
  type: TYPE_NORMAL
- en: (symbol->string (string->symbol "()")) ![<graphic>](ch6_0.gif) "()"`
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.12\. Booleans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While every Scheme object has a truth value when used in a conditional context,
    with every object but `#f` counting as true, Scheme provides the dedicated true
    value `#t` for use when a value of an expression should convey nothing more than
    that it is true.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(boolean=? *boolean[1]* *boolean[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the two booleans are the same, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The boolean values `#t` and `#f` may also be compared with `eq?`, which is typically
    more efficient than `boolean=?`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(boolean=? #t #t) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (boolean=? #t #f) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (boolean=? #t (< 3 4)) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.13\. Hashtables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hashtables represent sets of associations between arbitrary Scheme values. They
    serve essentially the same purpose as association lists (see page  [165](objects.html#page:assq))
    but are typically much faster when large numbers of associations are involved.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-eq-hashtable)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-eq-hashtable *size*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new mutable eq hashtable'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*size*` is provided, it must be a nonnegative exact integer indicating approximately
    how many elements the hashtable should initially hold. Hashtables grow as needed,
    but when the hashtable grows it generally must rehash all of the existing elements.
    Providing a nonzero `*size*` can help limit the amount of rehashing that must
    be done as the table is initially populated.
  prefs: []
  type: TYPE_NORMAL
- en: An eq hashtable compares keys using the `eq?` (pointer equality) procedure and
    typically employs a hash function based on object addresses. Its hash and equivalence
    functions are suitable for any Scheme object.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht1 (make-eq-hashtable))'
  prefs: []
  type: TYPE_NORMAL
- en: (define ht2 (make-eq-hashtable 32))`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-eqv-hashtable)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-eqv-hashtable *size*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new mutable eqv hashtable'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*size*` is provided, it must be a nonnegative exact integer indicating approximately
    how many elements the hashtable should initially hold. Hashtables grow as needed,
    but when the hashtable grows it generally must rehash all of the existing elements.
    Providing a nonzero `*size*` can help limit the amount of rehashing that must
    be done as the table is initially populated.
  prefs: []
  type: TYPE_NORMAL
- en: An eqv hashtable compares keys using the `eqv?` procedure and typically employs
    a hash function based on object addresses for objects that are identifiable with
    `eq?`. Its hash and equivalence functions are suitable for any Scheme object.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-hashtable *hash* *equiv?*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-hashtable *hash* *equiv?* *size*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new mutable hashtable'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*hash*` and `*equiv?*` must be procedures. If `*size*` is provided, it must
    be a nonnegative exact integer indicating approximately how many elements the
    hashtable should initially hold. Hashtables grow as needed, but when the hashtable
    grows it generally must rehash all of the existing elements. Providing a nonzero
    `*size*` can help limit the amount of rehashing that must be done as the table
    is initially populated.'
  prefs: []
  type: TYPE_NORMAL
- en: The new hashtable computes hash values using `*hash*` and compares keys using
    `*equiv?*`, neither of which should modify the hashtable. `*equiv?*` should compare
    two keys and return false only if the two keys should be distinguished. `*hash*`
    should accept a key as an argument and return a nonnegative exact integer value
    that is the same each time it is called with arguments that `*equiv?*` does not
    distinguish. The `*hash*` and `*equiv?*` procedures need not accept arbitrary
    inputs as long as the hashtable is used only for keys that they do accept, and
    both procedures may assume that the keys are immutable as long as the keys are
    not modified while they have associations stored in the table. The hashtable operation
    may call `*hash*` and `*equiv?*` once, not at all, or multiple times for each
    hashtable operation.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-hashtable string-hash string=?))`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-mutable? *hashtable*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*hashtable*` is mutable, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: Hashtables returned by one of the hashtable creation procedures above are mutable,
    but those created by `hashtable-copy` may be immutable. Immutable hashtables cannot
    be altered by any of the procedures `hashtable-set!`, `hashtable-update!`, `hashtable-delete!`,
    or `hashtable-clear!`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(hashtable-mutable? (make-eq-hashtable)) ![<graphic>](ch6_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-mutable? (hashtable-copy (make-eq-hashtable))) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-hash-function *hashtable*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the hash function associated with `*hashtable*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-equivalence-function *hashtable*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the equivalence function associated with `*hashtable*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtable-hash-function` returns `#f` for eq and eqv hashtables.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-hash-function ht) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (hashtable-equivalence-function ht) eq?) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (define ht (make-hashtable string-hash string=?))
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (hashtable-hash-function ht) string-hash) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (hashtable-equivalence-function ht) string=?) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(equal-hash *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-hash *string*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-ci-hash *string*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(symbol-hash *symbol*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** an exact nonnegative integer hash value'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'These procedures are hash functions suitable for use with the appropriate Scheme
    predicate: `equal?` for `equal-hash`, `string=?` for `string-hash`, `string-ci=?`
    for `string-ci-hash`, and `symbol=?` (or eq?) for `symbol-hash`. The hash values
    returned by `equal-hash`, `string-hash`, and `string-ci-hash` are typically dependent
    on the current structure and contents of the input values and are thus unsuitable
    if keys are modified while they have associations in a hashtable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-set! *hashtable* *key* *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*hashtable*` must be a mutable hashtable. `*key*` should be an appropriate
    key for the hashtable''s hash and equivalence functions. `*obj*` may be any Scheme
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtable-set!` associates `*key*` with `*obj*` in `*hashtable*`, replacing
    the existing association, if any.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht 'a 73)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-ref *hashtable* *key* *default*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*key*` should be an appropriate key for the hashtable''s hash and equivalence
    functions. `*default*` may be any Scheme object.'
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtable-ref` returns the value associated with `*key*` in `*hashtable*`.
    If no value is associated with `*key*` in `*hashtable*`, `hashtable-ref` returns
    `*default*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define p1 (cons ''a ''b))'
  prefs: []
  type: TYPE_NORMAL
- en: (define p2 (cons 'a 'b))
  prefs: []
  type: TYPE_NORMAL
- en: (define eqht (make-eq-hashtable))
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! eqht p1 73)
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref eqht p1 55) ![<graphic>](ch6_0.gif) 73
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref eqht p2 55) ![<graphic>](ch6_0.gif) 55
  prefs: []
  type: TYPE_NORMAL
- en: (define equalht (make-hashtable equal-hash equal?))
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! equalht p1 73)
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref equalht p1 55) ![<graphic>](ch6_0.gif) 73
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref equalht p2 55) ![<graphic>](ch6_0.gif) 73`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-contains? *hashtable* *key*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if an association for `*key*` exists in `*hashtable*`, `#f`
    otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*key*` should be an appropriate key for the hashtable''s hash and equivalence
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  prefs: []
  type: TYPE_NORMAL
- en: (define p1 (cons 'a 'b))
  prefs: []
  type: TYPE_NORMAL
- en: (define p2 (cons 'a 'b))
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p1 73)
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-contains? ht p1) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-contains? ht p2) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-update! *hashtable* *key* *procedure* *default*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*hashtable*` must be a mutable hashtable. `*key*` should be an appropriate
    key for the hashtable''s hash and equivalence functions. `*default*` may be any
    Scheme object. `*procedure*` should accept one argument, should return one value,
    and should not modify `*hashtable*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtable-update!` applies `*procedure*` to the value associated with `*key*`
    in `*hashtable*`, or to `*default*` if no value is associated with `*key*` in
    `*hashtable*`. If `*procedure*` returns, `hashtable-update!` associates `*key*`
    with the value returned by `*procedure*`, replacing the old association, if any.'
  prefs: []
  type: TYPE_NORMAL
- en: A version of `hashtable-update!` that does not verify that it receives arguments
    of the proper type might be defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define hashtable-update!'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ht key proc value)
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht key
  prefs: []
  type: TYPE_NORMAL
- en: (proc (hashtable-ref ht key value)))))`
  prefs: []
  type: TYPE_NORMAL
- en: An implementation may, however, be able to implement `hashtable-update!` more
    efficiently by avoiding multiple hash computations and hashtable lookups.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-update! ht 'a
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x) (* x 2))
  prefs: []
  type: TYPE_NORMAL
- en: 55)
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref ht 'a 0) ![<graphic>](ch6_0.gif) 110
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-update! ht 'a
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x) (* x 2))
  prefs: []
  type: TYPE_NORMAL
- en: 0)
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref ht 'a 0) ![<graphic>](ch6_0.gif) 220`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-delete! *hashtable* *key*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*hashtable*` must be a mutable hashtable. `*key*` should be an appropriate
    key for the hashtable''s hash and equivalence functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtable-delete!` drops any association for `*key*` from `*hashtable*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  prefs: []
  type: TYPE_NORMAL
- en: (define p1 (cons 'a 'b))
  prefs: []
  type: TYPE_NORMAL
- en: (define p2 (cons 'a 'b))
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p1 73)
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-contains? ht p1) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-delete! ht p1)
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-contains? ht p1) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-contains? ht p2) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-delete! ht p2)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-size *hashtable*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** number of entries in `*hashtable*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  prefs: []
  type: TYPE_NORMAL
- en: (define p1 (cons 'a 'b))
  prefs: []
  type: TYPE_NORMAL
- en: (define p2 (cons 'a 'b))
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-size ht) ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p1 73)
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-size ht) ![<graphic>](ch6_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-delete! ht p1)
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-size ht) ![<graphic>](ch6_0.gif) 0`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-copy *hashtable*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-copy *hashtable* *mutable?*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new hashtable containing the same entries as `*hashtable*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*mutable?*` is present and not false, the copy is mutable; otherwise, the
    copy is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  prefs: []
  type: TYPE_NORMAL
- en: (define p1 (cons 'a 'b))
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p1 "c")
  prefs: []
  type: TYPE_NORMAL
- en: (define ht-copy (hashtable-copy ht))
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-mutable? ht-copy) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-delete! ht p1)
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref ht p1 #f) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-delete! ht-copy p1) ![<graphic>](ch6_0.gif) *exception: not mutable*
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref ht-copy p1 #f) ![<graphic>](ch6_0.gif) "c"`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-clear! *hashtable*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-clear! *hashtable* *size*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*hashtable*` must be a mutable hashtable. If `*size*` is provided, it must
    be a nonnegative exact integer.'
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtable-clear!` removes all entries from `*hashtable*`. If size is provided,
    the hashtable is reset to the given size, as if newly created by one of the hashtable
    creation operations with size argument `*size*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  prefs: []
  type: TYPE_NORMAL
- en: (define p1 (cons 'a 'b))
  prefs: []
  type: TYPE_NORMAL
- en: (define p2 (cons 'a 'b))
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p1 "first")
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p2 "second")
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-size ht) ![<graphic>](ch6_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-clear! ht)
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-size ht) ![<graphic>](ch6_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref ht p1 #f) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-keys *hashtable*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a vector containing the keys in `*hashtable*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The keys may appear in any order in the returned vector.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  prefs: []
  type: TYPE_NORMAL
- en: (define p1 (cons 'a 'b))
  prefs: []
  type: TYPE_NORMAL
- en: (define p2 (cons 'a 'b))
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p1 "one")
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p2 "two")
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht 'q "three")
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-keys ht) ![<graphic>](ch6_0.gif) #((a . b) q (a . b))`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-entries *hashtable*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** two vectors: one of keys and a second of values'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtable-entries` returns two values. The first is a vector containing the
    keys in `*hashtable*`, and the second is a vector containing the corresponding
    values. The keys and values may appear in any order, but the order is the same
    for the keys and for the corresponding values.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  prefs: []
  type: TYPE_NORMAL
- en: (define p1 (cons 'a 'b))
  prefs: []
  type: TYPE_NORMAL
- en: (define p2 (cons 'a 'b))
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p1 "one")
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p2 "two")
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht 'q "three")
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-entries ht) ![<graphic>](ch6_0.gif) #((a . b) q (a . b))
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) #("two" "three" "one")`'
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.14\. Enumerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enumerations are ordered sets of symbols, typically used to name and manipulate
    options, as with the buffer modes and file options that may be specified when
    files are created.
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(define-enumeration *name* (*symbol* ...) *constructor*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: A `define-enumeration` form is a definition and can appear anywhere any other
    definition can appear.
  prefs: []
  type: TYPE_NORMAL
- en: The `define-enumeration` syntax creates a new enumeration set with the specified
    symbols in the specified order forming the enumeration's universe. It defines
    a new syntactic form named by `*name*` that may be used to verify that a symbol
    is in the universe. If `*x*` is in the universe, `(*name *x**)` evaluates to `*x*`.
    It is a syntax violation if `*x*` is not in the universe.
  prefs: []
  type: TYPE_NORMAL
- en: '`define-enumeration` also defines a new syntactic form named by `*constructor*`
    that may be used to create subsets of the enumeration type. If `*x* ...` are each
    in the universe, `*(constructor *x** ...)` evaluates to an enumeration set containing
    `*x* ...`. Otherwise, it is a syntax violation. The same symbol may appear more
    than once in `*x* ...`, but the resulting set contains only one occurrence of
    the symbol.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-enumeration weather-element'
  prefs: []
  type: TYPE_NORMAL
- en: (hot warm cold sunny rainy snowy windy)
  prefs: []
  type: TYPE_NORMAL
- en: weather)
  prefs: []
  type: TYPE_NORMAL
- en: (weather-element hot) ![<graphic>](ch6_0.gif) hot
  prefs: []
  type: TYPE_NORMAL
- en: (weather-element fun) ![<graphic>](ch6_0.gif) *syntax violation*
  prefs: []
  type: TYPE_NORMAL
- en: (weather hot sunny windy) ![<graphic>](ch6_0.gif) #<enum-set>
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (weather rainy cold rainy)) ![<graphic>](ch6_0.gif) (cold rainy)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-enumeration *symbol-list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** an enumeration set'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: This procedure creates a new enumeration type whose universe comprises the elements
    of `*symbol-list*`, which must be a list of symbols, in the order of their first
    appearance in the list. It returns the universe of the new enumeration type as
    an enumeration set.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define positions (make-enumeration ''(top bottom above top beside)))'
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list positions) ![<graphic>](ch6_0.gif) (top bottom above beside)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-constructor *enum-set*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** an enumeration-set construction procedure'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: This procedure returns a procedure `*p*` that may be used to create subsets
    of the universe of `*enum-set*`. `*p*` must be passed a list of symbols, and each
    element of the list must be an element of the universe of `*enum-set*`. The enumeration
    set returned by `*p*` contains all and only the symbols in the list it is passed.
    The value returned by `*p*` may contain elements not in `*enum-set*` if the universe
    of `*enum-set*` contains those elements.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(one two three four)))'
  prefs: []
  type: TYPE_NORMAL
- en: (define p1 (enum-set-constructor e1))
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 (p1 '(one three)))
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list e2) ![<graphic>](ch6_0.gif) (one three)
  prefs: []
  type: TYPE_NORMAL
- en: (define p2 (enum-set-constructor e2))
  prefs: []
  type: TYPE_NORMAL
- en: (define e3 (p2 '(one two four)))
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list e3) ![<graphic>](ch6_0.gif) (one two four)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-universe *enum-set*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the universe of `*enum-set*`, as an enumeration set'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c a b c d)))'
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-universe e1)) ![<graphic>](ch6_0.gif) (a b c d)
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 ((enum-set-constructor e1) '(c)))
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-universe e2)) ![<graphic>](ch6_0.gif) (a b c d)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set->list *enum-set*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a list of the elements of `*enum-set*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The symbols in the resulting list appear in the order given to them when the
    enumeration type of `enum-set` was created.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c a b c d)))'
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list e1) ![<graphic>](ch6_0.gif) (a b c d)
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 ((enum-set-constructor e1) '(d c a b)))
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list e2) ![<graphic>](ch6_0.gif) (a b c d)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-subset? *enum-set[1]* *enum-set[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*enum-set[1]*` is a subset of `*enum-set[2]*`, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: An enumeration set `*enum-set[1]*` is a subset of an enumeration set `*enum-set[2]*`
    if and only if the universe of `*enum-set[1]*` is a subset of the universe of
    `*enum-set[2]*` and each element of `*enum-set[1]*` is an element of `*enum-set[2]*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c)))'
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 (make-enumeration '(a b c d e)))
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-subset? e1 e2) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-subset? e2 e1) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (define e3 ((enum-set-constructor e2) '(a c)))
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-subset? e3 e1) ![<graphic>](ch6_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-subset? e3 e2) ![<graphic>](ch6_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set=? *enum-set[1]* *enum-set[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*enum-set[1]*` and `*enum-set[2]*` are equivalent, `#f`
    otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: Two enumeration sets `*enum-set[1]*` and `*enum-set[2]*` are equivalent if each
    is a subset of the other.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c d)))'
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 (make-enumeration '(b d c a)))
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set=? e1 e2) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (define e3 ((enum-set-constructor e1) '(a c)))
  prefs: []
  type: TYPE_NORMAL
- en: (define e4 ((enum-set-constructor e2) '(a c)))
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set=? e3 e4) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set=? e3 e2) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '`enum-set=?` could be defined in terms of `enum-set-subset?` as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define enum-set=?'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (e1 e2)
  prefs: []
  type: TYPE_NORMAL
- en: (and (enum-set-subset? e1 e2) (enum-set-subset? e2 e1))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-member? *symbol* *enum-set*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if symbol is an element of `*enum-set*`, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c d e)))'
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 ((enum-set-constructor e1) '(d b)))
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-member? 'c e1) ![<graphic>](ch6_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-member? 'c e2) ![<graphic>](ch6_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-union *enum-set[1]* *enum-set[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the union of `*enum-set[1]*` and `*enum-set[2]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-intersection *enum-set[1]* *enum-set[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the intersection of `*enum-set[1]*` and `*enum-set[2]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-difference *enum-set[1]* *enum-set[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the difference of `*enum-set[1]*` and `*enum-set[2]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*enum-set[1]*` and `*enum-set[2]*` must have the same enumeration type. Each
    procedure returns a new enumeration set representing the union, intersection,
    or difference of the two sets.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c d)))'
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 ((enum-set-constructor e1) '(a c)))
  prefs: []
  type: TYPE_NORMAL
- en: (define e3 ((enum-set-constructor e1) '(b c)))
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-union e2 e3)) ![<graphic>](ch6_0.gif) (a b c)
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-intersection e2 e3)) ![<graphic>](ch6_0.gif) (c)
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-difference e2 e3)) ![<graphic>](ch6_0.gif) (a)
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-difference e3 e2)) ![<graphic>](ch6_0.gif) (b)
  prefs: []
  type: TYPE_NORMAL
- en: (define e4 (make-enumeration '(b d c a)))
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-union e1 e4) ![<graphic>](ch6_0.gif) *exception: different enumeration types*`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-complement *enum-set*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the complement of `*enum-set*` relative to its universe'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c d)))'
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-complement e1)) ![<graphic>](ch6_0.gif) ()
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 ((enum-set-constructor e1) '(a c)))
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-complement e2)) ![<graphic>](ch6_0.gif) (b d)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-projection *enum-set[1]* *enum-set[2]*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the projection of `*enum-set[1]*` into the universe of `*enum-set[2]*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: Any elements of `*enum-set[1]*` not in the universe of `*enum-set[2]*` are dropped.
    The result is of the same enumeration type as `*enum-set[2]*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c d)))'
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 (make-enumeration '(a b c d e f g)))
  prefs: []
  type: TYPE_NORMAL
- en: (define e3 ((enum-set-constructor e1) '(a d)))
  prefs: []
  type: TYPE_NORMAL
- en: (define e4 ((enum-set-constructor e2) '(a c e g)))
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-projection e4 e3)) ![<graphic>](ch6_0.gif) (a c)
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-union e3
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-projection e4 e3))) ![<graphic>](ch6_0.gif) (a c d)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-indexer *enum-set*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a procedure that returns the index of a symbol in the universe
    of `*enum-set*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`enum-set-indexer` returns a procedure `*p*` that, when applied to a symbol
    in the universe of `*enum-set*`, returns the index of the symbol (zero-based)
    in the ordered set of symbols that form the universe. If applied to a symbol not
    in the universe, `*p*` returns `#f`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c d)))'
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 ((enum-set-constructor e1) '(a d)))
  prefs: []
  type: TYPE_NORMAL
- en: (define p (enum-set-indexer e2))
  prefs: []
  type: TYPE_NORMAL
- en: (list (p 'a) (p 'c) (p 'e)) ![<graphic>](ch6_0.gif) (0 2 #f)`
  prefs: []
  type: TYPE_NORMAL
