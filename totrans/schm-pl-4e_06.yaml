- en: Chapter 6\. Operations on Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。对象操作
- en: This chapter describes the operations on objects, including lists, numbers,
    characters, strings, vectors, bytevectors, symbols, booleans, hashtables, and
    enumerations. The first section covers constant objects and quotation. The second
    section describes generic equivalence predicates for comparing two objects and
    predicates for determining the type of an object. Later sections describe procedures
    that deal primarily with one of the object types mentioned above. There is no
    section treating operations on procedures, since the only operation defined specifically
    for procedures is application, and this is described in Chapter [5](control.html#g96).
    Operations on ports are covered in the more general discussion of input and output
    in Chapter [7](io.html#g121). A mechanism for defining new data types is described
    in Chapter [9](records.html#g138).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了对象的操作，包括列表、数字、字符、字符串、向量、字节向量、符号、布尔值、哈希表和枚举。第一节涵盖了常量对象和引用。第二节描述了用于比较两个对象的通用等价谓词以及用于确定对象类型的谓词。后续章节描述了主要涉及上述对象类型之一的过程。没有专门处理过程操作的章节，因为专门为过程定义的唯一操作是应用，这在第
    [5](control.html#g96) 章中描述。端口操作在第 [7](io.html#g121) 章中更一般地讨论了输入和输出。描述了定义新数据类型的机制在第
    [9](records.html#g138) 章中。
- en: Section 6.1\. Constants and Quotation
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 6.1 节。常量和引用
- en: '**syntax**: `*constant*`'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `*constant*`'
- en: '**returns:** `*constant*`'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值:** `*constant*`'
- en: '`*constant*` is any self-evaluating constant, i.e., a number, boolean, character,
    string, or bytevector. Constants are immutable; see the note in the description
    of `quote` below.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`*constant*` 是任何自我评估的常量，即数字、布尔值、字符、字符串或字节向量。常量是不可变的；请参见下面对 `quote` 描述的注释。'
- en: '`3.2 ![<graphic>](ch6_0.gif) 3.2'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`3.2 ![<graphic>](ch6_0.gif) 3.2'
- en: '#f ![<graphic>](ch6_0.gif) #f'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '#f ![<graphic>](ch6_0.gif) #f'
- en: '#\c ![<graphic>](ch6_0.gif) #\c'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '#\c ![<graphic>](ch6_0.gif) #\c'
- en: '"hi" ![<graphic>](ch6_0.gif) "hi"'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '"hi" ![<graphic>](ch6_0.gif) "hi"'
- en: '#vu8(3 4 5) ![<graphic>](ch6_0.gif) #vu8(3 4 5)`'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '#vu8(3 4 5) ![<graphic>](ch6_0.gif) #vu8(3 4 5)`'
- en: '**syntax**: `(quote *obj*)`'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `(quote *obj*)`'
- en: '**syntax**: `''*obj*`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `''*obj*`'
- en: '**returns:** `*obj*`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值:** `*obj*`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs base)`, `(rnrs)`'
- en: '`''*obj*` is equivalent to `(quote *obj*)`. The abbreviated form is converted
    into the longer form by the Scheme reader (see `read`).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`''*obj*` 等同于 `(quote *obj*)`。Scheme 读取器（参见 `read`）将缩写形式转换为较长形式。'
- en: '`quote` inhibits the normal evaluation rule for `*obj*`, allowing `*obj*` to
    be employed as data. Although any Scheme object may be quoted, quotation is not
    necessary for self-evaluating constants, i.e., numbers, booleans, characters,
    strings, and bytevectors.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`quote` 抑制了 `*obj*` 的正常评估规则，允许 `*obj*` 作为数据使用。虽然任何 Scheme 对象都可以被引用，但对于自我评估的常量，即数字、布尔值、字符、字符串和字节向量，引用并非必需。'
- en: Quoted and self-evaluating constants are immutable. That is, programs should
    not alter a constant via `set-car!`, `string-set!`, etc., and implementations
    are permitted to raise an exception with condition type `&assertion` if such an
    alteration is attempted. If an attempt to alter an immutable object is undetected,
    the behavior of the program is unspecified. An implementation may choose to share
    storage among different constants to save space.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 引用和自我评估的常量是不可变的。也就是说，程序不应通过 `set-car!`、`string-set!` 等方式改变常量，并且实现允许在尝试这种改变时引发带有条件类型
    `&assertion` 的异常。如果尝试更改不可变对象未被检测到，则程序的行为是未指定的。实现可以选择在不同常量之间共享存储空间以节省空间。
- en: '`(+ 2 3) ![<graphic>](ch6_0.gif) 5'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`(+ 2 3) ![<graphic>](ch6_0.gif) 5'
- en: '''(+ 2 3) ![<graphic>](ch6_0.gif) (+ 2 3)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '''(+ 2 3) ![<graphic>](ch6_0.gif) (+ 2 3)'
- en: (quote (+ 2 3)) ![<graphic>](ch6_0.gif) (+ 2 3)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: (quote (+ 2 3)) ![<graphic>](ch6_0.gif) (+ 2 3)
- en: '''a ![<graphic>](ch6_0.gif) a'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '''a ![<graphic>](ch6_0.gif) a'
- en: '''cons ![<graphic>](ch6_0.gif) cons'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '''cons ![<graphic>](ch6_0.gif) cons'
- en: '''() ![<graphic>](ch6_0.gif) ()'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '''() ![<graphic>](ch6_0.gif) ()'
- en: '''7 ![<graphic>](ch6_0.gif) 7`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '''7 ![<graphic>](ch6_0.gif) 7`'
- en: '**syntax**: `(quasiquote *obj* ...)`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `(quasiquote *obj* ...)`'
- en: '**syntax**: ``*obj*`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: ``*obj*`'
- en: '**syntax**: `(unquote *obj* ...)`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `(unquote *obj* ...)`'
- en: '**syntax**: `,*obj*`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `,*obj*`'
- en: '**syntax**: `(unquote-splicing *obj* ...)`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `(unquote-splicing *obj* ...)`'
- en: '**syntax**: `,@*obj*`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**: `,@*obj*`'
- en: '**returns:** see below'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值:** 见下文'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs base)`, `(rnrs)`'
- en: '``*obj*` is equivalent to `(quasiquote *obj*)`, `,*obj*` is equivalent to `(unquote *obj*)`,
    and `,@*obj*` is equivalent to `(unquote-splicing *obj*)`. The abbreviated forms
    are converted into the longer forms by the Scheme reader (see `read`).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '``*obj*` 等同于 `(quasiquote *obj*)`， `,*obj*` 等同于 `(unquote *obj*)`，而 `,@*obj*`
    等同于 `(unquote-splicing *obj*)`。这些缩写形式会被 Scheme 读取器转换为更长的形式（参见 `read`）。'
- en: '`quasiquote` is similar to `quote`, but it allows parts of the quoted text
    to be "unquoted." Within a `quasiquote` expression, `unquote` and `unquote-splicing`
    subforms are evaluated, and everything else is quoted, i.e., left unevaluated.
    The value of each `unquote` subform is inserted into the output in place of the
    `unquote` form, while the value of each `unquote-splicing` subform is spliced
    into the surrounding list or vector structure. `unquote` and `unquote-splicing`
    are valid only within `quasiquote` expressions.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`quasiquote` 类似于 `quote`，但允许引用文本的部分被“取消引用”。在 `quasiquote` 表达式中，`unquote` 和
    `unquote-splicing` 子形式会被评估，而其他所有内容会被引用，即保持未评估状态。每个 `unquote` 子形式的值会被插入到输出中，取代
    `unquote` 形式，而每个 `unquote-splicing` 子形式的值会被拼接到周围的列表或向量结构中。`unquote` 和 `unquote-splicing`
    仅在 `quasiquote` 表达式中有效。'
- en: '`quasiquote` expressions may be nested, with each `quasiquote` introducing
    a new level of quotation and each `unquote` or `unquote-splicing` taking away
    a level of quotation. An expression nested within *n* `quasiquote` expressions
    must be within *n* `unquote` or `unquote-splicing` expressions to be evaluated.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`quasiquote` 表达式可以嵌套，每个 `quasiquote` 引入一个新的引用级别，每个 `unquote` 或 `unquote-splicing`
    则减少一个引用级别。嵌套在 *n* 个 `quasiquote` 表达式中的表达式必须在 *n* 个 `unquote` 或 `unquote-splicing`
    表达式内才能被评估。'
- en: '``(+ 2 3) ![<graphic>](ch6_0.gif) (+ 2 3)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '``(+ 2 3) ![<graphic>](ch6_0.gif) (+ 2 3)'
- en: '`(+ 2 ,(* 3 4)) ![<graphic>](ch6_0.gif) (+ 2 12)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`(+ 2 ,(* 3 4)) ![<graphic>](ch6_0.gif) (+ 2 12)'
- en: '`(a b (,(+ 2 3) c) d) ![<graphic>](ch6_0.gif) (a b (5 c) d)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`(a b (,(+ 2 3) c) d) ![<graphic>](ch6_0.gif) (a b (5 c) d)'
- en: '`(a b ,(reverse ''(c d e)) f g) ![<graphic>](ch6_0.gif) (a b (e d c) f g)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`(a b ,(reverse ''(c d e)) f g) ![<graphic>](ch6_0.gif) (a b (e d c) f g)'
- en: (let ([a 1] [b 2])
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([a 1] [b 2])
- en: '`(,a . ,b)) ![<graphic>](ch6_0.gif) (1 . 2)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`(,a . ,b)) ![<graphic>](ch6_0.gif) (1 . 2)'
- en: '`(+ ,@(cdr ''(* 2 3))) ![<graphic>](ch6_0.gif) (+ 2 3)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`(+ ,@(cdr ''(* 2 3))) ![<graphic>](ch6_0.gif) (+ 2 3)'
- en: '`(a b ,@(reverse ''(c d e)) f g) ![<graphic>](ch6_0.gif) (a b e d c f g)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`(a b ,@(reverse ''(c d e)) f g) ![<graphic>](ch6_0.gif) (a b e d c f g)'
- en: (let ([a 1] [b 2])
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([a 1] [b 2])
- en: '`(,a ,@b)) ![<graphic>](ch6_0.gif) (1 . 2)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`(,a ,@b)) ![<graphic>](ch6_0.gif) (1 . 2)'
- en: '`#(,@(list 1 2 3)) ![<graphic>](ch6_0.gif) #(1 2 3)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`#(,@(list 1 2 3)) ![<graphic>](ch6_0.gif) #(1 2 3)'
- en: '''`,(cons ''a ''b) ![<graphic>](ch6_0.gif) `,(cons ''a ''b)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '''`,(cons ''a ''b) ![<graphic>](ch6_0.gif) `,(cons ''a ''b)'
- en: '`'',(cons ''a ''b) ![<graphic>](ch6_0.gif) ''(a . b)`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`'',(cons ''a ''b) ![<graphic>](ch6_0.gif) ''(a . b)`'
- en: '`unquote` and `unquote-splicing` forms with zero or more than one subform are
    valid only in splicing (list or vector) contexts. `(unquote *obj* ...)` is equivalent
    to `(unquote *obj*) ...`, and `(unquote-splicing *obj* ...)` is equivalent to
    `(unquote-splicing *obj*) ...`. These forms are primarily useful as intermediate
    forms in the output of the `quasiquote` expander. They support certain useful
    nested quasiquotation idioms [[3](bibliography.html#g221)], such as `,@,@`, which
    has the effect of a doubly indirect splicing when used within a doubly nested
    and doubly evaluated `quasiquote` expression.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`unquote` 和 `unquote-splicing` 表单在零个或多个子表单的情况下仅在拼接（列表或向量）上下文中有效。`(unquote *obj* ...)`
    等同于 `(unquote *obj*) ...`，`(unquote-splicing *obj* ...)` 等同于 `(unquote-splicing *obj*) ...`。这些形式主要用作
    `quasiquote` 展开器输出中的中间形式。它们支持某些有用的嵌套准引用习语 [[3](bibliography.html#g221)]，例如 `,@,@`，在双重嵌套和双重评估的
    `quasiquote` 表达式中使用时具有双重间接拼接的效果。'
- en: '``(a (unquote) b) ![<graphic>](ch6_0.gif) (a b)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '``(a (unquote) b) ![<graphic>](ch6_0.gif) (a b)'
- en: '`(a (unquote (+ 3 3)) b) ![<graphic>](ch6_0.gif) (a 6 b)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`(a (unquote (+ 3 3)) b) ![<graphic>](ch6_0.gif) (a 6 b)'
- en: '`(a (unquote (+ 3 3) (* 3 3)) b) ![<graphic>](ch6_0.gif) (a 6 9 b)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`(a (unquote (+ 3 3) (* 3 3)) b) ![<graphic>](ch6_0.gif) (a 6 9 b)'
- en: (let ([x '(m n)]) ``(a ,@,@x f)) ![<graphic>](ch6_0.gif) `(a (unquote-splicing m n) f)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x '(m n)]) ``(a ,@,@x f)) ![<graphic>](ch6_0.gif) `(a (unquote-splicing m n) f)
- en: (let ([x '(m n)])
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x '(m n)])
- en: (eval `(let ([m '(b c)] [n '(d e)]) `(a ,@,@x f))
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: (eval `(let ([m '(b c)] [n '(d e)]) `(a ,@,@x f))
- en: (environment '(rnrs)))) ![<graphic>](ch6_0.gif) (a b c d e f)`
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: (environment '(rnrs)))) ![<graphic>](ch6_0.gif) (a b c d e f)`
- en: '`unquote` and `unquote-splicing` are auxiliary keywords for `quasiquote`. It
    is a syntax violation to reference these identifiers except in contexts where
    they are recognized as auxiliary keywords.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`unquote` 和 `unquote-splicing` 是 `quasiquote` 的辅助关键字。在除了被识别为辅助关键字的上下文之外引用这些标识符是语法错误。'
- en: Section 6.2\. Generic Equivalence and Type Predicates
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 6.2 节。通用等价和类型谓词
- en: This section describes the basic Scheme predicates (procedures returning one
    of the boolean values `#t` or `#f`) for determining the type of an object or the
    equivalence of two objects. The equivalence predicates `eq?`, `eqv?`, and `equal?`
    are discussed first, followed by the type predicates.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了确定对象类型或两个对象等价性的基本 Scheme 谓词（返回布尔值 `#t` 或 `#f` 中的一个）的谓词。首先讨论等价谓词 `eq?`、`eqv?`
    和 `equal?`，然后是类型谓词。
- en: '**procedure**: `(eq? *obj[1]* *obj[2]*)`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(eq? *obj[1]* *obj[2]*)`'
- en: '**returns:** `#t` if `*obj[1]*` and `*obj[2]*` are identical, `#f` otherwise'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果 `*obj[1]*` 和 `*obj[2]*` 相同，则返回 `#t`，否则返回 `#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs base)`、`(rnrs)`'
- en: In most Scheme systems, two objects are considered identical if they are represented
    internally by the same pointer value and distinct (not identical) if they are
    represented internally by different pointer values, although other criteria, such
    as time-stamping, are possible.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 Scheme 系统中，如果两个对象在内部由相同的指针值表示，则认为它们是相同的，如果它们在内部由不同的指针值表示，则认为它们是不同的（不相同），尽管可能存在其他标准，例如时间戳。
- en: Although the particular rules for object identity vary somewhat from system
    to system, the following rules always hold.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对象标识的特定规则在各个系统之间略有不同，但以下规则始终成立。
- en: Two objects of different types (booleans, the empty list, pairs, numbers, characters,
    strings, vectors, symbols, and procedures) are distinct.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的两个对象（布尔值、空列表、对、数字、字符、字符串、向量、符号和过程）是不同的。
- en: Two objects of the same type with different contents or values are distinct.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个具有不同内容或值的相同类型对象是不同的。
- en: The boolean object `#t` is identical to itself wherever it appears, and `#f`
    is identical to itself wherever it appears, but `#t` and `#f` are distinct.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔对象 `#t` 在出现的任何位置都与自身相同，`#f` 在出现的任何位置都与自身相同，但 `#t` 和 `#f` 是不同的。
- en: The empty list `()` is identical to itself wherever it appears.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空列表 `()` 在出现的任何位置都与自身相同。
- en: Two symbols are identical if and only if they have the same name (by `string=?`).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果且仅当两个符号具有相同的名称（通过 `string=?`）时，它们是相同的。
- en: A constant pair, vector, string, or bytevector is identical to itself, as is
    a pair, vector, string, or bytevector created by an application of `cons`, `vector`,
    `string`, `make-bytevector`, etc. Two pairs, vectors, strings, or bytevectors
    created by different applications of `cons`, `vector`, `string`, `make-bytevector`,
    etc., are distinct. One consequence is that `cons`, for example, may be used to
    create a unique object distinct from all other objects.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量对、向量、字符串或字节向量与其自身相同，由 `cons`、`vector`、`string`、`make-bytevector` 等的应用创建的对、向量、字符串或字节向量也是如此。由
    `cons`、`vector`、`string`、`make-bytevector` 等的不同应用创建的两个对、向量、字符串或字节向量是不同的。一个后果是，例如，`cons`
    可以用于创建与所有其他对象不同的唯一对象。
- en: Two procedures that may behave differently are distinct. A procedure created
    by an evaluation of a `lambda` expression is identical to itself. Two procedures
    created by the same `lambda` expression at different times, or by similar `lambda`
    expressions, may or may not be distinct.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能表现不同的两个过程是不同的。通过对 `lambda` 表达式的评估创建的过程与其自身相同。由不同时间或相似 `lambda` 表达式创建的两个过程可能相同也可能不同。
- en: '`eq?` cannot be used to compare numbers and characters reliably. Although every
    inexact number is distinct from every exact number, two exact numbers, two inexact
    numbers, or two characters with the same value may or may not be identical.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`eq?` 不能可靠地用于比较数字和字符。尽管每个不精确数字都与每个精确数字不同，但两个精确数字、两个不精确数字或具有相同值的两个字符可能相同也可能不相同。'
- en: Since constant objects are immutable, i.e., programs should not modify them
    via `vector-set!`, `set-car!`, or any other structure mutation operation, all
    or portions of different quoted constants or self-evaluating literals may be represented
    internally by the same object. Thus, `eq?` may return `#t` when applied to equal
    parts of different immutable constants.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于常量对象是不可变的，即程序不应通过 `vector-set!`、`set-car!` 或任何其他结构变异操作修改它们，因此，所有或不同引用的常量或自评估字面量的部分可能在内部由相同的对象表示。因此，当应用于不同不可变常量的相等部分时，`eq?`
    可能返回 `#t`。
- en: '`eq?` is most often used to compare symbols or to check for pointer equivalence
    of allocated objects, e.g., pairs, vectors, or record instances.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`eq?` 最常用于比较符号或检查已分配对象的指针等价性，例如对、向量或记录实例。'
- en: '`(eq? ''a 3) ![<graphic>](ch6_0.gif) #f'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`(eq? ''a 3) ![<graphic>](ch6_0.gif) #f`'
- en: (eq? #t 't) ![<graphic>](ch6_0.gif) #f
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`(eq? #t ''t) ![<graphic>](ch6_0.gif) #f`'
- en: (eq? "abc" 'abc) ![<graphic>](ch6_0.gif) #f
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`(eq? "abc" ''abc) ![<graphic>](ch6_0.gif) #f`'
- en: (eq? "hi" '(hi)) ![<graphic>](ch6_0.gif) #f
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: (eq? #f '()) ![<graphic>](ch6_0.gif) #f
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 9/2 7/2) ![<graphic>](ch6_0.gif) #f
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 3.4 53344) ![<graphic>](ch6_0.gif) #f
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 3 3.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 1/3 #i1/3) ![<graphic>](ch6_0.gif) #f
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 9/2 9/2) ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 3.4 (+ 3.0 .4)) ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (* 12345678987654321 2)])
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: (eq? x x)) ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: (eq? #\a #\b) ![<graphic>](ch6_0.gif) #f
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: (eq? #\a #\a) ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (string-ref "hi" 0)])
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: (eq? x x)) ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: (eq? #t #t) ![<graphic>](ch6_0.gif) #t
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: (eq? #f #f) ![<graphic>](ch6_0.gif) #t
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: (eq? #t #f) ![<graphic>](ch6_0.gif) #f
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (null? '()) #t) ![<graphic>](ch6_0.gif) #t
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (null? '(a)) #f) ![<graphic>](ch6_0.gif) #t
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (cdr '(a)) '()) ![<graphic>](ch6_0.gif) #t
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 'a 'a) ![<graphic>](ch6_0.gif) #t
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 'a 'b) ![<graphic>](ch6_0.gif) #f
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: (eq? 'a (string->symbol "a")) ![<graphic>](ch6_0.gif) #t
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: (eq? '(a) '(b)) ![<graphic>](ch6_0.gif) #f
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: (eq? '(a) '(a)) ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x '(a . b)]) (eq? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (cons 'a 'b)])
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: (eq? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (cons 'a 'b) (cons 'a 'b)) ![<graphic>](ch6_0.gif) #f
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: (eq? "abc" "cba") ![<graphic>](ch6_0.gif) #f
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: (eq? "abc" "abc") ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x "hi"]) (eq? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (string #\h #\i)]) (eq? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (string #\h #\i)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: (string #\h #\i)) ![<graphic>](ch6_0.gif) #f
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: (eq? '#vu8(1) '#vu8(1)) ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: (eq? '#vu8(1) '#vu8(2)) ![<graphic>](ch6_0.gif) #f
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (make-bytevector 10 0)])
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: (eq? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (make-bytevector 10 0)])
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: (eq? x (make-bytevector 10 0))) ![<graphic>](ch6_0.gif) #f
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: (eq? '#(a) '#(b)) ![<graphic>](ch6_0.gif) #f
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: (eq? '#(a) '#(a)) ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x '#(a)]) (eq? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (vector 'a)])
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: (eq? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (vector 'a) (vector 'a)) ![<graphic>](ch6_0.gif) #f
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: (eq? car car) ![<graphic>](ch6_0.gif) #t
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: (eq? car cdr) ![<graphic>](ch6_0.gif) #f
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda (x) x)])
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: (eq? f f)) ![<graphic>](ch6_0.gif) #t
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda () (lambda (x) x))])
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (f) (f))) ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (lambda (x) x) (lambda (y) y)) ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda (x)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: (set! x (+ x 1))
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: x))])
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (f 0) (f 0))) ![<graphic>](ch6_0.gif) #f`
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(eqv? *obj[1]* *obj[2]*)`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj[1]*` and `*obj[2]*` are equivalent, `#f` otherwise'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '`eqv?` is similar to `eq?` except `eqv?` is guaranteed to return `#t` for two
    characters that are considered equal by `char=?` and two numbers that are (a)
    considered equal by `=` and (b) cannot be distinguished by any other operation
    besides `eq?` and `eqv?`. A consequence of (b) is that `(eqv? -0.0 +0.0)` is `#f`
    even though `(= -0.0 +0.0)` is `#t` in systems that distinguish `-0.0` and `+0.0`,
    such as those based on IEEE floating-point arithmetic. This is because operations
    such as `/` can expose the difference:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`eqv?` 类似于 `eq?`，但 `eqv?` 保证对于两个被 `char=?` 视为相等的字符和两个被 `=` 视为相等且除了 `eq?` 和
    `eqv?` 外无法区分的数字，`eqv?` 将返回 `#t`。由于（b）的结果是，即使在区分 `-0.0` 和 `+0.0` 的系统中（如基于 IEEE
    浮点运算的系统），`(eqv? -0.0 +0.0)` 也是 `#f`，尽管 `(= -0.0 +0.0)` 是 `#t`。这是因为诸如 `/` 这样的操作可以暴露出差异：'
- en: '`(/ 1.0 -0.0) ![<graphic>](ch6_0.gif) -inf.0'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`(/ 1.0 -0.0) ![<graphic>](ch6_0.gif) -inf.0'
- en: (/ 1.0 +0.0) ![<graphic>](ch6_0.gif) +inf.0`
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: (/ 1.0 +0.0) ![<graphic>](ch6_0.gif) +inf.0`
- en: Similarly, although 3.0 and 3.0+0.0i are considered numerically equal, they
    are not considered equivalent by `eqv?` if -0.0 and 0.0 have different representations.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，尽管 3.0 和 3.0+0.0i 在数值上被认为是相等的，但如果 -0.0 和 0.0 有不同的表示，则它们在 `eqv?` 中不被视为等价。
- en: '`(= 3.0+0.0i 3.0) ![<graphic>](ch6_0.gif) #t'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`(= 3.0+0.0i 3.0) ![<graphic>](ch6_0.gif) #t'
- en: (eqv? 3.0+0.0i 3.0) ![<graphic>](ch6_0.gif) #f`
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? 3.0+0.0i 3.0) ![<graphic>](ch6_0.gif) #f`
- en: The boolean value returned by `eqv?` is not specified when the arguments are
    NaNs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数为 NaN 时，`eqv?` 返回的布尔值未指定。
- en: '`(eqv? +nan.0 (/ 0.0 0.0)) ![<graphic>](ch6_0.gif) *unspecified*`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`(eqv? +nan.0 (/ 0.0 0.0)) ![<graphic>](ch6_0.gif) *unspecified*`'
- en: '`eqv?` is less implementation-dependent but generally more expensive than `eq?`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`eqv?` 不太依赖于实现，但通常比 `eq?` 更昂贵。'
- en: '`(eqv? ''a 3) ![<graphic>](ch6_0.gif) #f'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`(eqv? ''a 3) ![<graphic>](ch6_0.gif) #f'
- en: (eqv? #t 't) ![<graphic>](ch6_0.gif) #f
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? #t 't) ![<graphic>](ch6_0.gif) #f
- en: (eqv? "abc" 'abc) ![<graphic>](ch6_0.gif) #f
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? "abc" 'abc) ![<graphic>](ch6_0.gif) #f
- en: (eqv? "hi" '(hi)) ![<graphic>](ch6_0.gif) #f
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? "hi" '(hi)) ![<graphic>](ch6_0.gif) #f
- en: (eqv? #f '()) ![<graphic>](ch6_0.gif) #f
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? #f '()) ![<graphic>](ch6_0.gif) #f
- en: (eqv? 9/2 7/2) ![<graphic>](ch6_0.gif) #f
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? 9/2 7/2) ![<graphic>](ch6_0.gif) #f
- en: (eqv? 3.4 53344) ![<graphic>](ch6_0.gif) #f
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? 3.4 53344) ![<graphic>](ch6_0.gif) #f
- en: (eqv? 3 3.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? 3 3.0) ![<graphic>](ch6_0.gif) #f
- en: (eqv? 1/3 #i1/3) ![<graphic>](ch6_0.gif) #f
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? 1/3 #i1/3) ![<graphic>](ch6_0.gif) #f
- en: (eqv? 9/2 9/2) ![<graphic>](ch6_0.gif) #t
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? 9/2 9/2) ![<graphic>](ch6_0.gif) #t
- en: (eqv? 3.4 (+ 3.0 .4)) ![<graphic>](ch6_0.gif) #t
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? 3.4 (+ 3.0 .4)) ![<graphic>](ch6_0.gif) #t
- en: (let ([x (* 12345678987654321 2)])
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (* 12345678987654321 2)])
- en: (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? x x)) ![<graphic>](ch6_0.gif) #t
- en: (eqv? #\a #\b) ![<graphic>](ch6_0.gif) #f
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? #\a #\b) ![<graphic>](ch6_0.gif) #f
- en: (eqv? #\a #\a) ![<graphic>](ch6_0.gif) #t
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? #\a #\a) ![<graphic>](ch6_0.gif) #t
- en: (let ([x (string-ref "hi" 0)])
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (string-ref "hi" 0)])
- en: (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? x x)) ![<graphic>](ch6_0.gif) #t
- en: (eqv? #t #t) ![<graphic>](ch6_0.gif) #t
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? #t #t) ![<graphic>](ch6_0.gif) #t
- en: (eqv? #f #f) ![<graphic>](ch6_0.gif) #t
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? #f #f) ![<graphic>](ch6_0.gif) #t
- en: (eqv? #t #f) ![<graphic>](ch6_0.gif) #f
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? #t #f) ![<graphic>](ch6_0.gif) #f
- en: (eqv? (null? '()) #t) ![<graphic>](ch6_0.gif) #t
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? (null? '()) #t) ![<graphic>](ch6_0.gif) #t
- en: (eqv? (null? '(a)) #f) ![<graphic>](ch6_0.gif) #t
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? (null? '(a)) #f) ![<graphic>](ch6_0.gif) #t
- en: (eqv? (cdr '(a)) '()) ![<graphic>](ch6_0.gif) #t
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? (cdr '(a)) '()) ![<graphic>](ch6_0.gif) #t
- en: (eqv? 'a 'a) ![<graphic>](ch6_0.gif) #t
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? 'a 'a) ![<graphic>](ch6_0.gif) #t
- en: (eqv? 'a 'b) ![<graphic>](ch6_0.gif) #f
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? 'a 'b) ![<graphic>](ch6_0.gif) #f
- en: (eqv? 'a (string->symbol "a")) ![<graphic>](ch6_0.gif) #t
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? 'a (string->symbol "a")) ![<graphic>](ch6_0.gif) #t
- en: (eqv? '(a) '(b)) ![<graphic>](ch6_0.gif) #f
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? '(a) '(b)) ![<graphic>](ch6_0.gif) #f
- en: (eqv? '(a) '(a)) ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? '(a) '(a)) ![<graphic>](ch6_0.gif) *unspecified*
- en: (let ([x '(a . b)]) (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x '(a . b)]) (eqv? x x)) ![<graphic>](ch6_0.gif) #t
- en: (let ([x (cons 'a 'b)])
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (cons 'a 'b)])
- en: (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? x x)) ![<graphic>](ch6_0.gif) #t
- en: (eqv? (cons 'a 'b) (cons 'a 'b)) ![<graphic>](ch6_0.gif) #f
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? (cons 'a 'b) (cons 'a 'b)) ![<graphic>](ch6_0.gif) #f
- en: (eqv? "abc" "cba") ![<graphic>](ch6_0.gif) #f
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? "abc" "cba") ![<graphic>](ch6_0.gif) #f
- en: (eqv? "abc" "abc") ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? "abc" "abc") ![<graphic>](ch6_0.gif) *unspecified*
- en: (let ([x "hi"]) (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x "hi"]) (eqv? x x)) ![<graphic>](ch6_0.gif) #t
- en: (let ([x (string #\h #\i)]) (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (string #\h #\i)]) (eqv? x x)) ![<graphic>](ch6_0.gif) #t
- en: (eqv? (string #\h #\i)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? (string #\h #\i)
- en: (string #\h #\i)) ![<graphic>](ch6_0.gif) #f
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: (string #\h #\i)) ![<graphic>](ch6_0.gif) #f
- en: (eqv? '#vu8(1) '#vu8(1)) ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? '#vu8(1) '#vu8(1)) ![<graphic>](ch6_0.gif) *unspecified*
- en: (eqv? '#vu8(1) '#vu8(2)) ![<graphic>](ch6_0.gif) #f
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? '#vu8(1) '#vu8(2)) ![<graphic>](ch6_0.gif) #f
- en: (let ([x (make-bytevector 10 0)])
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (make-bytevector 10 0)])
- en: (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? x x)) ![<graphic>](ch6_0.gif) #t
- en: (let ([x (make-bytevector 10 0)])
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (make-bytevector 10 0)])
- en: (eqv? x (make-bytevector 10 0))) ![<graphic>](ch6_0.gif) #f
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? x (make-bytevector 10 0))) ![<graphic>](ch6_0.gif) #f
- en: (eqv? '#(a) '#(b)) ![<graphic>](ch6_0.gif) #f
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? '#(a) '#(b)) ![<graphic>](ch6_0.gif) #f
- en: (eqv? '#(a) '#(a)) ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? '#(a) '#(a)) ![<graphic>](ch6_0.gif) *unspecified*
- en: (let ([x '#(a)]) (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x '#(a)]) (eqv? x x)) ![<graphic>](ch6_0.gif) #t
- en: (let ([x (vector 'a)])
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (vector 'a)])
- en: (eqv? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? x x)) ![<graphic>](ch6_0.gif) #t
- en: (eqv? (vector 'a) (vector 'a)) ![<graphic>](ch6_0.gif) #f
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? (vector 'a) (vector 'a)) ![<graphic>](ch6_0.gif) #f
- en: (eqv? car car) ![<graphic>](ch6_0.gif) #t
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? car car) ![<graphic>](ch6_0.gif) #t
- en: (eqv? car cdr) ![<graphic>](ch6_0.gif) #f
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? car cdr) ![<graphic>](ch6_0.gif) #f
- en: (let ([f (lambda (x) x)])
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([f (lambda (x) x)])
- en: (eqv? f f)) ![<graphic>](ch6_0.gif) #t
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? f f)) ![<graphic>](ch6_0.gif) #t
- en: (let ([f (lambda () (lambda (x) x))])
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([f (lambda () (lambda (x) x))])
- en: (eqv? (f) (f))) ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? (f) (f))) ![<graphic>](ch6_0.gif) *unspecified*
- en: (eqv? (lambda (x) x) (lambda (y) y)) ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? (lambda (x) x) (lambda (y) y)) ![<graphic>](ch6_0.gif) *unspecified*
- en: (let ([f (lambda (x)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([f (lambda (x)
- en: (lambda ()
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (set! x (+ x 1))
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: (set! x (+ x 1))
- en: x))])
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: x))])
- en: (eqv? (f 0) (f 0))) ![<graphic>](ch6_0.gif) #f`
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? (f 0) (f 0))) ![<graphic>](ch6_0.gif) #f`
- en: '**procedure**: `(equal? *obj[1]* *obj[2]*)`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(equal? *obj[1]* *obj[2]*)`'
- en: '**returns:** `#t` if `*obj[1]*` and `*obj[2]*` have the same structure and
    contents, `#f` otherwise'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果 `*obj[1]*` 和 `*obj[2]*` 具有相同的结构和内容，则返回 `#t`，否则返回 `#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: Two objects are equal if they are equivalent according to `eqv?`, strings that
    are `string=?`, bytevectors that are `bytevector=?`, pairs whose cars and cdrs
    are equal, or vectors of the same length whose corresponding elements are equal.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 两个对象是相等的，如果它们根据 `eqv?`、字符串的 `string=?`、字节向量的 `bytevector=?`、其对应的 `car` 和 `cdr`
    相等的对、或者长度相等的向量的相应元素相等。
- en: '`equal?` is required to terminate even for cyclic arguments and return `#t`
    "if and only if the (possibly infinite) unfoldings of its arguments into regular
    trees are equal as ordered trees" [[24](bibliography.html#g242)]. In essence,
    two values are equivalent, in the sense of `equal?`, if the structure of the two
    objects cannot be distinguished by any composition of pair and vector accessors
    along with the `eqv?`, `string=?`, and `bytevector=?` procedures for comparing
    data at the leaves.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`equal?` 需要在循环参数中终止，并返回 `#t`，“仅当其参数（可能是无限的）展开成普通树时，其展开作为有序树相等”[[24](bibliography.html#g242)]。本质上，如果两个对象的结构不能通过任何一组对成对和向量访问器的组合以及用于比较叶子数据的
    `eqv?`、`string=?` 和 `bytevector=?` 程序来区分，则两个值在 `equal?` 的意义上是等价的。'
- en: Implementing `equal?` efficiently is tricky [[1](bibliography.html#g219)], and
    even with a good implementation, it is likely to be more expensive than either
    `eqv?` or `eq?`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `equal?` 的高效性是棘手的[[1](bibliography.html#g219)]，即使有一个良好的实现，它也可能比 `eqv?` 或
    `eq?` 更昂贵。
- en: '`(equal? ''a 3) ![<graphic>](ch6_0.gif) #f'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`(equal? ''a 3) ![<graphic>](ch6_0.gif) #f'
- en: (equal? #t 't) ![<graphic>](ch6_0.gif) #f
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? #t 't) ![<graphic>](ch6_0.gif) #f
- en: (equal? "abc" 'abc) ![<graphic>](ch6_0.gif) #f
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? "abc" 'abc) ![<graphic>](ch6_0.gif) #f
- en: (equal? "hi" '(hi)) ![<graphic>](ch6_0.gif) #f
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? "hi" '(hi)) ![<graphic>](ch6_0.gif) #f
- en: (equal? #f '()) ![<graphic>](ch6_0.gif) #f
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? #f '()) ![<graphic>](ch6_0.gif) #f
- en: (equal? 9/2 7/2) ![<graphic>](ch6_0.gif) #f
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? 9/2 7/2) ![<graphic>](ch6_0.gif) #f
- en: (equal? 3.4 53344) ![<graphic>](ch6_0.gif) #f
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? 3.4 53344) ![<graphic>](ch6_0.gif) #f
- en: (equal? 3 3.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? 3 3.0) ![<graphic>](ch6_0.gif) #f
- en: (equal? 1/3 #i1/3) ![<graphic>](ch6_0.gif) #f
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? 1/3 #i1/3) ![<graphic>](ch6_0.gif) #f
- en: (equal? 9/2 9/2) ![<graphic>](ch6_0.gif) #t
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? 9/2 9/2) ![<graphic>](ch6_0.gif) #t
- en: (equal? 3.4 (+ 3.0 .4)) ![<graphic>](ch6_0.gif) #t
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? 3.4 (+ 3.0 .4)) ![<graphic>](ch6_0.gif) #t
- en: (let ([x (* 12345678987654321 2)])
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (* 12345678987654321 2)])
- en: (equal? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? x x)) ![<graphic>](ch6_0.gif) #t
- en: (equal? #\a #\b) ![<graphic>](ch6_0.gif) #f
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? #\a #\b) ![<graphic>](ch6_0.gif) #f
- en: (equal? #\a #\a) ![<graphic>](ch6_0.gif) #t
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? #\a #\a) ![<graphic>](ch6_0.gif) #t
- en: (let ([x (string-ref "hi" 0)])
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (string-ref "hi" 0)])
- en: (equal? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? x x)) ![<graphic>](ch6_0.gif) #t
- en: (equal? #t #t) ![<graphic>](ch6_0.gif) #t
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? #t #t) ![<graphic>](ch6_0.gif) #t
- en: (equal? #f #f) ![<graphic>](ch6_0.gif) #t
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? #f #f) ![<graphic>](ch6_0.gif) #t
- en: (equal? #t #f) ![<graphic>](ch6_0.gif) #f
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? #t #f) ![<graphic>](ch6_0.gif) #f
- en: (equal? (null? '()) #t) ![<graphic>](ch6_0.gif) #t
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? (null? '()) #t) ![<graphic>](ch6_0.gif) #t
- en: (equal? (null? '(a)) #f) ![<graphic>](ch6_0.gif) #t
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? (null? '(a)) #f) ![<graphic>](ch6_0.gif) #t
- en: (equal? (cdr '(a)) '()) ![<graphic>](ch6_0.gif) #t
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? (cdr '(a)) '()) ![<graphic>](ch6_0.gif) #t
- en: (equal? 'a 'a) ![<graphic>](ch6_0.gif) #t
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? 'a 'a) ![<graphic>](ch6_0.gif) #t
- en: (equal? 'a 'b) ![<graphic>](ch6_0.gif) #f
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? 'a 'b) ![<graphic>](ch6_0.gif) #f
- en: (equal? 'a (string->symbol "a")) ![<graphic>](ch6_0.gif) #t
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? 'a (string->symbol "a")) ![<graphic>](ch6_0.gif) #t
- en: (equal? '(a) '(b)) ![<graphic>](ch6_0.gif) #f
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? '(a) '(b)) ![<graphic>](ch6_0.gif) #f
- en: (equal? '(a) '(a)) ![<graphic>](ch6_0.gif) #t
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? '(a) '(a)) ![<graphic>](ch6_0.gif) #t
- en: (let ([x '(a . b)]) (equal? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x '(a . b)]) (equal? x x)) ![<graphic>](ch6_0.gif) #t
- en: (let ([x (cons 'a 'b)])
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (cons 'a 'b)])
- en: (equal? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? x x)) ![<graphic>](ch6_0.gif) #t
- en: (equal? (cons 'a 'b) (cons 'a 'b)) ![<graphic>](ch6_0.gif) #t
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? (cons 'a 'b) (cons 'a 'b)) ![<graphic>](ch6_0.gif) #t
- en: (equal? "abc" "cba") ![<graphic>](ch6_0.gif) #f
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? "abc" "cba") ![<graphic>](ch6_0.gif) #f
- en: (equal? "abc" "abc") ![<graphic>](ch6_0.gif) #t
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? "abc" "abc") ![<graphic>](ch6_0.gif) #t
- en: (let ([x "hi"]) (equal? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x "hi"]) (equal? x x)) ![<graphic>](ch6_0.gif) #t
- en: (let ([x (string #\h #\i)]) (equal? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (string #\h #\i)]) (equal? x x)) ![<graphic>](ch6_0.gif) #t
- en: (equal? (string #\h #\i)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? (string #\h #\i)
- en: (string #\h #\i)) ![<graphic>](ch6_0.gif) #t
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: (string #\h #\i)) ![<graphic>](ch6_0.gif) #t
- en: (equal? '#vu8(1) '#vu8(1)) ![<graphic>](ch6_0.gif) #t
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? '#vu8(1) '#vu8(1)) ![<graphic>](ch6_0.gif) #t
- en: (equal? '#vu8(1) '#vu8(2)) ![<graphic>](ch6_0.gif) #f
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? '#vu8(1) '#vu8(2)) ![<graphic>](ch6_0.gif) #f
- en: (let ([x (make-bytevector 10 0)])
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (make-bytevector 10 0)])
- en: (equal? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? x x)) ![<graphic>](ch6_0.gif) #t
- en: (let ([x (make-bytevector 10 0)])
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (make-bytevector 10 0)])
- en: (equal? x (make-bytevector 10 0))) ![<graphic>](ch6_0.gif) #t
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? x (make-bytevector 10 0))) ![<graphic>](ch6_0.gif) #t
- en: (equal? '#(a) '#(b)) ![<graphic>](ch6_0.gif) #f
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? '#(a) '#(b)) ![<graphic>](ch6_0.gif) #f
- en: (equal? '#(a) '#(a)) ![<graphic>](ch6_0.gif) #t
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? '#(a) '#(a)) ![<graphic>](ch6_0.gif) #t
- en: (let ([x '#(a)]) (equal? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x '#(a)]) (equal? x x)) ![<graphic>](ch6_0.gif) #t
- en: (let ([x (vector 'a)])
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (vector 'a)])
- en: (equal? x x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? x x)) ![<graphic>](ch6_0.gif) #t
- en: (equal? (vector 'a) (vector 'a)) ![<graphic>](ch6_0.gif) #t
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? (vector 'a) (vector 'a)) ![<graphic>](ch6_0.gif) #t
- en: (equal? car car) ![<graphic>](ch6_0.gif) #t
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? car car) ![<graphic>](ch6_0.gif) #t
- en: (equal? car cdr) ![<graphic>](ch6_0.gif) #f
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? car cdr) ![<graphic>](ch6_0.gif) #f
- en: (let ([f (lambda (x) x)])
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([f (lambda (x) x)])
- en: (equal? f f)) ![<graphic>](ch6_0.gif) #t
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? f f)) ![<graphic>](ch6_0.gif) #t
- en: (let ([f (lambda () (lambda (x) x))])
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([f (lambda () (lambda (x) x))])
- en: (equal? (f) (f))) ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? (f) (f))) ![<graphic>](ch6_0.gif) *unspecified*
- en: (equal? (lambda (x) x) (lambda (y) y)) ![<graphic>](ch6_0.gif) *unspecified*
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? (lambda (x) x) (lambda (y) y)) ![<graphic>](ch6_0.gif) *unspecified*
- en: (let ([f (lambda (x)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([f (lambda (x)
- en: (lambda ()
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (set! x (+ x 1))
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: (set! x (+ x 1))
- en: x))])
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: x))])
- en: (equal? (f 0) (f 0))) ![<graphic>](ch6_0.gif) #f
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: (equal? (f 0) (f 0))) ![<graphic>](ch6_0.gif) #f
- en: (equal?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: (equal?
- en: (let ([x (cons 'x 'x)])
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (cons 'x 'x)])
- en: (set-car! x x)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: (set-car! x x)
- en: (set-cdr! x x)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cdr! x x)
- en: x)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: x)
- en: (let ([x (cons 'x 'x)])
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (cons 'x 'x)])
- en: (set-car! x x)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: (set-car! x x)
- en: (set-cdr! x x)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cdr! x x)
- en: (cons x x))) ![<graphic>](ch6_0.gif) #t`
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: (cons x x))) ![<graphic>](ch6_0.gif) #t`
- en: '**procedure**: `(boolean? *obj*)`'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(boolean? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is either `#t` or `#f`, `#f` otherwise'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是`#t`或`#f`，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`boolean?` is equivalent to `(lambda (x) (or (eq? x #t) (eq? x #f)))`.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean?` 等同于 `(lambda (x) (or (eq? x #t) (eq? x #f)))`.'
- en: '`(boolean? #t) ![<graphic>](ch6_0.gif) #t'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`(boolean? #t) ![<graphic>](ch6_0.gif) #t'
- en: (boolean? #f) ![<graphic>](ch6_0.gif) #t
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: (boolean? #f) ![<graphic>](ch6_0.gif) #t
- en: (or (boolean? 't) (boolean? '())) ![<graphic>](ch6_0.gif) #f`
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: (or (boolean? 't) (boolean? '())) ![<graphic>](ch6_0.gif) #f`
- en: '**procedure**: `(null? *obj*)`'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(null? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is the empty list, `#f` otherwise'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是空列表，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`null?` is equivalent to `(lambda (x) (eq? x ''()))`.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`null?` 等同于 `(lambda (x) (eq? x ''()))`.'
- en: '`(null? ''()) ![<graphic>](ch6_0.gif) #t'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`(null? ''()) ![<graphic>](ch6_0.gif) #t'
- en: (null? '(a)) ![<graphic>](ch6_0.gif) #f
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: (null? '(a)) ![<graphic>](ch6_0.gif) #f
- en: (null? (cdr '(a))) ![<graphic>](ch6_0.gif) #t
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: (null? (cdr '(a))) ![<graphic>](ch6_0.gif) #t
- en: (null? 3) ![<graphic>](ch6_0.gif) #f
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: (null? 3) ![<graphic>](ch6_0.gif) #f
- en: (null? #f) ![<graphic>](ch6_0.gif) #f`
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: (null? #f) ![<graphic>](ch6_0.gif) #f`
- en: '**procedure**: `(pair? *obj*)`'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(pair? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a pair, `#f` otherwise'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是一对，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`(pair? ''(a b c)) ![<graphic>](ch6_0.gif) #t'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`(pair? ''(a b c)) ![<graphic>](ch6_0.gif) #t'
- en: (pair? '(3 . 4)) ![<graphic>](ch6_0.gif) #t
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: (pair? '(3 . 4)) ![<graphic>](ch6_0.gif) #t
- en: (pair? '()) ![<graphic>](ch6_0.gif) #f
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: (pair? '()) ![<graphic>](ch6_0.gif) #f
- en: (pair? '#(a b)) ![<graphic>](ch6_0.gif) #f
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: (pair? '#(a b)) ![<graphic>](ch6_0.gif) #f
- en: (pair? 3) ![<graphic>](ch6_0.gif) #f`
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: (pair? 3) ![<graphic>](ch6_0.gif) #f`
- en: '**procedure**: `(number? *obj*)`'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(number? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a number object, `#f` otherwise'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是数字对象，则返回`#t`，否则返回`#f`'
- en: '**procedure**: `(complex? *obj*)`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(complex? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a complex number object, `#f` otherwise'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t` if `*obj*` is a complex number object, `#f` otherwise'
- en: '**procedure**: `(real? *obj*)`'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(real? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a real number object, `#f` otherwise'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t` if `*obj*` is a real number object, `#f` otherwise'
- en: '**procedure**: `(rational? *obj*)`'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(rational? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a rational number object, `#f` otherwise'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t` if `*obj*` is a rational number object, `#f` otherwise'
- en: '**procedure**: `(integer? *obj*)`'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(integer? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is an integer object, `#f` otherwise'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t` if `*obj*` is an integer object, `#f` otherwise'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: 'These predicates form a hierarchy: any integer is rational, any rational is
    real, any real is complex, and any complex is numeric. Most implementations do
    not provide internal representations for irrational numbers, so all real numbers
    are typically rational as well.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这些谓词形成一个层次结构：任何整数都是有理数，任何有理数都是实数，任何实数都是复数，任何复数都是数值。大多数实现不提供无理数的内部表示，因此所有实数通常也是有理数。
- en: The `real?`, `rational?`, and `integer?` predicates do not recognize as real,
    rational, or integer complex numbers with inexact zero imaginary parts.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`real?`、`rational?`和`integer?`谓词不会将具有非精确零虚部的复数识别为实数、有理数或整数。'
- en: '`(integer? 1901) ![<graphic>](ch6_0.gif) #t'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`(integer? 1901) ![<graphic>](ch6_0.gif) #t'
- en: (rational? 1901) ![<graphic>](ch6_0.gif) #t
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: (rational? 1901) ![<graphic>](ch6_0.gif) #t
- en: (real? 1901) ![<graphic>](ch6_0.gif) #t
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: (real? 1901) ![<graphic>](ch6_0.gif) #t
- en: (complex? 1901) ![<graphic>](ch6_0.gif) #t
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: (complex? 1901) ![<graphic>](ch6_0.gif) #t
- en: (number? 1901) ![<graphic>](ch6_0.gif) #t
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: (number? 1901) ![<graphic>](ch6_0.gif) #t
- en: (integer? -3.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: (integer? -3.0) ![<graphic>](ch6_0.gif) #t
- en: (rational? -3.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: (rational? -3.0) ![<graphic>](ch6_0.gif) #t
- en: (real? -3.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: (real? -3.0) ![<graphic>](ch6_0.gif) #t
- en: (complex? -3.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: (complex? -3.0) ![<graphic>](ch6_0.gif) #t
- en: (number? -3.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: (number? -3.0) ![<graphic>](ch6_0.gif) #t
- en: (integer? 7+0i) ![<graphic>](ch6_0.gif) #t
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: (integer? 7+0i) ![<graphic>](ch6_0.gif) #t
- en: (rational? 7+0i) ![<graphic>](ch6_0.gif) #t
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: (rational? 7+0i) ![<graphic>](ch6_0.gif) #t
- en: (real? 7+0i) ![<graphic>](ch6_0.gif) #t
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: (real? 7+0i) ![<graphic>](ch6_0.gif) #t
- en: (complex? 7+0i) ![<graphic>](ch6_0.gif) #t
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: (complex? 7+0i) ![<graphic>](ch6_0.gif) #t
- en: (number? 7+0i) ![<graphic>](ch6_0.gif) #t
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: (number? 7+0i) ![<graphic>](ch6_0.gif) #t
- en: (integer? -2/3) ![<graphic>](ch6_0.gif) #f
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: (integer? -2/3) ![<graphic>](ch6_0.gif) #f
- en: (rational? -2/3) ![<graphic>](ch6_0.gif) #t
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: (rational? -2/3) ![<graphic>](ch6_0.gif) #t
- en: (real? -2/3) ![<graphic>](ch6_0.gif) #t
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: (real? -2/3) ![<graphic>](ch6_0.gif) #t
- en: (complex? -2/3) ![<graphic>](ch6_0.gif) #t
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: (complex? -2/3) ![<graphic>](ch6_0.gif) #t
- en: (number? -2/3) ![<graphic>](ch6_0.gif) #t
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: (number? -2/3) ![<graphic>](ch6_0.gif) #t
- en: (integer? -2.345) ![<graphic>](ch6_0.gif) #f
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: (integer? -2.345) ![<graphic>](ch6_0.gif) #f
- en: (rational? -2.345) ![<graphic>](ch6_0.gif) #t
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: (rational? -2.345) ![<graphic>](ch6_0.gif) #t
- en: (real? -2.345) ![<graphic>](ch6_0.gif) #t
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: (real? -2.345) ![<graphic>](ch6_0.gif) #t
- en: (complex? -2.345) ![<graphic>](ch6_0.gif) #t
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: (complex? -2.345) ![<graphic>](ch6_0.gif) #t
- en: (number? -2.345) ![<graphic>](ch6_0.gif) #t
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: (number? -2.345) ![<graphic>](ch6_0.gif) #t
- en: (integer? 7.0+0.0i) ![<graphic>](ch6_0.gif) #f
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: (integer? 7.0+0.0i) ![<graphic>](ch6_0.gif) #f
- en: (rational? 7.0+0.0i) ![<graphic>](ch6_0.gif) #f
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: (rational? 7.0+0.0i) ![<graphic>](ch6_0.gif) #f
- en: (real? 7.0+0.0i) ![<graphic>](ch6_0.gif) #f
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: (real? 7.0+0.0i) ![<graphic>](ch6_0.gif) #f
- en: (complex? 7.0+0.0i) ![<graphic>](ch6_0.gif) #t
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: (complex? 7.0+0.0i) ![<graphic>](ch6_0.gif) #t
- en: (number? 7.0+0.0i) ![<graphic>](ch6_0.gif) #t
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: (number? 7.0+0.0i) ![<graphic>](ch6_0.gif) #t
- en: (integer? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: (integer? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f
- en: (rational? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: (rational? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f
- en: (real? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: (real? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f
- en: (complex? 3.2-2.01i) ![<graphic>](ch6_0.gif) #t
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: (complex? 3.2-2.01i) ![<graphic>](ch6_0.gif) #t
- en: (number? 3.2-2.01i) ![<graphic>](ch6_0.gif) #t
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: (number? 3.2-2.01i) ![<graphic>](ch6_0.gif) #t
- en: (integer? 'a) ![<graphic>](ch6_0.gif) #f
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: (integer? 'a) ![<graphic>](ch6_0.gif) #f
- en: (rational? '(a b c)) ![<graphic>](ch6_0.gif) #f
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: (rational? '(a b c)) ![<graphic>](ch6_0.gif) #f
- en: (real? "3") ![<graphic>](ch6_0.gif) #f
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: (real? "3") ![<graphic>](ch6_0.gif) #f
- en: (complex? '#(1 2)) ![<graphic>](ch6_0.gif) #f
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: (complex? '#(1 2)) ![<graphic>](ch6_0.gif) #f
- en: (number? #\a) ![<graphic>](ch6_0.gif) #f`
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: (number? #\a) ![<graphic>](ch6_0.gif) #f`
- en: '**procedure**: `(real-valued? *obj*)`'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(real-valued? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a real number, `#f` otherwise'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t` if `*obj*` is a real number, `#f` otherwise'
- en: '**procedure**: `(rational-valued? *obj*)`'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(rational-valued? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a rational number, `#f` otherwise'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t` if `*obj*` is a rational number, `#f` otherwise'
- en: '**procedure**: `(integer-valued? *obj*)`'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(integer-valued? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is an integer, `#f` otherwise'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t` if `*obj*` is an integer, `#f` otherwise'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: These predicates are similar to `real?`, `rational?`, and `integer?`, but treat
    as real, rational, or integral complex numbers with inexact zero imaginary parts.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这些谓词类似于`real?`、`rational?`和`integer?`，但将具有非精确零虚部的实数、有理数或整数复数视为实数、有理数或整数。
- en: '`(integer-valued? 1901) ![<graphic>](ch6_0.gif) #t'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`(integer-valued? 1901) ![<graphic>](ch6_0.gif) #t'
- en: (rational-valued? 1901) ![<graphic>](ch6_0.gif) #t
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: (rational-valued? 1901) ![<graphic>](ch6_0.gif) #t
- en: (real-valued? 1901) ![<graphic>](ch6_0.gif) #t
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: (real-valued? 1901) ![<graphic>](ch6_0.gif) #t
- en: (integer-valued? -3.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: (integer-valued? -3.0) ![<graphic>](ch6_0.gif) #t
- en: (rational-valued? -3.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: (rational-valued? -3.0) ![<graphic>](ch6_0.gif) #t
- en: (real-valued? -3.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: (real-valued? -3.0) ![<graphic>](ch6_0.gif) #t
- en: (integer-valued? 7+0i) ![<graphic>](ch6_0.gif) #t
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: (integer-valued? 7+0i) ![<graphic>](ch6_0.gif) #t
- en: (rational-valued? 7+0i) ![<graphic>](ch6_0.gif) #t
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: (rational-valued? 7+0i) ![<graphic>](ch6_0.gif) #t
- en: (real-valued? 7+0i) ![<graphic>](ch6_0.gif) #t
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: (real-valued? 7+0i) ![<graphic>](ch6_0.gif) #t
- en: (integer-valued? -2/3) ![<graphic>](ch6_0.gif) #f
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: (integer-valued? -2/3) ![<graphic>](ch6_0.gif) #f
- en: (rational-valued? -2/3) ![<graphic>](ch6_0.gif) #t
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: (rational-valued? -2/3) ![<graphic>](ch6_0.gif) #t
- en: (real-valued? -2/3) ![<graphic>](ch6_0.gif) #t
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: (real-valued? -2/3) ![<graphic>](ch6_0.gif) #t
- en: (integer-valued? -2.345) ![<graphic>](ch6_0.gif) #f
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: (integer-valued? -2.345) ![<graphic>](ch6_0.gif) #f
- en: (rational-valued? -2.345) ![<graphic>](ch6_0.gif) #t
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: (rational-valued? -2.345) ![<graphic>](ch6_0.gif) #t
- en: (real-valued? -2.345) ![<graphic>](ch6_0.gif) #t
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: (real-valued? -2.345) ![<graphic>](ch6_0.gif) #t
- en: (integer-valued? 7.0+0.0i) ![<graphic>](ch6_0.gif) #t
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: (integer-valued? 7.0+0.0i) ![<graphic>](ch6_0.gif) #t
- en: (rational-valued? 7.0+0.0i) ![<graphic>](ch6_0.gif) #t
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: (rational-valued? 7.0+0.0i) ![<graphic>](ch6_0.gif) #t
- en: (real-valued? 7.0+0.0i) ![<graphic>](ch6_0.gif) #t
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: (real-valued? 7.0+0.0i) ![<graphic>](ch6_0.gif) #t
- en: (integer-valued? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: (integer-valued? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f
- en: (rational-valued? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: (rational-valued? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f
- en: (real-valued? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f`
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: (real-valued? 3.2-2.01i) ![<graphic>](ch6_0.gif) #f`
- en: As with `real?`, `rational?`, and `integer?`, these predicates return `#f` for
    all non-numeric values.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 与`real?`、`rational?`和`integer?`类似，这些谓词对所有非数值返回`#f`。
- en: '`(integer-valued? ''a) ![<graphic>](ch6_0.gif) #f'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`(integer-valued? ''a) ![<graphic>](ch6_0.gif) #f`'
- en: (rational-valued? '(a b c)) ![<graphic>](ch6_0.gif) #f
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: (rational-valued? '(a b c)) ![<graphic>](ch6_0.gif) #f
- en: (real-valued? "3") ![<graphic>](ch6_0.gif) #f`
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: (real-valued? "3") ![<graphic>](ch6_0.gif) #f`
- en: '**procedure**: `(char? *obj*)`'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(char? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a character, `#f` otherwise'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t`如果`*obj*`是一个字符，否则为`#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`(char? ''a) ![<graphic>](ch6_0.gif) #f'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`(char? ''a) ![<graphic>](ch6_0.gif) #f`'
- en: (char? 97) ![<graphic>](ch6_0.gif) #f
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: (char? 97) ![<graphic>](ch6_0.gif) #f
- en: (char? #\a) ![<graphic>](ch6_0.gif) #t
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: (char? #\a) ![<graphic>](ch6_0.gif) #t
- en: (char? "a") ![<graphic>](ch6_0.gif) #f
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: (char? "a") ![<graphic>](ch6_0.gif) #f
- en: (char? (string-ref (make-string 1) 0)) ![<graphic>](ch6_0.gif) #t`
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: (char? (string-ref (make-string 1) 0)) ![<graphic>](ch6_0.gif) #t`
- en: '**procedure**: `(string? *obj*)`'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(string? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a string, `#f` otherwise'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t`如果`*obj*`是一个字符串，否则为`#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`(string? "hi") ![<graphic>](ch6_0.gif) #t'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`(string? "hi") ![<graphic>](ch6_0.gif) #t'
- en: (string? 'hi) ![<graphic>](ch6_0.gif) #f
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: (string? 'hi) ![<graphic>](ch6_0.gif) #f
- en: (string? #\h) ![<graphic>](ch6_0.gif) #f`
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: (string? #\h) ![<graphic>](ch6_0.gif) #f`
- en: '**procedure**: `(vector? *obj*)`'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(vector? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a vector, `#f` otherwise'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t`如果`*obj*`是一个向量，否则为`#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`(vector? ''#()) ![<graphic>](ch6_0.gif) #t'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`(vector? ''#()) ![<graphic>](ch6_0.gif) #t'
- en: (vector? '#(a b c)) ![<graphic>](ch6_0.gif) #t
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: (vector? '#(a b c)) ![<graphic>](ch6_0.gif) #t
- en: (vector? (vector 'a 'b 'c)) ![<graphic>](ch6_0.gif) #t
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: (vector? (vector 'a 'b 'c)) ![<graphic>](ch6_0.gif) #t
- en: (vector? '()) ![<graphic>](ch6_0.gif) #f
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: (vector? '()) ![<graphic>](ch6_0.gif) #f
- en: (vector? '(a b c)) ![<graphic>](ch6_0.gif) #f
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: (vector? '(a b c)) ![<graphic>](ch6_0.gif) #f
- en: (vector? "abc") ![<graphic>](ch6_0.gif) #f`
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: (vector? "abc") ![<graphic>](ch6_0.gif) #f`
- en: '**procedure**: `(symbol? *obj*)`'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(symbol? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a symbol, `#f` otherwise'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t`如果`*obj*`是一个符号，否则为`#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`(symbol? ''t) ![<graphic>](ch6_0.gif) #t'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`(symbol? ''t) ![<graphic>](ch6_0.gif) #t'
- en: (symbol? "t") ![<graphic>](ch6_0.gif) #f
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: (symbol? "t") ![<graphic>](ch6_0.gif) #f
- en: (symbol? '(t)) ![<graphic>](ch6_0.gif) #f
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: (symbol? '(t)) ![<graphic>](ch6_0.gif) #f
- en: (symbol? #\t) ![<graphic>](ch6_0.gif) #f
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: (symbol? #\t) ![<graphic>](ch6_0.gif) #f
- en: (symbol? 3) ![<graphic>](ch6_0.gif) #f
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: (symbol? 3) ![<graphic>](ch6_0.gif) #f
- en: (symbol? #t) ![<graphic>](ch6_0.gif) #f`
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: (symbol? #t) ![<graphic>](ch6_0.gif) #f`
- en: '**procedure**: `(procedure? *obj*)`'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(procedure? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a procedure, `#f` otherwise'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t`如果`*obj*`是一个过程，否则为`#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`(procedure? car) ![<graphic>](ch6_0.gif) #t'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`(procedure? car) ![<graphic>](ch6_0.gif) #t'
- en: (procedure? 'car) ![<graphic>](ch6_0.gif) #f
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: (procedure? 'car) ![<graphic>](ch6_0.gif) #f
- en: (procedure? (lambda (x) x)) ![<graphic>](ch6_0.gif) #t
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: (procedure? (lambda (x) x)) ![<graphic>](ch6_0.gif) #t
- en: (procedure? '(lambda (x) x)) ![<graphic>](ch6_0.gif) #f
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: (procedure? '(lambda (x) x)) ![<graphic>](ch6_0.gif) #f
- en: (call/cc procedure?) ![<graphic>](ch6_0.gif) #t`
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: (call/cc procedure?) ![<graphic>](ch6_0.gif) #t`
- en: '**procedure**: `(bytevector? *obj*)`'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(bytevector? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a bytevector, `#f` otherwise'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t` if `*obj*` is a bytevector, `#f` otherwise'
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
- en: '`(bytevector? #vu8()) ![<graphic>](ch6_0.gif) #t'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`(bytevector? #vu8()) ![<graphic>](ch6_0.gif) #t'
- en: (bytevector? '#()) ![<graphic>](ch6_0.gif) #f
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: (bytevector? '#()) ![<graphic>](ch6_0.gif) #f
- en: (bytevector? "abc") ![<graphic>](ch6_0.gif) #f`
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: (bytevector? "abc") ![<graphic>](ch6_0.gif) #f`
- en: '**procedure**: `(hashtable? *obj*)`'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(hashtable? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a hashtable, `#f` otherwise'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t` if `*obj*` is a hashtable, `#f` otherwise'
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
- en: '`(hashtable? (make-eq-hashtable)) ![<graphic>](ch6_0.gif) #t'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`(hashtable? (make-eq-hashtable)) ![<graphic>](ch6_0.gif) #t'
- en: (hashtable? '(not a hash table)) ![<graphic>](ch6_0.gif) #f`
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: (hashtable? '(not a hash table)) ![<graphic>](ch6_0.gif) #f`
- en: Section 6.3\. Lists and Pairs
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第6.3节。列表和对
- en: The pair, or *cons cell*, is the most fundamental of Scheme's structured object
    types. The most common use for pairs is to build lists, which are ordered sequences
    of pairs linked one to the next by the *cdr* field. The elements of the list occupy
    the *car* fields of the pairs. The cdr of the last pair in a *proper list* is
    the empty list, `()`; the cdr of the last pair in an *improper list* can be anything
    other than `()`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 对Scheme结构化对象类型来说，对偶或*cons cell*是最基本的。对偶最常见的用途是构建列表，这是由*cdr*字段链接的对之间的有序序列。列表的元素占据对的*car*字段。在*proper
    list*中，最后一个对的cdr是空列表`()`；在*improper list*中，最后一个对的cdr可以是除`()`之外的任何其他内容。
- en: Pairs may be used to construct binary trees. Each pair in the tree structure
    is an internal node of the binary tree; its car and cdr are the children of the
    node.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 对可以用来构建二叉树。树结构中的每个对都是二叉树的内部节点；其car和cdr是节点的子节点。
- en: Proper lists are printed as sequences of objects separated by whitespace and
    enclosed in parentheses. Matching pairs of brackets ( `[` `]` ) may be used in
    place of parentheses. For example, `(1 2 3)` and `(a [nested list])` are proper
    lists. The empty list is written as `()`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: Proper lists被打印为由空格分隔并用括号括起的对象序列。匹配的方括号（ `[` `]` ）可以用括号代替。例如，`(1 2 3)`和`(a [nested list])`是proper
    lists。空列表写作`()`。
- en: Improper lists and trees require a slightly more complex syntax. A single pair
    is written as two objects separated by whitespace and a dot, e.g., `(a . b)`.
    This is referred to as *dotted-pair notation*. Improper lists and trees are also
    written in dotted-pair notation; the dot appears wherever necessary, e.g., `(1 2 3 . 4)`
    or `((1 . 2) . 3)`. Proper lists may be written in dotted-pair notation as well.
    For example, `(1 2 3)` may be written as `(1 . (2 . (3 . ())))`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: Improper lists和trees需要稍微复杂的语法。单个对写作两个由空格和点分隔的对象，例如，`(a . b)`。这被称为*dotted-pair
    notation*。Improper lists和trees也用dotted-pair notation写作；点出现在必要的地方，例如，`(1 2 3 . 4)`或`((1 . 2) . 3)`。Proper
    lists也可以用dotted-pair notation写作。例如，`(1 2 3)`可以写作`(1 . (2 . (3 . ())))`。
- en: It is possible to create a circular list or a cyclic graph by destructively
    altering the car or cdr field of a pair, using `set-car!` or `set-cdr!`. Such
    lists are not considered proper lists.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 通过破坏性地改变对的car或cdr字段，使用`set-car!`或`set-cdr!`，可以创建循环列表或循环图。这样的列表不被视为proper lists。
- en: Procedures that accept a `*list*` argument are required to detect that the list
    is improper only to the extent that they actually traverse the list far enough
    either (a) to attempt to operate on a non-list tail or (b) to loop indefinitely
    due to a circularity. For example, `member` need not detect that a list is improper
    if it actually finds the element being sought, and `list-ref` need never detect
    circularities, because its recursion is bounded by the index argument.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 接受`*list*`参数的过程需要检测列表是否不完整，只要它们实际上遍历列表足够远，要么(a)尝试在非列表尾部操作，要么(b)由于循环而无限循环。例如，如果`member`实际上找到了正在寻找的元素，则无需检测列表是否不完整，而`list-ref`永远不需要检测循环，因为其递归受索引参数限制。
- en: '**procedure**: `(cons *obj[1]* *obj[2]*)`'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(cons *obj[1]* *obj[2]*)`'
- en: '**returns:** a new pair whose car and cdr are `*obj[1]*` and `*obj[2]*`'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个新的对，其car和cdr分别为`*obj[1]*`和`*obj[2]*`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`cons` is the pair constructor procedure. `*obj[1]*` becomes the car and `*obj[2]*`
    becomes the cdr of the new pair.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`cons`是一对构造过程。`*obj[1]*`成为新对的car，`*obj[2]*`成为cdr。'
- en: '`(cons ''a ''()) ![<graphic>](ch6_0.gif) (a)'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cons ''a ''()) ![<graphic>](ch6_0.gif) (a)`'
- en: (cons 'a '(b c)) ![<graphic>](ch6_0.gif) (a b c)
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cons ''a ''(b c)) ![<graphic>](ch6_0.gif) (a b c)`'
- en: (cons 3 4) ![<graphic>](ch6_0.gif) (3 . 4)`
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cons 3 4) ![<graphic>](ch6_0.gif) (3 . 4)`'
- en: '**procedure**: `(car *pair*)`'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(car *pair*)`'
- en: '**returns:** the car of `*pair*`'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*pair*`的car'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: The empty list is not a pair, so the argument must not be the empty list.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 空列表不是一对，因此参数不能是空列表。
- en: '`(car ''(a)) ![<graphic>](ch6_0.gif) a'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '`(car ''(a)) ![<graphic>](ch6_0.gif) a`'
- en: (car '(a b c)) ![<graphic>](ch6_0.gif) a
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`(car ''(a b c)) ![<graphic>](ch6_0.gif) a`'
- en: (car (cons 3 4)) ![<graphic>](ch6_0.gif) 3`
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`(car (cons 3 4)) ![<graphic>](ch6_0.gif) 3`'
- en: '**procedure**: `(cdr *pair*)`'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(cdr *pair*)`'
- en: '**returns:** the cdr of `*pair*`'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*pair*`的cdr'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: The empty list is not a pair, so the argument must not be the empty list.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 空列表不是一对，因此参数不能是空列表。
- en: '`(cdr ''(a)) ![<graphic>](ch6_0.gif) ()'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cdr ''(a)) ![<graphic>](ch6_0.gif) ()`'
- en: (cdr '(a b c)) ![<graphic>](ch6_0.gif) (b c)
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cdr ''(a b c)) ![<graphic>](ch6_0.gif) (b c)`'
- en: (cdr (cons 3 4)) ![<graphic>](ch6_0.gif) 4`
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cdr (cons 3 4)) ![<graphic>](ch6_0.gif) 4`'
- en: '**procedure**: `(set-car! *pair* *obj*)`'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(set-car! *pair* *obj*)`'
- en: '**returns:** unspecified'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 未指定'
- en: '**libraries:** `(rnrs mutable-pairs)`'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs mutable-pairs)`'
- en: '`set-car!` changes the car of `*pair*` to `*obj*`.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`set-car!`将`*pair*`的car更改为`*obj*`。'
- en: '`(let ([x (list ''a ''b ''c)])'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x (list ''a ''b ''c)])`'
- en: (set-car! x 1)
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`(set-car! x 1)`'
- en: x) ![<graphic>](ch6_0.gif) (1 b c)`
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: x) ![<graphic>](ch6_0.gif) (1 b c)`
- en: '**procedure**: `(set-cdr! *pair* *obj*)`'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(set-cdr! *pair* *obj*)`'
- en: '**returns:** unspecified'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 未指定'
- en: '**libraries:** `(rnrs mutable-pairs)`'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs mutable-pairs)`'
- en: '`set-cdr!` changes the cdr of `*pair*` to `*obj*`.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '`set-cdr!`将`*pair*`的cdr更改为`*obj*`。'
- en: '`(let ([x (list ''a ''b ''c)])'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x (list ''a ''b ''c)])`'
- en: (set-cdr! x 1)
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`(set-cdr! x 1)`'
- en: x) ![<graphic>](ch6_0.gif) (a . 1)`
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: x) ![<graphic>](ch6_0.gif) (a . 1)`
- en: '**procedure**: `(caar *pair*)`'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(caar *pair*)`'
- en: '**procedure**: `(cadr *pair*)` ![<graphic>](ch6_3.gif)'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(cadr *pair*)` ![<graphic>](ch6_3.gif)'
- en: '**procedure**: `(cddddr *pair*)`'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(cddddr *pair*)`'
- en: '**returns:** the caar, cadr, ..., or cddddr of `*pair*`'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*pair*`的caar、cadr等'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: These procedures are defined as the composition of up to four `car`s and `cdr`s.
    The `a`'s and `d`'s between the `c` and `r` represent the application of `car`
    or `cdr` in order from right to left. For example, the procedure `cadr` applied
    to a pair yields the `car` of the `cdr` of the pair and is equivalent to `(lambda (x) (car (cdr x)))`.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过程被定义为最多四个`car`和`cdr`的组合。在`c`和`r`之间的`a`和`d`表示从右到左应用`car`或`cdr`。例如，应用于一对的`cadr`过程会产生一对的`cdr`的`car`，等同于`(lambda (x) (car (cdr x)))`。
- en: '`(caar ''((a))) ![<graphic>](ch6_0.gif) a'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`(caar ''((a))) ![<graphic>](ch6_0.gif) a`'
- en: (cadr '(a b c)) ![<graphic>](ch6_0.gif) b
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cadr ''(a b c)) ![<graphic>](ch6_0.gif) b`'
- en: (cdddr '(a b c d)) ![<graphic>](ch6_0.gif) (d)
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cdddr ''(a b c d)) ![<graphic>](ch6_0.gif) (d)`'
- en: (cadadr '(a (b c))) ![<graphic>](ch6_0.gif) c`
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cadadr ''(a (b c))) ![<graphic>](ch6_0.gif) c`'
- en: '**procedure**: `(list *obj* ...)`'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(list *obj* ...)`'
- en: '**returns:** a list of `*obj* ...`'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个由`*obj* ...`组成的列表'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`list` is equivalent to `(lambda x x)`.'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`等同于`(lambda x x)`。'
- en: '`(list) ![<graphic>](ch6_0.gif) ()'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`(list) ![<graphic>](ch6_0.gif) ()`'
- en: (list 1 2 3) ![<graphic>](ch6_0.gif) (1 2 3)
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`(list 1 2 3) ![<graphic>](ch6_0.gif) (1 2 3)`'
- en: (list 3 2 1) ![<graphic>](ch6_0.gif) (3 2 1)`
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`(list 3 2 1) ![<graphic>](ch6_0.gif) (3 2 1)`'
- en: '**procedure**: `(cons* *obj* ... *final-obj*)`'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(cons* *obj* ... *final-obj*)`'
- en: '**returns:** a list of `*obj* ...` terminated by `*final-obj*`'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 由`*obj* ...`组成的列表，以`*final-obj*`结尾'
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs lists)`, `(rnrs)`'
- en: If the objects `*obj* ...` are omitted, the result is simply `*final-obj*`.
    Otherwise, a list of `*obj* ...` is constructed, as with `list`, except that the
    final cdr field is `*final-obj*` instead of `()`. If `*final-obj*` is not a list,
    the result is an improper list.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了`*obj* ...`，结果就是简单的`*final-obj*`。否则，将构建一个由`*obj* ...`组成的列表，类似于`list`，只是最终的cdr字段是`*final-obj*`而不是`()`。如果`*final-obj*`不是列表，则结果是不正确的列表。
- en: '`(cons* ''()) ![<graphic>](ch6_0.gif) ()'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cons* ''()) ![<graphic>](ch6_0.gif) ()`'
- en: (cons* '(a b)) ![<graphic>](ch6_0.gif) (a b)
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cons* ''(a b)) ![<graphic>](ch6_0.gif) (a b)`'
- en: (cons* 'a 'b 'c) ![<graphic>](ch6_0.gif) (a b . c)
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cons* ''a ''b ''c) ![<graphic>](ch6_0.gif) (a b . c)`'
- en: (cons* 'a 'b '(c d)) ![<graphic>](ch6_0.gif) (a b c d)`
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cons* ''a ''b ''(c d)) ![<graphic>](ch6_0.gif) (a b c d)`'
- en: '**procedure**: `(list? *obj*)`'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(list? *obj*)`'
- en: '**returns:** `#t` if `*obj*` is a proper list, `#f` otherwise'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t` 如果 `*obj*` 是一个正确的列表，否则为 `#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`list?` must return `#f` for all improper lists, including cyclic lists. A
    definition of `list?` is shown on page [67](further.html#defn:list?).'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '`list?` 必须对所有不正确的列表返回 `#f`，包括循环列表。 `list?` 的定义如下所示，第 [67](further.html#defn:list?) 页。'
- en: '`(list? ''()) ![<graphic>](ch6_0.gif) #t'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`(list? ''()) ![<graphic>](ch6_0.gif) #t'
- en: (list? '(a b c)) ![<graphic>](ch6_0.gif) #t
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: (list? '(a b c)) ![<graphic>](ch6_0.gif) #t
- en: (list? 'a) ![<graphic>](ch6_0.gif) #f
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: (list? 'a) ![<graphic>](ch6_0.gif) #f
- en: (list? '(3 . 4)) ![<graphic>](ch6_0.gif) #f
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: (list? '(3 . 4)) ![<graphic>](ch6_0.gif) #f
- en: (list? 3) ![<graphic>](ch6_0.gif) #f
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: (list? 3) ![<graphic>](ch6_0.gif) #f
- en: (let ([x (list 'a 'b 'c)])
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (list 'a 'b 'c)])
- en: (set-cdr! (cddr x) x)
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cdr! (cddr x) x)
- en: (list? x)) ![<graphic>](ch6_0.gif) #f`
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: (list? x)) ![<graphic>](ch6_0.gif) #f`
- en: '**procedure**: `(length *list*)`'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(length *list*)`'
- en: '**returns:** the number of elements in `*list*`'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*list*` 中元素的数量'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`length` may be defined as follows, using an adaptation of the hare and tortoise
    algorithm used for the definition of `list?` on page [67](further.html#defn:list?).'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`length` 可以如下定义，使用了用于定义 `list?` 的乌龟和兔子算法的改编，该算法在第 [67](further.html#defn:list?) 页上用于定义
    `list?`。'
- en: '`(define length'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define length'
- en: (lambda (x)
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (define improper-list
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: (define improper-list
- en: (lambda ()
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (assertion-violation 'length "not a proper list" x)))
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: (assertion-violation 'length "not a proper list" x)))
- en: (let f ([h x] [t x] [n 0])
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([h x] [t x] [n 0])
- en: (if (pair? h)
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: (if (pair? h)
- en: (let ([h (cdr h)])
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([h (cdr h)])
- en: (if (pair? h)
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: (if (pair? h)
- en: (if (eq? h t)
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: (if (eq? h t)
- en: (improper-list)
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: (improper-list)
- en: (f (cdr h) (cdr t) (+ n 2)))
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: (f (cdr h) (cdr t) (+ n 2)))
- en: (if (null? h)
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? h)
- en: (+ n 1)
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: (+ n 1)
- en: (improper-list))))
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: (improper-list))))
- en: (if (null? h)
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? h)
- en: n
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: n
- en: (improper-list))))))
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: (improper-list))))))
- en: (length '()) ![<graphic>](ch6_0.gif) 0
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: (length '()) ![<graphic>](ch6_0.gif) 0
- en: (length '(a b c)) ![<graphic>](ch6_0.gif) 3
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: (length '(a b c)) ![<graphic>](ch6_0.gif) 3
- en: (length '(a b . c)) ![<graphic>](ch6_0.gif) *exception*
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: (length '(a b . c)) ![<graphic>](ch6_0.gif) *exception*
- en: (length
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: (length
- en: (let ([ls (list 'a 'b)])
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([ls (list 'a 'b)])
- en: (set-cdr! (cdr ls) ls) ![<graphic>](ch6_0.gif) *exception*
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cdr! (cdr ls) ls) ![<graphic>](ch6_0.gif) *exception*
- en: ls))
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: ls))
- en: (length
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: (length
- en: (let ([ls (list 'a 'b)])
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([ls (list 'a 'b)])
- en: (set-car! (cdr ls) ls) ![<graphic>](ch6_0.gif) 2
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: (set-car! (cdr ls) ls) ![<graphic>](ch6_0.gif) 2
- en: ls))`
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: ls))`
- en: '**procedure**: `(list-ref *list* *n*)`'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(list-ref *list* *n*)`'
- en: '**returns:** the `*n*`th element (zero-based) of `*list*`'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*list*` 的第 `*n*` 个元素（从零开始）'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`*n*` must be an exact nonnegative integer less than the length of `*list*`.
    `list-ref` may be defined without error checks as follows.'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '`*n*` 必须是一个精确的非负整数，小于 `*list*` 的长度。 `list-ref` 可以如下定义，不带错误检查。'
- en: '`(define list-ref'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define list-ref'
- en: (lambda (ls n)
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls n)
- en: (if (= n 0)
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: (if (= n 0)
- en: (car ls)
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: (car ls)
- en: (list-ref (cdr ls) (- n 1)))))
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: (list-ref (cdr ls) (- n 1)))))
- en: (list-ref '(a b c) 0) ![<graphic>](ch6_0.gif) a
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: (list-ref '(a b c) 0) ![<graphic>](ch6_0.gif) a
- en: (list-ref '(a b c) 1) ![<graphic>](ch6_0.gif) b
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: (list-ref '(a b c) 1) ![<graphic>](ch6_0.gif) b
- en: (list-ref '(a b c) 2) ![<graphic>](ch6_0.gif) c`
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: (list-ref '(a b c) 2) ![<graphic>](ch6_0.gif) c`
- en: '**procedure**: `(list-tail *list* *n*)`'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(list-tail *list* *n*)`'
- en: '**returns:** the `*n*`th tail (zero-based) of `*list*`'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*list*` 的第 `*n*` 个尾部（从零开始）'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`*n*` must be an exact nonnegative integer less than or equal to the length
    of `*list*`. The result is not a copy; the tail is `eq?` to the `*n*`th cdr of
    `*list*` (or to `*list*` itself, if `*n*` is zero).'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '`*n*` 必须是一个精确的非负整数，小于或等于 `*list*` 的长度。结果不是一个副本；尾部与 `*list*` 的第 `*n*` 个 cdr
    是 `eq?` 的（如果 `*n*` 是零，则是 `*list*` 本身）。'
- en: '`list-tail` may be defined without error checks as follows.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '`list-tail` 可以如下定义，不带错误检查。'
- en: '`(define list-tail'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define list-tail'
- en: (lambda (ls n)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls n)
- en: (if (= n 0)
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: (if (= n 0)
- en: ls
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: ls
- en: (list-tail (cdr ls) (- n 1)))))
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: (list-tail (cdr ls) (- n 1)))))
- en: (list-tail '(a b c) 0) ![<graphic>](ch6_0.gif) (a b c)
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: (list-tail '(a b c) 0) ![<graphic>](ch6_0.gif) (a b c)
- en: (list-tail '(a b c) 2) ![<graphic>](ch6_0.gif) (c)
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: (list-tail '(a b c) 2) ![<graphic>](ch6_0.gif) (c)
- en: (list-tail '(a b c) 3) ![<graphic>](ch6_0.gif) ()
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: (list-tail '(a b c) 3) ![<graphic>](ch6_0.gif) ()
- en: (list-tail '(a b c . d) 2) ![<graphic>](ch6_0.gif) (c . d)
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: (list-tail '(a b c . d) 2) ![<graphic>](ch6_0.gif) (c . d)
- en: (list-tail '(a b c . d) 3) ![<graphic>](ch6_0.gif) d
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: (list-tail '(a b c . d) 3) ![<graphic>](ch6_0.gif) d
- en: (let ([x (list 1 2 3)])
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (list 1 2 3)])
- en: (eq? (list-tail x 2)
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: (eq? (list-tail x 2)
- en: (cddr x))) ![<graphic>](ch6_0.gif) #t`
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: (cddr x))) ![<graphic>](ch6_0.gif) #t`
- en: '**procedure**: `(append)`'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(append)`'
- en: '**procedure**: `(append *list* ... *obj*)`'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(append *list* ... *obj*)`'
- en: '**returns:** the concatenation of the input lists'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 输入列表的连接'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`append` returns a new list consisting of the elements of the first list followed
    by the elements of the second list, the elements of the third list, and so on.
    The new list is made from new pairs for all arguments but the last; the last (which
    need not be a list) is merely placed at the end of the new structure. `append`
    may be defined without error checks as follows.'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`返回一个新列表，其中包含第一个列表的元素，然后是第二个列表的元素，第三个列表的元素，依此类推。新列表由所有参数的新对构成，但最后一个参数（不必是列表）仅放置在新结构的末尾。`append`可以定义为如下无错误检查。'
- en: '`(define append'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define append'
- en: (lambda args
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda args
- en: (let f ([ls '()] [args args])
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([ls '()] [args args])
- en: (if (null? args)
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? args)
- en: ls
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: ls
- en: (let g ([ls ls])
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: (let g ([ls ls])
- en: (if (null? ls)
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: (f (car args) (cdr args))
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: (f (car args) (cdr args))
- en: (cons (car ls) (g (cdr ls)))))))))
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (car ls) (g (cdr ls)))))))))
- en: (append '(a b c) '()) ![<graphic>](ch6_0.gif) (a b c)
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: (append '(a b c) '()) ![<graphic>](ch6_0.gif) (a b c)
- en: (append '() '(a b c)) ![<graphic>](ch6_0.gif) (a b c)
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: (append '() '(a b c)) ![<graphic>](ch6_0.gif) (a b c)
- en: (append '(a b) '(c d)) ![<graphic>](ch6_0.gif) (a b c d)
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: (append '(a b) '(c d)) ![<graphic>](ch6_0.gif) (a b c d)
- en: (append '(a b) 'c) ![<graphic>](ch6_0.gif) (a b . c)
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: (append '(a b) 'c) ![<graphic>](ch6_0.gif) (a b . c)
- en: (let ([x (list 'b)])
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (list 'b)])
- en: (eq? x (cdr (append '(a) x)))) ![<graphic>](ch6_0.gif) #t`
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: (eq? x (cdr (append '(a) x)))) ![<graphic>](ch6_0.gif) #t`
- en: '**procedure**: `(reverse *list*)`'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(reverse *list*)`'
- en: '**returns:** a new list containing the elements of `*list*` in reverse order'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 一个包含`*list*`元素的逆序列表'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**: `(rnrs base)`，`(rnrs)`'
- en: '`reverse` may be defined without error checks as follows.'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse`可以定义为如下无错误检查。'
- en: '`(define reverse'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define reverse'
- en: (lambda (ls)
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls)
- en: (let rev ([ls ls] [new '()])
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: (let rev ([ls ls] [new '()])
- en: (if (null? ls)
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: new
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: (rev (cdr ls) (cons (car ls) new))))))
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: (rev (cdr ls) (cons (car ls) new))))))
- en: (reverse '()) ![<graphic>](ch6_0.gif) ()
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: (reverse '()) ![<graphic>](ch6_0.gif) ()
- en: (reverse '(a b c)) ![<graphic>](ch6_0.gif) (c b a)`
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: (reverse '(a b c)) ![<graphic>](ch6_0.gif) (c b a)`
- en: '**procedure**: `(memq *obj* *list*)`'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(memq *obj* *list*)`'
- en: '**procedure**: `(memv *obj* *list*)`'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(memv *obj* *list*)`'
- en: '**procedure**: `(member *obj* *list*)`'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(member *obj* *list*)`'
- en: '**returns:** the first tail of `*list*` whose car is equivalent to `*obj*`,
    or `#f`'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** `*list*`的首元素等价于`*obj*`的第一个尾部，或`#f`'
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**: `(rnrs lists)`，`(rnrs)`'
- en: These procedures traverse the argument `*list*` in order, comparing the elements
    of `*list*` against `*obj*`. If an object equivalent to `*obj*` is found, the
    tail of the list whose first element is that object is returned. If the list contains
    more than one object equivalent to `*obj*`, the first tail whose first element
    is equivalent to `*obj*` is returned. If no object equivalent to `*obj*` is found,
    `#f` is returned. The equivalence test for `memq` is `eq?`, for `memv` is `eqv?`,
    and for `member` is `equal?`.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过程按顺序遍历参数`*list*`，将`*list*`的元素与`*obj*`进行比较。如果找到一个等价于`*obj*`的对象，则返回以该对象为首元素的列表的尾部。如果列表包含多个等价于`*obj*`的对象，则返回第一个首元素等价于`*obj*`的尾部。如果找不到等价于`*obj*`的对象，则返回`#f`。对于`memq`的等价测试是`eq?`，对于`memv`是`eqv?`，对于`member`是`equal?`。
- en: These procedures are most often used as predicates, but their names do not end
    with a question mark because they return a useful true value in place of `#t`.
    `memq` may be defined without error checks as follows.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过程通常用作谓词，但它们的名称不以问号结尾，因为它们返回一个有用的��值，而不是`#t`。`memq`可以定义为如下无错误检查。
- en: '`(define memq'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define memq'
- en: (lambda (x ls)
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x ls)
- en: (cond
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(null? ls) #f]'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '[(null? ls) #f]'
- en: '[(eq? (car ls) x) ls]'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '[(eq? (car ls) x) ls]'
- en: '[else (memq x (cdr ls))])))`'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (memq x (cdr ls))])))`'
- en: '`memv` and `member` may be defined similarly, with `eqv?` and `equal?` in place
    of `eq?`.'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '`memv`和`member`可以类似地定义，其中`eqv?`和`equal?`代替`eq?`。'
- en: '`(memq ''a ''(b c a d e)) ![<graphic>](ch6_0.gif) (a d e)'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '`(memq ''a ''(b c a d e)) ![<graphic>](ch6_0.gif) (a d e)'
- en: (memq 'a '(b c d e g)) ![<graphic>](ch6_0.gif) #f
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: (memq 'a '(b c d e g)) ![<graphic>](ch6_0.gif) #f
- en: (memq 'a '(b a c a d a)) ![<graphic>](ch6_0.gif) (a c a d a)
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: (memq 'a '(b a c a d a)) ![<graphic>](ch6_0.gif) (a c a d a)
- en: (memv 3.4 '(1.2 2.3 3.4 4.5)) ![<graphic>](ch6_0.gif) (3.4 4.5)
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: (memv 3.4 '(1.2 2.3 3.4 4.5)) ![<graphic>](ch6_0.gif) (3.4 4.5)
- en: (memv 3.4 '(1.3 2.5 3.7 4.9)) ![<graphic>](ch6_0.gif) #f
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: (memv 3.4 '(1.3 2.5 3.7 4.9)) ![<graphic>](ch6_0.gif) #f
- en: (let ([ls (list 'a 'b 'c)])
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([ls (list 'a 'b 'c)])
- en: (set-car! (memv 'b ls) 'z)
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: (set-car! (memv 'b ls) 'z)
- en: ls) ![<graphic>](ch6_0.gif) (a z c)
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: ls) ![<graphic>](ch6_0.gif) (a z c)
- en: (member '(b) '((a) (b) (c))) ![<graphic>](ch6_0.gif) ((b) (c))
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: (member '(b) '((a) (b) (c))) ![<graphic>](ch6_0.gif) ((b) (c))
- en: (member '(d) '((a) (b) (c))) ![<graphic>](ch6_0.gif) #f
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: (member '(d) '((a) (b) (c))) ![<graphic>](ch6_0.gif) #f
- en: (member "b" '("a" "b" "c")) ![<graphic>](ch6_0.gif) ("b" "c")
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: (member "b" '("a" "b" "c")) ![<graphic>](ch6_0.gif) ("b" "c")
- en: (let ()
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: (let ()
- en: (define member?
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: （define member?
- en: (lambda (x ls)
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: （lambda （x ls）
- en: (and (member x ls) #t)))
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: （and （member x ls） #t）））
- en: (member? '(b) '((a) (b) (c)))) ![<graphic>](ch6_0.gif) #t
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: （member? '（b） '（（a） （b） （c））） ![<graphic>](ch6_0.gif) #t
- en: (define count-occurrences
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: （define count-occurrences
- en: (lambda (x ls)
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: （lambda （x ls）
- en: (cond
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: （cond
- en: '[(memq x ls) =>'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: \[（memq x ls）=>
- en: (lambda (ls)
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: （lambda （ls）
- en: (+ (count-occurrences x (cdr ls)) 1))]
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: （+ （count-occurrences x （cdr ls）） 1）】
- en: '[else 0])))'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: \[else 0]））
- en: (count-occurrences 'a '(a b c d a)) ![<graphic>](ch6_0.gif) 2`
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: （count-occurrences 'a '（a b c d a）） ![<graphic>](ch6_0.gif) 2`
- en: '**procedure**: `(memp *procedure* *list*)`'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**：`（memp *procedure* *list*）`'
- en: '**returns:** the first tail of `*list*` for whose car `*procedure*` returns
    true, or `#f`'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：**`*procedure*`返回true的`*list*`的第一个尾部，或`#f`'
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `（rnrs lists）`，`（rnrs）`'
- en: '`*procedure*` should accept one argument and return a single value. It should
    not modify `*list*`.'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '`*procedure*`应该接受一个参数并返回一个值。它不应该修改`*list*`。'
- en: '`(memp odd? ''(1 2 3 4)) ![<graphic>](ch6_0.gif) (1 2 3 4)'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '`（memp odd? ''（1 2 3 4））` ![<graphic>](ch6_0.gif) （1 2 3 4）'
- en: (memp even? '(1 2 3 4)) ![<graphic>](ch6_0.gif) (2 3 4)
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: （memp even? '（1 2 3 4）） ![<graphic>](ch6_0.gif) （2 3 4）
- en: (let ([ls (list 1 2 3 4)])
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: （let （[ls （list 1 2 3 4）]）
- en: (eq? (memp odd? ls) ls)) ![<graphic>](ch6_0.gif) #t
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: （eq? （memp odd? ls） ls）） ![<graphic>](ch6_0.gif) #t
- en: (let ([ls (list 1 2 3 4)])
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: （let （[ls （list 1 2 3 4）]）
- en: (eq? (memp even? ls) (cdr ls))) ![<graphic>](ch6_0.gif) #t
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: （eq? （memp even? ls） （cdr ls））） ![<graphic>](ch6_0.gif) #t
- en: (memp odd? '(2 4 6 8)) ![<graphic>](ch6_0.gif) #f`
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: （memp odd? '（2 4 6 8）） ![<graphic>](ch6_0.gif) #f`
- en: '**procedure**: `(remq *obj* *list*)`'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**：`（remq *obj* *list*）`'
- en: '**procedure**: `(remv *obj* *list*)`'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**：`（remv *obj* *list*）`'
- en: '**procedure**: `(remove *obj* *list*)`'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**：`（remove *obj* *list*）`'
- en: '**returns:** a list containing the elements of `*list*` with all occurrences
    of `*obj*` removed'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：**一个包含删除所有`*obj*`出现的`*list*`的元素的列表'
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `（rnrs lists）`，`（rnrs）`'
- en: These procedures traverse the argument `*list*`, removing any objects that are
    equivalent to `*obj*`. The elements remaining in the output list are in the same
    order as they appear in the input list. If a tail of `*list*` (including `*list*`
    itself) contains no occurrences of `*obj*`, the corresponding tail of the result
    list may be the same (by `eq?`) as the tail of the input list.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过程遍历参数`*list*`，移除任何等于`*obj*`的对象。输出列表中剩余的元素与它们在输入列表中出现的顺序相同。如果`*list*`的一个尾部（包括`*list*`本身）不包含`*obj*`的任何出现，则结果列表的相应尾部可能与输入列表的尾部相同（通过`eq?`）。
- en: The equivalence test for `remq` is `eq?`, for `remv` is `eqv?`, and for `remove`
    is `equal?`.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '`remq`的等价测试是`eq?`，对于`remv`是`eqv?`，对于`remove`是`equal?`。'
- en: '`(remq ''a ''(a b a c a d)) ![<graphic>](ch6_0.gif) (b c d)'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '`（remq ''a ''（a b a c a d））` ![<graphic>](ch6_0.gif) （b c d）'
- en: (remq 'a '(b c d)) ![<graphic>](ch6_0.gif) (b c d)
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: （remq 'a '（b c d）） ![<graphic>](ch6_0.gif) （b c d）
- en: (remv 1/2 '(1.2 1/2 0.5 3/2 4)) ![<graphic>](ch6_0.gif) (1.2 0.5 3/2 4)
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: （remv 1/2 '（1.2 1/2 0.5 3/2 4）） ![<graphic>](ch6_0.gif) （1.2 0.5 3/2 4）
- en: (remove '(b) '((a) (b) (c))) ![<graphic>](ch6_0.gif) ((a) (c))`
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: （remove '（b） '（（a） （b） （c））） ![<graphic>](ch6_0.gif) （（a） （c））`
- en: '**procedure**: `(remp *procedure* *list*)`'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**：`（remp *procedure* *list*）`'
- en: '**returns:** a list of the elements of `*list*` for which `*procedure*` returns
    `#f`'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：**一个包含`*procedure*`返回`#f`的`*list*`中元素的列表'
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `（rnrs lists）`，`（rnrs）`'
- en: '`*procedure*` should accept one argument and return a single value. It should
    not modify `*list*`.'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '`*procedure*`应该接受一个参数并返回一个值。它不应该修改`*list*`。'
- en: '`remp` applies `*procedure*` to each element of `*list*` and returns a list
    containing only the elements for which `*procedure*` returns `#f`. The elements
    of the returned list appear in the same order as they appeared in the original
    list.'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '`remp`将`*procedure*`应用于`*list*`的每个元素，并返回一个仅包含`*procedure*`返回`#f`的元素的列表。返回的列表的元素按照它们在原始列表中出现的顺序排列。'
- en: '`(remp odd? ''(1 2 3 4)) ![<graphic>](ch6_0.gif) (2 4)'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '`（remp odd? ''（1 2 3 4））` ![<graphic>](ch6_0.gif) （2 4）'
- en: (remp
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: （remp
- en: (lambda (x) (and (> x 0) (< x 10)))
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: （lambda （x）（and （> x 0）（< x 10）））
- en: '''(-5 15 3 14 -20 6 0 -9)) ![<graphic>](ch6_0.gif) (-5 15 14 -20 0 -9)`'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '''（-5 15 3 14 -20 6 0 -9）） ![<graphic>](ch6_0.gif) （-5 15 14 -20 0 -9）`'
- en: '**procedure**: `(filter *procedure* *list*)`'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**：`（filter *procedure* *list*）`'
- en: '**returns:** a list of the elements of `*list*` for which `*procedure*` returns
    true'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：**`*procedure*`返回true的`*list*`的元素列表'
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `（rnrs lists）`，`（rnrs）`'
- en: '`*procedure*` should accept one argument and return a single value. It should
    not modify `*list*`.'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '`*procedure*`应该接受一个参数并返回一个值。它不应该修改`*list*`。'
- en: '`filter` applies `*procedure*` to each element of `*list*` and returns a new
    list containing only the elements for which `*procedure*` returns true. The elements
    of the returned list appear in the same order as they appeared in the original
    list.'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`将`*procedure*`应用于`*list*`的每个元素，并返回一个新列表，仅包含`*procedure*`返回true的元素。返回的列表中的元素与它们在原始列表中出现的顺序相同。'
- en: '`(filter odd? ''(1 2 3 4)) ![<graphic>](ch6_0.gif) (1 3)'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '`(filter odd? ''(1 2 3 4)) ![<graphic>](ch6_0.gif) (1 3)'
- en: (filter
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: (filter
- en: (lambda (x) (and (> x 0) (< x 10)))
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x) (and (> x 0) (< x 10)))
- en: '''(-5 15 3 14 -20 6 0 -9)) ![<graphic>](ch6_0.gif) (3 6)`'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '''(-5 15 3 14 -20 6 0 -9)) ![<graphic>](ch6_0.gif) (3 6)`'
- en: '**procedure**: `(partition *procedure* *list*)`'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(partition *procedure* *list*)`'
- en: '**returns:** see below'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 请参见下文'
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs lists)`, `(rnrs)`'
- en: '`*procedure*` should accept one argument and return a single value. It should
    not modify `*list*`.'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '`*procedure*`应接受一个参数并返回一个值。它不应修改`*list*`。'
- en: '`partition` applies `*procedure*` to each element of `*list*` and returns two
    values: a new list containing only the elements for which `*procedure*` returns
    true, and a new list containing only the elements for which `*procedure*` returns
    `#f`. The elements of the returned lists appear in the same order as they appeared
    in the original list.'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition`将`*procedure*`应用于`*list*`的每个元素，并返回两个值：一个新列表，仅包含`*procedure*`返回true的元素，以及一个新列表，仅包含`*procedure*`返回`#f`的元素。返回的列表中的元素与它们在原始列表中出现的顺序相同。'
- en: '`(partition odd? ''(1 2 3 4)) ![<graphic>](ch6_0.gif) (1 3)'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '`(partition odd? ''(1 2 3 4)) ![<graphic>](ch6_0.gif) (1 3)'
- en: '![](ch3_ghostRightarrow.gif) (2 4)'
  id: totrans-707
  prefs: []
  type: TYPE_IMG
  zh: '![](ch3_ghostRightarrow.gif) (2 4)'
- en: (partition
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: (partition
- en: (lambda (x) (and (> x 0) (< x 10)))
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x) (and (> x 0) (< x 10)))
- en: '''(-5 15 3 14 -20 6 0 -9)) ![<graphic>](ch6_0.gif) (3 6)'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '''(-5 15 3 14 -20 6 0 -9)) ![<graphic>](ch6_0.gif) (3 6)'
- en: '![](ch3_ghostRightarrow.gif) (-5 15 14 -20 0 -9)`'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '![](ch3_ghostRightarrow.gif) (-5 15 14 -20 0 -9)`'
- en: The values returned by `partition` can be obtained by calling `filter` and `remp`
    separately, but this would require two calls to `*procedure*` for each element
    of `*list*`.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分别调用`filter`和`remp`可以获得`partition`返回的值，但这将要求对`*list*`的每个元素调用两次`*procedure*`。
- en: '**procedure**: `(find *procedure* *list*)`'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(find *procedure* *list*)`'
- en: '**returns:** the first element of `*list*` for which `*procedure*` returns
    true, or `#f`'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*procedure*`对`*list*`返回true的第一个元素，或`#f`'
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs lists)`, `(rnrs)`'
- en: '`*procedure*` should accept one argument and return a single value. It should
    not modify `*list*`.'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '`*procedure*`应接受一个参数并返回一个值。它不应修改`*list*`。'
- en: '`find` traverses the argument `*list*` in order, applying `*procedure*` to
    each element in turn. If `*procedure*` returns a true value for a given element,
    `find` returns that element without applying `*procedure*` to the remaining elements.
    If `*procedure*` returns `#f` for each element of `*list*`, `find` returns `#f`.'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`按顺序遍历参数`*list*`，依次将`*procedure*`应用于每个元素。如果`*procedure*`对给定元素返回true值，则`find`返回该元素，而不会将`*procedure*`应用于剩余元素。如果`*procedure*`对`*list*`的每个元素都返回`#f`，则`find`返回`#f`。'
- en: If a program must distinguish between finding `#f` in the list and finding no
    element at all, `memp` should be used instead.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序必须区分在列表中找到`#f`和根本找不到元素之间的区别，则应使用`memp`。
- en: '`(find odd? ''(1 2 3 4)) ![<graphic>](ch6_0.gif) 1'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '`(find odd? ''(1 2 3 4)) ![<graphic>](ch6_0.gif) 1'
- en: (find even? '(1 2 3 4)) ![<graphic>](ch6_0.gif) 2
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: (find even? '(1 2 3 4)) ![<graphic>](ch6_0.gif) 2
- en: (find odd? '(2 4 6 8)) ![<graphic>](ch6_0.gif) #f
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: (find odd? '(2 4 6 8)) ![<graphic>](ch6_0.gif) #f
- en: (find not '(1 a #f 55)) ![<graphic>](ch6_0.gif) #f`
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: (find not '(1 a #f 55)) ![<graphic>](ch6_0.gif) #f`
- en: '**procedure**: `(assq *obj* *alist*)`'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(assq *obj* *alist*)`'
- en: '**procedure**: `(assv *obj* *alist*)`'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(assv *obj* *alist*)`'
- en: '**procedure**: `(assoc *obj* *alist*)`'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(assoc *obj* *alist*)`'
- en: '**returns:** first element of `*alist*` whose car is equivalent to `*obj*`,
    or `#f`'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*alist*`的`car`等价于`*obj*`的第一个元素，或`#f`'
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs lists)`, `(rnrs)`'
- en: The argument `*alist*` must be an *association list*. An association list is
    a proper list whose elements are key-value pairs of the form `(key . value)`.
    Associations are useful for storing information (values) associated with certain
    objects (keys).
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`*alist*`必须是一个*关联列表*。关联列表是一个适当的列表，其元素是形式为`(key . value)`的键值对。关联对用于存储与某些对象（键）关联的信息（值）。
- en: These procedures traverse the association list, testing each key for equivalence
    with `*obj*`. If an equivalent key is found, the key-value pair is returned. Otherwise,
    `#f` is returned.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过程遍历关联列表，测试每个键是否等价于`*obj*`。如果找到等价的键，则返回键值对。否则，返回`#f`。
- en: The equivalence test for `assq` is `eq?`, for `assv` is `eqv?`, and for `assoc`
    is `equal?`. `assq` may be defined without error checks as follows.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '`assq` 的等价测试是 `eq?`，`assv` 的是 `eqv?`，`assoc` 的是 `equal?`。`assq` 可以无需错误检查地定义如下。'
- en: '`(define assq'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define assq'
- en: (lambda (x ls)
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x ls)
- en: (cond
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(null? ls) #f]'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '[(null? ls) #f]'
- en: '[(eq? (caar ls) x) (car ls)]'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '[(eq? (caar ls) x) (car ls)]'
- en: '[else (assq x (cdr ls))])))`'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (assq x (cdr ls))])))`'
- en: '`assv` and `assoc` may be defined similarly, with `eqv?` and `equal?` in place
    of `eq?`.'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '`assv` 和 `assoc` 可以类似地定义，只需用 `eqv?` 和 `equal?` 替换 `eq?`。'
- en: '`(assq ''b ''((a . 1) (b . 2))) ![<graphic>](ch6_0.gif) (b . 2)'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '`(assq ''b ''((a . 1) (b . 2))) ![<graphic>](ch6_0.gif) (b . 2)'
- en: (cdr (assq 'b '((a . 1) (b . 2)))) ![<graphic>](ch6_0.gif) 2
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr (assq 'b '((a . 1) (b . 2)))) ![<graphic>](ch6_0.gif) 2
- en: (assq 'c '((a . 1) (b . 2))) ![<graphic>](ch6_0.gif) #f
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: (assq 'c '((a . 1) (b . 2))) ![<graphic>](ch6_0.gif) #f
- en: (assv 2/3 '((1/3 . 1) (2/3 . 2))) ![<graphic>](ch6_0.gif) (2/3 . 2)
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: (assv 2/3 '((1/3 . 1) (2/3 . 2))) ![<graphic>](ch6_0.gif) (2/3 . 2)
- en: (assv 2/3 '((1/3 . a) (3/4 . b))) ![<graphic>](ch6_0.gif) #f
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: (assv 2/3 '((1/3 . a) (3/4 . b))) ![<graphic>](ch6_0.gif) #f
- en: (assoc '(a) '(((a) . a) (-1 . b))) ![<graphic>](ch6_0.gif) ((a) . a)
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: (assoc '(a) '(((a) . a) (-1 . b))) ![<graphic>](ch6_0.gif) ((a) . a)
- en: (assoc '(a) '(((b) . b) (a . c))) ![<graphic>](ch6_0.gif) #f
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: (assoc '(a) '(((b) . b) (a . c))) ![<graphic>](ch6_0.gif) #f
- en: (let ([alist (list (cons 2 'a) (cons 3 'b))])
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([alist (list (cons 2 'a) (cons 3 'b))])
- en: (set-cdr! (assv 3 alist) 'c)
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cdr! (assv 3 alist) 'c)
- en: alist) ![<graphic>](ch6_0.gif) ((2 . a) (3 . c))`
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: alist) ![<graphic>](ch6_0.gif) ((2 . a) (3 . c))`
- en: The interpreter given in Section [12.7](examples.html#g187) represents environments
    as association lists and uses `assq` for both variable lookup and assignment.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [12.7](examples.html#g187) 节中给出的解释器将环境表示为关联列表，并对变量查找和赋值都使用 `assq`。
- en: '**procedure**: `(assp *procedure* *alist*)`'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(assp *procedure* *alist*)`'
- en: '**returns:** first element of `*alist*` for whose car `*procedure*` returns
    true, or `#f`'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*procedure*` 返回 true 的 `*alist*` 的第一个元素，或 `#f`'
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs lists)`, `(rnrs)`'
- en: '`*alist*` must be an *association list*. An association list is a proper list
    whose elements are key-value pairs of the form `(key . value)`. `*procedure*`
    should accept one argument and return a single value. It should not modify `*list*`.'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '`*alist*` 必须是一个 *关联列表*。关联列表是一个适当的列表，其元素是形式为 `(key . value)` 的键-值对。`*procedure*`
    应接受一个参数并返回一个值。它不应修改 `*list*`。'
- en: '`(assp odd? ''((1 . a) (2 . b))) ![<graphic>](ch6_0.gif) (1 . a)'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '`(assp odd? ''((1 . a) (2 . b))) ![<graphic>](ch6_0.gif) (1 . a)'
- en: (assp even? '((1 . a) (2 . b))) ![<graphic>](ch6_0.gif) (2 . b)
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: (assp even? '((1 . a) (2 . b))) ![<graphic>](ch6_0.gif) (2 . b)
- en: (let ([ls (list (cons 1 'a) (cons 2 'b))])
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([ls (list (cons 1 'a) (cons 2 'b))])
- en: (eq? (assp odd? ls) (car ls))) ![<graphic>](ch6_0.gif) #t
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: (eq? (assp odd? ls) (car ls))) ![<graphic>](ch6_0.gif) #t
- en: (let ([ls (list (cons 1 'a) (cons 2 'b))])
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([ls (list (cons 1 'a) (cons 2 'b))])
- en: (eq? (assp even? ls) (cadr ls))) ![<graphic>](ch6_0.gif) #t
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: (eq? (assp even? ls) (cadr ls))) ![<graphic>](ch6_0.gif) #t
- en: (assp odd? '((2 . b))) ![<graphic>](ch6_0.gif) #f`
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: (assp odd? '((2 . b))) ![<graphic>](ch6_0.gif) #f`
- en: '**procedure**: `(list-sort *predicate* *list*)`'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(list-sort *predicate* *list*)`'
- en: '**returns:** a list containing the elements of `*list*` sorted according to
    `*predicate*`'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 包含根据 `*predicate*` 排序的 `*list*` 元素的列表'
- en: '**libraries:** `(rnrs sorting)`, `(rnrs)`'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs sorting)`, `(rnrs)`'
- en: '`*predicate*` should be a procedure that expects two arguments and returns
    `#t` if its first argument must precede its second in the sorted list. That is,
    if `*predicate*` is applied to two elements `*x*` and `*y*`, where `*x*` appears
    after `*y*` in the input list, it should return true only if `*x*` should appear
    before `*y*` in the output list. If this constraint is met, `list-sort` performs
    a stable sort, i.e., two elements are reordered only when necessary according
    to `*predicate*`. Duplicate elements are not removed. This procedure may call
    predicate up to *n*log*n* times, where *n* is the length of `*list*`.'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '`*predicate*` 应该是一个期望两个参数并在排序列表中第一个参数必须在第二个参数之前时返回 `#t` 的过程。也就是说，如果将 `*predicate*`
    应用于两个元素 `*x*` 和 `*y*`，其中 `*x*` 在输入列表中位于 `*y*` 之后，则仅当 `*x*` 应该在输出列表中出现在 `*y*` 之前时，它才应返回
    true。如果满足此约束，`list-sort` 执行稳定排序，即仅在根据 `*predicate*` 必要时重新排序两个元素。不会删除重复元素。此过程最多可能调用
    *n*log*n* 次 `predicate`，其中 *n* 是 `*list*` 的长度。'
- en: '`(list-sort < ''(3 4 2 1 2 5)) ![<graphic>](ch6_0.gif) (1 2 2 3 4 5)'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '`(list-sort < ''(3 4 2 1 2 5)) ![<graphic>](ch6_0.gif) (1 2 2 3 4 5)'
- en: (list-sort > '(0.5 1/2)) ![<graphic>](ch6_0.gif) (0.5 1/2)
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: (list-sort > '(0.5 1/2)) ![<graphic>](ch6_0.gif) (0.5 1/2)
- en: (list-sort > '(1/2 0.5)) ![<graphic>](ch6_0.gif) (1/2 0.5)
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: (list-sort > '(1/2 0.5)) ![<graphic>](ch6_0.gif) (1/2 0.5)
- en: (list->string
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: (list->string
- en: (list-sort char>?
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: (list-sort char>?
- en: (string->list "hello"))) ![<graphic>](ch6_0.gif) "ollhe"`
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: (string->list "hello"))) ![<graphic>](ch6_0.gif) "ollhe"`
- en: Section 6.4\. Numbers
  id: totrans-770
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 6.4 节。数字
- en: Scheme numbers may be classified as integers, rational numbers, real numbers,
    or complex numbers. This classification is hierarchical, in that all integers
    are rational, all rational numbers are real, and all real numbers are complex.
    The predicates `integer?`, `rational?`, `real?`, and `complex?` described in Section [6.2](objects.html#g108)
    are used to determine into which of these classes a number falls.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 方案数字可以分类为整数、有理数、实数或复数。这种分类是分层的，即所有整数都是有理数，所有有理数都是实数，所有实数都是复数。在[6.2](objects.html#g108)节中描述的`integer?`、`rational?`、`real?`和`complex?`谓词用于确定数字属于这些类别中的哪一个。
- en: 'A Scheme number may also be classified as *exact* or *inexact*, depending upon
    the quality of operations used to derive the number and the inputs to these operations.
    The predicates `exact?` and `inexact?` may be used to determine the exactness
    of a number. Most operations on numbers in Scheme are *exactness preserving*:
    if given exact operands they return exact values, and if given inexact operands
    or a combination of exact and inexact operands they return inexact values.'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 方案数字也可以根据用于导出数字的操作的质量和这些操作的输入而分类为*精确*或*不精确*。谓词`exact?`和`inexact?`可用于确定数字的精确性。Scheme中的大多数数字操作都是*精确性保持*的：如果给定精确操作数，它们返回精确值，如果给定不精确操作数或精确和不精确操作数的组合，它们返回不精确值。
- en: Exact integer and rational arithmetic is typically supported to arbitrary precision;
    the size of an integer or of the denominator or numerator of a ratio is limited
    only by system storage constraints. Although other representations are possible,
    inexact numbers are typically represented by *floating-point* numbers supported
    by the host computer's hardware or by system software. Complex numbers are typically
    represented as ordered pairs (`*real-part*`, `*imag-part*`), where `*real-part*`
    and `*imag-part*` are exact integers, exact rationals, or floating-point numbers.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 精确整数和有理数算术通常支持任意精度；整数的大小或比率的分母或分子仅受系统存储约束限制。虽然其他表示是可能的，但通常通过主机计算机硬件或系统软件支持的*浮点*数表示不精确数。复数通常表示为有序对(`*real-part*`、`*imag-part*`)，其中`*real-part*`和`*imag-part*`是精确整数、精确有理数或浮点数。
- en: Scheme numbers are written in a straightforward manner not much different from
    ordinary conventions for writing numbers. An exact integer is normally written
    as a sequence of numerals preceded by an optional sign. For example, `3`, `+19`,
    `-100000`, and `208423089237489374` all represent exact integers.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme数字的书写方式与书写数字的普通约定没有太大区别。精确整数通常写成一个由可选符号开头的数字序列。例如，`3`、`+19`、`-100000`和`208423089237489374`都表示精确整数。
- en: An exact rational number is normally written as two sequences of numerals separated
    by a slash (`/`) and preceded by an optional sign. For example, `3/4`, `-6/5`,
    and `1/1208203823` are all exact rational numbers. A ratio is reduced immediately
    to lowest terms when it is read and may in fact reduce to an exact integer.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 一个精确的有理数通常写成两个由斜杠(`/`)分隔的数字序列，并在可选的符号之前。例如，`3/4`、`-6/5`和`1/1208203823`都是精确的有理数。当读取时，比率立即缩减到最低项，实际上可能缩减为精确整数。
- en: Inexact real numbers are normally written in either floating-point or scientific
    notation. Floating-point notation consists of a sequence of numerals followed
    by a decimal point and another sequence of numerals, all preceded by an optional
    sign. Scientific notation consists of an optional sign, a sequence of numerals,
    an optional decimal point followed by a second string of numerals, and an exponent;
    an exponent is written as the letter `e` followed by an optional sign and a sequence
    of numerals. For example, `1.0` and `-200.0` are valid inexact integers, and `1.5`,
    `0.034`, `-10e-10` and `1.5e-5` are valid inexact rational numbers. The exponent
    is the power of ten by which the number preceding the exponent should be scaled,
    so that `2e3` is equivalent to `2000.0`.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 不精确实数通常以浮点或科学记数法书写。浮点表示法由一个数字序列后跟一个小数点和另一个数字序列组成，所有这些数字序列之前都有一个可选符号。科学记数法由一个可选符号、一个数字序列、一个可选的小数点后跟一个第二个数字序列和一个指数组成；指数写为字母`e`后跟一个可选符号和一个数字序列。例如，`1.0`和`-200.0`是有效的不精确整数，`1.5`、`0.034`、`-10e-10`和`1.5e-5`是有效的不精确有理数。指数是应该缩放到指数之前的数字的十的幂，因此`2e3`等同于`2000.0`。
- en: A mantissa width `|*w*` may appear as the suffix of a real number or the real
    components of a complex number written in floating-point or scientific notation.
    The mantissa width `*m*` represents the number of significant bits in the representation
    of the number. The mantissa width defaults to 53, the number of significant bits
    in a normalized IEEE double floating-point number, or more. For denormalized IEEE
    double floating-point numbers, the mantissa width is less than 53. If an implementation
    cannot represent a number with the mantissa width specified, it uses a representation
    with at least as many significant bits as requested if possible, otherwise it
    uses its representation with the largest mantissa width.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 尾数宽度`|*w*`可以作为实数或复数的实部的后缀，写成浮点或科学计数法。尾数宽度`*m*`表示数字表示中的有效位数。尾数宽度默认为53，即规范化IEEE双精度浮点数中的有效位数，或更多。对于非规范化IEEE双精度浮点数，尾数宽度小于53。如果实现无法表示具有指定尾数宽度的数字，则尽可能使用具有至少与请求的有效位数相同的表示，否则使用具有最大尾数宽度的表示。
- en: Exact and inexact real numbers are written as exact or inexact integers or rational
    numbers; no provision is made in the syntax of Scheme numbers for nonrational
    real numbers, i.e., irrational numbers.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 精确和非精确实数被写成精确或非精确整数或有理数；Scheme数字的语法中没有为非有理实数（即无理数）提供规定。
- en: Complex numbers may be written in either rectangular or polar form. In rectangular
    form, a complex number is written as `*x*+*y*i` or `*x*-*y*i`, where `*x*` is
    an integer, rational, or real number and `*y*` is an unsigned integer, rational,
    or real number. The real part, *x*, may be omitted, in which case it is assumed
    to be zero. For example, `3+4i`, `3.2-3/4i`, `+i`, and `-3e-5i` are complex numbers
    written in rectangular form. In polar form, a complex number is written as `*x*@*y*`,
    where `*x*` and `*y*` are integer, rational, or real numbers. For example, `1.1@1.764`
    and `-1@-1/2` are complex numbers written in polar form.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 复数可以以矩形形式或极坐标形式表示。在矩形形式中，复数写成`*x*+*y*i`或`*x*-*y*i`，其中`*x*`是整数、有理数或实数，而`*y*`是无符号整数、有理数或实数。实部*x*可以省略，此时假定为零。例如，`3+4i`，`3.2-3/4i`，`+i`和`-3e-5i`是以矩形形式写成的复数。在极坐标形式中，复数写成`*x*@*y*`，其中`*x*`和`*y*`是整数、有理数或实数。例如，`1.1@1.764`和`-1@-1/2`是以极坐标形式写成的复数。
- en: The syntaxes `+inf.0` and `-inf.0` represent inexact real numbers that represent
    positive and negative infinity. The syntaxes `+nan.0` and `-nan.0` represent an
    inexact "not-a-number" (NaN) value. Infinities may be produced by dividing inexact
    positive and negative values by inexact zero, and NaNs may also be produced by
    dividing inexact zero by inexact zero, among other ways.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 语法`+inf.0`和`-inf.0`表示代表正无穷大和负无穷大的非精确实数。语法`+nan.0`和`-nan.0`表示非精确的“非数字”（NaN）值。通过将非精确的正值和负值除以非精确的零，可以产生无穷大，而通过将非精确的零除以非精确的零等方式也可以产生NaN。
- en: The exactness of a numeric representation may be overridden by preceding the
    representation by either `#e` or `#i`. `#e` forces the number to be exact, and
    `#i` forces it to be inexact. For example, `1`, `#e1`, 1/1, `#e1/1`, `#e1.0`,
    and `#e1e0` all represent the exact integer 1, and `#i3/10`, `0.3`, `#i0.3`, and
    `3e-1` all represent the inexact rational 0.3.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 数字表示的精确性可以通过在表示之前加上`#e`或`#i`来覆盖。`#e`强制数字为精确值，而`#i`强制其为非精确值。例如，`1`，`#e1`，1/1，`#e1/1`，`#e1.0`和`#e1e0`都表示精确整数1，而`#i3/10`，`0.3`，`#i0.3`和`3e-1`都表示非精确有理数0.3。
- en: Numbers are written by default in base 10, although the special prefixes `#b`
    (binary), `#o` (octal), `#d` (decimal), and `#x` (hexadecimal) can be used to
    specify base 2, base 8, base 10, or base 16. For radix 16, the letters `a` through
    `f` or `A` through `F` serve as the additional numerals required to express digit
    values 10 through 15. For example, `#b10101` is the binary equivalent of 21[10],
    `#o72` is the octal equivalent of 58[10], and `#xC7` is the hexadecimal equivalent
    of 199[10]. Numbers written in floating-point and scientific notations are always
    written in base 10.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 数字默认以十进制表示，尽管特殊前缀`#b`（二进制）、`#o`（八进制）、`#d`（十进制）和`#x`（十六进制）可用于指定基数2、基数8、基数10或基数16。对于基数16，字母`a`到`f`或`A`到`F`用作表示数字值10到15所需的额外数字。例如，`#b10101`是21[10]的二进制等价物，`#o72`是58[10]的八进制等价物，`#xC7`是199[10]的十六进制等价物。浮点数和科学计数法表示的数字始终以十进制表示。
- en: If both are present, radix and exactness prefixes may appear in either order.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两者都存在，基数和精确性前缀可以以任意顺序出现。
- en: A Scheme implementation may support more than one size of internal representation
    for inexact quantities. The exponent markers `s` (*short*), `f` (*single*), `d`
    (*double*), and `l` (*long*) may appear in place of the default exponent marker
    `e` to override the default size for numbers written in scientific notation. In
    implementations that support multiple representations, the default size has at
    least as much precision as *double*.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme 实现可能支持多种不精确数量的内部表示尺寸。指数标记符`s`（*short*）、`f`（*single*）、`d`（*double*）和`l`（*long*）可以出现在默认指数标记符`e`的位置，以覆盖科学计数法中写入的数字的默认尺寸。在支持多个表示的实现中，默认尺寸至少具有与
    *double* 一样多的精度。
- en: A precise grammar for Scheme numbers is given on page [459](grammar.html#grammar:numbers).
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Scheme 数字提供了精确的语法，请参见[459](grammar.html#grammar:numbers)页。
- en: Any number can be written in a variety of different ways, but the system printer
    (invoked by `put-datum`, `write`, and `display`) and `number->string` express
    numbers in a compact form, using the fewest number of digits necessary to retain
    the property that, when read, the printed number is identical to the original
    number.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数字都可以用各种不同的方式写入，但系统打印程序（通过`put-datum`、`write`和`display`调用）和`number->string`以紧凑的形式表达数字，使用尽可能少的数字以保留属性，即读取时打印的数字与原始数字相同。
- en: The remainder of this section describes "generic arithmetic" procedures that
    operate on numbers. The two sections that follow this section describe operations
    specific to *fixnums* and *flonums*, which are representations of exact, fixed-precision
    integer values and inexact real values.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分描述了对数字进行操作的“通用算术”过程。接下来的两节描述了特定于 *fixnums* 和 *flonums* 的操作，它们分别是精确、固定精度整数值和不精确实值的表示。
- en: 'The types of numeric arguments accepted by the procedures in this section are
    implied by the names given to the arguments: `*num*` for complex numbers (that
    is, all numbers), `*real*` for real numbers, `*rat*` for rational numbers, and
    `*int*` for integers. If a `*real*`, `*rat*`, or `*int*` is required, the argument
    must be considered real, rational, or integral by `real?`, `rational?`, or `integer?`,
    i.e., the imaginary part of the number must be exactly zero. Where exact integers
    are required, the name `*exint*` is used. In each case, a suffix may appear on
    the name, e.g., `*int[2]*`.'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的过程所接受的数值参数的类型由给定参数的名称隐含：对于复数（即所有数字），`*num*`；对于实数，`*real*`；对于有理数，`*rat*`；对于整数，`*int*`。如果需要
    `*real*`、`*rat*` 或 `*int*`，则必须通过 `real?`、`rational?` 或 `integer?` 将参数视为实数、有理数或整数，即数字的虚部必须完全为零。如果需要精确整数，则使用名称
    `*exint*`。在每种情况下，名称后缀可能出现，例如 `*int[2]*`。
- en: '**procedure**: `(exact? *num*)`'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(exact? *num*)`'
- en: '**returns:** `#t` if `*num*` is exact, `#f` otherwise'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t` 如果 `*num*` 是精确的，则返回 `#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`(exact? 1) ![<graphic>](ch6_0.gif) #t'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '`(exact? 1) ![<graphic>](ch6_0.gif) #t'
- en: (exact? -15/16) ![<graphic>](ch6_0.gif) #t
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: (exact? -15/16) ![<graphic>](ch6_0.gif) #t
- en: (exact? 2.01) ![<graphic>](ch6_0.gif) #f
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: (exact? 2.01) ![<graphic>](ch6_0.gif) #f
- en: (exact? #i77) ![<graphic>](ch6_0.gif) #f
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: (exact? #i77) ![<graphic>](ch6_0.gif) #f
- en: (exact? #i2/3) ![<graphic>](ch6_0.gif) #f
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: (exact? #i2/3) ![<graphic>](ch6_0.gif) #f
- en: (exact? 1.0-2i) ![<graphic>](ch6_0.gif) #f`
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: (exact? 1.0-2i) ![<graphic>](ch6_0.gif) #f`
- en: '**procedure**: `(inexact? *num*)`'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(inexact? *num*)`'
- en: '**returns:** `#t` if `*num*` is inexact, `#f` otherwise'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t` 如果 `*num*` 是不精确的，则返回 `#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`(inexact? -123) ![<graphic>](ch6_0.gif) #f'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '`(inexact? -123) ![<graphic>](ch6_0.gif) #f'
- en: (inexact? #i123) ![<graphic>](ch6_0.gif) #t
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: (inexact? #i123) ![<graphic>](ch6_0.gif) #t
- en: (inexact? 1e23) ![<graphic>](ch6_0.gif) #t
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: (inexact? 1e23) ![<graphic>](ch6_0.gif) #t
- en: (inexact? +i) ![<graphic>](ch6_0.gif) #f`
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: (inexact? +i) ![<graphic>](ch6_0.gif) #f`
- en: '**procedure**: `(= *num[1]* *num[2]* *num[3]* ...)`'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(= *num[1]* *num[2]* *num[3]* ...)`'
- en: '**procedure**: `(< *real[1]* *real[2]* *real[3]* ...)`'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(< *real[1]* *real[2]* *real[3]* ...)`'
- en: '**procedure**: `(> *real[1]* *real[2]* *real[3]* ...)`'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(> *real[1]* *real[2]* *real[3]* ...)`'
- en: '**procedure**: `(<= *real[1]* *real[2]* *real[3]* ...)`'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(<= *real[1]* *real[2]* *real[3]* ...)`'
- en: '**procedure**: `(>= *real[1]* *real[2]* *real[3]* ...)`'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(>= *real[1]* *real[2]* *real[3]* ...)`'
- en: '**returns:** `#t` if the relation holds, `#f` otherwise'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `#t` 如果关系成立，则返回 `#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: The predicate `=` returns `#t` if its arguments are equal. The predicate `<`
    returns `#t` if its arguments are monotonically increasing, i.e., each argument
    is greater than the preceding ones, while `>` returns `#t` if its arguments are
    monotonically decreasing. The predicate `<=` returns `#t` if its arguments are
    monotonically nondecreasing, i.e., each argument is not less than the preceding
    ones, while `>=` returns `#t` if its arguments are monotonically nonincreasing.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: The predicate `=` returns `#t` if its arguments are equal. The predicate `<`
    returns `#t` if its arguments are monotonically increasing, i.e., each argument
    is greater than the preceding ones, while `>` returns `#t` if its arguments are
    monotonically decreasing. The predicate `<=` returns `#t` if its arguments are
    monotonically nondecreasing, i.e., each argument is not less than the preceding
    ones, while `>=` returns `#t` if its arguments are monotonically nonincreasing.
- en: As implied by the names of the arguments, `=` is defined for complex arguments
    while the other relational predicates are defined only for real arguments. Two
    complex numbers are considered equal if their real and imaginary parts are equal.
    Comparisons involving NaNs always return `#f`.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: As implied by the names of the arguments, `=` is defined for complex arguments
    while the other relational predicates are defined only for real arguments. Two
    complex numbers are considered equal if their real and imaginary parts are equal.
    Comparisons involving NaNs always return `#f`.
- en: '`(= 7 7) ![<graphic>](ch6_0.gif) #t'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '`(= 7 7) ![<graphic>](ch6_0.gif) #t'
- en: (= 7 9) ![<graphic>](ch6_0.gif) #f
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: (= 7 9) ![<graphic>](ch6_0.gif) #f
- en: (< 2e3 3e2) ![<graphic>](ch6_0.gif) #f
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: (< 2e3 3e2) ![<graphic>](ch6_0.gif) #f
- en: (<= 1 2 3 3 4 5) ![<graphic>](ch6_0.gif) #t
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: (<= 1 2 3 3 4 5) ![<graphic>](ch6_0.gif) #t
- en: (<= 1 2 3 4 5) ![<graphic>](ch6_0.gif) #t
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: (<= 1 2 3 4 5) ![<graphic>](ch6_0.gif) #t
- en: (> 1 2 2 3 3 4) ![<graphic>](ch6_0.gif) #f
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: (> 1 2 2 3 3 4) ![<graphic>](ch6_0.gif) #f
- en: (>= 1 2 2 3 3 4) ![<graphic>](ch6_0.gif) #f
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: (>= 1 2 2 3 3 4) ![<graphic>](ch6_0.gif) #f
- en: (= -1/2 -0.5) ![<graphic>](ch6_0.gif) #t
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: (= -1/2 -0.5) ![<graphic>](ch6_0.gif) #t
- en: (= 2/3 .667) ![<graphic>](ch6_0.gif) #f
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: (= 2/3 .667) ![<graphic>](ch6_0.gif) #f
- en: (= 7.2+0i 7.2) ![<graphic>](ch6_0.gif) #t
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: (= 7.2+0i 7.2) ![<graphic>](ch6_0.gif) #t
- en: (= 7.2-3i 7) ![<graphic>](ch6_0.gif) #f
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: (= 7.2-3i 7) ![<graphic>](ch6_0.gif) #f
- en: (< 1/2 2/3 3/4) ![<graphic>](ch6_0.gif) #t
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: (< 1/2 2/3 3/4) ![<graphic>](ch6_0.gif) #t
- en: (> 8 4.102 2/3 -5) ![<graphic>](ch6_0.gif) #t
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: (> 8 4.102 2/3 -5) ![<graphic>](ch6_0.gif) #t
- en: (let ([x 0.218723452])
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x 0.218723452])
- en: (< 0.210 x 0.220)) ![<graphic>](ch6_0.gif) #t
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: (< 0.210 x 0.220)) ![<graphic>](ch6_0.gif) #t
- en: (let ([i 1] [v (vector 'a 'b 'c)])
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([i 1] [v (vector 'a 'b 'c)])
- en: (< -1 i (vector-length v))) ![<graphic>](ch6_0.gif) #t
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: (< -1 i (vector-length v))) ![<graphic>](ch6_0.gif) #t
- en: (apply < '(1 2 3 4)) ![<graphic>](ch6_0.gif) #t
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: (apply < '(1 2 3 4)) ![<graphic>](ch6_0.gif) #t
- en: (apply > '(4 3 3 2)) ![<graphic>](ch6_0.gif) #f
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: (apply > '(4 3 3 2)) ![<graphic>](ch6_0.gif) #f
- en: (= +nan.0 +nan.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: (= +nan.0 +nan.0) ![<graphic>](ch6_0.gif) #f
- en: (< +nan.0 +nan.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: (< +nan.0 +nan.0) ![<graphic>](ch6_0.gif) #f
- en: (> +nan.0 +nan.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: (> +nan.0 +nan.0) ![<graphic>](ch6_0.gif) #f
- en: (>= +inf.0 +nan.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: (>= +inf.0 +nan.0) ![<graphic>](ch6_0.gif) #f
- en: (>= +nan.0 -inf.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: (>= +nan.0 -inf.0) ![<graphic>](ch6_0.gif) #f
- en: (> +nan.0 0.0) ![<graphic>](ch6_0.gif) #f`
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: (> +nan.0 0.0) ![<graphic>](ch6_0.gif) #f`
- en: '**procedure**: `(+ *num* ...)`'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(+ *num* ...)`'
- en: '**returns:** the sum of the arguments `*num* ...`'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** the sum of the arguments `*num* ...`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: When called with no arguments, `+` returns 0.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: When called with no arguments, `+` returns 0.
- en: '`(+) ![<graphic>](ch6_0.gif) 0'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '`(+) ![<graphic>](ch6_0.gif) 0'
- en: (+ 1 2) ![<graphic>](ch6_0.gif) 3
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: (+ 1 2) ![<graphic>](ch6_0.gif) 3
- en: (+ 1/2 2/3) ![<graphic>](ch6_0.gif) 7/6
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: (+ 1/2 2/3) ![<graphic>](ch6_0.gif) 7/6
- en: (+ 3 4 5) ![<graphic>](ch6_0.gif) 12
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: (+ 3 4 5) ![<graphic>](ch6_0.gif) 12
- en: (+ 3.0 4) ![<graphic>](ch6_0.gif) 7.0
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: (+ 3.0 4) ![<graphic>](ch6_0.gif) 7.0
- en: (+ 3+4i 4+3i) ![<graphic>](ch6_0.gif) 7+7i
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: (+ 3+4i 4+3i) ![<graphic>](ch6_0.gif) 7+7i
- en: (apply + '(1 2 3 4 5)) ![<graphic>](ch6_0.gif) 15`
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: (apply + '(1 2 3 4 5)) ![<graphic>](ch6_0.gif) 15`
- en: '**procedure**: `(- *num*)`'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(- *num*)`'
- en: '**returns:** the additive inverse of `*num*`'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** the additive inverse of `*num*`'
- en: '**procedure**: `(- *num[1]* *num[2]* *num[3]* ...)`'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(- *num[1]* *num[2]* *num[3]* ...)`'
- en: '**returns:** the difference between `*num[1]*` and the sum of `*num[2]* *num[3]* ...`'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** the difference between `*num[1]*` and the sum of `*num[2]* *num[3]* ...`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`(- 3) ![<graphic>](ch6_0.gif) -3'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '`(- 3) ![<graphic>](ch6_0.gif) -3'
- en: (- -2/3) ![<graphic>](ch6_0.gif) 2/3
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: (- -2/3) ![<graphic>](ch6_0.gif) 2/3
- en: (- 4 3.0) ![<graphic>](ch6_0.gif) 1.0
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: (- 4 3.0) ![<graphic>](ch6_0.gif) 1.0
- en: (- 3.25+4.25i 1/4+1/4i) ![<graphic>](ch6_0.gif) 3.0+4.0i
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: (- 3.25+4.25i 1/4+1/4i) ![<graphic>](ch6_0.gif) 3.0+4.0i
- en: (- 4 3 2 1) ![<graphic>](ch6_0.gif) -2`
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: (- 4 3 2 1) ![<graphic>](ch6_0.gif) -2`
- en: '**procedure**: `(* *num* ...)`'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(* *num* ...)`'
- en: '**returns:** the product of the arguments `*num* ...`'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** the product of the arguments `*num* ...`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: When called with no arguments, `*` returns 1.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: When called with no arguments, `*` returns 1.
- en: '`(*) ![<graphic>](ch6_0.gif) 1'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '`(*) ![<graphic>](ch6_0.gif) 1'
- en: (* 3.4) ![<graphic>](ch6_0.gif) 3.4
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: (* 3.4) ![<graphic>](ch6_0.gif) 3.4
- en: (* 1 1/2) ![<graphic>](ch6_0.gif) 1/2
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: (* 1 1/2) ![<graphic>](ch6_0.gif) 1/2
- en: (* 3 4 5.5) ![<graphic>](ch6_0.gif) 66.0
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: (* 3 4 5.5) ![<graphic>](ch6_0.gif) 66.0
- en: (* 1+2i 3+4i) ![<graphic>](ch6_0.gif) -5+10i
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: (* 1+2i 3+4i) ![<graphic>](ch6_0.gif) -5+10i
- en: (apply * '(1 2 3 4 5)) ![<graphic>](ch6_0.gif) 120`
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: (apply * '(1 2 3 4 5)) ![<graphic>](ch6_0.gif) 120`
- en: '**procedure**: `(/ *num*)`'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(/ *num*)`'
- en: '**returns:** the multiplicative inverse of `*num*`'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：`*num*`的倒数'
- en: '**procedure**: `(/ *num[1]* *num[2]* *num[3]* ...)`'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(/ *num[1]* *num[2]* *num[3]* ...)`'
- en: '**returns:** the result of dividing `*num[1]*` by the product of `*num[2]* *num[3]* ...`'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：将`*num[1]*`除以`*num[2]* *num[3]* ...`的乘积的结果'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs base)`，`(rnrs)`'
- en: '`(/ -17) ![<graphic>](ch6_0.gif) -1/17'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '`(/ -17) ![<graphic>](ch6_0.gif) -1/17'
- en: (/ 1/2) ![<graphic>](ch6_0.gif) 2
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: (/ 1/2) ![<graphic>](ch6_0.gif) 2
- en: (/ .5) ![<graphic>](ch6_0.gif) 2.0
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: (/ .5) ![<graphic>](ch6_0.gif) 2.0
- en: (/ 3 4) ![<graphic>](ch6_0.gif) 3/4
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: (/ 3 4) ![<graphic>](ch6_0.gif) 3/4
- en: (/ 3.0 4) ![<graphic>](ch6_0.gif) .75
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: (/ 3.0 4) ![<graphic>](ch6_0.gif) .75
- en: (/ -5+10i 3+4i) ![<graphic>](ch6_0.gif) 1+2i
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: (/ -5+10i 3+4i) ![<graphic>](ch6_0.gif) 1+2i
- en: (/ 60 5 4 3 2) ![<graphic>](ch6_0.gif) 1/2`
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: (/ 60 5 4 3 2) ![<graphic>](ch6_0.gif) 1/2`
- en: '**procedure**: `(zero? *num*)`'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(zero? *num*)`'
- en: '**returns:** `#t` if `*num*` is zero, `#f` otherwise'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果`*num*`为零，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs base)`，`(rnrs)`'
- en: '`zero?` is equivalent to `(lambda (x) (= x 0))`.'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '`zero?`等同于`(lambda (x) (= x 0))`。'
- en: '`(zero? 0) ![<graphic>](ch6_0.gif) #t'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '`(zero? 0) ![<graphic>](ch6_0.gif) #t'
- en: (zero? 1) ![<graphic>](ch6_0.gif) #f
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: (zero? 1) ![<graphic>](ch6_0.gif) #f
- en: (zero? (- 3.0 3.0)) ![<graphic>](ch6_0.gif) #t
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: (zero? (- 3.0 3.0)) ![<graphic>](ch6_0.gif) #t
- en: (zero? (+ 1/2 1/2)) ![<graphic>](ch6_0.gif) #f
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: (zero? (+ 1/2 1/2)) ![<graphic>](ch6_0.gif) #f
- en: (zero? 0+0i) ![<graphic>](ch6_0.gif) #t
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: (zero? 0+0i) ![<graphic>](ch6_0.gif) #t
- en: (zero? 0.0-0.0i) ![<graphic>](ch6_0.gif) #t`
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: (zero? 0.0-0.0i) ![<graphic>](ch6_0.gif) #t`
- en: '**procedure**: `(positive? *real*)`'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(positive? *real*)`'
- en: '**returns:** `#t` if `*real*` is greater than zero, `#f` otherwise'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果`*real*`大于零，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs base)`，`(rnrs)`'
- en: '`positive?` is equivalent to `(lambda (x) (> x 0))`.'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '`positive?`等同于`(lambda (x) (> x 0))`。'
- en: '`(positive? 128) ![<graphic>](ch6_0.gif) #t'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '`(positive? 128) ![<graphic>](ch6_0.gif) #t'
- en: (positive? 0.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: (positive? 0.0) ![<graphic>](ch6_0.gif) #f
- en: (positive? 1.8e-15) ![<graphic>](ch6_0.gif) #t
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: (positive? 1.8e-15) ![<graphic>](ch6_0.gif) #t
- en: (positive? -2/3) ![<graphic>](ch6_0.gif) #f
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: (positive? -2/3) ![<graphic>](ch6_0.gif) #f
- en: (positive? .001-0.0i) ![<graphic>](ch6_0.gif) *exception: not a real number*`
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: (positive? .001-0.0i) ![<graphic>](ch6_0.gif) *异常：不是实数*
- en: '**procedure**: `(negative? *real*)`'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(negative? *real*)`'
- en: '**returns:** `#t` if `*real*` is less than zero, `#f` otherwise'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果`*real*`小于零，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs base)`，`(rnrs)`'
- en: '`negative?` is equivalent to `(lambda (x) (< x 0))`.'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '`negative?`等同于`(lambda (x) (< x 0))`。'
- en: '`(negative? -65) ![<graphic>](ch6_0.gif) #t'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '`(negative? -65) ![<graphic>](ch6_0.gif) #t'
- en: (negative? 0) ![<graphic>](ch6_0.gif) #f
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: (negative? 0) ![<graphic>](ch6_0.gif) #f
- en: (negative? -0.0121) ![<graphic>](ch6_0.gif) #t
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: (negative? -0.0121) ![<graphic>](ch6_0.gif) #t
- en: (negative? 15/16) ![<graphic>](ch6_0.gif) #f
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: (negative? 15/16) ![<graphic>](ch6_0.gif) #f
- en: (negative? -7.0+0.0i) ![<graphic>](ch6_0.gif) *exception: not a real number*`
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: (negative? -7.0+0.0i) ![<graphic>](ch6_0.gif) *异常：不是实数*
- en: '**procedure**: `(even? *int*)`'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(even? *int*)`'
- en: '**returns:** `#t` if `*int*` is even, `#f` otherwise'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果`*int*`是偶数，则返回`#t`，否则返回`#f`'
- en: '**procedure**: `(odd? *int*)`'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(odd? *int*)`'
- en: '**returns:** `#t` if `*int*` is odd, `#f` otherwise'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果`*int*`是奇数，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs base)`，`(rnrs)`'
- en: '`(even? 0) ![<graphic>](ch6_0.gif) #t'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '`(even? 0) ![<graphic>](ch6_0.gif) #t'
- en: (even? 1) ![<graphic>](ch6_0.gif) #f
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: (even? 1) ![<graphic>](ch6_0.gif) #f
- en: (even? 2.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: (even? 2.0) ![<graphic>](ch6_0.gif) #t
- en: (even? -120762398465) ![<graphic>](ch6_0.gif) #f
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: (even? -120762398465) ![<graphic>](ch6_0.gif) #f
- en: (even? 2.0+0.0i) ![<graphic>](ch6_0.gif) *exception: not an integer*
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: (even? 2.0+0.0i) ![<graphic>](ch6_0.gif) *异常：不是整数*
- en: (odd? 0) ![<graphic>](ch6_0.gif) #f
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: (odd? 0) ![<graphic>](ch6_0.gif) #f
- en: (odd? 1) ![<graphic>](ch6_0.gif) #t
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: (odd? 1) ![<graphic>](ch6_0.gif) #t
- en: (odd? 2.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: (odd? 2.0) ![<graphic>](ch6_0.gif) #f
- en: (odd? -120762398465) ![<graphic>](ch6_0.gif) #t
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: (odd? -120762398465) ![<graphic>](ch6_0.gif) #t
- en: (odd? 2.0+0.0i) ![<graphic>](ch6_0.gif) *exception: not an integer*`
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: (odd? 2.0+0.0i) ![<graphic>](ch6_0.gif) *异常：不是整数*
- en: '**procedure**: `(finite? *real*)`'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(finite? *real*)`'
- en: '**returns:** `#t` if `*real*` is finite, `#f` otherwise'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果`*real*`是有限的，则返回`#t`，否则返回`#f`'
- en: '**procedure**: `(infinite? *real*)`'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(infinite? *real*)`'
- en: '**returns:** `#t` if `*real*` is infinite, `#f` otherwise'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果`*real*`是无限的，则返回`#t`，否则返回`#f`'
- en: '**procedure**: `(nan? *real*)`'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**：`(nan? *real*)`'
- en: '**returns:** `#t` if `*real*` is a NaN, `#f` otherwise'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**：如果`*real*`是 NaN，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**：`(rnrs base)`，`(rnrs)`'
- en: '`(finite? 2/3) ![<graphic>](ch6_0.gif) #t'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: (infinite? 2/3) ![<graphic>](ch6_0.gif) #f
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: (nan? 2/3) ![<graphic>](ch6_0.gif) #f
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: (finite? 3.1415) ![<graphic>](ch6_0.gif) #t
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: (infinite? 3.1415) ![<graphic>](ch6_0.gif) #f
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: (nan? 3.1415) ![<graphic>](ch6_0.gif) #f
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: (finite? +inf.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: (infinite? -inf.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: (nan? -inf.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: (finite? +nan.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: (infinite? +nan.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: (nan? +nan.0) ![<graphic>](ch6_0.gif) #t`
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(quotient *int[1]* *int[2]*)`'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer quotient of `*int[1]*` and `*int[2]*`'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(remainder *int[1]* *int[2]*)`'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer remainder of `*int[1]*` and `*int[2]*`'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(modulo *int[1]* *int[2]*)`'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer modulus of `*int[1]*` and `*int[2]*`'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs r5rs)`'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: The result of `remainder` has the same sign as `*int[1]*`, while the result
    of `modulo` has the same sign as `*int[2]*`.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: '`(quotient 45 6) ![<graphic>](ch6_0.gif) 7'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: (quotient 6.0 2.0) ![<graphic>](ch6_0.gif) 3.0
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: (quotient 3.0 -2) ![<graphic>](ch6_0.gif) -1.0
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: (remainder 16 4) ![<graphic>](ch6_0.gif) 0
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: (remainder 5 2) ![<graphic>](ch6_0.gif) 1
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: (remainder -45.0 7) ![<graphic>](ch6_0.gif) -3.0
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: (remainder 10.0 -3.0) ![<graphic>](ch6_0.gif) 1.0
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: (remainder -17 -9) ![<graphic>](ch6_0.gif) -8
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: (modulo 16 4) ![<graphic>](ch6_0.gif) 0
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: (modulo 5 2) ![<graphic>](ch6_0.gif) 1
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: (modulo -45.0 7) ![<graphic>](ch6_0.gif) 4.0
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: (modulo 10.0 -3.0) ![<graphic>](ch6_0.gif) -2.0
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: (modulo -17 -9) ![<graphic>](ch6_0.gif) -8`
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(div *x[1]* *x[2]*)`'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(mod *x[1]* *x[2]*)`'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(div-and-mod *x[1]* *x[2]*)`'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: If `*x[1]*` and `*x[2]*` are exact, `*x[2]*` must not be zero. These procedures
    implement number-theoretic integer division, with the `div` operation being related
    to `quotient` and the `mod` operation being related to `remainder` or `modulo`,
    but in both cases extended to handle real numbers.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: The value `*n[d]*` of `(div *x[1]* *x[2]*)` is an integer, and the value `*x[m]*`
    of `(mod *x[1]* *x[2]*)` is a real number such that *x*[1] = *n*[d] · *x*[2] +
    *x*[m] and 0 ≤ *x*[m] < |*x*[2]|. In situations where the implementation cannot
    represent the mathematical results prescribed by these equations as a number object,
    `div` and `mod` return an unspecified number or raise an exception with condition
    type `&implementation-restriction`.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: The `div-and-mod` procedure behaves as if defined as follows.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (div-and-mod x1 x2) (values (div x1 x2) (mod x1 x2)))`'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, unless it raises an exception in the circumstance described above,
    it returns two values: the result of calling `div` on the two arguments and the
    result of calling `mod` on the two arguments.'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: '`(div 17 3) ![<graphic>](ch6_0.gif) 5'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: (mod 17 3) ![<graphic>](ch6_0.gif) 2
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: (div -17 3) ![<graphic>](ch6_0.gif) -6
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: (mod -17 3) ![<graphic>](ch6_0.gif) 1
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: (div 17 -3) ![<graphic>](ch6_0.gif) -5
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: (div 17 -3) ![<graphic>](ch6_0.gif) -5
- en: (mod 17 -3) ![<graphic>](ch6_0.gif) 2
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: (mod 17 -3) ![<graphic>](ch6_0.gif) 2
- en: (div -17 -3) ![<graphic>](ch6_0.gif) 6
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: (div -17 -3) ![<graphic>](ch6_0.gif) 6
- en: (mod -17 -3) ![<graphic>](ch6_0.gif) 1
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: (mod -17 -3) ![<graphic>](ch6_0.gif) 1
- en: (div-and-mod 17.5 3) ![<graphic>](ch6_0.gif) 5.0
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: (div-and-mod 17.5 3) ![<graphic>](ch6_0.gif) 5.0
- en: '![](ch3_ghostRightarrow.gif) 2.5`'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '![](ch3_ghostRightarrow.gif) 2.5`'
- en: '**procedure**: `(div0 *x[1]* *x[2]*)`'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(div0 *x[1]* *x[2]*)`'
- en: '**procedure**: `(mod0 *x[1]* *x[2]*)`'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(mod0 *x[1]* *x[2]*)`'
- en: '**procedure**: `(div0-and-mod0 *x[1]* *x[2]*)`'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(div0-and-mod0 *x[1]* *x[2]*)`'
- en: '**returns:** see below'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 见下文'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: If `*x[1]*` and `*x[2]*` are exact, `*x[2]*` must not be zero. These procedures
    are similar to `div`, `mod`, and `div-and-mod`, but constrain the "mod" value
    differently, which also affects the "div" value. The value `*n[d]*` of `(div0 *x[1]* *x[2]*)`
    is an integer, and the value `*x[m]*` of `(mod0 *x[1]* *x[2]*)` is a real number
    such that *x*[1] = *n*[d] · *x*[2] + *x*[m] and -|*x*[2]/2| ≤ *x*[m] < |*x*[2]/2|.
    In situations where the implementation cannot represent the mathematical results
    prescribed by these equations as a number object, `div0` and `mod0` return an
    unspecified number or raise an exception with condition type `&implementation-restriction`.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `*x[1]*` 和 `*x[2]*` 是精确的，`*x[2]*` 不能为零。这些过程类似于 `div`、`mod` 和 `div-and-mod`，但对
    "mod" 值施加了不同的约束，这也影响了 "div" 值。`(div0 *x[1]* *x[2]*)` 的值 `*n[d]*` 是一个整数，`(mod0 *x[1]* *x[2]*)`
    的值 `*x[m]*` 是一个实数，满足 *x*[1] = *n*[d] · *x*[2] + *x*[m] 且 -|*x*[2]/2| ≤ *x*[m]
    < |*x*[2]/2|。在实现无法将这些方程规定的数学结果表示为数字对象时，`div0` 和 `mod0` 返回一个未指定的数字或引发带有条件类型 `&implementation-restriction`
    的异常。
- en: The `div0-and-mod0` procedure behaves as if defined as follows.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '`div0-and-mod0` 过程的行为就好像定义如下。'
- en: '`(define (div0-and-mod0 x1 x2) (values (div0 x1 x2) (mod0 x1 x2)))`'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define (div0-and-mod0 x1 x2) (values (div0 x1 x2) (mod0 x1 x2)))`'
- en: 'That is, unless it raises an exception in the circumstance described above,
    it returns two values: the result of calling `div0` on the two arguments and the
    result of calling `mod0` on the two arguments.'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，除非在上述情况下引发异常，否则它返回两个值：对两个参数调用 `div0` 的结果和对两个参数调用 `mod0` 的结果。
- en: '`(div0 17 3) ![<graphic>](ch6_0.gif) 6'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '`(div0 17 3) ![<graphic>](ch6_0.gif) 6'
- en: (mod0 17 3) ![<graphic>](ch6_0.gif) -1
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: (mod0 17 3) ![<graphic>](ch6_0.gif) -1
- en: (div0 -17 3) ![<graphic>](ch6_0.gif) -6
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: (div0 -17 3) ![<graphic>](ch6_0.gif) -6
- en: (mod0 -17 3) ![<graphic>](ch6_0.gif) 1
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: (mod0 -17 3) ![<graphic>](ch6_0.gif) 1
- en: (div0 17 -3) ![<graphic>](ch6_0.gif) -6
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: (div0 17 -3) ![<graphic>](ch6_0.gif) -6
- en: (mod0 17 -3) ![<graphic>](ch6_0.gif) -1
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: (mod0 17 -3) ![<graphic>](ch6_0.gif) -1
- en: (div0 -17 -3) ![<graphic>](ch6_0.gif) 6
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: (div0 -17 -3) ![<graphic>](ch6_0.gif) 6
- en: (mod0 -17 -3) ![<graphic>](ch6_0.gif) 1
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: (mod0 -17 -3) ![<graphic>](ch6_0.gif) 1
- en: (div0-and-mod0 17.5 3) ![<graphic>](ch6_0.gif) 6.0
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: (div0-and-mod0 17.5 3) ![<graphic>](ch6_0.gif) 6.0
- en: '![](ch3_ghostRightarrow.gif) -0.5`'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: '![](ch3_ghostRightarrow.gif) -0.5`'
- en: '**procedure**: `(truncate *real*)`'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(truncate *real*)`'
- en: '**returns:** the integer closest to `*real*` toward zero'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 最接近 `*real*` 且朝零的整数'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: If `*real*` is an infinity or NaN, `truncate` returns `*real*`.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `*real*` 是无穷大或 NaN，则 `truncate` 返回 `*real*`。
- en: '`(truncate 19) ![<graphic>](ch6_0.gif) 19'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: '`(truncate 19) ![<graphic>](ch6_0.gif) 19'
- en: (truncate 2/3) ![<graphic>](ch6_0.gif) 0
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: (truncate 2/3) ![<graphic>](ch6_0.gif) 0
- en: (truncate -2/3) ![<graphic>](ch6_0.gif) 0
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: (truncate -2/3) ![<graphic>](ch6_0.gif) 0
- en: (truncate 17.3) ![<graphic>](ch6_0.gif) 17.0
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: (truncate 17.3)��![<graphic>](ch6_0.gif) 17.0
- en: (truncate -17/2) ![<graphic>](ch6_0.gif) -8`
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: (truncate -17/2) ![<graphic>](ch6_0.gif) -8`
- en: '**procedure**: `(floor *real*)`'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(floor *real*)`'
- en: '**returns:** the integer closest to `*real*` toward ![<graphic>](ch6_11.gif)'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 最接近 `*real*` 且朝 ![<graphic>](ch6_11.gif) 的整数'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: If `*real*` is an infinity or NaN, `floor` returns `*real*`.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `*real*` 是无穷大或 NaN，则 `floor` 返回 `*real*`。
- en: '`(floor 19) ![<graphic>](ch6_0.gif) 19'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '`(floor 19) ![<graphic>](ch6_0.gif) 19'
- en: (floor 2/3) ![<graphic>](ch6_0.gif) 0
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: (floor 2/3) ![<graphic>](ch6_0.gif) 0
- en: (floor -2/3) ![<graphic>](ch6_0.gif) -1
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: (floor -2/3) ![<graphic>](ch6_0.gif) -1
- en: (floor 17.3) ![<graphic>](ch6_0.gif) 17.0
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: (floor 17.3) ![<graphic>](ch6_0.gif) 17.0
- en: (floor -17/2) ![<graphic>](ch6_0.gif) -9`
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: (floor -17/2) ![<graphic>](ch6_0.gif) -9`
- en: '**procedure**: `(ceiling *real*)`'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(ceiling *real*)`'
- en: '**returns:** the integer closest to `*real*` toward ![<graphic>](ch6_12.gif)'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 最接近 `*real*` 且朝 ![<graphic>](ch6_12.gif) 的整数'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: If `*real*` is an infinity or NaN, `ceiling` returns `*real*`.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `*real*` 是无穷大或 NaN，则 `ceiling` 返回 `*real*`。
- en: '`(ceiling 19) ![<graphic>](ch6_0.gif) 19'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '`(ceiling 19) ![<graphic>](ch6_0.gif) 19'
- en: (ceiling 2/3) ![<graphic>](ch6_0.gif) 1
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: (ceiling 2/3) ![<graphic>](ch6_0.gif) 1
- en: (ceiling -2/3) ![<graphic>](ch6_0.gif) 0
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: (ceiling -2/3) ![<graphic>](ch6_0.gif) 0
- en: (ceiling 17.3) ![<graphic>](ch6_0.gif) 18.0
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: (ceiling 17.3) ![<graphic>](ch6_0.gif) 18.0
- en: (ceiling -17/2) ![<graphic>](ch6_0.gif) -8`
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: (ceiling -17/2) ![<graphic>](ch6_0.gif) -8`
- en: '**procedure**: `(round *real*)`'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(round *real*)`'
- en: '**returns:** the integer closest to `*real*`'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 最接近`*real*`的整数'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs base)`，`(rnrs)`'
- en: If `*real*` is exactly between two integers, the closest even integer is returned.
    If `*real*` is an infinity or NaN, `round` returns `*real*`.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*real*`恰好介于两个整数之间，���返回最接近的偶数。如果`*real*`是无穷大或NaN，则`round`返回`*real*`。
- en: '`(round 19) ![<graphic>](ch6_0.gif) 19'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '`(round 19) ![<graphic>](ch6_0.gif) 19'
- en: (round 2/3) ![<graphic>](ch6_0.gif) 1
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: (round 2/3) ![<graphic>](ch6_0.gif) 1
- en: (round -2/3) ![<graphic>](ch6_0.gif) -1
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: (round -2/3) ![<graphic>](ch6_0.gif) -1
- en: (round 17.3) ![<graphic>](ch6_0.gif) 17.0
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: (round 17.3) ![<graphic>](ch6_0.gif) 17.0
- en: (round -17/2) ![<graphic>](ch6_0.gif) -8
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: (round -17/2) ![<graphic>](ch6_0.gif) -8
- en: (round 2.5) ![<graphic>](ch6_0.gif) 2.0
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: (round 2.5) ![<graphic>](ch6_0.gif) 2.0
- en: (round 3.5) ![<graphic>](ch6_0.gif) 4.0`
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: (round 3.5) ![<graphic>](ch6_0.gif) 4.0`
- en: '**procedure**: `(abs *real*)`'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(abs *real*)`'
- en: '**returns:** the absolute value of `*real*`'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** `*real*`的绝对值'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs base)`，`(rnrs)`'
- en: '`abs` is equivalent to `(lambda (x) (if (< x 0) (- x) x))`. `abs` and `magnitude`
    (see page [183](objects.html#page:magnitude)) are identical for real inputs.'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '`abs`等同于`(lambda (x) (if (< x 0) (- x) x))`。对于实数输入，`abs`和`magnitude`（见第[183](objects.html#page:magnitude)页）是相同的。'
- en: '`(abs 1) ![<graphic>](ch6_0.gif) 1'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '`(abs 1) ![<graphic>](ch6_0.gif) 1'
- en: (abs -3/4) ![<graphic>](ch6_0.gif) 3/4
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: (abs -3/4) ![<graphic>](ch6_0.gif) 3/4
- en: (abs 1.83) ![<graphic>](ch6_0.gif) 1.83
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: (abs 1.83) ![<graphic>](ch6_0.gif) 1.83
- en: (abs -0.093) ![<graphic>](ch6_0.gif) 0.093`
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: (abs -0.093) ![<graphic>](ch6_0.gif) 0.093`
- en: '**procedure**: `(max *real[1]* *real[2]* ...)`'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(max *real[1]* *real[2]* ...)`'
- en: '**returns:** the maximum of `*real[1]* *real[2]* ...`'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** `*real[1]* *real[2]* ...`的最大值'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs base)`，`(rnrs)`'
- en: '`(max 4 -7 2 0 -6) ![<graphic>](ch6_0.gif) 4'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: '`(max 4 -7 2 0 -6) ![<graphic>](ch6_0.gif) 4'
- en: (max 1/2 3/4 4/5 5/6 6/7) ![<graphic>](ch6_0.gif) 6/7
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: (max 1/2 3/4 4/5 5/6 6/7) ![<graphic>](ch6_0.gif) 6/7
- en: (max 1.5 1.3 -0.3 0.4 2.0 1.8) ![<graphic>](ch6_0.gif) 2.0
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: (max 1.5 1.3 -0.3 0.4 2.0 1.8) ![<graphic>](ch6_0.gif) 2.0
- en: (max 5 2.0) ![<graphic>](ch6_0.gif) 5.0
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: (max 5 2.0) ![<graphic>](ch6_0.gif) 5.0
- en: (max -5 -2.0) ![<graphic>](ch6_0.gif) -2.0
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: (max -5 -2.0) ![<graphic>](ch6_0.gif) -2.0
- en: (let ([ls '(7 3 5 2 9 8)])
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([ls '(7 3 5 2 9 8)])
- en: (apply max ls)) ![<graphic>](ch6_0.gif) 9`
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: (apply max ls)) ![<graphic>](ch6_0.gif) 9`
- en: '**procedure**: `(min *real[1]* *real[2]* ...)`'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(min *real[1]* *real[2]* ...)`'
- en: '**returns:** the minimum of `*real[1]* *real[2]* ...`'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** `*real[1]* *real[2]* ...`的最小值'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs base)`，`(rnrs)`'
- en: '`(min 4 -7 2 0 -6) ![<graphic>](ch6_0.gif) -7'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '`(min 4 -7 2 0 -6) ![<graphic>](ch6_0.gif) -7'
- en: (min 1/2 3/4 4/5 5/6 6/7) ![<graphic>](ch6_0.gif) 1/2
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: (min 1/2 3/4 4/5 5/6 6/7) ![<graphic>](ch6_0.gif) 1/2
- en: (min 1.5 1.3 -0.3 0.4 2.0 1.8) ![<graphic>](ch6_0.gif) -0.3
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: (min 1.5 1.3 -0.3 0.4 2.0 1.8) ![<graphic>](ch6_0.gif) -0.3
- en: (min 5 2.0) ![<graphic>](ch6_0.gif) 2.0
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: (min 5 2.0) ![<graphic>](ch6_0.gif) 2.0
- en: (min -5 -2.0) ![<graphic>](ch6_0.gif) -5.0
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: (min -5 -2.0) ![<graphic>](ch6_0.gif) -5.0
- en: (let ([ls '(7 3 5 2 9 8)])
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([ls '(7 3 5 2 9 8)])
- en: (apply min ls)) ![<graphic>](ch6_0.gif) 2`
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: (apply min ls)) ![<graphic>](ch6_0.gif) 2`
- en: '**procedure**: `(gcd *int* ...)`'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(gcd *int* ...)`'
- en: '**returns:** the greatest common divisor of its arguments `*int* ...`'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 参数`*int* ...`的最大公约数'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs base)`，`(rnrs)`'
- en: The result is always nonnegative, i.e., factors of -1 are ignored. When called
    with no arguments, `gcd` returns 0.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 结果始终为非负数，即-1的因子被忽略。当没有参数时，`gcd`返回0。
- en: '`(gcd) ![<graphic>](ch6_0.gif) 0'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '`(gcd) ![<graphic>](ch6_0.gif) 0'
- en: (gcd 34) ![<graphic>](ch6_0.gif) 34
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: (gcd 34) ![<graphic>](ch6_0.gif) 34
- en: (gcd 33.0 15.0) ![<graphic>](ch6_0.gif) 3.0
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: (gcd 33.0 15.0) ![<graphic>](ch6_0.gif) 3.0
- en: (gcd 70 -42 28) ![<graphic>](ch6_0.gif) 14`
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: (gcd 70 -42 28) ![<graphic>](ch6_0.gif) 14`
- en: '**procedure**: `(lcm *int* ...)`'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(lcm *int* ...)`'
- en: '**returns:** the least common multiple of its arguments `*int* ...`'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 参数`*int* ...`的最小公倍数'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs base)`，`(rnrs)`'
- en: The result is always nonnegative, i.e., common multiples of -1 are ignored.
    Although `lcm` should probably return ![<graphic>](ch6_13.gif) when called with
    no arguments, it is defined to return 1. If one or more of the arguments is 0,
    `lcm` returns 0.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 结果始终为非负数，即-1的公共倍数被忽略。虽然`lcm`在没有参数的情况下应该返回![<graphic>](ch6_13.gif)，但它被定义为返回1。如果一个或多个参数为0，`lcm`返回0。
- en: '`(lcm) ![<graphic>](ch6_0.gif) 1'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lcm) ![<graphic>](ch6_0.gif) 1'
- en: (lcm 34) ![<graphic>](ch6_0.gif) 34
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: (lcm 34) ![<graphic>](ch6_0.gif) 34
- en: (lcm 33.0 15.0) ![<graphic>](ch6_0.gif) 165.0
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: (lcm 33.0 15.0) ![<graphic>](ch6_0.gif) 165.0
- en: (lcm 70 -42 28) ![<graphic>](ch6_0.gif) 420
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: (lcm 70 -42 28) ![<graphic>](ch6_0.gif) 420
- en: (lcm 17.0 0) ![<graphic>](ch6_0.gif) 0.0`
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: (lcm 17.0 0) ![<graphic>](ch6_0.gif) 0.0`
- en: '**procedure**: `(expt *num[1]* *num[2]*)`'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(expt *num[1]* *num[2]*)`'
- en: '**returns:** `*num[1]*` raised to the `*num[2]*` power'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*num[1]*` 的 `*num[2]*` 次方'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: If both arguments are 0, `expt` returns 1.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个参数都是 0，则 `expt` 返回 1。
- en: '`(expt 2 10) ![<graphic>](ch6_0.gif) 1024'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: '`(expt 2 10) ![<graphic>](ch6_0.gif) 1024'
- en: (expt 2 -10) ![<graphic>](ch6_0.gif) 1/1024
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: (expt 2 -10) ![<graphic>](ch6_0.gif) 1/1024
- en: (expt 2 -10.0) ![<graphic>](ch6_0.gif) 9.765625e-4
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: (expt 2 -10.0) ![<graphic>](ch6_0.gif) 9.765625e-4
- en: (expt -1/2 5) ![<graphic>](ch6_0.gif) -1/32
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: (expt -1/2 5) ![<graphic>](ch6_0.gif) -1/32
- en: (expt 3.0 3) ![<graphic>](ch6_0.gif) 27.0
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: (expt 3.0 3) ![<graphic>](ch6_0.gif) 27.0
- en: (expt +i 2) ![<graphic>](ch6_0.gif) -1`
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: (expt +i 2) ![<graphic>](ch6_0.gif) -1`
- en: '**procedure**: `(inexact *num*)`'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(inexact *num*)`'
- en: '**returns:** an inexact representation of `*num*`'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*num*` 的非精确表示'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: If `*num*` is already inexact, it is returned unchanged. If no inexact representation
    for `*num*` is supported by the implementation, an exception with condition type
    `&implementation-violation` may be raised. `inexact` may also return `+inf.0`
    or `-inf.0` for inputs whose magnitude exceeds the range of the implementation's
    inexact number representations.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `*num*` 已经是非精确的，则返回不变。如果实现不支持 `*num*` 的非精确表示，可能会引发带有条件类型 `&implementation-violation`
    的异常。对于超出实现的非精确数表示范围的输入，`inexact` 也可能返回 `+inf.0` 或 `-inf.0`。
- en: '`(inexact 3) ![<graphic>](ch6_0.gif) 3.0'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: '`(inexact 3) ![<graphic>](ch6_0.gif) 3.0'
- en: (inexact 3.0) ![<graphic>](ch6_0.gif) 3.0
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: (inexact 3.0) ![<graphic>](ch6_0.gif) 3.0
- en: (inexact -1/4) ![<graphic>](ch6_0.gif) -.25
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: (inexact -1/4) ![<graphic>](ch6_0.gif) -.25
- en: (inexact 3+4i) ![<graphic>](ch6_0.gif) 3.0+4.0i
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: (inexact 3+4i) ![<graphic>](ch6_0.gif) 3.0+4.0i
- en: (inexact (expt 10 20)) ![<graphic>](ch6_0.gif) 1e20`
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: (inexact (expt 10 20)) ![<graphic>](ch6_0.gif) 1e20`
- en: '**procedure**: `(exact *num*)`'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(exact *num*)`'
- en: '**returns:** an exact representation of `*num*`'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*num*` 的精确表示'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: If `*num*` is already exact, it is returned unchanged. If no exact representation
    for `*num*` is supported by the implementation, an exception with condition type
    `&implementation-violation` may be raised.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `*num*` 已经是精确的，则返回不变。如果实现不支持 `*num*` 的精确表示，可能会引发带有条件类型 `&implementation-violation`
    的异常。
- en: '`(exact 3.0) ![<graphic>](ch6_0.gif) 3'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '`(exact 3.0) ![<graphic>](ch6_0.gif) 3'
- en: (exact 3) ![<graphic>](ch6_0.gif) 3
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: (exact 3) ![<graphic>](ch6_0.gif) 3
- en: (exact -.25) ![<graphic>](ch6_0.gif) -1/4
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: (exact -.25) ![<graphic>](ch6_0.gif) -1/4
- en: (exact 3.0+4.0i) ![<graphic>](ch6_0.gif) 3+4i
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: (exact 3.0+4.0i) ![<graphic>](ch6_0.gif) 3+4i
- en: (exact 1e20) ![<graphic>](ch6_0.gif) 100000000000000000000`
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: (exact 1e20) ![<graphic>](ch6_0.gif) 100000000000000000000`
- en: '**procedure**: `(exact->inexact *num*)`'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(exact->inexact *num*)`'
- en: '**returns:** an inexact representation of `*num*`'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*num*` 的非精确表示'
- en: '**procedure**: `(inexact->exact *num*)`'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(inexact->exact *num*)`'
- en: '**returns:** an exact representation of `*num*`'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*num*` 的精确表示'
- en: '**libraries:** `(rnrs r5rs)`'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs r5rs)`'
- en: These are alternative names for `inexact` and `exact`, supported for compatibility
    with the Revised⁵ Report.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是对 `inexact` 和 `exact` 的替代名称，用于与 Revised⁵ Report 兼容。
- en: '**procedure**: `(rationalize *real[1]* *real[2]*)`'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(rationalize *real[1]* *real[2]*)`'
- en: '**returns:** see below'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 见下文'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`rationalize` returns the simplest rational number that differs from `*real[1]*`
    by no more than `*real[2]*`. A rational number *q*[1] = *n*[1]/*m*[1] is simpler
    than another rational number *q*[2] = *n*[2]/*m*[2] if |*n*[1]| ≤ |*n*[2]| and
    |*m*[1]| ≤ |*m*[2]| and either |*n*[1]| < |*n*[2]| or |*m*[1]| < |*m*[2]|.'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '`rationalize` 返回与 `*real[1]*` 最多相差 `*real[2]*` 的最简有理数。有理数 *q*[1] = *n*[1]/*m*[1]
    比另一个有理数 *q*[2] = *n*[2]/*m*[2] 更简单，如果 |*n*[1]| ≤ |*n*[2]| 且 |*m*[1]| ≤ |*m*[2]|，并且
    |*n*[1]| < |*n*[2]| 或 |*m*[1]| < |*m*[2]|.'
- en: '`(rationalize 3/10 1/10) ![<graphic>](ch6_0.gif) 1/3'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: '`(rationalize 3/10 1/10) ![<graphic>](ch6_0.gif) 1/3'
- en: (rationalize .3 1/10) ![<graphic>](ch6_0.gif) 0.3333333333333333
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: (rationalize .3 1/10) ![<graphic>](ch6_0.gif) 0.3333333333333333
- en: (eqv? (rationalize .3 1/10) #i1/3) ![<graphic>](ch6_0.gif) #t`
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? (rationalize .3 1/10) #i1/3) ![<graphic>](ch6_0.gif) #t`
- en: '**procedure**: `(numerator *rat*)`'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(numerator *rat*)`'
- en: '**returns:** the numerator of `*rat*`'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*rat*` 的分子'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: If `*rat*` is an integer, the numerator is `*rat*`.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `*rat*` 是整数，则分子是 `*rat*`。
- en: '`(numerator 9) ![<graphic>](ch6_0.gif) 9'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: '`(numerator 9) ![<graphic>](ch6_0.gif) 9'
- en: (numerator 9.0) ![<graphic>](ch6_0.gif) 9.0
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: (numerator 9.0) ![<graphic>](ch6_0.gif) 9.0
- en: (numerator 0.0) ![<graphic>](ch6_0.gif) 0.0
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: (numerator 0.0) ![<graphic>](ch6_0.gif) 0.0
- en: (numerator 2/3) ![<graphic>](ch6_0.gif) 2
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: (numerator 2/3) ![<graphic>](ch6_0.gif) 2
- en: (numerator -9/4) ![<graphic>](ch6_0.gif) -9
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: (numerator -9/4) ![<graphic>](ch6_0.gif) -9
- en: (numerator -2.25) ![<graphic>](ch6_0.gif) -9.0`
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: (numerator -2.25) ![<graphic>](ch6_0.gif) -9.0`
- en: '**procedure**: `(denominator *rat*)`'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(denominator *rat*)`'
- en: '**returns:** the denominator of `*rat*`'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** the denominator of `*rat*`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: If `*rat*` is an integer, including zero, the denominator is one.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: If `*rat*` is an integer, including zero, the denominator is one.
- en: '`(denominator 9) ![<graphic>](ch6_0.gif) 1'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: '`(denominator 9) ![<graphic>](ch6_0.gif) 1'
- en: (denominator 9.0) ![<graphic>](ch6_0.gif) 1.0
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: (denominator 9.0) ![<graphic>](ch6_0.gif) 1.0
- en: (denominator 0) ![<graphic>](ch6_0.gif) 1
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: (denominator 0) ![<graphic>](ch6_0.gif) 1
- en: (denominator 0.0) ![<graphic>](ch6_0.gif) 1.0
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: (denominator 0.0) ![<graphic>](ch6_0.gif) 1.0
- en: (denominator 2/3) ![<graphic>](ch6_0.gif) 3
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: (denominator 2/3) ![<graphic>](ch6_0.gif) 3
- en: (denominator -9/4) ![<graphic>](ch6_0.gif) 4
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: (denominator -9/4) ![<graphic>](ch6_0.gif) 4
- en: (denominator -2.25) ![<graphic>](ch6_0.gif) 4.0`
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: (denominator -2.25) ![<graphic>](ch6_0.gif) 4.0`
- en: '**procedure**: `(real-part *num*)`'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(real-part *num*)`'
- en: '**returns:** the real component of `*num*`'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** the real component of `*num*`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: If `*num*` is real, `real-part` returns `*num*`.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: If `*num*` is real, `real-part` returns `*num*`.
- en: '`(real-part 3+4i) ![<graphic>](ch6_0.gif) 3'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: '`(real-part 3+4i) ![<graphic>](ch6_0.gif) 3'
- en: (real-part -2.3+0.7i) ![<graphic>](ch6_0.gif) -2.3
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: (real-part -2.3+0.7i) ![<graphic>](ch6_0.gif) -2.3
- en: (real-part -i) ![<graphic>](ch6_0.gif) 0
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: (real-part -i) ![<graphic>](ch6_0.gif) 0
- en: (real-part 17.2) ![<graphic>](ch6_0.gif) 17.2
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: (real-part 17.2) ![<graphic>](ch6_0.gif) 17.2
- en: (real-part -17/100) ![<graphic>](ch6_0.gif) -17/100`
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: (real-part -17/100) ![<graphic>](ch6_0.gif) -17/100`
- en: '**procedure**: `(imag-part *num*)`'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(imag-part *num*)`'
- en: '**returns:** the imaginary component of `*num*`'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** the imaginary component of `*num*`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: If `*num*` is real, `imag-part` returns exact zero.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: If `*num*` is real, `imag-part` returns exact zero.
- en: '`(imag-part 3+4i) ![<graphic>](ch6_0.gif) 4'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '`(imag-part 3+4i) ![<graphic>](ch6_0.gif) 4'
- en: (imag-part -2.3+0.7i) ![<graphic>](ch6_0.gif) 0.7
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: (imag-part -2.3+0.7i) ![<graphic>](ch6_0.gif) 0.7
- en: (imag-part -i) ![<graphic>](ch6_0.gif) -1
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: (imag-part -i) ![<graphic>](ch6_0.gif) -1
- en: (imag-part -2.5) ![<graphic>](ch6_0.gif) 0
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: (imag-part -2.5) ![<graphic>](ch6_0.gif) 0
- en: (imag-part -17/100) ![<graphic>](ch6_0.gif) 0`
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: (imag-part -17/100) ![<graphic>](ch6_0.gif) 0`
- en: '**procedure**: `(make-rectangular *real[1]* *real[2]*)`'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-rectangular *real[1]* *real[2]*)`'
- en: '**returns:** a complex number with real component `*real[1]*` and imaginary
    component `*real[2]*`'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** a complex number with real component `*real[1]*` and imaginary
    component `*real[2]*`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`(make-rectangular -2 7) ![<graphic>](ch6_0.gif) -2+7i'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: '`(make-rectangular -2 7) ![<graphic>](ch6_0.gif) -2+7i'
- en: (make-rectangular 2/3 -1/2) ![<graphic>](ch6_0.gif) 2/3-1/2i
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: (make-rectangular 2/3 -1/2) ![<graphic>](ch6_0.gif) 2/3-1/2i
- en: (make-rectangular 3.2 5.3) ![<graphic>](ch6_0.gif) 3.2+5.3i`
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: (make-rectangular 3.2 5.3) ![<graphic>](ch6_0.gif) 3.2+5.3i`
- en: '**procedure**: `(make-polar *real[1]* *real[2]*)`'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-polar *real[1]* *real[2]*)`'
- en: '**returns:** a complex number with magnitude `*real[1]*` and angle `*real[2]*`'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** a complex number with magnitude `*real[1]*` and angle `*real[2]*`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`(make-polar 2 0) ![<graphic>](ch6_0.gif) 2'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: '`(make-polar 2 0) ![<graphic>](ch6_0.gif) 2'
- en: (make-polar 2.0 0.0) ![<graphic>](ch6_0.gif) 2.0+0.0i
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: (make-polar 2.0 0.0) ![<graphic>](ch6_0.gif) 2.0+0.0i
- en: (make-polar 1.0 (asin -1.0)) ![<graphic>](ch6_0.gif) 0.0-1.0i
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: (make-polar 1.0 (asin -1.0)) ![<graphic>](ch6_0.gif) 0.0-1.0i
- en: (eqv? (make-polar 7.2 -0.588) 7.2@-0.588) ![<graphic>](ch6_0.gif) #t`
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: (eqv? (make-polar 7.2 -0.588) 7.2@-0.588) ![<graphic>](ch6_0.gif) #t`
- en: '**procedure**: `(angle *num*)`'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(angle *num*)`'
- en: '**returns:** the angle part of the polar representation of `*num*`'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** the angle part of the polar representation of `*num*`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: The range of the result is ![<graphic>](ch6_14.gif) (exclusive) to ![<graphic>](ch6_15.gif)
    (inclusive).
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: The range of the result is ![<graphic>](ch6_14.gif) (exclusive) to ![<graphic>](ch6_15.gif)
    (inclusive).
- en: '`(angle 7.3@1.5708) ![<graphic>](ch6_0.gif) 1.5708'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '`(angle 7.3@1.5708) ![<graphic>](ch6_0.gif) 1.5708'
- en: (angle 5.2) ![<graphic>](ch6_0.gif) 0.0`
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: (angle 5.2) ![<graphic>](ch6_0.gif) 0.0`
- en: '**procedure**: `(magnitude *num*)`'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(magnitude *num*)`'
- en: '**returns:** the magnitude of `*num*`'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** the magnitude of `*num*`'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`magnitude` and `abs` (see page [178](objects.html#page:abs)) are identical
    for real arguments. The magnitude of a complex number *x* + *yi* is ![<graphic>](ch6_16.gif).'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '`magnitude` and `abs` (see page [178](objects.html#page:abs)) are identical
    for real arguments. The magnitude of a complex number *x* + *yi* is ![<graphic>](ch6_16.gif).'
- en: '`(magnitude 1) ![<graphic>](ch6_0.gif) 1'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '`(magnitude 1) ![<graphic>](ch6_0.gif) 1'
- en: (magnitude -3/4) ![<graphic>](ch6_0.gif) 3/4
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: (magnitude -3/4) ![<graphic>](ch6_0.gif) 3/4
- en: (magnitude 1.83) ![<graphic>](ch6_0.gif) 1.83
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: (magnitude 1.83) ![<graphic>](ch6_0.gif) 1.83
- en: (magnitude -0.093) ![<graphic>](ch6_0.gif) 0.093
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: (magnitude -0.093) ![<graphic>](ch6_0.gif) 0.093
- en: (magnitude 3+4i) ![<graphic>](ch6_0.gif) 5
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: (magnitude 3+4i) ![<graphic>](ch6_0.gif) 5
- en: (magnitude 7.25@1.5708) ![<graphic>](ch6_0.gif) 7.25`
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(sqrt *num*)`'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the principal square root of `*num*`'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: Implementations are encouraged, but not required, to return exact results for
    exact inputs to `sqrt` whenever feasible.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: '`(sqrt 16) ![<graphic>](ch6_0.gif) 4'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: (sqrt 1/4) ![<graphic>](ch6_0.gif) 1/2
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: (sqrt 4.84) ![<graphic>](ch6_0.gif) 2.2
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: (sqrt -4.84) ![<graphic>](ch6_0.gif) 0.0+2.2i
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: (sqrt 3+4i) ![<graphic>](ch6_0.gif) 2+1i
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: (sqrt -3.0-4.0i) ![<graphic>](ch6_0.gif) 1.0-2.0i`
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(exact-integer-sqrt *n*)`'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: This procedure returns two nonnegative exact integers *s* and *r* where *n*
    = *s*² + *r* and *n* < (*s* + 1)².
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: '`(exact-integer-sqrt 0) ![<graphic>](ch6_0.gif) 0'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) 0'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: (exact-integer-sqrt 9) ![<graphic>](ch6_0.gif) 3
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch6_0.gif) 0'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: (exact-integer-sqrt 19) ![<graphic>](ch6_0.gif) 4
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch6_0.gif) 3`'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(exp *num*)`'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** *e* to the `*num*` power'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: '`(exp 0.0) ![<graphic>](ch6_0.gif) 1.0'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: (exp 1.0) ![<graphic>](ch6_0.gif) 2.7182818284590455
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: (exp -.5) ![<graphic>](ch6_0.gif) 0.6065306597126334`
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(log *num*)`'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the natural logarithm of `*num*`'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(log *num[1]* *num[2]*)`'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the base-`*num[2]*` logarithm of `*num[1]*`'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: '`(log 1.0) ![<graphic>](ch6_0.gif) 0.0'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: (log (exp 1.0)) ![<graphic>](ch6_0.gif) 1.0
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: (/ (log 100) (log 10)) ![<graphic>](ch6_0.gif) 2.0
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: (log (make-polar (exp 2.0) 1.0)) ![<graphic>](ch6_0.gif) 2.0+1.0i
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: (log 100.0 10.0) ![<graphic>](ch6_0.gif) 2.0
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: (log .125 2.0) ![<graphic>](ch6_0.gif) -3.0`
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(sin *num*)`'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(cos *num*)`'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(tan *num*)`'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the sine, cosine, or tangent of `*num*`'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: The argument is specified in radians.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: '`(sin 0.0) ![<graphic>](ch6_0.gif) 0.0'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: (cos 0.0) ![<graphic>](ch6_0.gif) 1.0
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: (tan 0.0) ![<graphic>](ch6_0.gif) 0.0`
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(asin *num*)`'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(acos *num*)`'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the arc sine or the arc cosine of `*num*`'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: The result is in radians. The arc sine and arc cosine of a complex number *z*
    are defined as follows.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch6_17.gif)'
  id: totrans-1247
  prefs: []
  type: TYPE_IMG
- en: '![<graphic>](ch6_18.gif)'
  id: totrans-1248
  prefs: []
  type: TYPE_IMG
- en: '`(define pi (* (asin 1) 2))'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: (= (* (acos 0) 2) pi) ![<graphic>](ch6_0.gif) #t`
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(atan *num*)`'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(atan *real[1]* *real[2]*)`'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: When passed a single complex argument `*num*` (the first form), `atan` returns
    the arc tangent of `*num*`. The arc tangent of a complex number *z* is defined
    as follows.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch6_19.gif)'
  id: totrans-1256
  prefs: []
  type: TYPE_IMG
- en: When passed two real arguments (the second form), `atan` is equivalent to `(lambda (y x) (angle (make-rectangular x y)))`.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: '`(define pi (* (atan 1) 4))'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: (= (* (atan 1.0 0.0) 2) pi) ![<graphic>](ch6_0.gif) #t`
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: (= (* (atan 1.0 0.0) 2) pi) ![<图形>](ch6_0.gif) #t`
- en: '**procedure**: `(bitwise-not *exint*)`'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(按位非 *exint*)`'
- en: '**returns:** the bitwise not of `*exint*`'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**: `*exint*`的按位非'
- en: '**procedure**: `(bitwise-and *exint* ...)`'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(按位与 *exint* ...)`'
- en: '**returns:** the bitwise and of `*exint* ...`'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**: `*exint* ...`的按位与'
- en: '**procedure**: `(bitwise-ior *exint* ...)`'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(按位或 *exint* ...)`'
- en: '**returns:** the bitwise inclusive or of `*exint* ...`'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**: `*exint* ...`的按位或'
- en: '**procedure**: `(bitwise-xor *exint* ...)`'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(按位异或 *exint* ...)`'
- en: '**returns:** the bitwise exclusive or of `*exint* ...`'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**: `*exint* ...`的按位异或'
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**: `(rnrs 算术 按位)`, `(rnrs)`'
- en: The inputs are treated as if represented in two's complement, even if they are
    not represented that way internally.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 即使内部表示方式不是以二进制补码表示，输入也会被视为以二进制补码表示。
- en: '`(bitwise-not 0) ![<graphic>](ch6_0.gif) -1'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: '`(按位非 0) ![<图形>](ch6_0.gif) -1'
- en: (bitwise-not 3) ![<graphic>](ch6_0.gif) -4
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: (按位非 3) ![<图形>](ch6_0.gif) -4
- en: (bitwise-and #b01101 #b00111) ![<graphic>](ch6_0.gif) #b00101
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: (按位与 #b01101 #b00111) ![<图形>](ch6_0.gif) #b00101
- en: (bitwise-ior #b01101 #b00111) ![<graphic>](ch6_0.gif) #b01111
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: (按位或 #b01101 #b00111) ![<图形>](ch6_0.gif) #b01111
- en: (bitwise-xor #b01101 #b00111) ![<graphic>](ch6_0.gif) #b01010`
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: (按位异或 #b01101 #b00111) ![<图形>](ch6_0.gif) #b01010`
- en: '**procedure**: `(bitwise-if *exint[1]* *exint[2]* *exint[3]*)`'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(按位if *exint[1]* *exint[2]* *exint[3]*)`'
- en: '**returns:** the bitwise "if" of its arguments'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**: 其参数的按位“if”'
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**: `(rnrs 算术 按位)`, `(rnrs)`'
- en: The inputs are treated as if represented in two's complement, even if they are
    not represented that way internally.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 即使内部表示方式不是以二进制补码表示，输入也会被视为以二进制补码表示。
- en: For each bit set in `*exint[1]*`, the corresponding bit of the result is taken
    from `*exint[2]*`, and for each bit not set in `*exint[1]*`, the corresponding
    bit of the result is taken from `*x[3]*`.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`*exint[1]*`中设置的每个位，结果的相应位取自`*exint[2]*`，对于`*exint[1]*`中未设置的每个位，结果的相应位取自`*x[3]*`。
- en: '`(bitwise-if #b101010 #b111000 #b001100) ![<graphic>](ch6_0.gif) #b101100`'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '`(按位if #b101010 #b111000 #b001100) ![<图形>](ch6_0.gif) #b101100`'
- en: '`bitwise-if` might be defined as follows:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: '`按位if`可能定义如下：'
- en: '`(define bitwise-if'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: '`(定义 按位if'
- en: (lambda (exint1 exint2 exint3)
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (exint1 exint2 exint3)
- en: (bitwise-ior
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: (按位或
- en: (bitwise-and exint1 exint2)
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: (按位与 exint1 exint2)
- en: (bitwise-and (bitwise-not exint1) exint3))))`
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: (按位与 (按位非 exint1) exint3))))`
- en: '**procedure**: `(bitwise-bit-count *exint*)`'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(按位计数 *exint*)`'
- en: '**returns:** see below'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**: 见下文'
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**: `(rnrs 算术 按位)`, `(rnrs)`'
- en: For nonnegative inputs, `bitwise-bit-count` returns the number of bits set in
    the two's complement representation of `*exint*`. For negative inputs, it returns
    a negative number whose magnitude is one greater than the number of bits not set
    in the two's complement representation of `*exint*`, which is equivalent to `(bitwise-not (bitwise-bit-count (bitwise-not *exint*)))`.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非负输入，`按位计数`返回`*exint*`的二进制补码表示中设置的位数。对于负输入，它返回一个负数，其大小比`*exint*`的二进制补码表示中未设置的位数多一个，这等效于`(按位非 (按位计数 (按位非 *exint*)))`。
- en: '`(bitwise-bit-count #b00000) ![<graphic>](ch6_0.gif) 0'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: '`(按位计数 #b00000) ![<图形>](ch6_0.gif) 0'
- en: (bitwise-bit-count #b00001) ![<graphic>](ch6_0.gif) 1
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: (按位计数 #b00001) ![<图形>](ch6_0.gif) 1
- en: (bitwise-bit-count #b00100) ![<graphic>](ch6_0.gif) 1
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: (按位计数 #b00100) ![<图形>](ch6_0.gif) 1
- en: (bitwise-bit-count #b10101) ![<graphic>](ch6_0.gif) 3
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: (按位计数 #b10101) ![<图形>](ch6_0.gif) 3
- en: (bitwise-bit-count -1) ![<graphic>](ch6_0.gif) -1
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: (按位计数 -1) ![<图形>](ch6_0.gif) -1
- en: (bitwise-bit-count -2) ![<graphic>](ch6_0.gif) -2
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: (按位计数 -2) ![<图形>](ch6_0.gif) -2
- en: (bitwise-bit-count -4) ![<graphic>](ch6_0.gif) -3`
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: (按位计数 -4) ![<图形>](ch6_0.gif) -3`
- en: '**procedure**: `(bitwise-length *exint*)`'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(按位长度 *exint*)`'
- en: '**returns:** see below'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回**: 见下文'
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: '**库**: `(rnrs 算术 按位)`, `(rnrs)`'
- en: This procedure returns the number of bits of the smallest two's complement representation
    of `*exint*`, not including the sign bit for negative numbers. For 0 `bitwise-length`
    returns 0.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程返回`*exint*`的最小二进制补码表示的位数，不包括负数的符号位。对于0，`按位长度`返回0。
- en: '`(bitwise-length #b00000) ![<graphic>](ch6_0.gif) 0'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: '`(按位长度 #b00000) ![<图形>](ch6_0.gif) 0'
- en: (bitwise-length #b00001) ![<graphic>](ch6_0.gif) 1
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: (按位长度 #b00001) ![<图形>](ch6_0.gif) 1
- en: (bitwise-length #b00100) ![<graphic>](ch6_0.gif) 3
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: (按位长度 #b00100) ![<图形>](ch6_0.gif) 3
- en: (bitwise-length #b00110) ![<graphic>](ch6_0.gif) 3
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: (按位长度 #b00110) ![<图形>](ch6_0.gif) 3
- en: (bitwise-length -1) ![<graphic>](ch6_0.gif) 0
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: (bitwise-length -1) ![<graphic>](ch6_0.gif) 0
- en: (bitwise-length -6) ![<graphic>](ch6_0.gif) 3
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: (bitwise-length -6) ![<graphic>](ch6_0.gif) 3
- en: (bitwise-length -9) ![<graphic>](ch6_0.gif) 4`
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: (bitwise-length -9) ![<graphic>](ch6_0.gif) 4`
- en: '**procedure**: `(bitwise-first-bit-set *exint*)`'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(bitwise-first-bit-set *exint*)`'
- en: '**returns:** the index of the least significant bit set in `*exint*`'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*exint*`中设置的最低有效位的���引'
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
- en: The input is treated as if represented in two's complement, even if it is not
    represented that way internally.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 输入被视为以二进制补码表示，即使内部没有以这种方式表示。
- en: If `*exint*` is 0, `bitwise-first-bit-set` returns -1.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*exint*`为0，则`bitwise-first-bit-set`返回-1。
- en: '`(bitwise-first-bit-set #b00000) ![<graphic>](ch6_0.gif) -1'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: '`(bitwise-first-bit-set #b00000) ![<graphic>](ch6_0.gif) -1'
- en: (bitwise-first-bit-set #b00001) ![<graphic>](ch6_0.gif) 0
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: (bitwise-first-bit-set #b00001) ![<graphic>](ch6_0.gif) 0
- en: (bitwise-first-bit-set #b01100) ![<graphic>](ch6_0.gif) 2
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: (bitwise-first-bit-set #b01100) ![<graphic>](ch6_0.gif) 2
- en: (bitwise-first-bit-set -1) ![<graphic>](ch6_0.gif) 0
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: (bitwise-first-bit-set -1) ![<graphic>](ch6_0.gif) 0
- en: (bitwise-first-bit-set -2) ![<graphic>](ch6_0.gif) 1
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: (bitwise-first-bit-set -2) ![<graphic>](ch6_0.gif) 1
- en: (bitwise-first-bit-set -3) ![<graphic>](ch6_0.gif) 0`
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: (bitwise-first-bit-set -3) ![<graphic>](ch6_0.gif) 0`
- en: '**procedure**: `(bitwise-bit-set? *exint[1]* *exint[2]*)`'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(bitwise-bit-set? *exint[1]* *exint[2]*)`'
- en: '**returns:** `#t` if bit `*exint[2]*` of `*exint[1]*` is set, `#f` otherwise'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*exint[1]*`的第`*exint[2]*`位被设置，则返回`#t`，否则返回`#f`'
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
- en: '`*exint[2]*` is taken as a zero-based index for the bits in the two''s complement
    representation of `*exint[1]*`. The two''s complement representation of a nonnegative
    number conceptually extends to the left (toward more significant bits) with an
    infinite number of zero bits, and the two''s complement representation of a negative
    number conceptually extends to the left with an infinite number of one bits. Thus,
    exact integers can be used to represent arbitrarily large sets, where 0 is the
    empty set, -1 is the universe, and `bitwise-bit-set?` is used to test for membership.'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: '`*exint[2]*`被视为`*exint[1]*`的二进制补码表示中位的从零开始的索引。非负数的二进制补码表示在左侧（向更重要的位）概念上扩展为无限数量的零位，而负数的二进制补码表示在左侧概念上扩展为无限数量的一位。因此，精确整数可用于表示任意大的集合，其中0是空集，-1是全集，`bitwise-bit-set?`用于测试成员资格。'
- en: '`(bitwise-bit-set? #b01011 0) ![<graphic>](ch6_0.gif) #t'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: '`(bitwise-bit-set? #b01011 0) ![<graphic>](ch6_0.gif) #t'
- en: (bitwise-bit-set? #b01011 2) ![<graphic>](ch6_0.gif) #f
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: (bitwise-bit-set? #b01011 2) ![<graphic>](ch6_0.gif) #f
- en: (bitwise-bit-set? -1 0) ![<graphic>](ch6_0.gif) #t
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: (bitwise-bit-set? -1 0) ![<graphic>](ch6_0.gif) #t
- en: (bitwise-bit-set? -1 20) ![<graphic>](ch6_0.gif) #t
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: (bitwise-bit-set? -1 20) ![<graphic>](ch6_0.gif) #t
- en: (bitwise-bit-set? -3 1) ![<graphic>](ch6_0.gif) #f
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: (bitwise-bit-set? -3 1) ![<graphic>](ch6_0.gif) #f
- en: (bitwise-bit-set? 0 5000) ![<graphic>](ch6_0.gif) #f
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: (bitwise-bit-set? 0 5000) ![<graphic>](ch6_0.gif) #f
- en: (bitwise-bit-set? -1 5000) ![<graphic>](ch6_0.gif) #t`
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: (bitwise-bit-set? -1 5000) ![<graphic>](ch6_0.gif) #t`
- en: '**procedure**: `(bitwise-copy-bit *exint[1]* *exint[2]* *exint[3]*)`'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(bitwise-copy-bit *exint[1]* *exint[2]* *exint[3]*)`'
- en: '**returns:** `*exint[1]*` with bit `*exint[2]*` replaced by `*exint[3]*`'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** `*exint[1]*`的第`*exint[2]*`位被`*exint[3]*`替换后的结果'
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
- en: '`*exint[2]*` is taken as a zero-based index for the bits in the two''s complement
    representation of `*exint[1]*`. `*exint[3]*` must be 0 or 1. This procedure effectively
    clears or sets the specified bit depending on the value of `*exint[3]*`. `*exint[1]*`
    is treated as if represented in two''s complement, even if it is not represented
    that way internally.'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: '`*exint[2]*`被视为`*exint[1]*`的二进制补码表示中位的从零开始的索引。`*exint[3]*`必须为0或1。该过程根据`*exint[3]*`的值有效地清除或设置指定的位。即使内部没有以二进制补码表示，也会将`*exint[1]*`视为以二进制补码表示。'
- en: '`(bitwise-copy-bit #b01110 0 1) ![<graphic>](ch6_0.gif) #b01111'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: '`(bitwise-copy-bit #b01110 0 1) ![<graphic>](ch6_0.gif) #b01111'
- en: (bitwise-copy-bit #b01110 2 0) ![<graphic>](ch6_0.gif) #b01010`
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: (bitwise-copy-bit #b01110 2 0) ![<graphic>](ch6_0.gif) #b01010`
- en: '**procedure**: `(bitwise-bit-field *exint[1]* *exint[2]* *exint[3]*)`'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(bitwise-bit-field *exint[1]* *exint[2]* *exint[3]*)`'
- en: '**returns:** see below'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 请参见下文'
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
- en: '`*exint[2]*` and `*exint[3]*` must be nonnegative, and `*exint[2]*` must not
    be greater than `*exint[3]*`. This procedure returns the number represented by
    extracting from `*exint[1]*` the sequence of bits from `*exint[2]*` (inclusive)
    to `*exint[3]*` (exclusive). `*exint[1]*` is treated as if represented in two''s
    complement, even if it is not represented that way internally.'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-bit-field #b10110 0 3) ![<graphic>](ch6_0.gif) #b00110'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-field #b10110 1 3) ![<graphic>](ch6_0.gif) #b00011
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-field #b10110 2 3) ![<graphic>](ch6_0.gif) #b00001
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-bit-field #b10110 3 3) ![<graphic>](ch6_0.gif) #b00000`
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-copy-bit-field *exint[1]* *exint[2]* *exint[3]* *exint[4]*)`'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: '`*exint[2]*` and `*exint[3]*` must be nonnegative, and `*exint[2]*` must not
    be greater than `*exint[3]*`. This procedure returns `*exint[1]*` with the `*n*`
    bits from `*exint[2]*` (inclusive) to `*exint[3]*` (exclusive) replaced by the
    low-order `*n*` bits of `*exint[4]*`. `*exint[1]*` and `*exint[4]*` are treated
    as if represented in two''s complement, even if they are not represented that
    way internally.'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-copy-bit-field #b10000 0 3 #b10101) ![<graphic>](ch6_0.gif) #b10101'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-copy-bit-field #b10000 1 3 #b10101) ![<graphic>](ch6_0.gif) #b10010
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-copy-bit-field #b10000 2 3 #b10101) ![<graphic>](ch6_0.gif) #b10100
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-copy-bit-field #b10000 3 3 #b10101) ![<graphic>](ch6_0.gif) #b10000`
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-arithmetic-shift-right *exint[1]* *exint[2]*)`'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*exint[1]*` arithmetically shifted right by `*exint[2]*` bits'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-arithmetic-shift-left *exint[1]* *exint[2]*)`'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*exint[1]*` shifted left by `*exint[2]*` bits'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
- en: '`*exint[2]*` must be nonnegative. `*exint[1]*` is treated as if represented
    in two''s complement, even if it is not represented that way internally.'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-arithmetic-shift-right #b10000 3) ![<graphic>](ch6_0.gif) #b00010'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift-right -1 1) ![<graphic>](ch6_0.gif) -1
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift-right -64 3) ![<graphic>](ch6_0.gif) -8
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift-left #b00010 2) ![<graphic>](ch6_0.gif) #b01000
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift-left -1 2) ![<graphic>](ch6_0.gif) -4`
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-arithmetic-shift *exint[1]* *exint[2]*)`'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: If `*exint[2]*` is negative, `bitwise-arithmetic-shift` returns the result of
    arithmetically shifting `*exint[1]*` right by `*exint[2]*` bits. Otherwise, `bitwise-arithmetic-shift`
    returns the result of shifting `*exint[1]*` left by `*exint[2]*` bits. `*exint[1]*`
    is treated as if represented in two's complement, even if it is not represented
    that way internally.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-arithmetic-shift #b10000 -3) ![<graphic>](ch6_0.gif) #b00010'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift -1 -1) ![<graphic>](ch6_0.gif) -1
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift -64 -3) ![<graphic>](ch6_0.gif) -8
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift #b00010 2) ![<graphic>](ch6_0.gif) #b01000
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift -1 2) ![<graphic>](ch6_0.gif) -4`
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: Thus, `bitwise-arithmetic-shift` behaves as if defined as follows.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
- en: '`(define bitwise-arithmetic-shift'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (exint1 exint2)
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
- en: (if (< exint2 0)
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift-right exint1 (- exint2))
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-arithmetic-shift-left exint1 exint2))))`
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-rotate-bit-field *exint[1]* *exint[2]* *exint[3]* *exint[4]*)`'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: '`*exint[2]*`, `*exint[3]*`, and `*exint[4]*` must be nonnegative, and `*exint[2]*`
    must not be greater than `*exint[3]*`. This procedure returns the result of shifting
    the bits of `*exint[1]*` from bit `*exint[2]*` (inclusive) through bit `*exint[3]*`
    (exclusive) left by `(mod *exint[4]* (- *exint[3]* *exint[2]*))` bits, with the
    bits shifted out of the range inserted at the bottom end of the range. `*exint[1]*`
    is treated as if represented in two''s complement, even if it is not represented
    that way internally.'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-rotate-bit-field #b00011010 0 5 3) ![<graphic>](ch6_0.gif) #b00010110'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-rotate-bit-field #b01101011 2 7 3) ![<graphic>](ch6_0.gif) #b01011011`
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bitwise-reverse-bit-field *exint[1]* *exint[2]* *exint[3]*)`'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic bitwise)`, `(rnrs)`'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: '`*exint[2]*` and `*exint[3]*` must be nonnegative, and `*exint[2]*` must not
    be greater than `*exint[3]*`. This procedure returns the result of reversing the
    bits of `*exint[1]*` from bit `*exint[2]*` (inclusive) through bit `*exint[3]*`
    (exclusive). `*exint[1]*` is treated as if represented in two''s complement, even
    if it is not represented that way internally.'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: '`(bitwise-reverse-bit-field #b00011010 0 5) ![<graphic>](ch6_0.gif) #b00001011'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
- en: (bitwise-reverse-bit-field #b01101011 2 7) ![<graphic>](ch6_0.gif) #b00101111`
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string->number *string*)`'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string->number *string* *radix*)`'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the number represented by `*string*`, or `#f`'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: If `*string*` is a valid representation of a number, that number is returned,
    otherwise `#f` is returned. The number is interpreted in radix `*radix*`, which
    must be an exact integer in the set {2,8,10,16}. If not specified, `*radix*` defaults
    to 10. Any radix specifier within `*string*`, e.g., `#x`, overrides the `*radix*`
    argument.
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: '`(string->number "0") ![<graphic>](ch6_0.gif) 0'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: (string->number "3.4e3") ![<graphic>](ch6_0.gif) 3400.0
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: (string->number "#x#e-2e2") ![<graphic>](ch6_0.gif) -738
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: (string->number "#e-2e2" 16) ![<graphic>](ch6_0.gif) -738
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
- en: (string->number "#i15/16") ![<graphic>](ch6_0.gif) 0.9375
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: (string->number "10" 16) ![<graphic>](ch6_0.gif) 16`
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(number->string *num*)`'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(number->string *num* *radix*)`'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(number->string *num* *radix* *precision*)`'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** an external representation of `*num*` as a string'
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: The num is expressed in radix `*radix*`, which must be an exact integer in the
    set {2,8,10,16}. If not specified, `*radix*` defaults to 10. In any case, no radix
    specifier appears in the resulting string.
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: 'The external representation is such that, when converted back into a number
    using `string->number`, the resulting numeric value is equivalent to `*num*`.
    That is, for all inputs:'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: '`(eqv? (string->number'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: (number->string *num* *radix*)
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: '*radix*)'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
- en: '*num*)`'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: returns `#t`. An exception with condition type `&implementation-restriction`
    is raised if this is not possible.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: If `*precision*` is provided, it must be an exact positive integer, `*num*`
    must be inexact, and `*radix*` must be 10. In this case, the real part and, if
    present, the imaginary part of the number are each printed with an explicit mantissa
    width `*m*`, where `*m*` is the least possible value greater than or equal to
    `*precision*` that makes the expression above true.
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: If `*radix*` is 10, inexact values of `*num*` are expressed using the fewest
    number of significant digits possible [[5](bibliography.html#g223)] without violating
    the above restriction.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: '`(number->string 3.4) ![<graphic>](ch6_0.gif) "3.4"'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: (number->string 1e2) ![<graphic>](ch6_0.gif) "100.0"
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
- en: (number->string 1e-23) ![<graphic>](ch6_0.gif) "1e-23"
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: (number->string -7/2) ![<graphic>](ch6_0.gif) "-7/2"
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
- en: (number->string 220/9 16) ![<graphic>](ch6_0.gif) "DC/9"`
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.5\. Fixnums
  id: totrans-1421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Fixnums* represent exact integers in the fixnum range, which is required to
    be a closed range [-2^(*w*-1),2^(*w*-2) - 1], where *w* (the *fixnum width*) is
    at least 24. The implementation-specific value of *w* may be determined via the
    procedure `fixnum-width`, and the endpoints of the range may be determined via
    the procedures `least-fixnum` and `greatest-fixnum`.'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: The names of arithmetic procedures that operate only on fixnums begin with the
    prefix "`fx`" to set them apart from their generic counterparts.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: Procedure arguments required to be fixnums are named `*fx*`, possibly with a
    suffix, e.g., `*fx[2]*`.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: Unless otherwise specified, the numeric values of fixnum-specific procedures
    are fixnums. If the value of a fixnum operation should be a fixnum, but the mathematical
    result would be outside the fixnum range, an exception with condition type `&implementation-restriction`
    is raised.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: Bit and shift operations on fixnums assume that fixnums are represented in two's
    complement, even if they are not represented that way internally.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fixnum? *obj*)`'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a fixnum, `#f` otherwise'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: '`(fixnum? 0) ![<graphic>](ch6_0.gif) #t'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: (fixnum? -1) ![<graphic>](ch6_0.gif) #t
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: (fixnum? (- (expt 2 23))) ![<graphic>](ch6_0.gif) #t
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: (fixnum? (- (expt 2 23) 1)) ![<graphic>](ch6_0.gif) #t`
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(least-fixnum)`'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the least (most negative) fixnum supported by the implementation'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(greatest-fixnum)`'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the greatest (most positive) fixnum supported by the implementation'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: '`(fixnum? (- (least-fixnum) 1)) ![<graphic>](ch6_0.gif) #f'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
- en: (fixnum? (least-fixnum)) ![<graphic>](ch6_0.gif) #t
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: (fixnum? (greatest-fixnum)) ![<graphic>](ch6_0.gif) #t
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: (fixnum? (+ (greatest-fixnum) 1)) ![<graphic>](ch6_0.gif) #f`
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fixnum-width)`'
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the implementation-dependent *fixnum width*'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: As described in the lead-in to this section, the fixnum width determines the
    size of the fixnum range and must be at least 24.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: '`(define w (fixnum-width))'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: (= (least-fixnum) (- (expt 2 (- w 1)))) ![<graphic>](ch6_0.gif) #t
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: (= (greatest-fixnum) (- (expt 2 (- w 1)) 1)) ![<graphic>](ch6_0.gif) #t
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: (>= w 24) ![<graphic>](ch6_0.gif) #t`
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx=? *fx[1]* *fx[2]* *fx[3]* ...)`'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx<? *fx[1]* *fx[2]* *fx[3]* ...)`'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx>? *fx[1]* *fx[2]* *fx[3]* ...)`'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx<=? *fx[1]* *fx[2]* *fx[3]* ...)`'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx>=? *fx[1]* *fx[2]* *fx[3]* ...)`'
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the relation holds, `#f` otherwise'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: The predicate `fx=?` returns `#t` if its arguments are equal. The predicate
    `fx<?` returns `#t` if its arguments are monotonically increasing, i.e., each
    argument is greater than the preceding ones, while `fx>?` returns `#t` if its
    arguments are monotonically decreasing. The predicate `fx<=?` returns `#t` if
    its arguments are monotonically nondecreasing, i.e., each argument is not less
    than the preceding ones, while `fx>=?` returns `#t` if its arguments are monotonically
    nonincreasing.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: '`(fx=? 0 0) ![<graphic>](ch6_0.gif) #t'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: (fx=? -1 1) ![<graphic>](ch6_0.gif) #f
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: (fx<? (least-fixnum) 0 (greatest-fixnum)) ![<graphic>](ch6_0.gif) #t
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x 3]) (fx<=? 0 x 9)) ![<graphic>](ch6_0.gif) #t
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: (fx>? 5 4 3 2 1) ![<graphic>](ch6_0.gif) #t
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: (fx<=? 1 3 2) ![<graphic>](ch6_0.gif) #f
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
- en: (fx>=? 0 0 (least-fixnum)) ![<graphic>](ch6_0.gif) #t`
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxzero? *fx*)`'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fx*` is zero, `#f` otherwise'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxpositive? *fx*)`'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fx*` is greater than zero, `#f` otherwise'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxnegative? *fx*)`'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fx*` is less than zero, `#f` otherwise'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: '`fxzero?` is equivalent to `(lambda (x) (fx=? x 0))`, `fxpositive?` is equivalent
    to `(lambda (x) (fx>? x 0))`, and `fxnegative?` to `(lambda (x) (fx<? x 0))`.'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxzero? 0) ![<graphic>](ch6_0.gif) #t'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: (fxzero? 1) ![<graphic>](ch6_0.gif) #f
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: (fxpositive? 128) ![<graphic>](ch6_0.gif) #t
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: (fxpositive? 0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: (fxpositive? -1) ![<graphic>](ch6_0.gif) #f
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: (fxnegative? -65) ![<graphic>](ch6_0.gif) #t
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: (fxnegative? 0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: (fxnegative? 1) ![<graphic>](ch6_0.gif) #f`
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxeven? *fx*)`'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fx*` is even, `#f` otherwise'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxodd? *fx*)`'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fx*` is odd, `#f` otherwise'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxeven? 0) ![<graphic>](ch6_0.gif) #t'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: (fxeven? 1) ![<graphic>](ch6_0.gif) #f
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: (fxeven? -1) ![<graphic>](ch6_0.gif) #f
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: (fxeven? -10) ![<graphic>](ch6_0.gif) #t
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: (fxodd? 0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: (fxodd? 1) ![<graphic>](ch6_0.gif) #t
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: (fxodd? -1) ![<graphic>](ch6_0.gif) #t
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: (fxodd? -10) ![<graphic>](ch6_0.gif) #f`
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxmin *fx[1]* *fx[2]* ...)`'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the minimum of `*fx[1]*` `*fx[2]*` ...'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxmax *fx[1]* *fx[2]* ...)`'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the maximum of `*fx[1]*` `*fx[2]*` ...'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxmin 4 -7 2 0 -6) ![<graphic>](ch6_0.gif) -7'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls '(7 3 5 2 9 8)])
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: (apply fxmin ls)) ![<graphic>](ch6_0.gif) 2
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: (fxmax 4 -7 2 0 -6) ![<graphic>](ch6_0.gif) 4
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls '(7 3 5 2 9 8)])
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: (apply fxmax ls)) ![<graphic>](ch6_0.gif) 9`
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx+ *fx[1]* *fx[2]*)`'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the sum of `*fx[1]*` and `*fx[2]*`'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: '`(fx+ -3 4) ![<graphic>](ch6_0.gif) 1`'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx- *fx*)`'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the additive inverse of `*fx*`'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx- *fx[1]* *fx[2]*)`'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the difference between `*fx[1]*` and `*fx[2]*`'
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: '`(fx- 3) ![<graphic>](ch6_0.gif) -3'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: (fx- -3 4) ![<graphic>](ch6_0.gif) -7`
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx* *fx[1]* *fx[2]*)`'
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the product of `*fx[1]*` and `*fx[2]*`'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: '`(fx* -3 4) ![<graphic>](ch6_0.gif) -12`'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxdiv *fx[1]* *fx[2]*)`'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxmod *fx[1]* *fx[2]*)`'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxdiv-and-mod *fx[1]* *fx[2]*)`'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*` must not be zero. These are fixnum-specific versions of the generic
    `div`, `mod`, and `div-and-mod`.'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxdiv 17 3) ![<graphic>](ch6_0.gif) 5'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: (fxmod 17 3) ![<graphic>](ch6_0.gif) 2
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: (fxdiv -17 3) ![<graphic>](ch6_0.gif) -6
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: (fxmod -17 3) ![<graphic>](ch6_0.gif) 1
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: (fxdiv 17 -3) ![<graphic>](ch6_0.gif) -5
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: (fxmod 17 -3) ![<graphic>](ch6_0.gif) 2
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: (fxdiv -17 -3) ![<graphic>](ch6_0.gif) 6
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: (fxmod -17 -3) ![<graphic>](ch6_0.gif) 1
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: (fxdiv-and-mod 17 3) ![<graphic>](ch6_0.gif) 5
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) 2`'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxdiv0 *fx[1]* *fx[2]*)`'
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxmod0 *fx[1]* *fx[2]*)`'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxdiv0-and-mod0 *fx[1]* *fx[2]*)`'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*` must not be zero. These are fixnum-specific versions of the generic
    `div0`, `mod0`, and `div0-and-mod0`.'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxdiv0 17 3) ![<graphic>](ch6_0.gif) 6'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: (fxmod0 17 3) ![<graphic>](ch6_0.gif) -1
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: (fxdiv0 -17 3) ![<graphic>](ch6_0.gif) -6
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: (fxmod0 -17 3) ![<graphic>](ch6_0.gif) 1
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: (fxdiv0 17 -3) ![<graphic>](ch6_0.gif) -6
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
- en: (fxmod0 17 -3) ![<graphic>](ch6_0.gif) -1
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: (fxdiv0 -17 -3) ![<graphic>](ch6_0.gif) 6
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: (fxmod0 -17 -3) ![<graphic>](ch6_0.gif) 1
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: (fxdiv0-and-mod0 17 3) ![<graphic>](ch6_0.gif) 6
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) -1`'
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx+/carry *fx[1]* *fx[2]* *fx[3]*)`'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx-/carry *fx[1]* *fx[2]* *fx[3]*)`'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fx*/carry *fx[1]* *fx[2]* *fx[3]*)`'
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: When an ordinary fixnum addition, subtraction, or multiplication operation overflows,
    an exception is raised. These alternative procedures instead return a carry and
    also allow the carry to be propagated to the next operation. They can be used
    to implement portable code for multiple-precision arithmetic.
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: 'These procedures return the two fixnum values of the following computations.
    For `fx+/carry`:'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: '`(let* ([s (+ *fx[1]* *fx[2]* *fx[3]*)]'
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: '[s0 (mod0 s (expt 2 (fixnum-width)))]'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: '[s1 (div0 s (expt 2 (fixnum-width)))])'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: (values s0 s1))`
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: 'for `fx-/carry`:'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: '`(let* ([d (- *fx[1]* *fx[2]* *fx[3]*)]'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: '[d0 (mod0 d (expt 2 (fixnum-width)))]'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: '[d1 (div0 d (expt 2 (fixnum-width)))])'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: (values d0 d1))`
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: 'and for `fx*/carry`:'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: '`(let* ([s (+ (* *fx[1]* *fx[2]*) *fx[3]*)]'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: '[s0 (mod0 s (expt 2 (fixnum-width)))]'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: '[s1 (div0 s (expt 2 (fixnum-width)))])'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: (values s0 s1))`
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxnot *fx*)`'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the bitwise not of `*fx*`'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxand *fx* ...)`'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the bitwise and of `*fx* ...`'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxior *fx* ...)`'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the bitwise inclusive or of `*fx* ...`'
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxxor *fx* ...)`'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the bitwise exclusive or of `*fx* ...`'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxnot 0) ![<graphic>](ch6_0.gif) -1'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: (fxnot 3) ![<graphic>](ch6_0.gif) -4
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: (fxand #b01101 #b00111) ![<graphic>](ch6_0.gif) #b00101
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: (fxior #b01101 #b00111) ![<graphic>](ch6_0.gif) #b01111
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: (fxxor #b01101 #b00111) ![<graphic>](ch6_0.gif) #b01010`
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxif *fx[1]* *fx[2]* *fx[3]*)`'
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the bitwise "if" of its arguments'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: For each bit set in `*fx[1]*`, the corresponding bit of the result is taken
    from `*fx[2]*`, and for each bit not set in `*fx[1]*`, the corresponding bit of
    the result is taken from `*x[3]*`.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxif #b101010 #b111000 #b001100) ![<graphic>](ch6_0.gif) #b101100`'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: '`fxif` might be defined as follows:'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: '`(define fxif'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (fx1 fx2 fx3)
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: (fxior (fxand fx1 fx2)
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: (fxand (fxnot fx1) fx3))))`
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxbit-count *fx*)`'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: For nonnegative inputs, `fxbit-count` returns the number of bits set in the
    two's complement representation of `*fx*`. For negative inputs, it returns a negative
    number whose magnitude is one greater than the number of bits not set in `*fx*`,
    which is equivalent to `(fxnot (fxbit-count (fxnot *fx*)))`.
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxbit-count #b00000) ![<graphic>](ch6_0.gif) 0'
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-count #b00001) ![<graphic>](ch6_0.gif) 1
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-count #b00100) ![<graphic>](ch6_0.gif) 1
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-count #b10101) ![<graphic>](ch6_0.gif) 3
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-count -1) ![<graphic>](ch6_0.gif) -1
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-count -2) ![<graphic>](ch6_0.gif) -2
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-count -4) ![<graphic>](ch6_0.gif) -3`
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxlength *fx*)`'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: This procedure returns the number of bits of the smallest two's complement representation
    of `*fx*`, not including the sign bit for negative numbers. For 0 `fxlength` returns
    0.
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxlength #b00000) ![<graphic>](ch6_0.gif) 0'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: (fxlength #b00001) ![<graphic>](ch6_0.gif) 1
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
- en: (fxlength #b00100) ![<graphic>](ch6_0.gif) 3
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: (fxlength #b00110) ![<graphic>](ch6_0.gif) 3
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: (fxlength -1) ![<graphic>](ch6_0.gif) 0
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
- en: (fxlength -6) ![<graphic>](ch6_0.gif) 3
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: (fxlength -9) ![<graphic>](ch6_0.gif) 4`
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxfirst-bit-set *fx*)`'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the index of the least significant bit set in `*fx*`'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
- en: If `*fx*` is 0, `fxfirst-bit-set` returns -1.
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxfirst-bit-set #b00000) ![<graphic>](ch6_0.gif) -1'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: (fxfirst-bit-set #b00001) ![<graphic>](ch6_0.gif) 0
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
- en: (fxfirst-bit-set #b01100) ![<graphic>](ch6_0.gif) 2
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: (fxfirst-bit-set -1) ![<graphic>](ch6_0.gif) 0
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
- en: (fxfirst-bit-set -2) ![<graphic>](ch6_0.gif) 1
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: (fxfirst-bit-set -3) ![<graphic>](ch6_0.gif) 0`
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxbit-set? *fx[1]* *fx[2]*)`'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if bit `*fx[2]*` of `*fx[1]*` is set, `#f` otherwise'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*` must be nonnegative. It is taken as a zero-based index for the bits
    in the two''s complement representation of `*fx[1]*`, with the sign bit virtually
    replicated an infinite number of positions to the left.'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxbit-set? #b01011 0) ![<graphic>](ch6_0.gif) #t'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-set? #b01011 2) ![<graphic>](ch6_0.gif) #f
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-set? -1 0) ![<graphic>](ch6_0.gif) #t
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-set? -1 20) ![<graphic>](ch6_0.gif) #t
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-set? -3 1) ![<graphic>](ch6_0.gif) #f
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-set? 0 (- (fixnum-width) 1)) ![<graphic>](ch6_0.gif) #f
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-set? -1 (- (fixnum-width) 1)) ![<graphic>](ch6_0.gif) #t`
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxcopy-bit *fx[1]* *fx[2]* *fx[3]*)`'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*fx[1]*` with bit `*fx[2]*` replaced by `*fx[3]*`'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*` must be nonnegative and less than the value of `(- (fixnum-width) 1)`.
    `*fx[3]*` must be 0 or 1. This procedure effectively clears or sets the specified
    bit depending on the value of `*fx[3]*`.'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxcopy-bit #b01110 0 1) ![<graphic>](ch6_0.gif) #b01111'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: (fxcopy-bit #b01110 2 0) ![<graphic>](ch6_0.gif) #b01010`
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxbit-field *fx[1]* *fx[2]* *fx[3]*)`'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*` and `*fx[3]*` must be nonnegative and less than the value of `(fixnum-width)`,
    and `*fx[2]*` must not be greater than `*fx[3]*`. This procedure returns the number
    represented by extracting from `*fx[1]*` the sequence of bits from `*fx[2]*` (inclusive)
    to `*fx[3]*` (exclusive).'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxbit-field #b10110 0 3) ![<graphic>](ch6_0.gif) #b00110'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-field #b10110 1 3) ![<graphic>](ch6_0.gif) #b00011
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-field #b10110 2 3) ![<graphic>](ch6_0.gif) #b00001
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: (fxbit-field #b10110 3 3) ![<graphic>](ch6_0.gif) #b00000`
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxcopy-bit-field *fx[1]* *fx[2]* *fx[3]* *fx[4]*)`'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*` and `*fx[3]*` must be nonnegative and less than the value of `(fixnum-width)`,
    and `*fx[2]*` must not be greater than `*fx[3]*`. This procedure returns `*fx[1]*`
    with `*n*` bits from `*fx[2]*` (inclusive) to `*fx[3]*` (exclusive) replaced by
    the low-order `*n*` bits of `*x[4]*`.'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxcopy-bit-field #b10000 0 3 #b10101) ![<graphic>](ch6_0.gif) #b10101'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: (fxcopy-bit-field #b10000 1 3 #b10101) ![<graphic>](ch6_0.gif) #b10010
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: (fxcopy-bit-field #b10000 2 3 #b10101) ![<graphic>](ch6_0.gif) #b10100
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: (fxcopy-bit-field #b10000 3 3 #b10101) ![<graphic>](ch6_0.gif) #b10000`
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxarithmetic-shift-right *fx[1]* *fx[2]*)`'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*fx[1]*` arithmetically shifted right by `*fx[2]*` bits'
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxarithmetic-shift-left *fx[1]* *fx[2]*)`'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*fx[1]*` shifted left by `*fx[2]*` bits'
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*` must be nonnegative and less than the value of `(fixnum-width)`.'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxarithmetic-shift-right #b10000 3) ![<graphic>](ch6_0.gif) #b00010'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift-right -1 1) ![<graphic>](ch6_0.gif) -1
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift-right -64 3) ![<graphic>](ch6_0.gif) -8
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift-left #b00010 2) ![<graphic>](ch6_0.gif) #b01000
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift-left -1 2) ![<graphic>](ch6_0.gif) -4`
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxarithmetic-shift *fx[1]* *fx[2]*)`'
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: The absolute value of `*fx[2]*` must be less than the value of `(fixnum-width)`.
    If `*fx[2]*` is negative, `fxarithmetic-shift` returns the result of arithmetically
    shifting `*fx[1]*` right by `*fx[2]*` bits. Otherwise, `fxarithmetic-shift` returns
    the result of shifting `*fx[1]*` left by `*fx[2]*` bits.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxarithmetic-shift #b10000 -3) ![<graphic>](ch6_0.gif) #b00010'
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift -1 -1) ![<graphic>](ch6_0.gif) -1
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift -64 -3) ![<graphic>](ch6_0.gif) -8
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift #b00010 2) ![<graphic>](ch6_0.gif) #b01000
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift -1 2) ![<graphic>](ch6_0.gif) -4`
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: Thus, `fxarithmetic-shift` behaves as if defined as follows.
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: '`(define fxarithmetic-shift'
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (fx1 fx2)
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: (if (fx<? fx2 0)
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift-right fx1 (fx- fx2))
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: (fxarithmetic-shift-left fx1 fx2))))`
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxrotate-bit-field *fx[1]* *fx[2]* *fx[3]* *fx[4]*)`'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*`, `*fx[3]*`, and `*fx[4]*` must be nonnegative and less than the value
    of `(fixnum-width)`, `*fx[2]*` must not be greater than `*fx[3]*`, and `*fx[4]*`
    must not be greater than the difference between `*fx[3]*` and `*fx[2]*`.'
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: This procedure returns the result of shifting the bits of `*fx[1]*` from bit
    `*fx[2]*` (inclusive) through bit `*fx[3]*` (exclusive) left by `*fx[4]*` bits,
    with the bits shifted out of the range inserted at the bottom end of the range.
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxrotate-bit-field #b00011010 0 5 3) ![<graphic>](ch6_0.gif) #b00010110'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: (fxrotate-bit-field #b01101011 2 7 3) ![<graphic>](ch6_0.gif) #b01011011`
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fxreverse-bit-field *fx[1]* *fx[2]* *fx[3]*)`'
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic fixnums)`, `(rnrs)`'
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: '`*fx[2]*` and `*fx[3]*` must be nonnegative and less than the value of `(fixnum-width)`,
    and `*fx[2]*` must not be greater than `*fx[3]*`. This procedure returns the result
    of reversing the bits of `*fx[1]*` from bit `*fx[2]*` (inclusive) through bit
    `*fx[3]*` (exclusive).'
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: '`(fxreverse-bit-field #b00011010 0 5) ![<graphic>](ch6_0.gif) #b00001011'
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: (fxreverse-bit-field #b01101011 2 7) ![<graphic>](ch6_0.gif) #b00101111`
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.6\. Flonums
  id: totrans-1702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Flonums* represent inexact real numbers. Implementations are required to represent
    as a flonum any inexact real number whose lexical syntax contains no vertical
    bar and no exponent marker other than `e`, but are not required to represent any
    other inexact real number as a flonum.'
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: Implementations typically use the IEEE double-precision floating-point representation
    for flonums, but implementations are not required to do so or even to use a floating-point
    representation of any sort, despite the name "flonum."
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: This section describes operations on flonums. Flonum-specific procedure names
    begin with the prefix "`fl`" to set them apart from their generic counterparts.
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: Procedure arguments required to be flonums are named `*fl*`, possibly with suffix,
    e.g., `*fl[2]*`. Unless otherwise specified, the numeric values of flonum-specific
    procedures are flonums.
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flonum? *obj*)`'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a flonum, otherwise `#f`'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: '`(flonum? 0) ![<graphic>](ch6_0.gif) #f'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: (flonum? 3/4) ![<graphic>](ch6_0.gif) #f
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: (flonum? 3.5) ![<graphic>](ch6_0.gif) #t
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: (flonum? .02) ![<graphic>](ch6_0.gif) #t
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
- en: (flonum? 1e10) ![<graphic>](ch6_0.gif) #t
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: (flonum? 3.0+0.0i) ![<graphic>](ch6_0.gif) #f`
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl=? *fl[1]* *fl[2]* *fl[3]* ...)`'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl<? *fl[1]* *fl[2]* *fl[3]* ...)`'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl>? *fl[1]* *fl[2]* *fl[3]* ...)`'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl<=? *fl[1]* *fl[2]* *fl[3]* ...)`'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl>=? *fl[1]* *fl[2]* *fl[3]* ...)`'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the relation holds, `#f` otherwise'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: The predicate `fl=?` returns `#t` if its arguments are equal. The predicate
    `fl<?` returns `#t` if its arguments are monotonically increasing, i.e., each
    argument is greater than the preceding ones, while `fl>?` returns `#t` if its
    arguments are monotonically decreasing. The predicate `fl<=?` returns `#t` if
    its arguments are monotonically nondecreasing, i.e., each argument is not less
    than the preceding ones, while `fl>=?` returns `#t` if its arguments are monotonically
    nonincreasing. When passed only one argument, each of these predicates returns
    `#t`.
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: Comparisons involving NaNs always return `#f`.
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: '`(fl=? 0.0 0.0) ![<graphic>](ch6_0.gif) #t'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
- en: (fl<? -1.0 0.0 1.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: (fl>? -1.0 0.0 1.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
- en: (fl<=? 0.0 3.0 3.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: (fl>=? 4.0 3.0 3.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: (fl<? 7.0 +inf.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: (fl=? +nan.0 0.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
- en: (fl=? +nan.0 +nan.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: (fl<? +nan.0 +nan.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
- en: (fl<=? +nan.0 +inf.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
- en: (fl>=? +nan.0 +inf.0) ![<graphic>](ch6_0.gif) #f`
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flzero? *fl*)`'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl*` is zero, `#f` otherwise'
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flpositive? *fl*)`'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl*` is greater than zero, `#f` otherwise'
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flnegative? *fl*)`'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl*` is less than zero, `#f` otherwise'
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: '`flzero?` is equivalent to `(lambda (x) (fl=? x 0.0))`, `flpositive?` is equivalent
    to `(lambda (x) (fl>? x 0.0))`, and `flnegative?` to `(lambda (x) (fl<? x 0.0))`.'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: Even if the flonum representation distinguishes -0.0 from +0.0, -0.0 is considered
    both zero and nonnegative.
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
- en: '`(flzero? 0.0) ![<graphic>](ch6_0.gif) #t'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
- en: (flzero? 1.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: (flpositive? 128.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: (flpositive? 0.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
- en: (flpositive? -1.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
- en: (flnegative? -65.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: (flnegative? 0.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
- en: (flnegative? 1.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
- en: (flzero? -0.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
- en: (flnegative? -0.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
- en: (flnegative? +nan.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: (flzero? +nan.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
- en: (flpositive? +nan.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
- en: (flnegative? +inf.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
- en: (flnegative? -inf.0) ![<graphic>](ch6_0.gif) #t`
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flinteger? *fl*)`'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl*` is integer, `#f` otherwise'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
- en: '`(flinteger? 0.0) ![<graphic>](ch6_0.gif) #t'
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
- en: (flinteger? -17.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
- en: (flinteger? +nan.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
- en: (flinteger? +inf.0) ![<graphic>](ch6_0.gif) #f`
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flfinite? *fl*)`'
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl*` is finite, `#f` otherwise'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flinfinite? *fl*)`'
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl*` is infinite, `#f` otherwise'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flnan? *fl*)`'
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl*` is a NaN, `#f` otherwise'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: '`(flfinite? 3.1415) ![<graphic>](ch6_0.gif) #t'
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
- en: (flinfinite? 3.1415) ![<graphic>](ch6_0.gif) #f
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: (flnan? 3.1415) ![<graphic>](ch6_0.gif) #f
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
- en: (flfinite? +inf.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
- en: (flinfinite? -inf.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
- en: (flnan? -inf.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
- en: (flfinite? +nan.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
- en: (flinfinite? +nan.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
- en: (flnan? +nan.0) ![<graphic>](ch6_0.gif) #t`
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fleven? *fl-int*)`'
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl-int*` is even, `#f` otherwise'
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flodd? *fl-int*)`'
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*fl-int*` is odd, `#f` otherwise'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
- en: '`*fl-int*` must be an integer-valued flonum.'
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
- en: '`(fleven? 0.0) ![<graphic>](ch6_0.gif) #t'
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
- en: (fleven? 1.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
- en: (fleven? -1.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
- en: (fleven? -10.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: (flodd? 0.0) ![<graphic>](ch6_0.gif) #f
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: (flodd? 1.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
- en: (flodd? -1.0) ![<graphic>](ch6_0.gif) #t
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: (flodd? -10.0) ![<graphic>](ch6_0.gif) #f`
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flmin *fl[1]* *fl[2]* ...)`'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the minimum of `*fl[1]*` `*fl[2]*` ...'
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flmax *fl[1]* *fl[2]* ...)`'
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the maximum of `*fl[1]*` `*fl[2]*` ...'
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
- en: '`(flmin 4.2 -7.5 2.0 0.0 -6.4) ![<graphic>](ch6_0.gif) -7.5'
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
- en: (apply flmin ls)) ![<graphic>](ch6_0.gif) 2.6
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: (flmax 4.2 -7.5 2.0 0.0 -6.4) ![<graphic>](ch6_0.gif) 4.2
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
- en: (apply flmax ls)) ![<graphic>](ch6_0.gif) 8.0`
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl+ *fl* ...)`'
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the sum of the arguments `*fl* ...`'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
- en: When called with no arguments, `fl+` returns `0.0`.
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
- en: '`(fl+) ![<graphic>](ch6_0.gif) 0.0'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
- en: (fl+ 1.0 2.5) ![<graphic>](ch6_0.gif) 3.25
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
- en: (fl+ 3.0 4.25 5.0) ![<graphic>](ch6_0.gif) 12.25
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
- en: (apply fl+ '(1.0 2.0 3.0 4.0 5.0)) ![<graphic>](ch6_0.gif) 15.0`
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl- *fl*)`'
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the additive inverse of `*fl*`'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl- *fl[1]* *fl[2]* *fl[3]* ...)`'
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the difference between `*fl[1]*` and the sum of `*fl[2]* *fl[3]* ...`'
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
- en: With an IEEE floating-point representation of flonums, the single-argument `fl-`
    is equivalent to
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
- en: '`(lambda (x) (fl* -1.0 x))`'
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
- en: or
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
- en: '`(lambda (x) (fl- -0.0 x))`'
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
- en: but not
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
- en: '`(lambda (x) (fl- 0.0 x))`'
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
- en: since the latter returns `0.0` rather than `-0.0` for `0.0`.
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
- en: '`(fl- 0.0) ![<graphic>](ch6_0.gif) -0.0'
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
- en: (fl- 3.0) ![<graphic>](ch6_0.gif) -3.0
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
- en: (fl- 4.0 3.0) ![<graphic>](ch6_0.gif) 1.0
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
- en: (fl- 4.0 3.0 2.0 1.0) ![<graphic>](ch6_0.gif) -2.0`
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl* *fl* ...)`'
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the product of the arguments `*fl* ...`'
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
- en: When called with no arguments, `fl*` returns `1.0`.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
- en: '`(fl*) ![<graphic>](ch6_0.gif) 1.0'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
- en: (fl* 1.5 2.5) ![<graphic>](ch6_0.gif) 3.75
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
- en: (fl* 3.0 -4.0 5.0) ![<graphic>](ch6_0.gif) -60.0
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
- en: (apply fl* '(1.0 -2.0 3.0 -4.0 5.0)) ![<graphic>](ch6_0.gif) 120.0`
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl/ *fl*)`'
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the multiplicative inverse of `*fl*`'
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fl/ *fl[1]* *fl[2]* *fl[3]* ...)`'
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the result of dividing `*fl[1]*` by the product of `*fl[2]* *fl[3]* ...`'
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
- en: '`(fl/ -4.0) ![<graphic>](ch6_0.gif) -0.25'
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
- en: (fl/ 8.0 -2.0) ![<graphic>](ch6_0.gif) -4.0
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
- en: (fl/ -9.0 2.0) ![<graphic>](ch6_0.gif) -4.5
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
- en: (fl/ 60.0 5.0 3.0 2.0) ![<graphic>](ch6_0.gif) 2.0`
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fldiv *fl[1]* *fl[2]*)`'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flmod *fl[1]* *fl[2]*)`'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fldiv-and-mod *fl[1]* *fl[2]*)`'
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
- en: These are flonum-specific versions of the generic `div`, `mod`, and `div-and-mod`.
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
- en: '`(fldiv 17.0 3.0) ![<graphic>](ch6_0.gif) 5.0'
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
- en: (flmod 17.0 3.0) ![<graphic>](ch6_0.gif) 2.0
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
- en: (fldiv -17.0 3.0) ![<graphic>](ch6_0.gif) -6.0
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
- en: (flmod -17.0 3.0) ![<graphic>](ch6_0.gif) 1.0
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
- en: (fldiv 17.0 -3.0) ![<graphic>](ch6_0.gif) -5.0
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
- en: (flmod 17.0 -3.0) ![<graphic>](ch6_0.gif) 2.0
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
- en: (fldiv -17.0 -3.0) ![<graphic>](ch6_0.gif) 6.0
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
- en: (flmod -17.0 -3.0) ![<graphic>](ch6_0.gif) 1.0
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
- en: (fldiv-and-mod 17.5 3.75) ![<graphic>](ch6_0.gif) 4.0
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) 2.5`'
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fldiv0 *fl[1]* *fl[2]*)`'
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flmod0 *fl[1]* *fl[2]*)`'
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fldiv0-and-mod0 *fl[1]* *fl[2]*)`'
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
- en: These are flonum-specific versions of the generic `div0`, `mod0`, and `div0-and-mod0`.
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
- en: '`(fldiv0 17.0 3.0) ![<graphic>](ch6_0.gif) 6.0'
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
- en: (flmod0 17.0 3.0) ![<graphic>](ch6_0.gif) -1.0
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
- en: (fldiv0 -17.0 3.0) ![<graphic>](ch6_0.gif) -6.0
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
- en: (flmod0 -17.0 3.0) ![<graphic>](ch6_0.gif) 1.0
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
- en: (fldiv0 17.0 -3.0) ![<graphic>](ch6_0.gif) -6.0
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
- en: (flmod0 17.0 -3.0) ![<graphic>](ch6_0.gif) -1.0
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
- en: (fldiv0 -17.0 -3.0) ![<graphic>](ch6_0.gif) 6.0
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
- en: (flmod0 -17.0 -3.0) ![<graphic>](ch6_0.gif) 1.0
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
- en: (fldiv0-and-mod0 17.5 3.75) ![<graphic>](ch6_0.gif) 5.0
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) -1.25`'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flround *fl*)`'
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer closest to `*fl*`'
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fltruncate *fl*)`'
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer closest to `*fl*` toward zero'
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flfloor *fl*)`'
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer closest to `*fl*` toward ![<graphic>](ch6_11.gif)'
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flceiling *fl*)`'
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the integer closest to `*fl*` toward ![<graphic>](ch6_12.gif)'
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
- en: If `*fl*` is an integer, NaN, or infinity, each of these procedures returns
    `*fl*`. If `*fl*` is exactly between two integers, `flround` returns the closest
    even integer.
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
- en: '`(flround 17.3) ![<graphic>](ch6_0.gif) 17.0'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
- en: (flround -17.3) ![<graphic>](ch6_0.gif) -17.0
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
- en: (flround 2.5) ![<graphic>](ch6_0.gif) 2.0
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
- en: (flround 3.5) ![<graphic>](ch6_0.gif) 4.0
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
- en: (fltruncate 17.3) ![<graphic>](ch6_0.gif) 17.0
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
- en: (fltruncate -17.3) ![<graphic>](ch6_0.gif) -17.0
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
- en: (flfloor 17.3) ![<graphic>](ch6_0.gif) 17.0
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
- en: (flfloor -17.3) ![<graphic>](ch6_0.gif) -18.0
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
- en: (flceiling 17.3) ![<graphic>](ch6_0.gif) 18.0
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
- en: (flceiling -17.3) ![<graphic>](ch6_0.gif) -17.0`
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flnumerator *fl*)`'
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the numerator of `*fl*`'
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fldenominator *fl*)`'
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the denominator of `*fl*`'
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
- en: If `*fl*` is an integer, including 0.0, or infinity, the numerator is `*fl*`
    and the denominator is 1.0.
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
- en: '`(flnumerator -9.0) ![<graphic>](ch6_0.gif) -9.0'
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
- en: (fldenominator -9.0) ![<graphic>](ch6_0.gif) 1.0
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
- en: (flnumerator 0.0) ![<graphic>](ch6_0.gif) 0.0
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
- en: (fldenominator 0.0) ![<graphic>](ch6_0.gif) 1.0
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
- en: (flnumerator -inf.0) ![<graphic>](ch6_0.gif) -inf.0
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
- en: (fldenominator -inf.0) ![<graphic>](ch6_0.gif) 1.0`
  id: totrans-1912
  prefs: []
  type: TYPE_NORMAL
- en: The following hold for IEEE floats, but not necessarily other flonum representations.
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
- en: '`(flnumerator 3.5) ![<graphic>](ch6_0.gif) 7.0'
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
- en: (fldenominator 3.5) ![<graphic>](ch6_0.gif) 2.0`
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flabs *fl*)`'
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** absolute value of `*fl*`'
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
- en: '`(flabs 3.2) ![<graphic>](ch6_0.gif) 3.2'
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
- en: (flabs -2e-20) ![<graphic>](ch6_0.gif) 2e-20`
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flexp *fl*)`'
  id: totrans-1921
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** *e* to the `*fl*` power'
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fllog *fl*)`'
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the natural logarithm of `*fl*`'
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fllog *fl[1]* *fl[2]*)`'
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the base-`*fl[2]*` logarithm of `*fl[1]*`'
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
- en: '`(flexp 0.0) ![<graphic>](ch6_0.gif) 1.0'
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
- en: (flexp 1.0) ![<graphic>](ch6_0.gif) 2.7182818284590455
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
- en: (fllog 1.0) ![<graphic>](ch6_0.gif) 0.0
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
- en: (fllog (exp 1.0)) ![<graphic>](ch6_0.gif) 1.0
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
- en: (fl/ (fllog 100.0) (fllog 10.0)) ![<graphic>](ch6_0.gif) 2.0
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
- en: (fllog 100.0 10.0) ![<graphic>](ch6_0.gif) 2.0
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
- en: (fllog .125 2.0) ![<graphic>](ch6_0.gif) -3.0`
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flsin *fl*)`'
  id: totrans-1935
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the sine of `*fl*`'
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flcos *fl*)`'
  id: totrans-1937
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the cosine of `*fl*`'
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fltan *fl*)`'
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the tangent of `*fl*`'
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flasin *fl*)`'
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the arc sine of `*fl*`'
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flacos *fl*)`'
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the arc cosine of `*fl*`'
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flatan *fl*)`'
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the arc tangent of `*fl*`'
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flatan *fl[1]* *fl[2]*)`'
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the arc tangent of `*fl[1]*`/`*fl[2]*`'
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flsqrt *fl*)`'
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the principal square root of `*fl*`'
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
- en: Returns the principal square root of `*fl*`. The square root of -0.0 should
    be -0.0. The result for other negative numbers may be a NaN or some other unspecified
    flonum.
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
- en: '`(flsqrt 4.0) ![<graphic>](ch6_0.gif) 2.0'
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
- en: (flsqrt 0.0) ![<graphic>](ch6_0.gif) 0.0
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
- en: (flsqrt -0.0) ![<graphic>](ch6_0.gif) -0.0`
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(flexpt *fl[1]* *fl[2]*)`'
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*fl[1]*` raised to the `*fl[2]*` power'
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
- en: If `*fl[1]*` is negative and `*fl[2]*` is not an integer, the result may be
    a NaN or some other unspecified flonum. If `*fl[1]*` and `*fl[2]*` are both zero,
    the result is 1.0\. If `*fl[1]*` is zero and `*fl[2]*` is positive, the result
    is zero. In other cases where `*fl[1]*` is zero, the result may be a NaN or some
    other unspecified flonum.
  id: totrans-1961
  prefs: []
  type: TYPE_NORMAL
- en: '`(flexpt 3.0 2.0) ![<graphic>](ch6_0.gif) 9.0'
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
- en: (flexpt 0.0 +inf.0) ![<graphic>](ch6_0.gif) 0.0`
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fixnum->flonum *fx*)`'
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the flonum representation closest to `*fx*`'
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(real->flonum *real*)`'
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the flonum representation closest to `*real*`'
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs arithmetic flonums)`, `(rnrs)`'
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
- en: '`fixnum->flonum` is a restricted variant of `inexact`. `real->flonum` is a
    restricted variant of `inexact` when the input is an exact real; when it is an
    inexact non-flonum real, it coverts the inexact non-flonum real into the closest
    flonum.'
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
- en: '`(fixnum->flonum 0) ![<graphic>](ch6_0.gif) 0.0'
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
- en: (fixnum->flonum 13) ![<graphic>](ch6_0.gif) 13.0
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
- en: (real->flonum -1/2) ![<graphic>](ch6_0.gif) -0.5
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
- en: (real->flonum 1s3) ![<graphic>](ch6_0.gif) 1000.0`
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.7\. Characters
  id: totrans-1974
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Characters are atomic objects representing letters, digits, special symbols
    such as `$` or `-`, and certain nongraphic control characters such as space and
    newline. Characters are written with a `#\` prefix. For most characters, the prefix
    is followed by the character itself. The written character representation of the
    letter `A`, for example, is `#\A`. The characters newline, space, and tab may
    be written in this manner as well, but they can be written more clearly as `#\newline`,
    `#\space`, and `#\tab`. Other character names are supported as well, as defined
    by the grammar for character objects on page [457](grammar.html#grammar:characters).
    Any Unicode character may be written with the syntax `#\x*n*`, where `*n*` consists
    of one or more hexadecimal digits and represents a valid Unicode scalar value.
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
- en: This section describes the operations that deal primarily with characters. See
    also the following section on strings and Chapter [7](io.html#g121) on input and
    output for other operations relating to characters.
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char=? *char[1]* *char[2]* *char[3]* ...)`'
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char<? *char[1]* *char[2]* *char[3]* ...)`'
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char>? *char[1]* *char[2]* *char[3]* ...)`'
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char<=? *char[1]* *char[2]* *char[3]* ...)`'
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char>=? *char[1]* *char[2]* *char[3]* ...)`'
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the relation holds, `#f` otherwise'
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
- en: These predicates behave in a similar manner to the numeric predicates `=`, `<`,
    `>`, `<=`, and `>=`. For example, `char=?` returns `#t` when its arguments are
    equivalent characters, and `char<?` returns `#t` when its arguments are monotonically
    increasing character (Unicode scalar) values.
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
- en: '`(char>? #\a #\b) ![<graphic>](ch6_0.gif) #f'
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
- en: (char<? #\a #\b) ![<graphic>](ch6_0.gif) #t
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
- en: (char<? #\a #\b #\c) ![<graphic>](ch6_0.gif) #t
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
- en: (let ([c #\r])
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
- en: (char<=? #\a c #\z)) ![<graphic>](ch6_0.gif) #t
  id: totrans-1989
  prefs: []
  type: TYPE_NORMAL
- en: (char<=? #\Z #\W) ![<graphic>](ch6_0.gif) #f
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
- en: (char=? #\+ #\+) ![<graphic>](ch6_0.gif) #t`
  id: totrans-1991
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-ci=? *char[1]* *char[2]* *char[3]* ...)`'
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-ci<? *char[1]* *char[2]* *char[3]* ...)`'
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-ci>? *char[1]* *char[2]* *char[3]* ...)`'
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-ci<=? *char[1]* *char[2]* *char[3]* ...)`'
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-ci>=? *char[1]* *char[2]* *char[3]* ...)`'
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the relation holds, `#f` otherwise'
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
- en: These predicates are identical to the predicates `char=?`, `char<?`, `char>?`,
    `char<=?`, and `char>=?` except that they are case-insensitive, i.e., compare
    the case-folded versions of their arguments. For example, `char=?` considers `#\a`
    and `#\A` to be distinct values; `char-ci=?` does not.
  id: totrans-1999
  prefs: []
  type: TYPE_NORMAL
- en: '`(char-ci<? #\a #\B) ![<graphic>](ch6_0.gif) #t'
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
- en: (char-ci=? #\W #\w) ![<graphic>](ch6_0.gif) #t
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
- en: (char-ci=? #\= #\+) ![<graphic>](ch6_0.gif) #f
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
- en: (let ([c #\R])
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
- en: (list (char<=? #\a c #\z)
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
- en: (char-ci<=? #\a c #\z))) ![<graphic>](ch6_0.gif) (#f #t)`
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-alphabetic? *char*)`'
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*char*` is a letter, `#f` otherwise'
  id: totrans-2007
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-numeric? *char*)`'
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*char*` is a digit, `#f` otherwise'
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-whitespace? *char*)`'
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*char*` is whitespace, `#f` otherwise'
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
- en: A character is alphabetic if it has the Unicode "Alphabetic" property, numeric
    if it has the Unicode "Numeric" property, and whitespace if has the Unicode "White_Space"
    property.
  id: totrans-2013
  prefs: []
  type: TYPE_NORMAL
- en: '`(char-alphabetic? #\a) ![<graphic>](ch6_0.gif) #t'
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
- en: (char-alphabetic? #\T) ![<graphic>](ch6_0.gif) #t
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
- en: (char-alphabetic? #\8) ![<graphic>](ch6_0.gif) #f
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
- en: (char-alphabetic? #\$) ![<graphic>](ch6_0.gif) #f
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
- en: (char-numeric? #\7) ![<graphic>](ch6_0.gif) #t
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
- en: (char-numeric? #\2) ![<graphic>](ch6_0.gif) #t
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
- en: (char-numeric? #\X) ![<graphic>](ch6_0.gif) #f
  id: totrans-2020
  prefs: []
  type: TYPE_NORMAL
- en: (char-numeric? #\space) ![<graphic>](ch6_0.gif) #f
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
- en: (char-whitespace? #\space) ![<graphic>](ch6_0.gif) #t
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
- en: (char-whitespace? #\newline) ![<graphic>](ch6_0.gif) #t
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
- en: (char-whitespace? #\Z) ![<graphic>](ch6_0.gif) #f`
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-lower-case? *char*)`'
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*char*` is lower case, `#f` otherwise'
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-upper-case? *char*)`'
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*char*` is upper case, `#f` otherwise'
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-title-case? *char*)`'
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*char*` is title case, `#f` otherwise'
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
- en: A character is upper-case if it has the Unicode "Uppercase" property, lower-case
    if it has the "Lowercase" property, and title-case if it is in the Lt general
    category.
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
- en: '`(char-lower-case? #\r) ![<graphic>](ch6_0.gif) #t'
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
- en: (char-lower-case? #\R) ![<graphic>](ch6_0.gif) #f
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
- en: (char-upper-case? #\r) ![<graphic>](ch6_0.gif) #f
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
- en: (char-upper-case? #\R) ![<graphic>](ch6_0.gif) #t
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
- en: (char-title-case? #\I) ![<graphic>](ch6_0.gif) #f
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
- en: (char-title-case? #\x01C5) ![<graphic>](ch6_0.gif) #t`
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-general-category *char*)`'
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a symbol representing the Unicode general category of `*char*`'
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
- en: The return value is one of the symbols `Lu`, `Ll`, `Lt`, `Lm`, `Lo`, `Mn`, `Mc`,
    `Me`, `Nd`, `Nl`, `No`, `Ps`, `Pe`, `Pi`, `Pf`, `Pd`, `Pc`, `Po`, `Sc`, `Sm`,
    `Sk`, `So`, `Zs`, `Zp`, `Zl`, `Cc`, `Cf`, `Cs`, `Co`, or `Cn`.
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
- en: '`(char-general-category #\a) ![<graphic>](ch6_0.gif) Ll'
  id: totrans-2043
  prefs: []
  type: TYPE_NORMAL
- en: (char-general-category #\space) ![<graphic>](ch6_0.gif) Zs
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
- en: (char-general-category #\x10FFFF) ![<graphic>](ch6_0.gif) Cn  `
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-upcase *char*)`'
  id: totrans-2046
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the upper-case character counterpart of `*char*`'
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
- en: If `*char*` is a lower- or title-case character and has a single upper-case
    counterpart, `char-upcase` returns the upper-case counterpart. Otherwise `char-upcase`
    returns `*char*`.
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
- en: '`(char-upcase #\g) ![<graphic>](ch6_0.gif) #\G'
  id: totrans-2050
  prefs: []
  type: TYPE_NORMAL
- en: (char-upcase #\G) ![<graphic>](ch6_0.gif) #\G
  id: totrans-2051
  prefs: []
  type: TYPE_NORMAL
- en: (char-upcase #\7) ![<graphic>](ch6_0.gif) #\7
  id: totrans-2052
  prefs: []
  type: TYPE_NORMAL
- en: (char-upcase #\![<graphic>](ch6_20.gif)) ![<graphic>](ch6_0.gif) #\![<graphic>](ch6_21.gif)`
  id: totrans-2053
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-downcase *char*)`'
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the lower-case character equivalent of `*char*`'
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
- en: If `*char*` is an upper- or title-case character and has a single lower-case
    counterpart, `char-downcase` returns the lower-case counterpart. Otherwise `char-downcase`
    returns `*char*`.
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
- en: '`(char-downcase #\g) ![<graphic>](ch6_0.gif) #\g'
  id: totrans-2058
  prefs: []
  type: TYPE_NORMAL
- en: (char-downcase #\G) ![<graphic>](ch6_0.gif) #\g
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
- en: (char-downcase #\7) ![<graphic>](ch6_0.gif) #\7
  id: totrans-2060
  prefs: []
  type: TYPE_NORMAL
- en: (char-downcase #\![<graphic>](ch6_20.gif)) ![<graphic>](ch6_0.gif) #\![<graphic>](ch6_20.gif)`
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-titlecase *char*)`'
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the title-case character equivalent of `*char*`'
  id: totrans-2063
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
- en: If `*char*` is an upper- or lower-case character and has a single title-case
    counterpart, `char-titlecase` returns the title-case counterpart. Otherwise, if
    it is not a title-case character, has no single title-case counterpart, but does
    have a single upper-case counterpart, `char-titlecase` returns the upper-case
    counterpart. Otherwise `char-titlecase` returns `*char*`.
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
- en: '`(char-titlecase #\g) ![<graphic>](ch6_0.gif) #\G'
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
- en: (char-titlecase #\G) ![<graphic>](ch6_0.gif) #\G
  id: totrans-2067
  prefs: []
  type: TYPE_NORMAL
- en: (char-titlecase #\7) ![<graphic>](ch6_0.gif) #\7
  id: totrans-2068
  prefs: []
  type: TYPE_NORMAL
- en: (char-titlecase #\![<graphic>](ch6_20.gif)) ![<graphic>](ch6_0.gif) #\![<graphic>](ch6_21.gif)`
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char-foldcase *char*)`'
  id: totrans-2070
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the case-folded character equivalent of `*char*`'
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  id: totrans-2072
  prefs: []
  type: TYPE_NORMAL
- en: If `*char*` has a case-folded counterpart, `char-foldcase` returns the case-folded
    counterpart. Otherwise, `char-foldcase` returns `*char*`. For most characters,
    `(char-foldcase *char*)` is equivalent to `(char-downcase (char-upcase *char*))`,
    but for Turkic İ and ı, `char-foldcase` acts as the identity.
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
- en: '`(char-foldcase #\g) ![<graphic>](ch6_0.gif) #\g'
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
- en: (char-foldcase #\G) ![<graphic>](ch6_0.gif) #\g
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
- en: (char-foldcase #\7) ![<graphic>](ch6_0.gif) #\7
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
- en: (char-foldcase #\![<graphic>](ch6_20.gif)) ![<graphic>](ch6_0.gif) #\![<graphic>](ch6_22.gif)`
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(char->integer *char*)`'
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the Unicode scalar value of `*char*` as an exact integer'
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
- en: '`(char->integer #\newline) ![<graphic>](ch6_0.gif) 10'
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
- en: (char->integer #\space) ![<graphic>](ch6_0.gif) 32
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
- en: (- (char->integer #\Z) (char->integer #\A)) ![<graphic>](ch6_0.gif) 25`
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(integer->char *n*)`'
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the character corresponding to the Unicode scalar value `*n*`'
  id: totrans-2085
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact integer and a valid Unicode scalar value, i.e., ![<graphic>](ch6_23.gif)
    or ![<graphic>](ch6_24.gif).'
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
- en: '`(integer->char 48) ![<graphic>](ch6_0.gif) #\0'
  id: totrans-2088
  prefs: []
  type: TYPE_NORMAL
- en: (integer->char #x3BB) ![<graphic>](ch6_0.gif) #\![<graphic>](ch6_25.gif)`
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.8\. Strings
  id: totrans-2090
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Strings are sequences of characters and are often used as messages, character
    buffers, or containers for blocks of text. Scheme provides operations for creating
    strings, extracting characters from strings, obtaining substrings, concatenating
    strings, and altering the contents of strings.
  id: totrans-2091
  prefs: []
  type: TYPE_NORMAL
- en: A string is written as a sequence of characters enclosed in double quotes, e.g.,
    `"hi there"`. A double quote may be introduced into a string by preceding it by
    a backward slash, e.g., `"two \"quotes\" within"`. A backward slash may also be
    included by preceding it with a backward slash, e.g., `"a \\slash"`. Various special
    characters can be inserted with other two-character sequences, e.g., `\n` for
    newline, `\r` for carriage return, and `\t` for tab. Any Unicode character may
    be inserted with the syntax `#\x*n*;`, where `*n*` consists of one or more hexadecimal
    digits and represents a valid Unicode scalar value. A grammar defining the precise
    syntax of strings is given on page [458](grammar.html#grammar:strings).
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
- en: Strings are indexed by exact nonnegative integers, and the index of the first
    element of any string is 0. The highest valid index for a given string is one
    less than its length.
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string=? *string[1]* *string[2]* *string[3]* ...)`'
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string<? *string[1]* *string[2]* *string[3]* ...)`'
  id: totrans-2095
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string>? *string[1]* *string[2]* *string[3]* ...)`'
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string<=? *string[1]* *string[2]* *string[3]* ...)`'
  id: totrans-2097
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string>=? *string[1]* *string[2]* *string[3]* ...)`'
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the relation holds, `#f` otherwise'
  id: totrans-2099
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
- en: As with `=`, `<`, `>`, `<=`, and `>=`, these predicates express relationships
    among all of the arguments. For example, `string>?` determines if the lexicographic
    ordering of its arguments is monotonically decreasing.
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
- en: The comparisons are based on the character predicates `char=?` and `char<?`.
    Two strings are lexicographically equivalent if they are the same length and consist
    of the same sequence of characters according to `char=?`. If two strings differ
    only in length, the shorter string is considered to be lexicographically less
    than the longer string. Otherwise, the first character position at which the strings
    differ (by `char=?`) determines which string is lexicographically less than the
    other, according to `char<?`.
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
- en: Two-argument `string=?` may be defined without error checks as follows.
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
- en: '`(define string=?'
  id: totrans-2104
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s1 s2)
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
- en: (let ([n (string-length s1)])
  id: totrans-2106
  prefs: []
  type: TYPE_NORMAL
- en: (and (= (string-length s2) n)
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
- en: (let loop ([i 0])
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
- en: (or (= i n)
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
- en: (and (char=? (string-ref s1 i) (string-ref s2 i))
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
- en: (loop (+ i 1)))))))))`
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
- en: Two-argument `string<?` may be defined without error checks as follows.
  id: totrans-2112
  prefs: []
  type: TYPE_NORMAL
- en: '`(define string<?'
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s1 s2)
  id: totrans-2114
  prefs: []
  type: TYPE_NORMAL
- en: (let ([n1 (string-length s1)] [n2 (string-length s2)])
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
- en: (let loop ([i 0])
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
- en: (and (not (= i n2))
  id: totrans-2117
  prefs: []
  type: TYPE_NORMAL
- en: (or (= i n1)
  id: totrans-2118
  prefs: []
  type: TYPE_NORMAL
- en: (let ([c1 (string-ref s1 i)] [c2 (string-ref s2 i)])
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
- en: (or (char<? c1 c2)
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
- en: (and (char=? c1 c2)
  id: totrans-2121
  prefs: []
  type: TYPE_NORMAL
- en: (loop (+ i 1)))))))))))`
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
- en: These definitions may be extended straightforwardly to support three or more
    arguments. `string<=?`, `string>?`, and `string>=?` may be defined similarly.
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
- en: '`(string=? "mom" "mom") ![<graphic>](ch6_0.gif) #t'
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
- en: (string<? "mom" "mommy") ![<graphic>](ch6_0.gif) #t
  id: totrans-2125
  prefs: []
  type: TYPE_NORMAL
- en: (string>? "Dad" "Dad") ![<graphic>](ch6_0.gif) #f
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
- en: (string=? "Mom and Dad" "mom and dad") ![<graphic>](ch6_0.gif) #f
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
- en: (string<? "a" "b" "c") ![<graphic>](ch6_0.gif) #t`
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-ci=? *string[1]* *string[2]* *string[3]* ...)`'
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-ci<? *string[1]* *string[2]* *string[3]* ...)`'
  id: totrans-2130
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-ci>? *string[1]* *string[2]* *string[3]* ...)`'
  id: totrans-2131
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-ci<=? *string[1]* *string[2]* *string[3]* ...)`'
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-ci>=? *string[1]* *string[2]* *string[3]* ...)`'
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the relation holds, `#f` otherwise'
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  id: totrans-2135
  prefs: []
  type: TYPE_NORMAL
- en: These predicates are identical to `string=?`, `string<?`, `string>?`, `string<=?`,
    and `string>=?` except that they are case-sensitive, i.e., compare the case-folded
    versions of their arguments.
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
- en: '`(string-ci=? "Mom and Dad" "mom and dad") ![<graphic>](ch6_0.gif) #t'
  id: totrans-2137
  prefs: []
  type: TYPE_NORMAL
- en: (string-ci<=? "say what" "Say What!?") ![<graphic>](ch6_0.gif) #t
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
- en: (string-ci>? "N" "m" "L" "k") ![<graphic>](ch6_0.gif) #t
  id: totrans-2139
  prefs: []
  type: TYPE_NORMAL
- en: (string-ci=? "Stra\sse" "Strasse") ![<graphic>](ch6_0.gif) #t`
  id: totrans-2140
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string *char* ...)`'
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a string containing the characters `*char* ...`'
  id: totrans-2142
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2143
  prefs: []
  type: TYPE_NORMAL
- en: '`(string) ![<graphic>](ch6_0.gif) ""'
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
- en: (string #\a #\b #\c) ![<graphic>](ch6_0.gif) "abc"
  id: totrans-2145
  prefs: []
  type: TYPE_NORMAL
- en: (string #\H #\E #\Y #\!) ![<graphic>](ch6_0.gif) "HEY!"`
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-string *n*)`'
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-string *n* *char*)`'
  id: totrans-2148
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a string of length `*n*`'
  id: totrans-2149
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer. If `*char*` is supplied, the string
    is filled with `*n*` occurrences of `*char*`, otherwise the characters contained
    in the string are unspecified.'
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
- en: '`(make-string 0) ![<graphic>](ch6_0.gif) ""'
  id: totrans-2152
  prefs: []
  type: TYPE_NORMAL
- en: (make-string 0 #\x) ![<graphic>](ch6_0.gif) ""
  id: totrans-2153
  prefs: []
  type: TYPE_NORMAL
- en: (make-string 5 #\x) ![<graphic>](ch6_0.gif) "xxxxx"`
  id: totrans-2154
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-length *string*)`'
  id: totrans-2155
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the number of characters in `*string*`'
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
- en: The length of a string is always an exact nonnegative integer.
  id: totrans-2158
  prefs: []
  type: TYPE_NORMAL
- en: '`(string-length "abc") ![<graphic>](ch6_0.gif) 3'
  id: totrans-2159
  prefs: []
  type: TYPE_NORMAL
- en: (string-length "") ![<graphic>](ch6_0.gif) 0
  id: totrans-2160
  prefs: []
  type: TYPE_NORMAL
- en: (string-length "hi there") ![<graphic>](ch6_0.gif) 8
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
- en: (string-length (make-string 1000000)) ![<graphic>](ch6_0.gif) 1000000`
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-ref *string* *n*)`'
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the `*n*`th character (zero-based) of `*string*`'
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than the length of `*string*`.'
  id: totrans-2166
  prefs: []
  type: TYPE_NORMAL
- en: '`(string-ref "hi there" 0) ![<graphic>](ch6_0.gif) #\h'
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
- en: (string-ref "hi there" 5) ![<graphic>](ch6_0.gif) #\e`
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-set! *string* *n* *char*)`'
  id: totrans-2169
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs mutable-strings)`'
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than the length of `*string*`.
    `string-set!` changes the `*n*`th element of `*string*` to `*char*`.'
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([str (string-copy "hi three")])'
  id: totrans-2173
  prefs: []
  type: TYPE_NORMAL
- en: (string-set! str 5 #\e)
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
- en: (string-set! str 6 #\r)
  id: totrans-2175
  prefs: []
  type: TYPE_NORMAL
- en: str) ![<graphic>](ch6_0.gif) "hi there"`
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-copy *string*)`'
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new copy of `*string*`'
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2179
  prefs: []
  type: TYPE_NORMAL
- en: This procedure creates a new string with the same length and contents as `*string*`.
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
- en: '`(string-copy "abc") ![<graphic>](ch6_0.gif) "abc"'
  id: totrans-2181
  prefs: []
  type: TYPE_NORMAL
- en: (let ([str "abc"])
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
- en: (eq? str (string-copy str))) ![<graphic>](ch6_0.gif) #f`
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-append *string* ...)`'
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new string formed by concatenating the strings `*string* ...`'
  id: totrans-2185
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
- en: '`(string-append) ![<graphic>](ch6_0.gif) ""'
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
- en: (string-append "abc" "def") ![<graphic>](ch6_0.gif) "abcdef"
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
- en: (string-append "Hey " "you " "there!") ![<graphic>](ch6_0.gif) "Hey you there!"`
  id: totrans-2189
  prefs: []
  type: TYPE_NORMAL
- en: The following implementation of `string-append` recurs down the list of strings
    to compute the total length, then allocates the new string, then fills it up as
    it unwinds the recursion.
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
- en: '`(define string-append'
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
- en: (lambda args
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([ls args] [n 0])
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
- en: (make-string n)
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
- en: (let* ([s1 (car ls)]
  id: totrans-2196
  prefs: []
  type: TYPE_NORMAL
- en: '[m (string-length s1)]'
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
- en: '[s2 (f (cdr ls) (+ n m))])'
  id: totrans-2198
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i 0 (+ i 1)] [j n (+ j 1)])
  id: totrans-2199
  prefs: []
  type: TYPE_NORMAL
- en: ((= i m) s2)
  id: totrans-2200
  prefs: []
  type: TYPE_NORMAL
- en: (string-set! s2 j (string-ref s1 i))))))))`
  id: totrans-2201
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(substring *string* *start* *end*)`'
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a copy of `*string*` from `*start*` (inclusive) to `*end*` (exclusive)'
  id: totrans-2203
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
- en: '`*start*` and `*end*` must be exact nonnegative integers; `*start*` must be
    less than the length of `*string*`, while `*end*` may be less than or equal to
    the length of `*string*`. If `*end*` ≤ `*start*`, a string of length zero is returned.
    `substring` may be defined without error checks as follows.'
  id: totrans-2205
  prefs: []
  type: TYPE_NORMAL
- en: '`(define substring'
  id: totrans-2206
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s1 m n)
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
- en: (let ([s2 (make-string (- n m))])
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
- en: (do ([j 0 (+ j 1)] [i m (+ i 1)])
  id: totrans-2209
  prefs: []
  type: TYPE_NORMAL
- en: ((= i n) s2)
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
- en: (string-set! s2 j (string-ref s1 i))))))
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
- en: (substring "hi there" 0 1) ![<graphic>](ch6_0.gif) "h"
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
- en: (substring "hi there" 3 6) ![<graphic>](ch6_0.gif) "the"
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
- en: (substring "hi there" 5 5) ![<graphic>](ch6_0.gif) ""
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
- en: (let ([str "hi there"])
  id: totrans-2215
  prefs: []
  type: TYPE_NORMAL
- en: (let ([end (string-length str)])
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
- en: (substring str 0 end))) ![<graphic>](ch6_0.gif) "hi there"`
  id: totrans-2217
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-fill! *string* *char*)`'
  id: totrans-2218
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs mutable-strings)`'
  id: totrans-2220
  prefs: []
  type: TYPE_NORMAL
- en: '`string-fill!` sets every character in `*string*` to `*char*`.'
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([str (string-copy "sleepy")])'
  id: totrans-2222
  prefs: []
  type: TYPE_NORMAL
- en: (string-fill! str #\Z)
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
- en: str) ![<graphic>](ch6_0.gif) "ZZZZZZ"`
  id: totrans-2224
  prefs: []
  type: TYPE_NORMAL
- en: '`string-fill!` might be defined as follows:'
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
- en: '`(define string-fill!'
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s c)
  id: totrans-2227
  prefs: []
  type: TYPE_NORMAL
- en: (let ([n (string-length s)])
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i 0 (+ i 1)])
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
- en: ((= i n))
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
- en: (string-set! s i c)))))`
  id: totrans-2231
  prefs: []
  type: TYPE_NORMAL
- en: An alternative definition is given on page [276](io.html#backdoor-string-fill).
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-upcase *string*)`'
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the upper-case equivalent of `*string*`'
  id: totrans-2234
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-downcase *string*)`'
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the lower-case equivalent of `*string*`'
  id: totrans-2236
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-foldcase *string*)`'
  id: totrans-2237
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the case-folded equivalent of `*string*`'
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-titlecase *string*)`'
  id: totrans-2239
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the title-case equivalent of `*string*`'
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  id: totrans-2241
  prefs: []
  type: TYPE_NORMAL
- en: These procedures implement Unicode's locale-independent case mappings from scalar-value
    sequences to scalar-value sequences. These mappings do not always map single characters
    to single characters, so the length of the result string may differ from the length
    of `*string*`. If the result string is the same as `*string*` (by `string=?`),
    `*string*` or a copy of `*string*` may be returned. Otherwise, the result string
    is newly allocated. `string-foldcase` does not use the special mappings for Turkic
    languages.
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
- en: '`string-titlecase` converts the first cased character of each word in `*string*`
    to its title-case counterpart and converts each other character to its lower-case
    counterpart. Word breaks are recognized as specified in Unicode Standard Annex #29 [[8](bibliography.html#g226)].'
  id: totrans-2243
  prefs: []
  type: TYPE_NORMAL
- en: '`(string-upcase "Hi") ![<graphic>](ch6_0.gif) "HI"'
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
- en: (string-downcase "Hi") ![<graphic>](ch6_0.gif) "hi"
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
- en: (string-foldcase "Hi") ![<graphic>](ch6_0.gif) "hi"
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
- en: (string-upcase "Straße") ![<graphic>](ch6_0.gif) "STRASSE"
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
- en: (string-downcase "Straße") ![<graphic>](ch6_0.gif) "straße"
  id: totrans-2248
  prefs: []
  type: TYPE_NORMAL
- en: (string-foldcase "Straße") ![<graphic>](ch6_0.gif) "strasse"
  id: totrans-2249
  prefs: []
  type: TYPE_NORMAL
- en: (string-downcase "STRASSE")  ![<graphic>](ch6_0.gif) "strasse"
  id: totrans-2250
  prefs: []
  type: TYPE_NORMAL
- en: (string-downcase "![<graphic>](ch6_21.gif)") ![<graphic>](ch6_0.gif) "![<graphic>](ch6_22.gif)"
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
- en: (string-titlecase "kNock KNoCK") ![<graphic>](ch6_0.gif) "Knock Knock"
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
- en: (string-titlecase "who's there?") ![<graphic>](ch6_0.gif) "Who's There?"
  id: totrans-2253
  prefs: []
  type: TYPE_NORMAL
- en: (string-titlecase "r6rs") ![<graphic>](ch6_0.gif) "R6rs"
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
- en: (string-titlecase "R6RS") ![<graphic>](ch6_0.gif) "R6rs"`
  id: totrans-2255
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-normalize-nfd *string*)`'
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the Unicode normalized form D of `*string*`'
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-normalize-nfkd *string*)`'
  id: totrans-2258
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the Unicode normalized form KD of `*string*`'
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-normalize-nfc *string*)`'
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the Unicode normalized form C of `*string*`'
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-normalize-nfkc *string*)`'
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the Unicode normalized form KC of `*string*`'
  id: totrans-2263
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs unicode)`, `(rnrs)`'
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
- en: If the result string is the same as `*string*` (by `string=?`), `*string*` or
    a copy of `*string*` may be returned. Otherwise, the result string is newly allocated.
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
- en: '`(string-normalize-nfd "\xE9;") ![<graphic>](ch6_0.gif) "e\x301;"'
  id: totrans-2266
  prefs: []
  type: TYPE_NORMAL
- en: (string-normalize-nfc "\xE9;") ![<graphic>](ch6_0.gif) "\xE9;"
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
- en: (string-normalize-nfd "\x65;\x301;") ![<graphic>](ch6_0.gif) "e\x301;"
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
- en: (string-normalize-nfc "\x65;\x301;") ![<graphic>](ch6_0.gif) "\xE9;"`
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string->list *string*)`'
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a list of the characters in `*string*`'
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2272
  prefs: []
  type: TYPE_NORMAL
- en: '`string->list` allows a string to be converted into a list, so that Scheme''s
    list-processing operations may be applied to the processing of strings. `string->list`
    may be defined without error checks as follows.'
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
- en: '`(define string->list'
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s)
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i (- (string-length s) 1) (- i 1)]
  id: totrans-2276
  prefs: []
  type: TYPE_NORMAL
- en: '[ls ''() (cons (string-ref s i) ls)])'
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
- en: ((< i 0) ls))))
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
- en: (string->list "") ![<graphic>](ch6_0.gif) ()
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
- en: (string->list "abc") ![<graphic>](ch6_0.gif) (#\a #\b #\c)
  id: totrans-2280
  prefs: []
  type: TYPE_NORMAL
- en: (apply char<? (string->list "abc")) ![<graphic>](ch6_0.gif) #t
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
- en: (map char-upcase (string->list "abc")) ![<graphic>](ch6_0.gif) (#\A #\B #\C)`
  id: totrans-2282
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(list->string *list*)`'
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a string of the characters in `*list*`'
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
- en: '`*list*` must consist entirely of characters.'
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
- en: '`list->string` is the functional inverse of `string->list`. A program might
    use both procedures together, first converting a string into a list, then operating
    on this list to produce a new list, and finally converting the new list back into
    a string.'
  id: totrans-2287
  prefs: []
  type: TYPE_NORMAL
- en: '`list->string` may be defined without error checks as follows.'
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
- en: '`(define list->string'
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
- en: (let ([s (make-string (length ls))])
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
- en: (do ([ls ls (cdr ls)] [i 0 (+ i 1)])
  id: totrans-2292
  prefs: []
  type: TYPE_NORMAL
- en: ((null? ls) s)
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
- en: (string-set! s i (car ls))))))
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
- en: (list->string '()) ![<graphic>](ch6_0.gif) ""
  id: totrans-2295
  prefs: []
  type: TYPE_NORMAL
- en: (list->string '(#\a #\b #\c)) ![<graphic>](ch6_0.gif) "abc"
  id: totrans-2296
  prefs: []
  type: TYPE_NORMAL
- en: (list->string
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
- en: (map char-upcase
  id: totrans-2298
  prefs: []
  type: TYPE_NORMAL
- en: (string->list "abc"))) ![<graphic>](ch6_0.gif) "ABC"`
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.9\. Vectors
  id: totrans-2300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vectors are more convenient and efficient than lists for some applications.
    Whereas accessing an arbitrary element in a list requires a linear traversal of
    the list up to the selected element, arbitrary vector elements are accessed in
    constant time. The *length* of a vector is the number of elements it contains.
    Vectors are indexed by exact nonnegative integers, and the index of the first
    element of any vector is 0. The highest valid index for a given vector is one
    less than its length.
  id: totrans-2301
  prefs: []
  type: TYPE_NORMAL
- en: As with lists, the elements of a vector can be of any type, and a single vector
    can hold more than one type of object.
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
- en: A vector is written as a sequence of objects separated by whitespace, preceded
    by the prefix `#(` and followed by `)`. For example, a vector consisting of the
    elements `a`, `b`, and `c` would be written `#(a b c)`.
  id: totrans-2303
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector *obj* ...)`'
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a vector of the objects `*obj* ...`'
  id: totrans-2305
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
- en: '`(vector) ![<graphic>](ch6_0.gif) #()'
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
- en: (vector 'a 'b 'c) ![<graphic>](ch6_0.gif) #(a b c)`
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-vector *n*)`'
  id: totrans-2309
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-vector *n* *obj*)`'
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a vector of length `*n*`'
  id: totrans-2311
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer. If `*obj*` is supplied, each element
    of the vector is filled with `*obj*`; otherwise, the elements are unspecified.'
  id: totrans-2313
  prefs: []
  type: TYPE_NORMAL
- en: '`(make-vector 0) ![<graphic>](ch6_0.gif) #()'
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
- en: (make-vector 0 '#(a)) ![<graphic>](ch6_0.gif) #()
  id: totrans-2315
  prefs: []
  type: TYPE_NORMAL
- en: (make-vector 5 '#(a)) ![<graphic>](ch6_0.gif) #(#(a) #(a) #(a) #(a) #(a))`
  id: totrans-2316
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector-length *vector*)`'
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the number of elements in `*vector*`'
  id: totrans-2318
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
- en: The length of a vector is always an exact nonnegative integer.
  id: totrans-2320
  prefs: []
  type: TYPE_NORMAL
- en: '`(vector-length ''#()) ![<graphic>](ch6_0.gif) 0'
  id: totrans-2321
  prefs: []
  type: TYPE_NORMAL
- en: (vector-length '#(a b c)) ![<graphic>](ch6_0.gif) 3
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
- en: (vector-length (vector 1 '(2) 3 '#(4 5))) ![<graphic>](ch6_0.gif) 4
  id: totrans-2323
  prefs: []
  type: TYPE_NORMAL
- en: (vector-length (make-vector 300)) ![<graphic>](ch6_0.gif) 300`
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector-ref *vector* *n*)`'
  id: totrans-2325
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the `*n*`th element (zero-based) of `*vector*`'
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than the length of `*vector*`.'
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
- en: '`(vector-ref ''#(a b c) 0) ![<graphic>](ch6_0.gif) a'
  id: totrans-2329
  prefs: []
  type: TYPE_NORMAL
- en: (vector-ref '#(a b c) 1) ![<graphic>](ch6_0.gif) b
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
- en: (vector-ref '#(x y z w) 3) ![<graphic>](ch6_0.gif) w`
  id: totrans-2331
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector-set! *vector* *n* *obj*)`'
  id: totrans-2332
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2333
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than the length of `*vector*`.
    `vector-set!` changes the `*n*`th element of `*vector*` to `*obj*`.'
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([v (vector ''a ''b ''c ''d ''e)])'
  id: totrans-2336
  prefs: []
  type: TYPE_NORMAL
- en: (vector-set! v 2 'x)
  id: totrans-2337
  prefs: []
  type: TYPE_NORMAL
- en: v) ![<graphic>](ch6_0.gif) #(a b x d e)`
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector-fill! *vector* *obj*)`'
  id: totrans-2339
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2340
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
- en: '`vector-fill!` replaces each element of `*vector*` with `*obj*`. It may be
    defined without error checks as follows.'
  id: totrans-2342
  prefs: []
  type: TYPE_NORMAL
- en: '`(define vector-fill!'
  id: totrans-2343
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (v x)
  id: totrans-2344
  prefs: []
  type: TYPE_NORMAL
- en: (let ([n (vector-length v)])
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i 0 (+ i 1)])
  id: totrans-2346
  prefs: []
  type: TYPE_NORMAL
- en: ((= i n))
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
- en: (vector-set! v i x)))))
  id: totrans-2348
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v (vector 1 2 3)])
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
- en: (vector-fill! v 0)
  id: totrans-2350
  prefs: []
  type: TYPE_NORMAL
- en: v) ![<graphic>](ch6_0.gif) #(0 0 0)`
  id: totrans-2351
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector->list *vector*)`'
  id: totrans-2352
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a list of the elements of `*vector*`'
  id: totrans-2353
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
- en: '`vector->list` provides a convenient method for applying list-processing operations
    to vectors. It may be defined without error checks as follows.'
  id: totrans-2355
  prefs: []
  type: TYPE_NORMAL
- en: '`(define vector->list'
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s)
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i (- (vector-length s) 1) (- i 1)]
  id: totrans-2358
  prefs: []
  type: TYPE_NORMAL
- en: '[ls ''() (cons (vector-ref s i) ls)])'
  id: totrans-2359
  prefs: []
  type: TYPE_NORMAL
- en: ((< i 0) ls))))
  id: totrans-2360
  prefs: []
  type: TYPE_NORMAL
- en: (vector->list (vector)) ![<graphic>](ch6_0.gif) ()
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
- en: (vector->list '#(a b c)) ![<graphic>](ch6_0.gif) (a b c)
  id: totrans-2362
  prefs: []
  type: TYPE_NORMAL
- en: (let ((v '#(1 2 3 4 5)))
  id: totrans-2363
  prefs: []
  type: TYPE_NORMAL
- en: (apply * (vector->list v))) ![<graphic>](ch6_0.gif) 120`
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(list->vector *list*)`'
  id: totrans-2365
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a vector of the elements of `*list*`'
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2367
  prefs: []
  type: TYPE_NORMAL
- en: '`list->vector` is the functional inverse of `vector->list`. The two procedures
    are often used in combination to take advantage of a list-processing operation.
    A vector may be converted to a list with `vector->list`, this list processed in
    some manner to produce a new list, and the new list converted back into a vector
    with `list->vector`.'
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
- en: '`list->vector` may be defined without error checks as follows.'
  id: totrans-2369
  prefs: []
  type: TYPE_NORMAL
- en: '`(define list->vector'
  id: totrans-2370
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  id: totrans-2371
  prefs: []
  type: TYPE_NORMAL
- en: (let ([s (make-vector (length ls))])
  id: totrans-2372
  prefs: []
  type: TYPE_NORMAL
- en: (do ([ls ls (cdr ls)] [i 0 (+ i 1)])
  id: totrans-2373
  prefs: []
  type: TYPE_NORMAL
- en: ((null? ls) s)
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
- en: (vector-set! s i (car ls))))))
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
- en: (list->vector '()) ![<graphic>](ch6_0.gif) #()
  id: totrans-2376
  prefs: []
  type: TYPE_NORMAL
- en: (list->vector '(a b c)) ![<graphic>](ch6_0.gif) #(a b c)
  id: totrans-2377
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v '#(1 2 3 4 5)])
  id: totrans-2378
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls (vector->list v)])
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
- en: (list->vector (map * ls ls)))) ![<graphic>](ch6_0.gif) #(1 4 9 16 25)`
  id: totrans-2380
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector-sort *predicate* *vector*)`'
  id: totrans-2381
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a vector containing the elements of `*vector*`, sorted according
    to `*predicate*`'
  id: totrans-2382
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector-sort! *predicate* *vector*)`'
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2384
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs sorting)`, `(rnrs)`'
  id: totrans-2385
  prefs: []
  type: TYPE_NORMAL
- en: '`*predicate*` should be a procedure that expects two arguments and returns
    `#t` if its first argument must precede its second in the sorted vector. That
    is, if `*predicate*` is applied to two elements `*x*` and `*y*`, where `*x*` appears
    after `*y*` in the input vector, the predicate should return true only if `*x*`
    should appear before `*y*` in the output vector. If this constraint is met, `vector-sort`
    performs a stable sort, i.e., two elements are reordered only when necessary according
    to `*predicate*`. `vector-sort!` performs the sort destructively and does not
    necessarily perform a stable sort. Duplicate elements are not removed. `*predicate*`
    should not have any side effects.'
  id: totrans-2386
  prefs: []
  type: TYPE_NORMAL
- en: '`vector-sort` may call `*predicate*` up to *n*log*n* times, where *n* is the
    length of `*vector*`, while `vector-sort!` may call the predicate up to *n*² times.
    The looser bound for `vector-sort!` allows an implementation to use a quicksort
    algorithm, which may be faster in some cases than algorithms that have the tighter
    *n*log*n* bound.'
  id: totrans-2387
  prefs: []
  type: TYPE_NORMAL
- en: '`(vector-sort < ''#(3 4 2 1 2 5)) ![<graphic>](ch6_0.gif) #(1 2 2 3 4 5)'
  id: totrans-2388
  prefs: []
  type: TYPE_NORMAL
- en: (vector-sort > '#(0.5 1/2)) ![<graphic>](ch6_0.gif) #(0.5 1/2)
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
- en: (vector-sort > '#(1/2 0.5)) ![<graphic>](ch6_0.gif) #(1/2 0.5)
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v (vector 3 4 2 1 2 5)])
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
- en: (vector-sort! < v)
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
- en: v) ![<graphic>](ch6_0.gif) #(1 2 2 3 4 5)`
  id: totrans-2393
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.10\. Bytevectors
  id: totrans-2394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bytevectors are vectors of raw binary data. Although nominally organized as
    a sequence of exact unsigned 8-bit integers, a bytevector can be interpreted as
    a sequence of exact signed 8-bit integers, exact signed or unsigned 16-bit, 32-bit,
    64-bit, or arbitrary-precision integers, IEEE single or double floating-point
    numbers, or arbitrary combinations of the above.
  id: totrans-2395
  prefs: []
  type: TYPE_NORMAL
- en: The length of a bytevector is the number of 8-bit bytes it stores, and indices
    into a bytevector are always given as byte offsets. Any data element may be aligned
    at any byte offset, regardless of the underlying hardware's alignment requirements,
    and may be represented using a specified endianness (see below) that differs from
    that prescribed by the hardware. Special, typically more efficient operators are
    provided for 16-, 32-, and 64-bit integers and single and double floats that are
    in their *native* format, i.e,. with the endianness of the underlying hardware
    and stored at an index that is a multiple of the size in bytes of the integer
    or float.
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
- en: The endianness of a multi-byte data value determines how it is laid out in memory.
    In *big-endian* format, the value is laid out with the more significant bytes
    at lower indices, while in *little-endian* format, the value is laid out with
    the more significant bytes at higher indices. When a bytevector procedure accepts
    an endianness argument, the argument may be the symbol `big`, representing the
    big-endian format, or the symbol `little`, representing the little-endian format.
    Implementations may extend these procedures to accept other endianness symbols.
    The native endianness of the implementation may be obtained via the procedure
    `native-endianness`.
  id: totrans-2397
  prefs: []
  type: TYPE_NORMAL
- en: Bytevectors are written with the `#vu8(` prefix in place of the `#(` prefix
    for vectors, e.g., `#vu8(1 2 3)`. The elements of a bytevector specified in this
    manner are always given as 8-bit unsigned exact integers, i.e., integers from
    0 to 255 inclusive, written using any valid syntax for such numbers. Like strings,
    bytevectors are self-evaluating, so they need not be quoted.
  id: totrans-2398
  prefs: []
  type: TYPE_NORMAL
- en: '`''#vu8(1 2 3) ![<graphic>](ch6_0.gif) #vu8(1 2 3)'
  id: totrans-2399
  prefs: []
  type: TYPE_NORMAL
- en: '#vu8(1 2 3) ![<graphic>](ch6_0.gif) #vu8(1 2 3)'
  id: totrans-2400
  prefs: []
  type: TYPE_NORMAL
- en: '#vu8(#x3f #x7f #xbf #xff) ![<graphic>](ch6_0.gif) #vu8(63 127 191 255)`'
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(endianness *symbol*)`'
  id: totrans-2402
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*symbol*`'
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2404
  prefs: []
  type: TYPE_NORMAL
- en: '`*symbol*` must be the symbol `little`, the symbol `big`, or some other symbol
    recognized by the implementation as an endianness symbol. It is a syntax violation
    if `*symbol*` is not a symbol or if it is not recognized by the implementation
    as an endianness symbol.'
  id: totrans-2405
  prefs: []
  type: TYPE_NORMAL
- en: '`(endianness little) ![<graphic>](ch6_0.gif) little'
  id: totrans-2406
  prefs: []
  type: TYPE_NORMAL
- en: (endianness big) ![<graphic>](ch6_0.gif) big
  id: totrans-2407
  prefs: []
  type: TYPE_NORMAL
- en: (endianness "spam") ![<graphic>](ch6_0.gif) *exception*`
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(native-endianness)`'
  id: totrans-2409
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a symbol naming the implementation''s native endianness'
  id: totrans-2410
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2411
  prefs: []
  type: TYPE_NORMAL
- en: The return value is the symbol `little`, the symbol `big`, or some other endianness
    symbol recognized by the implementation. It typically reflects the endianness
    of the underlying hardware.
  id: totrans-2412
  prefs: []
  type: TYPE_NORMAL
- en: '`(symbol? (native-endianness)) ![<graphic>](ch6_0.gif) #t`'
  id: totrans-2413
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-bytevector *n*)`'
  id: totrans-2414
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-bytevector *n* *fill*)`'
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new bytevector of length `*n*`'
  id: totrans-2416
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2417
  prefs: []
  type: TYPE_NORMAL
- en: If `*fill*` is supplied, each element of the bytevector is initialized to `*fill*`;
    otherwise, the elements are unspecified. The `*fill*` value must be a signed or
    unsigned 8-bit value, i.e., a value in the range -128 to 255 inclusive. A negative
    fill value is treated as its two's complement equivalent.
  id: totrans-2418
  prefs: []
  type: TYPE_NORMAL
- en: '`(make-bytevector 0) ![<graphic>](ch6_0.gif) #vu8()'
  id: totrans-2419
  prefs: []
  type: TYPE_NORMAL
- en: (make-bytevector 0 7) ![<graphic>](ch6_0.gif) #vu8()
  id: totrans-2420
  prefs: []
  type: TYPE_NORMAL
- en: (make-bytevector 5 7) ![<graphic>](ch6_0.gif) #vu8(7 7 7 7 7)
  id: totrans-2421
  prefs: []
  type: TYPE_NORMAL
- en: (make-bytevector 5 -7) ![<graphic>](ch6_0.gif) #vu8(249 249 249 249 249)`
  id: totrans-2422
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-length *bytevector*)`'
  id: totrans-2423
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the length of `*bytevector*` in 8-bit bytes'
  id: totrans-2424
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2425
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector-length #vu8()) ![<graphic>](ch6_0.gif) 0'
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-length #vu8(1 2 3)) ![<graphic>](ch6_0.gif) 3
  id: totrans-2427
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-length (make-bytevector 300)) ![<graphic>](ch6_0.gif) 300`
  id: totrans-2428
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector=? *bytevector[1]* *bytevector[2]*)`'
  id: totrans-2429
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the relation holds, `#f` otherwise'
  id: totrans-2430
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2431
  prefs: []
  type: TYPE_NORMAL
- en: Two bytevectors are equal by `bytevector=?` if and only if they have the same
    length and same contents.
  id: totrans-2432
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector=? #vu8() #vu8()) ![<graphic>](ch6_0.gif) #t'
  id: totrans-2433
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector=? (make-bytevector 3 0) #vu8(0 0 0)) ![<graphic>](ch6_0.gif) #t
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector=? (make-bytevector 5 0) #vu8(0 0 0)) ![<graphic>](ch6_0.gif) #f
  id: totrans-2435
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector=? #vu8(1 127 128 255) #vu8(255 128 127 1)) ![<graphic>](ch6_0.gif) #f`
  id: totrans-2436
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-fill! *bytevector* *fill*)`'
  id: totrans-2437
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2438
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2439
  prefs: []
  type: TYPE_NORMAL
- en: The `*fill*` value must be a signed or unsigned 8-bit value, i.e., a value in
    the range -128 to 255 inclusive. A negative fill value is treated as its two's
    complement equivalent.
  id: totrans-2440
  prefs: []
  type: TYPE_NORMAL
- en: '`bytevector-fill!` replaces each element of `*bytevector*` with `*fill*`.'
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([v (make-bytevector 6)])'
  id: totrans-2442
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-fill! v 255)
  id: totrans-2443
  prefs: []
  type: TYPE_NORMAL
- en: v) ![<graphic>](ch6_0.gif) #vu8(255 255 255 255 255 255)
  id: totrans-2444
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v (make-bytevector 6)])
  id: totrans-2445
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-fill! v -128)
  id: totrans-2446
  prefs: []
  type: TYPE_NORMAL
- en: v) ![<graphic>](ch6_0.gif) #vu8(128 128 128 128 128 128)`
  id: totrans-2447
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-copy *bytevector*)`'
  id: totrans-2448
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new bytevector that is a copy of `*bytevector*`'
  id: totrans-2449
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
- en: '`bytevector-copy` creates a new bytevector with the same length and contents
    as `*bytevector*`.'
  id: totrans-2451
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector-copy #vu8(1 127 128 255)) ![<graphic>](ch6_0.gif) #vu8(1 127 128 255)'
  id: totrans-2452
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v #vu8(1 127 128 255)])
  id: totrans-2453
  prefs: []
  type: TYPE_NORMAL
- en: (eq? v (bytevector-copy v))) ![<graphic>](ch6_0.gif) #f`
  id: totrans-2454
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-copy! *src* *src-start* *dst* *dst-start* *n*)`'
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2456
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2457
  prefs: []
  type: TYPE_NORMAL
- en: '`*src*` and `*dst*` must be bytevectors. `*src-start*`, `*dst-start*`, and
    `*n*` must be exact nonnegative integers. The sum of `*src-start*` and `*n*` must
    not exceed the length of `*src*`, and the sum of `*dst-start*` and `*n*` must
    not exceed the length of `*dst*`.'
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
- en: '`bytevector-copy!` overwrites the `*n*` bytes of `*dst*` starting at `*dst-start*`
    with the `*n*` bytes of `*dst*` starting at `*src-start*`. This works even if
    `*dst*` is the same bytevector as `*src*` and the source and destination locations
    overlap. That is, the destination is filled with the bytes that appeared at the
    source before the operation began.'
  id: totrans-2459
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v1 #vu8(31 63 95 127 159 191 223 255))'
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
- en: (define v2 (make-bytevector 10 0))
  id: totrans-2461
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-copy! v1 2 v2 1 4)
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
- en: v2 ![<graphic>](ch6_0.gif) #vu8(0 95 127 159 191 0 0 0 0 0)
  id: totrans-2463
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-copy! v1 5 v2 7 3)
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
- en: v2 ![<graphic>](ch6_0.gif) #vu8(0 95 127 159 191 0 0 191 223 255)
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-copy! v2 3 v2 0 6)
  id: totrans-2466
  prefs: []
  type: TYPE_NORMAL
- en: v2 ![<graphic>](ch6_0.gif) #vu8(159 191 0 0 191 223 0 191 223 255)
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-copy! v2 0 v2 1 9)
  id: totrans-2468
  prefs: []
  type: TYPE_NORMAL
- en: v2 ![<graphic>](ch6_0.gif) #vu8(159 159 191 0 0 191 223 0 191 223)`
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u8-ref *bytevector* *n*)`'
  id: totrans-2470
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 8-bit unsigned byte at index `*n*` (zero-based) of `*bytevector*`'
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than the length of `*bytevector*`.'
  id: totrans-2473
  prefs: []
  type: TYPE_NORMAL
- en: The value is returned as an exact 8-bit unsigned integer, i.e., a value in the
    range 0 to 255 inclusive.
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector-u8-ref #vu8(1 127 128 255) 0) ![<graphic>](ch6_0.gif) 1'
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u8-ref #vu8(1 127 128 255) 2) ![<graphic>](ch6_0.gif) 128
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u8-ref #vu8(1 127 128 255) 3) ![<graphic>](ch6_0.gif) 255`
  id: totrans-2477
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s8-ref *bytevector* *n*)`'
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 8-bit signed byte at index `*n*` (zero-based) of `*bytevector*`'
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2480
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than the length of `*bytevector*`.'
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
- en: The value returned is an exact 8-bit signed integer, i.e., a value in the range
    -128 to 127 inclusive, and is the equivalent of the stored value treated as a
    two's complement value.
  id: totrans-2482
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector-s8-ref #vu8(1 127 128 255) 0) ![<graphic>](ch6_0.gif) 1'
  id: totrans-2483
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s8-ref #vu8(1 127 128 255) 1) ![<graphic>](ch6_0.gif) 127
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s8-ref #vu8(1 127 128 255) 2) ![<graphic>](ch6_0.gif) -128
  id: totrans-2485
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s8-ref #vu8(1 127 128 255) 3) ![<graphic>](ch6_0.gif) -1`
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u8-set! *bytevector* *n* *u8*)`'
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2488
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2489
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than the length of `*bytevector*`.
    `*u8*` must be an 8-bit unsigned value, i.e., a value in the range 0 to 255 inclusive.'
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
- en: '`bytevector-u8-set!` changes the 8-bit value at index `*n*` (zero-based) of
    `*bytevector*` to `*u8*`.'
  id: totrans-2491
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([v (make-bytevector 5 -1)])'
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u8-set! v 2 128)
  id: totrans-2493
  prefs: []
  type: TYPE_NORMAL
- en: v) ![<graphic>](ch6_0.gif) #vu8(255 255 128 255 255)`
  id: totrans-2494
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s8-set! *bytevector* *n* *s8*)`'
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2496
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2497
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer less than the length of `*bytevector*`.
    `*s8*` must be an 8-bit signed value, i.e., a value in the range -128 to 127 inclusive.'
  id: totrans-2498
  prefs: []
  type: TYPE_NORMAL
- en: '`bytevector-s8-set!` changes the 8-bit value at index `*n*` (zero-based) of
    `*bytevector*` to the two''s complement equivalent of `*s8*`.'
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([v (make-bytevector 4 0)])'
  id: totrans-2500
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s8-set! v 1 100)
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s8-set! v 2 -100)
  id: totrans-2502
  prefs: []
  type: TYPE_NORMAL
- en: v) ![<graphic>](ch6_0.gif) #vu8(0 100 156 0)`
  id: totrans-2503
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector->u8-list *bytevector*)`'
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a list of the 8-bit unsigned elements of `*bytevector*`'
  id: totrans-2505
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector->u8-list (make-bytevector 0)) ![<graphic>](ch6_0.gif) ()'
  id: totrans-2507
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector->u8-list #vu8(1 127 128 255)) ![<graphic>](ch6_0.gif) (1 127 128 255)
  id: totrans-2508
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v #vu8(1 2 3 255)])
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
- en: (apply * (bytevector->u8-list v))) ![<graphic>](ch6_0.gif) 1530`
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(u8-list->bytevector *list*)`'
  id: totrans-2511
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new bytevector of the elements of `*list*`'
  id: totrans-2512
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2513
  prefs: []
  type: TYPE_NORMAL
- en: '`*list*` must consist entirely of exact 8-bit unsigned integers, i.e., values
    in the range 0 to 255 inclusive.'
  id: totrans-2514
  prefs: []
  type: TYPE_NORMAL
- en: '`(u8-list->bytevector ''()) ![<graphic>](ch6_0.gif) #vu8()'
  id: totrans-2515
  prefs: []
  type: TYPE_NORMAL
- en: (u8-list->bytevector '(1 127 128 255)) ![<graphic>](ch6_0.gif) #vu8(1 127 128 255)
  id: totrans-2516
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v #vu8(1 2 3 4 5)])
  id: totrans-2517
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls (bytevector->u8-list v)])
  id: totrans-2518
  prefs: []
  type: TYPE_NORMAL
- en: (u8-list->bytevector (map * ls ls)))) ![<graphic>](ch6_0.gif) #vu8(1 4 9 16 25)`
  id: totrans-2519
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u16-native-ref *bytevector* *n*)`'
  id: totrans-2520
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 16-bit unsigned integer at index `*n*` (zero-based) of `*bytevector*`'
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s16-native-ref *bytevector* *n*)`'
  id: totrans-2522
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 16-bit signed integer at index `*n*` (zero-based) of `*bytevector*`'
  id: totrans-2523
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u32-native-ref *bytevector* *n*)`'
  id: totrans-2524
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 32-bit unsigned integer at index `*n*` (zero-based) of `*bytevector*`'
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s32-native-ref *bytevector* *n*)`'
  id: totrans-2526
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 32-bit signed integer at index `*n*` (zero-based) of `*bytevector*`'
  id: totrans-2527
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u64-native-ref *bytevector* *n*)`'
  id: totrans-2528
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 64-bit unsigned integer at index `*n*` (zero-based) of `*bytevector*`'
  id: totrans-2529
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s64-native-ref *bytevector* *n*)`'
  id: totrans-2530
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 64-bit signed integer at index `*n*` (zero-based) of `*bytevector*`'
  id: totrans-2531
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2532
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer. It indexes the starting byte of
    the value and must be a multiple of the number of bytes occupied by the value:
    2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of
    `*n*` and the number of bytes occupied by the value must not exceed the length
    of `*bytevector*`. The native endianness is assumed.'
  id: totrans-2533
  prefs: []
  type: TYPE_NORMAL
- en: The return value is an exact integer in the appropriate range for the number
    of bytes occupied by the value. Signed values are the equivalent of the stored
    value treated as a two's complement value.
  id: totrans-2534
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98))`'
  id: totrans-2535
  prefs: []
  type: TYPE_NORMAL
- en: 'If native endianness is big:'
  id: totrans-2536
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector-u16-native-ref v 2) ![<graphic>](ch6_0.gif) #xfe56'
  id: totrans-2537
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-native-ref v 2) ![<graphic>](ch6_0.gif) #x-1aa
  id: totrans-2538
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-native-ref v 6) ![<graphic>](ch6_0.gif) #x7898
  id: totrans-2539
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u32-native-ref v 0) ![<graphic>](ch6_0.gif) #x1234fe56
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-native-ref v 0) ![<graphic>](ch6_0.gif) #x1234fe56
  id: totrans-2541
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-native-ref v 4) ![<graphic>](ch6_0.gif) #x-23458768
  id: totrans-2542
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u64-native-ref v 0) ![<graphic>](ch6_0.gif) #x1234fe56dcba7898
  id: totrans-2543
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s64-native-ref v 0) ![<graphic>](ch6_0.gif) #x1234fe56dcba7898`
  id: totrans-2544
  prefs: []
  type: TYPE_NORMAL
- en: 'If native endianness is little:'
  id: totrans-2545
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector-u16-native-ref v 2) ![<graphic>](ch6_0.gif) #x56fe'
  id: totrans-2546
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-native-ref v 2) ![<graphic>](ch6_0.gif) #x56fe
  id: totrans-2547
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-native-ref v 6) ![<graphic>](ch6_0.gif) #x-6788
  id: totrans-2548
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u32-native-ref v 0) ![<graphic>](ch6_0.gif) #x56fe3412
  id: totrans-2549
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-native-ref v 0) ![<graphic>](ch6_0.gif) #x56fe3412
  id: totrans-2550
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-native-ref v 4) ![<graphic>](ch6_0.gif) #x-67874524
  id: totrans-2551
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u64-native-ref v 0) ![<graphic>](ch6_0.gif) #x9878badc56fe3412
  id: totrans-2552
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s64-native-ref v 0) ![<graphic>](ch6_0.gif) #x-67874523a901cbee`
  id: totrans-2553
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u16-native-set! *bytevector* *n* *u16*)`'
  id: totrans-2554
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s16-native-set! *bytevector* *n* *s16*)`'
  id: totrans-2555
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u32-native-set! *bytevector* *n* *u32*)`'
  id: totrans-2556
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s32-native-set! *bytevector* *n* *s32*)`'
  id: totrans-2557
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u64-native-set! *bytevector* *n* *u64*)`'
  id: totrans-2558
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s64-native-set! *bytevector* *n* *s64*)`'
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2560
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2561
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer. It indexes the starting byte of
    the value and must be a multiple of the number of bytes occupied by the value:
    2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of
    `*n*` and the number of bytes occupied by the value must not exceed the length
    `*bytevector*`. `*u16*` must be a 16-bit unsigned value, i.e., a value in the
    range 0 to 2^(16) - 1 inclusive; `*s16*` must be a 16-bit signed value, i.e.,
    a value in the range -2^(15) to 2^(15) - 1 inclusive; `*u32*` must be a 32-bit
    unsigned value, i.e., a value in the range 0 to 2^(32) - 1 inclusive; `*s32*`
    must be a 32-bit signed value, i.e., a value in the range -2^(31) to 2^(31) -
    1 inclusive; `*u64*` must be a 64-bit unsigned value, i.e., a value in the range
    0 to 2^(64) - 1 inclusive; and `*s64*` must be a 64-bit signed value, i.e., a
    value in the range -2^(63) to 2^(63) - 1 inclusive. The native endianness is assumed.'
  id: totrans-2562
  prefs: []
  type: TYPE_NORMAL
- en: These procedures store the given value in the 2, 4, or 8 bytes starting at index
    `*n*` (zero-based) of `*bytevector*`. Negative values are stored as their two's
    complement equivalent.
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v (make-bytevector 8 0))'
  id: totrans-2564
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u16-native-set! v 0 #xfe56)
  id: totrans-2565
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-native-set! v 2 #x-1aa)
  id: totrans-2566
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-native-set! v 4 #x7898)`
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
- en: 'If native endianness is big:'
  id: totrans-2568
  prefs: []
  type: TYPE_NORMAL
- en: '`v ![<graphic>](ch6_0.gif) #vu8(#xfe #x56 #xfe #x56 #x78 #x98 #x00 #x00)`'
  id: totrans-2569
  prefs: []
  type: TYPE_NORMAL
- en: 'If native endianness is little:'
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
- en: '`v ![<graphic>](ch6_0.gif) #vu8(#x56 #xfe #x56 #xfe #x98 #x78 #x00 #x00)`'
  id: totrans-2571
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v (make-bytevector 16 0))'
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u32-native-set! v 0 #x1234fe56)
  id: totrans-2573
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-native-set! v 4 #x1234fe56)
  id: totrans-2574
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-native-set! v 8 #x-23458768)`
  id: totrans-2575
  prefs: []
  type: TYPE_NORMAL
- en: 'If native endianness is big:'
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
- en: '`v ![<graphic>](ch6_0.gif) #vu8(#x12 #x34 #xfe #x56 #x12 #x34 #xfe #x56'
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #xdc #xba #x78 #x98 #x00 #x00 #x00 #x00)`'
  id: totrans-2578
  prefs: []
  type: TYPE_NORMAL
- en: 'If native endianness is little:'
  id: totrans-2579
  prefs: []
  type: TYPE_NORMAL
- en: '`v ![<graphic>](ch6_0.gif) #vu8(#x56 #xfe #x34 #x12 #x56 #xfe #x34 #x12'
  id: totrans-2580
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x98 #x78 #xba #xdc #x00 #x00 #x00 #x00)`'
  id: totrans-2581
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v (make-bytevector 24 0))'
  id: totrans-2582
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u64-native-set! v 0 #x1234fe56dcba7898)
  id: totrans-2583
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s64-native-set! v 8 #x1234fe56dcba7898)
  id: totrans-2584
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s64-native-set! v 16 #x-67874523a901cbee)`
  id: totrans-2585
  prefs: []
  type: TYPE_NORMAL
- en: 'If native endianness is big:'
  id: totrans-2586
  prefs: []
  type: TYPE_NORMAL
- en: '`v ![<graphic>](ch6_0.gif) #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98'
  id: totrans-2587
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98'
  id: totrans-2588
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12)`'
  id: totrans-2589
  prefs: []
  type: TYPE_NORMAL
- en: 'If native endianness is little:'
  id: totrans-2590
  prefs: []
  type: TYPE_NORMAL
- en: '`v ![<graphic>](ch6_0.gif) #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12'
  id: totrans-2591
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12'
  id: totrans-2592
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98)`'
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u16-ref *bytevector* *n* *eness*)`'
  id: totrans-2594
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 16-bit unsigned integer at index `*n*` (zero-based) of `*bytevector*`'
  id: totrans-2595
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s16-ref *bytevector* *n* *eness*)`'
  id: totrans-2596
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 16-bit signed integer at index `*n*` (zero-based) of `*bytevector*`'
  id: totrans-2597
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u32-ref *bytevector* *n* *eness*)`'
  id: totrans-2598
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 32-bit unsigned integer at index `*n*` (zero-based) of `*bytevector*`'
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s32-ref *bytevector* *n* *eness*)`'
  id: totrans-2600
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 32-bit signed integer at index `*n*` (zero-based) of `*bytevector*`'
  id: totrans-2601
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u64-ref *bytevector* *n* *eness*)`'
  id: totrans-2602
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 64-bit unsigned integer at index `*n*` (zero-based) of `*bytevector*`'
  id: totrans-2603
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s64-ref *bytevector* *n* *eness*)`'
  id: totrans-2604
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the 64-bit signed integer at index `*n*` (zero-based) of `*bytevector*`'
  id: totrans-2605
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2606
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer and indexes the starting byte of
    the value. The sum of `*n*` and the number of bytes occupied by the value (2 for
    16-bit values, 4 for 32-bit values, and 8 for 32-bit values) must not exceed the
    length of `*bytevector*`. `*n*` need *not* be a multiple of the number of bytes
    occupied by the value. `*eness*` must be a valid endianness symbol naming the
    endianness.'
  id: totrans-2607
  prefs: []
  type: TYPE_NORMAL
- en: The return value is an exact integer in the appropriate range for the number
    of bytes occupied by the value. Signed values are the equivalent of the stored
    value treated as a two's complement value.
  id: totrans-2608
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))'
  id: totrans-2609
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u16-ref v 0 (endianness big)) ![<graphic>](ch6_0.gif) #x1234
  id: totrans-2610
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-ref v 1 (endianness big)) ![<graphic>](ch6_0.gif) #x34fe
  id: totrans-2611
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-ref v 5 (endianness big)) ![<graphic>](ch6_0.gif) #x-4588
  id: totrans-2612
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u32-ref v 2 'big) ![<graphic>](ch6_0.gif) #xfe56dcba
  id: totrans-2613
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-ref v 3 'big) ![<graphic>](ch6_0.gif) #x56dcba78
  id: totrans-2614
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-ref v 4 'big) ![<graphic>](ch6_0.gif) #x-23458768
  id: totrans-2615
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u64-ref v 0 'big) ![<graphic>](ch6_0.gif) #x1234fe56dcba7898
  id: totrans-2616
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s64-ref v 1 'big) ![<graphic>](ch6_0.gif) #x34fe56dcba78989a
  id: totrans-2617
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u16-ref v 0 (endianness little)) ![<graphic>](ch6_0.gif) #x3412
  id: totrans-2618
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-ref v 1 (endianness little)) ![<graphic>](ch6_0.gif) #x-1cc
  id: totrans-2619
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-ref v 5 (endianness little)) ![<graphic>](ch6_0.gif) #x78ba
  id: totrans-2620
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u32-ref v 2 'little) ![<graphic>](ch6_0.gif) #xbadc56fe
  id: totrans-2621
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-ref v 3 'little) ![<graphic>](ch6_0.gif) #x78badc56
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-ref v 4 'little) ![<graphic>](ch6_0.gif) #x-67874524
  id: totrans-2623
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u64-ref v 0 'little) ![<graphic>](ch6_0.gif) #x9878badc56fe3412
  id: totrans-2624
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s64-ref v 1 'little) ![<graphic>](ch6_0.gif) #x-6567874523a901cc`
  id: totrans-2625
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u16-set! *bytevector* *n* *u16* *eness*)`'
  id: totrans-2626
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s16-set! *bytevector* *n* *s16* *eness*)`'
  id: totrans-2627
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u32-set! *bytevector* *n* *u32* *eness*)`'
  id: totrans-2628
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s32-set! *bytevector* *n* *s32* *eness*)`'
  id: totrans-2629
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-u64-set! *bytevector* *n* *u64* *eness*)`'
  id: totrans-2630
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-s64-set! *bytevector* *n* *s64* *eness*)`'
  id: totrans-2631
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2632
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2633
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer and indexes the starting byte of
    the value. The sum of `*n*` and the number of bytes occupied by the value must
    not exceed the length of `*bytevector*`. `*n*` need *not* be a multiple of the
    number of bytes occupied by the value. `*u16*` must be a 16-bit unsigned value,
    i.e., a value in the range 0 to 2^(16) - 1 inclusive; `*s16*` must be a 16-bit
    signed value, i.e., a value in the range -2^(15) to 2^(15) - 1 inclusive; `*u32*`
    must be a 32-bit unsigned value, i.e., a value in the range 0 to 2^(32) - 1 inclusive;
    `*s32*` must be a 32-bit signed value, i.e., a value in the range -2^(31) to 2^(31)
    - 1 inclusive; `*u64*` must be a 64-bit unsigned value, i.e., a value in the range
    0 to 2^(64) - 1 inclusive; and `*s64*` must be a 64-bit signed value, i.e., a
    value in the range -2^(63) to 2^(63) - 1 inclusive. `*eness*` must be a valid
    endianness symbol naming the endianness.'
  id: totrans-2634
  prefs: []
  type: TYPE_NORMAL
- en: These procedures store the given value in the 2, 4, or 8 bytes starting at index
    `*n*` (zero-based) of `*bytevector*`. Negative values are stored as their two's
    complement equivalent.
  id: totrans-2635
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v (make-bytevector 8 0))'
  id: totrans-2636
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u16-set! v 0 #xfe56 (endianness big))
  id: totrans-2637
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-set! v 3 #x-1aa (endianness little))
  id: totrans-2638
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s16-set! v 5 #x7898 (endianness big))
  id: totrans-2639
  prefs: []
  type: TYPE_NORMAL
- en: v ![<graphic>](ch6_0.gif) #vu8(#xfe #x56 #x0 #x56 #xfe #x78 #x98 #x0)
  id: totrans-2640
  prefs: []
  type: TYPE_NORMAL
- en: (define v (make-bytevector 16 0))
  id: totrans-2641
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u32-set! v 0 #x1234fe56 'little)
  id: totrans-2642
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-set! v 6 #x1234fe56 'big)
  id: totrans-2643
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s32-set! v 11 #x-23458768 'little)
  id: totrans-2644
  prefs: []
  type: TYPE_NORMAL
- en: v ![<graphic>](ch6_0.gif) #vu8(#x56 #xfe #x34 #x12 #x0 #x0
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x12 #x34 #xfe #x56 #x0'
  id: totrans-2646
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x98 #x78 #xba #xdc #x0)'
  id: totrans-2647
  prefs: []
  type: TYPE_IMG
- en: (define v (make-bytevector 28 0))
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-u64-set! v 0 #x1234fe56dcba7898 'little)
  id: totrans-2649
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s64-set! v 10 #x1234fe56dcba7898 'big)
  id: totrans-2650
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-s64-set! v 19 #x-67874523a901cbee 'big)
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
- en: v ![<graphic>](ch6_0.gif) #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0 #x0
  id: totrans-2652
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x0'
  id: totrans-2653
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0)`'
  id: totrans-2654
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-uint-ref *bytevector* *n* *eness* *size*)`'
  id: totrans-2655
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the `*size*`-byte unsigned integer at index `*n*` (zero-based)
    of `*bytevector*`'
  id: totrans-2656
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-sint-ref *bytevector* *n* *eness* *size*)`'
  id: totrans-2657
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the `*size*`-byte signed integer at index `*n*` (zero-based) of
    `*bytevector*`'
  id: totrans-2658
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2659
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer and indexes the starting byte of
    the value. `*size*` must be an exact positive integer and specifies the number
    of bytes occupied by the value. The sum of `*n*` and `*size*` must not exceed
    the length of `*bytevector*`. `*n*` need *not* be a multiple of the number of
    bytes occupied by the value. `*eness*` must be a valid endianness symbol naming
    the endianness.'
  id: totrans-2660
  prefs: []
  type: TYPE_NORMAL
- en: The return value is an exact integer in the appropriate range for the number
    of bytes occupied by the value. Signed values are the equivalent of the stored
    value treated as a two's complement value.
  id: totrans-2661
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))'
  id: totrans-2662
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-uint-ref v 0 'big 1) ![<graphic>](ch6_0.gif) #x12
  id: totrans-2663
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-uint-ref v 0 'little 1) ![<graphic>](ch6_0.gif) #x12
  id: totrans-2664
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-uint-ref v 1 'big 3) ![<graphic>](ch6_0.gif) #x34fe56
  id: totrans-2665
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-uint-ref v 2 'little 7) ![<graphic>](ch6_0.gif) #x9a9878badc56fe
  id: totrans-2666
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-sint-ref v 2 'big 1) ![<graphic>](ch6_0.gif) #x-02
  id: totrans-2667
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-sint-ref v 1 'little 6) ![<graphic>](ch6_0.gif) #x78badc56fe34
  id: totrans-2668
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-sint-ref v 2 'little 7) ![<graphic>](ch6_0.gif) #x-6567874523a902
  id: totrans-2669
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-sint-ref (make-bytevector 1000 -1) 0 'big 1000) ![<graphic>](ch6_0.gif) -1`
  id: totrans-2670
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-uint-set! *bytevector* *n* *uint* *eness* *size*)`'
  id: totrans-2671
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-sint-set! *bytevector* *n* *sint* *eness* *size*)`'
  id: totrans-2672
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2673
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2674
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer and indexes the starting byte of
    the value. `*size*` must be an exact positive integer and specifies the number
    of bytes occupied by the value. The sum of `*n*` and `*size*` must not exceed
    the length of `*bytevector*`. `*n*` need *not* be a multiple of the number of
    bytes occupied by the value. `*uint*` must be an exact integer in the range 0
    to 2^(*size*·8) - 1 inclusive. `*sint*` must be an exact integer in the range
    -2^(*size*·8-1) to 2^(*size*·8-1) - 1 inclusive. `*eness*` must be a valid endianness
    symbol naming the endianness.'
  id: totrans-2675
  prefs: []
  type: TYPE_NORMAL
- en: These procedures store the given value in the `*size*` bytes starting at index
    `*n*` (zero-based) of `*bytevector*`. Negative values are stored as their two's
    complement equivalent.
  id: totrans-2676
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v (make-bytevector 5 0))'
  id: totrans-2677
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-uint-set! v 1 #x123456 (endianness big) 3)
  id: totrans-2678
  prefs: []
  type: TYPE_NORMAL
- en: v ![<graphic>](ch6_0.gif) #vu8(0 #x12 #x34 #x56 0)
  id: totrans-2679
  prefs: []
  type: TYPE_NORMAL
- en: (define v (make-bytevector 7 -1))
  id: totrans-2680
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-sint-set! v 1 #x-8000000000 (endianness little) 5)
  id: totrans-2681
  prefs: []
  type: TYPE_NORMAL
- en: v ![<graphic>](ch6_0.gif) #vu8(#xff 0 0 0 0 #x80 #xff)`
  id: totrans-2682
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector->uint-list *bytevector* *eness* *size*)`'
  id: totrans-2683
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new list of the `*size*`-bit unsigned elements of `*bytevector*`'
  id: totrans-2684
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector->sint-list *bytevector* *eness* *size*)`'
  id: totrans-2685
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new list of the `*size*`-bit signed elements of `*bytevector*`'
  id: totrans-2686
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2687
  prefs: []
  type: TYPE_NORMAL
- en: '`*eness*` must be a valid endianness symbol naming the endianness. `*size*`
    must be an exact positive integer and specifies the number of bytes occupied by
    the value. It must be a value that evenly divides the length of `*bytevector*`.'
  id: totrans-2688
  prefs: []
  type: TYPE_NORMAL
- en: '`(bytevector->uint-list (make-bytevector 0) ''little 3) ![<graphic>](ch6_0.gif) ()'
  id: totrans-2689
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v #vu8(1 2 3 4 5 6)])
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector->uint-list v 'big 3)) ![<graphic>](ch6_0.gif) (#x010203 #x040506)
  id: totrans-2691
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v (make-bytevector 80 -1)])
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector->sint-list v 'big 20)) ![<graphic>](ch6_0.gif) (-1 -1 -1 -1)`
  id: totrans-2693
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(uint-list->bytevector *list* *eness* *size*)`'
  id: totrans-2694
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(sint-list->bytevector *list* *eness* *size*)`'
  id: totrans-2695
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new bytevector of the elements of `*list*`'
  id: totrans-2696
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
- en: '`*eness*` must be a valid endianness symbol naming the endianness. `*size*`
    must be an exact positive integer and specifies the number of bytes occupied by
    the value. For `uint-list->bytevector`, `*list*` must consist entirely of `*size*`-byte
    exact unsigned integers, i.e., values in the range 0 to 2^(*size*·8) - 1 inclusive.
    For `sint-list->bytevector`, `*list*` must consist entirely of `*size*`-byte exact
    signed integers, i.e., values in the range -2^(*size*·8-1) to 2^(*size*·8-1) -
    1 inclusive. Each value occupies `*size*` bytes in the resulting bytevector, whose
    length is thus `*size*` times the length of `*list*`.'
  id: totrans-2698
  prefs: []
  type: TYPE_NORMAL
- en: '`(uint-list->bytevector ''() ''big 25) ![<graphic>](ch6_0.gif) #vu8()'
  id: totrans-2699
  prefs: []
  type: TYPE_NORMAL
- en: (sint-list->bytevector '(0 -1) 'big 3) ![<graphic>](ch6_0.gif) #vu8(0 0 0 #xff #xff #xff)
  id: totrans-2700
  prefs: []
  type: TYPE_NORMAL
- en: (define (f size)
  id: totrans-2701
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls (list (- (expt 2 (- (* 8 size) 1)))
  id: totrans-2702
  prefs: []
  type: TYPE_NORMAL
- en: (- (expt 2 (- (* 8 size) 1)) 1))])
  id: totrans-2703
  prefs: []
  type: TYPE_NORMAL
- en: (sint-list->bytevector ls 'little size)))
  id: totrans-2704
  prefs: []
  type: TYPE_NORMAL
- en: (f 6) ![<graphic>](ch6_0.gif) #vu8(#x00 #x00 #x00 #x00 #x00 #x80
  id: totrans-2705
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif)      #xff #xff #xff #xff #xff #x7f)`'
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-ieee-single-native-ref *bytevector* *n*)`'
  id: totrans-2707
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the single floating-point value at index `*n*` (zero-based) of
    `*bytevector*`'
  id: totrans-2708
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-ieee-double-native-ref *bytevector* *n*)`'
  id: totrans-2709
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the double floating-point value at index `*n*` (zero-based) of
    `*bytevector*`'
  id: totrans-2710
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2711
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer. It indexes the starting byte of
    the value and must be a multiple of the number of bytes occupied by the value:
    4 for single floats, 8 for double. The sum of `*n*` and the number of bytes occupied
    by the value must not exceed the length of `*bytevector*`. The native endianness
    is assumed.'
  id: totrans-2712
  prefs: []
  type: TYPE_NORMAL
- en: The return value is an inexact real number. Examples appear after the mutation
    operators below.
  id: totrans-2713
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-ieee-single-native-set! *bytevector* *n* *x*)`'
  id: totrans-2714
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-ieee-double-native-set! *bytevector* *n* *x*)`'
  id: totrans-2715
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2716
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2717
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer. It indexes the starting byte of
    the value and must be a multiple of the number of bytes occupied by the value:
    4 for single floats, 8 for double. The sum of `*n*` and the number of bytes occupied
    by the value must not exceed the length of `*bytevector*`. The native endianness
    is assumed.'
  id: totrans-2718
  prefs: []
  type: TYPE_NORMAL
- en: These procedures store the given value as an IEEE-754 single or double floating-point
    value at index `*n*` (zero-based) of `*bytevector*`.
  id: totrans-2719
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v (make-bytevector 8 0))'
  id: totrans-2720
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-single-native-set! v 0 .125)
  id: totrans-2721
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-single-native-set! v 4 -3/2)
  id: totrans-2722
  prefs: []
  type: TYPE_NORMAL
- en: (list
  id: totrans-2723
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-single-native-ref v 0)
  id: totrans-2724
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-single-native-ref v 4)) ![<graphic>](ch6_0.gif) (0.125 -1.5)
  id: totrans-2725
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-double-native-set! v 0 1e23)
  id: totrans-2726
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-double-native-ref v 0) ![<graphic>](ch6_0.gif) 1e23`
  id: totrans-2727
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-ieee-single-ref *bytevector* *n* *eness*)`'
  id: totrans-2728
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the single floating-point value at index `*n*` (zero-based) of
    `*bytevector*`'
  id: totrans-2729
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-ieee-double-ref *bytevector* *n* *eness*)`'
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the double floating-point value at index `*n*` (zero-based) of
    `*bytevector*`'
  id: totrans-2731
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2732
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer and indexes the starting byte of
    the value. The sum of `*n*` and the number of bytes occupied by the value (4 for
    a single float, 8 for a double) must not exceed the length of `*bytevector*`.
    `*n*` need *not* be a multiple of the number of bytes occupied by the value. `*eness*`
    must be a valid endianness symbol naming the endianness.'
  id: totrans-2733
  prefs: []
  type: TYPE_NORMAL
- en: The return value is an inexact real number. Examples appear after the mutation
    operators below.
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-ieee-single-set! *bytevector* *n* *x* *eness*)`'
  id: totrans-2735
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(bytevector-ieee-double-set! *bytevector* *n* *x* *eness*)`'
  id: totrans-2736
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2737
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs bytevectors)`, `(rnrs)`'
  id: totrans-2738
  prefs: []
  type: TYPE_NORMAL
- en: '`*n*` must be an exact nonnegative integer and indexes the starting byte of
    the value. The sum of `*n*` and the number of bytes occupied by the value (4 for
    a single float, 8 for a double) must not exceed the length of `*bytevector*`.
    `*n*` need *not* be a multiple of the number of bytes occupied by the value. `*eness*`
    must be a valid endianness symbol naming the endianness.'
  id: totrans-2739
  prefs: []
  type: TYPE_NORMAL
- en: These procedures store the given value as an IEEE-754 single or double floating-point
    value at index `*n*` (zero-based) of `*bytevector*`.
  id: totrans-2740
  prefs: []
  type: TYPE_NORMAL
- en: '`(define v (make-bytevector 10 #xc7))'
  id: totrans-2741
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-single-set! v 1 .125 'little)
  id: totrans-2742
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-single-set! v 6 -3/2 'big)
  id: totrans-2743
  prefs: []
  type: TYPE_NORMAL
- en: (list
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-single-ref v 1 'little)
  id: totrans-2745
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-single-ref v 6 'big)) ![<graphic>](ch6_0.gif) (0.125 -1.5)
  id: totrans-2746
  prefs: []
  type: TYPE_NORMAL
- en: v ![<graphic>](ch6_0.gif) #vu8(#xc7 #x0 #x0 #x0 #x3e #xc7 #xbf #xc0 #x0 #x0)
  id: totrans-2747
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-double-set! v 1 1e23 'big)
  id: totrans-2748
  prefs: []
  type: TYPE_NORMAL
- en: (bytevector-ieee-double-ref v 1 'big) ![<graphic>](ch6_0.gif) 1e23`
  id: totrans-2749
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.11\. Symbols
  id: totrans-2750
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Symbols are used for a variety of purposes as symbolic names in Scheme programs.
    Strings could be used for most of the same purposes, but an important characteristic
    of symbols makes comparisons between symbols much more efficient. This characteristic
    is that two symbols with the same name are identical in the sense of `eq?`. The
    reason is that the Scheme reader (invoked by `get-datum` and `read`) and the procedure
    `string->symbol` catalog symbols in an internal symbol table and always return
    the same symbol whenever the same name is encountered. Thus, no character-by-character
    comparison is needed, as would be needed to compare two strings.
  id: totrans-2751
  prefs: []
  type: TYPE_NORMAL
- en: The property that two symbols may be compared quickly for equivalence makes
    them ideally suited for use as identifiers in the representation of programs,
    allowing fast comparison of identifiers. This property also makes symbols useful
    for a variety of other purposes. For example, symbols might be used as messages
    passed between procedures, labels for list-structured records, or names for objects
    stored in an association list (see `assq` in Section [6.3](objects.html#g109)).
  id: totrans-2752
  prefs: []
  type: TYPE_NORMAL
- en: Symbols are written without double quotes or other bracketing characters. Parentheses,
    double quotes, spaces, and most other characters with a special meaning to the
    Scheme reader are not allowed within the printed representation of a symbol. These
    and any other Unicode character may appear anywhere within the printed representation
    of a symbol with the syntax `#\x*n*;`, where `*n*` consists of one or more hexadecimal
    digits and represents a valid Unicode scalar value.
  id: totrans-2753
  prefs: []
  type: TYPE_NORMAL
- en: The grammar for symbols on page [458](grammar.html#grammar:symbols) gives a
    precise definition of the syntax of symbols.
  id: totrans-2754
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(symbol=? *symbol[1]* *symbol[2]*)`'
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the two symbols are the same, `#f` otherwise'
  id: totrans-2756
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2757
  prefs: []
  type: TYPE_NORMAL
- en: Symbols can also be compared with `eq?`, which is typically more efficient than
    `symbol=?`.
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
- en: '`(symbol=? ''a ''a) ![<graphic>](ch6_0.gif) #t'
  id: totrans-2759
  prefs: []
  type: TYPE_NORMAL
- en: (symbol=? 'a (string->symbol "a")) ![<graphic>](ch6_0.gif) #t
  id: totrans-2760
  prefs: []
  type: TYPE_NORMAL
- en: (symbol=? 'a 'b) ![<graphic>](ch6_0.gif) #f`
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string->symbol *string*)`'
  id: totrans-2762
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a symbol whose name is `*string*`'
  id: totrans-2763
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2764
  prefs: []
  type: TYPE_NORMAL
- en: '`string->symbol` records all symbols it creates in an internal table that it
    shares with the system reader. If a symbol whose name is equivalent to string
    (according to the predicate `string=?`) already exists in the table, this symbol
    is returned. Otherwise, a new symbol is created with `*string*` as its name; this
    symbol is entered into the table and returned.'
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
- en: The effect of modifying a string after it is used as an argument to `string->symbol`
    is unspecified.
  id: totrans-2766
  prefs: []
  type: TYPE_NORMAL
- en: '`(string->symbol "x") ![<graphic>](ch6_0.gif) x'
  id: totrans-2767
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (string->symbol "x") 'x) ![<graphic>](ch6_0.gif) #t
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (string->symbol "X") 'x) ![<graphic>](ch6_0.gif) #f
  id: totrans-2769
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (string->symbol "x")
  id: totrans-2770
  prefs: []
  type: TYPE_NORMAL
- en: (string->symbol "x")) ![<graphic>](ch6_0.gif) #t
  id: totrans-2771
  prefs: []
  type: TYPE_NORMAL
- en: (string->symbol "()") ![<graphic>](ch6_0.gif) \x28;\x29;`
  id: totrans-2772
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(symbol->string *symbol*)`'
  id: totrans-2773
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a string, the name of `*symbol*`'
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2775
  prefs: []
  type: TYPE_NORMAL
- en: The string returned by `symbol->string` should be treated as immutable. Unpredictable
    behavior can result if a string passed to `string->symbol` is altered with `string-set!`
    or by any other means.
  id: totrans-2776
  prefs: []
  type: TYPE_NORMAL
- en: '`(symbol->string ''xyz) ![<graphic>](ch6_0.gif) "xyz"'
  id: totrans-2777
  prefs: []
  type: TYPE_NORMAL
- en: (symbol->string 'Hi) ![<graphic>](ch6_0.gif) "Hi"
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
- en: (symbol->string (string->symbol "()")) ![<graphic>](ch6_0.gif) "()"`
  id: totrans-2779
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.12\. Booleans
  id: totrans-2780
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While every Scheme object has a truth value when used in a conditional context,
    with every object but `#f` counting as true, Scheme provides the dedicated true
    value `#t` for use when a value of an expression should convey nothing more than
    that it is true.
  id: totrans-2781
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(boolean=? *boolean[1]* *boolean[2]*)`'
  id: totrans-2782
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the two booleans are the same, `#f` otherwise'
  id: totrans-2783
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-2784
  prefs: []
  type: TYPE_NORMAL
- en: The boolean values `#t` and `#f` may also be compared with `eq?`, which is typically
    more efficient than `boolean=?`.
  id: totrans-2785
  prefs: []
  type: TYPE_NORMAL
- en: '`(boolean=? #t #t) ![<graphic>](ch6_0.gif) #t'
  id: totrans-2786
  prefs: []
  type: TYPE_NORMAL
- en: (boolean=? #t #f) ![<graphic>](ch6_0.gif) #f
  id: totrans-2787
  prefs: []
  type: TYPE_NORMAL
- en: (boolean=? #t (< 3 4)) ![<graphic>](ch6_0.gif) #t`
  id: totrans-2788
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.13\. Hashtables
  id: totrans-2789
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hashtables represent sets of associations between arbitrary Scheme values. They
    serve essentially the same purpose as association lists (see page  [165](objects.html#page:assq))
    but are typically much faster when large numbers of associations are involved.
  id: totrans-2790
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-eq-hashtable)`'
  id: totrans-2791
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-eq-hashtable *size*)`'
  id: totrans-2792
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new mutable eq hashtable'
  id: totrans-2793
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  id: totrans-2794
  prefs: []
  type: TYPE_NORMAL
- en: If `*size*` is provided, it must be a nonnegative exact integer indicating approximately
    how many elements the hashtable should initially hold. Hashtables grow as needed,
    but when the hashtable grows it generally must rehash all of the existing elements.
    Providing a nonzero `*size*` can help limit the amount of rehashing that must
    be done as the table is initially populated.
  id: totrans-2795
  prefs: []
  type: TYPE_NORMAL
- en: An eq hashtable compares keys using the `eq?` (pointer equality) procedure and
    typically employs a hash function based on object addresses. Its hash and equivalence
    functions are suitable for any Scheme object.
  id: totrans-2796
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht1 (make-eq-hashtable))'
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
- en: (define ht2 (make-eq-hashtable 32))`
  id: totrans-2798
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-eqv-hashtable)`'
  id: totrans-2799
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-eqv-hashtable *size*)`'
  id: totrans-2800
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new mutable eqv hashtable'
  id: totrans-2801
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  id: totrans-2802
  prefs: []
  type: TYPE_NORMAL
- en: If `*size*` is provided, it must be a nonnegative exact integer indicating approximately
    how many elements the hashtable should initially hold. Hashtables grow as needed,
    but when the hashtable grows it generally must rehash all of the existing elements.
    Providing a nonzero `*size*` can help limit the amount of rehashing that must
    be done as the table is initially populated.
  id: totrans-2803
  prefs: []
  type: TYPE_NORMAL
- en: An eqv hashtable compares keys using the `eqv?` procedure and typically employs
    a hash function based on object addresses for objects that are identifiable with
    `eq?`. Its hash and equivalence functions are suitable for any Scheme object.
  id: totrans-2804
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-hashtable *hash* *equiv?*)`'
  id: totrans-2805
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-hashtable *hash* *equiv?* *size*)`'
  id: totrans-2806
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new mutable hashtable'
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  id: totrans-2808
  prefs: []
  type: TYPE_NORMAL
- en: '`*hash*` and `*equiv?*` must be procedures. If `*size*` is provided, it must
    be a nonnegative exact integer indicating approximately how many elements the
    hashtable should initially hold. Hashtables grow as needed, but when the hashtable
    grows it generally must rehash all of the existing elements. Providing a nonzero
    `*size*` can help limit the amount of rehashing that must be done as the table
    is initially populated.'
  id: totrans-2809
  prefs: []
  type: TYPE_NORMAL
- en: The new hashtable computes hash values using `*hash*` and compares keys using
    `*equiv?*`, neither of which should modify the hashtable. `*equiv?*` should compare
    two keys and return false only if the two keys should be distinguished. `*hash*`
    should accept a key as an argument and return a nonnegative exact integer value
    that is the same each time it is called with arguments that `*equiv?*` does not
    distinguish. The `*hash*` and `*equiv?*` procedures need not accept arbitrary
    inputs as long as the hashtable is used only for keys that they do accept, and
    both procedures may assume that the keys are immutable as long as the keys are
    not modified while they have associations stored in the table. The hashtable operation
    may call `*hash*` and `*equiv?*` once, not at all, or multiple times for each
    hashtable operation.
  id: totrans-2810
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-hashtable string-hash string=?))`'
  id: totrans-2811
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-mutable? *hashtable*)`'
  id: totrans-2812
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*hashtable*` is mutable, `#f` otherwise'
  id: totrans-2813
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  id: totrans-2814
  prefs: []
  type: TYPE_NORMAL
- en: Hashtables returned by one of the hashtable creation procedures above are mutable,
    but those created by `hashtable-copy` may be immutable. Immutable hashtables cannot
    be altered by any of the procedures `hashtable-set!`, `hashtable-update!`, `hashtable-delete!`,
    or `hashtable-clear!`.
  id: totrans-2815
  prefs: []
  type: TYPE_NORMAL
- en: '`(hashtable-mutable? (make-eq-hashtable)) ![<graphic>](ch6_0.gif) #t'
  id: totrans-2816
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-mutable? (hashtable-copy (make-eq-hashtable))) ![<graphic>](ch6_0.gif) #f`
  id: totrans-2817
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-hash-function *hashtable*)`'
  id: totrans-2818
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the hash function associated with `*hashtable*`'
  id: totrans-2819
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-equivalence-function *hashtable*)`'
  id: totrans-2820
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the equivalence function associated with `*hashtable*`'
  id: totrans-2821
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  id: totrans-2822
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtable-hash-function` returns `#f` for eq and eqv hashtables.'
  id: totrans-2823
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  id: totrans-2824
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-hash-function ht) ![<graphic>](ch6_0.gif) #f
  id: totrans-2825
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (hashtable-equivalence-function ht) eq?) ![<graphic>](ch6_0.gif) #t
  id: totrans-2826
  prefs: []
  type: TYPE_NORMAL
- en: (define ht (make-hashtable string-hash string=?))
  id: totrans-2827
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (hashtable-hash-function ht) string-hash) ![<graphic>](ch6_0.gif) #t
  id: totrans-2828
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (hashtable-equivalence-function ht) string=?) ![<graphic>](ch6_0.gif) #t`
  id: totrans-2829
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(equal-hash *obj*)`'
  id: totrans-2830
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-hash *string*)`'
  id: totrans-2831
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-ci-hash *string*)`'
  id: totrans-2832
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(symbol-hash *symbol*)`'
  id: totrans-2833
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** an exact nonnegative integer hash value'
  id: totrans-2834
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  id: totrans-2835
  prefs: []
  type: TYPE_NORMAL
- en: 'These procedures are hash functions suitable for use with the appropriate Scheme
    predicate: `equal?` for `equal-hash`, `string=?` for `string-hash`, `string-ci=?`
    for `string-ci-hash`, and `symbol=?` (or eq?) for `symbol-hash`. The hash values
    returned by `equal-hash`, `string-hash`, and `string-ci-hash` are typically dependent
    on the current structure and contents of the input values and are thus unsuitable
    if keys are modified while they have associations in a hashtable.'
  id: totrans-2836
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-set! *hashtable* *key* *obj*)`'
  id: totrans-2837
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2838
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  id: totrans-2839
  prefs: []
  type: TYPE_NORMAL
- en: '`*hashtable*` must be a mutable hashtable. `*key*` should be an appropriate
    key for the hashtable''s hash and equivalence functions. `*obj*` may be any Scheme
    object.'
  id: totrans-2840
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtable-set!` associates `*key*` with `*obj*` in `*hashtable*`, replacing
    the existing association, if any.'
  id: totrans-2841
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  id: totrans-2842
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht 'a 73)`
  id: totrans-2843
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-ref *hashtable* *key* *default*)`'
  id: totrans-2844
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-2845
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  id: totrans-2846
  prefs: []
  type: TYPE_NORMAL
- en: '`*key*` should be an appropriate key for the hashtable''s hash and equivalence
    functions. `*default*` may be any Scheme object.'
  id: totrans-2847
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtable-ref` returns the value associated with `*key*` in `*hashtable*`.
    If no value is associated with `*key*` in `*hashtable*`, `hashtable-ref` returns
    `*default*`.'
  id: totrans-2848
  prefs: []
  type: TYPE_NORMAL
- en: '`(define p1 (cons ''a ''b))'
  id: totrans-2849
  prefs: []
  type: TYPE_NORMAL
- en: (define p2 (cons 'a 'b))
  id: totrans-2850
  prefs: []
  type: TYPE_NORMAL
- en: (define eqht (make-eq-hashtable))
  id: totrans-2851
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! eqht p1 73)
  id: totrans-2852
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref eqht p1 55) ![<graphic>](ch6_0.gif) 73
  id: totrans-2853
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref eqht p2 55) ![<graphic>](ch6_0.gif) 55
  id: totrans-2854
  prefs: []
  type: TYPE_NORMAL
- en: (define equalht (make-hashtable equal-hash equal?))
  id: totrans-2855
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! equalht p1 73)
  id: totrans-2856
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref equalht p1 55) ![<graphic>](ch6_0.gif) 73
  id: totrans-2857
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref equalht p2 55) ![<graphic>](ch6_0.gif) 73`
  id: totrans-2858
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-contains? *hashtable* *key*)`'
  id: totrans-2859
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if an association for `*key*` exists in `*hashtable*`, `#f`
    otherwise'
  id: totrans-2860
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  id: totrans-2861
  prefs: []
  type: TYPE_NORMAL
- en: '`*key*` should be an appropriate key for the hashtable''s hash and equivalence
    functions.'
  id: totrans-2862
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  id: totrans-2863
  prefs: []
  type: TYPE_NORMAL
- en: (define p1 (cons 'a 'b))
  id: totrans-2864
  prefs: []
  type: TYPE_NORMAL
- en: (define p2 (cons 'a 'b))
  id: totrans-2865
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p1 73)
  id: totrans-2866
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-contains? ht p1) ![<graphic>](ch6_0.gif) #t
  id: totrans-2867
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-contains? ht p2) ![<graphic>](ch6_0.gif) #f`
  id: totrans-2868
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-update! *hashtable* *key* *procedure* *default*)`'
  id: totrans-2869
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2870
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  id: totrans-2871
  prefs: []
  type: TYPE_NORMAL
- en: '`*hashtable*` must be a mutable hashtable. `*key*` should be an appropriate
    key for the hashtable''s hash and equivalence functions. `*default*` may be any
    Scheme object. `*procedure*` should accept one argument, should return one value,
    and should not modify `*hashtable*`.'
  id: totrans-2872
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtable-update!` applies `*procedure*` to the value associated with `*key*`
    in `*hashtable*`, or to `*default*` if no value is associated with `*key*` in
    `*hashtable*`. If `*procedure*` returns, `hashtable-update!` associates `*key*`
    with the value returned by `*procedure*`, replacing the old association, if any.'
  id: totrans-2873
  prefs: []
  type: TYPE_NORMAL
- en: A version of `hashtable-update!` that does not verify that it receives arguments
    of the proper type might be defined as follows.
  id: totrans-2874
  prefs: []
  type: TYPE_NORMAL
- en: '`(define hashtable-update!'
  id: totrans-2875
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ht key proc value)
  id: totrans-2876
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht key
  id: totrans-2877
  prefs: []
  type: TYPE_NORMAL
- en: (proc (hashtable-ref ht key value)))))`
  id: totrans-2878
  prefs: []
  type: TYPE_NORMAL
- en: An implementation may, however, be able to implement `hashtable-update!` more
    efficiently by avoiding multiple hash computations and hashtable lookups.
  id: totrans-2879
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  id: totrans-2880
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-update! ht 'a
  id: totrans-2881
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x) (* x 2))
  id: totrans-2882
  prefs: []
  type: TYPE_NORMAL
- en: 55)
  id: totrans-2883
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref ht 'a 0) ![<graphic>](ch6_0.gif) 110
  id: totrans-2884
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-update! ht 'a
  id: totrans-2885
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x) (* x 2))
  id: totrans-2886
  prefs: []
  type: TYPE_NORMAL
- en: 0)
  id: totrans-2887
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref ht 'a 0) ![<graphic>](ch6_0.gif) 220`
  id: totrans-2888
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-delete! *hashtable* *key*)`'
  id: totrans-2889
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2890
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  id: totrans-2891
  prefs: []
  type: TYPE_NORMAL
- en: '`*hashtable*` must be a mutable hashtable. `*key*` should be an appropriate
    key for the hashtable''s hash and equivalence functions.'
  id: totrans-2892
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtable-delete!` drops any association for `*key*` from `*hashtable*`.'
  id: totrans-2893
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  id: totrans-2894
  prefs: []
  type: TYPE_NORMAL
- en: (define p1 (cons 'a 'b))
  id: totrans-2895
  prefs: []
  type: TYPE_NORMAL
- en: (define p2 (cons 'a 'b))
  id: totrans-2896
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p1 73)
  id: totrans-2897
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-contains? ht p1) ![<graphic>](ch6_0.gif) #t
  id: totrans-2898
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-delete! ht p1)
  id: totrans-2899
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-contains? ht p1) ![<graphic>](ch6_0.gif) #f
  id: totrans-2900
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-contains? ht p2) ![<graphic>](ch6_0.gif) #f
  id: totrans-2901
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-delete! ht p2)`
  id: totrans-2902
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-size *hashtable*)`'
  id: totrans-2903
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** number of entries in `*hashtable*`'
  id: totrans-2904
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  id: totrans-2905
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  id: totrans-2906
  prefs: []
  type: TYPE_NORMAL
- en: (define p1 (cons 'a 'b))
  id: totrans-2907
  prefs: []
  type: TYPE_NORMAL
- en: (define p2 (cons 'a 'b))
  id: totrans-2908
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-size ht) ![<graphic>](ch6_0.gif) 0
  id: totrans-2909
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p1 73)
  id: totrans-2910
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-size ht) ![<graphic>](ch6_0.gif) 1
  id: totrans-2911
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-delete! ht p1)
  id: totrans-2912
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-size ht) ![<graphic>](ch6_0.gif) 0`
  id: totrans-2913
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-copy *hashtable*)`'
  id: totrans-2914
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-copy *hashtable* *mutable?*)`'
  id: totrans-2915
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a new hashtable containing the same entries as `*hashtable*`'
  id: totrans-2916
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  id: totrans-2917
  prefs: []
  type: TYPE_NORMAL
- en: If `*mutable?*` is present and not false, the copy is mutable; otherwise, the
    copy is immutable.
  id: totrans-2918
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  id: totrans-2919
  prefs: []
  type: TYPE_NORMAL
- en: (define p1 (cons 'a 'b))
  id: totrans-2920
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p1 "c")
  id: totrans-2921
  prefs: []
  type: TYPE_NORMAL
- en: (define ht-copy (hashtable-copy ht))
  id: totrans-2922
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-mutable? ht-copy) ![<graphic>](ch6_0.gif) #f
  id: totrans-2923
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-delete! ht p1)
  id: totrans-2924
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref ht p1 #f) ![<graphic>](ch6_0.gif) #f
  id: totrans-2925
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-delete! ht-copy p1) ![<graphic>](ch6_0.gif) *exception: not mutable*
  id: totrans-2926
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref ht-copy p1 #f) ![<graphic>](ch6_0.gif) "c"`
  id: totrans-2927
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-clear! *hashtable*)`'
  id: totrans-2928
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-clear! *hashtable* *size*)`'
  id: totrans-2929
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-2930
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  id: totrans-2931
  prefs: []
  type: TYPE_NORMAL
- en: '`*hashtable*` must be a mutable hashtable. If `*size*` is provided, it must
    be a nonnegative exact integer.'
  id: totrans-2932
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtable-clear!` removes all entries from `*hashtable*`. If size is provided,
    the hashtable is reset to the given size, as if newly created by one of the hashtable
    creation operations with size argument `*size*`.'
  id: totrans-2933
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  id: totrans-2934
  prefs: []
  type: TYPE_NORMAL
- en: (define p1 (cons 'a 'b))
  id: totrans-2935
  prefs: []
  type: TYPE_NORMAL
- en: (define p2 (cons 'a 'b))
  id: totrans-2936
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p1 "first")
  id: totrans-2937
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p2 "second")
  id: totrans-2938
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-size ht) ![<graphic>](ch6_0.gif) 2
  id: totrans-2939
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-clear! ht)
  id: totrans-2940
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-size ht) ![<graphic>](ch6_0.gif) 0
  id: totrans-2941
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-ref ht p1 #f) ![<graphic>](ch6_0.gif) #f`
  id: totrans-2942
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-keys *hashtable*)`'
  id: totrans-2943
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a vector containing the keys in `*hashtable*`'
  id: totrans-2944
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  id: totrans-2945
  prefs: []
  type: TYPE_NORMAL
- en: The keys may appear in any order in the returned vector.
  id: totrans-2946
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  id: totrans-2947
  prefs: []
  type: TYPE_NORMAL
- en: (define p1 (cons 'a 'b))
  id: totrans-2948
  prefs: []
  type: TYPE_NORMAL
- en: (define p2 (cons 'a 'b))
  id: totrans-2949
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p1 "one")
  id: totrans-2950
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p2 "two")
  id: totrans-2951
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht 'q "three")
  id: totrans-2952
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-keys ht) ![<graphic>](ch6_0.gif) #((a . b) q (a . b))`
  id: totrans-2953
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(hashtable-entries *hashtable*)`'
  id: totrans-2954
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** two vectors: one of keys and a second of values'
  id: totrans-2955
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs hashtables)`, `(rnrs)`'
  id: totrans-2956
  prefs: []
  type: TYPE_NORMAL
- en: '`hashtable-entries` returns two values. The first is a vector containing the
    keys in `*hashtable*`, and the second is a vector containing the corresponding
    values. The keys and values may appear in any order, but the order is the same
    for the keys and for the corresponding values.'
  id: totrans-2957
  prefs: []
  type: TYPE_NORMAL
- en: '`(define ht (make-eq-hashtable))'
  id: totrans-2958
  prefs: []
  type: TYPE_NORMAL
- en: (define p1 (cons 'a 'b))
  id: totrans-2959
  prefs: []
  type: TYPE_NORMAL
- en: (define p2 (cons 'a 'b))
  id: totrans-2960
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p1 "one")
  id: totrans-2961
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht p2 "two")
  id: totrans-2962
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-set! ht 'q "three")
  id: totrans-2963
  prefs: []
  type: TYPE_NORMAL
- en: (hashtable-entries ht) ![<graphic>](ch6_0.gif) #((a . b) q (a . b))
  id: totrans-2964
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) #("two" "three" "one")`'
  id: totrans-2965
  prefs: []
  type: TYPE_NORMAL
- en: Section 6.14\. Enumerations
  id: totrans-2966
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enumerations are ordered sets of symbols, typically used to name and manipulate
    options, as with the buffer modes and file options that may be specified when
    files are created.
  id: totrans-2967
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(define-enumeration *name* (*symbol* ...) *constructor*)`'
  id: totrans-2968
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  id: totrans-2969
  prefs: []
  type: TYPE_NORMAL
- en: A `define-enumeration` form is a definition and can appear anywhere any other
    definition can appear.
  id: totrans-2970
  prefs: []
  type: TYPE_NORMAL
- en: The `define-enumeration` syntax creates a new enumeration set with the specified
    symbols in the specified order forming the enumeration's universe. It defines
    a new syntactic form named by `*name*` that may be used to verify that a symbol
    is in the universe. If `*x*` is in the universe, `(*name *x**)` evaluates to `*x*`.
    It is a syntax violation if `*x*` is not in the universe.
  id: totrans-2971
  prefs: []
  type: TYPE_NORMAL
- en: '`define-enumeration` also defines a new syntactic form named by `*constructor*`
    that may be used to create subsets of the enumeration type. If `*x* ...` are each
    in the universe, `*(constructor *x** ...)` evaluates to an enumeration set containing
    `*x* ...`. Otherwise, it is a syntax violation. The same symbol may appear more
    than once in `*x* ...`, but the resulting set contains only one occurrence of
    the symbol.'
  id: totrans-2972
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-enumeration weather-element'
  id: totrans-2973
  prefs: []
  type: TYPE_NORMAL
- en: (hot warm cold sunny rainy snowy windy)
  id: totrans-2974
  prefs: []
  type: TYPE_NORMAL
- en: weather)
  id: totrans-2975
  prefs: []
  type: TYPE_NORMAL
- en: (weather-element hot) ![<graphic>](ch6_0.gif) hot
  id: totrans-2976
  prefs: []
  type: TYPE_NORMAL
- en: (weather-element fun) ![<graphic>](ch6_0.gif) *syntax violation*
  id: totrans-2977
  prefs: []
  type: TYPE_NORMAL
- en: (weather hot sunny windy) ![<graphic>](ch6_0.gif) #<enum-set>
  id: totrans-2978
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (weather rainy cold rainy)) ![<graphic>](ch6_0.gif) (cold rainy)`
  id: totrans-2979
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(make-enumeration *symbol-list*)`'
  id: totrans-2980
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** an enumeration set'
  id: totrans-2981
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  id: totrans-2982
  prefs: []
  type: TYPE_NORMAL
- en: This procedure creates a new enumeration type whose universe comprises the elements
    of `*symbol-list*`, which must be a list of symbols, in the order of their first
    appearance in the list. It returns the universe of the new enumeration type as
    an enumeration set.
  id: totrans-2983
  prefs: []
  type: TYPE_NORMAL
- en: '`(define positions (make-enumeration ''(top bottom above top beside)))'
  id: totrans-2984
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list positions) ![<graphic>](ch6_0.gif) (top bottom above beside)`
  id: totrans-2985
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-constructor *enum-set*)`'
  id: totrans-2986
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** an enumeration-set construction procedure'
  id: totrans-2987
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  id: totrans-2988
  prefs: []
  type: TYPE_NORMAL
- en: This procedure returns a procedure `*p*` that may be used to create subsets
    of the universe of `*enum-set*`. `*p*` must be passed a list of symbols, and each
    element of the list must be an element of the universe of `*enum-set*`. The enumeration
    set returned by `*p*` contains all and only the symbols in the list it is passed.
    The value returned by `*p*` may contain elements not in `*enum-set*` if the universe
    of `*enum-set*` contains those elements.
  id: totrans-2989
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(one two three four)))'
  id: totrans-2990
  prefs: []
  type: TYPE_NORMAL
- en: (define p1 (enum-set-constructor e1))
  id: totrans-2991
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 (p1 '(one three)))
  id: totrans-2992
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list e2) ![<graphic>](ch6_0.gif) (one three)
  id: totrans-2993
  prefs: []
  type: TYPE_NORMAL
- en: (define p2 (enum-set-constructor e2))
  id: totrans-2994
  prefs: []
  type: TYPE_NORMAL
- en: (define e3 (p2 '(one two four)))
  id: totrans-2995
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list e3) ![<graphic>](ch6_0.gif) (one two four)`
  id: totrans-2996
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-universe *enum-set*)`'
  id: totrans-2997
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the universe of `*enum-set*`, as an enumeration set'
  id: totrans-2998
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  id: totrans-2999
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c a b c d)))'
  id: totrans-3000
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-universe e1)) ![<graphic>](ch6_0.gif) (a b c d)
  id: totrans-3001
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 ((enum-set-constructor e1) '(c)))
  id: totrans-3002
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-universe e2)) ![<graphic>](ch6_0.gif) (a b c d)`
  id: totrans-3003
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set->list *enum-set*)`'
  id: totrans-3004
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a list of the elements of `*enum-set*`'
  id: totrans-3005
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  id: totrans-3006
  prefs: []
  type: TYPE_NORMAL
- en: The symbols in the resulting list appear in the order given to them when the
    enumeration type of `enum-set` was created.
  id: totrans-3007
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c a b c d)))'
  id: totrans-3008
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list e1) ![<graphic>](ch6_0.gif) (a b c d)
  id: totrans-3009
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 ((enum-set-constructor e1) '(d c a b)))
  id: totrans-3010
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list e2) ![<graphic>](ch6_0.gif) (a b c d)`
  id: totrans-3011
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-subset? *enum-set[1]* *enum-set[2]*)`'
  id: totrans-3012
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*enum-set[1]*` is a subset of `*enum-set[2]*`, `#f` otherwise'
  id: totrans-3013
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  id: totrans-3014
  prefs: []
  type: TYPE_NORMAL
- en: An enumeration set `*enum-set[1]*` is a subset of an enumeration set `*enum-set[2]*`
    if and only if the universe of `*enum-set[1]*` is a subset of the universe of
    `*enum-set[2]*` and each element of `*enum-set[1]*` is an element of `*enum-set[2]*`.
  id: totrans-3015
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c)))'
  id: totrans-3016
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 (make-enumeration '(a b c d e)))
  id: totrans-3017
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-subset? e1 e2) ![<graphic>](ch6_0.gif) #t
  id: totrans-3018
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-subset? e2 e1) ![<graphic>](ch6_0.gif) #f
  id: totrans-3019
  prefs: []
  type: TYPE_NORMAL
- en: (define e3 ((enum-set-constructor e2) '(a c)))
  id: totrans-3020
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-subset? e3 e1) ![<graphic>](ch6_0.gif) #f
  id: totrans-3021
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-subset? e3 e2) ![<graphic>](ch6_0.gif) #t`
  id: totrans-3022
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set=? *enum-set[1]* *enum-set[2]*)`'
  id: totrans-3023
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*enum-set[1]*` and `*enum-set[2]*` are equivalent, `#f`
    otherwise'
  id: totrans-3024
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  id: totrans-3025
  prefs: []
  type: TYPE_NORMAL
- en: Two enumeration sets `*enum-set[1]*` and `*enum-set[2]*` are equivalent if each
    is a subset of the other.
  id: totrans-3026
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c d)))'
  id: totrans-3027
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 (make-enumeration '(b d c a)))
  id: totrans-3028
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set=? e1 e2) ![<graphic>](ch6_0.gif) #t
  id: totrans-3029
  prefs: []
  type: TYPE_NORMAL
- en: (define e3 ((enum-set-constructor e1) '(a c)))
  id: totrans-3030
  prefs: []
  type: TYPE_NORMAL
- en: (define e4 ((enum-set-constructor e2) '(a c)))
  id: totrans-3031
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set=? e3 e4) ![<graphic>](ch6_0.gif) #t
  id: totrans-3032
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set=? e3 e2) ![<graphic>](ch6_0.gif) #f`
  id: totrans-3033
  prefs: []
  type: TYPE_NORMAL
- en: '`enum-set=?` could be defined in terms of `enum-set-subset?` as follows.'
  id: totrans-3034
  prefs: []
  type: TYPE_NORMAL
- en: '`(define enum-set=?'
  id: totrans-3035
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (e1 e2)
  id: totrans-3036
  prefs: []
  type: TYPE_NORMAL
- en: (and (enum-set-subset? e1 e2) (enum-set-subset? e2 e1))))`
  id: totrans-3037
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-member? *symbol* *enum-set*)`'
  id: totrans-3038
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if symbol is an element of `*enum-set*`, `#f` otherwise'
  id: totrans-3039
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  id: totrans-3040
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c d e)))'
  id: totrans-3041
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 ((enum-set-constructor e1) '(d b)))
  id: totrans-3042
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-member? 'c e1) ![<graphic>](ch6_0.gif) #t
  id: totrans-3043
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-member? 'c e2) ![<graphic>](ch6_0.gif) #f`
  id: totrans-3044
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-union *enum-set[1]* *enum-set[2]*)`'
  id: totrans-3045
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the union of `*enum-set[1]*` and `*enum-set[2]*`'
  id: totrans-3046
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-intersection *enum-set[1]* *enum-set[2]*)`'
  id: totrans-3047
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the intersection of `*enum-set[1]*` and `*enum-set[2]*`'
  id: totrans-3048
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-difference *enum-set[1]* *enum-set[2]*)`'
  id: totrans-3049
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the difference of `*enum-set[1]*` and `*enum-set[2]*`'
  id: totrans-3050
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  id: totrans-3051
  prefs: []
  type: TYPE_NORMAL
- en: '`*enum-set[1]*` and `*enum-set[2]*` must have the same enumeration type. Each
    procedure returns a new enumeration set representing the union, intersection,
    or difference of the two sets.'
  id: totrans-3052
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c d)))'
  id: totrans-3053
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 ((enum-set-constructor e1) '(a c)))
  id: totrans-3054
  prefs: []
  type: TYPE_NORMAL
- en: (define e3 ((enum-set-constructor e1) '(b c)))
  id: totrans-3055
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-union e2 e3)) ![<graphic>](ch6_0.gif) (a b c)
  id: totrans-3056
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-intersection e2 e3)) ![<graphic>](ch6_0.gif) (c)
  id: totrans-3057
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-difference e2 e3)) ![<graphic>](ch6_0.gif) (a)
  id: totrans-3058
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-difference e3 e2)) ![<graphic>](ch6_0.gif) (b)
  id: totrans-3059
  prefs: []
  type: TYPE_NORMAL
- en: (define e4 (make-enumeration '(b d c a)))
  id: totrans-3060
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-union e1 e4) ![<graphic>](ch6_0.gif) *exception: different enumeration types*`
  id: totrans-3061
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-complement *enum-set*)`'
  id: totrans-3062
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the complement of `*enum-set*` relative to its universe'
  id: totrans-3063
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  id: totrans-3064
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c d)))'
  id: totrans-3065
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-complement e1)) ![<graphic>](ch6_0.gif) ()
  id: totrans-3066
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 ((enum-set-constructor e1) '(a c)))
  id: totrans-3067
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-complement e2)) ![<graphic>](ch6_0.gif) (b d)`
  id: totrans-3068
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-projection *enum-set[1]* *enum-set[2]*)`'
  id: totrans-3069
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the projection of `*enum-set[1]*` into the universe of `*enum-set[2]*`'
  id: totrans-3070
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  id: totrans-3071
  prefs: []
  type: TYPE_NORMAL
- en: Any elements of `*enum-set[1]*` not in the universe of `*enum-set[2]*` are dropped.
    The result is of the same enumeration type as `*enum-set[2]*`.
  id: totrans-3072
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c d)))'
  id: totrans-3073
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 (make-enumeration '(a b c d e f g)))
  id: totrans-3074
  prefs: []
  type: TYPE_NORMAL
- en: (define e3 ((enum-set-constructor e1) '(a d)))
  id: totrans-3075
  prefs: []
  type: TYPE_NORMAL
- en: (define e4 ((enum-set-constructor e2) '(a c e g)))
  id: totrans-3076
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list (enum-set-projection e4 e3)) ![<graphic>](ch6_0.gif) (a c)
  id: totrans-3077
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set->list
  id: totrans-3078
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-union e3
  id: totrans-3079
  prefs: []
  type: TYPE_NORMAL
- en: (enum-set-projection e4 e3))) ![<graphic>](ch6_0.gif) (a c d)`
  id: totrans-3080
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(enum-set-indexer *enum-set*)`'
  id: totrans-3081
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a procedure that returns the index of a symbol in the universe
    of `*enum-set*`'
  id: totrans-3082
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs enums)`, `(rnrs)`'
  id: totrans-3083
  prefs: []
  type: TYPE_NORMAL
- en: '`enum-set-indexer` returns a procedure `*p*` that, when applied to a symbol
    in the universe of `*enum-set*`, returns the index of the symbol (zero-based)
    in the ordered set of symbols that form the universe. If applied to a symbol not
    in the universe, `*p*` returns `#f`.'
  id: totrans-3084
  prefs: []
  type: TYPE_NORMAL
- en: '`(define e1 (make-enumeration ''(a b c d)))'
  id: totrans-3085
  prefs: []
  type: TYPE_NORMAL
- en: (define e2 ((enum-set-constructor e1) '(a d)))
  id: totrans-3086
  prefs: []
  type: TYPE_NORMAL
- en: (define p (enum-set-indexer e2))
  id: totrans-3087
  prefs: []
  type: TYPE_NORMAL
- en: (list (p 'a) (p 'c) (p 'e)) ![<graphic>](ch6_0.gif) (0 2 #f)`
  id: totrans-3088
  prefs: []
  type: TYPE_NORMAL
