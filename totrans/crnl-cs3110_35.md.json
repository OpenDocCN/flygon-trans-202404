["```\nlet rec split (l: 'a list) : 'a list * 'a list = \n   match l with\n    [] -> [],[]\n  | [x] -> [x],[]\n  | x::y::t -> let l,r=split t in x::l,y::r\n\n(* A simpler way to write split. Recall the definition of\n   List.fold_right. What is the asymptotic performance of \n   List.fold_right f lst acc0 where f is an O(1) function\n   and lst is an n-element list? O(n). *)\nlet split' (l: 'a list) : 'a list * 'a list = \n  List.fold_right (fun x (left,right) -> (x::right,left)) l ([],[])\n\nlet rec merge (left: 'a list) (right: 'a list): 'a list =\n  match (left, right) with\n    ([],_) -> right\n  | (_,[]) -> left\n  | (x::rest_left, y::rest_right) -> \n      if x > y then y::(merge left rest_right)\n               else x::(merge rest_left right)\n\n(* merge_sort l is a list containing the same elements as xs but in\n * ascending (nondescending) sorted order.  *)\nlet rec merge_sort (l: 'a list) : 'a list =\n(* Implementation: lists of size 0 or 1 are already sorted. Otherwise,\n * split the list into two lists of equal size, recursively sort\n * them, and then merge the two lists back together. *)\n  match l with\n   ([]|[_]) -> l\n  | _ -> let (left, right) = split l in \n           merge (merge_sort left) (merge_sort right)\n\n```", "```\n(* requires n>=0 *)\nlet rec fibo=function\n  0 -> 0\n| 1 -> 1\n| n -> (fibo (n-1))+(fibo (n-2))\n\n```", "```\n(* requires n>=0 *)\nlet fibo' n=\n if(n=0) then 0 else \n   (* a is F(i-2) and b is F(i-1) *)\n   let a=ref 0 and b=ref 1 and c=ref 0 in\n   for i=2 to n do\n      c:= !b;\n      b:= !a + !b; \n      a:= !c;\n   done; !b\n\n```"]