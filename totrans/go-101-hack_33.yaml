- en: Functional literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A functional literal just represents an anonymous function. You can assign
    functional literal to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or invoke functional literal directly (Please notice the `()` at the end of
    functional literal):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The above `2` programs both output "`Hello, 中国！`".
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional literal is also a closure, so it can access the variables of its
    surrounding function. Check the following example which your real intention is
    `1` and `2` are printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But the output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The cause is the `func` goroutines don''t get the opportunity to run until
    the `main` goroutine sleeps, and at that time, the variable `i` has been changed
    to `3`. Modify the above program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `func` goroutine can run before `i` is changed, so the running result is
    what you expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'But the idiom method should be passing `i` as an argument of the functional
    literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In above program, When "`go func(i int) {fmt.Println(i)}(i)`" is executed (Note:
    not goroutine is executed.), `i` defined in `main()` is assigned to `func`''s
    local parameter `i`. And the result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'P.S. You should notice, If you pass an argument while not use it, the `Go`
    compiler doesn''t complain, but the closure will use the variable inherited from
    the parent function. That means the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'equals to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'References:'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Go Programming Language Specification](https://golang.org/ref/spec#Function_literals);'
  prefs: []
  type: TYPE_NORMAL
- en: '[A question about passing arguments to closure](https://groups.google.com/forum/#!topic/golang-nuts/JXTEYyoPLio);'
  prefs: []
  type: TYPE_NORMAL
- en: '[Why add “()” after closure body in Golang?](http://stackoverflow.com/questions/16008604/why-add-after-closure-body-in-golang).'
  prefs: []
  type: TYPE_NORMAL
