- en: 'Lecture 21: Predicate Logic'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '## Syntax'
  prefs: []
  type: TYPE_NORMAL
- en: 'In propositional logic, the statements we are proving are completely abstract.
    To be able to prove programs correct, we need a logic that can talk about the
    things that programs compute on: integers, strings, tuples, datatype constructors,
    and functions. We''ll enrich propositional logic with the ability to talk about
    these things, obtaining a version of **predicate logic**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax extends propositional logic with a few new expressions, shown in
    blue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Terms t stand for individual elements of some domain of objects we are reasoning
    about, such as the natural numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The formula ∀x.f means that the formula f is true for any choice of x. This
    is called **universal quantification**, and ∀ is the **universal quantifier**.
    The formula ∃x.f denotes **existential quantification**. It means that the formula
    f is true for some choice of x, though there may be more than one such x.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to restrict the range of quantifiers to quantify over some subset
    of the domain of possible values. For universal quantifiers, we use an implication
    ⇒, and for existential quantifiers, we use conjunction ∧. For example, if we wanted
    to say that all *positive* numbers x satisfy some property Q(x), we could write
    ∀x.x > 0 ⇒ Q(x). This works because the quantified formula is vacuously true for
    numbers not greater than 0\. To say that there exists a positive number that satisfies
    Q, we can write ∃x.x > 0 ∧ Q(x).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using quantifiers, we can express some interesting statements. For example,
    we can express the idea that a number n is prime in various logically equivalent
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Prime(n) | ⇔ | ∀m. 1 < m ∧ m < n ⇒ ¬∃k. k*m = n |'
  prefs: []
  type: TYPE_TB
- en: '|   | ⇔ | ¬∃m. 1 < m ∧ m < n ∧ ∃k. k*m = n |'
  prefs: []
  type: TYPE_TB
- en: '|  | ⇔ | ¬∃m. ∃k. 1 < m ∧ m < n ∧ k*m = n |'
  prefs: []
  type: TYPE_TB
- en: Rules for Quantifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduction and elimination rules can be defined for universal and existential
    quantifiers. In the following rules, f(t) refers to f(x) with all free occurrences
    of the variable x replaced by the term t.
  prefs: []
  type: TYPE_NORMAL
- en: '| rule name | rule | intuition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ∀ | intro |  | (*) This rule can only be applied if x does not occur free
    in Γ.We can conclude that f holds for all x if we choose an **arbitrary** x and
    prove f(x). |'
  prefs: []
  type: TYPE_TB
- en: '| elim |  | If we''ve proven f holds for all x, we can conclude that f holds
    for any given t. |'
  prefs: []
  type: TYPE_TB
- en: '| ∃ | intro |  | We can prove that there exists some x with property f by simply
    producing a t with property f. |'
  prefs: []
  type: TYPE_TB
- en: '| elim |  | (*) this rule can be applied only if a does not occur free in Γ
    or g.This is like ∨ elimination — we can only conclude something from the existence
    of an x if the conclusion g doesn''t depend on which x satisfies f. |'
  prefs: []
  type: TYPE_TB
- en: The rule (∀-elim) specializes the formula f(x) to a particular value t of x.
    (We require implicitly that t be of the right type to be substituted for x.) Since
    f holds for all x, it should hold for any particular choice of x, including t.
    The (∀-intro) rule formalizes the type of argument that starts, "Let a be an arbitrary
    element..." If one can prove a fact f(a) for arbitrarily chosen a, then f(x) holds
    for all x.
  prefs: []
  type: TYPE_NORMAL
- en: The rule (∃-intro) derives ∃x.f(x) because a **witness** t to the existential
    has been produced. Intuitively, if f(t) holds for some t, then certainly there
    exists an x such that P(x) holds. The idea behind rule (∃-elim) is that if g can
    be shown without using any information about the witness x other than f(x), then
    the mere existence of an element satisfying f is enough to imply g.
  prefs: []
  type: TYPE_NORMAL
- en: 'The proviso (*) in the (∀-intro) and (∃-elim) rules is a restriction on the
    use of the rule. This restriction prevents us from doing unsound reasoning like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This proof says that if a particular x is greater than 10, then every x is
    greater than 10, something that is clearly false! The problem is the use of ∀-intro:
    we are able to prove that x > 10, but not for an arbitrary x, only for the particular
    x we had already made assumptions about.'
  prefs: []
  type: TYPE_NORMAL
- en: However, it is fine for the variable a to appear in an assumption that is made
    *after* the point where (∀-intro) is applied. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In automated proof assistants that allow a user to develop natural deduction
    proofs by subgoaling, proofs are generated from bottom to top. In such systems,
    the proviso (*) can be enforced by generating a fresh variable a when either (∀-intro)
    or (∃-elim) is applied.
  prefs: []
  type: TYPE_NORMAL
- en: Reasoning with Equality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Predicate logic allows the use of arbitary predicates P. Equality (=) is such
    a predicate. It applies to two arguments; we can read t[1]=t[2] as a predicate
    =(t[1],t[2]). But in addition to the rules above for arbitrary predicates, equality
    has some special properties. The following three rules capture that equality is
    an **equivalence relation**: it is reflexive, symmetric, and transitive.'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;   &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; t = t &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '| (reflexivity) |'
  prefs: []
  type: TYPE_TB
- en: '&#124; t[1] = t[2] &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; t[2] = t[1] &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '| (symmetry) |'
  prefs: []
  type: TYPE_TB
- en: '&#124; t[1] = t[2] &#124; t[2] = t[3] &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; t[1] = t[3] &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '| (transitivity) |'
  prefs: []
  type: TYPE_TB
- en: 'Beyond being an equivalence relation, equality preserves meaning under substitution.
    If two things are equal, substituting one for the other in equal terms results
    in equal terms. This is known as Leibniz''s rule (substitution of equals for equals):'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; t[1] = t[2] &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; t{t[1]/x} = t{t[2]/x} &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Leibniz''s rule can also be applied to show propositions are logically equivalent
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; t = t'' &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; P{t/x} ⇔ P{t''/x} &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we know y = x+1 and x(x+1)+(x+1) = (x+1)². Then we can
    use this rule to prove xy+(x+1) = y² by applying this rule with t = x+1, t' =
    y, and P = (xz+(x+1) = z²).
  prefs: []
  type: TYPE_NORMAL
- en: The same idea can be applied completely at the propositional level as well.
    If we can prove that two formulas are equivalent, they can be substituted for
    one another within any other formula.
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; Q ⇔ R &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; P{Q/A} ⇔ P{R/A} &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This admissible rule can be very convenient for writing proofs, though anything
    we can prove with it can be proved using just the basic rules. It can be very
    handy when there is a large library of logical equivalences to draw upon, because
    it allows rewriting of deeply nested subformulas.
  prefs: []
  type: TYPE_NORMAL
- en: Reasoning on Integers and Other Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For reasoning about specific kinds of values, we need axioms that describe how
    those values behave. For example, the following axioms partly describe the integers
    and can be used to prove many facts about integers. In fact, they define a more
    general structure, a **commutative ring**, so anything proved with them holds
    for any commutative ring. These axioms are all considered to be implicitly universally
    quantified.
  prefs: []
  type: TYPE_NORMAL
- en: '| (x+y)+z = x+(y+z) | (associativity of +) |'
  prefs: []
  type: TYPE_TB
- en: '| x+y = y+x | (commutativity of +) |'
  prefs: []
  type: TYPE_TB
- en: '| (x*y)*z = x*(y*z) | (associativity of *) |'
  prefs: []
  type: TYPE_TB
- en: '| x*y = y*x | (commutativity of *) |'
  prefs: []
  type: TYPE_TB
- en: '| x*(y+z) = x*y+x*z | (distributivity of * over +) |'
  prefs: []
  type: TYPE_TB
- en: '| x + 0 = x | (additive identity) |'
  prefs: []
  type: TYPE_TB
- en: '| x + (-x) = 0 | (additive inverse) |'
  prefs: []
  type: TYPE_TB
- en: '| x*1 = x | (multiplicative identity) |'
  prefs: []
  type: TYPE_TB
- en: '| x*0 = 0 | (annihilation) |'
  prefs: []
  type: TYPE_TB
- en: 'These rules use a number of functions: +, *, -, 0, and 1 (we can think of 0
    and 1 as functions that take zero arguments). These symbols are represented by
    the metavariable f in the grammar earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Proving facts about arithmetic can be tedious. For our purposes, we will write
    proofs that do reasonable algebraic manipulations as a single step, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (x+2)² = 2*x &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; x² = −2*x−4 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '| (algebra) |'
  prefs: []
  type: TYPE_TB
- en: This proof step can be done explicitly using the rules and axioms above, but
    it takes several steps.
  prefs: []
  type: TYPE_NORMAL
