- en: Special Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `if` Clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although we have done some exercises using `if` in the previous lesson, here
    is the general structure of the special form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`if` is a special form, since it will not evaluate its arguments unless it
    is used. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The last example shows why `if` needs to be a special form. Since `(= 1 1)`
    evaluates to `#t`, we never reach the else case, `(/ 1 0)`, and successfully return
    `'foobar`.
  prefs: []
  type: TYPE_NORMAL
- en: The `cond` Clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to nest `if` expressions within itself, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful for conditionals with many clauses. But, the more clauses, the
    messier and less readable your code becomes. A shorthand for nested `if`s is the
    `cond` clause, which uses different syntax to complete the same task. Here''s
    the `roman-value` function written using a `cond` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `cond` clause lets you specify a series of conditions and
    possible values. The `else` clause at the end specifies the value to return when
    none of the previous predicates are true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Translated into English, the above code reads:'
  prefs: []
  type: TYPE_NORMAL
- en: If the input letter is "i", the value is 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the input letter is "v", the value is 5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the input letter is "m", the value is 1000.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, when none of the above are true, the value is `'huh?`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The general structure of a `cond` clause is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Special Forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Special forms are procedures that do not follow normal evaluation steps. We
    learned earlier that all arguments within an expression are evaluated *before*
    the procedure is applied to its arguments. This is not true with special forms.
    Of the predicates and clauses we've gone over so far, `if`, `cond`, `or`, and
    `and` are all special forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: The following expressions currently error. Rearrange their arguments in a way
    that will cause the expressions to not error and return the correct value. Do
    not change any argument values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we decided to write our own `if` procedure called `new-if` and defined
    it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This should work exactly like `if`, since it's simply calling `if` in the body.
    But, **since this is a compound procedure, it is not a special form**. What happens
    when we call `new-if` like this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Since `new-if` is not a special form, it will evaluate all of its arguments
    first before entering the body.
  prefs: []
  type: TYPE_NORMAL
- en: '`(= 1 1)` returns `#t`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''foo` returns `''foo`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(/ 1 0)` returns-- wait a second...'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And since `(/ 1 0)` errors, our `new-if` is a failed attempt to recreate the
    `if` special form.
  prefs: []
  type: TYPE_NORMAL
- en: '`if` is Composable'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To save time and code space, keep in mind that functions like `if` and `cond`
    can be used within an expression, instead of being a stand-alone expression. To
    demonstrate this, consider the following simple function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we can rewrite it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Admittedly, there doesn’t seem to be much of a difference. It’s understandable,
    considering this is a simple function. When this technique is used in more complex
    functions, we save time by avoiding repetition. We can see above how the rewritten
    function only writes `'(i am a)` once, while the original definition writes it
    twice.
  prefs: []
  type: TYPE_NORMAL
- en: Pitfalls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The structure of a `cond` statement has very strict parenthetical rules. If
    you're code is erroring, it is very likely you missed a parenthesis or added an
    extra one. Thus, ***PAY ATTENTION TO PARENTHESES WHEN USING COND STATEMENTS!***
  prefs: []
  type: TYPE_NORMAL
- en: 'Another issue is that `and` and `or` cannot be used as if they were in English.
    To clarify, suppose we have an expression that attempts to check whether an argument
    was either `''yes` or `''no`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is WRONG. `or` returns the first argument that is not false, and thus
    will return `''yes` in this example. This expression ultimately is evaluated as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to check if the argument is *either* `''yes` or `''no`, you will
    need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Last, but definitely not least, it is essential to avoid redundant code. Simple
    code is smart code, and will make complex programs much more readable and maneuverable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example of redundant code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is bad coding style. We can simplify this into just one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** This is Exercise 3 on your Homework.'
  prefs: []
  type: TYPE_NORMAL
- en: Write a procedure `indef-article` that takes in a word as its only argument
    and returns a sentence. See examples below for how `indef-article` should work.
    Remember that the indefinite article for anything that starts with a consonant
    is "a", and the indefinite article for anything that starts with a vowel is "an".
    You can ignore any edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
