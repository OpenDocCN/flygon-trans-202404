- en: Defining Variables and Procedures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a language in which we cannot use names to refer to computational objects.
    As we write more and more complex programs, keeping track of the details of each
    step of computation would get increasingly difficult and inconvenient. Thus, we
    assign *values*, which are the computational object, to *variables*, identified
    by a name, by using `define`. This is Racket's simplest means of [abstraction](/textbook/intro-to-computer-science.html#sub1).
  prefs: []
  type: TYPE_NORMAL
- en: Though you have seen various variable and procedure definitions scattered throughout
    the previous sections, we have not yet formally taught how to use `define`.
  prefs: []
  type: TYPE_NORMAL
- en: To start off, here are a few example expressions that use `define`. Try these
    out in the Racket interpreter to see what they do.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Defining Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The general form of a **variable definition** is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `[name]` represents a **variable** to which **values** are assigned to.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`x` is a variable, and `5` is its value.'
  prefs: []
  type: TYPE_NORMAL
- en: '`[value]` can be replaced with any type of value, even expressions. An important
    property of variable definitions is that **the value of the definition is completely
    evaluated before being assigned to its variable**.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Why is `x` not `(+ 5 5)`? Because when we define `x`, we must first evaluate
    the expression `(+ 5 5)` to its simplest form, `10`. We then assign `10` to `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: What happens when we call `(define x (/ 1 0))`?
  prefs: []
  type: TYPE_NORMAL
- en: Defining Compound Procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Procedure definition** is an even more powerful abstraction technique than
    variable definition, in which we can give a name to a compound operation and consequently
    refer to it as a unit. Let''s start with a simple example by defining the `square`
    procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can understand this in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The general form of a procedure definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how a significant difference this has from a variable definition is
    that the name and parameters are bound by parentheses. Recall that, besides quotes,
    **a set of parentheses represents a procedure call**. We can translate this by
    saying: When we call `[name]` with `[formal parameters]`, we will do `[body]`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: A compound procedure can have any non-negative number of formal parameters,
    even 0\. How do we correctly define a procedure named `foo` that takes in no arguments,
    and returns `5`?
  prefs: []
  type: TYPE_NORMAL
- en: An important property of procedure definitions is that **the body of the procedure
    is not evaluated until the procedure is called**. This means that when we define
    `square`, we do not yet know that we need to multiply `x` by itself. Only when
    we call `square` on some number, say `3`, do we know that we have to call `(*
    3 3)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: What happens when we call `(define (x) (/ 1 0))`?
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One thing to pay attention to when creating compound procedures is naming.
    We need to be very careful when naming our procedures and formal parameters. Racket
    will not accept multiple definitions, which means that any procedure already defined
    cannot be used as the name of a compound procedure or a formal parameter. This
    is an example of a compound procedure definition that is NOT ALLOWED (try it in
    your interpreter to see why):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In both instances in the body, which `word` are we referring to, the parameter
    or the built-in procedure?
  prefs: []
  type: TYPE_NORMAL
- en: Nesting Procedures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Returning to the concept of nesting expressions, we can also nest procedures
    within other procedure definitions. As you did in Homework 0-1, we can define
    the procedure `sum-of-squares` by using the procedure `square` in its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This roughly translates to: When we call `sum-of-squares` on `x` and `y`, we
    will add the `square` of `x` to the `square` of `y`.'
  prefs: []
  type: TYPE_NORMAL
- en: A Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To clarify,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is a variable definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foo` is the variable name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10` is the value assigned to `foo`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is a compound procedure definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`square` is the procedure name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` is its only formal parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(* x x)` is its body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is an expression, and is also a procedure call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`square` is the procedure, and is the operator of this expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3` is the argument to `square`, and is the operand of this expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`9` is the return value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned that we can use `define` as a means of abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also learned how to define variables and compound procedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possibility of associating values and operations to symbols and later retrieving
    them means that the Racket interpreter must have some form of memory to keep track
    of these associative pairs. We call this memory the *environment*, which we will
    expand more on in Lesson 8.
  prefs: []
  type: TYPE_NORMAL
