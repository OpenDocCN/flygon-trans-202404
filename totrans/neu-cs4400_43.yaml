- en: Recursion, Recursion, RecursionTuesday, February 14th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PLAI §9](plai.pdf#chapter.9 "Understanding Recursion")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There is one major feature that is still missing from our language: we have
    no way to perform recursion (therefore no kind of loops). So far, we could only
    use recursion when we had *names*. In FLANG, the only way we can have names is
    through `with` which not good enough for recursion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To discuss the issue of recursion, we switch to a “broken” version of (untyped)
    Racket — one where a `define` has a different scoping rules: the scope of the
    defined name does *not* cover the defined expression. Specifically, in this language,
    this doesn’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In our language, this translation would also not work (assuming we have `if`
    etc):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And similarly, in plain Racket this won’t work if `let` is the only tool you
    use to create bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the broken-scope language, the `define` form is more similar to a mathematical
    definition. For example, when we write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: it is actually shorthand for
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'we can then replace defined names with their definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'and this can go on, until we get to the actual code that we wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the above `fact` definition is similar to writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: which is not a well-formed definition — it is *meaningless* (this is a formal
    use of the word “meaningless”). What we’d really want, is to take the *equation*
    (using `=` instead of `:=`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: and find a solution which will be a value for `fact` that makes this true.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the Racket evaluation rules handout on the web page, you will
    see that this problem is related to the way that we introduced the Racket `define`:
    there is a hand-wavy explanation that talks about *knowing* things.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The big question is: can we define recursive functions without Racket’s magical
    `define` form?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: This question is a little different than the question of implementing
    recursion in our language — in the Racket case we have no control over the implementation
    of the language. As it will eventually turn out, implementing recursion in our
    own language will be quite easy when we use mutation in a specific way. So the
    question that we’re now facing can be phrased as either “can we get recursion
    in Racket without Racket’s magical definition forms?” or “can we get recursion
    in our interpreter without mutation?”.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
