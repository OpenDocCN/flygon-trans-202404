- en: '8Mutation: Structures and Variables'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8Mutation: 结构和变量'
- en: It’s time for another
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 又到了另一个
- en: Which of these is the same?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中哪些是相同的？
- en: f = 3
  id: totrans-3
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: f = 3
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-5
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: o.f = 3
  id: totrans-6
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: o.f = 3
- en: ''
  id: totrans-7
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-8
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: f = 3
  id: totrans-9
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: f = 3
- en: 'Assuming all three are in Java, the first and third could behave exactly like
    each other or exactly like the second: it all depends on whether f is a local
    identifier (such as a parameter) or a field of the object (i.e., the code is really
    this.f = 3).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这三个都是在 Java 中，第一个和第三个可能会像第二个一样完全相同，或者完全像第二个一样：这完全取决于 f 是一个局部标识符（例如参数）还是对象的字段（即，代码实际上是
    this.f = 3）。
- en: 'In either case, we are asking the evaluator to permanently change the value
    bound to f. This has important implications for other observers. Until now, for
    a given set of inputs, a computation always returned the same value. Now, the
    answer depends on when it was invoked: above, it depends on whether it was invoked
    before or after the value of f was changed. The introduction of time has profound
    effects on reasoning about programs.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，我们都要求评估器永久更改绑定到 f 的值。这对其他观察者有重要的影响。直到现在，对于给定的一组输入，计算始终返回相同的值。现在，答案取决于何时调用它：在上面，它取决于在
    f 的值更改之前还是之后调用了它。时间的引入对于关于程序的推理有深远的影响。
- en: However, there are really two quite different notions of change buried in the
    uniform syntax above. Changing the value of a field (o.f = 3 or this.f = 3) is
    extremely different from changing that of an identifier (f = 3 where f is bound
    inside the method, not by the object). We will explore these in turn. We’ll tackle
    fields below, and return to identifiers in [Variables](#(part._mut-vars)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，上述统一语法中实际上有两种完全不同的更改概念。更改字段的值（o.f = 3 或 this.f = 3）与更改标识符的值（f = 3，其中 f 是在方法内部绑定的，而不是由对象绑定的）极为不同。我们将依次探讨这些。我们将在下文中处理字段，并在[Variables](#(part._mut-vars))中返回标识符。
- en: 8.1Mutable Structures
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1可变结构
- en: 8.1.1A Simple Model of Mutable Structures
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1可变结构的简单模型
- en: 'Objects are a generalization of structures, as we will soon see [REF]. Therefore,
    fields in objects are a generalization of fields in structures and to understand
    mutation, it is mostly (but not entirely! [REF]) sufficient to understand mutable
    objects. To be even more reductionist, we don’t need a structure to have many
    fields: a single one will suffice. We call this a box. In Racket, boxes support
    just three operations:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是结构的泛化，我们很快就会看到 [REF]。因此，对象中的字段是结构中字段的泛化，并且为了理解突变，大多数情况下（但不完全是！[REF]）理解可变对象就足够了。为了更加简化，我们不需要一个结构有很多字段：一个字段就足够了。我们称之为箱子。在
    Racket 中，箱子仅支持三种操作：
- en: '| box : (''a -> (boxof ''a)) |'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| box : (''a -> (boxof ''a)) |'
- en: '| unbox : ((boxof ''a) -> ''a) |'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| unbox : ((boxof ''a) -> ''a) |'
- en: '| set-box! : ((boxof ''a) ''a -> void) |'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| set-box! : ((boxof ''a) ''a -> void) |'
- en: 'Thus, box takes a value and wraps it in a mutable container. unbox extracts
    the current value inside the container. Finally, set-box! changes the value in
    the container, and in a typed language, the new value is expected to be type-consistent
    with what was there before. You can thus think of a box as equivalent to a Java
    container class with parameterized type, which has a single member field with
    a getter and setter: box is the constructor, unbox is the getter, and set-box!
    is the setter. (Because there is only one field, its name is irrelevant.)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，box 接受一个值并将其包装在可变容器中。unbox 提取容器内的当前值。最后，set-box! 更改容器中的值，在类型化语言中，新值应与之前的类型一致。因此，您可以将箱子视为等同于具有参数化类型的
    Java 容器类，该类具有具有获取器和设置器的单个成员字段：box 是构造函数，unbox 是获取器，而 set-box! 是设置器。（因为只有一个字段，它的名称无关紧要。）
- en: '| class Box<T> { |'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| class Box<T> { |'
- en: '|     private T the_value; |'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     private T the_value; |'
- en: '|     Box(T v) { |'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     Box(T v) { |'
- en: '|         this.the_value = v; |'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         this.the_value = v; |'
- en: '|     } |'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     } |'
- en: '|     T get() { |'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     T get() { |'
- en: '|         return the_value; |'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         return the_value; |'
- en: '|     } |'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     } |'
- en: '|     void set(T v) { |'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     void set(T v) { |'
- en: '|         the_value = v; |'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         the_value = v; |'
- en: '|     } |'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     } |'
- en: '| } |'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| } |'
- en: Because we must sometimes mutate in groups (e.g., removing money from one bank
    account and depositing it in another), it is useful to be able to sequence a group
    of mutable operations. In Racket, begin lets you write a sequence of operations;
    it evaluates them in order and returns the value of the last one.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们有时必须以组的形式进行突变（例如，从一个银行帐户中取钱并将其存入另一个帐户），因此能够对一组可变操作进行排序是有用的。在 Racket 中，begin
    允许您编写一系列操作；它按顺序评估它们并返回最后一个的值。
- en: Exercise
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Define begin by desugaring into let (and hence into lambda).
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过解糖为 let（因此转换为 lambda）来定义 begin。
- en: This is an excellent illustration of the non-canonical nature of desguaring.
    We’ve chosen to add to the core a construct that is certainly not necessary. If
    our goal was to shrink the size of the interpreter—<wbr>perhaps at some cost to
    the size of the input program—<wbr>we would not make this choice. But our goal
    in this book is to study pedagogic interpreters, so we choose a larger language
    because it is more instructive. Even though it is possible to eliminate begin
    as syntactic sugar, it will prove extremely useful for understanding how mutation
    works. Therefore, we will add a simple, two-term version of sequencing to the
    core.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非规范desguaring的绝佳示例。我们选择向核心添加一个明显不必要的构造。如果我们的目标是缩小解释器的大小——也许会增加输入程序的大小——我们不会做出这个选择。但是我们在本书中的目标是研究教学解释器，因此我们选择一个更大的语言，因为这更具教育意义。尽管可以消除begin作为语法糖，但它将非常有助于理解突变是如何工作的。因此，我们将在核心中添加一个简单的、两项的序列版本。
- en: 8.1.2Scaffolding
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2搭脚手架
- en: 'First, let’s extend our core language datatype:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们扩展我们的核心语言数据类型：
- en: '| (define-type ExprC |'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type ExprC |'
- en: '|   [numC (n : number)] |'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [numC (n : number)] |'
- en: '|   [idC (s : symbol)] |'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [idC (s : symbol)] |'
- en: '|   [appC (fun : ExprC) (arg : ExprC)] |'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [appC (fun : ExprC) (arg : ExprC)] |'
- en: '|   [plusC (l : ExprC) (r : ExprC)] |'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [plusC (l : ExprC) (r : ExprC)] |'
- en: '|   [multC (l : ExprC) (r : ExprC)] |'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [multC (l : ExprC) (r : ExprC)] |'
- en: '|   [lamC (arg : symbol) (body : ExprC)] |'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [lamC (arg : symbol) (body : ExprC)] |'
- en: '|   [boxC (arg : ExprC)] |'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [boxC (arg : ExprC)] |'
- en: '|   [unboxC (arg : ExprC)] |'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [unboxC (arg : ExprC)] |'
- en: '|   [setboxC (b : ExprC) (v : ExprC)] |'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [setboxC (b : ExprC) (v : ExprC)] |'
- en: '|   [seqC (b1 : ExprC) (b2 : ExprC)]) |'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [seqC (b1 : ExprC) (b2 : ExprC)]) |'
- en: 'Observe that in a setboxC expression, both the box position and its new value
    are expressions. The latter is unsurprising, but the former might be. It means
    we can write programs such as this in corresponding Racket:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到在setboxC表达式中，盒子位置和其新值都是表达式。后者并不奇怪，但前者可能会让人感到意外。这意味着我们可以在对应的Racket中编写这样的程序：
- en: '| (let ([b0 (box 0)] |'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([b0 (box 0)] |'
- en: '|       [b1 (box 1)]) |'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       [b1 (box 1)]) |'
- en: '|   (let ([l (list b0 b1)]) |'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (let ([l (list b0 b1)]) |'
- en: '|     (begin |'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (begin |'
- en: '|       (set-box! (first l) 1) |'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (set-box! (first l) 1) |'
- en: '|       (set-box! (second l) 2) |'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (set-box! (second l) 2) |'
- en: '|       l))) |'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       l))) |'
- en: 'This evaluates to a list of boxes, the first containing 1 and the second 2.Your
    output may look like ’(#&1 #&2). The #& notation is Racket’s abbreviated syntactic
    prefix for “box”. Observe that the first argument to the first set-box! instruction
    was (first l), i.e., an expression that evaluated to a box, rather than just a
    literal box or an identifier. This is precisely analogous to languages like Java,
    where one can (taking some type liberties) write'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '这将计算出一个包含1和2的盒子列表。你的输出可能看起来像''(#&1 #&2)。#&符号是Racket的缩写语法前缀，表示“盒子”。观察到第一个set-box!指令的第一个参数是(first
    l)，即一个计算结果为盒子的表达式，而不仅仅是一个文字盒子或标识符。这与诸如Java之类的语言完全类似，其中可以（在某种类型的自由度下）编写'
- en: '| public static void main (String[] args) { |'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| public static void main (String[] args) { |'
- en: '|     Box<Integer> b0 = new Box<Integer>(0); |'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     Box<Integer> b0 = new Box<Integer>(0); |'
- en: '|     Box<Integer> b1 = new Box<Integer>(1); |'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     Box<Integer> b1 = new Box<Integer>(1); |'
- en: '|   |'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '|     ArrayList<Box<Integer>> l = new ArrayList<Box<Integer>>(); |'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     ArrayList<Box<Integer>> l = new ArrayList<Box<Integer>>(); |'
- en: '|     l.add(b0); |'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     l.add(b0); |'
- en: '|     l.add(b1); |'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     l.add(b1); |'
- en: '|   |'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '|     l.get(0).set(1); |'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     l.get(0).set(1); |'
- en: '|     l.get(1).set(2); |'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     l.get(1).set(2); |'
- en: '| } |'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| } |'
- en: Observe that l.get(0) is a compound expression being used to find the appropriate
    box, and evaluates to the box object on which set is invoked.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到l.get(0)是一个复合表达式，用于找到适当的盒子，并计算出在其上调用set的盒子对象。
- en: For convenience, we will assume that we have implemented desguaring to provide
    us with (a) let and (b) if necessary, more than two terms in a sequence (which
    can be desugared into nested sequences). We will also sometimes write expressions
    in the original Racket syntax, both for brevity (because the core language terms
    can grow quite large and unwieldy) and so that you can run these same terms in
    Racket and observe what answers they produce. As this implies, we are taking the
    behavior in Racket—<wbr>which is similar to the behavior in just about every mainstream
    language with mutable objects and structures—<wbr>as the reference behavior.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为方便起见，我们假设已经实现了解糖功能，提供了（a）let 和（b）在序列中超过两个项时必要的功能（这些可以被解糖为嵌套序列）。我们有时也会用原始的 Racket
    语法编写表达式，这样做既是为了简洁（因为核心语言术语可能变得相当庞大和笨重），也是为了您可以在 Racket 中运行相同的术语并观察它们产生的答案。由此可见，我们将
    Racket 中的行为——<wbr>这与几乎所有支持可变对象和结构的主流语言中的行为类似——视为参考行为。
- en: 8.1.3Interaction with Closures
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3与闭包的交互
- en: 'Consider a simple counter:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的计数器：
- en: '| (define new-loc |'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define new-loc |'
- en: '|   (let ([n (box 0)]) |'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (let ([n (box 0)]) |'
- en: '|     (lambda () |'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (lambda () |'
- en: '|       (begin |'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (begin |'
- en: '|         (set-box! n (add1 (unbox n))) |'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         (set-box! n (add1 (unbox n))) |'
- en: '|         (unbox n))))) |'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         (unbox n))))) |'
- en: 'Every time it is invoked, it produces the next integer:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用它时，它都会产生下一个整数：
- en: '| > (new-loc) |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| > (new-loc) |'
- en: '| - number |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| - number |'
- en: '| 1 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 1 |'
- en: '| > (new-loc) |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| > (new-loc) |'
- en: '| - number |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| - number |'
- en: '| 2 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 2 |'
- en: 'Why does this work? It’s because the box is created only once, and bound to
    n, and then closed over. All subsequent mutations affect the same box. In contrast,
    swapping two lines makes a big difference:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么有效？因为盒子只创建一次，并绑定到 n，然后关闭。所有后续的变异都影响同一个盒子。相反，交换两行会产生很大的不同：
- en: '| (define new-loc-broken |'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define new-loc-broken |'
- en: '|   (lambda () |'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (lambda () |'
- en: '|     (let ([n (box 0)]) |'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (let ([n (box 0)]) |'
- en: '|       (begin |'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (begin |'
- en: '|         (set-box! n (add1 (unbox n))) |'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         (set-box! n (add1 (unbox n))) |'
- en: '|         (unbox n))))) |'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         (unbox n))))) |'
- en: 'Observe:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 观察：
- en: '| > (new-loc-broken) |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| > (new-loc-broken) |'
- en: '| - number |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| - number |'
- en: '| 1 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 1 |'
- en: '| > (new-loc-broken) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| > (new-loc-broken) |'
- en: '| - number |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| - number |'
- en: '| 1 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 1 |'
- en: In this case, a new box is allocated on every invocation of the function, so
    the answer each time is the same (despite the mutation inside the procedure).
    Our implementation of boxes should be certain to preserve this distinction.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每次调用函数时都会分配一个新的盒子，因此每次答案都相同（尽管过程内部发生了变异）。我们的盒子实现应确保保留此区别。
- en: 'The examples above hint at an implementation necessity. Clearly, whatever the
    environment closes over in new-loc must refer to the same box each time. Yet something
    also needs to make sure that the value in that box is different each time! Look
    at it more carefully: it must be lexically the same, but dynamically different.
    This distinction will be at the heart of our implementation.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例暗示了实施必要性。显然，无论 new-loc 中的环境闭合多少次，都必须每次都引用同一个盒子。然而，还需要确保该盒子中的值每次都不同！仔细看看：它在词法上必须是相同的，但在动态上不同。这种区别将是我们实现的核心。
- en: 8.1.4Understanding the Interpretation of Boxes
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.4理解盒子的解释
- en: 'Let’s begin by reproducing our current interpreter:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从复制我们当前的解释器开始：
- en: '[<interp-take-1>](#(elem._(chunk._~3cinterp-take-1~3e~3a1))) ::='
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[<interp-take-1>](#(elem._(chunk._~3cinterp-take-1~3e~3a1))) ::='
- en: '| (define (interp [expr : ExprC] [env : Env]) : Value |'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (interp [expr : ExprC] [env : Env]) : Value |'
- en: '|   (type-case ExprC expr |'
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (type-case ExprC expr |'
- en: '|     [numC (n) (numV n)] |'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [numC (n) (numV n)] |'
- en: '|     [idC (n) (lookup n env)] |'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [idC (n) (lookup n env)] |'
- en: '|     [appC (f a) (local ([define f-value (interp f env)]) |'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [appC (f a) (local ([define f-value (interp f env)]) |'
- en: '|                   (interp (closV-body f-value) |'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                   (interp (closV-body f-value) |'
- en: '|                           (extend-env (bind (closV-arg f-value) |'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                           (extend-env (bind (closV-arg f-value) |'
- en: '|                                             (interp a env)) |'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                             (interp a env)) |'
- en: '|                                       (closV-env f-value))))] |'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                       (closV-env f-value))))] |'
- en: '|     [plusC (l r) (num+ (interp l env) (interp r env))] |'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [plusC (l r) (num+ (interp l env) (interp r env))] |'
- en: '|     [multC (l r) (num* (interp l env) (interp r env))] |'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [multC (l r) (num* (interp l env) (interp r env))] |'
- en: '|     [lamC (a b) (closV a b env)] |'
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [lamC (a b) (closV a b env)] |'
- en: '|     <boxC-case> |'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     <boxC-case> |'
- en: '|     <unboxC-case> |'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     <unboxC-case> |'
- en: '|     <setboxC-case> |'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     <setboxC-case> |'
- en: '|     <seqC-case>)) |'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     <seqC-case>)) |'
- en: 'Because we’ve introduced a new kind of value, the box, we have to update the
    set of values:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们引入了一种新的值类型，盒子，我们必须更新值集合：
- en: '[<value-take-1>](#(elem._(chunk._~3cvalue-take-1~3e~3a1))) ::='
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[<value-take-1>](#(elem._(chunk._~3cvalue-take-1~3e~3a1))) ::='
- en: '| (define-type Value |'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type Value |'
- en: '|   [numV (n : number)] |'
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [numV (n : number)] |'
- en: '|   [closV (arg : symbol) (body : ExprC) (env : Env)] |'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [closV (arg : symbol) (body : ExprC) (env : Env)] |'
- en: '|   [boxV (v : Value)]) |'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [boxV (v : Value)]) |'
- en: 'Two of these cases should be easy. When we’re given a box expression, we simply
    evaluate it and return it wrapped in a boxV:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种情况应该很容易。当我们得到一个盒子表达式时，我们只需评估它并将其包装在 boxV 中返回：
- en: '[<boxC-case-take-1>](#(elem._(chunk._~3cbox.C-case-take-1~3e~3a1))) ::='
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[<boxC-case-take-1>](#(elem._(chunk._~3cbox.C-case-take-1~3e~3a1))) ::='
- en: '[boxC (a) (boxV (interp a env))]'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[boxC (a) (boxV (interp a env))]'
- en: 'Similarly, extracting a value from a box is easy:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，从盒子中提取值很容易：
- en: '[<unboxC-case-take-1>](#(elem._(chunk._~3cunbox.C-case-take-1~3e~3a1))) ::='
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[<unboxC-case-take-1>](#(elem._(chunk._~3cunbox.C-case-take-1~3e~3a1))) ::='
- en: '[unboxC (a) (boxV-v (interp a env))]'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[unboxC (a) (boxV-v (interp a env))]'
- en: By now, you should be constructing a healthy set of test cases to make sure
    these behave as you’d expect.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该正在构建一组健康的测试用例，以确保它们的行为符合您的预期。
- en: Of course, we haven’t done any hard work yet. All the interesting behavior is,
    presumably, hidden in the treatment of setboxC. It may therefore surprise you
    that we’re going to look at seqC first instead (and you’ll see why we included
    it in the core).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还没有做任何艰苦的工作。所有有趣的行为可能隐藏在 setboxC 的处理中。因此，您可能会感到惊讶，我们将首先查看 seqC（您将看到为什么我们将其包含在核心中）。
- en: 'Let’s take the most natural implementation of a sequence of two instructions:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑两个指令序列的最自然实现：
- en: '[<seqC-case-take-1>](#(elem._(chunk._~3cseq.C-case-take-1~3e~3a1))) ::='
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[<seqC-case-take-1>](#(elem._(chunk._~3cseq.C-case-take-1~3e~3a1))) ::='
- en: '| [seqC (b1 b2) (let ([v (interp b1 env)]) |'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [seqC (b1 b2) (let ([v (interp b1 env)]) |'
- en: '|                 (interp b2 env))] |'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 (interp b2 env))] |'
- en: That is, we evaluate the first term, then the second, and return the result
    of the second.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们首先评估第一个术语，然后是第二个术语，并返回第二个的结果。
- en: 'You should immediately spot something troubling. We bound the result of evaluating
    the first term, but didn’t subsequently do anything with it. That’s okay: presumably
    the first term contained a mutation expression of some sort, and its value is
    uninteresting (indeed, note that set-box! returns a void value). Thus, another
    implementation might be this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该立即发现一些令人不安的事情。我们绑定了评估第一个术语的结果，但随后没有做任何事情。没关系：很可能第一个术语包含某种变异表达式，其值并不重要（实际上，请注意
    set-box！返回一个空值）。因此，另一种实现可能是这样的：
- en: '[<seqC-case-take-2>](#(elem._(chunk._~3cseq.C-case-take-2~3e~3a1))) ::='
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[<seqC-case-take-2>](#(elem._(chunk._~3cseq.C-case-take-2~3e~3a1))) ::='
- en: '| [seqC (b1 b2) (begin |'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [seqC (b1 b2) (begin |'
- en: '|                 (interp b1 env) |'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 (interp b1 env) |'
- en: '|                 (interp b2 env))] |'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 (interp b2 env))] |'
- en: Not only is this slightly dissatisfying in that it just uses the analogous Racket
    sequencing construct, it still can’t possibly be right! This can only work only
    if the result of the mutation is being stored somewhere. But because our interpreter
    only computes values, and does not perform any mutation itself, any mutations
    in (interp b1 env) are completely lost. This is obviously not what we want.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅让人稍感不满，因为它只是使用了类似的 Racket 顺序构造，而且肯定是错误的！只有在变异���结果被存储在某处时，这才能起作用。但是，由于我们的解释器只计算值，并且不执行任何变异操作，因此在（interp
    b1 env）中的任何变异都完全丢失。这显然不是我们想要的。
- en: 8.1.5Can the Environment Help?
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.5环境有助于吗？
- en: 'Here is another example that can help:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一个示例可以帮助：
- en: '| (let ([b (box 0)]) |'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([b (box 0)]) |'
- en: '|   (begin (begin (set-box! b (+ 1 (unbox b))) |'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (begin (begin (set-box! b (+ 1 (unbox b))) |'
- en: '|                 (set-box! b (+ 1 (unbox b)))) |'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 (set-box! b (+ 1 (unbox b)))) |'
- en: '|          (unbox b))) |'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|          (unbox b))) |'
- en: In Racket, this evaluates to 2.Exercise
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Racket 中，这将评估为 2。练习
- en: Represent this expression in ExprC.
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 ExprC 中表示这个表达式。
- en: Let’s consider the evaluation of the inner sequence. In both cases, the expression
    (the representation of (set-box! ...)) is exactly identical. Yet something is
    changing underneath, because these cause the value of the box to go from 0 to
    2! We can “see” this even more clearly if instead we evaluate
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑内部序列的评估。在两种情况下，表达式（（set-box！...）的表示）完全相同。然而，在底层发生了一些变化，因为这些导致盒子的值从 0 变为
    2！如果我们改为评估
- en: '| (let ([b (box 0)]) |'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([b (box 0)]) |'
- en: '|   (+ (begin (set-box! b (+ 1 (unbox b))) |'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (+ (begin (set-box! b (+ 1 (unbox b))) |'
- en: '|             (unbox b)) |'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|             (unbox b)) |'
- en: '|      (begin (set-box! b (+ 1 (unbox b))) |'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (begin (set-box! b (+ 1 (unbox b))) |'
- en: '|             (unbox b)))) |'
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|             (unbox b)))) |'
- en: which evaluates to 3. Here, the two calls to interp in the rule for addition
    are sending exactly the same textual expression in both cases. Yet somehow the
    effects from the left branch of the addition are being felt in the right branch,
    and we must rule out spukhafte Fernwirkung.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处求值为 3。在加法规则中，对 interp 的两次调用在两种情况下都发送完全相同的文本表达式。然而，某种方式上左侧加法分支的影响会在右侧分支产生作用，我们必须排除远距作用。
- en: If the interpreter is being given precisely the same expression, how can it
    possibly avoid producing precisely the same answer? The most obvious way is if
    the interpreter’s other parameter, the environment were somehow different. As
    of now the exact same environment is sent to both both branches of the sequence
    and both arms of the addition, so our interpreter—<wbr>which produces the same
    output every time on a given input—<wbr>cannot possibly produce the answers we
    want.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解释器被给予完全相同的表达式，那么它如何可能避免产生完全相同的答案呢？最明显的方式是，如果解释器的另一个参数，即环境，有所不同。截至目前，完全相同的环境被发送到序列的两个分支和加法的两个分支，因此我们的解释器—对于给定的输入每次都产生相同的输出—不可能产生我们想要的答案。
- en: 'Here is what we know so far:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道以下内容：
- en: We must somehow make sure the interpreter is fed different arguments on calls
    that are expected to potentially produce different results.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须确保解释器在预计可能产生不同结果的调用时被提供不同的参数。
- en: We must return from the interpreter some record of the mutations made when evaluating
    its argument expression.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须在解释器中返回对其参数表达式求值时所做的变异记录。
- en: 'Because the expression is what it is, the first point suggests that we might
    try to use the environment to reflect the differences between invocations. In
    turn, the second point suggests that each invocation of the interpreter should
    also return the environment, so it can be passed to the next invocation. Roughly,
    then, the type of the interpreter might become:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因为表达式是什么样的，第一个观点表明我们可能尝试使用环境来反映调用之间的差异。反过来，第二个观点表明解释器的每次调用还应返回环境，以便传递给下一次调用。大致上，然后，解释器的类型可能变成：
- en: '| ; interp : ExprC * Env -> Value * Env |'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ; interp : ExprC * Env -> Value * Env |'
- en: 'That is, the interpreter consumes an expression and environment; it evaluates
    in that environment, updating it as it proceeds; when the expression is done evaluating,
    the interpreter returns the answer (as it did before), along with an updated environment,
    which in turn is sent to the next invocation of the interpreter. And the treatment
    of setboxC would somehow impact the environment to reflect the mutation.Before
    we dive into the implementation, however, we should consider the consequences
    of such a change. The environment already serves an important purpose: it holds
    deferred substitutions. In that respect, it already has a precise semantics—<wbr>given
    by substitution—<wbr>and we must be careful to not alter that. One consequence
    of its tie to substitution is that it is also the repository of lexical scope
    information. If we were to allow the extended environment escape from one branch
    of addition and be used in the other, for instance, consider the impact on the
    equivalent of the following program:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，解释器接受一个表达式和环境；它在该环境中进行评估，并在进行时更新环境；当表达式完成评估时，解释器返回答案（就像以前一样），以及一个更新后的环境，该环境又被发送到解释器的下一次调用。而
    setboxC 的处理在某种程度上会影响环境以反映变异。然而，在我们深入实现之前，我们应该考虑这种变化的后果。环境已经有一个重要的用途：它保存了延迟的替换。在这方面，它已经有了明确的语义—由替换给出—我们必须小心不要改变它。与替换的联系的一个后果是，它也是词法作用域信息的存储库。例如，如果我们允许扩展环境逃离加法的一个分支并在另一个分支中使用它，请考虑以下程序的影响：
- en: '| (+ (let ([b (box 0)]) |'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (+ (let ([b (box 0)]) |'
- en: '|      1) |'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      1) |'
- en: '|    b) |'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    b) |'
- en: 'It should be evident that this program has an error: b in the right branch
    of the addition is unbound (the scope of the b in the left branch ends with the
    closing of the let—<wbr>if this is not evident, desugar the above expression to
    use functions). But the extended environment at the end of interpreting the let
    clearly has b bound in it.Exercise'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这个程序有一个错误：加法的右侧分支中的 b 是未绑定的（左侧分支中的 b 的作用域在 let 的关闭时结束—如果这不明显，请对上述表达式进行解糖以使用函数）。但在解释
    let 结束时扩展的环境中，b 显然已经被绑定。练习
- en: Work out the above problem in detail and make sure you understand it.
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 详细解决上述问题并确保你理解它。
- en: You could try various other related proposals, but they are likely to all have
    similar failings. For instance, you may decide that, because the problem has to
    do with additional bindings in the environment, you will instead remove all added
    bindings in the returned environment. Sounds attractive? Did you remember we have
    closures?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试各种其他相关的提议，但它们很可能都有类似的缺陷。例如，你可能会决定，由于问题涉及环境中的额外绑定，你将在返回的环境中删除所有添加的绑定。听起来不错？你还记得我们有闭包吗？
- en: Exercise
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'Consider the representation of the following program:'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '考虑以下程序的表示： '
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| (let ([a (box 1)]) |'
  id: totrans-177
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([a (box 1)]) |'
- en: '|   (let ([f (lambda (x) (+ x (unbox a)))]) |'
  id: totrans-178
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (let ([f (lambda (x) (+ x (unbox a)))]) |'
- en: '|     (begin |'
  id: totrans-179
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (begin |'
- en: '|       (set-box! a 2) |'
  id: totrans-180
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (set-box! a 2) |'
- en: '|       (f 10)))) |'
  id: totrans-181
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (f 10)))) |'
- en: ''
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What problems does this example cause?
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个例子会引起什么问题？
- en: Rather, we should note that while the constraints described above are all valid,
    the solution we proposed is not the only one. What we require are the two conditions
    enumerated above; observe that neither one actually requires the environment to
    be the responsible agent. Indeed, it is quite evident that the environment cannot
    be the principal agent.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们应该注意到，虽然上述约束都是有效的，但我们提出的解决方案并不是唯一的解决方案。我们需要的是上述列出的两个条件；请注意，实际上两者都不需要环境成为负责任的代理。事实上，很明显，环境不能是主要代理。
- en: 8.1.6Introducing the Store
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.6引入存储
- en: The preceding discussion tells us that we need two repositories to accompany
    the expression, not one. One of them, the environment, continues to be responsible
    for maintaining lexical scope. But the environment cannot directly map identifiers
    to their value, because the value might change. Instead, something else needs
    to be responsible for maintaining the dynamic state of mutated boxes. This latter
    data structure is called the store.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的讨论告诉我们，我们需要两个存储库来配合表达式，而不是一个。其中之一，环境，继续负责维护词法作用域。但是环境不能直接将标识符映射到它们的值，因为值可能会改变。相反，需要有其他东西负责维护已变异盒子的动态状态。这个后者数据结构被称为存储。
- en: 'Like the environment, the store is a partial map. Its domain could be any abstract
    set of names, but it is natural to think of these as numbers, meant to stand for
    memory locations. This is because the store in the semantics maps directly onto
    (abstracted) physical memory in the machine, which is traditionally addressed
    by numbers. Thus the environment maps names to locations, and the store maps locations
    to values:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 像环境一样，存储是一个部分映射。它的域可以是任何抽象名称集合，但自然地将其视为数字，用于代表内存位置。这是因为语义中的存储直接映射到机器中（抽象的）物理存储器，传统上是用数字进行寻址的。因此，环境将名称映射到位置，而存储将位置映射到值：
- en: '| (define-type-alias Location number) |'
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type-alias Location number) |'
- en: '|   |'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '| (define-type Binding |'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type Binding |'
- en: '|   [bind (name : symbol) (val : Location)]) |'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [bind (name : symbol) (val : Location)]) |'
- en: '|   |'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '| (define-type-alias Env (listof Binding)) |'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type-alias Env (listof Binding)) |'
- en: '| (define mt-env empty) |'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define mt-env empty) |'
- en: '| (define extend-env cons) |'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define extend-env cons) |'
- en: '|   |'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '| (define-type Storage |'
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type Storage |'
- en: '|   [cell (location : Location) (val : Value)]) |'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [cell (location : Location) (val : Value)]) |'
- en: '|   |'
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   |'
- en: '| (define-type-alias Store (listof Storage)) |'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type-alias Store (listof Storage)) |'
- en: '| (define mt-store empty) |'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define mt-store empty) |'
- en: '| (define override-store cons) |'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define override-store cons) |'
- en: 'We’ll also equip ourselves with a function to look up values in the store,
    just as we already have one for the environment (which now returns locations instead):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将配备一个用于查找存储中值的函数，就像我们已经为环境配备了一个一样（现在返回位置而不是值）：
- en: '| (define (lookup [for : symbol] [env : Env]) : Location |'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (lookup [for : symbol] [env : Env]) : Location |'
- en: '|   ...) |'
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   ...) |'
- en: '| (define (fetch [loc : Location] [sto : Store]) : Value |'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (fetch [loc : Location] [sto : Store]) : Value |'
- en: '|   ...) |'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   ...) |'
- en: 'With this, we can refine our notion of values to the correct one:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就可以将我们对值的概念精炼到正确的位置：
- en: '| (define-type Value |'
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type Value |'
- en: '|   [numV (n : number)] |'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [numV (n : number)] |'
- en: '|   [closV (arg : symbol) (body : ExprC) (env : Env)] |'
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [closV (arg : symbol) (body : ExprC) (env : Env)] |'
- en: '|   [boxV (l : Location)]) |'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [boxV (l : Location)]) |'
- en: Exercise
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Fill in the bodies of lookup and fetch.
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 填写查找和提取的主体。
- en: 8.1.7Interpreting Boxes
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.7解释盒子
- en: 'Now we have something that the environment can return, updated, reflecting
    mutations during the evaluation of the expression, without having to change the
    environment in any way. Because a function can return only one value, let’s define
    a data structure to hold the new result from the interpreter:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了环境可以返回的东西，更新后反映了在表达式评估过程中的变化，而无需以任何方式更改环境。因为函数只能返回一个值，让我们定义一个数据结构来保存解释器的新结果：
- en: '| (define-type Result |'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type Result |'
- en: '|   [v*s (v : Value) (s : Store)]) |'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [v*s (v : Value) (s : Store)]) |'
- en: Thus the interpreter’s type becomes:[<interp-mut-struct>](#(elem._(chunk._~3cinterp-mut-struct~3e~3a1)))
    ::=
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，解释器的类型变为：[<interp-mut-struct>](#(elem._(chunk._~3cinterp-mut-struct~3e~3a1)))
    ::=
- en: '| (define (interp [expr : ExprC] [env : Env] [sto : Store]) : Result |'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (interp [expr : ExprC] [env : Env] [sto : Store]) : Result |'
- en: '|   [<ms-numC-case>](#(elem._(chunk._~3cms-num.C-case~3e~3a1))) |'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [<ms-numC-case>](#(elem._(chunk._~3cms-num.C-case~3e~3a1))) |'
- en: '|   [<ms-idC-case>](#(elem._(chunk._~3cms-id.C-case~3e~3a1))) |'
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [<ms-idC-case>](#(elem._(chunk._~3cms-id.C-case~3e~3a1))) |'
- en: '|   [<ms-appC-case>](#(elem._(chunk._~3cms-app.C-case~3e~3a1))) |'
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [<ms-appC-case>](#(elem._(chunk._~3cms-app.C-case~3e~3a1))) |'
- en: '|   [<ms-plusC/multC-case>](#(elem._(chunk._~3cms-plus.C/mult.C-case~3e~3a1)))
    |'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [<ms-plusC/multC-case>](#(elem._(chunk._~3cms-plus.C/mult.C-case~3e~3a1)))
    |'
- en: '|   [<ms-lamC-case>](#(elem._(chunk._~3cms-lam.C-case~3e~3a1))) |'
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [<ms-lamC-case>](#(elem._(chunk._~3cms-lam.C-case~3e~3a1))) |'
- en: '|   [<ms-boxC-case>](#(elem._(chunk._~3cms-box.C-case~3e~3a1))) |'
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [<ms-boxC-case>](#(elem._(chunk._~3cms-box.C-case~3e~3a1))) |'
- en: '|   [<ms-unboxC-case>](#(elem._(chunk._~3cms-unbox.C-case~3e~3a1))) |'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [<ms-unboxC-case>](#(elem._(chunk._~3cms-unbox.C-case~3e~3a1))) |'
- en: '|   [<ms-setboxC-case>](#(elem._(chunk._~3cms-setbox.C-case~3e~3a1))) |'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [<ms-setboxC-case>](#(elem._(chunk._~3cms-setbox.C-case~3e~3a1))) |'
- en: '|   [<ms-seqC-case>](#(elem._(chunk._~3cms-seq.C-case~3e~3a1)))) |'
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [<ms-seqC-case>](#(elem._(chunk._~3cms-seq.C-case~3e~3a1)))) |'
- en: 'The easiest one to dispatch is numbers. Remember that we have to return the
    store reflecting all mutations that happened while evaluating the given expression.
    Because a number is a constant, no mutations could have happened, so the returned
    store is the same as the one passed in:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易分派的是数字。记住，我们必须返回反映在评估给定表达式时发生的所有变化的存储。因为数字是一个常数，没有可能发生变化，所以返回的存储与传入的存储相同：
- en: '[<ms-numC-case>](#(elem._(chunk._~3cms-num.C-case~3e~3a1))) ::='
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[<ms-numC-case>](#(elem._(chunk._~3cms-num.C-case~3e~3a1))) ::='
- en: '[numC (n) (v*s (numV n) sto)]'
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[numC (n) (v*s (numV n) sto)]'
- en: 'A similar argument applies to closure creation; observe that we are speaking
    of the creation, not use, of closures:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '类似的论点适用于闭包的创建；请注意，我们谈论的是闭包的创建，而不是使用： '
- en: '[<ms-lamC-case>](#(elem._(chunk._~3cms-lam.C-case~3e~3a1))) ::='
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[<ms-lamC-case>](#(elem._(chunk._~3cms-lam.C-case~3e~3a1))) ::='
- en: '[lamC (a b) (v*s (closV a b env) sto)]'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[lamC (a b) (v*s (closV a b env) sto)]'
- en: 'Identifiers are almost as straightforward, though if you are simplistic, you’ll
    get a type error that will alert you that to obtain a value, you must now look
    up both in the environment and in the store:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符几乎一样简单，但如果你过于简单，你会得到一个类型错误，提醒你要获取一个值，你现在必须在环境和存储中查找：
- en: '[<ms-idC-case>](#(elem._(chunk._~3cms-id.C-case~3e~3a1))) ::='
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[<ms-idC-case>](#(elem._(chunk._~3cms-id.C-case~3e~3a1))) ::='
- en: '[idC (n) (v*s (fetch (lookup n env) sto) sto)]'
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[idC (n) (v*s (fetch (lookup n env) sto) sto)]'
- en: Notice how lookup and fetch compose to produce the same result that lookup alone
    produced before.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意查找和提取如何组合以产生与之前仅查找产生的相同结果。
- en: Now things get interesting.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事情变得有趣起来。
- en: 'Let’s take sequencing. Clearly, we need to interpret the two terms:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下顺序。显然，我们需要解释这两个术语：
- en: '| (interp b1 env sto) |'
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (interp b1 env sto) |'
- en: '| (interp b2 env sto) |'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (interp b2 env sto) |'
- en: Oh, but wait. The whole point was to evaluate the second term in the store returned
    by the first one—<wbr>otherwise there would have been no point to all these changes.
    Therefore, instead we must evaluate the first term, capture the resulting store,
    and use it to evaluate the second. (Evaluating the first term also yields its
    value, but sequencing ignores this value and assumes the first time was run purely
    for its potential mutations.) We will write this in a stylized manner:[<ms-seqC-case>](#(elem._(chunk._~3cms-seq.C-case~3e~3a1)))
    ::=
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，但等等。整个重点是在第一个术语返回的存储中评估第二个术语，否则所有这些更改就没有意义。因此，我们必须评估第一个术语，捕获结果存储，并使用它来评估第二个术语。（评估第一个术语也会产生其值，但顺序会忽略这个值，并假定第一次运行纯粹是为了其潜在的变化。）我们将以一种程式化的方式写出这个：[<ms-seqC-case>](#(elem._(chunk._~3cms-seq.C-case~3e~3a1)))
    ::=
- en: '| [seqC (b1 b2) (type-case Result (interp b1 env sto) |'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [seqC (b1 b2) (type-case Result (interp b1 env sto) |'
- en: '|                 [v*s (v-b1 s-b1) |'
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 [v*s (v-b1 s-b1) |'
- en: '|                      (interp b2 env s-b1)])] |'
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      (interp b2 env s-b1)])] |'
- en: 'This says to (interp b1 env sto); name the resulting value and store v-b1 and
    s-b1, respectively; and evaluate the second term in the store from the first:
    (interp b2 env s-b1). The result will be the value and store returned by the second
    term, which is what we expect. The fact that the first term’s effect is only on
    the store can be read from the code because, though we bind v-b1, we never subsequently
    use it.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示要(interp b1 env sto);给结果命名，并将 v-b1 和 s-b1 分别存储，然后在第一个存储器中评估第二个项：(interp b2
    env s-b1)。结果将是第二项返回的值和存储器，这是我们预期的。从代码中可以看出，第一个项的效果仅对存储器有影响，因为虽然我们绑定了 v-b1，但我们从未随后使用它。
- en: Do Now!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始吧！
- en: Spend a moment contemplating the code above. You’ll soon need to adjust your
    eyes to read this pattern fluently.
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 花点时间思考上面的代码。您很快就需要调整眼睛以流畅地阅读此模式。
- en: Now let’s move on to the binary arithmetic primitives. These are similar to
    sequencing in that they have two sub-terms, but in this case we really do care
    about the value from each branch. As usual, we’ll look at only plusC since multC
    is virtually identical.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续讨论二进制算术原语。这些与序列类似，因为它们有两个子项，但在这种情况下，我们确实关心每个分支的值。和往常一样，我们只看 plusC，因为
    multC 几乎相同。
- en: '[<ms-plusC/multC-case>](#(elem._(chunk._~3cms-plus.C/mult.C-case~3e~3a1)))
    ::='
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[<ms-plusC/multC-case>](#(elem._(chunk._~3cms-plus.C/mult.C-case~3e~3a1)))
    ::= '
- en: '| [plusC (l r) (type-case Result (interp l env sto) |'
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [plusC (l r) (type-case Result (interp l env sto) |'
- en: '|                [v*s (v-l s-l) |'
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                [v*s (v-l s-l) |'
- en: '|                     (type-case Result (interp r env s-l) |'
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                     (type-case Result (interp r env s-l) |'
- en: '|                       [v*s (v-r s-r) |'
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                       [v*s (v-r s-r) |'
- en: '|                            (v*s (num+ v-l v-r) s-r)])])] |'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                            (v*s (num+ v-l v-r) s-r)])])] |'
- en: Observe that we’ve unfolded the sequencing pattern out another level, so we
    can hold on to both results and supply them to num+.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经展开了另一层序列模式，这样我们就可以保存两个结果并将它们提供给 num+。
- en: 'Here’s an important distinction. When we evaluate a term, we usually use the
    same environment for all its sub-terms in accordance with the scoping rules of
    the language. The environment thus flows in a recursive-descent pattern. In contrast,
    the store is threaded: rather than using the same store in all branches, we take
    the store from one branch and pass it on to the next, and take the result and
    send it back out. This pattern is called store-passing style.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要区别。当我们评估一个术语时，通常根据语言的作用域规则，我们为所有其子项使用相同的环境。因此，环境以递归下降的模式流动。相比之下，存储器是线程化的：我们不是在所有分支中使用相同的存储器，而是从一个分支中取出存储器并将其传递到下一个分支，然后取出结果并将其发送回。这种模式称为传递存储器的风格。
- en: 'Now the penny drops. We see that store-passing style is our secret ingredient:
    it enables the environment to preserve lexical scope while still giving a binding
    structure that can reflect changes. Our intution told us that the environment
    had to somehow participate in obtaining different results for the same expression,
    and we can now see how it does: not directly, by itself changing, but indirectly,
    by referring to the store, which updates. Now we only need to see how the store
    itself “changes”.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都清楚了。我们看到传递存储器的风格是我们的秘密武器：它使环境能够保留词法范围，同时仍然提供可以反映更改的绑定结构。我们的直觉告诉我们，环境必须以某种方式参与获取同一表达式的不同结果，我们现在可以看到它是如何做到的：不是直接地，通过自身的更改，而是间接地，通过引用存储器，后者会更新。现在我们只需要看看存储器本身是如何“变化”的。
- en: Let’s begin with boxing. To store a value in a box, we have to first allocate
    a new place in the store where its value will reside. The value corresponding
    to a box will then remember this location, for use in box mutation.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从装箱开始。要将值存储到箱子中，我们必须首先在存储器中分配一个新的位置，该位置将存放其值。然后，与箱子对应的值将记住此位置，供箱子突变时使用。
- en: '[<ms-boxC-case>](#(elem._(chunk._~3cms-box.C-case~3e~3a1))) ::='
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[<ms-boxC-case>](#(elem._(chunk._~3cms-box.C-case~3e~3a1))) ::= '
- en: '| [boxC (a) (type-case Result (interp a env sto) |'
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [boxC (a) (type-case Result (interp a env sto) |'
- en: '|             [v*s (v-a s-a) |'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|             [v*s (v-a s-a) |'
- en: '|                  (let ([where (new-loc)]) |'
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                  (let ([where (new-loc)]) |'
- en: '|                    (v*s (boxV where) |'
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    (v*s (boxV where) |'
- en: '|                         (override-store (cell where v-a) |'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                         (override-store (cell where v-a) |'
- en: '|                                         s-a)))])] |'
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                         s-a)))])] |'
- en: Do Now!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始吧！
- en: Observe that we have relied above on new-loc, which is itself implemented in
    terms of boxes! This is outright cheating. How would you modify the interpreter
    so that we no longer need an mutating implementation of new-loc?
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意我们以上依赖于new-loc，它本身是以盒子为基础实现的！这是彻头彻尾的作弊。你会如何修改解释器，以便我们不再需要一个变异实现的new-loc？
- en: 'To eliminate this style of new-loc, the simplest option would be to add yet
    another parameter to and return value from the interpreter, which represents the
    largest address used so far. Every operation that allocates in the store would
    return an incremented address, while all others would return it unchanged. In
    other words, this is precisely another application of the store-passing pattern.
    Writing the interpreter this way would make it extremely unwieldy and might obscure
    the more important use of store-passing for the store itself, which is why we
    have not done so. However, it is important to make sure that we can: that’s what
    tells us that we are not reliant on boxes to add boxes to the language.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要消除这种new-loc风格，最简单的选择是向解释器添加另一个参数，并从中返回值，表示迄今为止使用的最大地址。每个在存储中分配的操作都会返回一个递增的地址，而其他操作则会返回不变。换句话说，这正是存储传递模式的另一个应用。以这种方式编写解释器会使其非常笨重，可能会掩盖存储传递模式对存储本身更重要的用途，这就是为什么我们没有这样做的原因。然而，重要的是要确保我们能够做到：这告诉我们我们不依赖于盒子来向语言中添加盒子。
- en: Now that boxes are recording the location in memory, getting the value corresponding
    to them is easy.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在盒子记录了内存中的位置，获取与之对应的值就很容易了。
- en: '[<ms-unboxC-case>](#(elem._(chunk._~3cms-unbox.C-case~3e~3a1))) ::='
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[<ms-unboxC-case>](#(elem._(chunk._~3cms-unbox.C-case~3e~3a1))) ::='
- en: '| [unboxC (a) (type-case Result (interp a env sto) |'
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [unboxC (a) (type-case Result (interp a env sto) |'
- en: '|               [v*s (v-a s-a) |'
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|               [v*s (v-a s-a) |'
- en: '|                    (v*s (fetch (boxV-l v-a) s-a) s-a)])] |'
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    (v*s (fetch (boxV-l v-a) s-a) s-a)])] |'
- en: It’s the same pattern we saw before, where we have to use fetch to obtain the
    actual value residing at that location. Note that we are relying on Racket to
    halt with an error if the underlying value isn’t actually a boxV; otherwise it
    would be dangerous to not check, since this would be tantamount to dereferencing
    arbitrary memory (as C programs can, sometimes with disastrous consequences).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前看到的模式相同，我们必须使用fetch来获取实际驻留在那个位置的值。请注意，我们依赖Racket在底层值实际上不是boxV时停止并显示错误；否则，不检查将是危险的，因为这等同于对任意内存进行解引用（就像C程序有时会导致灾难性后果一样）。
- en: Let’s now see how to update the value held in a box. First we have to evaluate
    the box expression to obtain a box, and the value expression to obtain the new
    value to store in it. The box’s value is going to be a boxV holding a location.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何更新盒子中保存的值。首先，我们必须评估盒子表达式以获得一个盒子，以及评估值表达式以获得要存储在其中的新值。盒子的值将是一个包含位置的boxV。
- en: In principle, we want to “change”, or override, the value at that location in
    the store. We can do this in two ways.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，我们希望“更改”或覆盖存储中该位置的值。我们可以通过两种方式实现这一点。
- en: One is to traverse the store, find the old binding for that location, and replace
    it with the new one, copying all the other store bindings unchanged.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有两种方法可以更新存储在那个位置的值，一种是遍历存储空间，找到该位置的旧绑定，并用新的替换它，同时保留所有其他存储绑定不变。
- en: The other, lazier, option is to simply extend the store with a new binding for
    that location, which works provided we always obtain the most recent binding for
    a location (which is how lookup works in the environment, so fetch presumably
    also does in the store).
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种更懒惰的选择是简单地为该位置扩展存储空间，这样做可以确保我们总是获得该位置的最新绑定（这就是环境中查找的工作方式，所以在存储中获取也应该是这样）。
- en: The code below is written to be independent of these options:[<ms-setboxC-case>](#(elem._(chunk._~3cms-setbox.C-case~3e~3a1)))
    ::=
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是独立于这些选项的：[<ms-setboxC-case>](#(elem._(chunk._~3cms-setbox.C-case~3e~3a1)))
    ::=
- en: '| [setboxC (b v) (type-case Result (interp b env sto) |'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [setboxC (b v) (type-case Result (interp b env sto) |'
- en: '|                  [v*s (v-b s-b) |'
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                  [v*s (v-b s-b) |'
- en: '|                       (type-case Result (interp v env s-b) |'
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                       (type-case Result (interp v env s-b) |'
- en: '|                         [v*s (v-v s-v) |'
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                         [v*s (v-v s-v) |'
- en: '|                              (v*s v-v |'
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                              (v*s v-v |'
- en: '|                                   (override-store (cell (boxV-l v-b) |'
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                   (override-store (cell (boxV-l v-b) |'
- en: '|                                                         v-v) |'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                                         v-v) |'
- en: '|                                                   s-v))])])] |'
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                                   s-v))])])] |'
- en: However, because we’ve implemented override-store as cons above, we’ve actually
    taken the lazier (and slightly riskier, because of its dependence on the implementation
    of fetch) option.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，由于我们将`override-store`实现为上述的`cons`，我们实际上选择了更懒惰的（并且稍微有风险，因为它依赖于`fetch`的实现）选项。
- en: Exercise
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Implement the other version of store alteration, whereby we update an existing
    binding and thereby avoid multiple bindings for a location in the store.
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现存储改变的另一种版本，通过这种方式我们更新一个现有的绑定，从而避免了存储中一个位置的多个绑定。
- en: Exercise
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: When we look for a location to override the value stored at it, can the location
    fail to be present? If so, write a program that demonstrates this. If not, explain
    what invariant of the interpreter prevents this from happening.
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我们寻找要覆盖其上存储的值的位置时，该位置可能不存在吗？如果是这样，请编写一个演示此情况的程序。如果不是，请解释解释器的不变量防止这种情况发生的原因。
- en: 'Alright, we’re now done with everything other than application! Most of application
    should already be familiar: evaluate the function position, evaluate the argument
    position, interpret the closure body in an extension of the closure’s environment...but
    how do stores interact with this?'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，除了应用之外，我们现在已经完成了所有内容！大部分应用程序应该已经很熟悉了：评估函数位置，评估参数位置，解释闭包体在闭包环境的扩展中...但是存储如何与此交互？
- en: '[<ms-appC-case>](#(elem._(chunk._~3cms-app.C-case~3e~3a1))) ::='
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[<ms-appC-case>](#(elem._(chunk._~3cms-app.C-case~3e~3a1))) ::='
- en: '| [appC (f a) |'
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [appC (f a) |'
- en: '|       (type-case Result (interp f env sto) |'
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (type-case Result (interp f env sto) |'
- en: '|         [v*s (v-f s-f) |'
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         [v*s (v-f s-f) |'
- en: '|              (type-case Result (interp a env s-f) |'
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              (type-case Result (interp a env s-f) |'
- en: '|                [v*s (v-a s-a) |'
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                [v*s (v-a s-a) |'
- en: '|                     [<ms-appC-case-main>](#(elem._(chunk._~3cms-app.C-case-main~3e~3a1)))])])]
    |'
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                     [<ms-appC-case-main>](#(elem._(chunk._~3cms-app.C-case-main~3e~3a1)))])])]
    |'
- en: 'Let’s start by thinking about extending the closure environment. The name we’re
    extending it with is obviously the name of the function’s formal parameter. But
    what location do we bind it to? To avoid any confusion with already-used locations
    (a confusion we will explicitly introduce later! [REF]), let’s just allocate a
    new location. This location is used in the environment, and the value of the argument
    resides at this location in the store:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先考虑扩展闭包环境。我们要扩展的名称显然是函数的形式参数的名称。但我们将它绑定到哪个位置？为了避免与已使用的位置混淆（这是我们稍后将明确介绍的混淆！[REF]），让我们只分配一个新位置。此位置在环境中使用，并且参数的值驻留在存储中的此位置上：
- en: '[<ms-appC-case-main>](#(elem._(chunk._~3cms-app.C-case-main~3e~3a1))) ::='
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[<ms-appC-case-main>](#(elem._(chunk._~3cms-app.C-case-main~3e~3a1))) ::='
- en: '| (let ([where (new-loc)]) |'
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([where (new-loc)]) |'
- en: '|   (interp (closV-body v-f) |'
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (interp (closV-body v-f) |'
- en: '|           (extend-env (bind (closV-arg v-f) |'
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|           (extend-env (bind (closV-arg v-f) |'
- en: '|                             where) |'
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                             where) |'
- en: '|                       (closV-env v-f)) |'
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                       (closV-env v-f)) |'
- en: '|           (override-store (cell where v-a) s-a))) |'
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|           (override-store (cell where v-a) s-a))) |'
- en: 'Because we have not said the function parameter is mutable, there is no real
    need to have implemented procedure calls this way. We could instead have followed
    the same strategy as before. Indeed, observe that the mutability of this location
    will never be used: only setboxC changes what’s in an existing store location
    (the override-store above is technically a store initialization), and then only
    when they are referred to by boxVs, but no box is being allocated above.You could
    call this the useless app store. However, we have chosen to implement application
    this way for uniformity, and to reduce the number of cases we’d have to handle.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有说函数参数是可变的，所以没有真正需要以这种方式实现过程调用。我们可以选择像以前一样遵循相同的策略。实际上，注意到此位置的可变性永远不会被使用：只有`setboxC`改变了现有存储位置中的内容（上面的`override-store`在技术上是存储初始化），而且仅当它们被`boxVs`引用时才这样做，但是上面并没有分配任何盒子。您可以将其称为无用的应用商店。但是，我们选择以这种方式实现应用程序是为了统一性，并减少我们需要处理的情况数量。
- en: Exercise
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: It’s a useful exercise to try to limit the use of store locations only to boxes.
    How many changes would you need to make?
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尝试仅将存储位置的使用限制为盒子是一项有用的练习。您需要做多少改变？
- en: 8.1.8The Bigger Picture
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.8整体情况
- en: Even though we’ve finished the implementation, there are still many subtleties
    and insights to discuss.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们已经完成了实现，仍然有许多微妙之处和见解需要讨论。
- en: 'Implicit in our implementation is a subtle and important decision: the order
    of evaluation. For instance, why did we not implement addition thus?'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现中隐含的一个微妙而重要的决定是评估的顺序。例如，为什么我们没有这样实现加法呢？
- en: '| [plusC (l r) (type-case Result (interp r env sto) |'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| [plusC (l r) (type-case Result (interp r env sto) |'
- en: '|                [v*s (v-r s-r) |'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|                [v*s (v-r s-r) |'
- en: '|                     (type-case Result (interp l env s-r) |'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|                     (type-case Result (interp l env s-r) |'
- en: '|                       [v*s (v-l s-l) |'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|                       [v*s (v-l s-l) |'
- en: '|                            (v*s (num+ v-l v-r) s-l)])])] |'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|                            (v*s (num+ v-l v-r) s-l)])])] |'
- en: 'It would have been perfectly consistent to do so. Similarly, embodied in the
    pattern of store-passing is the decision to evaluate the function position before
    the argument. Observe that:'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样做也是完全一致的。同样，在传递存储的模式中体现的是在评估函数位置之前评估参数的决定。请注意：
- en: Previously, we delegated such decisions to the underlying language implementation.
    Now, store-passing has forced us to sequentialize the computation, and hence make
    this decision ourselves (whether we realized it or not).
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以前，我们将这样的决定委托给底层语言实现。现在，传递存储迫使我们将计算序列化，因此我们必须自己做出这个决定（无论我们是否意识到）。
- en: Even more importantly, this decision is now a semantic one. Before there were
    mutations, one branch of an addition, for instance, could not affect the value
    produced by the other branch.The only effect they could have was halting with
    an error or failing to terminate—<wbr>which, to be sure, are certainly observable
    effects, but at a much more gross level. A program would not terminate with two
    different answers depending on the order of evaluation. Because each branch can
    have mutations that impact the value of the other, we must choose some order so
    that programmers can predict what their program is going to do! Being forced to
    write a store-passing interpreter has made this clear.
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更重要的是，这个决定现在是一个语义决定。在没有变异之前，例如，加法的一个分支不能影响另一个分支产生的值。它们唯一能产生的影响是停止并出现错误或无法终止——这确实是可观察的效果，但在更粗略的层面上。一个程序不会因为评估的顺序不同而以两个不同的答案终止。因为每个分支都可能有影响另一个值的变异，我们必须选择某种顺序，以便程序员可以预测他们的程序将要做什么！被迫编写一个传递存储的解释器已经让这一点变得清晰。
- en: Observe that in the application rule, we are passing along the dynamic store,
    i.e., the one resulting from evaluating both function and argument. This is precisely
    the opposite of what we said to do with the environment. This distinction is critical.
    The store is, in effect, “dynamically scoped”, in that it reflects the history
    of the computation, not its lexical shape. Because we are already using the term
    “scope” to refer to the bindings of identifiers, however, it would be confusing
    to say “dynamically scoped” to refer to the store. Instead, we simply say that
    it is persistent.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在应用规则中，我们传递的是动态存储，即，由评估函数和参数得到的存储。这恰恰与我们在环境中所说的相反。这种区别至关重要。存储实际上是“动态作用域的”，因为它反映了计算的历史，而不是其词法形状。然而，由于我们已经使用术语“作用域”来指代标识符的绑定，因此说“动态作用域”来指代存储会令人困惑。相反，我们只说它是持久的。
- en: 'Languages sometimes dangerously conflate these two. In C, for instance, values
    bound to local identifiers are allocated (by default) on the stack. However, the
    stack matches the environment, and hence disappears upon completion of the call.
    If the call, however, returned references to any of these values, these references
    are now pointing to unused or even overridden memory: a genuine source of serious
    errors in C programs. The problem is that the values themselves persist; it is
    only the identifiers that refer to them that have lexical scope.'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时语言会危险地混淆这两者。例如，在C语言中，绑定到本地标识符的值（默认情况下）是在堆栈上分配的。然而，堆栈与环境匹配，因此在调用完成后会消失。然而，如果调用返回对这些值的任何引用，这些引用现在指向未使用或甚至被覆盖的内存：这是C程序中严重错误的真正来源。问题在于值本身是持久的；只有引用这些值的标识符具有词法作用域。
- en: 'We have already discussed how there are two strategies for overriding the store:
    to simply extend it (and rely on fetch to extract the newest one) or to “search-and-replace”.
    The latter strategy has the virtue of not holding on to useless store bindings
    that will can never be obtained again.'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经讨论过有两种覆盖存储的策略：简单地扩展它（并依赖于提取最新的值）或“搜索和替换”。后一种策略的优点是不保留永远无法再次获得的无用存储绑定。
- en: 'However, this does not cover all the wasted memory. Over time, we cease to
    be able to access some boxes entirely: e.g., if they are bound to only one identifier,
    and that identifier is no longer in scope. These locations are called garbage.
    Thinking more conceptually, garbage locations are those whose elimination does
    not have any impact on the value produced by a program. There are many strategies
    for identifying and reclaiming garbage locations, usually called garbage collection
    [REF].'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，这并不覆盖所有的浪费内存。随着时间的推移，我们不再能够完全访问某些箱子：例如，如果它们只绑定到一个标识符，而该标识符不再在范围内。这些位置被称为垃圾。更多概念上的思考，垃圾位置是那些其消除对程序产生的值没有任何影响的位置。有许多识别和回收垃圾位置的策略，通常称为垃圾收集
    [REF]。
- en: 'It’s very important to evaluate every expression position and thread the store
    that results from it. Consider, for instance, this implementation of unboxC:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个表达式位置都评估并线程化结果存储非常重要。例如，考虑一下 unboxC 的这个实现：
- en: '| [unboxC (a) (type-case Result (interp a env sto) |'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| [unboxC (a) (type-case Result (interp a env sto) |'
- en: '|               [v*s (v-a s-a) |'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|               [v*s (v-a s-a) |'
- en: '|                    (v*s (fetch (boxV-l v-a) sto) s-a)])] |'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    (v*s (fetch (boxV-l v-a) sto) s-a)])] |'
- en: Did you notice? We fetched the location from sto, not s-a. But sto reflects
    mutations up to but before the evaluation of the unboxC expression, not any within
    it. Could there possibly be any? Mais oui!
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你注意到了吗？我们从 sto 中获取了位置，而不是 s-a。但 sto 反映了在 unboxC 表达式的评估之前发生的变异，而不是其中的任何变异。可能还会有吗？Mais
    oui！
- en: '| (let ([b (box 0)]) |'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([b (box 0)]) |'
- en: '|   (unbox (begin (set-box! b 1) |'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (unbox (begin (set-box! b 1) |'
- en: '|                 b))) |'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|                 b))) |'
- en: With the incorrect code above, this would evaluate to 0 rather than 1.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以上的错误代码将导致评估结果为0，而不是1。
- en: 'Here’s another, similar, error:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有另一个类似的错误：
- en: '| [unboxC (a) (type-case Result (interp a env sto) |'
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| [unboxC (a) (type-case Result (interp a env sto) |'
- en: '|               [v*s (v-a s-a) |'
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|               [v*s (v-a s-a) |'
- en: '|                    (v*s (fetch (boxV-l v-a) s-a) sto)])] |'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    (v*s (fetch (boxV-l v-a) s-a) sto)])] |'
- en: How do we break this? Well, we’re returning the old store, the one before any
    mutations in the unboxC happened. Thus, we just need the outside context to depend
    on one of them.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们如何打破这个？嗯，我们正在返回旧的存储，即在 unboxC 中的任何变异之前的存储。因此，我们只需要外部上下文依赖于其中一个。
- en: '| (let ([b (box 0)]) |'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([b (box 0)]) |'
- en: '|   (+ (unbox (begin (set-box! b 1) |'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (+ (unbox (begin (set-box! b 1) |'
- en: '|                    b)) |'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    b)) |'
- en: '|      (unbox b))) |'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (unbox b))) |'
- en: This should evaluate to 2, but because the store being returned is one where
    b’s location is bound to the representation of 0, the result is 1.
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该评估为2，但由于返回的存储是一个其中 b 的位置被绑定到表示 0 的表示形式的存储，结果是1。
- en: If we combined both bugs above—<wbr>i.e., using sto twice in the last line instead
    of s-a twice—<wbr>this expression would evaluate to 0 rather than 2.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们结合上述两个错误——即在最后一行两次使用 sto 而不是两次使用 s-a——这个表达式将评估为0而不是2。
- en: Exercise
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 练习
- en: Go through the interpreter; replace every reference to an updated store with
    a reference to one before update; make sure your test cases catch all the introduced
    errors!
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过解释器；将对更新后的存储的每个引用替换为更新之前的引用；确保你的测试案例捕获所有引入的错误！
- en: 'Observe that these uses of “old” stores enable us to perform a kind of time
    travel: because mutation introduces a notion of time, these enable us to go back
    in time to when the mutation had not yet occurred. This sounds both interesting
    and perverse; does it have any use?'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，这些“旧”存储的使用使我们能够执行一种时间旅行：因为变异引入了时间的概念，所以这些使我们能够回到变异尚未发生的时刻。这听起来既有趣又反常；它有什么用处吗？
- en: 'It does! Imagine that instead of directly mutating the store, we introduce
    the idea of a journal of intended updates to the store. The journal flows in a
    threaded manner just like the real store itself. Some instruction creates a new
    journal; after that, all lookups first check the journal, and only if the journal
    cannot find a binding for a location is it looked for in the actual store. There
    are two other new instructions: one to discard the journal (i.e., perform time
    travel), and the other to commit it (i.e., all of its edits get applied to the
    real store).'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它可以！想象一下，我们不直接对存储进行变异，而是引入了一个关于对存储预期更新的日志的概念。日志像真实的存储本身一样以线程方式流动。某些指令创建一个新的日志；之后，所有查找都首先检查日志，只有在日志找不到位置的绑定时才会在实际存储中查找。还有两个新指令：一个是丢弃日志（即，执行时间旅行），另一个是提交它（即，将其所有编辑应用于实际存储）。
- en: This is the essence of software transactional memory. Each thread maintains
    its own journal. Thus, one thread does not see the edits made by the other before
    committing (because each thread sees only its own journal and the global store,
    but not the journals of other threads). At the same time, each thread gets its
    own consistent view of the world (it sees edits it made, because these are recorded
    in the journal). If the transaction ends successfully, all threads atomically
    see the updated global store. If the transaction aborts, the discarded journal
    takes with it all changes and the state of the thread reverts (modulo global changes
    committed by other threads).
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是软件事务内存的本质。每个线程维护自己的日志。因此，一个线程在提交之前看不到其他线程所做的编辑（因为每个线程只看到自己的日志和全局存储器，但不看其他线程的日志）。同时，每个线程都可以获得自己的一致视图（它可以看到它所做的编辑，因为这些编辑记录在日志中）。如果事务成功结束，所有线程都会原子地看到更新后的全局存储器。如果事务中止，被丢弃的日志将带走所有更改，并且线程的状态将恢复（除了其他线程提交的全局更改）。
- en: Software transactional memory offers one of the most sensible approaches to
    tackling the difficulties of multi-threaded programming, if we insist on programming
    with shared mutable state. Because most computers have only one global store,
    however, maintaining the journals can be expensive, and much effort goes into
    optimizing them. As an alternative, some hardware architectures have begun to
    provide direct support for transactional memory by making the creation, maintenance,
    and commitment of journals as efficient as using the global store, removing one
    important barrier to the adoption of this idea.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们坚持使用共享可变状态进行编程，软件事务内存提供了一种最明智的解决多线程编程困难的方法之一。然而，由于大多数计算机只有一个全局存储器，维护日志可能很昂贵，并且需要大量工作来对其进行优化。作为一种替代方案，一些硬件架构已经开始提供对事务内存的直接支持，使得创建、维护和提交日志与使用全局存储器一样高效，消除了采用这一想法的一个重要障碍。
- en: Exercise
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 练习
- en: Augment the language with the journal features of software transactional memory
    journal.
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 增加语言与软件事务内存日志的日志功能。
- en: Exercise
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 'An alternate implementation strategy is to have the environment map names to
    boxed Values. We don’t do it here because it: (a) would be cheating, (b) wouldn’t
    tell us how to implement the same feature in a language without boxes, (c) doesn’t
    necessarily carry over to other mutation operations, and (d) most of all, doesn’t
    really give us insight into what is happening here.'
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一种实现策略是将环境映射到装箱值的名称。我们在这里不这样做，因为：（a）这将是作弊，（b）不会告诉我们如何在没有箱子的语言中实现相同的功能，（c）不一定适用于其他变异操作，（d）最重要的是，这并不能真正让我们了解到这里发生了什么。
- en: ''
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is nevertheless useful to understand, not least because you may find it a
    useful strategy to adopt when implementing your own language. Therefore, alter
    the implementation to obey this strategy. Do you still need store-passing style?
    Why or why not?
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，了解这一点仍然是有用的，至少因为在实现自己的语言时，您可能会发现这是一种有用的策略。因此，修改实现以遵循这个策略。你是否仍然需要传递存储样式？为什么？
- en: 8.2Variables
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2变量
- en: 'Now that we’ve got structure mutation worked out, let’s consider the other
    case: variable mutation.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经弄清楚了结构变异，让我们考虑另一种情况：变量变异。
- en: 8.2.1Terminology
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1术语
- en: First, our choice of terms. We’ve insisted on using the word “identifier” before
    because we wanted to reserve “variable” for what we’re about to study. In Java,
    when we say (assuming x is locally bound, e.g., as a method parameter)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的术语选择。我们之前一直坚持使用“标识符”一词，因为我们想保留“变量”一词来研究我们即将学习的内容。在Java中，当我们说（假设x是本地绑定的，例如作为方法参数时）
- en: '| x = 1; |'
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| x = 1; |'
- en: '| x = 3; |'
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| x = 3; |'
- en: we’re asking to change the value of x. After the first assignment, the value
    of x is 1; after the second one, it’s 3. Thus, the value of x varies over the
    course of the execution of the method.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求改变x的值。在第一次赋值之后，x的值是1；在第二次赋值之后，它是3。因此，在方法执行过程中，x的值会变化。
- en: Now, we also use the term “variable” in mathematics to refer to function parameters.
    For instance, in \(f(y) = y+3\) we say that \(y\) is a “variable”. That is called
    a variable because it varies across invocations; however, within each invocation,
    it has the same value in its scope. Our identifiers until now have corresponded
    to this notion of a variable.If the identifier was bound to a box, then it remained
    bound to the same box value. It’s the content of the box that changed, not which
    box the identifier was bound to. In contrast, programming variables can vary even
    within each invocation, like the Java x above.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在数学中也使用术语“变量”来指代函数参数。例如，在\(f(y) = y+3\)中，我们说\(y\)是一个“变量”。这被称为变量，因为它在每次调用时都会变化；然而，在每次调用中，它在其作用域内具有相同的值。直到现在，我们的标识符对应于这种变量的概念。如果标识符绑定���一个盒子，那么它仍然绑定到相同的盒子值。改变的是盒子的内容，而不是标识符绑定到的盒子。相比之下，编程变量甚至在每次调用中都可能变化，就像上面的Java
    x一样。
- en: Henceforth, we will use variable when we mean an identifier whose value can
    change within its scope, and identifier when this cannot happen. If in doubt,
    we might play it safe and use “variable”; if the difference doesn’t really matter,
    we might use either one. It is less important to get caught up in these specific
    terms than to understand that they represent a distinction that matters [REF].
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们指的是一个在其作用域内可以改变值的标识符时，我们将使用“变量”，而当这种情况不会发生时，我们将使用“标识符”。如果有疑问，我们可能会选择更保守的“变量”；如果区别并不重要，我们可能会两者都使用。比起纠结于这些具体术语，更重要的是理解它们代表了一个重要的区别[REF]。
- en: 8.2.2Syntax
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 语法
- en: 'Whereas other languages overload the mutation syntax (= or :=), in Racket they
    are kept distinct: set! is used to mutate variables. This forces Racket programmers
    to confront the distinction we introduced at the beginning of Mutation: Structures
    and Variables. We will, of course, sidestep these syntactic issues in our core
    language by using different constructs for boxes and for variables.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 而其他语言会重载突变语法（=或:=），在Racket中它们保持不同：set!用于突变变量。这迫使Racket程序员面对我们在突变：结构和变量开头介绍的区别。当然，在我们的核心语言中，我们将通过使用不同的构造来避开这些语法问题，用于盒子和变量。
- en: 'The first thing to note about variable mutation is that, although it too has
    two sub-terms like box mutation (setboxC), its syntax is fundamentally different.
    To understand why, let’s return to our Java fragment:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 关于变量突变的第一件事是，尽管它也有两个子项像盒子突变（setboxC）一样，但其语法基本上是不同的。为了理解为什么，让我们回到我们的Java片段：
- en: '| x = 3; |'
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| x = 3; |'
- en: 'In this setting, we cannot write an arbitrary expression in place of x: we
    must literally write the name of the identifier itself. That is because, if it
    were an expression position, then we could evaluate it, yielding a value: for
    instance, if x were previously bound to 1, this would be tantamout to writing
    the following statement:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不能在x的位置写一个任意表达式：我们必须字面上写下标识符本身的名称。这是因为，如果它是一个表达式位置，那么我们可以对其求值，得到一个值：例如，如果x先前绑定到1，这将等同于写下以下语句：
- en: '| 1 = 3; |'
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| 1 = 3; |'
- en: But this is, of course, nonsensical! We can’t assign a new value to 1, and indeed
    1 is pretty much the definition of immutable. Thus, what we instead want is to
    find where x is in the store, and change the value held over there.Here’s another
    way to see this. Suppose the local variable o were bound to some String object;
    let’s call this object \(s\). Say we write
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 但这当然是荒谬的！我们不能给1赋一个新值，而且1基本上就是不可变的定义。因此，我们真正想要的是找到x在存储中的位置，并改变那里保存的值。这里有另一种看待这个问题的方式。假设局部变量o绑定到某个String对象；让我们称这个对象为\(s\)。假设我们写下
- en: '| o = new String("a new string"); |'
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| o = new String("a new string"); |'
- en: 'Are we trying to change \(s\) in any way? Certainly not: this statement intends
    to leave \(s\) alone. It only wants to change the value that o is referring to,
    so that subsequent references evaluate to this new string object instead.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否试图改变\(s\)的任何方式？当然不是：这个语句的意图是让\(s\)保持不变。它只想改变o所引用的值，以便后续引用评估为这个新的字符串对象。
- en: 8.2.3Interpreting Variables
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 解释变量
- en: 'We’ll start by reflecting this in our syntax:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从语法上反映这一点：
- en: '| (define-type ExprC |'
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type ExprC |'
- en: '|   [numC (n : number)] |'
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [numC (n : number)] |'
- en: '|   [varC (s : symbol)] |'
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [varC (s : symbol)] |'
- en: '|   [appC (fun : ExprC) (arg : ExprC)] |'
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [appC (fun : ExprC) (arg : ExprC)] |'
- en: '|   [plusC (l : ExprC) (r : ExprC)] |'
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [plusC (l : ExprC) (r : ExprC)] |'
- en: '|   [multC (l : ExprC) (r : ExprC)] |'
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [multC (l : ExprC) (r : ExprC)] |'
- en: '|   [lamC (arg : symbol) (body : ExprC)] |'
  id: totrans-388
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [lamC (arg : symbol) (body : ExprC)] |'
- en: '|   [setC (var : symbol) (arg : ExprC)] |'
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [setC (var : symbol) (arg : ExprC)] |'
- en: '|   [seqC (b1 : ExprC) (b2 : ExprC)]) |'
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [seqC (b1 : ExprC) (b2 : ExprC)]) |'
- en: Observe that we’ve jettisoned the box operations, but kept sequencing because
    it’s handy around mutation. Importantly, we’ve now added the setC case, and its
    first sub-term is not an expression but the literal name of a variable. We’ve
    also renamed idC to varC.Because we’ve gotten rid of boxes, we can also get rid
    of the special box values. When the only kind of mutation you have is variables,
    you don’t need new kinds of values.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经放弃了盒子操作，但保留了序列化，因为它在突变周围很方便。重要的是，我们现在已经添加了setC情况，它的第一个子项不是一个表达式，而是一个变量的字面名称。我们还将idC重命名为varC。因为我们已经摆脱了盒子，所以我们也可以摆脱特殊的盒子值。当您只有一种变量的变异时，您不需要新的值类型。
- en: '| (define-type Value |'
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type Value |'
- en: '|   [numV (n : number)] |'
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [numV (n : number)] |'
- en: '|   [closV (arg : symbol) (body : ExprC) (env : Env)]) |'
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [closV (arg : symbol) (body : ExprC) (env : Env)]) |'
- en: As you might imagine, to support variables we need the same store-passing style
    that we’ve seen before ([Interpreting Boxes](#(part._store-passing-style))), and
    for the same reasons. What differs is in precisely how we use it. Because sequencing
    is interpreted in just the same way (observe that the code for it does not depend
    on boxes versus variables), that leaves us just the variable mutation case to
    handle.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能想象的那样，为了支持变量，我们需要与我们之前看到的相同的传递存储器样式（[解释盒子](#(part._store-passing-style)）），原因也是如此。不同之处在于我们如何准确地使用它。因为序列化以完全相同的方式解释（请注意，其代码不依赖于盒子与变量之间的区别），这使我们只需要处理变量突变案例。
- en: 'First, we might as well evaluate the value expression and obtain the updated
    store:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以评估值表达式并获得更新后的存储器：
- en: '[<setC-case>](#(elem._(chunk._~3cset.C-case~3e~3a1))) ::='
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[<setC-case>](#(elem._(chunk._~3cset.C-case~3e~3a1))) ::='
- en: '| [setC (var val) (type-case Result (interp val env sto) |'
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [setC (var val) (type-case Result (interp val env sto) |'
- en: '|                   [v*s (v-val s-val) |'
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                   [v*s (v-val s-val) |'
- en: '|                        [<rest-of-setC-case>](#(elem._(chunk._~3crest-of-set.C-case~3e~3a1)))])]
    |'
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                        [<rest-of-setC-case>](#(elem._(chunk._~3crest-of-set.C-case~3e~3a1)))])]
    |'
- en: 'What now? Remember we just said that we don’t want to fully evaluate the variable,
    because that would just give the value it is bound to. Instead, we want to know
    which memory location it corresponds to, and update what is stored at that memory
    location; this latter part is just the same thing we did when mutating boxes:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在呢？请记住，我们刚刚说过，我们不想完全评估变量，因为那只会给出它绑定的值。相反，我们想知道它对应哪个内存位置，并更新存储在该内存位置的内容；后者与突变盒子时所做的事情完全相同：
- en: '[<rest-of-setC-case>](#(elem._(chunk._~3crest-of-set.C-case~3e~3a1))) ::='
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '[<rest-of-setC-case>](#(elem._(chunk._~3crest-of-set.C-case~3e~3a1))) ::='
- en: '| (let ([where (lookup var env)]) |'
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([where (lookup var env)]) |'
- en: '|   (v*s v-val |'
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (v*s v-val |'
- en: '|        (override-store (cell where v-val) |'
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|        (override-store (cell where v-val) |'
- en: '|                        s-val))) |'
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                        s-val))) |'
- en: 'The very interesting new pattern we have here is this. When we added boxes,
    in the idC case, we looked up an identifier in the environment, and immediately
    fetched the value at that location from the store; the composition yielded a value,
    just as it used to before we added stores. Now, however, we have a new pattern:
    looking up an identifier in the environment without subsequently fetching its
    value from the store. The result of invoking just lookup is traditionally called
    an l-value, for “left-hand-side (of an assignment) value”. This is a fancy way
    of saying “memory address”, and stands in contast to the actual values that the
    store yields: observe that it does not directly correspond to anything in the
    type Value.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一个非常有趣的新模式。当我们添加了盒子时，在idC情况下，我们在环境中查找标识符，并立即从存储器中获取该位置的值；组合产生了一个值，就像我们在添加存储器之前一样。现在，我们有了一个新模式：在环境中查找标识符，而不随后从存储器中获取其值。只调用lookup的结果传统上称为l-value，“赋值语句左边的值”。这是一种花哨的说法，“内存地址”，与存储器产生的实际值形成对比：请注意，它与类型Value中的任何内容都没有直接对应。
- en: And we’re done! We did all the hard work when we implemented store-passing style
    (and also in that application allocated new locations for variables).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！当我们实现传递存储器样式时，我们做了所有艰苦的工作（并且在那个应用程序中为变量分配了新位置）。
- en: 8.3The Design of Stateful Language Operations
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3有状态语言操作的设计
- en: 'Though most programming languages include one or both kinds of state we have
    studied, their admission should not be regarded as a trivial or foregone matter.
    On the one hand, state brings some vital benefits:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数编程语言包含我们研究过的一种或两种状态，但它们的引入不应被视为微不足道或不可避免的事情。一方面，状态带来了一些重要的好处：
- en: 'State provides a form of modularity. As our very interpreter demonstrates,
    without explicit stateful operations, to achieve the same effect:'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态提供了一种模块化的形式。正如我们的解释器所示，没有显式的状态操作，要实现相同的效果：
- en: We would need to add explicit parameters and return values that pass the equivalent
    of the store around.
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要添加显式参数和返回值，以传递等效的存储。
- en: These changes would have to be made to all procedures that may be involved in
    a communication path between producers and consumers of state.
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些更改必须针对所有可能涉及生产者和消费者之间通信路径的过程进行。
- en: Thus, a different way to think of state in a programming language is that it
    is an implicit parameter already passed to and returned from all procedures, without
    imposing that burden on the programmer. This enables procedures to communicate
    “at a distance” without all the intermediaries having to be aware of the communication.
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，思考编程语言中状态的另一种方式是，它是隐式参数，已经传递给并从所有过程返回，而不会对程序员施加负担。这使得过程能够在“距离上”进行通信，而无需所有中介者都意识到通信。
- en: 'State makes it possible to construct dynamic, cyclic data structures, or at
    least to do so in a relatively straightforward manner ([Recursion and Cycles:
    Procedures and Data](recursion.html)).'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态使得构建动态循环数据结构成为可能，或者至少相对简单（[递归和循环：过程和数据](recursion.html)）。
- en: State gives procedures memory, such as new-loc above. If a procedure could not
    remember things for itself, the callers would need to perform the remembering
    on its behalf, employing the moral equivalent of store-passing. This is not only
    unwieldy, it creates the potential for a caller to interfere with the memory for
    its own nefarious purposes (e.g., a caller might purposely send back an old store,
    thereby obtaining a reference already granted to some other party, through which
    it might launch a correctness or security attack).
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态为程序提供了内存，例如上面的 new-loc。如果一个过程不能自己记住事情，调用者将需要代表它执行记忆，采用存储传递的道德等效物。这不仅笨拙，还会导致调用者为自己的不良目的而干涉记忆（例如，调用者可能有意地发送回一个旧的存储，从而获得已经授予给其他方的引用，通过它可能发起正确性或安全攻击）。
- en: On the other hand, state imposes real costs on programmers as well as on programs
    that process programs (such as compilers). One is “aliasing”, which we discuss
    later [REF]. Another is “referential transparency”, which too I hope to return
    to [REF]. Finally, we have described above how state provides a form of modularity.
    However, this same description could be viewed as that of a back-channel of communication
    that the intermediaries did not know and could not monitor. In some (especially
    security and distributed system) settings, such back-channels can lead to collusion,
    and can hence be extremely dangerous and undesirable.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，状态对程序员以及处理程序的程序（如编译器）也会产生实际成本。一个是“别名”，我们稍后会讨论 [REF]。另一个是“引用透明度”，我也希望能够回顾一下
    [REF]。最后，我们已经描述了状态如何提供一种模块化形式。然而，同样的描述也可以被视为中介者不知道并且无法监视的通信后通道。在某些（特别是安全和分布式系统）环境中，这些后通道可能导致串通，因此可能非常危险和不受欢迎。
- en: Because there is no optimal answer, it is probably wise to include mutation
    operators but to carefully delinate them. In Standard ML, for instance, there
    is no variable mutation, because it is considered unnecessary. Instead, the language
    has the equivalent of boxes (called refs). One can easily simulate variables using
    boxes (e.g., see new-loc and consider how it would be written with variables instead),
    so no expressive power is lost, though it does create more potential for aliasing
    than variables alone would have ([REF aliasing]) if the boxes are not used carefully.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有最佳答案，可能明智的做法是包括变异运算符，但要仔细划分它们。例如，在标准 ML 中，没有变量突变，因为被认为是不必要的。相反，语言具有等效的盒子（称为
    refs）。可以使用盒子轻松模拟变量（例如，参见 new-loc 并考虑如何使用变量而不是盒子编写它），因此不会失去表达能力，尽管这会比仅使用变量更容易引起别名（[REF
    别名]）如果盒子不小心使用。
- en: 'In return, however, developers obtain expressive types: every data structure
    is considered immutable unless it contains a ref, and the presence of a ref is
    a warning to both developers and programs (such as compilers) that the underlying
    value may keep changing. Thus, for instance, if b is a box, a developer should
    be aware that replacing all instances of (unbox b) with v, where v is bound to
    (unbox b), is unwise: the former always fetches the current value in the box,
    while the latter may be referring to an older content. (Conversely, if the developer
    wants the value at a certain point in time, oblivious to future mutations to the
    box, they should be sure to retrieve and bind it rather than always use unbox.)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 8.4Parameter Passing
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our current implementation, on every function call, we allocate a fresh location
    in the store for the parameter. This means the following program
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '| (let ([f (lambda (x) (set! x 3))]) |'
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (let ([y 5]) |'
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (begin |'
  id: totrans-424
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (f y) |'
  id: totrans-425
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       y))) |'
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: evaluates to 5, not 3. That is because the value of the formal parameter x is
    held at a different location than that of the actual parameter y, so the mutation
    affects the location of x, leaving y unscathed.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose, instead, that application behaved as follows. When the actual
    parameter is a variable, and hence has a location in memory, instead of allocating
    a new location for the value, it simply passes along the existing one for the
    variable. Now the formal parameter is referring to the same store location as
    the actual: i.e., they are variable aliases. Thus any mutation on the formal will
    leak back out into the calling context; the above program would evaluate to 3
    rather than 5. These is called a call-by-reference parameter-passing strategy.Instead,
    our interpreter implements call-by-value, and this is the same strategy followed
    by languages like Java. This causes confusion because when the value is itself
    mutable, changes made to the value in the callee are observed by the caller. However,
    that is simply an artifact of mutable values, not of the calling strategy. Please
    avoid this confusion!'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'For some years, this power was considered a good idea. It was useful because
    programmers could write abstractions such as swap, which swaps the value of two
    variables in the caller. However, the disadvantages greatly outweigh the advantages:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: A careless programmer can alias a variable in the caller and modify it without
    realizing they have done so, and the caller may not even realize this has happened
    until some obscure condition triggers it.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some people thought this was necessary for efficiency: they assumed the alternative
    was to copy large data structures. However, call-by-value is compatible with passing
    just the address of the data structure. You only need make a copy if (a) the data
    structure is mutable, (b) you do not want the caller to be able to mutate it,
    and (c) the language does not itself provide immutability annotations or other
    mechanisms.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It can force non-uniform and hence non-modular reasoning. For instance, suppose
    we have the procedure:'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能强制进行非统一的、因此非模块化的推理。例如，假设我们有以下过程：
- en: '| (define (f g) |'
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义 (f g) |'
- en: '|   (let ([x 10]) |'
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (让 ([x 10]) |'
- en: '|     (begin |'
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (开始 |'
- en: '|       (g x) |'
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (g x) |'
- en: '|       ...))) |'
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
  zh: '|       ...))) |'
- en: If the language were to permit by-reference parameter passing, then the programmer
    cannot locally—<wbr>i.e., just from the above code—<wbr>determine what the value
    of x will be in the ellipses.
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果语言允许按引用传递参数，那么程序员无法从上述代码中局部地—<wbr>即，仅仅从上面的代码—<wbr>确定省略号中x的值。
- en: At the very least, then, if the language is going to permit by-reference parameters,
    it should let the caller determine whether to pass the reference—<wbr>i.e., let
    the callee share the memory address of the caller’s variable—<wbr>or not. However,
    even this option is not quite as attractive as it may sound, because now the callee
    faces a symmetric problem, not knowing whether its parameters are aliased or not.
    In traditional, sequential programs this is less of a concern, but if the procedure
    is reentrant, the callee faces precisely the same predicaments.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，如果语言允许按引用传递参数，那么它应该让调用者确定是否传递引用—<wbr>即，让被调用方分享调用方变量的内存地址—<wbr>或不传递。然而，即使有这个选项，也并不像听起来那么吸引人，因为现在被调用方面临着对称的问题，不知道它的参数是否别名。在传统的、顺序执行的程序中，这不是很令人担心，但如果过程是可重入的，被调用方将面临完全相同的困境。
- en: At some point, therefore, we should consider whether any of this fuss is worthwhile.
    Instead, callers who want the callee to perform a mutation could simply send a
    boxed value to the callee. The box signals that the caller accepts—<wbr>indeed,
    invites—<wbr>the callee to perform a mutation, and the caller can extract the
    value when it’s done. This does obviate the ability to write a simple swapper,
    but that’s a small price to pay for genuine software engineering concerns.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该考虑在某个时候是否值得费这么大的劲。相反，希望被调用方执行变异的调用方可以简单地向被调用方发送一个装箱值。该箱子表示调用方接受—<wbr>甚至邀请—<wbr>被调用方执行变异，并且在完成后，调用方可以提取该值。这确实消除了编写一个简单的交换程序的能力，但这是为了真正的软件工程问题所付出的小代价。
