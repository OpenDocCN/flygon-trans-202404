["```\n\n```", "```\n\n# Polymorphism\n\n    In this chapter we continue our development of basic\n    concepts of functional programming.  The critical new ideas are\n    *polymorphism* (abstracting functions over the types of the data\n    they manipulate) and *higher-order functions* (treating functions\n    as data).  We begin with polymorphism.\n\n```", "```\nInductive boollist : Type :=\n\u00a0\u00a0| bool_nil : boollist\n\u00a0\u00a0| bool_cons : bool \u2192 boollist \u2192 boollist.\n\n```", "```\nInductive list (X:Type) : Type :=\n\u00a0\u00a0| nil : list X\n\u00a0\u00a0| cons : X \u2192 list X \u2192 list X.\n\n```", "```\nCheck nil.\n(*\u00a0===>\u00a0nil\u00a0:\u00a0forall\u00a0X\u00a0:\u00a0Type,\u00a0list\u00a0X\u00a0*)\nCheck cons.\n(*\u00a0===>\u00a0cons\u00a0:\u00a0forall\u00a0X\u00a0:\u00a0Type,\u00a0X\u00a0->\u00a0list\u00a0X\u00a0->\u00a0list\u00a0X\u00a0*)\n\n```", "```\nCheck (cons nat 2 (cons nat 1 (nil nat))).\n\n```", "```\nFixpoint repeat (X : Type) (x : X) (count : nat) : list X :=\n\u00a0\u00a0match count with\n\u00a0\u00a0| 0 \u21d2 nil X\n\u00a0\u00a0| S count' \u21d2 cons X x (repeat X x count')\n\u00a0\u00a0end.\n\n```", "```\nExample test_repeat1 :\n\u00a0\u00a0repeat nat 4 2 = cons nat 4 (cons nat 4 (nil nat)).\nProof. reflexivity. Qed.\n\n```", "```\nExample test_repeat2 :\n\u00a0\u00a0repeat bool false 1 = cons bool false (nil bool).\nProof. reflexivity. Qed.\n\nModule MumbleGrumble.\n\n```", "```\nInductive mumble : Type :=\n\u00a0\u00a0| a : mumble\n\u00a0\u00a0| b : mumble \u2192 nat \u2192 mumble\n\u00a0\u00a0| c : mumble.\n\nInductive grumble (X:Type) : Type :=\n\u00a0\u00a0| d : mumble \u2192 grumble X\n\u00a0\u00a0| e : X \u2192 grumble X.\n\n```", "```\nEnd MumbleGrumble.\n\n```", "```\nFixpoint repeat' X x count : list X :=\n\u00a0\u00a0match count with\n\u00a0\u00a0| 0        \u21d2 nil X\n\u00a0\u00a0| S count' \u21d2 cons X x (repeat' X x count')\n\u00a0\u00a0end.\n\n```", "```\nCheck repeat'.\n(*\u00a0===>\u00a0forall\u00a0X\u00a0:\u00a0Type,\u00a0X\u00a0->\u00a0nat\u00a0->\u00a0list\u00a0X\u00a0*)\nCheck repeat.\n(*\u00a0===>\u00a0forall\u00a0X\u00a0:\u00a0Type,\u00a0X\u00a0->\u00a0nat\u00a0->\u00a0list\u00a0X\u00a0*)\n\n```", "```\n\n### Type Argument Synthesis\n\n    To use a polymorphic function, we need to pass it one or\n    more types in addition to its other arguments.  For example, the\n    recursive call in the body of the repeat function above must\n    pass along the type X.  But since the second argument to\n    repeat is an element of X, it seems entirely obvious that the\n    first argument can only be X \u2014 why should we have to write it\n    explicitly?\n\n    Fortunately, Coq permits us to avoid this kind of redundancy.  In\n    place of any type argument we can write the \"implicit argument\"\n    _, which can be read as \"Please try to figure out for yourself\n    what belongs here.\"  More precisely, when Coq encounters a _, it\n    will attempt to *unify* all locally available information \u2014 the\n    type of the function being applied, the types of the other\n    arguments, and the type expected by the context in which the\n    application appears \u2014 to determine what concrete type should\n    replace the _.\n\n    This may sound similar to type annotation inference \u2014 indeed, the\n    two procedures rely on the same underlying mechanisms.  Instead of\n    simply omitting the types of some arguments to a function, like\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0repeat'\u00a0(X\u00a0:\u00a0_)\u00a0(x\u00a0:\u00a0_)\u00a0(count\u00a0:\u00a0_)\u00a0:\u00a0list\u00a0X\u00a0:=\n\n    to tell Coq to attempt to infer the missing information.\n\n    Using implicit arguments, the count function can be written like\n    this:\n\n```", "```\n\n    In this instance, we don't save much by writing _ instead of\n    X.  But in many cases the difference in both keystrokes and\n    readability is nontrivial.  For example, suppose we want to write\n    down a list containing the numbers 1, 2, and 3.  Instead of\n    writing this...\n\n```", "```\n\n    ...we can use argument synthesis to write this:\n\n```", "```\n\n### Implicit Arguments\n\n    We can go further and even avoid writing _'s in most cases by\n    telling Coq *always* to infer the type argument(s) of a given\n    function.  The Arguments directive specifies the name of the\n    function (or constructor) and then lists its argument names, with\n    curly braces around any arguments to be treated as implicit.  (If\n    some arguments of a definition don't have a name, as is often the\n    case for constructors, they can be marked with a wildcard pattern\n    _.)\n\n```", "```\n\n    Now, we don't have to supply type arguments at all:\n\n```", "```\n\n    Alternatively, we can declare an argument to be implicit\n    when defining the function itself, by surrounding it in curly\n    braces instead of parens.  For example:\n\n```", "```\n\n    (Note that we didn't even have to provide a type argument to the\n    recursive call to repeat'''; indeed, it would be invalid to\n    provide one!)\n\n    We will use the latter style whenever possible, but we will\n    continue to use use explicit Argument declarations for\n    Inductive constructors.  The reason for this is that marking the\n    parameter of an inductive type as implicit causes it to become\n    implicit for the type itself, not just for its constructors.  For\n    instance, consider the following alternative definition of the\n    list type:\n\n```", "```\n\n    Because X is declared as implicit for the *entire* inductive\n    definition including list' itself, we now have to write just\n    list' whether we are talking about lists of numbers or booleans\n    or anything else, rather than list' nat or list' bool or\n    whatever; this is a step too far. \n\n    Let's finish by re-implementing a few other standard list\n    functions on our new polymorphic lists...\n\n```", "```\n\n### Supplying Type Arguments Explicitly\n\n    One small problem with declaring arguments Implicit is\n    that, occasionally, Coq does not have enough local information to\n    determine a type argument; in such cases, we need to tell Coq that\n    we want to give the argument explicitly just this time.  For\n    example, suppose we write this:\n\n```", "```\n\n    (The Fail qualifier that appears before Definition can be\n    used with *any* command, and is used to ensure that that command\n    indeed fails when executed. If the command does fail, Coq prints\n    the corresponding error message, but continues processing the rest\n    of the file.)\n\n    Here, Coq gives us an error because it doesn't know what type\n    argument to supply to nil.  We can help it by providing an\n    explicit type declaration (so that Coq has more information\n    available when it gets to the \"application\" of nil):\n\n```", "```\n\n    Alternatively, we can force the implicit arguments to be explicit by\n   prefixing the function name with @.\n\n```", "```\n\n    Using argument synthesis and implicit arguments, we can\n    define convenient notation for lists, as before.  Since we have\n    made the constructor type arguments implicit, Coq will know to\n    automatically infer these when we use the notations.\n\n```", "```\n\n    Now lists can be written just the way we'd hope:\n\n```", "```\n\n### Exercises\n\n#### Exercise: 2 stars, optional (poly_exercises)\n\n    Here are a few simple exercises, just like ones in the Lists\n    chapter, for practice with polymorphism.  Complete the proofs below.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 stars, optional (more_poly_exercises)\n\n    Here are some slightly more interesting ones...\n\n```", "```\n\n    \u2610\n\n```", "```\nInductive prod (X Y : Type) : Type :=\n| pair : X \u2192 Y \u2192 prod X Y.\n\nArguments pair {X} {Y} _ _.\n\n```", "```\nNotation \"( x , y )\" := (pair x y).\n\n```", "```\nNotation \"X * Y\" := (prod X Y) : type_scope.\n\n```", "```\nDefinition fst {X Y : Type} (p : X * Y) : X :=\n\u00a0\u00a0match p with\n\u00a0\u00a0| (x, y) \u21d2 x\n\u00a0\u00a0end.\n\nDefinition snd {X Y : Type} (p : X * Y) : Y :=\n\u00a0\u00a0match p with\n\u00a0\u00a0| (x, y) \u21d2 y\n\u00a0\u00a0end.\n\n```", "```\nFixpoint combine {X Y : Type} (lx : list X) (ly : list Y)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: list (X*Y) :=\n\u00a0\u00a0match lx, ly with\n\u00a0\u00a0| [], _ \u21d2 []\n\u00a0\u00a0| _, [] \u21d2 []\n\u00a0\u00a0| x :: tx, y :: ty \u21d2 (x, y) :: (combine tx ty)\n\u00a0\u00a0end.\n\n```", "```\n    \u00a0\u00a0Compute\u00a0(combine\u00a0[1;2]\u00a0[false;false;true;true]).\n\n     print?\n    ```", "```\nFixpoint split {X Y : Type} (l : list (X*Y))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: (list X) * (list Y)\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample test_split:\n\u00a0\u00a0split [(1,false);(2,false)] = ([1;2],[false;false]).\nProof.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n## Polymorphic Options\n\n    One last polymorphic type for now: *polymorphic options*,\n    which generalize natoption from the previous chapter:\n\n```", "```\n\n    We can now rewrite the nth_error function so that it works\n    with any type of lists.\n\n```", "```\n\n#### Exercise: 1 star, optional (hd_error_poly)\n\n    Complete the definition of a polymorphic version of the\n    hd_error function from the last chapter. Be sure that it\n    passes the unit tests below.\n\n```", "```\n\n    Once again, to force the implicit arguments to be explicit,\n    we can use @ before the name of the function.\n\n```", "```\n\n    \u2610\n\n```", "```\n\n## Higher-Order Functions\n\n    Functions that manipulate other functions are often called\n    *higher-order* functions.  Here's a simple one:\n\n```", "```\n\n    The argument f here is itself a function (from X to\n    X); the body of doit3times applies f three times to some\n    value n.\n\n```", "```\n\n## Filter\n\n    Here is a more useful higher-order function, taking a list\n    of Xs and a *predicate* on X (a function from X to bool)\n    and \"filtering\" the list, returning a new list containing just\n    those elements for which the predicate returns true.\n\n```", "```\n\n    For example, if we apply filter to the predicate evenb\n    and a list of numbers l, it returns a list containing just the\n    even members of l.\n\n```", "```\n\n    We can use filter to give a concise version of the\n    countoddmembers function from the [Lists](Lists.html) chapter.\n\n```", "```\n\n## Anonymous Functions\n\n    It is arguably a little sad, in the example just above, to\n    be forced to define the function length_is_1 and give it a name\n    just to be able to pass it as an argument to filter, since we\n    will probably never use it again.  Moreover, this is not an\n    isolated example: when using higher-order functions, we often want\n    to pass as arguments \"one-off\" functions that we will never use\n    again; having to give each of these functions a name would be\n    tedious.\n\n    Fortunately, there is a better way.  We can construct a function\n    \"on the fly\" without declaring it at the top level or giving it a\n    name.\n\n```", "```\n\n    The expression (fun n \u21d2 n * n) can be read as \"the function\n    that, given a number n, yields n * n.\" \n\n    Here is the filter example, rewritten to use an anonymous\n    function.\n\n```", "```\n\n#### Exercise: 2 stars (filter_even_gt[7])\n\n    Use filter (instead of Fixpoint) to write a Coq function\n    filter_even_gt[7] that takes a list of natural numbers as input\n    and returns a list of just those that are even and greater than\n    7.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 3 stars (partition)\n\n    Use filter to write a Coq function partition:\n\n```", "```\nDefinition partition {X : Type}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(test : X \u2192 bool)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(l : list X)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: list X * list X\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample test_partition1: partition oddb [1;2;3;4;5] = ([1;3;5], [2;4]).\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\nExample test_partition2: partition (fun x \u21d2 false) [5;9;0] = ([], [5;9;0]).\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n## Map\n\n    Another handy higher-order function is called map.\n\n```", "```\n\n    It takes a function f and a list l = [n[1], n[2], n[3], ...] and returns the list [f n[1], f n[2], f n[3],...] , where f has\n    been applied to each element of l in turn.  For example: \n\n```", "```\n\n    The element types of the input and output lists need not be\n    the same, since map takes *two* type arguments, X and Y; it\n    can thus be applied to a list of numbers and a function from\n    numbers to booleans to yield a list of booleans:\n\n```", "```\n\n    It can even be applied to a list of numbers and\n    a function from numbers to *lists* of booleans to\n    yield a *list of lists* of booleans:\n\n```", "```\n\n### Exercises\n\n#### Exercise: 3 stars (map_rev)\n\n    Show that map and rev commute.  You may need to define an\n    auxiliary lemma.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 stars, recommended (flat_map)\n\n    The function map maps a list X to a list Y using a function\n    of type X \u2192 Y.  We can define a similar function, flat_map,\n    which maps a list X to a list Y using a function f of type\n    X \u2192 list Y.  Your definition should work by 'flattening' the\n    results of f, like so:\n\n```", "```\nFixpoint flat_map {X Y:Type} (f:X \u2192 list Y) (l:list X)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: (list Y)\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample test_flat_map1:\n\u00a0\u00a0flat_map (fun n \u21d2 [n;n;n]) [1;5;4]\n\u00a0\u00a0= [1; 1; 1; 5; 5; 5; 4; 4; 4].\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nDefinition option_map {X Y : Type} (f : X \u2192 Y) (xo : option X)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: option Y :=\n\u00a0\u00a0match xo with\n\u00a0\u00a0\u00a0\u00a0| None \u21d2 None\n\u00a0\u00a0\u00a0\u00a0| Some x \u21d2 Some (f x)\n\u00a0\u00a0end.\n\n```", "```\n\n## Fold\n\n    An even more powerful higher-order function is called\n    fold.  This function is the inspiration for the \"reduce\"\n    operation that lies at the heart of Google's map/reduce\n    distributed programming framework.\n\n```", "```\n\n    Intuitively, the behavior of the fold operation is to\n    insert a given binary operator f between every pair of elements\n    in a given list.  For example, fold plus [1;2;3;4] intuitively\n    means 1+2+3+4.  To make this precise, we also need a \"starting\n    element\" that serves as the initial second input to f.  So, for\n    example,\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\u00a0+\u00a0(2\u00a0+\u00a0(3\u00a0+\u00a0(4\u00a0+\u00a00))).\n\n    Some more examples:\n\n```", "```\n\n#### Exercise: 1 star, advancedM (fold_types_different)\n\n    Observe that the type of fold is parameterized by *two* type\n    variables, X and Y, and the parameter f is a binary operator\n    that takes an X and a Y and returns a Y.  Can you think of a\n    situation where it would be useful for X and Y to be\n    different?\n\n```", "```\n\n    \u2610\n\n```", "```\nDefinition constfun {X: Type} (x: X) : nat\u2192X :=\n\u00a0\u00a0fun (k:nat) \u21d2 x.\n\nDefinition ftrue := constfun true.\n\nExample constfun_example1 : ftrue 0 = true.\n\n    Proof. reflexivity. Qed.\n\nExample constfun_example2 : (constfun 5) 99 = 5.\n\n    Proof. reflexivity. Qed.\n\n```", "```\nCheck plus.\n(*\u00a0==>\u00a0nat\u00a0->\u00a0nat\u00a0->\u00a0nat\u00a0*)\n\n```", "```\nDefinition plus3 := plus 3.\nCheck plus3.\n\nExample test_plus3 :    plus3 4 = 7.\nProof. reflexivity. Qed.\nExample test_plus3' :   doit3times plus3 0 = 9.\nProof. reflexivity. Qed.\nExample test_plus3'' :  doit3times (plus 3) 0 = 9.\nProof. reflexivity. Qed.\n\n```", "```\nModule Exercises.\n\n```", "```\nDefinition fold_length {X : Type} (l : list X) : nat :=\n\u00a0\u00a0fold (fun _ n \u21d2 S n) l 0.\n\nExample test_fold_length1 : fold_length [4;7;0] = 3.\n\n    Proof. reflexivity. Qed.\n\n```", "```\nTheorem fold_length_correct : \u2200X (l : list X),\n\u00a0\u00a0fold_length l = length l.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nDefinition fold_map {X Y:Type} (f : X \u2192 Y) (l : list X) : list Y\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\nDefinition prod_curry {X Y Z : Type}\n\u00a0\u00a0(f : X * Y \u2192 Z) (x : X) (y : Y) : Z := f (x, y).\n\n```", "```\nDefinition prod_uncurry {X Y Z : Type}\n\u00a0\u00a0(f : X \u2192 Y \u2192 Z) (p : X * Y) : Z\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\n```", "```\nExample test_map2: map (fun x \u21d2 plus 3 x) [2;0;2] = [5;3;5].\nProof. reflexivity. Qed.\n\n```", "```\nCheck @prod_curry.\nCheck @prod_uncurry.\n\nTheorem uncurry_curry : \u2200(X Y Z : Type)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(f : X \u2192 Y \u2192 Z)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0x y,\n\u00a0\u00a0prod_curry (prod_uncurry f) x y = f x y.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nTheorem curry_uncurry : \u2200(X Y Z : Type)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(f : (X * Y) \u2192 Z) (p : X * Y),\n\u00a0\u00a0prod_uncurry (prod_curry f) p = f p.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\u00a0\u00a0\u00a0Fixpoint\u00a0nth_error\u00a0{X\u00a0:\u00a0Type}\u00a0(l\u00a0:\u00a0list\u00a0X)\u00a0(n\u00a0:\u00a0nat)\u00a0:\u00a0option\u00a0X\u00a0:=\n\u00a0\u00a0\u00a0\u00a0\u00a0match\u00a0l\u00a0with\n\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0[]\u00a0\u21d2\u00a0None\n\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0a\u00a0::\u00a0l'\u00a0\u21d2\u00a0if\u00a0beq_nat\u00a0n\u00a0O\u00a0then\u00a0Some\u00a0a\u00a0else\u00a0nth_error\u00a0l'\u00a0(pred\u00a0n)\n\u00a0\u00a0\u00a0\u00a0\u00a0end.\n\n    Write an informal proof of the following theorem:\n\n```", "```\nModule Church.\nDefinition nat := \u2200X : Type, (X \u2192 X) \u2192 X \u2192 X.\n\n```", "```\nDefinition one : nat :=\n\u00a0\u00a0fun (X : Type) (f : X \u2192 X) (x : X) \u21d2 f x.\n\n```", "```\nDefinition two : nat :=\n\u00a0\u00a0fun (X : Type) (f : X \u2192 X) (x : X) \u21d2 f (f x).\n\n```", "```\nDefinition zero : nat :=\n\u00a0\u00a0fun (X : Type) (f : X \u2192 X) (x : X) \u21d2 x.\n\n```", "```\nDefinition three : nat := @doit3times.\n\n```", "```\nDefinition succ (n : nat) : nat\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample succ_1 : succ zero = one.\nProof. (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nExample succ_2 : succ one = two.\nProof. (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nExample succ_3 : succ two = three.\nProof. (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nDefinition plus (n m : nat) : nat\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample plus_1 : plus zero one = one.\nProof. (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nExample plus_2 : plus two three = plus three two.\nProof. (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nExample plus_3 :\n\u00a0\u00a0plus (plus two two) three = plus one (plus three three).\nProof. (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nDefinition mult (n m : nat) : nat\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample mult_1 : mult one one = one.\nProof. (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nExample mult_2 : mult zero (plus three three) = zero.\nProof. (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nExample mult_3 : mult two three = plus three three.\nProof. (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nDefinition exp (n m : nat) : nat\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample exp_1 : exp two two = plus two two.\nProof. (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nExample exp_2 : exp three two = plus (mult two (mult two two)) one.\nProof. (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nExample exp_3 : exp three zero = one.\nProof. (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nEnd Church.\n\n```", "```\nEnd Exercises.\n\n```", "```\n\n```", "```\n\n```", "``` \n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]