["```\n proposer          acceptors\n\n           prepare(n) ->\n        <- prepare_ok(n, n_a, v_a)\n\n           accept(n, v') ->\n        <- accept_ok(n)\n\n           decided(v') -> \n```", "```\n proposer(v):\n      choose n, unique and higher than any n seen so far\n      send prepare(n) to all servers including self\n      if prepare_ok(n, n_a, v_a) from majority:\n        v' = v_a with highest n_a; choose own v otherwise\n        send accept(n, v') to all\n        if accept_ok(n) from majority:\n          send decided(n, v') to all\n\n    acceptor state:\n      must persist across reboots\n      n_p (highest prepare seen)\n      n_a, v_a (highest accept seen)\n\n    acceptor's prepare(n) handler:\n      if n > n_p\n        n_p = n\n        reply prepare_ok(n, n_a, v_a)\n      else\n        reply prepare_reject\n\n    acceptor's accept(n, v) handler:\n      if n >= n_p\n        n_p = n\n        n_a = n\n        v_a = v\n        reply accept_ok(n)\n      else\n        reply accept_reject \n```", "```\n `S1`, `S2`, `S3` but `S3` is dead or slow\n\n    `S1`: -> starts proposal w/ n=1 v=A\n    `S1`: <- p1   <- a1vA    <- dA\n    `S2`: <- p1   <- a1vA    <- dA\n    `S3`: dead...\n\n    \"p1\" means Sx receives prepare(n=1)\n    \"a1vA\" means Sx receives accept(n=1, v=A)\n    \"dA\" means Sx receives decided(v=A) \n```", "```\n proposer 1 crashes after sending two accept() requests\n  proposer 2 has a different value in mind\n\n  A: p1 a1foo\n  B: p1       p2 a2bar\n  C: p1 a1foo p2 a2bar\n\n  C's prepare_ok to B really included \"foo\"\n    thus a2foo, and so no problem \n```", "```\n A1 starts proposing n=10 by sending prepare(n=10) \n    A1 sends out just one accept v=10\n    A3 starts proposing n=11\n      but A1 does not receive its proposal\n      A3 only has to wait for a majority of proposal responses\n\n    A1: p10 a10v10 \n    A2: p10        p11\n    A3: p10        p11  a11v11\n\n    A1 and A3 have accepted different values! \n```", "```\nA1: p10  a10v10               p12\nA2: p10          p11  a11v11  \nA3: p10          p11          p12   a12v10 \n```", "```\n A1: p10  a10vA               p12\n    A2: p10          p11  a11vB  \n    A3: p10          p11  a11vB  p12   a12v??\n\n    n=11 already agreed on vB\n    n=12 sees both vA and vB, but must choose vB \n```", "```\n A1: p1 p2 a1vA\n    A2: p1 p2 a1vA a2vB\n    A3: p1 p2      a2vB \n```", "```\n A1: p1    a2vB a1vA p3 a3vA\n    A2: p1 p2           p3 a3vA\n    A3:    p2 a2vB \n```", "```\nA1: p1  a1v1\nA2: p1  a1v1 reboot  p2  a2v?\nA3: p1               p2  a2v?\n\nA2 must remember v_a/n_a across reboot! on disk\n  might be only intersection with new proposer's majority\n  and thus only evidence that already agreed on v1 \n```", "```\n `S1`: p10            a10v10\n  `S2`: p10 p11 reboot a10v10 a11v11\n  `S3`:     p11               a11v11 \n```"]