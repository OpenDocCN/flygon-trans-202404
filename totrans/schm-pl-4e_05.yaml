- en: Chapter 5\. Control Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces the syntactic forms and procedures that serve as control
    structures for Scheme programs, The first section covers the most basic control
    structure, procedure application, and the remaining sections cover sequencing,
    conditional evaluation, recursion, mapping, continuations, delayed evaluation,
    multiple values, and evaluation of programs constructed at run time.
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.1\. Procedure Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**syntax**: `(*expr[0]* *expr[1]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** values of applying the value of `*expr[0]*` to the values of `*expr[1]* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: Procedure application is the most basic Scheme control structure. Any structured
    form without a syntax keyword in the first position is a procedure application.
    The expressions `*expr[0]*` and `*expr[1]* ...` are evaluated; each should evaluate
    to a single value. After each of these expressions has been evaluated, the value
    of `*expr[0]*` is applied to the values of `*expr[1]* ...`. If `*expr[0]*` does
    not evaluate to a procedure, or if the procedure does not accept the number of
    arguments provided, an exception with condition type `&assertion` is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The order in which the procedure and argument expressions are evaluated is
    unspecified. It may be left to right, right to left, or any other order. The evaluation
    is guaranteed to be sequential, however: whatever order is chosen, each expression
    is fully evaluated before evaluation of the next is started.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 3 4) ![<graphic>](ch2_0.gif) 7'
  prefs: []
  type: TYPE_NORMAL
- en: ((if (odd? 3) + -) 6 2) ![<graphic>](ch2_0.gif) 8
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda (x) x) 5) ![<graphic>](ch2_0.gif) 5
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda (x) (+ x x))])
  prefs: []
  type: TYPE_NORMAL
- en: (f 8)) ![<graphic>](ch2_0.gif) 16`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(apply *procedure* *obj* ... *list*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the values of applying `*procedure*` to `*obj* ...` and the elements
    of `*list*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`apply` invokes `*procedure*`, passing the first `*obj*` as the first argument,
    the second `*obj*` as the second argument, and so on for each object in `*obj* ...`,
    and passing the elements of `*list*` in order as the remaining arguments. Thus,
    `*procedure*` is called with as many arguments as there are `*objs*` plus elements
    of `*list*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`apply` is useful when some or all of the arguments to be passed to a procedure
    are in a list, since it frees the programmer from explicitly destructuring the
    list.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(apply + ''(4 5)) ![<graphic>](ch2_0.gif) 9'
  prefs: []
  type: TYPE_NORMAL
- en: (apply min '(6 8 3 2 5)) ![<graphic>](ch2_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (apply min  5 1 3 '(6 8 3 2 5)) ![<graphic>](ch2_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (apply vector 'a 'b '(c d e)) ![<graphic>](ch2_0.gif) #(a b c d e)
  prefs: []
  type: TYPE_NORMAL
- en: (define first
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (apply (lambda (x . y) x) ls)))
  prefs: []
  type: TYPE_NORMAL
- en: (define rest
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (apply (lambda (x . y) y) ls)))
  prefs: []
  type: TYPE_NORMAL
- en: (first '(a b c d)) ![<graphic>](ch2_0.gif) a
  prefs: []
  type: TYPE_NORMAL
- en: (rest '(a b c d)) ![<graphic>](ch2_0.gif) (b c d)
  prefs: []
  type: TYPE_NORMAL
- en: (apply append
  prefs: []
  type: TYPE_NORMAL
- en: '''(1 2 3)'
  prefs: []
  type: TYPE_NORMAL
- en: '''((a b) (c d e) (f))) ![<graphic>](ch2_0.gif) (1 2 3 a b c d e f)`'
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.2\. Sequencing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**syntax**: `(begin *expr[1]* *expr[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the values of the last subexpression'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The expressions `*expr[1]* *expr[2]* ...` are evaluated in sequence from left
    to right. `begin` is used to sequence assignments, input/output, or other operations
    that cause side effects.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define x 3)'
  prefs: []
  type: TYPE_NORMAL
- en: (begin
  prefs: []
  type: TYPE_NORMAL
- en: (set! x (+ x 1))
  prefs: []
  type: TYPE_NORMAL
- en: (+ x x)) ![<graphic>](ch2_0.gif) 8`
  prefs: []
  type: TYPE_NORMAL
- en: A `begin` form may contain zero or more definitions in place of the expressions
    `*expr[1]* *expr[2]* ...`, in which case it is considered to be a definition and
    may appear only where definitions are valid.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ()'
  prefs: []
  type: TYPE_NORMAL
- en: (begin (define x 3) (define y 4))
  prefs: []
  type: TYPE_NORMAL
- en: (+ x y)) ![<graphic>](ch2_0.gif) 7`
  prefs: []
  type: TYPE_NORMAL
- en: This form of `begin` is primarily used by syntactic extensions that must expand
    into multiple definitions. (See page [101](binding.html#multi-define-syntax).)
  prefs: []
  type: TYPE_NORMAL
- en: The bodies of many syntactic forms, including `lambda`, `case-lambda`, `let`,
    `let*`, `letrec`, and `letrec*`, as well as the result clauses of `cond`, `case`,
    and `do`, are treated as if they were inside an implicit `begin`; i.e., the expressions
    making up the body or result clause are executed in sequence, with the values
    of the last expression being returned.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define swap-pair!'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([temp (car x)])
  prefs: []
  type: TYPE_NORMAL
- en: (set-car! x (cdr x))
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! x temp)
  prefs: []
  type: TYPE_NORMAL
- en: x)))
  prefs: []
  type: TYPE_NORMAL
- en: (swap-pair! (cons 'a 'b)) ![<graphic>](ch2_0.gif) (b . a)`
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.3\. Conditionals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**syntax**: `(if *test* *consequent* *alternative*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(if *test* *consequent*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the values of `*consequent*` or `*alternative*` depending on the
    value of `*test*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The `*test*`, `*consequent*`, and `*alternative*` subforms must be expressions.
    If `*test*` evaluates to a true value (anything other than `#f`), `consequent`
    is evaluated and its values are returned. Otherwise, `alternative` is evaluated
    and its values are returned. With the second, "one-armed," form, which has no
    `*alternative*`, the result is unspecified if `*test*` evaluates to false.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([ls ''(a b c)])'
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: '''()'
  prefs: []
  type: TYPE_NORMAL
- en: (cdr ls))) ![<graphic>](ch2_0.gif) (b c)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls '()])
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: '''()'
  prefs: []
  type: TYPE_NORMAL
- en: (cdr ls))) ![<graphic>](ch2_0.gif) ()
  prefs: []
  type: TYPE_NORMAL
- en: (let ([abs
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (if (< x 0)
  prefs: []
  type: TYPE_NORMAL
- en: (- 0 x)
  prefs: []
  type: TYPE_NORMAL
- en: x))])
  prefs: []
  type: TYPE_NORMAL
- en: (abs -4)) ![<graphic>](ch2_0.gif) 4
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x -4])
  prefs: []
  type: TYPE_NORMAL
- en: (if (< x 0)
  prefs: []
  type: TYPE_NORMAL
- en: (list 'minus (- 0 x))
  prefs: []
  type: TYPE_NORMAL
- en: (list 'plus 4))) ![<graphic>](ch2_0.gif) (minus 4)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(not *obj*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is false, `#f` otherwise'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`not` is equivalent to `(lambda (x) (if x #f #t))`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(not #f) ![<graphic>](ch2_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (not #t) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (not '()) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (not (< 4 5)) ![<graphic>](ch2_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(and *expr* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If no subexpressions are present, the `and` form evaluates to `#t`. Otherwise,
    `and` evaluates each subexpression in sequence from left to right until only one
    subexpression remains or a subexpression returns `#f`. If one subexpression remains,
    it is evaluated and its values are returned. If a subexpression returns `#f`,
    `and` returns `#f` without evaluating the remaining subexpressions. A syntax definition
    of `and` appears on page [62](further.html#defn:and).
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 3])'
  prefs: []
  type: TYPE_NORMAL
- en: (and (> x 2) (< x 4))) ![<graphic>](ch2_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x 5])
  prefs: []
  type: TYPE_NORMAL
- en: (and (> x 2) (< x 4))) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (and #f '(a b) '(c d)) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (and '(a b) '(c d) '(e f)) ![<graphic>](ch2_0.gif) (e f)`
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(or *expr* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: If no subexpressions are present, the `or` form evaluates to `#f`. Otherwise,
    `or` evaluates each subexpression in sequence from left to right until only one
    subexpression remains or a subexpression returns a value other than `#f`. If one
    subexpression remains, it is evaluated and its values are returned. If a subexpression
    returns a value other than `#f`, `or` returns that value without evaluating the
    remaining subexpressions. A syntax definition of `or` appears on page [63](further.html#defn:or).
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 3])'
  prefs: []
  type: TYPE_NORMAL
- en: (or (< x 2) (> x 4))) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x 5])
  prefs: []
  type: TYPE_NORMAL
- en: (or (< x 2) (> x 4))) ![<graphic>](ch2_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (or #f '(a b) '(c d)) ![<graphic>](ch2_0.gif) (a b)`
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(cond *clause[1]* *clause[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: Each `*clause*` but the last must take one of the forms below.
  prefs: []
  type: TYPE_NORMAL
- en: '`(*test*)'
  prefs: []
  type: TYPE_NORMAL
- en: (*test* *expr[1]* *expr[2]* ...)
  prefs: []
  type: TYPE_NORMAL
- en: (*test* => *expr*)`
  prefs: []
  type: TYPE_NORMAL
- en: The last clause may be in any of the above forms, or it may be an "`else` clause"
    of the form
  prefs: []
  type: TYPE_NORMAL
- en: '`(else *expr[1]* *expr[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: Each `*test*` is evaluated in order until one evaluates to a true value or until
    all of the tests have been evaluated. If the first clause whose `*test*` evaluates
    to a true value is in the first form given above, the value of `*test*` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: If the first clause whose `*test*` evaluates to a true value is in the second
    form given above, the expressions `*expr[1]* *expr[2]*...` are evaluated in sequence
    and the values of the last expression are returned.
  prefs: []
  type: TYPE_NORMAL
- en: If the first clause whose `*test*` evaluates to a true value is in the third
    form given above, the expression `*expr*` is evaluated. The value should be a
    procedure of one argument, which is applied to the value of `*test*`. The values
    of this application are returned.
  prefs: []
  type: TYPE_NORMAL
- en: If none of the tests evaluates to a true value and an `else` clause is present,
    the expressions `*expr[1]* *expr[2]* ...` of the `else` clause are evaluated in
    sequence and the values of the last expression are returned.
  prefs: []
  type: TYPE_NORMAL
- en: If none of the tests evaluates to a true value and no `else` clause is present,
    the value or values are unspecified.
  prefs: []
  type: TYPE_NORMAL
- en: See page [305](syntax.html#defn:cond) for a syntax definition of `cond`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 0])'
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(< x 0) (list ''minus (abs x))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(> x 0) (list ''plus x)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (list ''zero x)])) ![<graphic>](ch2_0.gif) (zero 0)'
  prefs: []
  type: TYPE_NORMAL
- en: (define select
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(not (symbol? x))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(assq x ''((a . 1) (b . 2) (c . 3))) => cdr]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else 0])))'
  prefs: []
  type: TYPE_NORMAL
- en: (select 3) ![<graphic>](ch2_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (select 'b) ![<graphic>](ch2_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (select 'e) ![<graphic>](ch2_0.gif) 0`
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `else`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `=>`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs exceptions)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: These identifiers are auxiliary keywords for `cond`. Both also serve as auxiliary
    keywords for `guard`, and `else` also serves as an auxiliary keyword for `case`.
    It is a syntax violation to reference these identifiers except in contexts where
    they are recognized as auxiliary keywords.
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(when *test-expr* *expr[1]* *expr[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(unless *test-expr* *expr[1]* *expr[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs control)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: For `when`, if `*test-expr*` evaluates to a true value, the expressions `*expr[1]* *expr[2]* ...`
    are evaluated in sequence, and the values of the last expression are returned.
    If `*test-expr*` evaluates to false, none of the other expressions are evaluated,
    and the value or values of `when` are unspecified.
  prefs: []
  type: TYPE_NORMAL
- en: For `unless`, if `*test-expr*` evaluates to false, the expressions `*expr[1]* *expr[2]* ...`
    are evaluated in sequence, and the values of the last expression are returned.
    If `*test-expr*` evaluates to a true value, none of the other expressions are
    evaluated, and the value or values of `unless` are unspecified.
  prefs: []
  type: TYPE_NORMAL
- en: A `when` or `unless` expression is usually clearer than the corresponding "one-armed"
    `if` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x -4] [sign ''plus])'
  prefs: []
  type: TYPE_NORMAL
- en: (when (< x 0)
  prefs: []
  type: TYPE_NORMAL
- en: (set! x (- 0 x))
  prefs: []
  type: TYPE_NORMAL
- en: (set! sign 'minus))
  prefs: []
  type: TYPE_NORMAL
- en: (list sign x)) ![<graphic>](ch2_0.gif) (minus 4)
  prefs: []
  type: TYPE_NORMAL
- en: (define check-pair
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (unless (pair? x)
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-violation 'check-pair "invalid argument" x))
  prefs: []
  type: TYPE_NORMAL
- en: x))
  prefs: []
  type: TYPE_NORMAL
- en: (check-pair '(a b c)) ![<graphic>](ch2_0.gif) (a b c)`
  prefs: []
  type: TYPE_NORMAL
- en: '`when` may be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax when'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e0 e1 e2 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (if e0 (begin e1 e2 ...))]))`
  prefs: []
  type: TYPE_NORMAL
- en: '`unless` may be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax unless'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e0 e1 e2 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (if (not e0) (begin e1 e2 ...))]))`
  prefs: []
  type: TYPE_NORMAL
- en: 'or in terms of `when` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax unless'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e0 e1 e2 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (when (not e0) e1 e2 ...)]))`
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(case *expr[0]* *clause[1]* *clause[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: Each clause but the last must take the form
  prefs: []
  type: TYPE_NORMAL
- en: '`((*key* ...) *expr[1]* *expr[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: where each `*key*` is a datum distinct from the other keys. The last clause
    may be in the above form or it may be an `else` clause of the form
  prefs: []
  type: TYPE_NORMAL
- en: '`(else *expr[1]* *expr[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*expr[0]*` is evaluated and the result is compared (using `eqv?`) against
    the keys of each clause in order. If a clause containing a matching key is found,
    the expressions `*expr[1]* *expr[2]* ...` are evaluated in sequence and the values
    of the last expression are returned.'
  prefs: []
  type: TYPE_NORMAL
- en: If none of the clauses contains a matching key and an `else` clause is present,
    the expressions `*expr[1]* *expr[2]* ...` of the `else` clause are evaluated in
    sequence and the values of the last expression are returned.
  prefs: []
  type: TYPE_NORMAL
- en: If none of the clauses contains a matching key and no `else` clause is present,
    the value or values are unspecified.
  prefs: []
  type: TYPE_NORMAL
- en: See page [306](syntax.html#defn:case) for a syntax definition of `case`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 4] [y 5])'
  prefs: []
  type: TYPE_NORMAL
- en: (case (+ x y)
  prefs: []
  type: TYPE_NORMAL
- en: '[(1 3 5 7 9) ''odd]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(0 2 4 6 8) ''even]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else ''out-of-range])) ![<graphic>](ch2_0.gif) odd`'
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.4\. Recursion and Iteration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**syntax**: `(let *name* ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** values of the final body expression'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: This form of `let`, called `*named*` `let`, is a general-purpose iteration and
    recursion construct. It is similar to the more common form of `let` (see Section [4.4](binding.html#g92))
    in the binding of the variables `*var* ...` to the values of `*expr* ...` within
    the body `*body[1]* *body[2]* ...`, which is processed and evaluated like a `lambda`
    body. In addition, the variable `*name*` is bound within the body to a procedure
    that may be called to recur or iterate; the arguments to the procedure become
    the new values of the variables `*var* ...`.
  prefs: []
  type: TYPE_NORMAL
- en: A named `let` expression of the form
  prefs: []
  type: TYPE_NORMAL
- en: '`(let *name* ((*var* *expr*) ...)'
  prefs: []
  type: TYPE_NORMAL
- en: '*body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: can be rewritten with `letrec` as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`((letrec ((*name* (lambda (*var* ...) *body[1]* *body[2]* ...)))'
  prefs: []
  type: TYPE_NORMAL
- en: '*name*)'
  prefs: []
  type: TYPE_NORMAL
- en: '*expr* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: A syntax definition of `let` that implements this transformation and handles
    unnamed `let` as well can be found on page [312](syntax.html#defn:let).
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `divisors` defined below uses named `let` to compute the nontrivial
    divisors of a nonnegative integer.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define divisors'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([i 2])
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(>= i n) ''()]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(integer? (/ n i)) (cons i (f (+ i 1)))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (f (+ i 1))]))))'
  prefs: []
  type: TYPE_NORMAL
- en: (divisors 5) ![<graphic>](ch2_0.gif) ()
  prefs: []
  type: TYPE_NORMAL
- en: (divisors 32) ![<graphic>](ch2_0.gif) (2 4 8 16)`
  prefs: []
  type: TYPE_NORMAL
- en: The version above is non-tail-recursive when a divisor is found and tail-recursive
    when a divisor is not found. The version below is fully tail-recursive. It builds
    up the list in reverse order, but this is easy to remedy, if desired, by reversing
    the list on exit.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define divisors'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([i 2] [ls '()])
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(>= i n) ls]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(integer? (/ n i)) (f (+ i 1) (cons i ls))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (f (+ i 1) ls)]))))`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(do ((*var* *init* *update*) ...) (*test* *result* ...) *expr* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the values of the last `*result*` expression'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs control)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`do` allows a common restricted form of iteration to be expressed succinctly.
    The variables `*var* ...` are bound initially to the values of `*init* ...` and
    are rebound on each subsequent iteration to the values of `*update* ...`. The
    expressions `*test*`, `*update* ...`, `*expr* ...`, and `*result* ...` are all
    within the scope of the bindings established for `*var* ...`.'
  prefs: []
  type: TYPE_NORMAL
- en: On each step, the test expression `*test*` is evaluated. If the value of `*test*`
    is true, iteration ceases, the expressions `*result* ...` are evaluated in sequence,
    and the values of the last expression are returned. If no result expressions are
    present, the value or values of the `do` expression are unspecified.
  prefs: []
  type: TYPE_NORMAL
- en: If the value of `*test*` is false, the expressions `*expr* ...` are evaluated
    in sequence, the expressions `*update* ...` are evaluated, new bindings for `*var* ...`
    to the values of `*update* ...` are created, and iteration continues.
  prefs: []
  type: TYPE_NORMAL
- en: The expressions `*expr* ...` are evaluated only for effect and are often omitted
    entirely. Any `*update*` expression may be omitted, in which case the effect is
    the same as if the `*update*` were simply the corresponding `*var*`.
  prefs: []
  type: TYPE_NORMAL
- en: Although looping constructs in most languages require that the loop iterands
    be updated via assignment, `do` requires the loop iterands `*var* ...` to be updated
    via rebinding. In fact, no side effects are involved in the evaluation of a `do`
    expression unless they are performed explicitly by its subexpressions.
  prefs: []
  type: TYPE_NORMAL
- en: See page [313](syntax.html#defn:do) for a syntax definition of `do`.
  prefs: []
  type: TYPE_NORMAL
- en: The definitions of `factorial` and `fibonacci` below are straightforward translations
    of the tail-recursive named-`let` versions given in Section [3.2](further.html#g55).
  prefs: []
  type: TYPE_NORMAL
- en: '`(define factorial'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i n (- i 1)] [a 1 (* a i)])
  prefs: []
  type: TYPE_NORMAL
- en: ((zero? i) a))))
  prefs: []
  type: TYPE_NORMAL
- en: (factorial 10) ![<graphic>](ch2_0.gif) 3628800
  prefs: []
  type: TYPE_NORMAL
- en: (define fibonacci
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (if (= n 0)
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i n (- i 1)] [a1 1 (+ a1 a2)] [a2 0 a1])
  prefs: []
  type: TYPE_NORMAL
- en: ((= i 1) a1)))))
  prefs: []
  type: TYPE_NORMAL
- en: (fibonacci 6) ![<graphic>](ch2_0.gif) 8`
  prefs: []
  type: TYPE_NORMAL
- en: The definition of `divisors` below is similar to the tail-recursive definition
    of `divisors` given with the description of named `let` above.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define divisors'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i 2 (+ i 1)]
  prefs: []
  type: TYPE_NORMAL
- en: '[ls ''()'
  prefs: []
  type: TYPE_NORMAL
- en: (if (integer? (/ n i))
  prefs: []
  type: TYPE_NORMAL
- en: (cons i ls)
  prefs: []
  type: TYPE_NORMAL
- en: ls)])
  prefs: []
  type: TYPE_NORMAL
- en: ((>= i n) ls))))`
  prefs: []
  type: TYPE_NORMAL
- en: The definition of `scale-vector!` below, which scales each element of a vector
    *v* by a constant *k*, demonstrates a nonempty `do` body.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define scale-vector!'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (v k)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([n (vector-length v)])
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i 0 (+ i 1)])
  prefs: []
  type: TYPE_NORMAL
- en: ((= i n))
  prefs: []
  type: TYPE_NORMAL
- en: (vector-set! v i (* (vector-ref v i) k))))))
  prefs: []
  type: TYPE_NORMAL
- en: (define vec (vector 1 2 3 4 5))
  prefs: []
  type: TYPE_NORMAL
- en: (scale-vector! vec 2)
  prefs: []
  type: TYPE_NORMAL
- en: vec ![<graphic>](ch2_0.gif) #(2 4 6 8 10)`
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.5\. Mapping and Folding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a program must recur or iterate over the elements of a list, a mapping
    or folding operator is often more convenient. These operators abstract away from
    null checks and explicit recursion by applying a procedure to the elements of
    the list one by one. A few mapping operators are also available for vectors and
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(map *procedure* *list[1]* *list[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** list of results'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`map` applies `*procedure*` to corresponding elements of the lists `*list[1]* *list[2]* ...`
    and returns a list of the resulting values. The lists `*list[1]* *list[2]* ...`
    must be of the same length. `*procedure*` should accept as many arguments as there
    are lists, should return a single value, and should not mutate the `*list*` arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(map abs ''(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) (1 2 3 4 5 6)'
  prefs: []
  type: TYPE_NORMAL
- en: (map (lambda (x y) (* x y))
  prefs: []
  type: TYPE_NORMAL
- en: '''(1 2 3 4)'
  prefs: []
  type: TYPE_NORMAL
- en: '''(8 7 6 5)) ![<graphic>](ch2_0.gif) (8 14 18 20)`'
  prefs: []
  type: TYPE_NORMAL
- en: While the order in which the applications themselves occur is not specified,
    the order of the values in the output list is the same as that of the corresponding
    values in the input lists.
  prefs: []
  type: TYPE_NORMAL
- en: '`map` might be defined as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define map'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (f ls . more)
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? more)
  prefs: []
  type: TYPE_NORMAL
- en: (let map1 ([ls ls])
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: '''()'
  prefs: []
  type: TYPE_NORMAL
- en: (cons (f (car ls))
  prefs: []
  type: TYPE_NORMAL
- en: (map1 (cdr ls)))))
  prefs: []
  type: TYPE_NORMAL
- en: (let map-more ([ls ls] [more more])
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: '''()'
  prefs: []
  type: TYPE_NORMAL
- en: (cons
  prefs: []
  type: TYPE_NORMAL
- en: (apply f (car ls) (map car more))
  prefs: []
  type: TYPE_NORMAL
- en: (map-more (cdr ls) (map cdr more))))))))`
  prefs: []
  type: TYPE_NORMAL
- en: No error checking is done by this version of `map`; `f` is assumed to be a procedure
    and the other arguments are assumed to be proper lists of the same length. An
    interesting feature of this definition is that `map` uses itself to pull out the
    cars and cdrs of the list of input lists; this works because of the special treatment
    of the single-list case.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(for-each *procedure* *list[1]* *list[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for-each` is similar to `map` except that `for-each` does not create and return
    a list of the resulting values, and `for-each` guarantees to perform the applications
    in sequence over the elements from left to right. `*procedure*` should accept
    as many arguments as there are lists and should not mutate the `*list*` arguments.
    `for-each` may be defined without error checks as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define for-each'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (f ls . more)
  prefs: []
  type: TYPE_NORMAL
- en: (do ([ls ls (cdr ls)] [more more (map cdr more)])
  prefs: []
  type: TYPE_NORMAL
- en: ((null? ls))
  prefs: []
  type: TYPE_NORMAL
- en: (apply f (car ls) (map car more)))))
  prefs: []
  type: TYPE_NORMAL
- en: (let ([same-count 0])
  prefs: []
  type: TYPE_NORMAL
- en: (for-each
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y)
  prefs: []
  type: TYPE_NORMAL
- en: (when (= x y)
  prefs: []
  type: TYPE_NORMAL
- en: (set! same-count (+ same-count 1))))
  prefs: []
  type: TYPE_NORMAL
- en: '''(1 2 3 4 5 6)'
  prefs: []
  type: TYPE_NORMAL
- en: '''(2 3 3 4 7 6))'
  prefs: []
  type: TYPE_NORMAL
- en: same-count) ![<graphic>](ch2_0.gif) 3`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(exists *procedure* *list[1]* *list[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The lists `*list[1]* *list[2]* ...` must be of the same length. `*procedure*`
    should accept as many arguments as there are lists and should not mutate the `*list*`
    arguments. If the lists are empty, `exists` returns `#f`. Otherwise, `exists`
    applies `*procedure*` to corresponding elements of the lists `*list[1]* *list[2]* ...`
    in sequence until either the lists each have only one element or `*procedure*`
    returns a true value `*t*`. In the former case, `exists` tail-calls `*procedure*`,
    applying it to the remaining element of each list. In the latter case, `exists`
    returns `*t*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(exists symbol? ''(1.0 #\a "hi" ''())) ![<graphic>](ch2_0.gif) #f'
  prefs: []
  type: TYPE_NORMAL
- en: (exists member
  prefs: []
  type: TYPE_NORMAL
- en: '''(a b c)'
  prefs: []
  type: TYPE_NORMAL
- en: '''((c b) (b a) (a c))) ![<graphic>](ch2_0.gif) (b a)'
  prefs: []
  type: TYPE_NORMAL
- en: (exists (lambda (x y z) (= (+ x y) z))
  prefs: []
  type: TYPE_NORMAL
- en: '''(1 2 3 4)'
  prefs: []
  type: TYPE_NORMAL
- en: '''(1.2 2.3 3.4 4.5)'
  prefs: []
  type: TYPE_NORMAL
- en: '''(2.3 4.4 6.4 8.6)) ![<graphic>](ch2_0.gif) #t`'
  prefs: []
  type: TYPE_NORMAL
- en: '`exists` may be defined (somewhat inefficiently and without error checks) as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define exists'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (f ls . more)
  prefs: []
  type: TYPE_NORMAL
- en: (and (not (null? ls))
  prefs: []
  type: TYPE_NORMAL
- en: (let exists ([x (car ls)] [ls (cdr ls)] [more more])
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: (apply f x (map car more))
  prefs: []
  type: TYPE_NORMAL
- en: (or (apply f x (map car more))
  prefs: []
  type: TYPE_NORMAL
- en: (exists (car ls) (cdr ls) (map cdr more))))))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(for-all *procedure* *list[1]* *list[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The lists `*list[1]* *list[2]* ...` must be of the same length. `*procedure*`
    should accept as many arguments as there are lists and should not mutate the `*list*`
    arguments. If the lists are empty, `for-all` returns `#t`. Otherwise, `for-all`
    applies `*procedure*` to corresponding elements of the lists `*list[1]* *list[2]* ...`
    in sequence until either the lists each have only one element left or `*procedure*`
    returns `#f`. In the former case, `for-all` tail-calls `*procedure*`, applying
    it to the remaining element of each list. In the latter case, `for-all` returns
    `#f`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(for-all symbol? ''(a b c d)) ![<graphic>](ch2_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (for-all =
  prefs: []
  type: TYPE_NORMAL
- en: '''(1 2 3 4)'
  prefs: []
  type: TYPE_NORMAL
- en: '''(1.0 2.0 3.0 4.0)) ![<graphic>](ch2_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (for-all (lambda (x y z) (= (+ x y) z))
  prefs: []
  type: TYPE_NORMAL
- en: '''(1 2 3 4)'
  prefs: []
  type: TYPE_NORMAL
- en: '''(1.2 2.3 3.4 4.5)'
  prefs: []
  type: TYPE_NORMAL
- en: '''(2.2 4.3 6.5 8.5)) ![<graphic>](ch2_0.gif) #f`'
  prefs: []
  type: TYPE_NORMAL
- en: '`for-all` may be defined (somewhat inefficiently and without error checks)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define for-all'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (f ls . more)
  prefs: []
  type: TYPE_NORMAL
- en: (or (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: (let for-all ([x (car ls)] [ls (cdr ls)] [more more])
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: (apply f x (map car more))
  prefs: []
  type: TYPE_NORMAL
- en: (and (apply f x (map car more))
  prefs: []
  type: TYPE_NORMAL
- en: (for-all (car ls) (cdr ls) (map cdr more))))))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fold-left *procedure* *obj* *list[1]* *list[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The `*list*` arguments should all have the same length. `*procedure*` should
    accept one more argument than the number of `*list*` arguments and return a single
    value. It should not mutate the `*list*` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '`fold-left` returns `*obj*` if the `*list*` arguments are empty. If they are
    not empty, `fold-left` applies `*procedure*` to `*obj*` and the cars of `*list[1]* *list[2]* ...`,
    then recurs with the value returned by `*procedure*` in place of `*obj*` and the
    cdr of each `*list*` in place of the `*list*`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fold-left cons ''() ''(1 2 3 4)) ![<graphic>](ch2_0.gif) ((((() . 1) . 2) . 3) . 4)'
  prefs: []
  type: TYPE_NORMAL
- en: (fold-left
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (a x) (+ a (* x x)))
  prefs: []
  type: TYPE_NORMAL
- en: 0 '(1 2 3 4 5)) ![<graphic>](ch2_0.gif) 55
  prefs: []
  type: TYPE_NORMAL
- en: (fold-left
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (a . args) (append args a))
  prefs: []
  type: TYPE_NORMAL
- en: '''(question)'
  prefs: []
  type: TYPE_NORMAL
- en: '''(that not to)'
  prefs: []
  type: TYPE_NORMAL
- en: '''(is to be)'
  prefs: []
  type: TYPE_NORMAL
- en: '''(the be: or)) ![<graphic>](ch2_0.gif) (to be or not to be: that is the question)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fold-right *procedure* *obj* *list[1]* *list[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The `*list*` arguments should all have the same length. `*procedure*` should
    accept one more argument than the number of `*list*` arguments and return a single
    value. It should not mutate the `*list*` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '`fold-right` returns `*obj*` if the `*list*` arguments are empty. If they are
    not empty, `fold-right` recurs with the cdr of each `*list*` replacing the `*list*`,
    then applies `*procedure*` to the cars of `*list[1]* *list[2]* ...` and the result
    returned by the recursion.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(fold-right cons ''() ''(1 2 3 4)) ![<graphic>](ch2_0.gif) (1 2 3 4)'
  prefs: []
  type: TYPE_NORMAL
- en: (fold-right
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x a) (+ a (* x x)))
  prefs: []
  type: TYPE_NORMAL
- en: 0 '(1 2 3 4 5)) ![<graphic>](ch2_0.gif) 55
  prefs: []
  type: TYPE_NORMAL
- en: (fold-right
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y a) (cons* x y a))   ![<graphic>](ch2_0.gif) (parting is such sweet sorrow
  prefs: []
  type: TYPE_NORMAL
- en: '''((with apologies))              ![](ch3_ghostRightarrow.gif)  gotta go see ya tomorrow'
  prefs: []
  type: TYPE_NORMAL
- en: '''(parting such sorrow go ya)     ![](ch3_ghostRightarrow.gif)  (with apologies))'
  prefs: []
  type: TYPE_NORMAL
- en: '''(is sweet gotta see tomorrow))`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector-map *procedure* *vector[1]* *vector[1]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** vector of results'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`vector-map` applies `*procedure*` to corresponding elements of `*vector[1]* *vector[2]* ...`
    and returns a vector of the resulting values. The vectors `*vector[1]* *vector[2]* ...`
    must be of the same length, and `*procedure*` should accept as many arguments
    as there are vectors and return a single value.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(vector-map abs ''#(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) #(1 2 3 4 5 6)'
  prefs: []
  type: TYPE_NORMAL
- en: (vector-map (lambda (x y) (* x y))
  prefs: []
  type: TYPE_NORMAL
- en: '''#(1 2 3 4)'
  prefs: []
  type: TYPE_NORMAL
- en: '''#(8 7 6 5)) ![<graphic>](ch2_0.gif) #(8 14 18 20)`'
  prefs: []
  type: TYPE_NORMAL
- en: While the order in which the applications themselves occur is not specified,
    the order of the values in the output vector is the same as that of the corresponding
    values in the input vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector-for-each *procedure* *vector[1]* *vector[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`vector-for-each` is similar to `vector-map` except that `vector-for-each`
    does not create and return a vector of the resulting values, and `vector-for-each`
    guarantees to perform the applications in sequence over the elements from left
    to right.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([same-count 0])'
  prefs: []
  type: TYPE_NORMAL
- en: (vector-for-each
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y)
  prefs: []
  type: TYPE_NORMAL
- en: (when (= x y)
  prefs: []
  type: TYPE_NORMAL
- en: (set! same-count (+ same-count 1))))
  prefs: []
  type: TYPE_NORMAL
- en: '''#(1 2 3 4 5 6)'
  prefs: []
  type: TYPE_NORMAL
- en: '''#(2 3 3 4 7 6))'
  prefs: []
  type: TYPE_NORMAL
- en: same-count) ![<graphic>](ch2_0.gif) 3`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-for-each *procedure* *string[1]* *string[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`string-for-each` is similar to `for-each` and `vector-for-each` except that
    the inputs are strings rather than lists or vectors.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([ls ''()])'
  prefs: []
  type: TYPE_NORMAL
- en: (string-for-each
  prefs: []
  type: TYPE_NORMAL
- en: (lambda r (set! ls (cons r ls)))
  prefs: []
  type: TYPE_NORMAL
- en: '"abcd"'
  prefs: []
  type: TYPE_NORMAL
- en: '"===="'
  prefs: []
  type: TYPE_NORMAL
- en: '"1234")'
  prefs: []
  type: TYPE_NORMAL
- en: (map list->string (reverse ls))) ![<graphic>](ch2_0.gif) ("a=1" "b=2" "c=3" "d=4")`
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.6\. Continuations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Continuations in Scheme are procedures that represent the remainder of a computation
    from a given point in the computation. They may be obtained with `call-with-current-continuation`,
    which can be abbreviated to `call/cc`.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(call/cc *procedure*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(call-with-current-continuation *procedure*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: These procedures are the same. The shorter name is often used for the obvious
    reason that it requires fewer keystrokes to type.
  prefs: []
  type: TYPE_NORMAL
- en: '`call/cc` obtains its continuation and passes it to `*procedure*`, which should
    accept one argument. The continuation itself is represented by a procedure. Each
    time this procedure is applied to zero or more values, it returns the values to
    the continuation of the `call/cc` application. That is, when the continuation
    procedure is called, it returns its arguments as the values of the application
    of `call/cc`.'
  prefs: []
  type: TYPE_NORMAL
- en: If `*procedure*` returns normally when passed the continuation procedure, the
    values returned by `call/cc` are the values returned by `*procedure*`.
  prefs: []
  type: TYPE_NORMAL
- en: Continuations allow the implementation of nonlocal exits, backtracking [[14](bibliography.html#g232),[29](bibliography.html#g247)],
    coroutines [[16](bibliography.html#g234)], and multitasking [[10](bibliography.html#g228),[32](bibliography.html#g250)].
  prefs: []
  type: TYPE_NORMAL
- en: The example below illustrates the use of a continuation to perform a nonlocal
    exit from a loop.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define member'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x ls)
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (break)
  prefs: []
  type: TYPE_NORMAL
- en: (do ([ls ls (cdr ls)])
  prefs: []
  type: TYPE_NORMAL
- en: ((null? ls) #f)
  prefs: []
  type: TYPE_NORMAL
- en: (when (equal? x (car ls))
  prefs: []
  type: TYPE_NORMAL
- en: (break ls)))))))
  prefs: []
  type: TYPE_NORMAL
- en: (member 'd '(a b c)) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (member 'b '(a b c)) ![<graphic>](ch2_0.gif) (b c)`
  prefs: []
  type: TYPE_NORMAL
- en: Additional examples are given in Sections [3.3](further.html#g63) and [12.11](examples.html#g208).
  prefs: []
  type: TYPE_NORMAL
- en: The current continuation is typically represented internally as a stack of procedure
    activation records, and obtaining the continuation involves encapsulating the
    stack within a procedural object. Since an encapsulated stack has indefinite extent,
    some mechanism must be used to preserve the stack contents indefinitely. This
    can be done with surprising ease and efficiency and with no impact on programs
    that do not use continuations [[17](bibliography.html#g235)].
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(dynamic-wind *in* *body* *out*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** values resulting from the application of `*body*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`dynamic-wind` offers "protection" from continuation invocation. It is useful
    for performing tasks that must be performed whenever control enters or leaves
    `*body*`, either normally or by continuation application.'
  prefs: []
  type: TYPE_NORMAL
- en: The three arguments `*in*`, `*body*`, and `*out*` must be procedures and should
    accept zero arguments, i.e., they should be `*thunks*`. Before applying `*body*`,
    and each time `*body*` is entered subsequently by the application of a continuation
    created within `*body*`, the `*in*` thunk is applied. Upon normal exit from `*body*`
    and each time `*body*` is exited by the application of a continuation created
    outside `*body*`, the `*out*` thunk is applied.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, it is guaranteed that `*in*` is invoked at least once. In addition, if
    `*body*` ever returns, `*out*` is invoked at least once.
  prefs: []
  type: TYPE_NORMAL
- en: The following example demonstrates the use of `dynamic-wind` to be sure that
    an input port is closed after processing, regardless of whether the processing
    completes normally.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([p (open-input-file "input-file")])'
  prefs: []
  type: TYPE_NORMAL
- en: (dynamic-wind
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () #f)
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (process p))
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (close-port p))))`
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp provides a similar facility (`unwind-protect`) for protection from
    nonlocal exits. This is often sufficient. `unwind-protect` provides only the equivalent
    to `*out*`, however, since Common Lisp does not support fully general continuations.
    Here is how `unwind-protect` might be specified with `dynamic-wind`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax unwind-protect'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ body cleanup ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (dynamic-wind
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () #f)
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () body)
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () cleanup ...))]))
  prefs: []
  type: TYPE_NORMAL
- en: ((call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x 'a])
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (k)
  prefs: []
  type: TYPE_NORMAL
- en: (unwind-protect
  prefs: []
  type: TYPE_NORMAL
- en: (k (lambda () x))
  prefs: []
  type: TYPE_NORMAL
- en: (set! x 'b)))))) ![<graphic>](ch2_0.gif) b`
  prefs: []
  type: TYPE_NORMAL
- en: Some Scheme implementations support a controlled form of assignment known as
    *fluid binding*, in which a variable takes on a temporary value during a given
    computation and reverts to the old value after the computation has completed.
    The syntactic form `fluid-let` defined below in terms of `dynamic-wind` permits
    the fluid binding of a single variable `x` to the value of an expression `e` within
    a the body `b1 b2 ...`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax fluid-let'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ ((x e)) b1 b2 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([y e])
  prefs: []
  type: TYPE_NORMAL
- en: (let ([swap (lambda () (let ([t x]) (set! x y) (set! y t)))])
  prefs: []
  type: TYPE_NORMAL
- en: (dynamic-wind swap (lambda () b1 b2 ...) swap)))]))`
  prefs: []
  type: TYPE_NORMAL
- en: Implementations that support `fluid-let` typically extend it to allow an indefinite
    number of `(x e)` pairs, as with `let`.
  prefs: []
  type: TYPE_NORMAL
- en: If no continuations are invoked within the body of a `fluid-let`, the behavior
    is the same as if the variable were simply assigned the new value on entry and
    assigned the old value on return.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 3])'
  prefs: []
  type: TYPE_NORMAL
- en: (+ (fluid-let ([x 5])
  prefs: []
  type: TYPE_NORMAL
- en: x)
  prefs: []
  type: TYPE_NORMAL
- en: x)) ![<graphic>](ch2_0.gif) 8`
  prefs: []
  type: TYPE_NORMAL
- en: A fluid-bound variable also reverts to the old value if a continuation created
    outside of the `fluid-let` is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x ''a])'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda () x)])
  prefs: []
  type: TYPE_NORMAL
- en: (cons (call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (k)
  prefs: []
  type: TYPE_NORMAL
- en: (fluid-let ([x 'b])
  prefs: []
  type: TYPE_NORMAL
- en: (k (f)))))
  prefs: []
  type: TYPE_NORMAL
- en: (f)))) ![<graphic>](ch2_0.gif) (b . a)`
  prefs: []
  type: TYPE_NORMAL
- en: If control has left a `fluid-let` body, either normally or by the invocation
    of a continuation, and control reenters the body by the invocation of a continuation,
    the temporary value of the fluid-bound variable is reinstated. Furthermore, any
    changes to the temporary value are maintained and reflected upon reentry.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define reenter #f)'
  prefs: []
  type: TYPE_NORMAL
- en: (define x 0)
  prefs: []
  type: TYPE_NORMAL
- en: (fluid-let ([x 1])
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc (lambda (k) (set! reenter k)))
  prefs: []
  type: TYPE_NORMAL
- en: (set! x (+ x 1))
  prefs: []
  type: TYPE_NORMAL
- en: x) ![<graphic>](ch2_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: x ![<graphic>](ch2_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (reenter '*) ![<graphic>](ch2_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (reenter '*) ![<graphic>](ch2_0.gif) 4
  prefs: []
  type: TYPE_NORMAL
- en: x ![<graphic>](ch2_0.gif) 0`
  prefs: []
  type: TYPE_NORMAL
- en: A library showing how `dynamic-wind` might be implemented were it not already
    built in is given below. In addition to defining `dynamic-wind`, the code defines
    a version of `call/cc` that does its part to support `dynamic-wind`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(library (dynamic-wind)'
  prefs: []
  type: TYPE_NORMAL
- en: (export dynamic-wind call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (rename (call/cc call-with-current-continuation)))
  prefs: []
  type: TYPE_NORMAL
- en: (import (rename (except (rnrs) dynamic-wind) (call/cc rnrs:call/cc)))
  prefs: []
  type: TYPE_NORMAL
- en: (define winders '())
  prefs: []
  type: TYPE_NORMAL
- en: (define common-tail
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([lx (length x)] [ly (length y)])
  prefs: []
  type: TYPE_NORMAL
- en: (do ([x (if (> lx ly) (list-tail x (- lx ly)) x) (cdr x)]
  prefs: []
  type: TYPE_NORMAL
- en: '[y (if (> ly lx) (list-tail y (- ly lx)) y) (cdr y)])'
  prefs: []
  type: TYPE_NORMAL
- en: ((eq? x y) x)))))
  prefs: []
  type: TYPE_NORMAL
- en: (define do-wind
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (new)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([tail (common-tail new winders)])
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([ls winders])
  prefs: []
  type: TYPE_NORMAL
- en: (if (not (eq? ls tail))
  prefs: []
  type: TYPE_NORMAL
- en: (begin
  prefs: []
  type: TYPE_NORMAL
- en: (set! winders (cdr ls))
  prefs: []
  type: TYPE_NORMAL
- en: ((cdar ls))
  prefs: []
  type: TYPE_NORMAL
- en: (f (cdr ls)))))
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([ls new])
  prefs: []
  type: TYPE_NORMAL
- en: (if (not (eq? ls tail))
  prefs: []
  type: TYPE_NORMAL
- en: (begin
  prefs: []
  type: TYPE_NORMAL
- en: (f (cdr ls))
  prefs: []
  type: TYPE_NORMAL
- en: ((caar ls))
  prefs: []
  type: TYPE_NORMAL
- en: (set! winders ls)))))))`
  prefs: []
  type: TYPE_NORMAL
- en: '`  (define call/cc'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (f)
  prefs: []
  type: TYPE_NORMAL
- en: (rnrs:call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (k)
  prefs: []
  type: TYPE_NORMAL
- en: (f (let ([save winders])
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (unless (eq? save winders) (do-wind save))
  prefs: []
  type: TYPE_NORMAL
- en: (k x))))))))
  prefs: []
  type: TYPE_NORMAL
- en: (define dynamic-wind
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (in body out)
  prefs: []
  type: TYPE_NORMAL
- en: (in)
  prefs: []
  type: TYPE_NORMAL
- en: (set! winders (cons (cons in out) winders))
  prefs: []
  type: TYPE_NORMAL
- en: (let-values ([ans* (body)])
  prefs: []
  type: TYPE_NORMAL
- en: (set! winders (cdr winders))
  prefs: []
  type: TYPE_NORMAL
- en: (out)
  prefs: []
  type: TYPE_NORMAL
- en: (apply values ans*)))))`
  prefs: []
  type: TYPE_NORMAL
- en: Together, `dynamic-wind` and `call/cc` manage a list of *winders*. A winder
    is a pair of *in* and *out* thunks established by a call to `dynamic-wind`. Whenever
    `dynamic-wind` is invoked, the *in* thunk is invoked, a new winder containing
    the *in* and *out* thunks is placed on the winders list, the *body* thunk is invoked,
    the winder is removed from the winders list, and the *out* thunk is invoked. This
    ordering ensures that the winder is on the winders list only when control has
    passed through *in* and not yet entered *out*. Whenever a continuation is obtained,
    the winders list is saved, and whenever the continuation is invoked, the saved
    winders list is reinstated. During reinstatement, the *out* thunk of each winder
    on the current winders list that is not also on the saved winders list is invoked,
    followed by the *in* thunk of each winder on the saved winders list that is not
    also on the current winders list. The winders list is updated incrementally, again
    to ensure that a winder is on the current winders list only if control has passed
    through its *in* thunk and not entered its *out* thunk.
  prefs: []
  type: TYPE_NORMAL
- en: The test `(not (eq? save winders))` performed in `call/cc` is not strictly necessary
    but makes invoking a continuation less costly whenever the saved winders list
    is the same as the current winders list.
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.7\. Delayed Evaluation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The syntactic form `delay` and the procedure `force` may be used in combination
    to implement *lazy evaluation*. An expression subject to lazy evaluation is not
    evaluated until its value is required and, once evaluated, is never reevaluated.
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(delay *expr*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a promise'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(force *promise*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** result of forcing `*promise*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs r5rs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The first time a promise created by `delay` is *forced* (with `force`), it evaluates
    `*expr*`, "remembering" the resulting value. Thereafter, each time the promise
    is forced, it returns the remembered value instead of reevaluating `*expr*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`delay` and `force` are typically used only in the absence of side effects,
    e.g., assignments, so that the order of evaluation is unimportant.'
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of using `delay` and `force` is that some amount of computation
    might be avoided altogether if it is delayed until absolutely required. Delayed
    evaluation may be used to construct conceptually infinite lists, or *streams*.
    The example below shows how a stream abstraction may be built with `delay` and
    `force`. A stream is a promise that, when forced, returns a pair whose cdr is
    a stream.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define stream-car'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s)
  prefs: []
  type: TYPE_NORMAL
- en: (car (force s))))
  prefs: []
  type: TYPE_NORMAL
- en: (define stream-cdr
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s)
  prefs: []
  type: TYPE_NORMAL
- en: (cdr (force s))))
  prefs: []
  type: TYPE_NORMAL
- en: (define counters
  prefs: []
  type: TYPE_NORMAL
- en: (let next ([n 1])
  prefs: []
  type: TYPE_NORMAL
- en: (delay (cons n (next (+ n 1))))))
  prefs: []
  type: TYPE_NORMAL
- en: (stream-car counters) ![<graphic>](ch2_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (stream-car (stream-cdr counters)) ![<graphic>](ch2_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (define stream-add
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s1 s2)
  prefs: []
  type: TYPE_NORMAL
- en: (delay (cons
  prefs: []
  type: TYPE_NORMAL
- en: (+ (stream-car s1) (stream-car s2))
  prefs: []
  type: TYPE_NORMAL
- en: (stream-add (stream-cdr s1) (stream-cdr s2))))))
  prefs: []
  type: TYPE_NORMAL
- en: (define even-counters
  prefs: []
  type: TYPE_NORMAL
- en: (stream-add counters counters))
  prefs: []
  type: TYPE_NORMAL
- en: (stream-car even-counters) ![<graphic>](ch2_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (stream-car (stream-cdr even-counters)) ![<graphic>](ch2_0.gif) 4`
  prefs: []
  type: TYPE_NORMAL
- en: '`delay` may be defined by'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax delay'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ expr) (make-promise (lambda () expr))]))`'
  prefs: []
  type: TYPE_NORMAL
- en: where `make-promise` might be defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define make-promise'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([val #f] [set? #f])
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (unless set?
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (p)])
  prefs: []
  type: TYPE_NORMAL
- en: (unless set?
  prefs: []
  type: TYPE_NORMAL
- en: (set! val x)
  prefs: []
  type: TYPE_NORMAL
- en: (set! set? #t))))
  prefs: []
  type: TYPE_NORMAL
- en: val))))`
  prefs: []
  type: TYPE_NORMAL
- en: With this definition of `delay`, `force` simply invokes the promise to force
    evaluation or to retrieve the saved value.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define force'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (promise)
  prefs: []
  type: TYPE_NORMAL
- en: (promise)))`
  prefs: []
  type: TYPE_NORMAL
- en: The second test of the variable `set?` in `make-promise` is necessary in the
    event that, as a result of applying `*p*`, the promise is recursively forced.
    Since a promise must always return the same value, the result of the first application
    of `*p*` to complete is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Whether `delay` and `force` handle multiple return values is unspecified; the
    implementation given above does not, but the following version does, with the
    help of `call-with-values` and `apply`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define make-promise'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([vals #f] [set? #f])
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (unless set?
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values p
  prefs: []
  type: TYPE_NORMAL
- en: (lambda x
  prefs: []
  type: TYPE_NORMAL
- en: (unless set?
  prefs: []
  type: TYPE_NORMAL
- en: (set! vals x)
  prefs: []
  type: TYPE_NORMAL
- en: (set! set? #t)))))
  prefs: []
  type: TYPE_NORMAL
- en: (apply values vals)))))
  prefs: []
  type: TYPE_NORMAL
- en: (define p (delay (values 1 2 3)))
  prefs: []
  type: TYPE_NORMAL
- en: (force p) ![<graphic>](ch2_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) 2'
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) 3'
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values (lambda () (force p)) +) ![<graphic>](ch2_0.gif) 6`
  prefs: []
  type: TYPE_NORMAL
- en: Neither implementation is quite right, since `force` must raise an exception
    with condition type `&assertion` if its argument is not a promise. Since distinguishing
    procedures created by `make-promise` from other procedures is impossible, `force`
    cannot do so reliably. The following reimplementation of `make-promise` and `force`
    represents promises as records of the type `promise` to allow `force` to make
    the required check.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-record-type promise'
  prefs: []
  type: TYPE_NORMAL
- en: (fields (immutable p) (mutable vals) (mutable set?))
  prefs: []
  type: TYPE_NORMAL
- en: (protocol (lambda (new) (lambda (p) (new p #f #f)))))
  prefs: []
  type: TYPE_NORMAL
- en: (define force
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (promise)
  prefs: []
  type: TYPE_NORMAL
- en: (unless (promise? promise)
  prefs: []
  type: TYPE_NORMAL
- en: (assertion-violation 'promise "invalid argument" promise))
  prefs: []
  type: TYPE_NORMAL
- en: (unless (promise-set? promise)
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values (promise-p promise)
  prefs: []
  type: TYPE_NORMAL
- en: (lambda x
  prefs: []
  type: TYPE_NORMAL
- en: (unless (promise-set? promise)
  prefs: []
  type: TYPE_NORMAL
- en: (promise-vals-set! promise x)
  prefs: []
  type: TYPE_NORMAL
- en: (promise-set?-set! promise #t)))))
  prefs: []
  type: TYPE_NORMAL
- en: (apply values (promise-vals promise))))`
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.8\. Multiple Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While all Scheme primitives and most user-defined procedures return exactly
    one value, some programming problems are best solved by returning zero values,
    more than one value, or even a variable number of values. For example, a procedure
    that partitions a list of values into two sublists needs to return two values.
    While it is possible for the producer of multiple values to package them into
    a data structure and for the consumer to extract them, it is often cleaner to
    use the built-in multiple-values interface. This interface consists of two procedures:
    `values` and `call-with-values`. The former produces multiple values and the latter
    links procedures that produce multiple-value values with procedures that consume
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(values *obj* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*obj* ...`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `values` accepts any number of arguments and simply passes (returns)
    the arguments to its continuation.
  prefs: []
  type: TYPE_NORMAL
- en: '`(values) ![<graphic>](ch2_0.gif)'
  prefs: []
  type: TYPE_NORMAL
- en: (values 1) ![<graphic>](ch2_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (values 1 2 3) ![<graphic>](ch2_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) 2'
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) 3'
  prefs: []
  type: TYPE_NORMAL
- en: (define head&tail
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (values (car ls) (cdr ls))))
  prefs: []
  type: TYPE_NORMAL
- en: (head&tail '(a b c)) ![<graphic>](ch2_0.gif) a
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) (b c)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(call-with-values *producer* *consumer*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*producer*` and `*consumer*` must be procedures. `call-with-values` applies
    `*consumer*` to the values returned by invoking `*producer*` without arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(call-with-values'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (values 'bond 'james))
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y) (cons y x))) ![<graphic>](ch2_0.gif) (james . bond)
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values values list) ![<graphic>](ch2_0.gif) '()`
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, `values` itself serves as the producer. It receives no
    arguments and thus returns no values. `list` is thus applied to no arguments and
    so returns the empty list.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `dxdy` defined below computes the change in `*x*` and `*y*` coordinates
    for a pair of points whose coordinates are represented by `(*x* . *y*)` pairs.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define dxdy'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p1 p2)
  prefs: []
  type: TYPE_NORMAL
- en: (values (- (car p2) (car p1))
  prefs: []
  type: TYPE_NORMAL
- en: (- (cdr p2) (cdr p1)))))
  prefs: []
  type: TYPE_NORMAL
- en: (dxdy '(0 . 0) '(0 . 5)) ![<graphic>](ch2_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) 5`'
  prefs: []
  type: TYPE_NORMAL
- en: '`dxdy` can be used to compute the length and slope of a segment represented
    by two endpoints.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define segment-length'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p1 p2)
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (dxdy p1 p2))
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (dx dy) (sqrt (+ (* dx dx) (* dy dy)))))))
  prefs: []
  type: TYPE_NORMAL
- en: (define segment-slope
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p1 p2)
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (dxdy p1 p2))
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (dx dy) (/ dy dx)))))
  prefs: []
  type: TYPE_NORMAL
- en: (segment-length '(1 . 4) '(4 . 8)) ![<graphic>](ch2_0.gif) 5
  prefs: []
  type: TYPE_NORMAL
- en: (segment-slope '(1 . 4) '(4 . 8)) ![<graphic>](ch2_0.gif) 4/3`
  prefs: []
  type: TYPE_NORMAL
- en: We can of course combine these to form one procedure that returns two values.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define describe-segment'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p1 p2)
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (dxdy p1 p2))
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (dx dy)
  prefs: []
  type: TYPE_NORMAL
- en: (values
  prefs: []
  type: TYPE_NORMAL
- en: (sqrt (+ (* dx dx) (* dy dy)))
  prefs: []
  type: TYPE_NORMAL
- en: (/ dy dx))))))
  prefs: []
  type: TYPE_NORMAL
- en: (describe-segment '(1 . 4) '(4 . 8)) ![<graphic>](ch2_0.gif) 5
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch2_0.gif) 4/3`'
  prefs: []
  type: TYPE_NORMAL
- en: The example below employs multiple values to divide a list nondestructively
    into two sublists of alternating elements.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define split'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (if (or (null? ls) (null? (cdr ls)))
  prefs: []
  type: TYPE_NORMAL
- en: (values ls '())
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (split (cddr ls)))
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (odds evens)
  prefs: []
  type: TYPE_NORMAL
- en: (values (cons (car ls) odds)
  prefs: []
  type: TYPE_NORMAL
- en: (cons (cadr ls) evens)))))))
  prefs: []
  type: TYPE_NORMAL
- en: (split '(a b c d e f)) ![<graphic>](ch2_0.gif) (a c e)
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) (b d f)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'At each level of recursion, the procedure `split` returns two values: a list
    of the odd-numbered elements from the argument list and a list of the even-numbered
    elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The continuation of a call to `values` need not be one established by a call
    to `call-with-values`, nor must only `values` be used to return to a continuation
    established by `call-with-values`. In particular, `(values *e*)` and `*e*` are
    equivalent expressions. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ (values 2) 4) ![<graphic>](ch2_0.gif) 6'
  prefs: []
  type: TYPE_NORMAL
- en: (if (values #t) 1 2) ![<graphic>](ch2_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () 4)
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x) x)) ![<graphic>](ch2_0.gif) 4`
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, `values` may be used to pass any number of values to a continuation
    that ignores the values, as in the following.
  prefs: []
  type: TYPE_NORMAL
- en: '`(begin (values 1 2 3) 4) ![<graphic>](ch2_0.gif) 4`'
  prefs: []
  type: TYPE_NORMAL
- en: Because a continuation may accept zero or more than one value, continuations
    obtained via `call/cc` may accept zero or more than one argument.
  prefs: []
  type: TYPE_NORMAL
- en: '`(call-with-values'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc (lambda (k) (k 2 3))))
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y) (list x y))) ![<graphic>](ch2_0.gif) (2 3)`
  prefs: []
  type: TYPE_NORMAL
- en: The behavior is unspecified when a continuation expecting exactly one value
    receives zero values or more than one value. For example, the behavior of each
    of the following expressions is unspecified. Some implementations raise an exception,
    while others silently suppress additional values or supply defaults for missing
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '`(if (values 1 2) ''x ''y)'
  prefs: []
  type: TYPE_NORMAL
- en: (+ (values) 5)`
  prefs: []
  type: TYPE_NORMAL
- en: Programs that wish to force extra values to be ignored in particular contexts
    can do so easily by calling `call-with-values` explicitly. A syntactic form, which
    we might call `first`, can be defined to abstract the discarding of more than
    one value when only one is desired.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax first'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ expr)'
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () expr)
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x . y) x))]))
  prefs: []
  type: TYPE_NORMAL
- en: (if (first (values #t #f)) 'a 'b) ![<graphic>](ch2_0.gif) a`
  prefs: []
  type: TYPE_NORMAL
- en: Since implementations are required to raise an exception with condition type
    `&assertion` if a procedure does not accept the number of arguments passed to
    it, each of the following raises an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '`(call-with-values'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (values 2 3 4))
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y) x))
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (call/cc (lambda (k) (k 0))))
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y) x))`
  prefs: []
  type: TYPE_NORMAL
- en: Since `*producer*` is most often a `lambda` expression, it is often convenient
    to use a syntactic extension that suppresses the lambda expression in the interest
    of readability.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax with-values'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ expr consumer)'
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values (lambda () expr) consumer)]))
  prefs: []
  type: TYPE_NORMAL
- en: (with-values (values 1 2) list) ![<graphic>](ch2_0.gif) (1 2)
  prefs: []
  type: TYPE_NORMAL
- en: (with-values (split '(1 2 3 4))
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (odds evens)
  prefs: []
  type: TYPE_NORMAL
- en: evens)) ![<graphic>](ch2_0.gif) (2 4)`
  prefs: []
  type: TYPE_NORMAL
- en: If the `*consumer*` is also a `lambda` expression, the multiple-value variants
    of `let` and `let*` described in Section [4.5](binding.html#g93) are usually even
    more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let-values ([(odds evens) (split ''(1 2 3 4))])'
  prefs: []
  type: TYPE_NORMAL
- en: evens) ![<graphic>](ch2_0.gif) (2 4)
  prefs: []
  type: TYPE_NORMAL
- en: (let-values ([ls (values 'a 'b 'c)])
  prefs: []
  type: TYPE_NORMAL
- en: ls) ![<graphic>](ch2_0.gif) (a b c)`
  prefs: []
  type: TYPE_NORMAL
- en: 'Many standard syntactic forms and procedures pass along multiple values. Most
    of these are "automatic," in the sense that nothing special must be done by the
    implementation to make this happen. The usual expansion of `let` into a direct
    `lambda` call automatically propagates multiple values produced by the body of
    the `let`. Other operators must be coded specially to pass along multiple values.
    The `call-with-port` procedure (page [7.6](io.html#g127)), for example, calls
    its procedure argument, then closes the port argument before returning the procedure''s
    values, so it must save the values temporarily. This is easily accomplished via
    `let-values`, `apply`, and `values`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define call-with-port'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (port proc)
  prefs: []
  type: TYPE_NORMAL
- en: (let-values ([val* (proc port)])
  prefs: []
  type: TYPE_NORMAL
- en: (close-port port)
  prefs: []
  type: TYPE_NORMAL
- en: (apply values val*))))`
  prefs: []
  type: TYPE_NORMAL
- en: 'If this seems like too much overhead when a single value is returned, the code
    can use `call-with-values` and `case-lambda` to handle the single-value case more
    efficiently:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define call-with-port'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (port proc)
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values (lambda () (proc port))
  prefs: []
  type: TYPE_NORMAL
- en: (case-lambda
  prefs: []
  type: TYPE_NORMAL
- en: '[(val) (close-port port) val]'
  prefs: []
  type: TYPE_NORMAL
- en: '[val* (close-port port) (apply values val*)]))))`'
  prefs: []
  type: TYPE_NORMAL
- en: The definitions of `values` and `call-with-values` (and concomitant redefinition
    of `call/cc`) in the library below demonstrate that the multiple-return-values
    interface could be implemented in Scheme if it were not already built in. No error
    checking can be done, however, for the case in which more than one value is returned
    to a single-value context, such as the test part of an `if` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '`(library (mrvs)'
  prefs: []
  type: TYPE_NORMAL
- en: (export call-with-values values call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (rename (call/cc call-with-current-continuation)))
  prefs: []
  type: TYPE_NORMAL
- en: (import
  prefs: []
  type: TYPE_NORMAL
- en: (rename
  prefs: []
  type: TYPE_NORMAL
- en: (except (rnrs) values call-with-values)
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc rnrs:call/cc)))
  prefs: []
  type: TYPE_NORMAL
- en: (define magic (cons 'multiple 'values))
  prefs: []
  type: TYPE_NORMAL
- en: (define magic?
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (and (pair? x) (eq? (car x) magic))))`
  prefs: []
  type: TYPE_NORMAL
- en: '`  (define call/cc'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p)
  prefs: []
  type: TYPE_NORMAL
- en: (rnrs:call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (k)
  prefs: []
  type: TYPE_NORMAL
- en: (p (lambda args
  prefs: []
  type: TYPE_NORMAL
- en: (k (apply values args))))))))
  prefs: []
  type: TYPE_NORMAL
- en: (define values
  prefs: []
  type: TYPE_NORMAL
- en: (lambda args
  prefs: []
  type: TYPE_NORMAL
- en: (if (and (not (null? args)) (null? (cdr args)))
  prefs: []
  type: TYPE_NORMAL
- en: (car args)
  prefs: []
  type: TYPE_NORMAL
- en: (cons magic args))))
  prefs: []
  type: TYPE_NORMAL
- en: (define call-with-values
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (producer consumer)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (producer)])
  prefs: []
  type: TYPE_NORMAL
- en: (if (magic? x)
  prefs: []
  type: TYPE_NORMAL
- en: (apply consumer (cdr x))
  prefs: []
  type: TYPE_NORMAL
- en: (consumer x))))))`
  prefs: []
  type: TYPE_NORMAL
- en: Multiple values can be implemented more efficiently [[2](bibliography.html#g220)],
    but this code serves to illustrate the meanings of the operators and may be used
    to provide multiple values in older, nonstandard implementations that do not support
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.9\. Eval
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scheme's `eval` procedure allows programmers to write programs that construct
    and evaluate other programs. This ability to do run-time *meta programming* should
    not be overused but is handy when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(eval *obj* *environment*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** values of the Scheme expression represented by `*obj*` in `*environment*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs eval)`'
  prefs: []
  type: TYPE_NORMAL
- en: If `*obj*` does not represent a syntactically valid expression, `eval` raises
    an exception with condition type `&syntax`. The environments returned by `environment`,
    `scheme-report-environment`, and `null-environment` are immutable. Thus, `eval`
    also raises an exception with condition type `&syntax` if an assignment to any
    of the variables in the environment appears within the expression.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define cons ''not-cons)'
  prefs: []
  type: TYPE_NORMAL
- en: (eval '(let ([x 3]) (cons x 4)) (environment '(rnrs))) ![<graphic>](ch2_0.gif) (3 . 4)
  prefs: []
  type: TYPE_NORMAL
- en: (define lambda 'not-lambda)
  prefs: []
  type: TYPE_NORMAL
- en: (eval '(lambda (x) x) (environment '(rnrs))) ![<graphic>](ch2_0.gif) #<procedure>
  prefs: []
  type: TYPE_NORMAL
- en: (eval '(cons 3 4) (environment)) ![<graphic>](ch2_0.gif) *exception*`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(environment *import-spec* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** an environment'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs eval)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`environment` returns an environment formed from the combined bindings of the
    given import specifiers. Each `*import-spec*` must be an s-expression representing
    a valid import specifier (see Chapter [10](libraries.html#g142)).'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define env (environment ''(rnrs) ''(prefix (rnrs lists) $)))'
  prefs: []
  type: TYPE_NORMAL
- en: (eval '($cons* 3 4 (* 5 8)) env) ![<graphic>](ch2_0.gif) (3 4 . 40)`
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(null-environment *version*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(scheme-report-environment *version*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** an R5RS compatibility environment'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs r5rs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`*version*` must be the exact integer `5`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`null-environment` returns an environment containing bindings for the keywords
    whose meanings are defined by the Revised⁵ Report on Scheme, along with bindings
    for the auxiliary keywords `else`, `=>`, `...`, and `_`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`scheme-report-environment` returns an environment containing the same keyword
    bindings as the environment returned by `null-environment` along with bindings
    for the variables whose meanings are defined by the Revised⁵ Report on Scheme,
    except those not defined by the Revised⁶ Report: `load`, `interaction-environment`,
    `transcript-on`, `transcript-off`, and `char-ready?`.'
  prefs: []
  type: TYPE_NORMAL
- en: The bindings for each of the identifiers in the environments returned by these
    procedures are those of the corresponding Revised⁶ Report library, so this does
    not provide full backward compatibility, even if the excepted identifier bindings
    are not used.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it>
  prefs: []
  type: TYPE_NORMAL
- en: Copyright © 2009 [The MIT Press](http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984).
    Electronically reproduced by permission.
  prefs: []
  type: TYPE_NORMAL
- en: Illustrations © 2009 [Jean-Pierre Hébert](http://hebert.kitp.ucsb.edu/)
  prefs: []
  type: TYPE_NORMAL
- en: ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93
  prefs: []
  type: TYPE_NORMAL
- en: '[to order this book](http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984)
    / [about this book](canned/about.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.scheme.com](http://www.scheme.com/)'
  prefs: []
  type: TYPE_NORMAL
