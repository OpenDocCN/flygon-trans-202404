- en: Chapter 5\. Control Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduces the syntactic forms and procedures that serve as control
    structures for Scheme programs, The first section covers the most basic control
    structure, procedure application, and the remaining sections cover sequencing,
    conditional evaluation, recursion, mapping, continuations, delayed evaluation,
    multiple values, and evaluation of programs constructed at run time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.1\. Procedure Application
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**syntax**: `(*expr[0]* *expr[1]* ...)`'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** values of applying the value of `*expr[0]*` to the values of `*expr[1]* ...`'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Procedure application is the most basic Scheme control structure. Any structured
    form without a syntax keyword in the first position is a procedure application.
    The expressions `*expr[0]*` and `*expr[1]* ...` are evaluated; each should evaluate
    to a single value. After each of these expressions has been evaluated, the value
    of `*expr[0]*` is applied to the values of `*expr[1]* ...`. If `*expr[0]*` does
    not evaluate to a procedure, or if the procedure does not accept the number of
    arguments provided, an exception with condition type `&assertion` is raised.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'The order in which the procedure and argument expressions are evaluated is
    unspecified. It may be left to right, right to left, or any other order. The evaluation
    is guaranteed to be sequential, however: whatever order is chosen, each expression
    is fully evaluated before evaluation of the next is started.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 3 4) ![<graphic>](ch2_0.gif) 7'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: ((if (odd? 3) + -) 6 2) ![<graphic>](ch2_0.gif) 8
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda (x) x) 5) ![<graphic>](ch2_0.gif) 5
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda (x) (+ x x))])
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: (f 8)) ![<graphic>](ch2_0.gif) 16`
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(apply *procedure* *obj* ... *list*)`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the values of applying `*procedure*` to `*obj* ...` and the elements
    of `*list*`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '`apply` invokes `*procedure*`, passing the first `*obj*` as the first argument,
    the second `*obj*` as the second argument, and so on for each object in `*obj* ...`,
    and passing the elements of `*list*` in order as the remaining arguments. Thus,
    `*procedure*` is called with as many arguments as there are `*objs*` plus elements
    of `*list*`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '`apply` is useful when some or all of the arguments to be passed to a procedure
    are in a list, since it frees the programmer from explicitly destructuring the
    list.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '`(apply + ''(4 5)) ![<graphic>](ch2_0.gif) 9'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: (apply min '(6 8 3 2 5)) ![<graphic>](ch2_0.gif) 2
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: (apply min  5 1 3 '(6 8 3 2 5)) ![<graphic>](ch2_0.gif) 1
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: (apply vector 'a 'b '(c d e)) ![<graphic>](ch2_0.gif) #(a b c d e)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: (define first
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: (apply (lambda (x . y) x) ls)))
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: (define rest
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: (apply (lambda (x . y) y) ls)))
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: (first '(a b c d)) ![<graphic>](ch2_0.gif) a
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: (rest '(a b c d)) ![<graphic>](ch2_0.gif) (b c d)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: (apply append
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '''(1 2 3)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '''((a b) (c d e) (f))) ![<graphic>](ch2_0.gif) (1 2 3 a b c d e f)`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.2\. Sequencing
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**syntax**: `(begin *expr[1]* *expr[2]* ...)`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the values of the last subexpression'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The expressions `*expr[1]* *expr[2]* ...` are evaluated in sequence from left
    to right. `begin` is used to sequence assignments, input/output, or other operations
    that cause side effects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '`(define x 3)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: (begin
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: (set! x (+ x 1))
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: (+ x x)) ![<graphic>](ch2_0.gif) 8`
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: A `begin` form may contain zero or more definitions in place of the expressions
    `*expr[1]* *expr[2]* ...`, in which case it is considered to be a definition and
    may appear only where definitions are valid.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ()'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: (begin (define x 3) (define y 4))
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: (+ x y)) ![<graphic>](ch2_0.gif) 7`
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: This form of `begin` is primarily used by syntactic extensions that must expand
    into multiple definitions. (See page [101](binding.html#multi-define-syntax).)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The bodies of many syntactic forms, including `lambda`, `case-lambda`, `let`,
    `let*`, `letrec`, and `letrec*`, as well as the result clauses of `cond`, `case`,
    and `do`, are treated as if they were inside an implicit `begin`; i.e., the expressions
    making up the body or result clause are executed in sequence, with the values
    of the last expression being returned.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '`(define swap-pair!'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: (let ([temp (car x)])
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: (set-car! x (cdr x))
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! x temp)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: x)))
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: (swap-pair! (cons 'a 'b)) ![<graphic>](ch2_0.gif) (b . a)`
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.3\. Conditionals
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**syntax**: `(if *test* *consequent* *alternative*)`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(if *test* *consequent*)`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the values of `*consequent*` or `*alternative*` depending on the
    value of `*test*`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The `*test*`, `*consequent*`, and `*alternative*` subforms must be expressions.
    If `*test*` evaluates to a true value (anything other than `#f`), `consequent`
    is evaluated and its values are returned. Otherwise, `alternative` is evaluated
    and its values are returned. With the second, "one-armed," form, which has no
    `*alternative*`, the result is unspecified if `*test*` evaluates to false.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([ls ''(a b c)])'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '''()'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: (cdr ls))) ![<graphic>](ch2_0.gif) (b c)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls '()])
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '''()'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: (cdr ls))) ![<graphic>](ch2_0.gif) ()
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: (let ([abs
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: (if (< x 0)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: (- 0 x)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: x))])
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: (abs -4)) ![<graphic>](ch2_0.gif) 4
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x -4])
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: (if (< x 0)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: (list 'minus (- 0 x))
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: (list 'plus 4))) ![<graphic>](ch2_0.gif) (minus 4)`
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(not *obj*)`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is false, `#f` otherwise'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '`not` is equivalent to `(lambda (x) (if x #f #t))`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '`(not #f) ![<graphic>](ch2_0.gif) #t'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: (not #t) ![<graphic>](ch2_0.gif) #f
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: (not '()) ![<graphic>](ch2_0.gif) #f
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: (not (< 4 5)) ![<graphic>](ch2_0.gif) #f`
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(and *expr* ...)`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: If no subexpressions are present, the `and` form evaluates to `#t`. Otherwise,
    `and` evaluates each subexpression in sequence from left to right until only one
    subexpression remains or a subexpression returns `#f`. If one subexpression remains,
    it is evaluated and its values are returned. If a subexpression returns `#f`,
    `and` returns `#f` without evaluating the remaining subexpressions. A syntax definition
    of `and` appears on page [62](further.html#defn:and).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 3])'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: (and (> x 2) (< x 4))) ![<graphic>](ch2_0.gif) #t
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x 5])
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: (and (> x 2) (< x 4))) ![<graphic>](ch2_0.gif) #f
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: (and #f '(a b) '(c d)) ![<graphic>](ch2_0.gif) #f
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: (and '(a b) '(c d) '(e f)) ![<graphic>](ch2_0.gif) (e f)`
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(or *expr* ...)`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: If no subexpressions are present, the `or` form evaluates to `#f`. Otherwise,
    `or` evaluates each subexpression in sequence from left to right until only one
    subexpression remains or a subexpression returns a value other than `#f`. If one
    subexpression remains, it is evaluated and its values are returned. If a subexpression
    returns a value other than `#f`, `or` returns that value without evaluating the
    remaining subexpressions. A syntax definition of `or` appears on page [63](further.html#defn:or).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 3])'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: (or (< x 2) (> x 4))) ![<graphic>](ch2_0.gif) #f
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x 5])
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: (or (< x 2) (> x 4))) ![<graphic>](ch2_0.gif) #t
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: (or #f '(a b) '(c d)) ![<graphic>](ch2_0.gif) (a b)`
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(cond *clause[1]* *clause[2]* ...)`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Each `*clause*` but the last must take one of the forms below.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '`(*test*)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: (*test* *expr[1]* *expr[2]* ...)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: (*test* => *expr*)`
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The last clause may be in any of the above forms, or it may be an "`else` clause"
    of the form
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '`(else *expr[1]* *expr[2]* ...)`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Each `*test*` is evaluated in order until one evaluates to a true value or until
    all of the tests have been evaluated. If the first clause whose `*test*` evaluates
    to a true value is in the first form given above, the value of `*test*` is returned.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: If the first clause whose `*test*` evaluates to a true value is in the second
    form given above, the expressions `*expr[1]* *expr[2]*...` are evaluated in sequence
    and the values of the last expression are returned.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: If the first clause whose `*test*` evaluates to a true value is in the third
    form given above, the expression `*expr*` is evaluated. The value should be a
    procedure of one argument, which is applied to the value of `*test*`. The values
    of this application are returned.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: If none of the tests evaluates to a true value and an `else` clause is present,
    the expressions `*expr[1]* *expr[2]* ...` of the `else` clause are evaluated in
    sequence and the values of the last expression are returned.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: If none of the tests evaluates to a true value and no `else` clause is present,
    the value or values are unspecified.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: See page [305](syntax.html#defn:cond) for a syntax definition of `cond`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 0])'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[(< x 0) (list ''minus (abs x))]'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[(> x 0) (list ''plus x)]'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[else (list ''zero x)])) ![<graphic>](ch2_0.gif) (zero 0)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: (define select
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[(not (symbol? x))]'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[(assq x ''((a . 1) (b . 2) (c . 3))) => cdr]'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[else 0])))'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: (select 3) ![<graphic>](ch2_0.gif) #t
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: (select 'b) ![<graphic>](ch2_0.gif) 2
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: (select 'e) ![<graphic>](ch2_0.gif) 0`
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `else`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `=>`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs exceptions)`, `(rnrs)`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: These identifiers are auxiliary keywords for `cond`. Both also serve as auxiliary
    keywords for `guard`, and `else` also serves as an auxiliary keyword for `case`.
    It is a syntax violation to reference these identifiers except in contexts where
    they are recognized as auxiliary keywords.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(when *test-expr* *expr[1]* *expr[2]* ...)`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(unless *test-expr* *expr[1]* *expr[2]* ...)`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs control)`, `(rnrs)`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: For `when`, if `*test-expr*` evaluates to a true value, the expressions `*expr[1]* *expr[2]* ...`
    are evaluated in sequence, and the values of the last expression are returned.
    If `*test-expr*` evaluates to false, none of the other expressions are evaluated,
    and the value or values of `when` are unspecified.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: For `unless`, if `*test-expr*` evaluates to false, the expressions `*expr[1]* *expr[2]* ...`
    are evaluated in sequence, and the values of the last expression are returned.
    If `*test-expr*` evaluates to a true value, none of the other expressions are
    evaluated, and the value or values of `unless` are unspecified.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: A `when` or `unless` expression is usually clearer than the corresponding "one-armed"
    `if` expression.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x -4] [sign ''plus])'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: (when (< x 0)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: (set! x (- 0 x))
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: (set! sign 'minus))
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: (list sign x)) ![<graphic>](ch2_0.gif) (minus 4)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: (define check-pair
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: (unless (pair? x)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-violation 'check-pair "invalid argument" x))
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: x))
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: (check-pair '(a b c)) ![<graphic>](ch2_0.gif) (a b c)`
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '`when` may be defined as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax when'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e0 e1 e2 ...)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: (if e0 (begin e1 e2 ...))]))`
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '`unless` may be defined as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax unless'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e0 e1 e2 ...)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: (if (not e0) (begin e1 e2 ...))]))`
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'or in terms of `when` as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax unless'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e0 e1 e2 ...)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: (when (not e0) e1 e2 ...)]))`
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(case *expr[0]* *clause[1]* *clause[2]* ...)`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Each clause but the last must take the form
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '`((*key* ...) *expr[1]* *expr[2]* ...)`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: where each `*key*` is a datum distinct from the other keys. The last clause
    may be in the above form or it may be an `else` clause of the form
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '`(else *expr[1]* *expr[2]* ...)`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '`*expr[0]*` is evaluated and the result is compared (using `eqv?`) against
    the keys of each clause in order. If a clause containing a matching key is found,
    the expressions `*expr[1]* *expr[2]* ...` are evaluated in sequence and the values
    of the last expression are returned.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: If none of the clauses contains a matching key and an `else` clause is present,
    the expressions `*expr[1]* *expr[2]* ...` of the `else` clause are evaluated in
    sequence and the values of the last expression are returned.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: If none of the clauses contains a matching key and no `else` clause is present,
    the value or values are unspecified.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: See page [306](syntax.html#defn:case) for a syntax definition of `case`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 4] [y 5])'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: (case (+ x y)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[(1 3 5 7 9) ''odd]'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[(0 2 4 6 8) ''even]'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[else ''out-of-range])) ![<graphic>](ch2_0.gif) odd`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.4\. Recursion and Iteration
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**syntax**: `(let *name* ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** values of the final body expression'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: This form of `let`, called `*named*` `let`, is a general-purpose iteration and
    recursion construct. It is similar to the more common form of `let` (see Section [4.4](binding.html#g92))
    in the binding of the variables `*var* ...` to the values of `*expr* ...` within
    the body `*body[1]* *body[2]* ...`, which is processed and evaluated like a `lambda`
    body. In addition, the variable `*name*` is bound within the body to a procedure
    that may be called to recur or iterate; the arguments to the procedure become
    the new values of the variables `*var* ...`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: A named `let` expression of the form
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '`(let *name* ((*var* *expr*) ...)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '*body[1]* *body[2]* ...)`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: can be rewritten with `letrec` as follows.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '`((letrec ((*name* (lambda (*var* ...) *body[1]* *body[2]* ...)))'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '*name*)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '*expr* ...)`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: A syntax definition of `let` that implements this transformation and handles
    unnamed `let` as well can be found on page [312](syntax.html#defn:let).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `divisors` defined below uses named `let` to compute the nontrivial
    divisors of a nonnegative integer.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '`(define divisors'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([i 2])
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[(>= i n) ''()]'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[(integer? (/ n i)) (cons i (f (+ i 1)))]'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[else (f (+ i 1))]))))'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: (divisors 5) ![<graphic>](ch2_0.gif) ()
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: (divisors 32) ![<graphic>](ch2_0.gif) (2 4 8 16)`
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The version above is non-tail-recursive when a divisor is found and tail-recursive
    when a divisor is not found. The version below is fully tail-recursive. It builds
    up the list in reverse order, but this is easy to remedy, if desired, by reversing
    the list on exit.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '`(define divisors'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([i 2] [ls '()])
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[(>= i n) ls]'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[(integer? (/ n i)) (f (+ i 1) (cons i ls))]'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[else (f (+ i 1) ls)]))))`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(do ((*var* *init* *update*) ...) (*test* *result* ...) *expr* ...)`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the values of the last `*result*` expression'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs control)`, `(rnrs)`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '`do` allows a common restricted form of iteration to be expressed succinctly.
    The variables `*var* ...` are bound initially to the values of `*init* ...` and
    are rebound on each subsequent iteration to the values of `*update* ...`. The
    expressions `*test*`, `*update* ...`, `*expr* ...`, and `*result* ...` are all
    within the scope of the bindings established for `*var* ...`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: On each step, the test expression `*test*` is evaluated. If the value of `*test*`
    is true, iteration ceases, the expressions `*result* ...` are evaluated in sequence,
    and the values of the last expression are returned. If no result expressions are
    present, the value or values of the `do` expression are unspecified.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: If the value of `*test*` is false, the expressions `*expr* ...` are evaluated
    in sequence, the expressions `*update* ...` are evaluated, new bindings for `*var* ...`
    to the values of `*update* ...` are created, and iteration continues.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The expressions `*expr* ...` are evaluated only for effect and are often omitted
    entirely. Any `*update*` expression may be omitted, in which case the effect is
    the same as if the `*update*` were simply the corresponding `*var*`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Although looping constructs in most languages require that the loop iterands
    be updated via assignment, `do` requires the loop iterands `*var* ...` to be updated
    via rebinding. In fact, no side effects are involved in the evaluation of a `do`
    expression unless they are performed explicitly by its subexpressions.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: See page [313](syntax.html#defn:do) for a syntax definition of `do`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The definitions of `factorial` and `fibonacci` below are straightforward translations
    of the tail-recursive named-`let` versions given in Section [3.2](further.html#g55).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '`(define factorial'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i n (- i 1)] [a 1 (* a i)])
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: ((zero? i) a))))
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: (factorial 10) ![<graphic>](ch2_0.gif) 3628800
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: (define fibonacci
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: (if (= n 0)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i n (- i 1)] [a1 1 (+ a1 a2)] [a2 0 a1])
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: ((= i 1) a1)))))
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: (fibonacci 6) ![<graphic>](ch2_0.gif) 8`
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The definition of `divisors` below is similar to the tail-recursive definition
    of `divisors` given with the description of named `let` above.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '`(define divisors'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i 2 (+ i 1)]
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[ls ''()'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: (if (integer? (/ n i))
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: (cons i ls)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: ls)])
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: ((>= i n) ls))))`
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The definition of `scale-vector!` below, which scales each element of a vector
    *v* by a constant *k*, demonstrates a nonempty `do` body.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '`(define scale-vector!'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (v k)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: (let ([n (vector-length v)])
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i 0 (+ i 1)])
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: ((= i n))
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: (vector-set! v i (* (vector-ref v i) k))))))
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: (define vec (vector 1 2 3 4 5))
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: (scale-vector! vec 2)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: vec ![<graphic>](ch2_0.gif) #(2 4 6 8 10)`
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.5\. Mapping and Folding
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a program must recur or iterate over the elements of a list, a mapping
    or folding operator is often more convenient. These operators abstract away from
    null checks and explicit recursion by applying a procedure to the elements of
    the list one by one. A few mapping operators are also available for vectors and
    strings.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(map *procedure* *list[1]* *list[2]* ...)`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** list of results'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '`map` applies `*procedure*` to corresponding elements of the lists `*list[1]* *list[2]* ...`
    and returns a list of the resulting values. The lists `*list[1]* *list[2]* ...`
    must be of the same length. `*procedure*` should accept as many arguments as there
    are lists, should return a single value, and should not mutate the `*list*` arguments.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 将 `*procedure*` 应用于列表 `*list[1]* *list[2]* ...` 中对应的元素，并返回结果值的列表。列表 `*list[1]* *list[2]* ...`
    必须具有相同长度。`*procedure*` 应接受与列表数量相同的参数，应返回单个值，并且不应改变 `*list*` 参数。'
- en: '`(map abs ''(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) (1 2 3 4 5 6)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`(map abs ''(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) (1 2 3 4 5 6)'
- en: (map (lambda (x y) (* x y))
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: (map (lambda (x y) (* x y))
- en: '''(1 2 3 4)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '''(1 2 3 4)'
- en: '''(8 7 6 5)) ![<graphic>](ch2_0.gif) (8 14 18 20)`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '''(8 7 6 5)) ![<graphic>](ch2_0.gif) (8 14 18 20)`'
- en: While the order in which the applications themselves occur is not specified,
    the order of the values in the output list is the same as that of the corresponding
    values in the input lists.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管应用本身的顺序没有指定，但输出列表中值的顺序与输入列表中相应值的顺序相同。
- en: '`map` might be defined as follows.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 可能定义如下。'
- en: '`(define map'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`(定义 map'
- en: (lambda (f ls . more)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (f ls . more)
- en: (if (null? more)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? more)
- en: (let map1 ([ls ls])
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: (let map1 ([ls ls])
- en: (if (null? ls)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: '''()'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (cons (f (car ls))
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (f (car ls))
- en: (map1 (cdr ls)))))
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: (map1 (cdr ls)))))
- en: (let map-more ([ls ls] [more more])
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: (let map-more ([ls ls] [more more])
- en: (if (null? ls)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: '''()'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (cons
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: (cons
- en: (apply f (car ls) (map car more))
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: (apply f (car ls) (map car more))
- en: (map-more (cdr ls) (map cdr more))))))))`
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: (map-more (cdr ls) (map cdr more))))))))`
- en: No error checking is done by this version of `map`; `f` is assumed to be a procedure
    and the other arguments are assumed to be proper lists of the same length. An
    interesting feature of this definition is that `map` uses itself to pull out the
    cars and cdrs of the list of input lists; this works because of the special treatment
    of the single-list case.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的 `map` 没有进行错误检查；假定 `f` 是一个过程，其他参数假定为相同长度的适当列表。这个定义的一个有趣特点是，`map` 使用自身来提取输入列表的
    car 和 cdr；这是因为对于单列表情况的特殊处理。
- en: '**procedure**: `(for-each *procedure* *list[1]* *list[2]* ...)`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(for-each *procedure* *list[1]* *list[2]* ...)`'
- en: '**returns:** unspecified'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 未指定'
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs base)`, `(rnrs)`'
- en: '`for-each` is similar to `map` except that `for-each` does not create and return
    a list of the resulting values, and `for-each` guarantees to perform the applications
    in sequence over the elements from left to right. `*procedure*` should accept
    as many arguments as there are lists and should not mutate the `*list*` arguments.
    `for-each` may be defined without error checks as follows.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-each` 类似于 `map`，但 `for-each` 不会创建并返回结果值的列表，并且 `for-each` 保���按顺序从左到右对元素执行应用。`*procedure*`
    应接受与列表数量相同的参数，并且不应改变 `*list*` 参数。`for-each` 可以如下定义而无需错误检查。'
- en: '`(define for-each'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`(定义 for-each'
- en: (lambda (f ls . more)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (f ls . more)
- en: (do ([ls ls (cdr ls)] [more more (map cdr more)])
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([ls ls (cdr ls)] [more more (map cdr more)])
- en: ((null? ls))
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ((null? ls))
- en: (apply f (car ls) (map car more)))))
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: (apply f (car ls) (map car more)))))
- en: (let ([same-count 0])
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([same-count 0])
- en: (for-each
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: (for-each
- en: (lambda (x y)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x y)
- en: (when (= x y)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: (when (= x y)
- en: (set! same-count (+ same-count 1))))
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: (set! same-count (+ same-count 1))))
- en: '''(1 2 3 4 5 6)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '''(1 2 3 4 5 6)'
- en: '''(2 3 3 4 7 6))'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '''(2 3 3 4 7 6))'
- en: same-count) ![<graphic>](ch2_0.gif) 3`
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: same-count) ![<graphic>](ch2_0.gif) 3`
- en: '**procedure**: `(exists *procedure* *list[1]* *list[2]* ...)`'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(存在 *procedure* *list[1]* *list[2]* ...)`'
- en: '**returns:** see below'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 见下文'
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs lists)`, `(rnrs)`'
- en: The lists `*list[1]* *list[2]* ...` must be of the same length. `*procedure*`
    should accept as many arguments as there are lists and should not mutate the `*list*`
    arguments. If the lists are empty, `exists` returns `#f`. Otherwise, `exists`
    applies `*procedure*` to corresponding elements of the lists `*list[1]* *list[2]* ...`
    in sequence until either the lists each have only one element or `*procedure*`
    returns a true value `*t*`. In the former case, `exists` tail-calls `*procedure*`,
    applying it to the remaining element of each list. In the latter case, `exists`
    returns `*t*`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 `*list[1]* *list[2]* ...` 必须具有相同长度。`*procedure*` 应接受与列表数量相同的参数，并且不应改变 `*list*`
    参数。如果列表为空，则 `exists` 返回 `#f`。否则，`exists` 依次对列表 `*list[1]* *list[2]* ...` 中对应的元素应用
    `*procedure*`，直到每个列表仅剩一个元素或 `*procedure*` 返回真值 `*t*`。在前一种情况下，`exists` 尾调用 `*procedure*`，将其应用于每个列表的剩余元素。在后一种情况下，`exists`
    返回 `*t*`。
- en: '`(exists symbol? ''(1.0 #\a "hi" ''())) ![<graphic>](ch2_0.gif) #f'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`(存在 symbol? ''(1.0 #\a "hi" ''())) ![<graphic>](ch2_0.gif) #f'
- en: (exists member
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: (存在 member
- en: '''(a b c)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '''(a b c)'
- en: '''((c b) (b a) (a c))) ![<graphic>](ch2_0.gif) (b a)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: (exists (lambda (x y z) (= (+ x y) z))
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '''(1 2 3 4)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '''(1.2 2.3 3.4 4.5)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '''(2.3 4.4 6.4 8.6)) ![<graphic>](ch2_0.gif) #t`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '`exists` may be defined (somewhat inefficiently and without error checks) as
    follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '`(define exists'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (f ls . more)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: (and (not (null? ls))
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: (let exists ([x (car ls)] [ls (cdr ls)] [more more])
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: (apply f x (map car more))
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: (or (apply f x (map car more))
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: (exists (car ls) (cdr ls) (map cdr more))))))))`
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(for-all *procedure* *list[1]* *list[2]* ...)`'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The lists `*list[1]* *list[2]* ...` must be of the same length. `*procedure*`
    should accept as many arguments as there are lists and should not mutate the `*list*`
    arguments. If the lists are empty, `for-all` returns `#t`. Otherwise, `for-all`
    applies `*procedure*` to corresponding elements of the lists `*list[1]* *list[2]* ...`
    in sequence until either the lists each have only one element left or `*procedure*`
    returns `#f`. In the former case, `for-all` tail-calls `*procedure*`, applying
    it to the remaining element of each list. In the latter case, `for-all` returns
    `#f`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '`(for-all symbol? ''(a b c d)) ![<graphic>](ch2_0.gif) #t'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: (for-all =
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '''(1 2 3 4)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '''(1.0 2.0 3.0 4.0)) ![<graphic>](ch2_0.gif) #t'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: (for-all (lambda (x y z) (= (+ x y) z))
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '''(1 2 3 4)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '''(1.2 2.3 3.4 4.5)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '''(2.2 4.3 6.5 8.5)) ![<graphic>](ch2_0.gif) #f`'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '`for-all` may be defined (somewhat inefficiently and without error checks)
    as follows:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '`(define for-all'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (f ls . more)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: (or (null? ls)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: (let for-all ([x (car ls)] [ls (cdr ls)] [more more])
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: (apply f x (map car more))
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: (and (apply f x (map car more))
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: (for-all (car ls) (cdr ls) (map cdr more))))))))`
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fold-left *procedure* *obj* *list[1]* *list[2]* ...)`'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: The `*list*` arguments should all have the same length. `*procedure*` should
    accept one more argument than the number of `*list*` arguments and return a single
    value. It should not mutate the `*list*` arguments.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '`fold-left` returns `*obj*` if the `*list*` arguments are empty. If they are
    not empty, `fold-left` applies `*procedure*` to `*obj*` and the cars of `*list[1]* *list[2]* ...`,
    then recurs with the value returned by `*procedure*` in place of `*obj*` and the
    cdr of each `*list*` in place of the `*list*`.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '`(fold-left cons ''() ''(1 2 3 4)) ![<graphic>](ch2_0.gif) ((((() . 1) . 2) . 3) . 4)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: (fold-left
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (a x) (+ a (* x x)))
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 0 '(1 2 3 4 5)) ![<graphic>](ch2_0.gif) 55
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: (fold-left
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (a . args) (append args a))
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '''(question)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '''(that not to)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '''(is to be)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '''(the be: or)) ![<graphic>](ch2_0.gif) (to be or not to be: that is the question)`'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(fold-right *procedure* *obj* *list[1]* *list[2]* ...)`'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs lists)`, `(rnrs)`'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: The `*list*` arguments should all have the same length. `*procedure*` should
    accept one more argument than the number of `*list*` arguments and return a single
    value. It should not mutate the `*list*` arguments.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '`fold-right` returns `*obj*` if the `*list*` arguments are empty. If they are
    not empty, `fold-right` recurs with the cdr of each `*list*` replacing the `*list*`,
    then applies `*procedure*` to the cars of `*list[1]* *list[2]* ...` and the result
    returned by the recursion.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '`(fold-right cons ''() ''(1 2 3 4)) ![<graphic>](ch2_0.gif) (1 2 3 4)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: (fold-right
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x a) (+ a (* x x)))
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 0 '(1 2 3 4 5)) ![<graphic>](ch2_0.gif) 55
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: (fold-right
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y a) (cons* x y a))   ![<graphic>](ch2_0.gif) (parting is such sweet sorrow
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '''((with apologies))              ![](ch3_ghostRightarrow.gif)  gotta go see ya tomorrow'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '''(parting such sorrow go ya)     ![](ch3_ghostRightarrow.gif)  (with apologies))'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '''(is sweet gotta see tomorrow))`'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector-map *procedure* *vector[1]* *vector[1]* ...)`'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** vector of results'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '`vector-map` applies `*procedure*` to corresponding elements of `*vector[1]* *vector[2]* ...`
    and returns a vector of the resulting values. The vectors `*vector[1]* *vector[2]* ...`
    must be of the same length, and `*procedure*` should accept as many arguments
    as there are vectors and return a single value.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '`(vector-map abs ''#(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) #(1 2 3 4 5 6)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: (vector-map (lambda (x y) (* x y))
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '''#(1 2 3 4)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '''#(8 7 6 5)) ![<graphic>](ch2_0.gif) #(8 14 18 20)`'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: While the order in which the applications themselves occur is not specified,
    the order of the values in the output vector is the same as that of the corresponding
    values in the input vectors.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(vector-for-each *procedure* *vector[1]* *vector[2]* ...)`'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '`vector-for-each` is similar to `vector-map` except that `vector-for-each`
    does not create and return a vector of the resulting values, and `vector-for-each`
    guarantees to perform the applications in sequence over the elements from left
    to right.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([same-count 0])'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: (vector-for-each
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y)
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: (when (= x y)
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: (set! same-count (+ same-count 1))))
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '''#(1 2 3 4 5 6)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '''#(2 3 3 4 7 6))'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: same-count) ![<graphic>](ch2_0.gif) 3`
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(string-for-each *procedure* *string[1]* *string[2]* ...)`'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '`string-for-each` is similar to `for-each` and `vector-for-each` except that
    the inputs are strings rather than lists or vectors.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([ls ''()])'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: (string-for-each
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: (lambda r (set! ls (cons r ls)))
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '"abcd"'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '"===="'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '"1234")'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: (map list->string (reverse ls))) ![<graphic>](ch2_0.gif) ("a=1" "b=2" "c=3" "d=4")`
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.6\. Continuations
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Continuations in Scheme are procedures that represent the remainder of a computation
    from a given point in the computation. They may be obtained with `call-with-current-continuation`,
    which can be abbreviated to `call/cc`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(call/cc *procedure*)`'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(call-with-current-continuation *procedure*)`'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: These procedures are the same. The shorter name is often used for the obvious
    reason that it requires fewer keystrokes to type.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '`call/cc` obtains its continuation and passes it to `*procedure*`, which should
    accept one argument. The continuation itself is represented by a procedure. Each
    time this procedure is applied to zero or more values, it returns the values to
    the continuation of the `call/cc` application. That is, when the continuation
    procedure is called, it returns its arguments as the values of the application
    of `call/cc`.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: If `*procedure*` returns normally when passed the continuation procedure, the
    values returned by `call/cc` are the values returned by `*procedure*`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Continuations allow the implementation of nonlocal exits, backtracking [[14](bibliography.html#g232),[29](bibliography.html#g247)],
    coroutines [[16](bibliography.html#g234)], and multitasking [[10](bibliography.html#g228),[32](bibliography.html#g250)].
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: The example below illustrates the use of a continuation to perform a nonlocal
    exit from a loop.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '`(define member'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x ls)
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (break)
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: (do ([ls ls (cdr ls)])
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: ((null? ls) #f)
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: (when (equal? x (car ls))
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: (break ls)))))))
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: (member 'd '(a b c)) ![<graphic>](ch2_0.gif) #f
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: (member 'b '(a b c)) ![<graphic>](ch2_0.gif) (b c)`
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Additional examples are given in Sections [3.3](further.html#g63) and [12.11](examples.html#g208).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: The current continuation is typically represented internally as a stack of procedure
    activation records, and obtaining the continuation involves encapsulating the
    stack within a procedural object. Since an encapsulated stack has indefinite extent,
    some mechanism must be used to preserve the stack contents indefinitely. This
    can be done with surprising ease and efficiency and with no impact on programs
    that do not use continuations [[17](bibliography.html#g235)].
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(dynamic-wind *in* *body* *out*)`'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** values resulting from the application of `*body*`'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '`dynamic-wind` offers "protection" from continuation invocation. It is useful
    for performing tasks that must be performed whenever control enters or leaves
    `*body*`, either normally or by continuation application.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: The three arguments `*in*`, `*body*`, and `*out*` must be procedures and should
    accept zero arguments, i.e., they should be `*thunks*`. Before applying `*body*`,
    and each time `*body*` is entered subsequently by the application of a continuation
    created within `*body*`, the `*in*` thunk is applied. Upon normal exit from `*body*`
    and each time `*body*` is exited by the application of a continuation created
    outside `*body*`, the `*out*` thunk is applied.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Thus, it is guaranteed that `*in*` is invoked at least once. In addition, if
    `*body*` ever returns, `*out*` is invoked at least once.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: The following example demonstrates the use of `dynamic-wind` to be sure that
    an input port is closed after processing, regardless of whether the processing
    completes normally.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([p (open-input-file "input-file")])'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: (dynamic-wind
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () #f)
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (process p))
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (close-port p))))`
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Common Lisp provides a similar facility (`unwind-protect`) for protection from
    nonlocal exits. This is often sufficient. `unwind-protect` provides only the equivalent
    to `*out*`, however, since Common Lisp does not support fully general continuations.
    Here is how `unwind-protect` might be specified with `dynamic-wind`.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax unwind-protect'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ body cleanup ...)'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: (dynamic-wind
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () #f)
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () body)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () cleanup ...))]))
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: ((call/cc
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x 'a])
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (k)
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: (unwind-protect
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: (k (lambda () x))
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: (set! x 'b)))))) ![<graphic>](ch2_0.gif) b`
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Some Scheme implementations support a controlled form of assignment known as
    *fluid binding*, in which a variable takes on a temporary value during a given
    computation and reverts to the old value after the computation has completed.
    The syntactic form `fluid-let` defined below in terms of `dynamic-wind` permits
    the fluid binding of a single variable `x` to the value of an expression `e` within
    a the body `b1 b2 ...`.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax fluid-let'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ ((x e)) b1 b2 ...)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: (let ([y e])
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: (let ([swap (lambda () (let ([t x]) (set! x y) (set! y t)))])
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: (dynamic-wind swap (lambda () b1 b2 ...) swap)))]))`
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Implementations that support `fluid-let` typically extend it to allow an indefinite
    number of `(x e)` pairs, as with `let`.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: If no continuations are invoked within the body of a `fluid-let`, the behavior
    is the same as if the variable were simply assigned the new value on entry and
    assigned the old value on return.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 3])'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: (+ (fluid-let ([x 5])
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: x)
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: x)) ![<graphic>](ch2_0.gif) 8`
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: A fluid-bound variable also reverts to the old value if a continuation created
    outside of the `fluid-let` is invoked.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x ''a])'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda () x)])
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: (cons (call/cc
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (k)
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: (fluid-let ([x 'b])
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: (k (f)))))
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: (f)))) ![<graphic>](ch2_0.gif) (b . a)`
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: If control has left a `fluid-let` body, either normally or by the invocation
    of a continuation, and control reenters the body by the invocation of a continuation,
    the temporary value of the fluid-bound variable is reinstated. Furthermore, any
    changes to the temporary value are maintained and reflected upon reentry.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '`(define reenter #f)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: (define x 0)
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: (fluid-let ([x 1])
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc (lambda (k) (set! reenter k)))
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: (set! x (+ x 1))
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: x) ![<graphic>](ch2_0.gif) 2
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: x ![<graphic>](ch2_0.gif) 0
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: (reenter '*) ![<graphic>](ch2_0.gif) 3
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: (reenter '*) ![<graphic>](ch2_0.gif) 4
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: x ![<graphic>](ch2_0.gif) 0`
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: A library showing how `dynamic-wind` might be implemented were it not already
    built in is given below. In addition to defining `dynamic-wind`, the code defines
    a version of `call/cc` that does its part to support `dynamic-wind`.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '`(library (dynamic-wind)'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: (export dynamic-wind call/cc
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: (rename (call/cc call-with-current-continuation)))
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: (import (rename (except (rnrs) dynamic-wind) (call/cc rnrs:call/cc)))
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: (define winders '())
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: (define common-tail
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y)
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: (let ([lx (length x)] [ly (length y)])
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: (do ([x (if (> lx ly) (list-tail x (- lx ly)) x) (cdr x)]
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[y (if (> ly lx) (list-tail y (- ly lx)) y) (cdr y)])'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: ((eq? x y) x)))))
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: (define do-wind
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (new)
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: (let ([tail (common-tail new winders)])
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([ls winders])
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: (if (not (eq? ls tail))
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: (begin
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: (set! winders (cdr ls))
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: ((cdar ls))
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: (f (cdr ls)))))
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([ls new])
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: (if (not (eq? ls tail))
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: (begin
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: (f (cdr ls))
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: ((caar ls))
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: (set! winders ls)))))))`
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '`  (define call/cc'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (f)
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: (rnrs:call/cc
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (k)
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: (f (let ([save winders])
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: (unless (eq? save winders) (do-wind save))
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: (k x))))))))
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: (define dynamic-wind
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (in body out)
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: (in)
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: (set! winders (cons (cons in out) winders))
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: (let-values ([ans* (body)])
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: (set! winders (cdr winders))
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: (out)
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: (apply values ans*)))))`
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Together, `dynamic-wind` and `call/cc` manage a list of *winders*. A winder
    is a pair of *in* and *out* thunks established by a call to `dynamic-wind`. Whenever
    `dynamic-wind` is invoked, the *in* thunk is invoked, a new winder containing
    the *in* and *out* thunks is placed on the winders list, the *body* thunk is invoked,
    the winder is removed from the winders list, and the *out* thunk is invoked. This
    ordering ensures that the winder is on the winders list only when control has
    passed through *in* and not yet entered *out*. Whenever a continuation is obtained,
    the winders list is saved, and whenever the continuation is invoked, the saved
    winders list is reinstated. During reinstatement, the *out* thunk of each winder
    on the current winders list that is not also on the saved winders list is invoked,
    followed by the *in* thunk of each winder on the saved winders list that is not
    also on the current winders list. The winders list is updated incrementally, again
    to ensure that a winder is on the current winders list only if control has passed
    through its *in* thunk and not entered its *out* thunk.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: The test `(not (eq? save winders))` performed in `call/cc` is not strictly necessary
    but makes invoking a continuation less costly whenever the saved winders list
    is the same as the current winders list.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.7\. Delayed Evaluation
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The syntactic form `delay` and the procedure `force` may be used in combination
    to implement *lazy evaluation*. An expression subject to lazy evaluation is not
    evaluated until its value is required and, once evaluated, is never reevaluated.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(delay *expr*)`'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a promise'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(force *promise*)`'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** result of forcing `*promise*`'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs r5rs)`'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: The first time a promise created by `delay` is *forced* (with `force`), it evaluates
    `*expr*`, "remembering" the resulting value. Thereafter, each time the promise
    is forced, it returns the remembered value instead of reevaluating `*expr*`.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '`delay` and `force` are typically used only in the absence of side effects,
    e.g., assignments, so that the order of evaluation is unimportant.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of using `delay` and `force` is that some amount of computation
    might be avoided altogether if it is delayed until absolutely required. Delayed
    evaluation may be used to construct conceptually infinite lists, or *streams*.
    The example below shows how a stream abstraction may be built with `delay` and
    `force`. A stream is a promise that, when forced, returns a pair whose cdr is
    a stream.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '`(define stream-car'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s)
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: (car (force s))))
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: (define stream-cdr
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: (cdr (force s))))
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: (define counters
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: (let next ([n 1])
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: (delay (cons n (next (+ n 1))))))
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: (stream-car counters) ![<graphic>](ch2_0.gif) 1
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: (stream-car (stream-cdr counters)) ![<graphic>](ch2_0.gif) 2
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: (define stream-add
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (s1 s2)
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: (delay (cons
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: (+ (stream-car s1) (stream-car s2))
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: (stream-add (stream-cdr s1) (stream-cdr s2))))))
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: (define even-counters
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: (stream-add counters counters))
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: (stream-car even-counters) ![<graphic>](ch2_0.gif) 2
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: (stream-car (stream-cdr even-counters)) ![<graphic>](ch2_0.gif) 4`
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '`delay` may be defined by'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax delay'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ expr) (make-promise (lambda () expr))]))`'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: where `make-promise` might be defined as follows.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '`(define make-promise'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p)
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: (let ([val #f] [set? #f])
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: (unless set?
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (p)])
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: (unless set?
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: (set! val x)
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: (set! set? #t))))
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: val))))`
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: With this definition of `delay`, `force` simply invokes the promise to force
    evaluation or to retrieve the saved value.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '`(define force'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (promise)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: (promise)))`
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: The second test of the variable `set?` in `make-promise` is necessary in the
    event that, as a result of applying `*p*`, the promise is recursively forced.
    Since a promise must always return the same value, the result of the first application
    of `*p*` to complete is returned.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: Whether `delay` and `force` handle multiple return values is unspecified; the
    implementation given above does not, but the following version does, with the
    help of `call-with-values` and `apply`.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '`(define make-promise'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p)
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: (let ([vals #f] [set? #f])
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: (unless set?
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values p
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: (lambda x
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: (unless set?
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: (set! vals x)
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: (set! set? #t)))))
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: (apply values vals)))))
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: (define p (delay (values 1 2 3)))
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: (force p) ![<graphic>](ch2_0.gif) 1
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) 2'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) 3'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values (lambda () (force p)) +) ![<graphic>](ch2_0.gif) 6`
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: Neither implementation is quite right, since `force` must raise an exception
    with condition type `&assertion` if its argument is not a promise. Since distinguishing
    procedures created by `make-promise` from other procedures is impossible, `force`
    cannot do so reliably. The following reimplementation of `make-promise` and `force`
    represents promises as records of the type `promise` to allow `force` to make
    the required check.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-record-type promise'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: (fields (immutable p) (mutable vals) (mutable set?))
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: (protocol (lambda (new) (lambda (p) (new p #f #f)))))
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: (define force
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (promise)
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: (unless (promise? promise)
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: (assertion-violation 'promise "invalid argument" promise))
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: (unless (promise-set? promise)
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values (promise-p promise)
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: (lambda x
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: (unless (promise-set? promise)
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: (promise-vals-set! promise x)
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: (promise-set?-set! promise #t)))))
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: (apply values (promise-vals promise))))`
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.8\. Multiple Values
  id: totrans-614
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While all Scheme primitives and most user-defined procedures return exactly
    one value, some programming problems are best solved by returning zero values,
    more than one value, or even a variable number of values. For example, a procedure
    that partitions a list of values into two sublists needs to return two values.
    While it is possible for the producer of multiple values to package them into
    a data structure and for the consumer to extract them, it is often cleaner to
    use the built-in multiple-values interface. This interface consists of two procedures:
    `values` and `call-with-values`. The former produces multiple values and the latter
    links procedures that produce multiple-value values with procedures that consume
    them.'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(values *obj* ...)`'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `*obj* ...`'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `values` accepts any number of arguments and simply passes (returns)
    the arguments to its continuation.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '`(values) ![<graphic>](ch2_0.gif)'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: (values 1) ![<graphic>](ch2_0.gif) 1
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: (values 1 2 3) ![<graphic>](ch2_0.gif) 1
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) 2'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) 3'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: (define head&tail
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: (values (car ls) (cdr ls))))
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: (head&tail '(a b c)) ![<graphic>](ch2_0.gif) a
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) (b c)`'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(call-with-values *producer* *consumer*)`'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** see below'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '`*producer*` and `*consumer*` must be procedures. `call-with-values` applies
    `*consumer*` to the values returned by invoking `*producer*` without arguments.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '`(call-with-values'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (values 'bond 'james))
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y) (cons y x))) ![<graphic>](ch2_0.gif) (james . bond)
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values values list) ![<graphic>](ch2_0.gif) '()`
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, `values` itself serves as the producer. It receives no
    arguments and thus returns no values. `list` is thus applied to no arguments and
    so returns the empty list.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `dxdy` defined below computes the change in `*x*` and `*y*` coordinates
    for a pair of points whose coordinates are represented by `(*x* . *y*)` pairs.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '`(define dxdy'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p1 p2)
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: (values (- (car p2) (car p1))
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: (- (cdr p2) (cdr p1)))))
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: (dxdy '(0 . 0) '(0 . 5)) ![<graphic>](ch2_0.gif) 0
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) 5`'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '`dxdy` can be used to compute the length and slope of a segment represented
    by two endpoints.'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '`(define segment-length'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p1 p2)
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (dxdy p1 p2))
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (dx dy) (sqrt (+ (* dx dx) (* dy dy)))))))
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: (define segment-slope
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p1 p2)
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (dxdy p1 p2))
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (dx dy) (/ dy dx)))))
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: (segment-length '(1 . 4) '(4 . 8)) ![<graphic>](ch2_0.gif) 5
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: (segment-slope '(1 . 4) '(4 . 8)) ![<graphic>](ch2_0.gif) 4/3`
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: We can of course combine these to form one procedure that returns two values.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '`(define describe-segment'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p1 p2)
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (dxdy p1 p2))
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (dx dy)
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: (values
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: (sqrt (+ (* dx dx) (* dy dy)))
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: (/ dy dx))))))
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: (describe-segment '(1 . 4) '(4 . 8)) ![<graphic>](ch2_0.gif) 5
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch2_0.gif) 4/3`'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: The example below employs multiple values to divide a list nondestructively
    into two sublists of alternating elements.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '`(define split'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: (if (or (null? ls) (null? (cdr ls)))
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: (values ls '())
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (split (cddr ls)))
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (odds evens)
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: (values (cons (car ls) odds)
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: (cons (cadr ls) evens)))))))
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: (split '(a b c d e f)) ![<graphic>](ch2_0.gif) (a c e)
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '![](ch3_ghostRightarrow.gif) (b d f)`'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: 'At each level of recursion, the procedure `split` returns two values: a list
    of the odd-numbered elements from the argument list and a list of the even-numbered
    elements.'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: 'The continuation of a call to `values` need not be one established by a call
    to `call-with-values`, nor must only `values` be used to return to a continuation
    established by `call-with-values`. In particular, `(values *e*)` and `*e*` are
    equivalent expressions. For example:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ (values 2) 4) ![<graphic>](ch2_0.gif) 6'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: (if (values #t) 1 2) ![<graphic>](ch2_0.gif) 1
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () 4)
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x) x)) ![<graphic>](ch2_0.gif) 4`
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, `values` may be used to pass any number of values to a continuation
    that ignores the values, as in the following.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '`(begin (values 1 2 3) 4) ![<graphic>](ch2_0.gif) 4`'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: Because a continuation may accept zero or more than one value, continuations
    obtained via `call/cc` may accept zero or more than one argument.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '`(call-with-values'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc (lambda (k) (k 2 3))))
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y) (list x y))) ![<graphic>](ch2_0.gif) (2 3)`
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: The behavior is unspecified when a continuation expecting exactly one value
    receives zero values or more than one value. For example, the behavior of each
    of the following expressions is unspecified. Some implementations raise an exception,
    while others silently suppress additional values or supply defaults for missing
    values.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '`(if (values 1 2) ''x ''y)'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: (+ (values) 5)`
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: Programs that wish to force extra values to be ignored in particular contexts
    can do so easily by calling `call-with-values` explicitly. A syntactic form, which
    we might call `first`, can be defined to abstract the discarding of more than
    one value when only one is desired.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax first'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ expr)'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () expr)
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x . y) x))]))
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: (if (first (values #t #f)) 'a 'b) ![<graphic>](ch2_0.gif) a`
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: Since implementations are required to raise an exception with condition type
    `&assertion` if a procedure does not accept the number of arguments passed to
    it, each of the following raises an exception.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '`(call-with-values'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (values 2 3 4))
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y) x))
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (call/cc (lambda (k) (k 0))))
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y) x))`
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: Since `*producer*` is most often a `lambda` expression, it is often convenient
    to use a syntactic extension that suppresses the lambda expression in the interest
    of readability.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax with-values'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ expr consumer)'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values (lambda () expr) consumer)]))
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: (with-values (values 1 2) list) ![<graphic>](ch2_0.gif) (1 2)
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: (with-values (split '(1 2 3 4))
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (odds evens)
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: evens)) ![<graphic>](ch2_0.gif) (2 4)`
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: If the `*consumer*` is also a `lambda` expression, the multiple-value variants
    of `let` and `let*` described in Section [4.5](binding.html#g93) are usually even
    more convenient.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '`(let-values ([(odds evens) (split ''(1 2 3 4))])'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: evens) ![<graphic>](ch2_0.gif) (2 4)
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: (let-values ([ls (values 'a 'b 'c)])
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: ls) ![<graphic>](ch2_0.gif) (a b c)`
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: 'Many standard syntactic forms and procedures pass along multiple values. Most
    of these are "automatic," in the sense that nothing special must be done by the
    implementation to make this happen. The usual expansion of `let` into a direct
    `lambda` call automatically propagates multiple values produced by the body of
    the `let`. Other operators must be coded specially to pass along multiple values.
    The `call-with-port` procedure (page [7.6](io.html#g127)), for example, calls
    its procedure argument, then closes the port argument before returning the procedure''s
    values, so it must save the values temporarily. This is easily accomplished via
    `let-values`, `apply`, and `values`:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: '`(define call-with-port'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (port proc)
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: (let-values ([val* (proc port)])
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: (close-port port)
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: (apply values val*))))`
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: 'If this seems like too much overhead when a single value is returned, the code
    can use `call-with-values` and `case-lambda` to handle the single-value case more
    efficiently:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: '`(define call-with-port'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (port proc)
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: (call-with-values (lambda () (proc port))
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: (case-lambda
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: '[(val) (close-port port) val]'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: '[val* (close-port port) (apply values val*)]))))`'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: The definitions of `values` and `call-with-values` (and concomitant redefinition
    of `call/cc`) in the library below demonstrate that the multiple-return-values
    interface could be implemented in Scheme if it were not already built in. No error
    checking can be done, however, for the case in which more than one value is returned
    to a single-value context, such as the test part of an `if` expression.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: '`(library (mrvs)'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: (export call-with-values values call/cc
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: (rename (call/cc call-with-current-continuation)))
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: (import
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: (rename
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: (except (rnrs) values call-with-values)
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc rnrs:call/cc)))
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: (define magic (cons 'multiple 'values))
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: (define magic?
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: (and (pair? x) (eq? (car x) magic))))`
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: '`  (define call/cc'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p)
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: (rnrs:call/cc
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (k)
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: (p (lambda args
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: (k (apply values args))))))))
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: (define values
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: (lambda args
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: (if (and (not (null? args)) (null? (cdr args)))
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: (car args)
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: (cons magic args))))
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: (define call-with-values
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (producer consumer)
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (producer)])
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: (if (magic? x)
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: (apply consumer (cdr x))
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: (consumer x))))))`
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: Multiple values can be implemented more efficiently [[2](bibliography.html#g220)],
    but this code serves to illustrate the meanings of the operators and may be used
    to provide multiple values in older, nonstandard implementations that do not support
    them.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: Section 5.9\. Eval
  id: totrans-771
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scheme's `eval` procedure allows programmers to write programs that construct
    and evaluate other programs. This ability to do run-time *meta programming* should
    not be overused but is handy when needed.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(eval *obj* *environment*)`'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** values of the Scheme expression represented by `*obj*` in `*environment*`'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs eval)`'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: If `*obj*` does not represent a syntactically valid expression, `eval` raises
    an exception with condition type `&syntax`. The environments returned by `environment`,
    `scheme-report-environment`, and `null-environment` are immutable. Thus, `eval`
    also raises an exception with condition type `&syntax` if an assignment to any
    of the variables in the environment appears within the expression.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: '`(define cons ''not-cons)'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: (eval '(let ([x 3]) (cons x 4)) (environment '(rnrs))) ![<graphic>](ch2_0.gif) (3 . 4)
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: (define lambda 'not-lambda)
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: (eval '(lambda (x) x) (environment '(rnrs))) ![<graphic>](ch2_0.gif) #<procedure>
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: (eval '(cons 3 4) (environment)) ![<graphic>](ch2_0.gif) *exception*`
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(environment *import-spec* ...)`'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** an environment'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs eval)`'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '`environment` returns an environment formed from the combined bindings of the
    given import specifiers. Each `*import-spec*` must be an s-expression representing
    a valid import specifier (see Chapter [10](libraries.html#g142)).'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: '`(define env (environment ''(rnrs) ''(prefix (rnrs lists) $)))'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: (eval '($cons* 3 4 (* 5 8)) env) ![<graphic>](ch2_0.gif) (3 4 . 40)`
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(null-environment *version*)`'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(scheme-report-environment *version*)`'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** an R5RS compatibility environment'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs r5rs)`'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '`*version*` must be the exact integer `5`.'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '`null-environment` returns an environment containing bindings for the keywords
    whose meanings are defined by the Revised⁵ Report on Scheme, along with bindings
    for the auxiliary keywords `else`, `=>`, `...`, and `_`.'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: '`scheme-report-environment` returns an environment containing the same keyword
    bindings as the environment returned by `null-environment` along with bindings
    for the variables whose meanings are defined by the Revised⁵ Report on Scheme,
    except those not defined by the Revised⁶ Report: `load`, `interaction-environment`,
    `transcript-on`, `transcript-off`, and `char-ready?`.'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: The bindings for each of the identifiers in the environments returned by these
    procedures are those of the corresponding Revised⁶ Report library, so this does
    not provide full backward compatibility, even if the excepted identifier bindings
    are not used.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: R. Kent Dybvig / <it>The Scheme Programming Language, Fourth Edition</it>
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: Copyright © 2009 [The MIT Press](http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984).
    Electronically reproduced by permission.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: Illustrations © 2009 [Jean-Pierre Hébert](http://hebert.kitp.ucsb.edu/)
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: '[to order this book](http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=11984)
    / [about this book](canned/about.html)'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.scheme.com](http://www.scheme.com/)'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
