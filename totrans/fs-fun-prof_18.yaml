- en: The "Designing with types" Series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “使用类型设计”系列
- en: In this series, we'll look at some of the ways we can use types as part of the
    design process. In particular, the thoughtful use of types can make a design more
    transparent and improve correctness at the same time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系列中，我们将探讨如何在设计过程中使用类型的一些方法。特别是，深思熟虑地使用类型可以使设计更加透明，同时提高正确性。
- en: This series will be focused on the "micro level" of design. That is, working
    at the lowest level of individual types and functions. Higher level design approaches,
    and the associated decisions about using functional or object-oriented style,
    will be discussed in another series.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本系列将专注于设计的“微观层面”。也就是说，工作在单个类型和函数的最低级别。关于使用函数式或面向对象风格的更高级别设计方法，以及相关的决策，将在另一个系列中讨论。
- en: Many of the suggestions are also feasable in C# or Java, but the lightweight
    nature of F# types means that it is much more likely that we will do this kind
    of refactoring.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多建议在C#或Java中也是可行的，但F#类型的轻量级特性意味着我们更有可能进行这种类型的重构。
- en: '[Designing with types: Introduction](designing-with-types-intro.html). Making
    design more transparent and improving correctness.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用类型设计：介绍](designing-with-types-intro.html)。使设计更透明，提高正确性。'
- en: '[Designing with types: Single case union types](designing-with-types-single-case-dus.html).
    Adding meaning to primitive types.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用类型设计：单例联合类型](designing-with-types-single-case-dus.html)。为原始类型添加含义。'
- en: '[Designing with types: Making illegal states unrepresentable](designing-with-types-making-illegal-states-unrepresentable.html).
    Encoding business logic in types.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用类型设计：使非法状态不可表示](designing-with-types-making-illegal-states-unrepresentable.html)。在类型中编码业务逻辑。'
- en: '[Designing with types: Discovering new concepts](designing-with-types-discovering-the-domain.html).
    Gaining deeper insight into the domain.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用类型设计：发现新概念](designing-with-types-discovering-the-domain.html)。深入了解领域。'
- en: '[Designing with types: Making state explicit](designing-with-types-representing-states.html).
    Using state machines to ensure correctness.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用类型设计：使状态显式](designing-with-types-representing-states.html)。使用状态机确保正确性。'
- en: '[Designing with types: Constrained strings](designing-with-types-more-semantic-types.html).
    Adding more semantic information to a primitive type.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用类型设计：受限字符串](designing-with-types-more-semantic-types.html)。为原始类型添加更多语义信息。'
- en: '[Designing with types: Non-string types](designing-with-types-non-strings.html).
    Working with integers and dates safely.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用类型设计：非字符串类型](designing-with-types-non-strings.html)。安全地使用整数和日期。'
- en: '[Designing with types: Conclusion](designing-with-types-conclusion.html). A
    before and after comparison.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用类型设计：结论](designing-with-types-conclusion.html)。前后对比。'
- en: 'Designing with types: Introduction'
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型设计：介绍
- en: 'Designing with types: Introduction'
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型设计：介绍
- en: In this series, we'll look at some of the ways we can use types as part of the
    design process. In particular, the thoughtful use of types can make a design more
    transparent and improve correctness at the same time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系列中，我们将探讨如何在设计过程中使用类型的一些方法。特别是，深思熟虑地使用类型可以使设计更加透明，同时提高正确性。
- en: This series will be focused on the "micro level" of design. That is, working
    at the lowest level of individual types and functions. Higher level design approaches,
    and the associated decisions about using functional or object-oriented style,
    will be discussed in another series.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本系列将专注于设计的“微观层面”。也就是说，工作在单个类型和函数的最低级别。关于使用函数式或面向对象风格的更高级别设计方法，以及相关的决策，将在另一个系列中讨论。
- en: Many of the suggestions are also feasable in C# or Java, but the lightweight
    nature of F# types means that it is much more likely that we will do this kind
    of refactoring.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 许多建议在C#或Java中也是可行的，但F#类型的轻量级特性意味着我们更有可能进行这种类型的重构。
- en: A basic example
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个基本示例
- en: For demonstration of the various uses of types, I'll work with a very straightforward
    example, namely a `Contact` type, such as the one below.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示各种类型的用途，我将使用一个非常简单的示例，即`Contact`类型，如下所示。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This seems very obvious -- I'm sure we have all seen something like this many
    times. So what can we do with it? How can we refactor this to make the most of
    the type system?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎非常明显--我相信我们都见过类似的东西很多次。那么我们可以怎么做呢？我们如何重构它以充分利用类型系统？
- en: Creating "atomic" types
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建“原子”类型
- en: The first thing to do is to look at the usage pattern of data access and updates.
    For example, would be it be likely that `Zip` is updated without also updating
    `Address1` at the same time? On the other hand, it might be common that a transaction
    updates `EmailAddress` but not `FirstName`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是查看数据访问和更新的使用模式。例如，`Zip` 是否有可能在不同时更新 `Address1`？另一方面，交易更新 `EmailAddress`
    而不更新 `FirstName` 可能是常见的。
- en: 'This leads to the first guideline:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了第一个指导原则：
- en: '*Guideline: Use records or tuples to group together data that are required
    to be consistent (that is "atomic") but don''t needlessly group together data
    that is not related.*'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指导原则：使用记录或元组将需要保持一致性的数据组合在一起（即“原子”），但不要无谓地将不相关的数据组合在一起。*'
- en: In this case, it is fairly obvious that the three name values are a set, the
    address values are a set, and the email is also a set.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，很明显三个名称值是一组，地址值是一组，电子邮件也是一组。
- en: We have also some extra flags here, such as `IsAddressValid` and `IsEmailVerified`.
    Should these be part of the related set or not? Certainly yes for now, because
    the flags are dependent on the related values.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些额外的标志，如 `IsAddressValid` 和 `IsEmailVerified`。这些是否应该成为相关集合的一部分？现在肯定是，因为这些标志依赖于相关值。
- en: For example, if the `EmailAddress` changes, then `IsEmailVerified` probably
    needs to be reset to false at the same time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 `EmailAddress` 发生变化，那么 `IsEmailVerified` 可能也需要同时被重置为 false。
- en: For `PostalAddress`, it seems clear that the core "address" part is a useful
    common type, without the `IsAddressValid` flag. On the other hand, the `IsAddressValid`
    is associated with the address, and will be updated when it changes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `PostalAddress`，显然核心的“地址”部分是一个有用的通用类型，没有 `IsAddressValid` 标志。另一方面，`IsAddressValid`
    与地址相关联，并且在其更改时将进行更新。
- en: So it seems that we should create *two* types. One is a generic `PostalAddress`
    and the other is an address in the context of a contact, which we can call `PostalContactInfo`,
    say.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所以似乎我们应该创建*两种*类型。一个是通用的 `PostalAddress`，另一个是在联系人上下文中的地址，我们可以称之为 `PostalContactInfo`。
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Finally, we can use the option type to signal that certain values, such as `MiddleInitial`,
    are indeed optional.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用选项类型来表示某些值，例如 `MiddleInitial`，确实是可选的。
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Summary
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'With all these changes, we now have the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所有这些变化，我们现在有了以下代码：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We haven't written a single function yet, but already the code represents the
    domain better. However, this is just the beginning of what we can do.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有写一个函数，但代码已经更好地代表了领域。然而，这只是我们可以做的开始。
- en: Next up, using single case unions to add semantic meaning to primitive types.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用单一案例联合类型为基本类型添加语义含义。
- en: Single case union types
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一案例联合类型
- en: 'Designing with types: Single case union types'
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型设计：单一案例联合类型
- en: 'At the end of the previous post, we had values for email addresses, zip codes,
    etc., defined like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇文章的结尾，我们为电子邮件地址、邮政编码等定义了值，如下所示：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These are all defined as simple strings. But really, are they just strings?
    Is an email address interchangable with a zip code or a state abbreviation?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都被定义为简单的字符串。但是实际上，它们只是字符串吗？电子邮件地址是否可以与邮政编码或州缩写互换使用？
- en: In a domain driven design, they are indeed distinct things, not just strings.
    So we would ideally like to have lots of separate types for them so that they
    cannot accidentally be mixed up.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域驱动设计中，它们确实是不同的事物，而不仅仅是字符串。因此，我们理想情况下希望为它们创建许多单独的类型，以防止它们被意外混淆。
- en: This has been [known as good practice](http://codemonkeyism.com/never-never-never-use-string-in-java-or-at-least-less-often/)
    for a long time, but in languages like C# and Java it can be painful to create
    hundred of tiny types like this, leading to the so called ["primitive obsession"](http://sourcemaking.com/refactoring/primitive-obsession)
    code smell.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，这一直被视为[良好的实践](http://codemonkeyism.com/never-never-never-use-string-in-java-or-at-least-less-often/)，但在像
    C# 和 Java 这样的语言中，创建数百个这样的微小类型可能会很痛苦，导致所谓的["原始迷恋"](http://sourcemaking.com/refactoring/primitive-obsession)代码异味。
- en: But F# there is no excuse! It is trivial to create simple wrapper types.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在 F# 中没有借口！创建简单的包装类型是微不足道的。
- en: Wrapping primitive types
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包装基本类型
- en: The simplest way to create a separate type is to wrap the underlying string
    type inside another type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个单独类型的最简单方法是将底层的字符串类型包装在另一个类型中。
- en: 'We can do it using single case union types, like so:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用单一案例联合类型来做到这一点，就像这样：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'or alternatively, we could use record types with one field, like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用一个字段的记录类型，就像这样：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Both approaches can be used to create wrapper types around a string or other
    primitive type, so which way is better?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都可以用于创建围绕字符串或其他原始类型的包装类型，那么哪种方式更好呢？
- en: The answer is generally the single case discriminated union. It is much easier
    to "wrap" and "unwrap", as the "union case" is actually a proper constructor function
    in its own right. Unwrapping can be done using inline pattern matching.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 答案通常是单一情况辨别式联合。它要容易得多地“包装”和“解包”，因为“联合情况”实际上是一个适当的构造函数。使用内联模式匹配可以进行解包。
- en: 'Here''s some examples of how an `EmailAddress` type might be constructed and
    deconstructed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`EmailAddress`类型可能被构造和解构的一些示例：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can't do this as easily using record types.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用记录类型不容易做到这一点。
- en: 'So, let''s refactor the code again to use these union types. It now looks like
    this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们再次重构代码以使用这些联合类型。现在它看起来像这样：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Another nice thing about the union type is that the implementation can be encapsulated
    with module signatures, as we'll discuss below.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型的另一个好处是，实现可以通过模块签名进行封装，我们将在下面讨论。
- en: Naming the "case" of a single case union
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给单一情况联合命名
- en: 'In the examples above we used the same name for the case as we did for the
    type:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们对案例使用了与类型相同的名称：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This might seem confusing initially, but really they are in different scopes,
    so there is no naming collision. One is a type, and one is a constructor function
    with the same name.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最初这可能看起来令人困惑，但实际上它们处于不同的作用域，因此没有命名冲突。一个是类型，另一个是具有相同名称的构造函数。
- en: 'So if you see a function signature like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您看到这样的函数签名：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: this refers to things in the world of types, so `EmailAddress` refers to the
    type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` 指的是类型世界中的事物，所以 `EmailAddress` 指的是类型。'
- en: 'On the other hand, if you see some code like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您看到这样的代码：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: this refers to things in the world of values, so `EmailAddress` refers to the
    constructor function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` 指的是值世界中的事物，所以`EmailAddress`指的是构造函数。'
- en: Constructing single case unions
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造单一情况联合
- en: For values that have special meaning, such as email addresses and zip codes,
    generally only certain values are allowed. Not every string is an acceptable email
    or zip code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有特殊含义的值，例如电子邮件地址和邮政编码，通常只允许特定的值。并非每个字符串都是可接受的电子邮件或邮政编码。
- en: This implies that we will need to do validation at some point, and what better
    point than at construction time? After all, once the value is constructed, it
    is immutable, so there is no worry that someone might modify it later.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们将需要在某个时候进行验证，那么最好的时机何时？毕竟，一旦值被构造，它就是不可变的，所以不用担心后来有人可能修改它。
- en: 'Here''s how we might extend the above module with some constructor functions:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何扩展上面模块的一些构造函数的方法：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can test the constructors now:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以测试构造函数了：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Handling invalid input in a constructor
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在构造函数中处理无效输入
- en: With these kinds of constructor functions, one immediate challenge is the question
    of how to handle invalid input. For example, what should happen if I pass in "abc"
    to the email address constructor?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些类型的构造函数，一个即时的挑战是如何处理无效输入的问题。例如，如果我将“abc”传递给电子邮件地址构造函数，会发生什么？
- en: There are a number of ways to deal with it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多处理方法。
- en: First, you could throw an exception. I find this ugly and unimaginative, so
    I'm rejecting this one out of hand!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以抛出异常。我觉得这很丑陋，毫无想象力，所以我不接受这个！
- en: Next, you could return an option type, with `None` meaning that the input wasn't
    valid. This is what the constructor functions above do.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以返回一个选项类型，`None`表示输入无效。这就是上面的构造函数所做的。
- en: This is generally the easiest approach. It has the advantage that the caller
    has to explicitly handle the case when the value is not valid.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是最简单的方法。它的优点是调用者必须明确处理值无效的情况。
- en: 'For example, the caller''s code for the example above might look like:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上面示例的调用者代码可能如下所示：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The disadvantage is that with complex validations, it might not be obvious what
    went wrong. Was the email too long, or missing a '@' sign, or an invalid domain?
    We can't tell.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是，在进行复杂的验证时，可能不明显出错。是电子邮件太长了，还是缺少了'@'符号，或者是无效的域名？我们无法确定。
- en: If you do need more detail, you might want to return a type which contains a
    more detailed explanation in the error case.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更详细的信息，您可能希望返回一个类型，在错误情况下包含更详细的解释。
- en: The following example uses a `CreationResult` type to indicate the error in
    the failure case.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`CreationResult`类型指示失败情况中的错误。
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, the most general approach uses continuations. That is, you pass in
    two functions, one for the success case (that takes the newly constructed email
    as parameter), and another for the failure case (that takes the error string as
    parameter).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最一般的方法使用延续。也就是说，您传入两个函数，一个用于成功情况（以新构造的电子邮件作为参数），另一个用于失败情况（以错误字符串作为参数）。
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The success function takes the email as a parameter and the error function takes
    a string. Both functions must return the same type, but the type is up to you.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 成功函数以电子邮件作为参数，错误函数以字符串作为参数。这两个函数必须返回相同的类型，但类型由您决定。
- en: Here is a simple example -- both functions do a printf, and return nothing (i.e.
    unit).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子--两个函数都执行 printf，并且不返回任何内容（即 unit）。
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With continuations, you can easily reproduce any of the other approaches. Here's
    the way to create options, for example. In this case both functions return an
    `EmailAddress option`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用延续，您可以轻松地重现任何其他方法。例如，这是创建选项的方法。在这种情况下，两个函数都返回一个`EmailAddress option`。
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And here is the way to throw exceptions in the error case:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是在错误情况下抛出异常的方法：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code seems quite cumbersome, but in practice you would probably create
    a local partially applied function that you use instead of the long-winded one.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码似乎相当繁琐，但在实践中，您可能会创建一个局部应用函数，而不是使用冗长的函数。
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Creating modules for wrapper types
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为包装类型创建模块
- en: These simple wrapper types are starting to get more complicated now that we
    are adding validations, and we will probably discover other functions that we
    want to associate with the type.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的包装类型现在开始变得更加复杂，因为我们正在添加验证，并且我们可能会发现其他要与该类型关联的函数。
- en: So it is probably a good idea to create a module for each wrapper type, and
    put the type and its associated functions there.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为每个包装类型创建一个模块可能是一个好主意，并将类型及其相关函数放在那里。
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The users of the type would then use the module functions to create and unwrap
    the type. For example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，类型的用户将使用模块函数来创建和解包类型。例如：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Forcing use of the constructor
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制使用构造函数
- en: One issue is that you cannot force callers to use the constructor. Someone could
    just bypass the validation and create the type directly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题是您无法强制调用者使用构造函数。有人可能会绕过验证直接创建类型。
- en: In practice, that tends not to be a problem. One simple techinique is to use
    naming conventions to indicate a "private" type, and provide "wrap" and "unwrap"
    functions so that the clients never need to interact with the type directly.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这往往不是一个问题。一个简单的技巧是使用命名约定来指示“私有”类型，并提供“包装”和“解包”函数，以便客户端永远不需要直接与类型交互。
- en: 'Here''s an example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Of course the type is not really private in this case, but you are encouraging
    the callers to always use the "published" functions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这种情况下，类型实际上并不是私有的，但您鼓励调用者始终使用“发布的”函数。
- en: If you really want to encapsulate the internals of the type and force callers
    to use a constructor function, you can use module signatures.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的想封装类型的内部并强制调用者使用构造函数，您可以使用模块签名。
- en: 'Here''s a signature file for the email address example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是电子邮件地址示例的签名文件：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: (Note that module signatures only work in compiled projects, not in interactive
    scripts, so to test this, you will need to create three files in an F# project,
    with the filenames as shown here.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，模块签名仅适用于编译项目，而不适用于交互式脚本，因此要测试这一点，您需要在一个 F# 项目中创建三个文件，文件名如下所示。）
- en: 'Here''s the implementation file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现文件：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And here''s a client:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个客户端：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The type `EmailAddress.T` exported by the module signature is opaque, so clients
    cannot access the internals.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由模块签名导出的`EmailAddress.T`类型是不透明的，因此客户端无法访问内部。
- en: As you can see, this approach enforces the use of the constructor. Trying to
    create the type directly (`T.EmailAddress "bad email"`) causes a compile error.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这种方法强制使用构造函数。尝试直接创建类型（`T.EmailAddress "bad email"`）会导致编译错误。
- en: When to "wrap" single case unions
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时“包装”单例联合
- en: Now that we have the wrapper type, when should we construct them?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了包装类型，那么什么时候应该构建它们？
- en: Generally you only need to at service boundaries (for example, boundaries in
    a [hexagonal architecture](http://alistair.cockburn.us/Hexagonal+architecture))
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您只需要在服务边界（例如，在[六边形架构](http://alistair.cockburn.us/Hexagonal+architecture)中的边界）处使用。
- en: In this approach, wrapping is done in the UI layer, or when loading from a persistence
    layer, and once the wrapped type is created, it is passed in to the domain layer
    and manipulated "whole", as an opaque type. It is suprisingly uncommon that you
    actually need the wrapped contents directly when working in the domain itself.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，包装是在 UI 层或从持久化层加载时完成的，一旦创建了包装类型，它就作为不透明类型传递给域层并“整体”操作。在域本身工作时，直接需要包装内容的情况非常少见。
- en: As part of the construction, it is critical that the caller uses the provided
    constructor rather than doing its own validation logic. This ensures that "bad"
    values can never enter the domain.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 作为构造的一部分，调用者使用提供的构造函数而不是自己的验证逻辑是至关重要的。这确保了“坏”值永远无法进入域中。
- en: 'For example, here is some code that shows the UI doing its own validation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一些显示 UI 自己进行验证的代码：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A better way is to let the constructor do it, as shown earlier.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是让构造函数来做，如前所示。
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When to "unwrap" single case unions
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时“解封装”单个案例联合
- en: And when is unwrapping needed? Again, generally only at service boundaries.
    For example, when you are persisting an email to a database, or binding to a UI
    element or view model.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 那么何时需要解封装呢？再次强调，通常只在服务边界处需要。例如，当您将电子邮件持久化到数据库中，或者绑定到 UI 元素或视图模型时。
- en: One tip to avoid explicit unwrapping is to use the continuation approach again,
    passing in a function that will be applied to the wrapped value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 避免显式解包的一个技巧是再次使用延续方法，传递一个将被应用于包装值的函数。
- en: 'That is, rather than calling the "unwrap" function explicitly:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，而不是显式调用“解封装”函数：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You would pass in a function which gets applied to the inner value, like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您将传递一个函数，该函数将应用于内部值，如下所示：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Putting this together, we now have the complete `EmailAddress` module.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些放在一起，我们现在有了完整的 `EmailAddress` 模块。
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `create` and `value` functions are not strictly necessary, but are added
    for the convenience of callers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`create` 和 `value` 函数并非绝对必需，但为调用者的方便而添加。'
- en: The code so far
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 到目前为止的代码
- en: Let's refactor the `Contact` code now, with the new wrapper types and modules
    added.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重构 `Contact` 代码，添加新的包装类型和模块。
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By the way, notice that we now have quite a lot of duplicate code in the three
    wrapper type modules. What would be a good way of getting rid of it, or at least
    making it cleaner?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，请注意我们现在在三个包装类型模块中有相当多的重复代码。如何摆脱它，或者至少使它更清晰？
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概要
- en: 'To sum up the use of discriminated unions, here are some guidelines:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 总结使用歧义联合的用法，以下是一些指导方针：
- en: Do use single case discriminated unions to create types that represent the domain
    accurately.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个案例的歧义联合来创建准确表示域的类型。
- en: If the wrapped value needs validation, then provide constructors that do the
    validation and enforce their use.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果包装值需要验证，则提供进行验证并强制使用的构造函数。
- en: Be clear what happens when validation fails. In simple cases, return option
    types. In more complex cases, let the caller pass in handlers for success and
    failure.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清楚地说明验证失败时会发生什么。在简单情况下，返回选项类型。在更复杂的情况下，让调用者传递成功和失败的处理程序。
- en: If the wrapped value has many associated functions, consider moving it into
    its own module.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果包装值有许多关联函数，请考虑将其移动到自己的模块中。
- en: If you need to enforce encapsulation, use signature files.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要强制封装，请使用签名文件。
- en: We're still not done with refactoring. We can alter the design of types to enforce
    business rules at compile time -- making illegal states unrepresentable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的重构工作还没有完成。我们可以改变类型的设计以在编译时强制执行业务规则 -- 使非法状态不可表示。
- en: Update
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新
- en: Many people have asked for more information on how to ensure that constrained
    types such as `EmailAddress` are only created through a special constructor that
    does the validation. So I have created a [gist here](https://gist.github.com/swlaschin/54cfff886669ccab895a)
    that has some detailed examples of other ways of doing it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人询问如何确保约束类型（如 `EmailAddress`）只能通过执行验证的特殊构造函数来创建，所以我创建了一个[gist](https://gist.github.com/swlaschin/54cfff886669ccab895a)，里面有一些详细的其他方法的示例。
- en: Making illegal states unrepresentable
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使非法状态不可表示
- en: 'Designing with types: Making illegal states unrepresentable'
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型进行设计：使非法状态不可表示
- en: In this post, we look at a key benefit of F#, which using the type system to
    "make illegal states unrepresentable" (a phrase borrowed from [Yaron Minsky](https://ocaml.janestreet.com/?q=node/85)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将看到 F# 的一个关键优势，即使用类型系统来“使非法状态不可表示”（这是从[Yaron Minsky](https://ocaml.janestreet.com/?q=node/85)那里借来的短语）。
- en: 'Let''s look at our `Contact` type. Thanks to the previous refactoring, it is
    quite simple:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的`Contact`类型。由于之前的重构，它非常简单：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now let''s say that we have the following simple business rule: *"A contact
    must have an email or a postal address"*. Does our type conform to this rule?'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们假设我们有以下简单的业务规则：“一个联系人必须有电子邮件或邮寄地址”。我们的类型符合这个规则吗？
- en: The answer is no. The business rule implies that a contact might have an email
    address but no postal address, or vice versa. But as it stands, our type requires
    that a contact must always have *both* pieces of information.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的。业务规则暗示着一个联系人可能有电子邮件地址但没有邮寄地址，反之亦然。但就目前而言，我们的类型要求一个联系人必须始终*同时*具有这两种信息。
- en: 'The answer seems obvious -- make the addresses optional, like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 答案似乎很明显--把地址设为可选项，就像这样：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: But now we have gone too far the other way. In this design, it would be possible
    for a contact to have neither type of address at all. But the business rule says
    that at least one piece of information *must* be present.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们已经走得太远了。在这个设计中，一个联系人可能根本没有任何类型的地址。但是业务规则说，至少必须有一个信息*必须*存在。
- en: What's the solution?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是什么？
- en: Making illegal states unrepresentable
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使非法状态不可表示
- en: 'If we think about the business rule carefully, we realize that there are three
    possibilities:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细思考业务规则，我们会意识到有三种可能性：
- en: A contact only has an email address
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个联系人只有电子邮件地址。
- en: A contact only has a postal address
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个联系人只有邮寄地址。
- en: A contact has both a email address and a postal address
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个联系人既有电子邮件地址，又有邮寄地址。
- en: Once it is put like this, the solution becomes obvious -- use a union type with
    a case for each possibility.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这样表述，解决方案就变得很明显--使用一个联合类型，每种可能情况都有一个情况。
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This design meets the requirements perfectly. All three cases are explictly
    represented, and the fourth possible case (with no email or postal address at
    all) is not allowed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计完全满足要求。所有三种情况都得到了明确表示，而第四种可能情况（完全没有电子邮件或邮寄地址）是不允许的。
- en: Note that for the "email and post" case, I just used a tuple type for now. It's
    perfectly adequate for what we need.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于“电子邮件和邮寄”情况，我目前只是使用了元组类型。对于我们需要的内容来说，它完全足够了。
- en: Constructing a ContactInfo
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造一个ContactInfo
- en: 'Now let''s see how we might use this in practice. We''ll start by creating
    a new contact:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在实践中使用这个。我们将从创建一个新的联系人开始：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this code, we have created a simple helper function `contactFromEmail` to
    create a new contact by passing in a name and email. However, the email might
    not be valid, so the function has to handle both cases, which it doesn't by returning
    a `Contact option`, not a `Contact`
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了一个简单的辅助函数`contactFromEmail`，通过传入名称和电子邮件来创建一个新的联系人。然而，电子邮件可能无效，所以该函数必须处理这两种情况，但它通过返回`Contact
    option`而不是`Contact`来处理。
- en: Updating a ContactInfo
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新一个ContactInfo
- en: 'Now if we need to add a postal address to an existing `ContactInfo`, we have
    no choice but to handle all three possible cases:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们需要向现有的`ContactInfo`添加邮寄地址，我们别无选择，只能处理所有三种可能的情况：
- en: If a contact previously only had an email address, it now has both an email
    address and a postal address, so return a contact using the `EmailAndPost` case.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个联系人以前只有电子邮件地址，现在既有电子邮件地址又有邮寄地址，那么返回一个使用`EmailAndPost`情况的联系人。
- en: If a contact previously only had a postal address, return a contact using the
    `PostOnly` case, replacing the existing address.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个联系人以前只有邮寄地址，那么返回一个使用`PostOnly`情况的联系人，替换现有的地址。
- en: If a contact previously had both an email address and a postal address, return
    a contact with using the `EmailAndPost` case, replacing the existing address.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个联系人以前既有电子邮件地址又有邮寄地址，那么返回一个使用`EmailAndPost`情况的联系人，替换现有的地址。
- en: So here's a helper method that updates the postal address. You can see how it
    explicitly handles each case.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里有一个辅助方法，用于更新邮寄地址。你可以看到它如何明确处理每种情况。
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And here is the code in use:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的使用方式：
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*WARNING: I am using `option.Value` to extract the contents of an option in
    this code. This is ok when playing around interactively but is extremely bad practice
    in production code! You should always use matching to handle both cases of an
    option.*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*警告：我在此代码中使用`option.Value`来提取选项的内容。这在交互式玩耍时是可以的，但在生产代码中是极其不好的做法！你应该始终使用匹配来处理选项的两种情况。*'
- en: Why bother to make these complicated types?
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要把这些复杂的类型做得如此复杂？
- en: 'At this point, you might be saying that we have made things unnecessarily complicated.
    I would answer with these points:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能会说我们把事情搞得太复杂了。我会用以下几点来回答：
- en: First, the business logic *is* complicated. There is no easy way to avoid it.
    If your code is not this complicated, you are not handling all the cases properly.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，业务逻辑 *是* 复杂的。没有简单的方法可以避免它。如果您的代码不是这么复杂，那么您没有正确处理所有情况。
- en: Second, if the logic is represented by types, it is automatically self documenting.
    You can look at the union cases below and immediate see what the business rule
    is. You do not have to spend any time trying to analyze any other code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果逻辑由类型表示，它就是自动自我记录的。您可以查看下面的联合情况，立即看到业务规则是什么。您不必花时间分析其他任何代码。
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, if the logic is represented by a type, any changes to the business
    rules will immediately create breaking changes, which is a generally a good thing.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果逻辑由类型表示，任何对业务规则的更改都将立即创建断更，这通常是一件好事。
- en: In the next post, we'll dig deeper into the last point. As you try to represent
    business logic using types, you may suddenly find that can gain a whole new insight
    into the domain.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一篇文章中，我们将更深入地探讨最后一点。当您尝试使用类型表示业务逻辑时，您可能会突然发现可以对该领域获得全新的见解。
- en: Discovering new concepts
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现新概念
- en: 'Designing with types: Discovering new concepts'
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型进行设计：发现新概念
- en: In the last post, we looked at how we could represent a business rule using
    types.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇文章中，我们看了如何使用类型表示业务规则。
- en: 'The rule was: *"A contact must have an email or a postal address"*.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是：“*联系人必须具有电子邮件或邮政地址*”。
- en: 'And the type we designed was:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的类型是：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now let''s say that the business decides that phone numbers need to be supported
    as well. The new business rule is: *"A contact must have at least one of the following:
    an email, a postal address, a home phone, or a work phone"*.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设业务决定也需要支持电话号码。新的业务规则是：“*联系人必须至少具有以下一种：电子邮件、邮政地址、家庭电话或工作电话*”。
- en: How can we represent this now?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们如何表示这个？
- en: A little thought reveals that there are 15 possible combinations of these four
    contact methods. Surely we don't want to create a union case with 15 choices?
    Is there a better way?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一点思考，可以发现这四种联系方式有15种可能的组合。我们肯定不想创建一个有15个选项的联合情况吧？有更好的方法吗？
- en: Let's hold that thought and look at a different but related problem.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时搁置这个想法，看看一个不同但相关的问题。
- en: Forcing breaking changes when requirements change
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当需求变化时强制性断更
- en: 'Here''s the problem. Say that you have a contact structure which contains a
    list of email addresses and also a list of postal addresses, like so:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有个问题。假设您有一个包含电子邮件地址列表和邮政地址列表的联系人结构，如下所示：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And, also let''s say that you have created a `printReport` function that loops
    through the information and prints it out in a report:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，假设您已创建一个循环遍历信息并将其打印到报告中的`printReport`函数：
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Crude, but simple and understandable.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 粗糙，但简单易懂。
- en: 'Now if the new business rule comes into effect, we might decide to change the
    structure to have some new lists for the phone numbers. The updated structure
    will now look something like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果新的业务规则生效，我们可能决定更改结构以获得一些新的电话列表。更新后的结构现在将如下所示：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you make this change, you also want to make sure that all the functions that
    process the contact infomation are updated to handle the new phone cases as well.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您进行此更改，还要确保更新处理联系信息的所有函数以处理新的电话情况。
- en: Certainly, you will be forced to fix any pattern matches that break. But in
    many cases, you would *not* be forced to handle the new cases.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您将被迫修复任何破坏的模式匹配。但在许多情况下，您将 *不* 被迫处理新情况。
- en: 'For example, here''s `printReport` updated to work with the new lists:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是`printReport`更新后与新列表一起工作的情况：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Can you see the deliberate mistake? Yes, I forgot to change the function to
    handle the phones. The new fields in the record have not caused the code to break
    at all. There is no guarantee that you will remember to handle the new cases.
    It would be all too easy to forget.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您能看到故意的错误吗？是的，我忘记了更改函数以处理电话。记录中的新字段根本没有导致代码中断。不能保证您会记得处理新情况。很容易忘记。
- en: 'Again, we have the challenge: can we design types such that these situations
    cannot easily happen?'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们面临的挑战是：我们能设计出类型，以便这些情况不容易发生吗？
- en: Deeper insight into the domain
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对领域的更深入了解
- en: If you think about this example a bit more deeply, you will realize that we
    have missed the forest for the trees.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再深入思考一下这个例子，您会意识到我们错失了森林。
- en: 'Our initial concept was: *"to contact a customer, there will be a list of possible
    emails, and a list of possible addresses, etc"*.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的概念是：*“要联系客户，将有一个可能的电子邮件列表，以及可能的地址列表等”*。
- en: 'But really, this is all wrong. A much better concept is: *"To contact a customer,
    there will be a list of contact methods. Each contact method could be an email
    OR a postal address OR a phone number"*.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，这一切都是错误的。一个更好的概念是：*“要联系客户，将有一个联系方式列表。每种联系方式可以是电子邮件、邮寄地址或电话号码之一”*。
- en: This is a key insight into how the domain should be modelled. It creates a whole
    new type, a "ContactMethod", which resolves our problems in one stroke.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对领域建模应该如何进行的关键见解。它创建了一个全新的类型，即“ContactMethod”，一举解决了我们的问题。
- en: 'We can immediately refactor the types to use this new concept:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即重构类型以使用这个新概念：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And the reporting code must now be changed to handle the new type as well:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 并且报告代码现在也必须更改以处理新类型：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: These changes have a number of benefits.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化带来了许多好处。
- en: First, from a modelling point of view, the new types represent the domain much
    better, and are more adaptable to changing requitements.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从建模的角度来看，新类型更好地代表了领域，并且更适应变化的需求。
- en: And from a development point of view, changing the type to be a union means
    that any new cases that we add (or remove) will break the code in a very obvious
    way, and it will be much harder to accidentally forget to handle all the cases.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发的角度来看，将类型更改为联合类型意味着我们添加（或删除）的任何新情况都会以非常明显的方式破坏代码，并且更难以偶然地忘记处理所有情况。
- en: Back to the business rule with 15 possible combinations
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到具有 15 种可能组合的业务规则
- en: So now back to the original example. We left it thinking that, in order to encode
    the business rule, we might have to create 15 possible combinations of various
    contact methods.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到原始示例。我们离开时认为，为了编码业务规则，我们可能必须创建 15 种各种联系方式的可能组合。
- en: But the new insight from the reporting problem also affects our understanding
    of the business rule.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 但是来自报告问题的新见解也影响了我们对业务规则的理解。
- en: 'With the "contact method" concept in our heads, we can rephase the requirement
    as: *"A customer must have at least one contact method. A contact method could
    be an email OR a postal addresses OR a phone number"*.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有了“联系方式”的概念，我们可以重新阐述需求为：*“客户必须至少有一种联系方式。联系方式可以是电子邮件、邮寄地址或电话号码之一”*。
- en: 'So let''s redesign the `Contact` type to have a list of contact methods:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们重新设计 `Contact` 类型来有一个联系方式列表：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: But this is still not quite right. The list could be empty. How can we enforce
    the rule that there must be *at least* one contact method?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不够对。列表可能是空的。我们如何强制执行必须至少有一个联系方式的规则？
- en: 'The simplest way is to create a new field that is required, like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是创建一个必需的新字段，如下所示：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this design, the `PrimaryContactMethod` is required, and the secondary contact
    methods are optional, which is exactly what the business rule requires!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，`PrimaryContactMethod` 是必需的，而次要联系方式是可选的，这正是业务规则要求的！
- en: And this refactoring too, has given us some insight. It may be that the concepts
    of "primary" and "secondary" contact methods might, in turn, clarify code in other
    areas, creating a cascading change of insight and refactoring.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重构也给我们带来了一些见解。也许“主要”和“次要”联系方式的概念可能反过来澄清其他领域的代码，从而创造出一连串的见解和重构。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this post, we've seen how using types to model business rules can actually
    help you to understand the domain at a deeper level.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们看到了如何使用类型来建模业务规则实际上可以帮助你更深入地理解领域。
- en: In the *Domain Driven Design* book, Eric Evans devotes a whole section and two
    chapters in particular (chapters 8 and 9) to discussing the importance of [refactoring
    towards deeper insight](http://dddcommunity.org/wp-content/uploads/files/books/evans_pt03.pdf).
    The example in this post is simple in comparison, but I hope that it shows that
    how an insight like this can help improve both the model and the code correctness.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在*领域驱动设计*书中，Eric Evans专门讨论了一整节内容，特别是第8章和第9章（第三部分）。本文示例与之相比较简单，但我希望它能显示出这样一个见解如何帮助改善模型和代码的正确性。
- en: In the next post, we'll see how types can help with representing fine-grained
    states.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一篇文章中，我们将看到类型如何帮助表示细粒度的状态。
- en: Making state explicit
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 明确状态
- en: 'Designing with types: Making state explicit'
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型进行设计：明确状态
- en: In this post we will look at making implicit states explicit by using state
    machines, and then modelling these state machines with union types.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将通过使用状态机将隐含状态显式化，并用联合类型对这些状态机进行建模。
- en: Background
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: In an [earlier post](designing-with-types-single-case-dus.html) in this series,
    we looked at single case unions as a wrapper for types such as email addresses.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系列的[早期文章](designing-with-types-single-case-dus.html)中，我们研究了单个情况的联合类型作为电子邮件地址等类型的包装器。
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This code assumes that either an address is valid or it is not. If it is not,
    we reject it altogether and return `None` instead of a valid value.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码假设地址要么有效要么无效。如果不是，我们将完全拒绝它并返回`None`而不是有效值。
- en: But there are degrees of validity. For example, what happens if we want to keep
    an invalid email address around rather than just rejecting it? In this case, as
    usual, we want to use the type system to make sure that we don't get a valid address
    mixed up with an invalid address.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 但是存在不同程度的有效性。例如，如果我们想保留一个无效的电子邮件地址而不是仅仅拒绝它会发生什么？在这种情况下，通常情况下，我们希望使用类型系统确保我们不会混淆有效地址和无效地址。
- en: 'The obvious way to do this is with a union type:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的方法是使用联合类型：
- en: '[PRE50]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'and with these types we can ensure that only valid emails get sent:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些类型，我们可以确保只发送有效的电子邮件：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: So far, so good. This kind of design should be obvious to you by now.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好。这种设计现在对你来说应该是显而易见的。
- en: But this approach is more widely applicable than you might think. In many situations,
    there are similar "states" that are not made explicit, and handled with flags,
    enums, or conditional logic in code.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种方法的适用性可能比您想象的要广泛得多。在许多情况下，存在类似的“状态”，这些状态没有显式说明，并且在代码中使用标志、枚举或条件逻辑来处理。
- en: State machines
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态机
- en: In the example above, the "valid" and "invalid" cases are mutually incompatible.
    That is, a valid email can never become invalid, and vice versa.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，"有效"和"无效"案例是互斥的。也就是说，有效的电子邮件永远不会变为无效，反之亦然。
- en: But in many cases, it is possible to go from one case to another, triggered
    by some kind of event. At which point we have a ["state machine"](http://en.wikipedia.org/wiki/Finite-state_machine),
    where each case represents a "state", and moving from one state to another is
    a "transition".
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 但在许多情况下，可能会从一个情况转移到另一个情况，由某种事件触发。在这一点上，我们有一个["状态机"](http://en.wikipedia.org/wiki/Finite-state_machine)，其中每种情况代表一个"状态"，从一个状态到另一个状态是一个"转换"。
- en: 'Some examples:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一些例子：
- en: 'A email address might have states "Unverified" and "Verified", where you can
    transition from the "Unverified" state to the "Verified" state by asking the user
    to click on a link in a confirmation email. ![State transition diagram: Verified
    Email](State_VerifiedEmail.png)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子邮件地址可能具有“未验证”和“已验证”等状态，您可以通过要求用户单击确认电子邮件中的链接来从“未验证”状态转换到“已验证”状态。![状态转换图：已验证的电子邮件](State_VerifiedEmail.png)
- en: 'A shopping cart might have states "Empty", "Active" and "Paid", where you can
    transition from the "Empty" state to the "Active" state by adding an item to the
    cart, and to the "Paid" state by paying. ![State transition diagram: Shopping
    Cart](State_ShoppingCart.png)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车可能具有“空”，“活动”和“已付款”等状态，其中您可以通过向购物车添加项目从“空”状态转换到“活动”状态，并通过支付从“活动”状态转换到“已付款”状态。![状态转换图：购物车](State_ShoppingCart.png)
- en: 'A game such as chess might have states "WhiteToPlay", "BlackToPlay" and "GameOver",
    where you can transition from the "WhiteToPlay" state to the "BlackToPlay" state
    by White making a non-game-ending move, or transition to the "GameOver" state
    by playing a checkmate move. ![State transition diagram: Chess game](State_Chess.png)'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，象棋这样的游戏可能具有“白方轮到下棋”，“黑方轮到下棋”和“游戏结束”等状态，其中您可以通过白方进行一个非终结游戏的移动来从“白方轮到下棋”状态转换到“黑方轮到下棋”状态，或通过进行将军移动来转换到“游戏结束”状态。![状态转换图：象棋游戏](State_Chess.png)
- en: In each of these cases, we have a set of states, a set of transitions, and events
    that can trigger a transition.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们有一组状态，一组转换，以及可以触发转换的事件。
- en: 'State machines are often represented by a table, like this one for a shopping
    cart:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机通常由表格表示，就像这个购物车的表格一样：
- en: '| Current State | Event-> | Add Item | Remove Item | Pay |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 当前状态 | 事件-> | 添加项目 | 移除项目 | 支付 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Empty |  | new state = Active | n/a | n/a |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 空的 |  | 新状态 = 活动的 | n/a | n/a |'
- en: '| Active |  | new state = Active | new state = Active or Empty, depending on
    the number of items | new state = Paid |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 活动的 |  | 新状态 = 活动的 | 新状态 = 活动的或空的，取决于项目数量 | 新状态 = 已付款 |'
- en: '| Paid |  | n/a | n/a | n/a |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 已付款 |  | n/a | n/a | n/a |'
- en: With a table like this, you can quickly see exactly what should happen for each
    event when the system is in a given state.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样的表格，您可以快速查看系统处于给定状态时每个事件应该发生的确切情况。
- en: Why use state machines?
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要使用状态机？
- en: 'There are a number of benefits to using state machines in these cases:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下使用状态机有许多好处：
- en: '**Each state can have different allowable behavior.**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个状态可以有不同的可允许行为。**'
- en: In the verified email example, there is probably a business rule that says that
    you can only send password resets to verified email addresses, not to unverified
    addresses. And in the shopping cart example, only an active cart can be paid for,
    and a paid cart cannot be added to.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证过的电子邮件示例中，可能有一项业务规则，规定只能向已验证的电子邮件地址发送密码重置，而不能发送给未验证的地址。在购物车示例中，只有活跃的购物车才能支付，而已支付的购物车不能添加商品。
- en: '**All the states are explicitly documented.**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有状态都有明确的文档记录。**'
- en: It is all too easy to have important states that are implicit but never documented.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种很容易发生的错误是，某些边缘情况没有被处理，但是状态机强制考虑所有情况。
- en: For example, the "empty cart" has different behavior from the "active cart"
    but it would be rare to see this documented explicitly in code.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，“空购物车”的行为与“活跃购物车”的行为不同，但在代码中明确记录这一点是罕见的。
- en: '**It is a design tool that forces you to think about every possibility that
    could occur.**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**这是一个设计工具，它迫使你考虑可能发生的每一种情况。**'
- en: A common cause of errors is that certain edge cases are not handled, but a state
    machine forces all cases to be thought about.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的常见原因是某些边缘情况没有被处理，但是状态机强制考虑所有情况。
- en: For example, what should happen if we try to verify an already verified email?
    What happens if we try to remove an item from an empty shopping cart? What happens
    if white tries to play when the state is "BlackToPlay"? And so on.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们尝试验证已经验证过的电子邮件会发生什么？如果我们尝试从空购物车中移除项目会发生什么？如果在状态为“黑方轮到下棋”时白方试图下棋会发生什么？等等。
- en: How to implement simple state machines in F#
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在 F# 中实现简单的状态机
- en: You are probably familiar with complex state machines, such as those used in
    language parsers and regular expressions. Those kinds of state machines are generated
    from rule sets or grammars, and are quite complicated.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能熟悉复杂的状态机，比如语言解析器和正则表达式中使用的状态机。那些类型的状态机是根据规则集或语法生成的，非常复杂。
- en: The kinds of state machines that I'm talking about are much, much simpler. Just
    a few cases at the most, with a small number of transitions, so we don't need
    to use complex generators.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我所说的状态机类型要简单得多，简单得多。最多只有几种情况，转换的数量很少，因此我们不需要使用复杂的生成器。
- en: So what is the best way implement these simple state machines?
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，实现这些简单状态机的最佳方式是什么？
- en: Typically, each state will have its own type, to store the data that is relevant
    to that state (if any), and then the entire set of states will be represented
    by a union class.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个状态都会有自己的类型，用于存储与该状态相关的数据（如果有的话），然后整个状态集将由联合类表示。
- en: 'Here''s an example using the shopping cart state machine:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用购物车状态机的示例：
- en: '[PRE52]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that the `EmptyCart` state has no data, so no special type is needed.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`EmptyCart`状态没有数据，因此不需要特殊类型。
- en: Each event is then represented by a function that accepts the entire state machine
    (the union type) and returns a new version of the state machine (again, the union
    type).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个事件由一个接受整个状态机（联合类型）并返回状态机的新版本（同样是联合类型）的函数表示。
- en: 'Here''s an example using two of the shopping cart events:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用两个购物车事件的示例：
- en: '[PRE53]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can see that from the caller's point of view, the set of states is treated
    as "one thing" for general manipulation (the `ShoppingCart` type), but when processing
    the events internally, each state is treated separately.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从调用者的角度看到，状态集被视为通用操纵的“一个整体”（`ShoppingCart`类型），但在内部处理事件时，每个状态都是单独处理的。
- en: Designing event handling functions
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计事件处理函数
- en: 'Guideline: *Event handling functions should always accept and return the entire
    state machine*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 指南：*事件处理函数应始终接受并返回整个状态机*
- en: 'You might ask: why do we have to pass in the whole shopping cart to the event-handling
    functions? For example, the `makePayment` event only has relevance when the cart
    is in the Active state, so why not just explicitly pass it the ActiveCart type,
    like this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问：为什么我们必须将整个购物车传递给事件处理函数？例如，`makePayment`事件仅在购物车处于活跃状态时才相关，那么为什么不像这样明确地将其传递给ActiveCart类型：
- en: '[PRE54]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s compare the function signatures:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较函数签名：
- en: '[PRE55]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You will see that the original `makePayment` function takes a cart and results
    in a cart, while the new function takes an `ActiveCartData` and results in a `PaidCartData`,
    which seems to be much more relevant.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现原始`makePayment`函数接受一个购物车并返回一个购物车，而新函数接受一个`ActiveCartData`并返回一个`PaidCartData`，这似乎更相关。
- en: But if you did this, how would you handle the same event when the cart was in
    a different state, such as empty or paid? Someone has to handle the event for
    all three possible states somewhere, and it is much better to encapsulate this
    business logic inside the function than to be at the mercy of the caller.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你这样做了，当购物车处于不同状态时（例如空或已付款），你将如何处理相同的事件？某人必须在某个地方处理所有三种可能状态的事件，将这个业务逻辑封装在函数内比完全依赖调用方要好得多。
- en: Working with "raw" states
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用“原始”状态处理
- en: Occasionally you do genuinely need to treat one of the states as a separate
    entity in its own right and use it independently. Because each state is a type
    as well, this is normally straightforward.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔你确实需要将其中一个状态视为独立的实体并独立使用它。因为每个状态也是一个类型，所以这通常很简单。
- en: For example, if I need to report on all paid carts, I can pass it a list of
    `PaidCartData`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我需要报告所有已付款的购物车，我可以向它传递一个`PaidCartData`列表。
- en: '[PRE56]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: By using a list of `PaidCartData` as the parameter rather than `ShoppingCart`
    itself, I ensure that I cannot accidentally report on unpaid carts.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`PaidCartData`列表作为参数而不是`ShoppingCart`本身，我确保无法意外报告未支付的购物车。
- en: If you do this, it should be in a supporting function to the event handlers,
    never the event handlers themselves.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，它应该是支持函数而不是事件处理程序本身。
- en: Using explicit states to replace boolean flags
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用显式状态替换布尔标志
- en: Let's look at how we can apply this approach to a real example now.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何将这种方法应用到一个真实示例中。
- en: 'In the `Contact` example from an [earlier post](designing-with-types-intro.html)
    we had a flag that was used to indicate whether a customer had verified their
    email address. The type looked like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在[之前的帖子](designing-with-types-intro.html)中的`Contact`示例中，我们有一个标志，用于指示客户是否已验证其电子邮件地址。类型看起来像这样：
- en: '[PRE57]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Any time you see a flag like this, chances are you are dealing with state.
    In this case, the boolean is used to indicate that we have two states: "Unverified"
    and "Verified".'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你看到像这样的标志时，很有可能你正在处理状态。在这种情况下，布尔值用于指示我们有两种状态：“未验证”和“已验证”。
- en: 'As mentioned above, there will probably be various business rules associated
    with what is permissible in each state. For example, here are two:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，每个状态可能会与每个状态允许的内容相关联的各种业务规则。例如，这里有两个：
- en: 'Business rule: *"Verification emails should only be sent to customers who have
    unverified email addresses"*'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务规则：*“只向未验证电子邮件地址的客户发送验证电子邮件”*
- en: 'Business rule: *"Password reset emails should only be sent to customers who
    have verified email addresses"*'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务规则：*“密码重置电子邮件应仅发送给已验证电子邮件地址的客户”*
- en: As before, we can use types to ensure that code conforms to these rules.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们可以使用类型来确保代码符合这些规则。
- en: Let's rewrite the `EmailContactInfo` type using a state machine. We'll put it
    in an module as well.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用状态机重新编写`EmailContactInfo`类型。我们也将把它放在一个模块中。
- en: We'll start by defining the two states.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从定义这两个状态开始。
- en: For the "Unverified" state, the only data we need to keep is the email address.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于“未验证”状态，我们需要保留的唯一数据是电子邮件地址。
- en: For the "Verified" state, we might want to keep some extra data in addition
    to the email address, such as the date it was verified, the number of recent password
    resets, on so on. This data is not relevant (and should not even be visible) to
    the "Unverified" state.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于“已验证”状态，除了电子邮件地址外，我们可能还想保留一些额外数据，例如验证日期、最近密码重置次数等等。这些数据对“未验证”状态不相关（甚至不应该可见）。
- en: '[PRE58]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that for the `UnverifiedData` type I just used a type alias. No need for
    anything more complicated right now, but using a type alias makes the purpose
    explicit and helps with refactoring.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于`UnverifiedData`类型，我只是使用了类型别名。现在没有必要使用更复杂的东西，但是使用类型别名使目的明确，并有助于重构。
- en: Now let's handle the construction of a new state machine, and then the events.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们处理一个新状态机的构建，然后是事件。
- en: Construction *always* results in an unverified email, so that is easy.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造*总是*导致未验证的电子邮件，所以这很容易。
- en: 'There is only one event that transitions from one state to another: the "verified"
    event.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个事件可以从一个状态转换到另一个状态：验证事件。
- en: '[PRE59]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that, as [discussed here](match-expression.html), every branch of the match
    must return the same type, so when ignoring the verified state we must still return
    something, such as the object that was passed in.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如[这里所讨论的](match-expression.html)，匹配的每个分支必须返回相同的类型，因此当忽略已验证的状态时，我们仍然必须返回某些东西，比如传入的对象。
- en: Finally, we can write the two utility functions `sendVerificationEmail` and
    `sendPasswordReset`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以编写两个实用函数`sendVerificationEmail`和`sendPasswordReset`。
- en: '[PRE60]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Using explicit cases to replace case/switch statements
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用显式分支替换case/switch语句
- en: Sometimes it is not just a simple boolean flag that is used to indicate state.
    In C# and Java it is common to use a `int` or an `enum` to represent a set of
    states.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，用于表示状态的不仅仅是一个简单的布尔标志。在C#和Java中，使用`int`或`enum`来表示一组状态是很常见的。
- en: 'For example, here''s a simple state diagram of a package status for a delivery
    system, where a package has three possible states:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个交付系统包裹状态的简单状态图，其中包裹有三种可能的状态：
- en: '![State transition diagram: Package Delivery](State_Delivery.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![状态转换图：包裹投递](State_Delivery.png)'
- en: 'There are some obvious business rules that come out of this diagram:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 从此图中可以得出一些明显的业务规则：
- en: '*Rule: "You can''t put a package on a truck if it is already out for delivery"*'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*规则：“如果包裹已经派送，则无法将包裹放到卡车上”*'
- en: '*Rule: "You can''t sign for a package that is already delivered"*'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*规则：“您无法签收已交付的包裹”*'
- en: and so on.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。
- en: 'Now, without using union types, we might represent this design by using an
    enum to represent the state, like this:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果不使用联合类型，我们可以通过使用枚举来表示状态来表示此设计，如下所示：
- en: '[PRE61]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And then the code to handle the "putOnTruck" and "signedFor" events might look
    like this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 然后处理“putOnTruck”和“signedFor”事件的代码可能如下所示：
- en: '[PRE62]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This code has some subtle bugs in it.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码中存在一些微妙的错误。
- en: When handling the "putOnTruck" event, what should happen in the case that the
    status is *already* `OutForDelivery` or `Delivered`. The code is not explicit
    about it.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理“putOnTruck”事件时，如果状态已经是`OutForDelivery`或`Delivered`，应该发生什么情况？代码对此并不明确。
- en: When handling the "signedFor" event, we do handle the other states, but the
    last else branch assumes that we only have three states, and therefore doesn't
    bother to be explicit about testing for it. This code would be incorrect if we
    ever added a new status.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理“signedFor”事件时，我们确实处理了其他状态，但是最后的else分支假设我们只有三种状态，因此并没有明确地对其进行测试。如果我们添加了新状态，此代码将不正确。
- en: Finally, because the `DeliveryDate` and `DeliverySignature` are in the basic
    structure, it would be possible to set them accidentally, even though the status
    was not `Delivered`.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，因为`DeliveryDate`和`DeliverySignature`位于基本结构中，所以即使状态不是`Delivered`，也有可能意外设置它们。
- en: But as usual, the idiomatic and more type-safe F# approach is to use an overall
    union type rather than embed a status value inside a data structure.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 但是通常情况下，惯用且更具类型安全性的F#方法是使用整体联合类型，而不是将状态值嵌入到数据结构中。
- en: '[PRE63]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: And then the event handlers *must* handle every case.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 然后事件处理程序*必须*处理每种情况。
- en: '[PRE64]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '*Note: I am using `failWith` to handle the errors. In a production system,
    this code should be replaced by client driven error handlers. See the discussion
    of handling constructor errors in the [post about single case DUs](designing-with-types-single-case-dus.html)
    for some ideas.*'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：我使用`failWith`来处理错误。在生产系统中，此代码应由客户驱动的错误处理程序替换。有关单例情况DU的[帖子中处理构造函数错误的讨论](designing-with-types-single-case-dus.html)提供了一些想法。*'
- en: Using explicit cases to replace implicit conditional code
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用显式分支替换隐式条件代码
- en: Finally, there are often cases where a system has states, but they are implicit
    in conditional code.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通常情况下，系统具有状态，但它们在条件代码中是隐式的。
- en: For example, here is a type that represents an order.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是表示订单的类型。
- en: '[PRE65]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: You can guess that Orders can be "new", "paid", "shipped" or "returned", and
    have timestamps and extra information for each transition, but this is not made
    explicit in the structure.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以猜测订单可以是“新建”，“已付款”，“已发货”或“已退货”，并且每个转换都有时间戳和额外信息，但是这在结构中并没有明确表示出来。
- en: The option types are a clue that this type is trying to do too much. At least
    F# forces you to use options -- in C# or Java these might just be nulls, and you
    would have no idea from the type definition whether they were required or not.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 选项类型是表明此类型尝试做太多事情的线索。至少F#强制您使用选项 - 在C#或Java中，这些可能只是null，并且您无法从类型定义中得知它们是否是必需的。
- en: And now let's look at the kind of ugly code that might test these option types
    to see what state the order is in.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看测试这些选项类型以确定订单状态的可能会产生的丑陋代码。
- en: Again, there is some important business logic that depends on the state of the
    order, but nowhere is it explicitly documented what the various states and transitions
    are.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，有一些重要的业务逻辑取决于订单的状态，但各种状态和转换并没有明确记录。
- en: '[PRE66]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '*Note: I added `IsSome` to test for option values being present as a direct
    port of the way that a C# program would test for `null`. But `IsSome` is both
    ugly and dangerous. Don''t use it!*'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：我添加了 `IsSome` 来测试选项值是否存在，这是直接移植了 C# 程序测试 `null` 的方式。但 `IsSome` 既丑陋又危险。不要使用它！*'
- en: Here is a better approach using types that makes the states explicit.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一种更好的方法，使用类型使状态明确。
- en: '[PRE67]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And here are the event handling methods:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是事件处理方法：
- en: '[PRE68]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '*Note: Here I am using `printfn` to handle the errors. In a production system,
    do use a different approach.*'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：这里我使用 `printfn` 来处理错误。在生产系统中，请使用不同的方法。*'
- en: When not to use this approach
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不适合使用这种方法的情况
- en: As with any technique we learn, we have to be careful of treating it like a
    [golden hammer](http://en.wikipedia.org/wiki/Law_of_the_instrument).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们学到的任何技术一样，我们必须小心将其视为[金锤子](http://en.wikipedia.org/wiki/Law_of_the_instrument)。
- en: This approach does add complexity, so before you start using it, be sure that
    benefits will outweigh the costs.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确实增加了复杂性，因此在开始使用之前，请确保收益将超过成本。
- en: 'To recap, here are the conditions where using simple state machines might be
    benficial:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，以下情况下使用简单的状态机可能是有益的：
- en: You have a set of mutually exclusive states with transitions between them.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一组互斥的状态，它们之间存在转换。
- en: The transitions are triggered by external events.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换是由外部事件触发的。
- en: The states are exhaustive. That is, there are no other choices and you must
    always handle all cases.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态是穷尽的。也就是说，没有其他选择，你必须始终处理所有情况。
- en: Each state might have associated data that should not be accessable when the
    system is in another state.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个状态可能都有关联的数据，在系统处于另一个状态时不应该被访问。
- en: There are static business rules that apply to the states.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有适用于状态的静态业务规则。
- en: Let's look at some examples where these guidelines *don't* apply.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些这些准则**不适用**的例子。
- en: '**States are not important in the domain.**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态在领域中不重要。**'
- en: Consider a blog authoring application. Typically, each blog post can be in a
    state such as "Draft", "Published", etc. And there are obviously transitions between
    these states driven by events (such as clicking a "publish" button).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个博客撰写应用程序。通常，每篇博客文章都可以处于“草稿”、“已发布”等状态，这些状态之间显然存在由事件驱动的转换（例如点击“发布”按钮）。
- en: But is it worth creating a state machine for this? Generally, I would say not.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 但为此创建状态机值得吗？一般来说，我会说不值得。
- en: Yes, there are state transitions, but is there really any change in logic because
    of this? From the authoring point of view, most blogging apps don't have any restrictions
    based on the state. You can author a draft post in exactly the same way as you
    author a published post.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，有状态转换，但这真的会因此而改变逻辑吗？从作者的角度来看，大多数博客应用程序并没有基于状态的任何限制。你可以像编写已发布的帖子一样编写草稿帖子。
- en: The only part of the system that *does* care about the state is the display
    engine, and that filters out the drafts in the database layer before it ever gets
    to the domain.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中唯一关心状态的部分是显示引擎，在到达域之前，它在数据库层过滤掉了草稿。
- en: Since there is no special domain logic that cares about the state, it is probably
    unnecessary.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有特殊的领域逻辑关心状态，因此可能是不必要的。
- en: '**State transitions occur outside the application**'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态转换发生在应用程序外部**'
- en: In a customer management application, it is common to classify customers as
    "prospects", "active", "inactive", etc.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户管理应用程序中，将客户分类为“潜在客户”、“活跃客户”、“非活跃客户”等是很常见的。
- en: '![State transition diagram: Customer states](State_Customer.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![状态转换图：客户状态](State_Customer.png)'
- en: In the application, these states have business meaning and should be represented
    by the type system (such as a union type). But the state *transitions* generally
    do not occur within the application itself. For example, we might classify a customer
    as inactive if they haven't ordered anything for 6 months. And then this rule
    might be applied to customer records in a database by a nightly batch job, or
    when the customer record is loaded from the database. But from our application's
    point of view, the transitions do not happen *within* the application, and so
    we do not need to create a special state machine.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，这些状态具有业务含义，并且应该由类型系统（例如联合类型）表示。但是状态*转换*通常不会发生在应用程序内部。例如，如果客户六个月内没有下订单，我们可能会将其分类为不活跃。然后，这个规则可能会通过夜间批处理作业应用到数据库中的客户记录中，或者在从数据库加载客户记录时应用。但从我们应用程序的角度来看，这些转换并不发生*在*应用程序内部，因此我们不需要创建特殊的状态机。
- en: '**Dynamic business rules**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态业务规则**'
- en: The last bullet point in the list above refers to "static" business rules. By
    this I mean that the rules change slowly enough that they should be embedded into
    the code itself.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 上面列表中的最后一个项目指的是“静态”业务规则。我的意思是，这些规则变化得足够缓慢，以至于它们应该被嵌入到代码本身中。
- en: On the other hand, if the rules are dynamic and change frequently, it is probably
    not worth going to the trouble of creating static types.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果规则是动态的并且频繁变化，那么可能不值得费力去创建静态类型。
- en: In these situations, you should consider using active patterns, or even a proper
    rules engine.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，您应该考虑使用活动模式，甚至是一个合适的规则引擎。
- en: Summary
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this post, we've seen that if you have data structures with explicit flags
    ("IsVerified") or status fields ("OrderStatus"), or implicit state (clued by an
    excessive number of nullable or option types), it is worth considering using a
    simple state machine to model the domain objects. In most cases the extra complexity
    is compensated for by the explicit documention of the states and the elimination
    of errors due to not handling all possible cases.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们已经看到，如果您有具有显式标志（“IsVerified”）或状态字段（“OrderStatus”）的数据结构，或者隐式状态（由过多的可空或选项类型提示），那么考虑使用简单的状态机来模拟领域对象是值得的。在大多数情况下，额外的复杂性都可以通过对状态的明确文档化以及消除由于未处理所有可能情况而导致的错误来补偿。
- en: Constrained strings
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制字符串
- en: 'Designing with types: Constrained strings'
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型设计：受限字符串
- en: In a [previous post](designing-with-types-single-case-dus.html), I talked about
    avoiding using plain primitive strings for email addresses, zip codes, states,
    etc. By wrapping them in a single case union, we could (a) force the types to
    be distinct and (b) add validation rules.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在[之前的帖子](designing-with-types-single-case-dus.html)中，我谈到了避免使用普通原始字符串来表示电子邮件地址、邮政编码、州等。通过将它们包装在单例联合体中，我们可以(a)强制类型不同，(b)添加验证规则。
- en: In this post, we'll look at whether we can extend that concept to an even more
    fine grained level.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们将看看是否可以将该概念扩展到更细粒度的层次。
- en: When is a string not a string?
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么时候一个字符串不是一个字符串？
- en: Let's look a simple `PersonalName` type.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的`PersonalName`类型。
- en: '[PRE69]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The type says that the first name is a `string`. But really, is that all it
    is? Are there any other constraints that we might need to add to it?
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 类型说名字是一个`string`。但实际上，它只是这样吗？我们可能需要添加其他约束吗？
- en: Well, OK, it must not be null. But that is assumed in F#.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，好吧，它不能是null。但在F#中，这是被假定的。
- en: What about the length of the string? Is it acceptable to have a name which is
    64K characters long? If not, then is there some maximum length allowed?
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的长度呢？接受一个长度为64K字符的名字吗？如果不是，那么允许的最大长度是多少？
- en: And can a name contain linefeed characters or tabs? Can it start or end with
    whitespace?
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 名称中可以包含换行符或制表符吗？它可以以空格开始或结束吗？
- en: 'Once you put it this way, there are quite a lot of constraints even for a "generic"
    string. Here are some of the obvious ones:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你这样说，即使是对于一个“通用”的字符串，也有相当多的约束。以下是一些显而易见的：
- en: What is its maximum length?
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的最大长度是多少？
- en: Can it cross over multiple lines?
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以跨越多行吗？
- en: Can it have leading or trailing whitespace?
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以有前导或尾随空格吗？
- en: Can it contain non-printing characters?
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以包含非打印字符吗？
- en: Should these constraints be part of the domain model?
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这些约束条件应该作为领域模型的一部分吗？
- en: So we might acknowledge that some constraints exist, but should they really
    be part of the domain model (and the corresponding types derived from it)? For
    example, the constraint that a last name is limited to 100 characters -- surely
    that is specific to a particular implementation and not part of the domain at
    all.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能承认一些约束存在，但它们真的应该成为领域模型（以及从中派生的相应类型）的一部分吗？例如，姓氏限制为100个字符的约束--这显然是特定于特定实现的，根本不是领域的一部分。
- en: I would answer that there is a difference between a logical model and a physical
    model. In a logical model some of these constraints might not be relevant, but
    in a physical model they most certainly are. And when we are writing code, we
    are always dealing with a physical model anyway.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我会回答逻辑模型和物理模型之间存在差异。在逻辑模型中，一些约束可能不相关，但在物理模型中，它们肯定是相关的。而且当我们编写代码时，我们总是在处理物理模型。
- en: Another reason for incorporating the constraints into the model is that often
    the model is shared across many separate applications. For example, a personal
    name may be created in a e-commerce application, which writes it into a database
    table and then puts it on a message queue to be picked up by a CRM application,
    which in turn calls an email templating service, and so on.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 将约束纳入模型的另一个原因是，通常模型在许多独立应用程序之间共享。例如，个人姓名可能在电子商务应用程序中创建，将其写入数据库表，然后将其放入消息队列以供CRM应用程序接收，然后调用电子邮件模板服务，依此类推。
- en: It is important that all these applications and services have the *same* idea
    of what a personal name is, including the length and other constraints. If the
    model does not make the constraints explicit, then it is easy to have a mismatch
    when moving across service boundaries.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些应用程序和服务都有*相同*的个人姓名概念，包括长度和其他约束。如果模型没有明确约束，那么在跨服务边界移动时很容易出现不匹配。
- en: For example, have you ever written code that checks the length of a string before
    writing it to a database?
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您是否曾经编写过在将字符串写入数据库之前检查其长度的代码？
- en: '[PRE70]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If the string *is* too long at this point, what should you do? Silently truncate
    it? Throw an exception?
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时字符串*太长*，你应该怎么办？悄悄截断它？抛出异常？
- en: A better answer is to avoid the problem altogether if you can. By the time the
    string gets to the database layer it is too late -- the database layer should
    not be making these kinds of decisions.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的答案是尽可能避免问题。当字符串到达数据库层时，为时已晚--数据库层不应该做出这种决定。
- en: The problem should be dealt with when the string was *first created*, not when
    it is *used*. In other words, it should have been part of the validation of the
    string.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 问题应该在字符串*第一次创建*时处理，而不是在*使用*时处理。换句话说，它应该是字符串验证的一部分。
- en: But how can we trust that the validation has been done correctly for all possible
    paths? I think you can guess the answer...
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何确保验证已正确完成所有可能的路径？我想你可以猜到答案...
- en: Modeling constrained strings with types
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用类型对受约束的字符串建模
- en: The answer, of course, is to create wrapper types which have the constraints
    built into the type.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，答案是创建具有约束的包装类型。
- en: So let's knock up a quick prototype using the single case union technique we
    used [before](designing-with-types-single-case-dus.html).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们之前使用过的单例联合技术快速制作一个原型 [before](designing-with-types-single-case-dus.html)。
- en: '[PRE71]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note that we immediately have to deal with the case when the validation fails
    by using an option type as the result. It makes creation more painful, but we
    can't avoid it if we want the benefits later.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们立即使用选项类型来处理验证失败的情况作为结果。这使得创建更加痛苦，但如果我们想要以后获得好处，我们无法避免它。
- en: For example, here is a good string and a bad string of length 2.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个长度为2的好字符串和一个坏字符串。
- en: '[PRE72]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In order to use the `String2` value we are forced to check whether it is `Some`
    or `None` at the time of creation.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`String2`值，我们被迫在创建时检查它是`Some`还是`None`。
- en: Problems with this design
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这种设计存在的问题
- en: One problem is that we have a lot of duplicated code. In practice a typical
    domain only has a few dozen string types, so there won't be that much wasted code.
    But still, we can probably do better.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题是我们有很多重复的代码。实际上，一个典型的领域只有几十个字符串类型，因此不会有太多浪费的代码。但是，我们可能可以做得更好。
- en: Another more serious problem is that comparisons become harder. A `String50`
    is a different type from a `String100` so that they cannot be compared directly.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更严重的问题是比较变得更加困难。`String50`是与`String100`不同的类型，因此它们不能直接进行比较。
- en: '[PRE73]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This kind of thing will make working with dictionaries and lists harder.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法将使得与字典和列表一起工作变得更加困难。
- en: Refactoring
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构
- en: 'At this point we can exploit F#''s support for interfaces, and create a common
    interface that all wrapped strings have to support, and also some standard functions:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 此时我们可以利用 F# 对接口的支持，创建一个所有包装字符串都必须支持的公共接口，以及一些标准函数：
- en: '[PRE74]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The key function is `create`, which takes a constructor function and creates
    new values using it only when the validation passes.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 关键函数是 `create`，它接受一个构造函数，并在仅在验证通过时使用它创建新值。
- en: 'With this in place it is a lot easier to define new types:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个之后，定义新类型就容易多了：
- en: '[PRE75]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'For each type of string now, we just have to:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于每种类型的字符串，我们只需要：
- en: create a type (e.g. `String100`)
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个类型（例如 `String100`）
- en: an implementation of `IWrappedString` for that type
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为该类型实现 `IWrappedString`
- en: and a public constructor (e.g. `string100`) for that type.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及该类型的公共构造函数（例如 `string100`）。
- en: (In the sample above I have also thrown in a useful `convertTo` to convert from
    one type to another.)
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: （在上面的示例中，我还添加了一个有用的 `convertTo` 函数，用于将一个类型转换为另一个类型。）
- en: The type is a simple wrapped type as we have seen before.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 该类型是一个简单的包装类型，就像我们以前看到的那样。
- en: 'The implementation of the `Value` method of the IWrappedString could have been
    written using multiple lines, like this:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: IWrappedString 的 `Value` 方法的实现可以使用多行写成，就像这样：
- en: '[PRE76]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'But I chose to use a one liner shortcut:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 但我选择使用一个一行代码的快捷方式：
- en: '[PRE77]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The constructor function is also very simple. The canonicalize function is `singleLineTrimmed`,
    the validator function checks the length, and the constructor is the `String100`
    function (the function associated with the single case, not to be confused with
    the type of the same name).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数也非常简单。规范化函数是 `singleLineTrimmed`，验证器函数检查长度，并且构造函数是 `String100` 函数（与相同名称的类型不要混淆）。
- en: '[PRE78]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: If you want to have other types with different constraints, you can easily add
    them. For example you might want to have a `Text1000` type that supports multiple
    lines and embedded tabs and is not trimmed.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要具有不同约束的其他类型，你可以很容易地添加它们。例如，您可能想要一个支持多行和嵌入制表符且不被修剪的 `Text1000` 类型。
- en: '[PRE79]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Playing with the WrappedString module
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 WrappedString 模块玩耍
- en: 'We can now play with the module interactively to see how it works:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以交互式地玩弄这个模块，看看它是如何工作的：
- en: '[PRE80]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: When we need to interact with types such as maps that use raw strings, it is
    easy to compose new helper functions.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要与使用原始字符串的地图等类型进行交互时，很容易组合新的辅助函数。
- en: 'For example, here are some helpers to work with maps:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一些用于处理地图的辅助函数：
- en: '[PRE81]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'And here is how these helpers might be used in practice:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这些辅助函数在实践中可能如何使用：
- en: '[PRE82]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: So overall, this "WrappedString" module allows us to create nicely typed strings
    without interfering too much. Now let's use it in a real situation.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说，这个 "WrappedString" 模块允许我们创建漂亮的类型化字符串而不会干扰太多。现在让我们在实际情况中使用它。
- en: Using the new string types in the domain
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在领域中使用新的字符串类型
- en: Now we have our types, we can change the definition of the `PersonalName` type
    to use them.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的类型，我们可以更改 `PersonalName` 类型的定义以使用它们。
- en: '[PRE83]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We have created a module for the type and added a creation function that converts
    a pair of strings into a `PersonalName`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为该类型创建了一个模块，并添加了一个创建函数，将一对字符串转换为 `PersonalName`。
- en: Note that we have to decide what to do if *either* of the input strings are
    invalid. Again, we cannot postpone the issue till later, we have to deal with
    it at construction time.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须决定如果 *任何* 输入字符串无效时该怎么办。同样，我们不能推迟到以后处理此问题，我们必须在构造时处理它。
- en: In this case we use the simple approach of creating an option type with None
    to indicate failure.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用简单的方法创建一个选项类型，使用 None 表示失败。
- en: 'Here it is in use:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里是它的使用方法：
- en: '[PRE84]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We can also provide additional helper functions in the module.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在模块中提供额外的辅助函数。
- en: Let's say, for example, that we want to create a `fullname` function that will
    return the first and last names joined together.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，我们想创建一个 `fullname` 函数，它将返回名字和姓氏连接在一起。
- en: Again, more decisions to make.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，需要做更多的决定。
- en: Should we return a raw string or a wrapped string? The advantage of the latter
    is that the callers know exactly how long the string will be, and it will be compatible
    with other similar types.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该返回原始字符串还是包装字符串？后者的优点是调用者确切地知道字符串的长度，它将与其他类似类型兼容。
- en: If we do return a wrapped string (say a `String100`), then how do we handle
    the the case when the combined length is too long? (It could be up to 151 chars,
    based on the length of the first and last name types.). We could either return
    an option, or force a truncation if the combined length is too long.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here's code that demonstrates all three options.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Which particular approach you take to implementing `fullName` is up to you.
    But it demonstrates a key point about this style of type-oriented design: these
    decisions have to be taken *up front*, when creating the code. You cannot postpone
    them till later.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: This can be very annoying at times, but overall I think it is a good thing.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the email address and zip code types
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use this WrappedString module to reimplement the `EmailAddress` and `ZipCode`
    types.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Other uses of wrapped strings
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This approach to wrapping strings can also be used for other scenarios where
    you don't want to mix string types together accidentally.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: One case that leaps to mind is ensuring safe quoting and unquoting of strings
    in web applications.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say that you want to output a string to HTML. Should the
    string be escaped or not?
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: If it is already escaped, you want to leave it alone but if it is not, you do
    want to escape it.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: This can be a tricky problem. Joel Spolsky discusses using a naming convention
    [here](http://www.joelonsoftware.com/articles/Wrong.html), but of course, in F#,
    we want a type-based solution instead.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: A type-based solution will probably use a type for "safe" (already escaped)
    HTML strings (`HtmlString` say), and one for safe Javascript strings (`JsString`),
    one for safe SQL strings (`SqlString`), etc. Then these strings can be mixed and
    matched safely without accidentally causing security issues.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: I won't create a solution here (and you will probably be using something like
    Razor anyway), but if you are interested you can read about a [Haskell approach
    here](http://blog.moertel.com/articles/2006/10/18/a-type-based-solution-to-the-strings-problem)
    and a [port of that to F#](http://stevegilham.blogspot.co.uk/2011/12/approximate-type-based-solution-to.html).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Update
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many people have asked for more information on how to ensure that constrained
    types such as `EmailAddress` are only created through a special constructor that
    does the validation. So I have created a [gist here](https://gist.github.com/swlaschin/54cfff886669ccab895a)
    that has some detailed examples of other ways of doing it.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: Non-string types
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Designing with types: Non-string types'
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this series we've seen a lot of uses of single case discriminated unions
    to wrap strings.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: There is no reason why you cannot use this technique with other primitive types,
    such as numbers and dates. Let's look a few examples.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Single case unions
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many cases, we want to avoid accidentally mixing up different kinds of integers.
    Two domain objects may have the same representation (using integers) but they
    should never be confused.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: For example, you may have an `OrderId` and a `CustomerId`, both of which are
    stored as ints. But they are not *really* ints. You cannot add 42 to a `CustomerId`,
    for example. And `CustomerId(42)` is not equal to `OrderId(42)`. In fact, they
    should not even be allowed to be compared at all.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能有一个`OrderId`和一个`CustomerId`，它们都存储为整数。但它们并不是*真正的*整数。例如，你不能将 42 添加到`CustomerId`，而`CustomerId(42)`也不等于`OrderId(42)`。事实上，它们甚至不应该被允许进行比较。
- en: Types to the rescue, of course.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 类型当然可以帮上忙。
- en: '[PRE87]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Similarly, you might want avoid mixing up semantically different date values
    by wrapping them in a type. (`DateTimeKind` is an attempt at this, but not always
    reliable.)
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你可能希望通过将语义上不同的日期值包装在类型中来避免混淆。(`DateTimeKind`是对此的一种尝试，但不总是可靠的。)
- en: '[PRE88]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: With these types we can ensure that we always pass the right kind of datetime
    as parameters. Plus, it acts as documentation as well.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些类型，我们可以确保我们始终传递正确类型的日期作为参数。此外，它也起到了文档的作用。
- en: '[PRE89]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Constraints on integers
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数的约束
- en: Just as we had validation and constraints on types such as `String50` and `ZipCode`,
    we can use the same approach when we need to have constraints on integers.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在`String50`和`ZipCode`等类型上有验证和约束一样，当我们需要对整数进行约束时，我们可以使用相同的方法。
- en: For example, an inventory management system or a shopping cart may require that
    certain types of number are always positive. You might ensure this by creating
    a `NonNegativeInt` type.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，库存管理系统或购物车可能要求某些类型的数字始终为正。你可以通过创建一个`NonNegativeInt`类型来确保这一点。
- en: '[PRE90]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Embedding business rules in the type
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在类型中嵌入业务规则
- en: Just as we wondered earlier whether first names could ever be 64K characters
    long, can you really add 999999 items to your shopping cart?
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前想知道名字是否能够有 64K 个字符长一样，你真的能将 999999 个项目添加到购物车中吗？
- en: '![State transition diagram: Package Delivery](AddToCart.png)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![状态转换图：包裹送货](AddToCart.png)'
- en: Is it worth trying to avoid this issue by using constrained types? Let's look
    at some real code.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用约束类型来避免此问题是否值得一试？让我们看一些真实的代码。
- en: Here is a very simple shopping cart manager using a standard `int` type for
    the quantity. The quantity is incremented or decremented when the related buttons
    are clicked. Can you find the obvious bug?
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的购物车管理器，使用标准的`int`类型作为数量。当相关按钮被点击时，数量会增加或减少。你能找到明显的错误吗？
- en: '[PRE91]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: If you can't quickly find the bug, perhaps you should consider making any constraints
    more explicit.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法快速找到错误，也许你应该考虑使任何约束更加明确。
- en: 'Here is the same simple shopping cart manager using a typed quantity instead.
    Can you find the bug now? (Tip: paste the code into a F# script file and run it)'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这是同一个简单的购物车管理器，现在使用了一个带类型的数量。现在你能找到错误了吗？（提示：将代码粘贴到 F# 脚本文件中运行）
- en: '[PRE92]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: You might think this is overkill for such a trivial problem. But if you want
    to avoid being in the DailyWTF, it might be worth considering.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这对于这样一个微不足道的问题来说有些过度。但如果你想要避免成为 DailyWTF 的一部分，也许考虑一下也是值得的。
- en: Constraints on dates
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期的约束
- en: Not all systems can handle all possible dates. Some systems can only store dates
    going back to 1/1/1980, and some systems can only go into the future up to 2038
    (I like to use 1/1/2038 as a max date to avoid US/UK issues with month/day order).
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有系统都能处理所有可能的日期。一些系统只能存储从 1980 年 1 月 1 日开始的日期，而一些系统则只能向未来延伸到 2038 年（我喜欢使用
    2038 年 1 月 1 日作为最大日期，以避免美国/英国日期顺序的问题）。
- en: As with integers, it might be useful to have constraints on the valid dates
    built into the type, so that any out of bound issues are dealt with at construction
    time rather than later on.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 与整数一样，将有效日期的约束内置到类型中可能是有用的，这样任何超出范围的问题都将在构造时处理而不是以后。
- en: '[PRE93]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Union types vs. units of measure
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合类型 vs. 计量单位
- en: 'You might be asking at this point: What about [units of measure](units-of-measure.html)?
    Aren''t they meant to be used for this purpose?'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在这一点上问：[计量单位](units-of-measure.html)呢？它们不是应该用于此目的吗？
- en: Yes and no. Units of measure can indeed be used to avoid mixing up numeric values
    of different type, and are much more powerful than the single case unions we've
    been using.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 是的也不是。计量单位确实可以用于避免混淆不同类型的数值，并且比我们一直使用的单一情况联合更加强大。
- en: On the other hand, units of measure are not encapsulated and cannot have constraints.
    Anyone can create a int with unit of measure `<kg>` say, and there is no min or
    max value.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，计量单位不是封装的，并且不能有约束。任何人都可以创建一个带有单位`<kg>`的整数，而且没有最小值或最大值。
- en: In many cases, both approaches will work fine. For example, there are many parts
    of the .NET library that use timeouts, but sometimes the timeouts are set in seconds,
    and sometimes in milliseconds. I often have trouble remembering which is which.
    I definitely don't want to accidentally use a 1000 second timeout when I really
    meant a 1000 millisecond timeout.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，这两种方法都能很好地工作。例如，.NET库中有许多部分使用超时，但有时超时是以秒为单位设置的，有时是以毫秒为单位设置的。我经常记不住哪个是哪个。我绝对不想在我真正想要的是1000毫秒超时时意外使用1000秒超时。
- en: To avoid this scenario, I often like to create separate types for seconds and
    milliseconds.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我经常喜欢为秒和毫秒创建单独的类型。
- en: 'Here''s a type based approach using single case unions:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个基于类型的方法，使用单例联合：
- en: '[PRE94]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'And here''s the same thing using units of measure:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用单位量的相同示例：
- en: '[PRE95]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Which approach is better?
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法更好？
- en: If you are doing lots of arithmetic on them (adding, multiplying, etc) then
    the units of measure approach is much more convenient, but otherwise there is
    not much to choose between them.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对它们进行大量的算术运算（加法、乘法等），那么单位量的方法更加方便，但除此之外，它们之间没有太大的区别。
- en: 'Designing with types: Conclusion'
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型进行设计：结论
- en: 'Designing with types: Conclusion'
  id: totrans-539
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型进行设计：结论
- en: 'In this series, we''ve looked at some of the ways we can use types as part
    of the design process, including:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系列中，我们已经看过一些使用类型作为设计过程的一部分的方法，包括：
- en: Breaking large structures down into small "atomic" components.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将大型结构分解为小的“原子”组件。
- en: Using single case unions to add semantic meaning and validation to key domain
    types such `EmailAddress` and `ZipCode`.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单例联合来为关键领域类型（如`EmailAddress`和`ZipCode`）添加语义含义和验证。
- en: Ensuring that the type system can only represent valid data ("making illegal
    states unrepresentable").
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保类型系统只能表示有效数据（“使非法状态无法表示”）。
- en: Using types as an analysis tool to uncover hidden requirements
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型作为分析工具来揭示隐藏的需求
- en: Replacing flags and enums with simple state machines
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用简单状态机替换标志和枚举
- en: Replacing primitive strings with types that guarantee various constraints
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用保证各种约束的类型替换原始字符串
- en: For this final post, let's see them all applied together.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这篇最终文章，让我们看看它们全部应用在一起的效果。
- en: The "before" code
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “之前”的代码
- en: 'Here''s the original example we started off with in the [first post](designing-with-types-intro.html)
    in the series:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在系列中的[第一篇文章](designing-with-types-intro.html)中开始的原始示例：
- en: '[PRE96]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: And how does that compare to the final result after applying all the techniques
    above?
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，与上述所有技术应用后的最终结果相比如何？
- en: The "after" code
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “之后”的代码
- en: First, let's start with the types that are not application specific. These types
    could probably be reused in many applications.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从不是应用程序特定的类型开始。这些类型可能在许多应用程序中被重复使用。
- en: '[PRE97]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: And now the application specific types.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是应用程序特定类型的时候了。
- en: '[PRE98]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Conclusion
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: Phew! The new code is much, much longer than the original code. Granted, it
    has a lot of supporting functions that were not needed in the original version,
    but even so it seems like a lot of extra work. So was it worth it?
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！新代码比原始代码长得多得多。当然，它有许多在原始版本中不需要的支持函数，但即便如此，看起来仍然需要做很多额外的工作。那么这样做值得吗？
- en: 'I think the answer is yes. Here are some of the reasons why:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为答案是肯定的。以下是一些原因：
- en: '**The new code is more explicit**'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**新代码更加明确**'
- en: If we look at the original example, there was no atomicity between fields, no
    validation rules, no length constraints, nothing to stop you updating flags in
    the wrong order, and so on.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看原始示例，字段之间没有原子性，没有验证规则，没有长度约束，没有阻止你以错误的顺序更新标志的任何内容，等等。
- en: The data structure was "dumb" and all the business rules were implicit in the
    application code. Chances are that the application would have lots of subtle bugs
    that might not even show up in unit tests. (*Are you sure the application reset
    the `IsEmailVerified` flag to false in every place the email address was updated?*)
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是“愚蠢的”，所有的业务规则都隐含在应用程序代码中。应用程序很可能会有许多微妙的错误，甚至可能不会在单元测试中显示出来。（*你确定应用程序在更新电子邮件地址的每个地方都将`IsEmailVerified`标志重置为false吗？*）
- en: On the other hand, the new code is extremely explicit about every little detail.
    If I stripped away everything but the types themselves, you would have a very
    good idea of what the business rules and domain constraints were.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，新代码对每一个细节都非常明确。如果我除去除了类型本身以外的所有内容，你会对业务规则和领域约束有一个很好的了解。
- en: '**The new code won''t let you postpone error handling**'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '**新代码不会让你推迟错误处理**'
- en: Writing code that works with the new types means that you are forced to handle
    every possible thing that could go wrong, from dealing with a name that is too
    long, to failing to supply a contact method. And you have to do this up front
    at construction time. You can't postpone it till later.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 编写与新类型配套的代码意味着你被迫处理可能出错的每一件事情，从处理太长的名称到未提供联系方式。而且你必须在构建时立即处理。你不能推迟到以后再处理。
- en: Writing such error handling code can be annoying and tedious, but on the other
    hand, it pretty much writes itself. There is really only one way to write code
    that actually compiles with these types.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这样的错误处理代码可能会让人感到烦躁和乏味，但另一方面，它几乎可以自己编写。实际上只有一种方法可以编写与这些类型实际编译的代码。
- en: '**The new code is more likely to be correct**'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '**新代码更有可能是正确的**'
- en: The *huge* benefit of the new code is that it is probably bug free. Without
    even writing any unit tests, I can be quite confident that a first name will never
    be truncated when written to a `varchar(50)` in a database, and that I can never
    accidentally send out a verification email twice.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码的*巨大*好处是它可能没有错误。即使我没有编写任何单元测试，我也可以非常有信心，在将一个名字写入数据库的`varchar(50)`时，名字永远不会被截断，而且我永远不会意外地发送两次验证电子邮件。
- en: And in terms of the code itself, many of the things that you as a developer
    have to remember to deal with (or forget to deal with) are completely absent.
    No null checks, no casting, no worrying about what the default should be in a
    `switch` statement. And if you like to use cyclomatic complexity as a code quality
    metric, you might note that there are only three `if` statements in the entire
    350 odd lines.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 至于代码本身，作为开发者，你必须记住要处理的许多事情（或者忘记要处理的事情），完全不存在。没有空值检查，没有类型转换，不用担心在`switch`语句中的默认值应该是什么。如果你喜欢使用圈复杂度作为代码质量指标，你可能会注意到整个
    350 行代码中只有三个`if`语句。
- en: '**A word of warning...**'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个警告...**'
- en: Finally, beware! Getting comfortable with this style of type-based design will
    have an insidious effect on you. You will start to develop paranoia whenever you
    see code that isn't typed strictly enough. (*How long should an email address
    be, exactly?*) and you will be unable to write the simplest python script without
    getting anxious. When this happens, you will have been fully inducted into the
    cult. Welcome!
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意！逐渐习惯这种基于类型的设计风格将对你产生潜在的影响。当你看到代码不够严格的时候，你会开始产生偏执狂。(*一个电子邮件地址应该有多长？*)，你甚至写不出最简单的
    Python 脚本而感到焦虑。当这种情况发生时，你已经完全加入了这个“教派”。欢迎！
- en: '*If you liked this series, here is a slide deck that covers many of the same
    topics. There is [a video as well (here)](http://fsharpforfunandprofit.com/ddd/)*'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你喜欢这个系列，这里有一个幻灯片演示涵盖了许多相同的主题。[这里还有一个视频（在这里）](http://fsharpforfunandprofit.com/ddd/)*'
- en: '[//www.slideshare.net/slideshow/embed_code/32418451](//www.slideshare.net/slideshow/embed_code/32418451)'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '[//www.slideshare.net/slideshow/embed_code/32418451](//www.slideshare.net/slideshow/embed_code/32418451)'
- en: '**[Domain Driven Design with the F# type System -- F#unctional Londoners 2014](https://www.slideshare.net/ScottWlaschin/domain-driven-design-with-the-f-type-system-functional-londoners-2014
    "Domain Driven Design with the F# type System -- F#unctional Londoners 2014")**
    from **[my slideshare page](http://www.slideshare.net/ScottWlaschin)**'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '**[使用 F# 类型系统进行领域驱动设计 -- F#unctional Londoners 2014](https://www.slideshare.net/ScottWlaschin/domain-driven-design-with-the-f-type-system-functional-londoners-2014
    "使用 F# 类型系统进行领域驱动设计 -- F#unctional Londoners 2014")**，来自**[我的 slideshare 页面](http://www.slideshare.net/ScottWlaschin)**'
