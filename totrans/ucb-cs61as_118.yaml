- en: Infinite Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen how to support the illusion of manipulating a stream as a complete
    sequence, when in actuality we only compute as much of the stream as we need.
    We can exploit this technique to represent sequences efficiently as streams, even
    if the sequences are very long. But more importantly, we can use streams to represent
    sequences that are infinitely long. For instance, suppose we define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then `integers` represents the stream of all positive integers. More specifically,
    the `stream-car` of `integers` is 1 and the `stream-cdr` of `integers` is a promise
    equivalent to `(integers-starting-from 2)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `integers`, we can define other infinite streams, such as the stream
    of integers that are not divisible by 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then find integers not divisible by 7 simply by accessing elements of
    this stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Stream Procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way we've been defining streams up until now is very similar to the way
    we define lists. Now we're going to take a more "streamy" approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take advantage of delayed evaluation to implicitly define streams. For
    example, we can define an infinite stream of all ones like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This works much like the definition of a recursive procedure: `ones` is a pair
    whose `car` is `1` and whose `cdr` is a promise to evaluate `ones`. Evaluating
    the `cdr` gives us again a `1` and a promise to evaluate `ones`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define a stream procedure `add-streams`, which produces the elementwise
    sum of two streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For example, `(add-streams ones ones)` would produce a stream of all twos.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can redefine then define `integers` implicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This defines `integers` to be a stream whose `stream-car` is 1 and whose `stream-cdr`
    is the sum of `ones` and `integers`. Thus, the second element of `integers` is
    1 plus the first element of `integers`, or 2; the third element of integers is
    1 plus the second element of integers, or 3; and so on. This definition works
    because, at any point, enough of the integers stream has been generated so that
    we can feed it back into the definition to produce the next integer.
  prefs: []
  type: TYPE_NORMAL
- en: Note on `stream-map`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note that in the example above, we called `stream-map` with two streams. Previously,
    we used stream-map with just one stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `stream-map` with any number of streams, given that the procedure
    you give has the corresponding number of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, the actual definition of `stream-map` is slightly different, but
    don't worry about it for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define the Fibonacci sequence in the same style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This definition says that `fibs` is a stream beginning with 0 and 1, such that
    the rest of the stream can be generated by adding `fibs` to itself shifted by
    one place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another stream operation that we can use is `scale-stream`. It takes in two
    arguments—a stream of integers and an integer—and multiplies all elements in the
    stream by the integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now define a stream of all the powers of 2 like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define the infinite stream of primes in a different, implicit way now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This might seem fairly straightforward—we start with the first prime, 2, and
    we then `cons-stream` the rest of the integers that are prime to it. However,
    the way that `prime?` is defined makes this problem a little more subtle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We check if a number is prime by seeing whether it is divisible by any prime
    (not just any integer!) less than √(n):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is a recursive definition (much like you saw in trees!) since `primes`
    is defined in terms of the `prime?` predicate, which itself uses the `primes`
    stream. The reason this procedure works is that, at any point, enough of the `primes`
    stream has been generated to test the primality of the numbers we need to check
    next. That is, for every `n` we test for primality, either `n` is not prime (in
    which case there is a prime already generated that divides it) or `n` is prime
    (in which case there is a prime already generated -- i.e., a prime less than `n`
    -- that is greater than √(`n`))
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, you learned:'
  prefs: []
  type: TYPE_NORMAL
- en: What infinite streams are!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some cool stuff we can make with them
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
