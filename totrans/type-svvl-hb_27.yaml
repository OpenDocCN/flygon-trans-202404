- en: JSXとECMAScriptの違い
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://typescriptbook.jp/reference/jsx](https://typescriptbook.jp/reference/jsx)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSX（JavaScript XML）は、コンポーネント指向のJavaScriptライブラリやフレームワーク（特にReact）で一般的に採用されている、JavaScriptの拡張構文です。JSXを用いると、JavaScriptのコード内にHTMLタグのような構文が埋め込み可能となり、より直感的かつ読みやすい形でUIのコードを表現することができます。それによって、開発者のコーディング体験や開発、デバッグの効率が上がります。
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptの文法はECMAScriptという言語仕様で規定されています。一方、JSXはJavaScriptの構文を独自に拡張した言語です。そのため、JSXはECMAScriptの言語仕様に盛り込まれていません。ブラウザがJavaScriptエンジンを実装する場合は、ECMAScript(標準)に準拠するため、ブラウザで直接JSXを解釈し、実行することができない現状があります。この問題を解消するためには、JSXをブラウザが認識できるJavaScriptに変換する、いわゆるトランスパイルという過程が必要となります。このトランスパイル作業を助けるツールとして、BabelやTypeScriptコンパイラーが使われます。
  prefs: []
  type: TYPE_NORMAL
- en: JSX構文とHTML構文の違い[​](#jsx構文とhtml構文の違い "JSX構文とHTML構文の違い への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 初見では異なると気づきにくいかもしれませんが、実はJSXとHTMLはまったく同じではありません。構文のレベルにおいてJSXとHTMLの間には複数の違いが存在します。一例を挙げると、属性名の表記方法や、スタイルの指定方法、自己終了タグの書き方などが異なります。これらの詳細については後程の「属性」セクションでより詳しく説明します。覚えておくべき重要なポイントとしては、JSXがHTMLとJavaScriptのハイブリッドであるため、両者の規則や慣例を調和させる形で設計されているという点です。
  prefs: []
  type: TYPE_NORMAL
- en: JSX構文[​](#jsx構文 "JSX構文 への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 要素[​](#要素 "要素 への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSXでもっとも一般的な形式は、ネスト可能な要素（タグ）を使ってコンポーネントを表現するものです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 入れ子の要素[​](#入れ子の要素 "入れ子の要素 への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSX要素はHTMLのようにネストすることができます。たとえば、`div`要素内に2つの`br`要素がネストされている状況を考えてみましょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: これらは簡単な例ですが、属性や子要素を追加してより複雑なコンポーネントを表現することも可能です。
  prefs: []
  type: TYPE_NORMAL
- en: テキスト要素[​](#テキスト要素 "テキスト要素 への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSX内では、要素に直接テキストを書くことができます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 上記のように、要素の中に直接テキストを書くと、そのテキストはそのままの形で出力されます。
  prefs: []
  type: TYPE_NORMAL
- en: 空白と要素[​](#空白と要素 "空白と要素 への直接リンク")
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: JSXでは、要素間のスペースは自動的に無視されます。たとえば、
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 上記のコードは「This is a**pen**.」として「a」と「pen」の分かち書きがない状態でレンダリングされてしまいます。
  prefs: []
  type: TYPE_NORMAL
- en: これを回避するには、文字列をJavaScriptの式として書くことです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: こうすると、正しく「This is a pen.」としてレンダリングされます。
  prefs: []
  type: TYPE_NORMAL
- en: 属性[​](#属性 "属性 への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSX属性の名前は、JavaScriptの命名規則に従いcamelCaseで記述することが推奨されています。この命名規則は、HTML内のアトリビュートとは異なる点に注意が必要です。
  prefs: []
  type: TYPE_NORMAL
- en: 標準HTML属性[​](#標準html属性 "標準HTML属性 への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSXでは、HTML属性と同じように要素に属性を与えることができます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: ただし、`class`属性はJavaScriptの予約語であるため、代わりに`className`を使用します。たとえば、次のコードでは`h1`要素に`className`属性を適用しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: JSXで用いる属性は、JavaScriptのDOMのプロパティ名です。したがって、いくつかのHTML属性はJSXでは異なる名前を持ちます。次の表は、いくつかの一般的なHTML属性と対応するJSX属性名を示しています。
  prefs: []
  type: TYPE_NORMAL
- en: '| HTML | JSX |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `class` | `className` |'
  prefs: []
  type: TYPE_TB
- en: '| `tabindex` | `tabIndex` |'
  prefs: []
  type: TYPE_TB
- en: '| `for` | `htmlFor` |'
  prefs: []
  type: TYPE_TB
- en: '| `colspan` | `colSpan` |'
  prefs: []
  type: TYPE_TB
- en: '| `maxlength` | `maxLength` |'
  prefs: []
  type: TYPE_TB
- en: '| `cellpadding` | `cellPadding` |'
  prefs: []
  type: TYPE_TB
- en: '| `cellspacing` | `cellSpacing` |'
  prefs: []
  type: TYPE_TB
- en: '| `rowspan` | `rowSpan` |'
  prefs: []
  type: TYPE_TB
- en: スタイル属性[​](#スタイル属性 "スタイル属性 への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTMLでは、スタイル属性は一般的に文字列です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 一方、JSXではスタイル属性はオブジェクトでなければなりません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 真偽属性[​](#真偽属性 "真偽属性 への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 真偽属性は要素に特定の特性を指定します。たとえば、input要素には"disabled"というboolean型の属性があり、その値に真を指定するとinput要素は無効になります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 属性の値として`{true}`を付けて明示的に指定することもできます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: しかし、一般的には属性値がtrueの場合、値の部分を省略することが推奨されます。このように記述すると、コードが短くシンプルになるためです。したがって、上記の例のように属性名のみを指定することで、その属性を有効にすることができます。
  prefs: []
  type: TYPE_NORMAL
- en: 式[​](#式 "式 への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSX内ではJavaScriptの式を埋め込むことが可能です。これにより、動的な値をJSX内に簡単に導入することができます。
  prefs: []
  type: TYPE_NORMAL
- en: 基本的な式[​](#基本的な式 "基本的な式 への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScriptの式をJSX内部に埋め込むためには、波カッコ`{}`を使います。次の例では、変数`name`の値を`<h1>`要素内に埋め込んでいます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: ここでは、JavaScriptの変数を埋め込んでいますが、式としての評価結果が挿入されるので、JavaScriptの演算やメソッドの呼び出しも可能です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 条件式[​](#条件式 "条件式 への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScriptのif文は式ではなく文であるため、JSXの式の中に直接書くことはできません。条件式が必要な場合には三項演算子を用います。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'このように、三項演算子`条件式 ? 真の場合の値 : 偽の場合の値`を使うことで、JSX内で条件によって表示を切り替えることが可能です。'
  prefs: []
  type: TYPE_NORMAL
- en: 短絡評価[​](#短絡評価 "短絡評価 への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScriptの論理演算子を使用して、短絡評価を行うことも可能です。これを使用すると、特定の条件下でのみ要素を表示したり、デフォルトの値を提供したりします。
  prefs: []
  type: TYPE_NORMAL
- en: 論理AND演算子(`&&`)による短絡評価[​](#論理and演算子による短絡評価 "論理and演算子による短絡評価 への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 論理AND演算子`&&`は、最初の要素が`false`またはfalsyな値（`false`、`null`、`undefined`、`""`、`0`、`NaN`）の場合その値をそのまま返し、それ以外の場合には2番目の値を返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: この例では、`isLoggedIn`がtruthyの場合にのみ、`<h1>Welcome back!</h1>`が表示されます。
  prefs: []
  type: TYPE_NORMAL
- en: 論理OR演算子(`||`)による短絡評価[​](#論理or演算子による短絡評価 "論理or演算子による短絡評価 への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 論理OR演算子 `||`は、最初のオペランドがtruthyな値の場合にその値をそのまま返し、それ以外の場合には2番目の値を返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: この例では、`isLoggedIn`がfalsyな値（`undefined`、`null`、`""`、`0`、`NaN`）の場合にのみ、`<h1>Please
    sign up.</h1>`が表示されます。
  prefs: []
  type: TYPE_NORMAL
- en: Null合体演算子(`??`)による短絡評価[​](#null合体演算子による短絡評価 "null合体演算子による短絡評価 への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Null合体演算子(nullish coalescing operator)`??`は、最初のオペランドが`null`または`undefined`の場合にのみ2番目の値を返します。そのため、最初のオペランドが`false`、`0`、`NaN`、空文字列であっても、その値が保持されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: この例では、`input.name`が`null`または`undefined`の場合にのみ、`<p>No input provided.</p>`が表示されます。
  prefs: []
  type: TYPE_NORMAL
- en: ループ(反復処理)[​](#ループ反復処理 "ループ(反復処理) への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScriptの`for-of`ループなど、JSX内では文を直接使用することができないため、配列の反復処理を行う際は`Array.prototype.map`関数のような式を使用します。式とは、値を返すコードの片段のことで、それに対して文は値を生成しません。JSXは基本的には式ベースのシンタックスですので、式が使われます。
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.map`関数は配列の各要素に対して関数を適用し、その結果で新たな配列を作成します。これを利用して、一連の要素を作ることができます。次にサンプルコードを示します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: この例では、`numbers`という配列の各要素に対して関数が適用され、その結果から新たな`<li>`要素で構成された配列が作成されます。そして、その配列は`<ul>`要素に展開され`list`に代入されます。
  prefs: []
  type: TYPE_NORMAL
- en: また、Reactでは配列内の要素に一意な`key`プロパティを追加することが推奨されます。これは、ReactがDOMの変更を効率的に追跡するために使用されます。上記の例では、`key`として数値を文字列に変換したものを使用しています。
  prefs: []
  type: TYPE_NORMAL
- en: 自己終了タグ[​](#自己終了タグ "自己終了タグ への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSXでは、XMLのように自己終了タグ(self-closing tags)が使用できます。これは、開始タグと終了タグの間に何も内容を持たない要素について使用します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: その要素が内容を持たない場合でも、`<img></img>`のように書くことは文法的には可能です。しかし、一般的には`<img />`のように自己終了タグを書くことが推奨されます。これは可読性の観点から、タグが内容を持たないことを明示するためです。
  prefs: []
  type: TYPE_NORMAL
- en: フラグメント[​](#フラグメント "フラグメント への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 一般的にJSX要素は、ひとつの親要素内にすべての子要素をネストしなければなりません。これは、JSXが最終的にひとつのルートノードを返すことを要求するためです。しかし、この要求はしばしばReactのDOM構造に余計な要素を追加することを強制してしまいます。これを解決するためにReactが提供する機能が「フラグメント」です。
  prefs: []
  type: TYPE_NORMAL
- en: フラグメントを使うと、ひとつの親要素なしに、複数の要素を同時に返すことができます。これにより、無駄なDOMノードの生成を防ぎつつ、構造をくずさずに複数の要素をレンダリングすることができます。
  prefs: []
  type: TYPE_NORMAL
- en: JSXでのフラグメントの使用[​](#jsxでのフラグメントの使用 "JSXでのフラグメントの使用 への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: フラグメントは`<React.Fragment>`タグを使って明示的に表現することができます。次の例では、`h1`と`h2`要素がフラグメント内にまとめられています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: ただ、より簡潔にフラグメントを表現するために`<>...</>`というショートハンド（短縮形）がよく使われます。次の例では、`<React.Fragment>`タグが`<>...</>`に置き換えられています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: いずれの形式でも、フラグメントを使うことで`h1`と`h2`要素は同一階層に配置され、それらをラップする余計なHTML要素を追加せずにレンダリングされます。フラグメントは、Reactアプリケーションのレンダリングパフォーマンスを持続的に向上させるツールとなります。
  prefs: []
  type: TYPE_NORMAL
- en: JSX内のコメント[​](#jsx内のコメント "JSX内のコメント への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: コメントはコードの読み易さを向上させる重要な要素です。しかし、JSX内のコメントは少し特殊で、明示的にJavaScriptのブロック、つまり波カッコ `{}`
    内に書く必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: 一行コメント[​](#一行コメント "一行コメント への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSX内では一行コメントを書く方法は次の通りです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: このように、コメントは `{/* */}` の形式で書かれます。この書き方により、コメントはブラウザに表示されず、ただ開発者を支援するために存在します。
  prefs: []
  type: TYPE_NORMAL
- en: ジェネリクス[​](#ジェネリクス "ジェネリクス への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ジェネリクスを活用することで、一度定義したコンポーネントや関数を、各種の型に対応可能な形で再利用できます。ここではジェネリクス型を用いたReactコンポーネントの定義とその利用について、詳しく見ていきましょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[## 📄️ ジェネリクス'
  prefs: []
  type: TYPE_NORMAL
- en: 型の安全性とコードの共通化の両立は難しいものです。あらゆる型で同じコードを使おうとすると、型の安全性が犠牲になります。逆に、型の安全性を重視しようとすると、同じようなコードを量産する必要が出てコードの共通化が達成しづらくなります。こうした問題を解決するために導入された言語機能がジェネリクスです。ジェネリクスを用いると、型の安全性とコードの共通化を両立することができます。](/reference/generics)
  prefs: []
  type: TYPE_NORMAL
- en: ジェネリックコンポーネントの定義[​](#ジェネリックコンポーネントの定義 "ジェネリックコンポーネントの定義 への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: まず初めに、型変数`T`を用いたコンポーネントを定義します。ここでは`ItemType`という名前で型を作り、それがプロパティ`prop`を介して型`T`を受け取るように設計します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 上記の`Item`という名前のコンポーネントには、ジェネリクス型を適用しています。そのため、あらゆる型を`prop`として受け取ることが可能になります。
  prefs: []
  type: TYPE_NORMAL
- en: 注目すべき点として、`<T>`の書き方について説明します。もしジェネリクスとして `<T>`だけを記述する場合、TypeScriptはそれがJSXのタグと混同してしまう可能性があります。これは、TypeScriptのパーサーが
    `<T>`と読み取ったとき、それがジェネリクス開始を示すものなのかJSX要素の開始を示すものなのかを特定するのが難しいためです。この混同を避けるためには、ジェネリクスの開始を示す
    `<T>`に `,`を追加し、`<T,>`と記述する必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: ジェネリックコンポーネントの利用[​](#ジェネリックコンポーネントの利用 "ジェネリックコンポーネントの利用 への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ここで、上記で定義したジェネリクス型のコンポーネントを利用してみます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`Item`コンポーネントに対して`string`という型引数を渡し、その`prop`プロパティとして`a`という文字列値を渡しています。これは問題ありません。しかし、次の行では、`Item`コンポーネントに対して`number`という型引数を渡しているのに、その`prop`プロパティとして`a`という文字列値を渡しています。これにより、TypeScriptは型エラーを発生させます。これで、型安全性が確保されていることが確認できます。'
  prefs: []
  type: TYPE_NORMAL
- en: JSXのベストプラクティス[​](#jsxのベストプラクティス "JSXのベストプラクティス への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSXにおけるベストプラクティスは、効果的で読みやすいコードを書くために役立ちます。次にいくつかの主要なベストプラクティスを示します。
  prefs: []
  type: TYPE_NORMAL
- en: コンポーネント名は常に大文字ではじめる[​](#コンポーネント名は常に大文字ではじめる "コンポーネント名は常に大文字ではじめる への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reactは小文字で始まるコンポーネントをDOMタグとして認識します。したがって、コンポーネント名は常に大文字ではじめることを推奨します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: マルチラインのJSXはカッコで囲む[​](#マルチラインのjsxはカッコで囲む "マルチラインのJSXはカッコで囲む への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 複数行に渡るJSXは可読性を上げるためにカッコで囲むことを推奨します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 自己終了タグを利用する[​](#自己終了タグを利用する "自己終了タグを利用する への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 通常、JSX要素は開始タグと終了タグの間に子要素を配置して記述します。しかし内容が空の場合、すなわち子要素を持たない場合、自己終了タグという短縮形を使用することができます。自己終了タグでは、開始タグと終了タグをひとつのタグにまとめることができます。
  prefs: []
  type: TYPE_NORMAL
- en: 次の2つの表現は同等です：
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 前者の例では、`<input></input>`という形で開始タグと終了タグを明示的に記述しています。一方、後者の例では、`<input />`という形で開始タグと終了タグをひとつにまとめた自己終了タグを利用しています。どちらの記述も完全に同じ動作をしますが、後者の形が簡潔であり一般的に好まれます。
  prefs: []
  type: TYPE_NORMAL
- en: '`true`の場合は真偽属性を省略する[​](#trueの場合は真偽属性を省略する "trueの場合は真偽属性を省略する への直接リンク")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSXでは、属性の値が`true`の場合、その属性名だけ記述することで属性の値を省略することが可能です。この書き方を真偽属性と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: 次の2つの表現は同等です：
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 前者の例では、`required`という属性に対して`{true}`（即ち真）を明示的に設定しています。一方、後者の例では、属性が真であることを示すために`required`という属性名だけを記述しています。どちらの記述も完全に同じ動作をしますが、後者の形が簡潔であり一般的に好まれます。
  prefs: []
  type: TYPE_NORMAL
- en: マップ関数内で一意の`key`プロパティを使用する[​](#マップ関数内で一意のkeyプロパティを使用する "マップ関数内で一意のkeyプロパティを使用する
    への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`map`関数を使用してリストを作成する際には、各要素に一意の`key`プロパティを付与することを推奨します。これによりReactは変更、追加、削除を効率的に適用できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: JSXとコンパイル[​](#jsxとコンパイル "JSXとコンパイル への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSXはJavaScriptの一部ではないため、ブラウザで直接実行することはできません。デフォルトでは、JSX構文はJavaScript構文にないものであり、そのまま実行してもブラウザは理解できません。そのため、JSXをJavaScriptにコンパイル（または変換）する必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: TypeScriptでは、こうしたJSXのコンパイル方法を指定するために、"jsx"という名前のフラグを `tsconfig.json` 内で設定します。このフラグには次の5つの値を設定することができます。
  prefs: []
  type: TYPE_NORMAL
- en: '"react"：この設定を選択すると、JSXはJavaScriptへと変換されます。そして、出力される.jsファイルでは、それぞれのJSX要素は対応する`React.createElement`呼び出しに変換されます。これはReactというライブラリが、JSXをどのように標準的なJavaScriptに変換するかを指定しています。'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"react-jsx"：元のJSX要素は`_jsx`呼び出しに変換され、出力された.jsファイルに含まれます。これにより、ある程度のパフォーマンスの向上が期待できます。'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"react-jsxdev"：こちらも元のJSX要素は`_jsx`呼び出しに変換されますが、このモードは開発環境でのみ使用することを目的としています。ここで生成される`_jsxの`呼び出しは、開発中のデバッグを容易にするような追加のランタイムチェックを含みます。'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"preserve"：このモードはJSXをそのままの形で出力ファイルに残します。つまり、元のJSX構文は変更されず、出力されるファイル拡張子は.jsxであることが期待されます。さらなる変換ステップ（たとえばBabel等のトランスパイラ）のためにJSXをそのまま保持する必要がある場合に使用します。'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '"react-native"：このオプションもJSXをそのままの形で出力します。ただし、出力するファイル拡張子は.jsのままであることが期待されます。これは主にReact
    Nativeの開発環境で使用されます。'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 上記の設定により、JSXの構文をどのようにJavaScriptにコンパイルするかを制御できます。そして、TypeScriptとJSXを一緒に使う際には、これらの設定が不可欠となります。
  prefs: []
  type: TYPE_NORMAL
- en: それぞれのフラグでどのようにコンパイルされるのか、次のサンプルコードのコンパイル結果を見てみましょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
