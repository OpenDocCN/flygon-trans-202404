["```\nPersonList x; \nPersonList y = x; // Copy constructor, not assignment\nPersonList z;\nz = x; // Assignment operator \n```", "```\nstruct Person {\n    //...\n};\n\nclass PersonList {\n  std::vector<Person> *personList_;\npublic:\n  PersonList() : personList_(new std::vector<Person>) {\n  }\n\n  ~PersonList() {\n    delete personList_;\n  }\n\n  // ... Methods to add / search list\n}; \n```", "```\nstruct Person {\n    //...\n};\n\nclass PersonList {\n    std::vector<Person> *personList_;\npublic:\n    PersonList() : personList_(new std::vector<Person>) {\n    }\n\n    PersonList(const PersonList &other) :\n            personList_(new std::vector<Person>)    {\n        personList_->insert(\n                personList_->end(), other.personList_->begin(),\n                other.personList_->end());\n    }\n\n    ~PersonList() {\n        delete personList_;\n    }\n\n    PersonList & operator=(const PersonList &other) {\n        // Don't forget to check if someone assigns an object to itself\n        if (&other != this) {\n            personList_->clear();\n            personList_->insert(\n                    personList_->end(), other.personList_->begin(),\n                    other.personList_->end());\n        }\n        return *this;\n    }\n\n    // ... Methods to add / search list\n}; \n```", "```\nclass PersonList {\n    std::vector<Person> *personList_;\n\nprivate:\n    PersonList(const PersonList &other) {}\n    PersonList & operator=(const PersonList &other) { return *this; }\n\npublic:\n    PersonList() : personList_(new std::vector<Person>) {\n    }\n\n    ~PersonList() {\n        delete personList_;\n    }\n    // ... Methods to add / search list\n}; \n```", "```\nclass PersonList {\n  // See class above for other methods, rule of three....\n\n  PersonList(PersonList &&other) {\n    // TODO\n  }\n\n  PersonList &operator=(PersonList &&other) {\n    if (&other != this) {\n      // TODO\n    }\n    return  *this\n  } \n```", "```\n// This is all good\nlet x = 8;\nlet y = x;\ny = 20;\nassert_eq!(x, 8); \n```", "```\nlet copyright = \"Copyright 2017 Acme Factory\".to_string();\nlet copyright2 = copyright.clone(); \n```", "```\nstruct Person {\n  name: String,\n  age: u8\n} \n```", "```\nlet person1 = Person { name: \"Tony\".to_string(), age: 38u8 };\nlet person2 = person1; \n```", "```\nprintln!(\"{}\", person1.name); // Error, use of a moved value \n```", "```\nstruct PersonList {\n    pub persons: Vec<Person>,\n} \n```", "```\nlet mut x = PersonList { persons: Vec::new(), };\nlet mut y = x;\n// x is not the owner any more...\nx.persons.push(Person{ name: \"Fred\".to_string(), age: 30u8} ); \n```", "```\nerror[E0382]: use of moved value: `*x.persons`\n   |\n10 | let mut y = x;\n   |     ----- value moved here\n11 | x.persons.push(Person{});\n   | ^^^^^^^^^ value used here after move\n   |\n   = note: move occurs because `x` has type `main::PersonList`, which does not implement the `Copy` trait \n```", "```\n#[derive(Copy)]\nstruct PersonKey {\n  id: u32,\n  age: u8,\n}\n\n// Alternatively...\n\nimpl Copy for PersonKey {}\n\nimpl Clone for PersonKey {\n  fn clone(&self) -> PersonKey {\n     *self\n  }\n} \n```", "```\n#[derive(Copy)]\nstruct Person {\n  name: String,\n  age: u8\n}\n// Compiler error! \n```", "```\n#[derive(Clone)]\nstruct Person {\n  name: String,\n  age: u8\n}\n...\nlet x = Person { /*...*/ };\nlet y = x.clone(); \n```", "```\n#[derive(Clone)]\nstruct PersonList {\n    pub persons: Box<Vec<Person>>,\n} \n```", "```\n//...\nlet mut x = PersonList { persons: Box::new(Vec::new()), };\nlet mut y = x.clone();\n// x and y are two independent lists now, not shared\nx.persons.push(Person{ name: \"Fred\".to_string(), age: 30} );\ny.persons.push(Person{ name: \"Mary\".to_string(), age: 24} ); \n```", "```\nconst bool result = fetch_files();\nif (result) {\n  process_files()\n}\nelse\n  print_error()\n  return false;\n\n// Now cleanup and return success\ncleanup_files();\nreturn true; \n```", "```\nstatic OSStatus\nSSLVerifySignedServerKeyExchange(\n   SSLContext *ctx, bool isRsa, SSLBuffer signedParams,\n   uint8_t *signature, UInt16 signatureLen) {\n  OSStatus        err;\n  //...\n\n  if ((err = SSLHashSHA1.update(&hashCtx, &serverRandom)) != 0)\n    goto fail;\n  if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)\n    goto fail;\n    goto fail;\n  if ((err = SSLHashSHA1.final(&hashCtx, &hashOut)) != 0)\n    goto fail;\n  //...\n\nfail:\n  SSLFreeBuffer(&signedHashes);\n  SSLFreeBuffer(&hashCtx);\n  return err;\n} \n```", "```\nlet mut x: i32 = do_something();\nif x == 200 {\n  // ...\n}\nelse\n  println!(\"Error\"); \n```", "```\nrustc 1.13.0-beta.1 (cbbeba430 2016-09-28)\nerror: expected `{`, found `println`\n  |\n8 |   println!(\"Error\");\n  |   ^^^^^^^\n  |\nhelp: try placing this code inside a block\n  |\n8 |   println!(\"Error\");\n  |   ^^^^^^^^^^^^^^^^^^\nerror[E0425]: unresolved name `do_something`\n  |\n3 | let mut x: i32 = do_something();\n  |                  ^^^^^^^^^^^^ unresolved name \n```", "```\nint result = getResponseCode();\nif (result = 200) { // BUG!\n  // Success\n}\nelse {\n  //... Process error\n} \n```", "```\nif (200 = result) { // Compiler error\n  // Success\n}\nelse {\n  // ... Process error\n} \n```", "```\nif ((err = SSLHashSHA1.update(&hashCtx, &serverRandom)) != 0)\n  goto fail; \n```", "```\nif ((err == SSLHashSHA1.update(&hashCtx, &serverRandom)) != 0)\n  goto fail; \n```", "```\nlet mut result = 0;\nif result = 200 { // Compile Error\n  //...\n} \n```", "```\nclass Coords {\npublic:\n    double x = 0.0;\n    double y = 0.0;\n    double z = 0.0;\n\n    // 2D initializer, x and y are set with the inputs, z is set to 0\n    Coords(double x, double y) : x(x), y(y) {}\n}; \n```", "```\nstruct Alphabet {\n  a: i32,\n  b: u32,\n  c: bool,\n}\n\nlet a = Alphabet { a: -10, c: true }; \n```", "```\nrustc 1.13.0-beta.1 (cbbeba430 2016-09-28)\nerror[E0063]: missing field `b` in initializer of `main::Alphabet`\n  |\n9 |     let a = Alphabet { a: -10, c: true };\n  |             ^^^^^^^^ missing `b` \n```", "```\nstruct Coord {\n  pub x: f64,\n  pub y: f64,\n  pub z: f64,\n}\n\nimpl Coord {\n  pub fn new(x: f64, y:f64) {\n    Coord { x: x, y: y, z: 0f64 }\n  }\n}\n///...\nlet coord1 = Coord::new(100f64, 200f64); \n```", "```\nimpl From<(f64, f64)> for Coord {\n  fn from(value: (f64, f64)) -> Coord {\n    Coord { x: value.0, y: value.1, z: 0.0 }\n  }\n}\n\nimpl From<(f64, f64, f64)> for Coord {\n  fn from(value: (f64, f64, f64)) -> Coord {\n    Coord { x: value.0, y: value.1, z: value.2 }\n  }\n}\n\n//...\nlet coord = Coord::from((10.0, 20.0));\nlet coord = Coord::from((10.0, 20.0, 30.0)); \n```", "```\n#ifndef FOO_H\n#define FOO_H\n....\n#endif \n```", "```\n#pragma once\n\n// Gory details are in the .cpp file\nclass ComplexThingImpl;\n\nclass ComplexThing {\n  ComplexThingImpl *pimpl_;\npublic:\n  ComplexThing();\n  ~ComplexThing();\n\n  // See note 1 below\n\n  void somethingReallyComplex();\n}; \n```", "```\n// source file\n#include \"random/header.hpp\"\n// Lots of includes here\n#include <...>\n#include \"more/stuff.hpp\"\n\nclass  ComplexThingImpl {\n  // Lots of member variables and stuff here\n  // ...\npublic:\n  void somethingReallyComplex();\n}\n\nvoid ComplexThingImpl::somethingReallyComplex() {\n  // Lots of complex stuff here\n  // ...\n}\n\nComplexThing::ComplexThing() :\n  pimpl_(new ComplexThingImpl()) {\n}\n\nComplexThing::~ComplexThing() {\n  delete pimpl_;\n}\n\nvoid ComplexThing:: somethingReallyComplex() {\n  pimpl_->somethingReallyComplex();\n} \n```", "```\n// functions.rs\npub fn create_directory_structure() {\n  // Implementation\n} \n```", "```\n// directory.rs\npub struct Directory {\n  pub path: String,\n}\nimpl Directory {\n  pub fn mkdir(&self) {\n    // implementation\n  }\n} \n```", "```\n// lib.rs for file_utils\nmod functions;\nmod directory;\npub use functions::*;\npub use directory::Directory; \n```", "```\nextern crate file_utils;\nuse file_utils::*;\nfn main() {\n   create_directory_structure();\n   let d = Directory { /* ... */ };\n} \n```", "```\nclass Data; // Forward declaration\n\nclass DataManager {\npublic:\n  Data *getDataById(const std::string &id);\n};\n\nclass Data {\npublic:\n  Data(DataManager &dataManager);\n} \n```", "```\nclass Data;\n\nclass DataManager {\n  std::map<std::string, Data> data_;\npublic:\n  Data *getDataById(const std::string &id);\n} \n```", "```\nclass Data;\n\nclass DataManager {\n  // Great, now we have to remember to new / delete Data and we increase\n  // memory fragmentation\n  std::map<std::string, Data*> data_;\npublic:\n  Data *getDataById(const std::string &id);\n} \n```", "```\nvoid hello() {\n  // My function hello is in the global namespace, i.e. ::hello()\n}\n\nint main() {\n  // Main entry point\n  hello();\n} \n```", "```\nnamespace application {\n  // stuff in here belongs to application::\n}\n//...\napplication::App app(\"my app\"); \n```", "```\n// Inside of foo.h...\nusing namespace std;\n//... all code after here is tainted with std \n```", "```\nnamespace application { namespace gui {\n  // stuff in here belongs to application::gui::\n} }\n//... eg.\napplication::gui::Point2d point(100,100); \n```", "```\n#define SQUARED(x) x * x\n// And in code\nfloat result = SQUARED(++x);\nThat would expand to\nfloat result = ++x * ++x; \n```", "```\n// Header\nstruct Tooltip\n#if TOOLTIP_VERSION > 4\n  char buffer[128];\n#else\n  char buffer[64];\n#endif\n}; \n```", "```\nTooltip tooltip;\nmemset(&tooltip, 0, sizeof(tooltip)); \n```", "```\n#ifdef TRUE\n#define TMP_TRUE TRUE\n#undef TRUE\n#endif\nbool value = myapp::TRUE;\n#ifdef TMP_TRUE\n#define TRUE TMP_TRUE\n#undef TMP_TRUE\n#endif \n```", "```\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nvoid evaluate(bool value) {\n    cout << \"Evaluating a bool \" << value << endl;\n}\n\nvoid evaluate(const std::string &value) {\n    cout << \"Evaluating a string \" << value << endl;\n}\n\nint main() {\n    evaluate(\"Hello world\");\n    return 0;\n} \n```", "```\nEvaluating a bool 1 \n```", "```\nbool evaluate(bool value);\nbool evaluate(double value); \n```", "```\nfn print_i32(value: i32) {\n   println!(\"Your value is {}\", value);\n}\nlet value = 20i16; // 16-bit int\nprint_i32(value); \n```", "```\nerror[E0308]: mismatched types\n  |\n7 | print_i32(value);\n  |           ^^^^^ expected i32, found i16 \n```", "```\nprint_i32(value as i32); \n```", "```\nclass MagicNumber {\npublic:\n    MagicNumber(int value) {}\n};\n\nvoid magic(const MagicNumber &m) {\n  //...\n}\n\nint main() {\n    //...\n    magic(2016);\n    return 0;\n} \n```", "```\nexplicit MagicNumber(int value) {} \n```", "```\nclass MagicNumber {\npublic:\n    MagicNumber(int value) {}\n    MagicNumber(double value) = delete;\n};\n\nvoid magic(const MagicNumber &m) {\n  //...\n}\n\n//...\nmagic(2016);   // OK\nmagic(2016.0); // error: use of deleted function 'MagicNumber::MagicNumber(double)' \n```", "```\nstruct MagicNumber { /* ... */ }\n\nimpl MagicNumber {\n  fn new<T>(value: T) -> MagicNumber where T: Into<MagicNumber> {\n    value.into()\n  }\n} \n```", "```\nimpl Into<MagicNumber> for i32 {\n   fn into(self) {\n     MagicNumber { /* ... */ }\n   }\n} \n```", "```\n let magic = MagicNumber::new(2016);\n   // But this won't work because f64 doesn't implement the trait\n   let magic = MagicNumber::new(2016.0); \n```", "```\nstd::string &getValue() {\n  std::string value(\"Hello world\");\n  return value;\n} \n```", "```\nstd::string *strings = new std::string[100];\n//...\ndelete strings; \n```", "```\ndelete []strings; \n```", "```\nclass ABase {\npublic:\n  ~ABase() {}\n};\n\nclass A : public ABase {\n  std::string *value_;\npublic:\n  A() : value_(new std::string) {}\n  ~A() { delete value_; }\n};\n\nvoid do_something() {\n  ABase *instance = new A();\n  //...\n  delete instance;\n} \n```", "```\nclass ABase {\npublic:\n  virtual ~ABase() {}\n}; \n```", "```\ntrait ABase {\n  //...\n}\n\nstruct A {\n  value: String,\n}\n\nimpl ABase for A {\n  //...\n} \n```", "```\nimpl Drop for A {\n  fn drop(&mut self) {\n    println!(\"A has been dropped!\");\n  }\n} \n```", "```\nDatabaseConn::DatabaseConn() {\n  db_ = connect();\n  if (db_ == NULL) {\n    throw string(\"The database connection is null\");\n  }\n}\n\n// These both recover their memory\nDatabaseConn db1;\nDatabaseConn *db2 = new DatabaseConn(); \n```", "```\nDatabaseConn::DatabaseConn() {\n  buffer_ = new char[100];\n  // ... exception throwing code\n}\n\nDatabaseConn::~DatabaseConn() {\n  if (buffer_) {\n    delete[] buffer_;\n  }\n} \n```", "```\nDatabaseConn::DatabaseConn() : buffer_(NULL) {\n  // ... exception throwing code\n  buffer_ = new char[100];\n} \n```", "```\nBadNews::~BadNews() {\n    if (ptr == NULL) {\n      throw string(\"This is a bad idea\");\n   }\n} \n```", "```\nclass PatientRecord {\n  std::string name_;\n\n  PatientRecord() {}\n  PatientRecord operator= (const PatientRecord &other) { return *this; }\n\npublic:\n  PatientRecord(const std::string &name) : name_(name) {\n  }\n};\n...\nstd::vector<PatientRecord> records; \n```", "```\nrecords.push_back(PatientRecord(\"John Doe\")); \n```", "```\nrecords.erase(records.begin()); \n```", "```\nc:/mingw/i686-w64-mingw32/include/c++/bits/stl_algobase.h: In instantiation of 'static _OI std::__copy_move<true, false, std::random_access_iterator_tag>::__copy_m(_II, _II, _OI) [with _II = PatientRecord*; _OI = PatientRecord*]':\nc:/mingw/i686-w64-mingw32/include/c++/bits/stl_algobase.h:396:70:   required from '_OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = true; _II = PatientRecord*; _OI = PatientRecord*]'\nc:/mingw/i686-w64-mingw32/include/c++/bits/stl_algobase.h:434:38:   required from '_OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove = true; _II = __gnu_cxx::__normal_iterator<PatientRecord*, std::vector<PatientRecord> >; _OI = __gnu_cxx::__normal_iterator<PatientRecord*, std::vector<PatientRecord> >]'\nc:/mingw/i686-w64-mingw32/include/c++/bits/stl_algobase.h:498:47:   required from '_OI std::move(_II, _II, _OI) [with _II = __gnu_cxx::__normal_iterator<PatientRecord*, std::vector<PatientRecord> >; _OI = __gnu_cxx::__normal_iterator<PatientRecord*, std::vector<PatientRecord> >]'\nc:/mingw/i686-w64-mingw32/include/c++/bits/vector.tcc:145:2:   required from 'std::vector<_Tp, _Alloc>::iterator std::vector<_Tp, _Alloc>::_M_erase(std::vector<_Tp, _Alloc>::iterator) [with _Tp = PatientRecord; _Alloc = std::allocator<PatientRecord>; std::vector<_Tp, _Alloc>::iterator = __gnu_cxx::__normal_iterator<PatientRecord*, std::vector<PatientRecord> >; typename std::_Vector_base<_Tp, _Alloc>::pointer = PatientRecord*]'\nc:/mingw/i686-w64-mingw32/include/c++/bits/stl_vector.h:1147:58:   required from 'std::vector<_Tp, _Alloc>::iterator std::vector<_Tp, _Alloc>::erase(std::vector<_Tp, _Alloc>::const_iterator) [with _Tp = PatientRecord; _Alloc = std::allocator<PatientRecord>; std::vector<_Tp, _Alloc>::iterator = __gnu_cxx::__normal_iterator<PatientRecord*, std::vector<PatientRecord> >; typename std::_Vector_base<_Tp, _Alloc>::pointer = PatientRecord*; std::vector<_Tp, _Alloc>::const_iterator = __gnu_cxx::__normal_iterator<const PatientRecord*, std::vector<PatientRecord> >; typename __gnu_cxx::__alloc_traits<typename std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type>::const_pointer = const PatientRecord*]'\n..\\vectest\\main.cpp:22:34:   required from here\n..\\vectest\\main.cpp:8:19: error: 'PatientRecord PatientRecord::operator=(const PatientRecord&)' is private\n     PatientRecord operator= (const PatientRecord &other) { return *this; } \n```", "```\nfn clone_something<T>(value: T) -> T {\n  value.clone()\n} \n```", "```\n |\n4 |   value.clone();\n  |         ^^^^^\n  |\n  = help: items from traits can only be used if the trait is implemented and in scope; the following trait defines an item `clone`, perhaps you need to implement it:\n  = help: candidate #1: `std::clone::Clone` \n```", "```\nfn clone_something<T: Clone>(value: T) -> T {\n  value.clone();\n} \n```", "```\nstruct WhatHappensToMe;\nlet x = clone_something(10);\nlet y = clone_something(WhatHappensToMe{}); \n```", "```\nerror[E0277]: the trait bound `main::WhatHappensToMe: std::clone::Clone` is not satisfied\n  |\n8 | let y = clone_something(WhatHappensToMe{});\n  |         ^^^^^^^^^^^^^^^\n  |\n  = note: required by `main::clone_something` \n```", "```\nclass B : public virtual A {\n//...\n};\nclass C: public virtual A {\n};\nclass D: public B, public C {\n//...\n}; \n```", "```\ntrait A {\n//...\n}\n\ntrait B : A {\n//...\n}\n\ntrait C : A {\n//...\n}\n\nstruct D;\n\nimpl A for D {\n//...\n}\n\nimpl B for D {\n//...\n}\n\nimpl C for D {\n//...\n} \n```", "```\ncargo update \n```"]