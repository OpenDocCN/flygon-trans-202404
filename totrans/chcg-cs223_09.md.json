["```\ntype alias Rank = Int\n\ntype Heap = E | T Rank Int Heap Heap \n```", "```\nrank h  = case h of { E -> 0      ; T r _ _ _ -> r                   }\n\nvalue h = case h of { E -> maxInt ; T _ i _ _ -> i                   }\n\nleft h  = case h of { E -> E      ; T _ _ a _ -> a                   }\n\nright h = case h of { E -> E      ; T _ _ _ b -> b                   }\n\nsize h  = case h of { E -> 0      ; T _ _ a b -> 1 + size a + size b } \n```", "```\nlog = logBase 2 \n```", "```\nmakeT : Int -> Heap -> Heap -> Heap\nmakeT x h1 h2 =\nlet (r1,r2) = (rank h1, rank h2) in if\n  | r1 >= r2  -> T (1+r2) x h1 h2\n  | otherwise -> T (1+r1) x h2 h1 \n```", "```\nmakeT x h1 h2 =\n  let (l,r) = if | rank h1 >= rank h2 -> (h1, h2)\n                 | otherwise          -> (h2, h1) in\n  T (1 + rank r) x l r \n```", "```\nmerge : Heap -> Heap -> Heap\nmerge h1 h2 = case (h1, h2) of\n  (_, E) -> h1\n  (E, _) -> h2 \n  (T _ x1 l1 r1, T _ x2 l2 r2) ->\n    if | x1 <= x2  -> makeT x1 l1 (merge r1 h2)\n       | otherwise -> makeT x2 l2 (merge h1 r2) \n```", "```\nempty       = E\nsingleton x = T 1 x E E \n```", "```\ninsert : Int -> Heap -> Heap\ninsert x h = merge (singleton x) h\n\ndeleteMin : Heap -> Maybe Heap\ndeleteMin h = case h of\n  E         -> Nothing\n  T r _ a b -> Just (merge a b) \n```", "```\nfindMin : Heap -> Maybe Int\nfindMin h = case h of\n  E         -> Nothing\n  T _ i _ _ -> Just i\n\nisEmpty : Heap -> Bool\nisEmpty h = h == empty \n```", "```\nmodule LeftistHeaps\n  (Heap, empty, isEmpty, findMin, insert, deleteMin, merge) where\n  ... \n```", "```\n> import LeftistHeaps (..)\n> insert 1 <| insert 2 <| insert 3 <| empty\nT 1 1 (T 1 2 (T 1 3 E E) E) E : LeftistHeaps.Heap \n```"]