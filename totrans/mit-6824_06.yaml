- en: Raft
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6.824 2015 Lecture 6: Raft'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Note:** These lecture notes were slightly modified from the ones posted on
    the 6.824 [course website](http://nil.csail.mit.edu/6.824/2015/schedule.html)
    from Spring 2015.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This lecture: Raft'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: larger topic is fault tolerance via replicated state machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raft -- a much more complete design than straight Paxos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Raft overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Raft vs Paxos?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our use of Paxos:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: agrees separately on each client operation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Raft:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: agrees on each new leader (and on tail of log)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: agreement not required for most client operations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Raft is Paxos optimized for log appends (more or less)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: why Raft-style leader?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: no *dueling proposers* (unless leader fails)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: leader just tells other people what to do
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: fewer messages, less complexity (unless leader fails)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: well-defined notion of one log being more complete than another
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: simplifies switching leaders (and maybe crash recovery)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: very hard to find a solution for this in Paxos because logs have "holes"
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What about understandability?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: you must decide for yourself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: straight Paxos is simpler than Raft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: but straight Paxos is too simple for practical replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: everyone extends it in their own way
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: and ends up with something more or less like Raft
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Paxos+log+leader probably not simpler than Raft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: though presumably depends on which Paxos variant you choose
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is more direct use of Paxos (like Lab 3) ever a win?
  prefs: []
  type: TYPE_NORMAL
- en: i.e. is a Raft-style leader ever a bad idea?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: geographically spread peers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a single leader would be far from some clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: some peers would be slow to other peers (Paxos tolerates lag)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start w/ Raft w/ no leader change
  prefs: []
  type: TYPE_NORMAL
- en: for now, reliable leader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: followers may be slow or unreachable (but they do not lose state)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: what do we want?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tolerate a *minority of failed followers*
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: live followers and dead followers *converge on same log* since replication requires
    same order of execution
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '*execute only when entry cannot be lost* (committed) since cannot easily undo
    execution or reply to client'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'idea for ensuring identical log:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: leader sends *log entry*, *index*, and info about *previous* entry
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: client can reject (e.g I don't have previous entry!)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: leader backs up for that follower, sends earlier entries
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: leader forces followers' logs to be identical to leader's
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'idea for execution:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'idea #1 means leader knows follower is identical up to some point'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: once a majority are identical up to a point,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: leader sends that out as commit point,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: everyone can execute through that point,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: leader can reply to clients
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What to do if the leader crashes?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: other servers time out (no AppendEntries "heart-beats" for a while)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if other servers are missing heartbeats they start to suspect the leader is
    down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: can't really know *for sure* leader is down/up on a network
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: choose a new leader!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raft divides time into terms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: most terms have a leader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the dangers in transition to a new leader?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: two leaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: no leader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: might forget an executed log entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: logs might end up different (diverge)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Talk about leader election first, then log consistency at term boundary
  prefs: []
  type: TYPE_NORMAL
- en: How to ensure at most one leader in a term?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (look at Figure 2, RequestVote RPC, and Rules for Servers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: leader must get votes from a majority of servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule:** server can cast only one vote per term'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: thus at most one server can think it has won
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: why a majority?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the answer is always the same!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"requiring a majority means not requiring a minority essentially"'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: allows fault tolerance (failure of minority doesn't impede progress)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: prevents split brain (at most one candidate can get a majority)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ensures overlap (at least one in majority has every previously committed log
    entry)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Could election fail to choose any leader?
  prefs: []
  type: TYPE_NORMAL
- en: Yes!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '= 3 candidates split the vote evenly or even # of live servers, two candidates
    each get half'
  prefs:
  - PREF_IND
  - PREF_UL
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens after an election in which no-one gets majority?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: timeout, increment term, new election
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: when a server decides it might wants to be a candidate it first waits a random
    delay and only if it doesn't hear from anyone else then it becomes a candidate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: higher term takes precedence, candidates for older terms quit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: timeout must be longer than it takes to complete election!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: this means some terms may have no leader, no log entries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does Raft reduce chances of election failure due to split vote?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: each server delays a random amount of time before starting candidacy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: why is the random delay useful?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[see diagram of times at which servers'' delays expire]'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: one will choose lowest random delay
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: hopefully enough time to elect before next delay expires
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: this idea comes up often in distributed systems
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to choose the random delay range?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'too short: 2nd candidate starts before first finishes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'too long: system sits idle for too long after leader fails'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'a rough guide:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: suppose it takes 10ms to complete an unopposed election
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: and there are five servers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: we want delays to be separated by (say) 20ms
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: so random delay from 0 to 100 ms
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: plus a few multiples of leader heartbeat interval
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember this random delay idea!
  prefs: []
  type: TYPE_NORMAL
- en: it's a classic scheme for decentralized soft election; e.g. ethernet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Raft''s elections follow a common pattern: separation of safety from progress'
  prefs: []
  type: TYPE_NORMAL
- en: '*Hard* mechanisms ensure `< 2` leaders in one term'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Problem: elections can fail (e.g. 3-way split)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution: always safe to start a new election in a new term'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Poblem: repeated elections can prevent any work getting done'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution: *soft* mechanisms reduce probability of wasted elections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: heartbeat from leader (remind servers not to start election)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: timeout period (don't start election too soon)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: random delays (give one leader time to be elected)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remember:** there''s a way to split the problem into "safety/correctness"
    concerns and "liveness/performance" concerns'
  prefs: []
  type: TYPE_NORMAL
- en: What if old leader isn't aware a new one is elected?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: perhaps b/c old leader didn't see election messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: new leader means a majority of servers have incremented currentTerm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: so old leader (w/ old term) can't get majority for AppendEntries
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: though a minority may accept old server's log entries...
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: so logs may diverge at end of old term...
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's switch topics to **data handling** at term boundaries
  prefs: []
  type: TYPE_NORMAL
- en: What do we want to ensure?
  prefs: []
  type: TYPE_NORMAL
- en: each server executes the same client cmds, in the same order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: i.e. if any server executes, then no server executes something else for that
    log entry
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: as long as single leader, we've already seen it makes logs identical what about
    when leader changes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's the danger?
  prefs: []
  type: TYPE_NORMAL
- en: Leader of term 3 crashed while sending `AppendEntries`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: May be a series of crashes, e.g.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Thus different entries for the same index!
  prefs: []
  type: TYPE_NORMAL
- en: Roll-back is a big hammer -- forces leader's log on everyone
  prefs: []
  type: TYPE_NORMAL
- en: in above examples, whoever is elected imposes log on everyone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S3 is chosen as new leader for term 6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: S3 wants to send out a new entry (in term 6)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppendEntries` says previous entry must have term 5'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: S2 replies false (`AppendEntries` step 2)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: S3 decrements `nextIndex[S2]`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: S3 sends `AppendEntries` for the op w/ term=5, saying prev has term=3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: S2 deletes op from term 4 (`AppendEntries` step 3) and replaces with op for
    term 5 from S3 (and S1 rejects b/c it doesn't have anything in that entry)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: S2 sets op for term 6 as well
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ok, leader will force its own log on followers
  prefs: []
  type: TYPE_NORMAL
- en: but that's not enough!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: can roll-back delete an executed entry?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When is a log entry executed?
  prefs: []
  type: TYPE_NORMAL
- en: when leader advances `commitIndex/leaderCommit`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: when a majority match the leader up through this point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Could new leader roll back executed entries from end of previous term?
  prefs: []
  type: TYPE_NORMAL
- en: i.e. could an executed entry be missing from the new leader's log?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raft needs to ensure new leader's log contains every potentially executed entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: i.e. must forbid election of server who might be missing an executed entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the election rules?
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2 says only vote if candidate's log "at least as up to date"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So leader will be *at least as up to date* as a majority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does "at least as up to date" mean?
  prefs: []
  type: TYPE_NORMAL
- en: 'Could it mean log is >= length? No, example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: first, could this scenario happen? how?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S1 leader in epoch 6; crash+reboot; leader in epoch 7; crash and stay down
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: both times it crashed after only appending to its own log
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: S2 leader in epoch 8, only S2+S3 alive, then crash
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: who should be next leader?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S1 has longest log, but entry 8 is committed !!!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Raft adopts leader's log, so S1 as leader -> un-commit entry 8
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: this would be incorrect since S2 may have replied to client
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: so new leader can only be one of S2 or S3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: i.e. the rule cannot be simply "longest log"
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: End of 5.4.1 explains "at least as up to date" voting rule
  prefs: []
  type: TYPE_NORMAL
- en: compare last entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: higher term wins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if equal terms, longer log wins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So:'
  prefs: []
  type: TYPE_NORMAL
- en: S1 can't get any vote from S2 or S3, since `7 < 8`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S1 will vote for either S2 or S3, since `8 > 7`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S1's operations from terms 6 and 7 will be discarded!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ok since no majority -> not executed -> no client reply
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The point:'
  prefs: []
  type: TYPE_NORMAL
- en: '"at least as up to date" rule causes new leader to have all executed entries
    in its log'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: so new leader won't roll back any executed operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'similar to Paxos: new round ends up using chosen value (if any) of prev round'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The question: Figure 7, which of a/d/f could be elected?'
  prefs: []
  type: TYPE_NORMAL
- en: i.e. majority of votes from "less up to date" servers?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most subtle thing about Raft (figure 8)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: not 100% true that a log entry on a majority is committed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: i.e. will never be forgotten
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 8:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S1 was leader in term 2, sends out two copies of 2
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: S5 leader in term 3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: S1 leader in term 4, sends one more copy of 2 (b/c S3 rejected op 4)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: what if S5 now becomes leader?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: S5 can get a majority (w/o S1)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: S5 will roll back 2 and replace it with 3
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: could 2 have executed?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: it is on a majority...
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: so could S1 have mentioned it in leaderCommit after majority?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: no! very end of Figure 2 says "log[N].term == currentTerm"
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: and S1 was in term 4 when sending 3rd copy of 2
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: what's Raft's actual commit point?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: bottom-right of page 310
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"committed once the leader that created the entry has replicated on majority"'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: and commit point of one entry commits all before it
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: which is how 2 *could* have committed if S1 hadn't lost leadership
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another topic: configuration change (Section 6)'
  prefs: []
  type: TYPE_NORMAL
- en: configuration = set of servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how does Raft change the set of servers?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: e.g. every few years might want to retire some, add some
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: or move all at once to an entirely new set of server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: or increase/decrease the number of servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How might a *broken* configuration change work?
  prefs: []
  type: TYPE_NORMAL
- en: each server has the list of servers in the current config
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: change configuation by changing lists, one by one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'example: want to replace S3 with S4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'S1: 1,2,3 1,2,4'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'S2: 1,2,3 1,2,3'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'S3: 1,2,3 1,2,3'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'S4: 1,2,4 1,2,4'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: OOPS!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'now *two* disjoint group/leaders can form:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: S2 and S3 (who know nothing of new config)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: S1 and S4
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: both can process client requests, so split brain
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Raft configuration change
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Idea:** "join consensus" stage that includes *both* old and new configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: leader of old group logs entry that switches to joint consensus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: during joint consensus, leader separately logs in old and new
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: i.e. *two* log and *two* agreements on each log entry
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: this will force new servers to catch up and force new and old logs to be the
    same
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: after majority of old and new have switched to joint consensus,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: leader logs entry that switches to final configuration
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example (which won''t make sense because it''s not properly illustrated in
    the original notes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: if crash but new leader didn't see the switch to joint consensus,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: then old group will continue, no switch, but that's OK
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: if crash and new leader did see the switch to joint consensus,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: it will complete the configuration change
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: no numbers on how fast it can process requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: what are the bottlenecks likely to be?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'disk:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: need to write disk for client data durability, and for protocol promises
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: write per client request? so 100 per second?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: could probably batch and get 10,000 to 100,000
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'net: a few message exchanges per client request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10s of microseconds for local LAN message exchange?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: so 100,000 per second?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Next week:* use of a Raft-like protocol in a complex application'
  prefs: []
  type: TYPE_NORMAL
