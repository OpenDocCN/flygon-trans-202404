- en: Lexical Scope using Racket ClosuresTuesday, February 7th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PLAI §11](plai.pdf#chapter.11 "Representation Choices") (without the last
    part about recursion)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: An alternative representation for an environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already seen how first-class functions can be used to implement “objects”
    that contain some information. We can use the same idea to represent an environment.
    The basic intuition is — an environment is a *mapping* (a function) between an
    identifier and some value. For example, we can represent the environment that
    maps `''a` to `1` and `''b` to `2` (using just numbers for simplicity) using this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An empty mapping that is implemented in this way has the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this idea to implement our environments: we only need to define
    three things — `EmptyEnv`, `Extend`, and `lookup`. If we manage to keep the contract
    to these functions intact, we will be able to simply plug it into the same evaluator
    code with no other changes. It will also be more convenient to define `ENV` as
    the appropriate function type for use in the `VAL` type definition instead of
    using the actual type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we get to `EmptyEnv` — this is expected to be a function that expects no
    arguments and creates an empty environment, one that behaves like the `empty-mapping`
    function defined above. We could define it like this (changing the `empty-mapping`
    type to return a `VAL`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'but we can skip the need for an extra definition and simply return an empty
    mapping function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: (The un-Rackety name is to avoid replacing previous code that used the `EmptyEnv`
    name for the constructor that was created by the type definition.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we tackle is `lookup`. The previous definition that was used
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'How should it be modified now? Easy — an environment is a mapping: a Racket
    function that will do the searching job itself. We don’t need to modify the contract
    since we’re still using `ENV`, except a different implementation for it. The new
    definition is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that `lookup` does almost nothing — it simply delegates the real work to
    the `env` argument. This is a good hint for the error message that empty mappings
    should throw —
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `Extend` — this was previously created by the variant case of the
    ENV type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'keeping the same type that is implied by this variant means that the new `Extend`
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The question is — how do we extend a given environment? Well, first, we know
    that the result should be mapping — a `symbol -> VAL` function that expects an
    identifier to look for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we know that in the generated mapping, if we look for `id` then the result
    should be `val`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `name` that we’re looking for is not the same as `id`, then we need
    to search through the previous environment, eg: (lookup name rest). But we know
    what `lookup` does — it simply delegates back to the mapping function (which is
    our `rest` argument), so we can take a direct route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: (Note that the last line is simply `(lookup name rest-env)`, but we know that
    we have a functional implementation.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how all this works, try out extending an empty environment a few times
    and examine the result. For example, the environment that we began with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: behaves in the same way (if the type of values is numbers) as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The new code is now the same, except for the environment code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
