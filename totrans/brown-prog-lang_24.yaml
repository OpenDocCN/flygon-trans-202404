- en: '24Processing Programs: A First Look at Interpretation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|     [24.1 Representing Arithmetic](#%28part._dt-for-arith%29) |'
  prefs: []
  type: TYPE_TB
- en: '|     [24.2 Writing an Interpreter](#%28part._.Writing_an_.Interpreter%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|     [24.3 A First Taste of “Semantics”](#%28part._.A_.First_.Taste_of__.Semantics_%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|     [24.4 Desugaring: Growing the Language Without Enlarging It](#%28part._first-desugar%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|       [24.4.1 Extension: Binary Subtraction](#%28part._.Extension__.Binary_.Subtraction%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|       [24.4.2 Extension: Unary Negation](#%28part._.Extension__.Unary_.Negation%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|     [24.5 A Three-Stage Pipeline](#%28part._.A_.Three-.Stage_.Pipeline%29)
    |'
  prefs: []
  type: TYPE_TB
- en: 'Now we’re ready to write an evaluator—<wbr>a program that turns programs into
    answers—<wbr>in the form of an interpreter, for our arithmetic language.The term
    “evaluate” means “to reduce to a value”. We choose arithmetic first for three
    reasons: (a) you already know how it works, so we can focus on the mechanics of
    writing evaluators; (b) it’s contained in every language we will encounter later,
    so we can build upwards and outwards from it; and (c) it’s (surprisingly) sophisticated
    enough to convey some important points.'
  prefs: []
  type: TYPE_NORMAL
- en: 24.1Representing Arithmetic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s first agree on how we will represent arithmetic expressions. Let’s say
    we want to support only two operations—<wbr>addition and multiplication—<wbr>in
    addition to primitive numbers. We need to represent arithmetic expressions. What
    are the rules that govern the nesting of arithmetic expressions? We’re actually
    free to nest any expression inside another.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why did we not include division? What impact does it have on the remarks above?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We’ve ignored division because it forces us into a discussion of what expressions
    we might consider legal: clearly the representation of 1/2 ought to be legal;
    the representation of 1/0 is much more debatable; and that of 1/(1-1) seems even
    more controversial. We’d like to sidestep this controversy for now and return
    to it later [REF].Thus, we want a representation for numbers and arbitrarily nestable
    addition and multiplication. Here’s one we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 24.2Writing an Interpreter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s write an interpreter for this arithmetic language. First, we should
    think about what its type is. It clearly consumes a ArithC value. What does it
    produce? Well, an interpreter evaluates—<wbr>and what kind of value might arithmetic
    expressions reduce to? Numbers, of course. So the interpreter is going to be a
    function from arithmetic expressions to numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write your examples for the interpreter.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because we have a recursive datatype, it is natural to structure our interpreter
    as a recursive function over it. Here’s a first template:Templates are explained
    in detail in [How to Design Programs](http://www.htdp.org/).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You’re probably tempted to jump straight to code, which you can:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: which works just fine, passing its test.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you spot the errors?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Instead, let’s expand the template out a step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'and now we can fill in the blanks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Later on ([Functions Anywhere](Interpreting_Functions.html#%28part._higher-order-functions%29)),
    we’re going to wish we had returned a more complex datatype than just numbers.
    But for now, this will do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations: you’ve written your first interpreter! I know, it’s very nearly
    an anticlimax. But they’ll get harder—<wbr>much harder—<wbr>pretty soon, I promise.'
  prefs: []
  type: TYPE_NORMAL
- en: 24.3A First Taste of “Semantics”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I just slipped something by you:'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the “meaning” of addition and multiplication in this new language?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: That’s a pretty abstract question, isn’t it. Let’s make it concrete. I’ll pose
    the problem as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Which of these is the same?
  prefs: []
  type: TYPE_NORMAL
- en: 1 + 2
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 1 + 2
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ’1’ + ’2’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ’1’ + ’2’
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What we’re driving at is that there are many kinds of addition in computer
    science:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, there are many different kinds of numbers: fixed-width (e.g.,
    32-bit) integers, signed fixed-width (e.g., 31-bits plus a sign-bit) integers,
    arbitrary precision integers; in some languages, rationals; various formats of
    fixed- and floating-point numbers; in some languages, complex numbers; and so
    on. After the numbers have been chosen, addition may support only some combinations
    of them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, some languages permit the addition of datatypes such as matrices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, many languages support “addition” of strings (we use scare-quotes
    because we don’t really mean the mathematical concept of addition, but rather
    the operation performed by an operator with the syntax +). In some languages this
    always means concatenation; in some others, it can result in numeric results (or
    numbers stored in strings).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are all different “meanings for addition”. Semantics is the mapping of
    syntax (e.g., +) to meaning (e.g., some or all of the above).
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to our interpreter, what semantics do we have? We’ve adopted whatever
    semantics Pyret provides, because we map + to Pyret’s +. In fact that’s not even
    quite true: Pyret may, for all we know, also enable + to apply to strings (which
    in fact it does), so we’ve chosen the restriction of Pyret’s semantics to numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In what way have we restricted + to apply only to numbers? Where exactly is
    this restriction?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: If we wanted a different semantics, we’d have to implement it explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What all would you have to change so that the number had signed 32-bit arithmetic?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: In general, we have to be careful about too readily borrowing from the host
    language. We’ll return to this topic later [REF]. However, because we have lots
    of interesting things to study already, we will adopt Pyret’s numbers as our numbers
    for now.
  prefs: []
  type: TYPE_NORMAL
- en: '24.4Desugaring: Growing the Language Without Enlarging It'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve picked a very restricted first language, so there are many ways we can
    grow it. Some, such as representing data structures and functions, will clearly
    force us to add new features to the interpreter itself. Others, such as adding
    more of arithmetic itself, can possibly be done without disturbing the core language
    and hence its interpreter: this is known as adding syntactic sugar, or “sugar”
    for short. Let’s investigate.'
  prefs: []
  type: TYPE_NORMAL
- en: '24.4.1Extension: Binary Subtraction'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we’ll add subtraction. Because our language already has numbers, addition,
    and multiplication, it’s easy to define subtraction: \(a - b = a + -1 \times b\).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, that was easy! But now we should turn this into concrete code. To do
    so, we face a decision: where does this new subtraction operator reside? It is
    tempting, and perhaps seems natural, to just add one more case to our existing
    ArithC datatype.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the negative consequences of modifying ArithC?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This creates a few problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The first, obvious, one is that we now have to modify all programs that process
    ArithC. So far that’s only our interpreter, which is pretty simple, but in a more
    complex implementation, there could be many programs built around the datatype—<wbr>a
    type-checker, compiler, etc.—<wbr>which must all be changed, creating a heavy
    burden.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, we were trying to add new constructs that we can define in terms of
    existing ones; it feels slightly self-defeating to do this in a way that isn’t
    modular.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Third, and most subtly, there’s something conceptually unnecessary about modifying
    ArithC. That’s because ArithC represents a perfectly good core language. Atop
    this, we might want to include any number of additional operations that make the
    user’s life more convenient, but there’s no need to put these in the core. Rather,
    it’s wise to record conceptually different ideas in distinct datatypes, rather
    than shoehorn them into one. The separation can look a little unwieldy sometimes,
    but it makes the program much easier for future developers to read and maintain.
    Besides, for different purposes you might want to layer on different extensions,
    and separating the core from the surface enables that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Therefore, we’ll define a new datatype to reflect our intended surface syntax
    terms:<arith-dt> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '|   data ArithExt: |'
  prefs: []
  type: TYPE_TB
- en: '|     &#124; numExt (n :: Number) |'
  prefs: []
  type: TYPE_TB
- en: '|     &#124; plusExt (l :: ArithExt, r :: ArithExt) |'
  prefs: []
  type: TYPE_TB
- en: '|     &#124; multExt (l :: ArithExt, r :: ArithExt) |'
  prefs: []
  type: TYPE_TB
- en: '|     &#124; bminusExt (l :: ArithExt, r :: ArithExt) |'
  prefs: []
  type: TYPE_TB
- en: '|     [<uminus-dt>](#%28elem._uminus-dt%29) |'
  prefs: []
  type: TYPE_TB
- en: '|   end |'
  prefs: []
  type: TYPE_TB
- en: This looks almost exactly like ArithC, other than the added case, which follows
    the familiar recursive pattern. Note that the children of each node refer to ArithExt,
    not ArithC.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if the children are declared to be ArithC rather than ArithExt?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: If we did this, then we would be able to use sugar only at the top-level, not
    in any sub-expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Given this datatype, we should do two things. First, we should modify our parser
    to also parse - expressions, and always construct ArithExt terms (rather than
    any ArithC ones). Second, we should implement a desugar function that translates
    ArithExt values into ArithC ones.Desugaring is the act of removing syntactic sugar.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write the obvious part of desugar:<main> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '|   fun desugar(s :: ArithExt) -> ArithC: |'
  prefs: []
  type: TYPE_TB
- en: '|     cases (ArithExt) s: |'
  prefs: []
  type: TYPE_TB
- en: '|       &#124; numExt(n) => numC(n) |'
  prefs: []
  type: TYPE_TB
- en: '|       &#124; plusExt(l, r) => plusC(desugar(l), desugar(r)) |'
  prefs: []
  type: TYPE_TB
- en: '|       &#124; multExt(l, r) => multC(desugar(l), desugar(r)) |'
  prefs: []
  type: TYPE_TB
- en: '|       [<bminus>](#%28elem._bminus%29) |'
  prefs: []
  type: TYPE_TB
- en: '|       [<uminus>](#%28elem._uminus%29) |'
  prefs: []
  type: TYPE_TB
- en: '|     end |'
  prefs: []
  type: TYPE_TB
- en: '|   end |'
  prefs: []
  type: TYPE_TB
- en: Now let’s convert the mathematical description of subtraction above into code:<bminus>
    ::=
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; bminusExt(l, r) => |'
  prefs: []
  type: TYPE_TB
- en: '|     plusC(desugar(l), multC(numC(-1), desugar(r))) |'
  prefs: []
  type: TYPE_TB
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s a common mistake to forget the recursive calls to desugar on l and r. What
    happens when you forget them? Try for yourself and see.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '24.4.2Extension: Unary Negation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s consider another extension, which is a little more interesting: unary
    negation. This forces you to do a little more work in the parser because, depending
    on your surface syntax, you may need to look ahead to determine whether you’re
    in the unary or binary case. But that’s not even the interesting part!'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify parse to handle unary subtraction.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There are many ways we can desugar unary negation. We can define it naturally
    as \(-b = 0 - b\), or we could abstract over the desugaring of binary subtraction
    with this expansion: \(-b = 0 + -1 \times b\).'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which one do you prefer? Why?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s tempting to pick the first expansion, because it’s much simpler. Imagine
    we’ve extended the ArithExt datatype with a representation of unary negation:<uminus-dt>
    ::=
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; uminusExt (e :: ArithExtU) |'
  prefs: []
  type: TYPE_TB
- en: Now the implementation in desugar is straightforward:<uminus> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; uminusExt(e) => desugar(bminusExt(numExt(0), e)) |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s make sure the types match up. Observe that e is a ArithExt term, so it
    is valid to use as an argument to bminusExt, and the entire term can legally be
    passed to desugar. It is therefore important to not desugar e but rather embed
    it directly in the generated term. This embedding of an input term in another
    one and recursively calling desugar is a common pattern in desugaring tools; it
    is called a macro (specifically, the “macro” here is this definition of uminusExt).However,
    there are two problems with the definition above:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is that the recursion is generative, which forces us to take extra
    care.If you haven’t heard of generative recursion before, read the section on
    it in [How to Design Programs](http://www.htdp.org/). Essentially, in generative
    recursion the sub-problem is a computed function of the input, rather than a structural
    piece of it. This is an especially simple case of generative recursion, because
    the “function” is simple: it’s just the bminusExt constructor. We might be tempted
    to fix this by using a different rewrite:<uminus/alt> ::='
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|   &#124; uminusExt(e) => bminusExt(numExt(0), desugar(e)) |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: which does indeed eliminate the generativity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unfortunately, this desugaring transformation won’t work at all! Do you see
    why? If you don’t, try to run it.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The second is that we are implicitly depending on exactly what bminusExt means;
    if its meaning changes, so will that of uminusExt, even if we don’t want it to.
    In contrast, defining a functional abstraction that consumes two terms and generates
    one representing the addition of the first to -1 times the second, and using this
    to define the desugaring of both uminusExt and bminusExt, is a little more fault-tolerant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might say that the meaning of subtraction is never going to change, so why
    bother? Yes and no. Yes, it’s meaning is unlikely to change; but no, its implementation
    might. For instance, the developer may decide to log all uses of binary subtraction.
    In the first expansion all uses of unary negation would also get logged, but they
    would not in the second expansion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fortunately, in this particular case we have a much simpler option, which is
    to define \(-b = -1 \times b\). This expansion works with the primitives we have,
    and follows structural recursion. The reason we took the above detour, however,
    is to alert you to these problems, and warn that you might not always be so fortunate.
  prefs: []
  type: TYPE_NORMAL
- en: 24.5A Three-Stage Pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This concludes our first look at the standard pipeline we’re going to use. We
    will first parse programs to convert them to abstract syntax; we will then desugar
    them to eliminate unnecessary constructs. From now on, we will usually focus just
    on the resulting core language, which will be subject to not only interpretation
    but also type-checking and other actions.
  prefs: []
  type: TYPE_NORMAL
