- en: Running the Evaluator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running the Evaluator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at how Scheme runs the evaluator. So far, we learned how the Scheme
    expressions are evaluated using `mc-eval` and `mc-apply`. Then how is the evaluator
    program running?
  prefs: []
  type: TYPE_NORMAL
- en: What our evaluator program does is to reduce all the expressions to the application
    of primitive procedures. So all we need to run the evaluator is to create a mechanism
    that uses the underlying Scheme system for the application of primitive procedures.
  prefs: []
  type: TYPE_NORMAL
- en: There must be a binding for each primitive procedure name, so that when `mc-eval`
    evaluates the operator of an application of a primitive, it will find an object
    to pass to `mc-apply`. We thus set up a global environment that associates unique
    objects with the names of the primitive procedures that can appear in the expressions
    we will be evaluating (for example, we'll bind `+` to the underlying Scheme procedure
    with the same name). The global environment also includes bindings for the symbols
    `true` and `false`, so that they can be used as variables in expressions to be
    evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For convenience in running the metacircular evaluator, we provide a **driver
    loop** that models the read-eval-print loop (or REPL) of the underlying Scheme
    system. It prints a **prompt**, reads an input expression, evaluates this expression
    in the global environment, and prints the result. We precede each printed result
    by an **output prompt** so as to distinguish the value of the expression from
    other output that may be printed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We use a special printing procedure, `user-print`, to avoid printing the environment
    part of a compound procedure, which may be a very long list (or may even contain
    cycles).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all we need to do to run the evaluator is to initialize the global environment
    and start the driver loop. Here is a sample interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Wait, I still don''t get it. How can we evaluate Scheme code with an evaluator
    that is written in Scheme?*'
  prefs: []
  type: TYPE_NORMAL
- en: It's because Scheme is powerful enough to handle a program as data, and to let
    us construct data structures that are both hierarchical and circular. I have an
    analogy for you in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Data as Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand interpreting Scheme expression with the interpreter written in
    Scheme, think of a program as a description of an abstract machine. For example,
    you can think of the program to compute factorials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'as the description of a machine containing parts that decrement, multiply,
    and test for equality, together with a two-position switch and another factorial
    machine. (The factorial machine is infinite because it contains another factorial
    machine within it -- recursion!) So the machine will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e573237fc15c3c41936fac8959325d54.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Like `factorial`, the evaluator is a very special machine that takes a description
    of other machine as input, and then configures itself to emulate the given machine.
    For example, if we give the evaluator the definition of `factorial`, the evaluator
    will emulate it and be able to compute factorials.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/747dece8f01e6a003704c21c47f7d1e5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So our evaluator is just a universal machine that mimics all other machines!
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to know more about the machines, ask for Unit 5.
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this subsection, you learned how the evaluator works.
  prefs: []
  type: TYPE_NORMAL
- en: What's Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go do your homework! You should also start on Project 4, where you'll learn
    the Python programming language.
  prefs: []
  type: TYPE_NORMAL
