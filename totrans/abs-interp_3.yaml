- en: 3  Topics in abstract interpretation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3.1  Abstract domains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An abstract domain is an abstract algebra, often implemented as a library module
    (see **Sec. [5](#sec:libraries)**), providing a description of abstract program
    properties and abstract property transformers describing the operational effect
    of program instructions and commands in the abstract. Abstract domains are often
    complete lattices, an abstraction of powersets [[26](#CousotCousot79-1-POPL)].
  prefs: []
  type: TYPE_NORMAL
- en: 3.2  Finite versus infinite abstract domains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first infinite abstract domain (that of intervals) was introduced in [[21](#CousotCousot76-1-ISOP)].
    This abstract domain was later used to prove that, thanks to widenings, infinite
    abstract domains can lead to effective static analyses for a given programming
    language that are strictly more precise and equally efficient than any other one
    using a finite abstract domain or an abstract domain satisfying chain conditions
    [[31](#CousotCousot92-4-PLILP)].
  prefs: []
  type: TYPE_NORMAL
- en: 3.3  Merge over all paths (MOP) in dataflow analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first dataflow analyses where proved correct by comparing the union of the
    abstraction along all execution paths (so-called MOP[¹](#tthFtNtAAB) solution)
    with a fixpoint solution using transfer functions (i.e. abstract property transformer)
    [[67](#Hecht77-1)]. Instead of comparing one solution of the static analysis problem
    to another one, the theory of abstract interpretation introduced the idea that
    the correctness/soundness should be expressed with respect to a formal semantics.
    A consequence is that static analysis algorithms can be specified and designed
    by approximation of a program semantics. Moreover, the "fixpoint solution" was
    shown to be an abstraction of the "MOP solution". These two solutions coincide
    for distributive abstract interpretations (for which abstract transformers preserve
    union). Otherwise, the abstract domain used for the fixpoint solution can be minimally
    enriched into its *disjunctive completion* to get exactly the "MOP solution" in
    fixpoint form (on the completed abstract domain) [[26](#CousotCousot79-1-POPL)].
  prefs: []
  type: TYPE_NORMAL
- en: 3.4  Standard and collecting semantics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *collecting semantics* or *non-standard semantics* (after the *static semantics*
    of [[22](#CousotCousot77-1-POPL)]) is the semantics of the language formally defining
    the program execution properties of interest to be analyzed by abstraction. These
    program executions themselves are formalized by the standard semantics.For example
    in [[22](#CousotCousot77-1-POPL)], the standard semantics is an operational semantics.
    The concrete properties of interest are invariance properties so the collecting
    semantics defines the reachable states from initial states. This collecting semantics
    is expressed as the least fixpoint of equations using strongest postcondition
    transformers. Thus the considered abstractions provide abstract invariance properties
    (overapproximating the reachable states).
  prefs: []
  type: TYPE_NORMAL
- en: 3.5  Galois connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Galois connections can be used when the abstract domain always offers a most
    precise approximation of any concrete property [[26](#CousotCousot79-1-POPL)].
    Indeed the Galois connections introduced in [[21](#CousotCousot76-1-ISOP),[22](#CousotCousot77-1-POPL)]
    are the semi-dual of the one introduced by Évariste Galois, and so do compose
    (the abstraction of an abstraction is an abstraction). Equivalent presentations
    involve closure operators, ideals, congruences, etc [[26](#CousotCousot79-1-POPL)].An
    interesting consequence of the existence of the best abstraction of concrete properties
    is the existence of best/most precise transformers, which provides guidelines
    for their [automatic] design [[17](#Cousot99-3-Marktoberdorf-paper)]. Moreover
    by abstracting fixpoints by fixpoints, static analysis is specified by an abstract
    semantics expressed in fixpoint form whereas a static analyzer is an algorithm
    for computing or overapproximating this fixpoint.There are several alternative
    formalizations in absence of best approximations [[94](#MycroftJones86-1)], [[30](#CousotCousot92-3-JLC)].
  prefs: []
  type: TYPE_NORMAL
- en: 3.6  Moore family, Closure operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the correspondance between the concrete and abstract properties is given
    by a Galois connection, then the image of the abstract properties in the concrete
    is a *Moore family*, which is the image of the concrete properties by a *closure
    operator* [[26](#CousotCousot79-1-POPL)]. The formalization of the abstraction
    by closure operators is useful to abstract away from the representation of the
    concrete properties. Other equivalent formalizations of the existence of the best
    abstraction of concrete properties include principal ideals, complete join congruences,
    etc [[26](#CousotCousot79-1-POPL)].
  prefs: []
  type: TYPE_NORMAL
- en: 3.7  Moore completion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If an abstract domains has no best approximations for some concrete properties
    its *Moore completion* is the most abstract abstract domain more expressive than
    the original abstract domain which has this property [[26](#CousotCousot79-1-POPL)].
    This introduces a Galois connection.
  prefs: []
  type: TYPE_NORMAL
- en: 3.8  Fixpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most program properties can be expressed as fixpoints of monotone or extensive
    property transformers, a property preserved by abstraction [[26](#CousotCousot79-1-POPL)].
    This reduces program analysis to fixpoint approximation and verification to fixpoint
    checking [[22](#CousotCousot77-1-POPL)].
  prefs: []
  type: TYPE_NORMAL
- en: 3.9  Inference rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most (concrete and abstract) program properties can also be expressed using
    inference rules, which indeed is equivalent to definitions using fixpoints, equations,
    constraints, etc [[34](#CousotCousot95-4-CAV)]. This point of view has the advantage
    of separating the design of an (abstract) semantics (or a static analysis) from
    its formal presentation.
  prefs: []
  type: TYPE_NORMAL
- en: 3.10  Iteration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A standard method for fixpoints construction is *iteration*. This can be extended
    to transfinite iterations to prove Tarski's fixpoint theorem [[25](#CousotCousot79-3)].
    In practice one can accelerate the fixpoint computation using appropriate iteration
    strategies formalized as chaotic/asynchronous iterations [[14](#Cousot78-1-TheseEtat)].
    This extends to higher-order [[24](#CousotCousot77-3)], [[74](#JonesRosendahl97-jflp)].
  prefs: []
  type: TYPE_NORMAL
- en: 3.11  Convergence acceleration by widening/narrowing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Convergence acceleration is mandatory in infinite abstract domains in which
    the iterative computation of abstract fixpoints may diverge. Widenings/narrowings
    and their duals are universal methods to do so [[22](#CousotCousot77-1-POPL),[14](#Cousot78-1-TheseEtat)].
    This extends to higher-order [[24](#CousotCousot77-3),[6](#Bourdoncle-FMPA93)].
  prefs: []
  type: TYPE_NORMAL
- en: 3.12  Constraint resolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thanks to Tarski's theorem, fixpoints can be re-expressed as equality or inequality
    constraints whence static analysis can be equally viewed as a fixpoint approximation
    or as a constraint resolution problem. Some constraint resolution methods are
    mere fixpoint iteration (e.g. set-based analysis [[35](#CousotCousot95-3-FPCA)]).
  prefs: []
  type: TYPE_NORMAL
- en: 3.13  Modularity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The static analysis of programs by parts [[37](#CousotCousot-CC02)]. This includes
    separate interprocedural analysis [[24](#CousotCousot77-3)].
  prefs: []
  type: TYPE_NORMAL
- en: 3.14  Abstract domain combination
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The design of abstractions can be done by parts, by choosing basic abstractions
    and then by composing them using abstract domain combinators [[26](#CousotCousot79-1-POPL)].
    This provides a unifying view on abstract domain design [[52](#FileGiacobazziRanzato96-1survey)].There
    are numerous examples of such abstract domain combinations including the *reduced
    sum*, the *reduced product* and the *reduced power* [[26](#CousotCousot79-1-POPL)].
  prefs: []
  type: TYPE_NORMAL
- en: 3.15  Refinement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The enrichment of an abstract domain so has to express in the refined domain
    properties which cannot be expressed in the original domain. Examples are the
    *Moore completion* **Sec. [3.7](#sec:Moorecompletion)**, *partitioning* [[15](#Cousot81-1-MuchnickJones),[5](#Bourdoncle92-1),[79](#MauborgneRival05-ESOP)],
    [[69](#JeannetHalbwachsRaymond-SAS-99)], the *disjunctive completion* [[26](#CousotCousot79-1-POPL)],
    [[53](#FileRanzato-TCS99)], the *Heyting completion* [[59](#GiacobazziScozzari-TOPLAS-98)],
    *complementation* [[13](#CortesiFileGiacobazziPalamidessiRanzato97)], etc.
  prefs: []
  type: TYPE_NORMAL
- en: 3.16  Completion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The refinement of an abstract domain into the most abstract abstract domain
    which is precise enough to prove a given specification [[26](#CousotCousot79-1-POPL)],
    [[93](#Mycroft93-1),[57](#GiacobazziRanzato97-amast),[58](#GiacobazziRanzatoScozzari-JACM-00),[104](#Schmidt-APLAS06)].
  prefs: []
  type: TYPE_NORMAL
- en: 3.17  Lattice of abstract interpretations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A consequence of the formalization of static analyses by Galois connections
    is that they can be organized into a complete lattice according to the partial
    order of their relative precisions [[26](#CousotCousot79-1-POPL)]. All semantics
    and analyses are present in this formally defined lattice and so it remains to
    find the useful ones, which is the real question!
  prefs: []
  type: TYPE_NORMAL
