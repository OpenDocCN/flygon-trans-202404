- en: The "Porting from C#" Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you want to port C# code to F#? In this series of posts we'll look at various
    approaches to this, and the design decisions and trade-offs involved.
  prefs: []
  type: TYPE_NORMAL
- en: '[Porting from C# to F#: Introduction](porting-to-csharp-intro.html). Three
    approaches to porting existing C# code to F#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Getting started with direct porting](porting-to-csharp-getting-started.html).
    F# equivalents to C#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Porting from C# to F#: Introduction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Porting from C# to F#: Introduction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*NOTE: Before reading this series, I suggest that you read the following series
    as a prerequisite: ["thinking functionally"](thinking-functionally.html), ["expressions
    and syntax"](expressions-and-syntax.html), and ["understanding F# types"](understanding-fsharp-types.html).*'
  prefs: []
  type: TYPE_NORMAL
- en: For many developers, the next step after learning a new language might be to
    port some existing code over to it, so that they can get a good feel for the differences
    between the two languages.
  prefs: []
  type: TYPE_NORMAL
- en: As we pointed out earlier, functional languages are very different from imperative
    languages, and so trying to do a direct port of imperative code to a functional
    language is often not possible, and even if a crude port is done successfully,
    the ported code will probably not be using the functional model to its best advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, F# is a multi-paradigm language, and includes support for object-oriented
    and imperative techniques, but even so, a direct port will generally not be the
    best way to write the corresponding F# code.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this series, we'll look at various approaches to porting existing C#
    code to F#.
  prefs: []
  type: TYPE_NORMAL
- en: Levels of porting sophistication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you recall the diagram from an [earlier post](key-concepts), there are four
    key concepts that differentiate F# from C#.
  prefs: []
  type: TYPE_NORMAL
- en: Function-oriented rather than object-oriented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressions rather than statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Algebraic types for creating domain models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching for flow of control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![four key concepts](four-concepts2.png)'
  prefs: []
  type: TYPE_IMG
- en: And, as explained in that post and its sequels, these aspects are not just academic,
    but offer concrete benefits to you as a developer.
  prefs: []
  type: TYPE_NORMAL
- en: So I have divided the porting process into three levels of sophistication (for
    lack of a better term), which represent how well the ported code exploits these
    benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic Level: Direct port'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this first level, the F# code is a direct port (where possible) of the C#
    code. Classes and methods are used instead of modules and functions, and values
    are frequently mutated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Intermediate Level: Functional code'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the next level, the F# code has been refactored to be fully functional.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and methods have been replaced by modules and functions, and values
    are generally immutable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher order functions are used to replace interfaces and inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching is used extensively for control flow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loops have been replaced with list functions such as "map" or recursion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two different paths that can get you to this level.
  prefs: []
  type: TYPE_NORMAL
- en: The first path is to do a basic direct port to F#, and then refactor the F#
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second path is to convert the existing imperative code to functional code
    while staying in C#, and only then port the functional C# code to functional F#
    code!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second option might seem clumsy, but for real code it will probably be both
    faster and more comfortable. Faster because you can use a tool such as Resharper
    to do the refactoring, and more comfortable because you are working in C# until
    the final port. This approach also makes it clear that the hard part is not the
    actual port from C# to F#, but the conversion of imperative code to functional
    code!
  prefs: []
  type: TYPE_NORMAL
- en: 'Advanced Level: Types represent the domain'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this final level, not only is the code functional, but the design itself
    has been changed to exploit the power of algebraic data types (especially union
    types).
  prefs: []
  type: TYPE_NORMAL
- en: The domain will have been [encoded into types](designing-with-types-single-case-dus.html)
    such that [illegal states are not even representable](designing-with-types-making-illegal-states-unrepresentable.html),
    and [correctness is enforced at compile time](correctness-type-checking.html).
    For a concrete demonstration of the power of this approach, see the [shopping
    cart example](designing-for-correctness) in the ["why use F#" series](why-use-fsharp.html)
    and the whole ["Designing with types" series](designing-with-types.html).
  prefs: []
  type: TYPE_NORMAL
- en: This level can only be done in F#, and is not really practical in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Porting diagram
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is a diagram to help you visualize the various porting paths described
    above.
  prefs: []
  type: TYPE_NORMAL
- en: '![four key concepts](porting-paths.png)'
  prefs: []
  type: TYPE_IMG
- en: The approach for this series
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see how these three levels work in practice, we''ll apply them to some worked
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The first example is a simple system for creating and scoring a ten-pin bowling
    game, based on the code from the well known "bowling game kata" described by "Uncle"
    Bob Martin. The original C# code has only one class and about 70 lines of code,
    but even so, it demonstrates a number of important principles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we'll look at some shopping cart code, based on [this example](designing-for-correctness.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final example is code that represents states for a subway turnstile system,
    also based on an example from Bob Martin. This example demonstrates how the union
    types in F# can represent a state transition model more easily than the OO approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But first, before we get started on the detailed examples, we'll go back to
    basics and do some simple porting of some code snippets. That will be the topic
    of the next post.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with direct porting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting started with direct porting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started on the detailed examples, we'll go back to basics and
    do some simple porting of trivial examples.
  prefs: []
  type: TYPE_NORMAL
- en: In this post and the next, we'll look at the nearest F# equivalents to common
    C# statements and keywords, to guide you when doing direct ports.
  prefs: []
  type: TYPE_NORMAL
- en: Basic syntax conversion guidelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before starting a port, you need to understand how F# syntax is different from
    C# syntax. This section presents some general guidelines for converting from one
    to another. (For a quick overview of F# syntax as a whole, see ["F# syntax in
    60 seconds"](fsharp-in-60-seconds.html))
  prefs: []
  type: TYPE_NORMAL
- en: Curly braces and indentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C# uses curly braces to indicate the start and end of a block of code. F# generally
    just uses indentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Curly braces are used in F#, but not for blocks of code. Instead, you will
    see them used:'
  prefs: []
  type: TYPE_NORMAL
- en: For definitions and usage of "record" types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conjunction with computation expressions, such as `seq` and `async`. In general,
    you will not be using these expressions for basic ports anyway.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details on the indentation rules, [see this post](fsharp-syntax).
  prefs: []
  type: TYPE_NORMAL
- en: Semicolons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike C#'s semicolon, F# does not require any kind of line or statement terminator.
  prefs: []
  type: TYPE_NORMAL
- en: Commas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: F# does not use commas for separating parameters or list elements, so remember
    not to use commas when porting!
  prefs: []
  type: TYPE_NORMAL
- en: '*For separating list elements, use semicolons rather than commas.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*For separating parameters for native F# functions, use white space.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Commas are generally only used for tuples, or for separating parameters when
    calling .NET library functions. (See [this post](defining-functions.html#tuples)
    for more on tuples vs multiple parameters)
  prefs: []
  type: TYPE_NORMAL
- en: Defining variables, functions and types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In F#, definitions of both variables and functions use the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Definitions for all types (classes, structures, interfaces, etc.) use the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The use of the `=` sign is an important difference between F# and C#. Where
    C# uses curly braces, F# uses the `=` and then the following block of code must
    be indented.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In F#, values are immutable by default. If you are doing a direct imperative
    port, you probably need to make some of the values mutable, using the `mutable`
    keyword. Then to assign to the values, use the `<-` operator, not the equals sign.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Assignment vs. testing for equality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C#, the equals sign is used for assignment, and the double equals `==` is
    used for testing equality.
  prefs: []
  type: TYPE_NORMAL
- en: However in F#, the equals sign is used for testing equality, and is also used
    to initially bind values to other values when declared,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To test for inequality, use SQL-style `<>` rather than `!=`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you accidentally use `!=` you will probably get an [error FS0020](index5.html#FS0020).
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversion example #1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With these basic guidelines in place, let's look at some real code examples,
    and do a direct port for them.
  prefs: []
  type: TYPE_NORMAL
- en: This first example has some very simple code, which we will port line by line.
    Here's the C# code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Converting "using" and "namespace"
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These keywords are straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '`using` becomes `open`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`namespace` with curly braces becomes just `namespace`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike C#, F# files do not generally declare namespaces unless they need to
    interop with other .NET code. The filename itself acts as a default namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the namespace, if used, must come before anything else, such as "open".
    This the opposite order from most C# code.
  prefs: []
  type: TYPE_NORMAL
- en: Converting the class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To declare a simple class, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that there are parentheses after the class name. These are required for
    class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: More complicated class definitions will be shown in the next example, and you
    read the [complete discussion of classes](classes.html).
  prefs: []
  type: TYPE_NORMAL
- en: Converting function/method signatures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For function/method signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: Parentheses are not needed around the parameter list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whitespace is used to separate the parameters, not commas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rather than curly braces, an equals sign signals the start of the function body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The parameters don''t normally need types but if you do need them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type name comes after the value or parameter
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameter name and type are separated by colons
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When specifying types for parameters, you should probably wrap the pair in parentheses
    to avoid unexpected behavior.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The return type for the function as a whole is prefixed by a colon, and comes
    after all the other parameters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a C# function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'and here''s the corresponding F# function signature with explicit types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: However, because F# can normally infer the parameter and return types, you rarely
    need to specify them explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a more typical F# signature, with inferred types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: void
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `void` keyword in C# is generally not needed, but if required, would be
    converted to `unit`
  prefs: []
  type: TYPE_NORMAL
- en: 'So the C# code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'could be converted to the F# code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'but again, the specific types are rarely needed, and so the F# version is just:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Converting function/method bodies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a function body, you are likely to have a combination of:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable declarations and assignments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control flow statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll have a quick look at porting each of these in turn, except for control
    flow, which we'll discuss later.
  prefs: []
  type: TYPE_NORMAL
- en: Converting variable declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Almost always, you can use `let` on its own, just like `var` in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Unlike C#, you must always assign ("bind") something to an F# value as part
    of its declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As noted above, if you need to change the value after its declaration, you must
    use the "mutable" keyword.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to specify a type for a value, the type name comes after the value
    or parameter, preceded by a colon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Converting function calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When calling a native F# function, there is no need for parentheses or commas.
    In other words, the same rules apply for calling a function as when defining it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s C# code for defining a function, then calling it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'However, because F# can normally infer the parameter and return types, you
    rarely need to specify them explicitly So here''s typical F# code for defining
    a function and then calling it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Return values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C#, you use the `return` keyword. But in F#, the last value in the block
    is automatically the "return" value.
  prefs: []
  type: TYPE_NORMAL
- en: Here's the C# code returning the `result` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And here's the F# equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is because F# is expression-based. Everything is an expression, and the
    value of a block expression as a whole is just the value of the last expression
    in the block.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on expression-oriented code, see ["expressions vs statements"](expressions-vs-statements.html).
  prefs: []
  type: TYPE_NORMAL
- en: Printing to the console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To print output in C#, you generally use `Console.WriteLine` or similar. In
    F#, you generally use `printf` or similar, which is typesafe. ([More details on
    using "printf" family](printf)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete port of example #1'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Putting it all together, here is the complete direct port of example #1 to
    F#.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The C# code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And the equivalent F# code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
