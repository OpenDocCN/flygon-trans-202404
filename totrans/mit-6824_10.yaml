- en: Consistency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6.824 2015 Lecture 10: Consistency'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Note:** These lecture notes were slightly modified from the ones posted on
    the 6.824 [course website](http://nil.csail.mit.edu/6.824/2015/schedule.html)
    from Spring 2015.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Today:** consistency'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy release consistency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using lazy consistency to get performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistency = meaning of concurrent reads and writes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less obvious than it may seem!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choice trades off between performance and programmer-friendliness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Huge factor in many designs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Today''s paper](papers/keleher-treadmarks.pdf): a case study'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many systems have storage/memory w/ concurrent readers and writers
  prefs: []
  type: TYPE_NORMAL
- en: Multiprocessors, databases, AFS, labs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You often want to improve in ways that risk changing behavior:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: add caching
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: split over multiple servers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: replicate for fault tolerance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we know if an optimization is correct?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a way to think about correct execution of distributed programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of these ideas from multiprocessors and databases 20/30 years ago
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we write correct distributed programs w/ shared storage?
  prefs: []
  type: TYPE_NORMAL
- en: Memory system promises to behave according to certain rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We write programs assuming those rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rules are a "consistency model"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contract between memory system and programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What makes a good consistency model?
  prefs: []
  type: TYPE_NORMAL
- en: There are no "right" or "wrong" models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A model may make it harder or easier to program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: i.e. lead to more or less intuitive results
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A model may be harder or easier to implement efficiently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also application dependent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: e.g. Web pages vs memory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some consistency models:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spanner: external consistency (behaves like a single machine)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Database world: strict serializability, serializability, snap-shot isolation,
    read-committed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Distributed file systems: open-to-close consistency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Computer architects: TSO (total store ordering), release consistency, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Concurrency theory: sequential consistency, linearizability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar ideas, but sometimes slightly different meaning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DSM is a good place to start to study consistency
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple interface: read and write of memory locations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistency well developed in architecture community
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Performance of DSM is limited by memory consistency
  prefs: []
  type: TYPE_NORMAL
- en: With sequential consistency, M0's write must be visible to M1 before M0 can
    execute read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise both M0 and M1 can read 0 and print "yes"
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (Second "forbidden" example)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus operations will take a while in a distributed system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And they have to be done one by one
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Treadmarks high level goals?
  prefs: []
  type: TYPE_NORMAL
- en: Better DSM performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run existing parallel code (multithreaded)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: this code already has locks
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: TreadMarks will run each thread/process on a separate machine and let it access
    the DSM.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: TreadMarks takes advantage that the code already uses locking
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What specific problems with previous DSM are they trying to fix?
  prefs: []
  type: TYPE_NORMAL
- en: '**false sharing:** two machines r/w different vars on same page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: m1 writes x, m2 writes y
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: m1 writes x, m2 just reads y
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** what does IVY do in this situation?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A:** Ivy will bounce the page between x and y back and forth'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write amplification:** a 1-byte write turns into a whole-page transfer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**First Goal:** eliminate write amplification'
  prefs: []
  type: TYPE_NORMAL
- en: don't send whole page, just written bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Big idea: write diffs (to fix write amplification)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'on M1 write fault:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tell other hosts to invalidate but *keep hidden copy*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: M1 makes hidden copy as well
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: M1 marks the page as R/W
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'on M2 read fault:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M2 asks M1 for recent modifications
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: M1 "diffs" current page against hidden copy
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: M1 send diffs to M2
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: M2 applies diffs to its hidden copy
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: M2 marks the page as read-only
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: M1 marks the page as read-only
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** Do write diffs provide sequential consistency?'
  prefs: []
  type: TYPE_NORMAL
- en: At most one writeable copy, so writes are ordered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No writing while any copy is readable, so no stale reads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readable copies are up to date, so no stale reads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Still sequentially consistent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** Do write diffs help with false sharing?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A:** No, they help with write amplification'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next goal: allow multiple readers+writers to cope with false sharing'
  prefs: []
  type: TYPE_NORMAL
- en: our solution needs to allow two machines to write the same page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=>` don''t invalidate others when a machine writes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=>` don''t demote writers to r/o when another machine reads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=>` multiple *different* copies of a page!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: which should a reader look at?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'diffs help: can merge writes to same page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: but when to send the diffs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: no invalidations -> no page faults -> what triggers sending diffs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '...so we come to *release consistency*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Big idea: (eager) release consistency (RC)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Again:* what should trigger sending diffs?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seems like we should be sending the diffs when someone reads the data that was
    changed. How can we tell someone's reading the data if we won't get a read fault
    because we did not invalidate other people's pages when it was written by one
    person?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: no-one should read data w/o holding a lock!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: so let's assume a lock server
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: send out write diffs on release (unlock)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: to *all* machines with a copy of the written page(s)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Q:** Why detect all writes since the last `unlock()` and not the last `lock()`?'
  prefs: []
  type: TYPE_NORMAL
- en: '**A:** See causal consistency discussion below.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 (RC and false sharing)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What does RC do?
  prefs: []
  type: TYPE_NORMAL
- en: M0 and M1 both get cached writeable copy of the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: when they release, each computes diffs against original page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M1`''s `a1` causes it to wait until `M0`''s `r1` release'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: so M1 will see M0's writes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** What is the performance benefit of RC?'
  prefs: []
  type: TYPE_NORMAL
- en: What does IVY do with Example 1?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if `x` and `y` are on the same page, page is bounced back between `M0` and `M1`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: multiple machines can have copies of a page, even when 1 or more writes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=>` no bouncing of pages due to false sharing'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=>` read copies can co-exist with writers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** Is RC sequentially consistent? No!'
  prefs: []
  type: TYPE_NORMAL
- en: in SC, a read sees the latest write
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M1 won't see M0's writes until M0 releases a lock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: i.e. M1 can see a stale copy of x, which wasn't allowed under seq const
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: so machines can temporarily disagree on memory contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'if you always lock:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: locks force order `->` no stale reads `->` like sequential consistency
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** What if you don''t lock?'
  prefs: []
  type: TYPE_NORMAL
- en: Reads can return stale data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent writes to same var -> trouble
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** Does RC make sense without write diffs?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Probably not: diffs needed to reconcile concurrent writes to same page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Big idea: lazy release consistency (LRC)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: one problem is that when we `unlock()` we update everybody, but not everyone
    might need the changed data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: only send write diffs to next acquirer of released lock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (i.e. when someone calls `lock()` and they need updates to the data)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'lazier than RC in two ways:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: release does nothing, so maybe defer work to future release
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: sends write diffs just to acquirer, not everyone
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Example 2 (lazyness)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What does LRC do?
  prefs: []
  type: TYPE_NORMAL
- en: M2 asks the lock manager who the previous holder of lock 1 was
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: it was M1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: M2 only asks previous holder of lock 1 for write diffs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: M2 does not see M1's modification to `y`, even though on same page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: because it did not acquire lock 2 using `a2`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What does RC do?
  prefs: []
  type: TYPE_NORMAL
- en: RC would have broadcast all changes on `x` and `y` to everyone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does IVY do?
  prefs: []
  type: TYPE_NORMAL
- en: IVY would invalidate pages and ensure only the writer has a write-only copy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: on reads, the written page is turned to read only and the data is fetched by
    the readers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** What''s the performance win from LRC?'
  prefs: []
  type: TYPE_NORMAL
- en: if you don't acquire lock on object, you don't see updates to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=>` if you use just some vars on a page, you don''t see writes to others'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=>` less network traffic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** Does LRC provide the same consistency model as RC?'
  prefs: []
  type: TYPE_NORMAL
- en: '**No!** LRC hides some writes that RC reveals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: if you use locks correctly, then you should not notice the differences
    between (E)RC and LRC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: in above example, RC reveals `y=1` to M2, LRC does not reveal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: because RC broadcasts changes on a lock release
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'so `"M2: print x, y"` might print fresh data for RC, stale for LRC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: depends on whether print is before/after M1's release
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** Is LRC a win over IVY if each variable on a separate page?'
  prefs: []
  type: TYPE_NORMAL
- en: IVY doesn't move data until the program tries to read it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So Ivy is pretty lazy already
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Robert: TreadMarks is only worth it pages are big'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or a win over IVY plus write diffs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we think all threaded/locking code will work with LRC?
  prefs: []
  type: TYPE_NORMAL
- en: Do all programs lock every shared variable they read?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paper doesn't quite say, but strongly implies "no"!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example 3 (causal anomaly)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What's the potential problem here?
  prefs: []
  type: TYPE_NORMAL
- en: Counter-intuitive that M2 might see y=1 but x=0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: because M2 didn't acquire lock 1, it could not get the changes to `x`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A violation of "causal consistency":'
  prefs: []
  type: TYPE_NORMAL
- en: If write W1 contributed to write W2, everyone sees W1 before W2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example 4 (there''s an argument that this is *natural cod*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In example 4, it's not clear if M2 will learn from M1 the writes that M0 also
    did and contributed to `y=&x`.
  prefs: []
  type: TYPE_NORMAL
- en: for instance, if `x` was 1 before it was changed by M0, will M2 see this when
    it prints `*z`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TreadMarks provides **causal consistency**:'
  prefs: []
  type: TYPE_NORMAL
- en: when you acquire a lock,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: you see all writes by previous holder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and all writes previous holder saw
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to track what writes contributed to a write?
  prefs: []
  type: TYPE_NORMAL
- en: Number each machine's releases -- "interval" numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each machine tracks highest write it has seen from each other machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'highest write = the interval # of the last write that machine is aware of'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a "Vector Timestamp"
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tag each release with current VT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On acquire, tell previous holder your VT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: difference indicates which writes need to be sent
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: (annotate previous example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: when can you throw diffs away?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: seems like you need to globally know what everyone knows about
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: see "Garbage Collection" section from paper
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VTs order writes to same variable by different machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How does M2 know what to do?
  prefs: []
  type: TYPE_NORMAL
- en: Could the VTs for two values of the same variable not be ordered?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Summary of programmer rules / system guarantees
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each shared variable protected by some lock
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lock before writing a shared variable to order writes to same var., otherwise
    "latest value" not well defined
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lock before reading a shared variable to get the latest version
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no lock for read, guaranteed to see values that contributed to the variables
    you did lock
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Example of when LRC might work too hard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: TreadMarks will send `z` to M1, because it comes before `x=1` in VT order.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming x and z are on the same page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if on different pages, M1 must invalidate z's page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But M1 doesn't use z.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How could a system understand that z isn't needed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Require locking of all data you read
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=>` Relax the causal part of the LRC model'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Q:** Could TreadMarks work without using VM page protection?'
  prefs: []
  type: TYPE_NORMAL
- en: it uses VM to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: detect writes to avoid making hidden copies (for diffs) if not needed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: detect reads to pages => know whether to fetch a diff
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: neither is really crucial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: so TM doesn't depend on VM as much as IVY does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IVY used VM faults to decide what data has to be moved, and when
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: TM uses acquire()/release() and diffs for that purpose
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Figure 3 shows mostly good scaling
  prefs: []
  type: TYPE_NORMAL
- en: is that the same as "good"?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: though apparently Water does lots of locking / sharing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How close are they to best possible performance?
  prefs: []
  type: TYPE_NORMAL
- en: maybe Figure 5 implies there is only about 20% fat to be cut
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does LRC beat previous DSM schemes?
  prefs: []
  type: TYPE_NORMAL
- en: they only compare against their own straw-man eager realease consistency (ERC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: not against best known prior work
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 9 suggests not much win, even for Water
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has DSM been successful?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: clusters of cooperating machines are hugely successful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DSM not so much
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: main justification is transparency for existing threaded code
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: that's not interesting for new apps
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: and transparency makes it hard to get high performance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: MapReduce or message-passing or shared storage more common than DSM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
