- en: 'Reading 17: Regular Expressions & Grammars'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software in 6.005
  id: totrans-1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
- en: Objectives
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After today’s class, you should:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Understand the ideas of grammar productions and regular expression operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to read a grammar or regular expression and determine whether it matches
    a sequence of characters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be able to write a grammar or regular expression to match a set of character
    sequences and parse them into a data structure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Today’s reading introduces several ideas:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: grammars, with productions, nonterminals, terminals, and operators
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: regular expressions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: parser generators
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some program modules take input or produce output in the form of a sequence
    of bytes or a sequence of characters, which is called a *string* when it’s simply
    stored in memory, or a *stream* when it flows into or out of a module. In today’s
    reading, we talk about how to write a specification for such a sequence. Concretely,
    a sequence of bytes or characters might be:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: A file on disk, in which case the specification is called the *file format*
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages sent over a network, in which case the specification is a *wire protocol*
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A command typed by the user on the console, in which case the specification
    is a *command line interface*
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string stored in memory
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For these kinds of sequences, we introduce the notion of a *grammar*, which
    allows us not only to distinguish between legal and illegal sequences, but also
    to parse a sequence into a data structure that a program can work with. The data
    structure produced from a grammar will often be a recursive data type like we
    talked about in the [recursive data type reading](../16-recursive-data-types/).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: We also talk about a specialized form of a grammar called a *regular expression*.
    In addition to being used for specification and parsing, regular expressions are
    a widely-used tool for many string-processing tasks that need to disassemble a
    string, extract information from it, or transform it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The next reading will talk about parser generators, a kind of tool that translate
    a grammar automatically into a parser for that grammar.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Grammars
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To describe a sequence of symbols, whether they are bytes, characters, or some
    other kind of symbol drawn from a fixed set, we use a compact representation called
    a *grammar*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: A *grammar* defines a set of sentences, where each *sentence* is a sequence
    of symbols. For example, our grammar for URLs will specify the set of sentences
    that are legal URLs in the HTTP protocol.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The symbols in a sentence are called *terminals* (or tokens).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: They’re called terminals because they are the leaves of a tree that represents
    the structure of the sentence. They don’t have any children, and can’t be expanded
    any further. We generally write terminals in quotes, like `'http'` or `':'`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: A grammar is described by a set of *productions*, where each production defines
    a *nonterminal*. You can think of a nonterminal like a variable that stands for
    a set of sentences, and the production as the definition of that variable in terms
    of other variables (nonterminals), operators, and constants (terminals). Nonterminals
    are internal nodes of the tree representing a sentence.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: A production in a grammar has the form
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: nonterminal ::= expression of terminals, nonterminals, and operators
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In 6.005, we will name nonterminals using lowercase identifiers, like `x` or
    `y` or `url`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: One of the nonterminals of the grammar is designated as the *root*. The set
    of sentences that the grammar recognizes are the ones that match the root nonterminal.
    This nonterminal is often called `root` or `start`, but in the grammars below
    we will typically choose more memorable names like `url`, `html`, and `markdown`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Grammar Operators
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The three most important operators in a production expression are:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: concatenation
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: repetition
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: union (also called alternation)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also use additional operators which are just syntactic sugar (i.e.,
    they’re equivalent to combinations of the big three operators):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: option (0 or 1 occurrence)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 1+ repetition (1 or more occurrences)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: character classes
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By convention, the operators `*`, `?`, and `+` have highest precedence, which
    means they are applied first. Alternation `|` has lowest precedence, which means
    it is applied last. Parentheses can be used to override this precedence, so that
    a sequence or alternation can be repeated:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: grouping using parentheses
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: reading exercises
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Reading a Grammar 1
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this grammar:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Reading a Grammar 2
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Reading a Grammar 3
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Reading a Grammar 4
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: URL'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose we want to write a grammar that represents URLs. Let’s build up a grammar
    gradually by starting with simple examples and extending the grammar as we go.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple URL:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A grammar that represents the set of sentences containing *only this URL* would
    look like:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But let’s generalize it to capture other domains, as well:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can write this as one line, like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This grammar represents the set of all URLs that consist of just a two-part
    hostname, where each part of the hostname consists of 1 or more letters. So `http://mit.edu/`
    and `http://yahoo.com/` would match, but not `http://ou812.com/`. Since it has
    only one nonterminal, a *parse tree* for this URL grammar would look like the
    picture on the right.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'In this one-line form, with a single nonterminal whose production uses only
    operators and terminals, a grammar is called a *regular expression* (more about
    that later). But it will be easier to understand if we name the parts using new
    nonterminals:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![the parse tree produced by parsing ''http://mit.edu'' with a grammar with
    url, hostname, and word nonterminals](http://web.mit.edu/6.005/www/fa16/classes/17-regex-grammarsfigures/url-with-hostname.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The parse tree for this grammar is now shown at right. The tree has more structure
    now. The leaves of the tree are the parts of the string that have been parsed.
    If we concatenated the leaves together, we would recover the original string.
    The `hostname` and `word` nonterminals are labeling nodes of the tree whose subtrees
    match those rules in the grammar. Notice that the immediate children of a nonterminal
    node like `hostname` follow the pattern of the `hostname` rule, `word '.' word`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'How else do we need to generalize? Hostnames can have more than two components,
    and there can be an optional port number:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To handle this kind of string, the grammar is now:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![the parse tree produced by parsing ''http://mit.edu'' with a grammar with
    a recursive hostname rule](http://web.mit.edu/6.005/www/fa16/classes/17-regex-grammarsfigures/url-with-recursive-hostname.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Notice how hostname is now defined recursively in terms of itself.* Which
    part of the hostname definition is the base case, and which part is the recursive
    step? What kinds of hostnames are allowed?'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the repetition operator, we could also write hostname like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Another thing to observe is that this grammar allows port numbers that are not
    technically legal, since port numbers can only range from 0 to 65535\. We could
    write a more complex definition of port that would allow only these integers,
    but that’s not typically done in a grammar. Instead, the constraint 0 <= port
    <= 65535 would be specified alongside the grammar.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more things we should do to go farther:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: generalizing `http` to support the additional protocols that URLs can have
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: generalizing the `/` at the end to a slash-separated path
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: allowing hostnames with the full set of legal characters instead of just a-z
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: reading exercises
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Writing a Grammar
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want the `url` grammar to also match strings of the form:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'but not strings of the form:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So we change the grammar to:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Markdown and HTML'
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s look at grammars for some file formats. We’ll be using two different
    markup languages that represent typographic style in text. Here they are:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Markdown
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: HTML
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For simplicity, our example HTML and Markdown grammars will only specify italics,
    but other text styles are of course possible.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the grammar for our simplified version of Markdown:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![a parse tree produced by the Markdown grammar](http://web.mit.edu/6.005/www/fa16/classes/17-regex-grammarsfigures/markdown.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here’s the grammar for our simplified version of HTML:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![a parse tree produced by the HTML grammar](http://web.mit.edu/6.005/www/fa16/classes/17-regex-grammarsfigures/html.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: reading exercises
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recursive Grammars
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Look at the `markdown` and `html` grammars above, and compare their `italic`
    productions. Notice that not only do they differ in delimiters (`_` in one case,
    `< >` tags in the other), but also in the nonterminal that is matched between
    those delimiters. One grammar is recursive; the other grammar is not.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: For each string below, if you match the specified grammar against it, which
    letters are inside matches to the `italic` nonterminal? Your answer should be
    some subset of the letters `abcde`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Regular Expressions
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *regular* grammar has a special property: by substituting every nonterminal
    (except the root one) with its righthand side, you can reduce it down to a single
    production for the root, with only terminals and operators on the right-hand side.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Our URL grammar was regular. By replacing nonterminals with their productions,
    it can be reduced to a single expression:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The Markdown grammar is also regular:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But our HTML grammar can’t be reduced completely. By substituting righthand
    sides for nonterminals, you can eventually reduce it to something like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: …but the recursive use of `html` on the righthand side can’t be eliminated,
    and can’t be simply replaced by a repetition operator either. So the HTML grammar
    is not regular.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The reduced expression of terminals and operators can be written in an even
    more compact form, called a *regular expression*. A regular expression does away
    with the quotes around the terminals, and the spaces between terminals and operators,
    so that it consists just of terminal characters, parentheses for grouping, and
    operator characters. For example, the regular expression for our `markdown` format
    is just
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Regular expressions are also called *regexes* for short. A regex is far less
    readable than the original grammar, because it lacks the nonterminal names that
    documented the meaning of each subexpression. But a regex is fast to implement,
    and there are libraries in many programming languages that support regular expressions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'The regex syntax commonly implemented in programming language libraries has
    a few more special operators, in addition to the ones we used above in grammars.
    Here’s are some common useful ones:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Using backslashes is important whenever there are terminal characters that
    would be confused with special characters. Because our `url` regular expression
    has `.` in it as a terminal, we need to use a backslash to escape it:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: reading exercises
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Regular Expressions
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following regular expression:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Using regular expressions in Java
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regular expressions (“regexes”) are widely used in programming, and you should
    have them in your toolbox.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: In Java, you can use regexes for manipulating strings (see [`String.split`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-),
    [`String.matches`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#matches-java.lang.String-),
    [`java.util.regex.Pattern`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html)).
    They’re built-in as a first-class feature of modern scripting languages like Python,
    Ruby, and Javascript, and you can use them in many text editors for find and replace.
    Regular expressions are your friend! Most of the time. Here are some examples.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace all runs of spaces with a single space:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Match a URL:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Extract part of an HTML tag:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice the backslashes in the URL and HTML tag examples. In the URL example,
    we want to match a literal period `.`, so we have to first escape it as `\.` to
    protect it from being interpreted as the regex match-any-character operator, and
    then we have to further escape it as `\\.` to protect the backslash from being
    interpreted as a Java string escape character. In the HTML example, we have to
    escape the quote mark `"` as `\"` to keep it from ending the string. The frequency
    of backslash escapes makes regexes still less readable.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using regexes in Java
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the shortest regex you can to remove single-word, lowercase-letter-only
    HTML tags from a string:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If the desired output is `"The Good, the Bad, and the Ugly"`, what is shortest
    regex you can put in place of TODO? You may find it useful to [run this example
    in the Online Python Tutor](http://www.pythontutor.com/java.html#code=public+class+Regex+%7B%0A++++public+static+void+main(String%5B%5D+args%29+%7B%0A++++++++String+input+%3D+%22The+%3Cb%3EGood%3C/b%3E,+the+%3Ci%3EBad%3C/i%3E,+and+the+%3Cstrong%3EUgly%3C/strong%3E%22%3B+%0A++++++++String+regex+%3D+%22TODO%22%3B%0A++++++++String+output+%3D+input.replaceAll(regex,+%22%22%29%3B%0A++++++++System.out.println(output%29%3B%0A++++%7D%0A%7D&mode=edit&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Context-Free Grammars
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, a language that can be expressed with our system of grammars is
    called context-free. Not all context-free languages are also regular; that is,
    some grammars can’t be reduced to single nonrecursive productions. Our HTML grammar
    is context-free but not regular.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The grammars for most programming languages are also context-free. In general,
    any language with nested structure (like nesting parentheses or braces) is context-free
    but not regular. That description applies to the Java grammar, shown here in part:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言的语法也是上下文无关的。通常，任何具有嵌套结构的语言（如嵌套括号或大括号）都是上下文无关的，但不是正则的。该描述适用于 Java 语法，此处部分显示：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Machine-processed textual languages are ubiquitous in computer science. Grammars
    are the most popular formalism for describing such languages, and regular expressions
    are an important subclass of grammars that can be expressed without recursion.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，机器处理的文本语言无处不在。语法是描述这种语言的最流行形式，而正则表达式是语法的一个重要子类，可以在没有递归的情况下表示。
- en: 'The topics of today’s reading connect to our three properties of good software
    as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 今天阅读的主题与我们对好软件的三个特性有关，如下：
- en: '**Safe from bugs.** Grammars and regular expressions are declarative specifications
    for strings and streams, which can be used directly by libraries and tools. These
    specifications are often simpler, more direct, and less likely to be buggy then
    parsing code written by hand.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免受错误的影响**。语法和正则表达式是字符串和流的声明性规范，可以直接由库和工具使用。这些规范通常更简单、更直接，而且不太可能出错，与手工编写的解析代码相比。'
- en: '**Easy to understand.** A grammar captures the shape of a sequence in a form
    that is easier to understand than hand-written parsing code. Regular expressions,
    alas, are often not easy to understand, because they are a one-line reduced form
    of what might have been a more understandable regular grammar.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于理解**。语法捕捉了序列的形状，以一种比手写解析代码更易于理解的形式。不幸的是，正则表达式通常不容易理解，因为它们是可能更易于理解的正则语法的一行简化形式。'
- en: '**Ready for change.** A grammar can be easily edited, but regular expressions,
    unfortunately, are much harder to change, because a complex regular expression
    is cryptic and hard to understand.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于更改**。语法可以很容易地编辑，但是正则表达式，不幸的是，要改变就难得多，因为复杂的正则表达式晦涩难懂。'
