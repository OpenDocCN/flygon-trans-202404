- en: Denotational Explanation of RecursionTuesday, February 14th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note: This explanation is similar to the one you can find in “The Little Schemer”
    called “(Y Y) Works!”, by Dan Friedman and Matthias Felleisen.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The explanation that we have now for how to derive the `make-recursive` definition
    is fine — after all, we did manage to get it working. But this explanation was
    done from a kind of an operational point of view: we knew a certain trick that
    can make things work and we pushed things around until we got it working like
    we wanted. Instead of doing this, we can re-approach the problem from a more declarative
    point of view.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, start again from the same broken code that we had (using the broken-scope
    language):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is as broken as it was when we started: the occurrence of `fact` in the
    body of the function is free, which means that this code is meaningless. To avoid
    the compilation error that we get when we run this code, we can substitute *anything*
    for that `fact` — it’s even better to use a replacement that will lead to a runtime
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will not work in a similar way to the original one — but there
    is one case where it *does* work: when the input value is `0` (since then we do
    not reach the bogus application). We note this by calling this function `fact0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have this function defined, we can use it to write `fact1` which
    is the factorial function for arguments of `0` or `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And remember that this is actually just shorthand for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can continue in this way and write `fact2` that will work for n<=2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'or, in full form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we continue this way, we *will* get the true factorial function, but the
    problem is that to handle *any* possible integer argument, it will have to be
    an infinite definition! Here is what it is supposed to look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The true factorial function is `fact-infinity`, with an infinite size. So, we’re
    back at the original problem…
  prefs: []
  type: TYPE_NORMAL
- en: 'To help make things more concise, we can observe the repeated pattern in the
    above, and extract a function that abstracts this pattern. This function is the
    same as the `fact-core` that we have seen previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'which is actually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Do this a little differently — rewrite `fact0` as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, `fact1` is written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'and so on, until the real factorial, which is still infinite at this stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, look at that `(lambda (mk) ...)` — it is an infinite expression, but for
    every actual application of the resulting factorial function we only need a finite
    number of `mk` applications. We can guess how many, and as soon as we hit an application
    of `777` we know that our guess is too small. So instead of `777`, we can try
    to use the maker function to create and use the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things more explicit, here is the expression that is our `fact0`, without
    the definition form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This function has a very low guess — it works for 0, but with 1 it will run
    into the `777` application. At this point, we want to somehow invoke `mk` again
    to get the next level — and since `777` *does* get applied, we can just replace
    it with `mk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting function works just the same for an input of `0` because it does
    not attempt a recursive call — but if we give it `1`, then instead of running
    into the error of applying `777`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'we get to apply `fact-core` there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'and this is still wrong, because `fact-core` expects a function as an input.
    To see what happens more clearly, write `fact-core` explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is in what we’re going to pass into `fact-core` — its `fact` argument
    will not be the factorial function, but the `mk` function constructor. Renaming
    the `fact` argument as `mk` will make this more obvious (but not change the meaning):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It should now be obvious that this application of `mk` will not work, instead,
    we need to apply it on some function and *then* apply the result on `(- n 1)`.
    To get what we had before, we can use `777` as a bogus function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow one recursive call — so the definition works for both inputs
    of `0` and `1` — but not more. But that `777` is used as a maker function now,
    so instead, we can just use `mk` itself again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is a *working* version of the real factorial function, so make it
    into a (non-magical) definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: But we’re not done — we “broke” into the factorial code to insert that `(mk
    mk)` application — that’s why we dragged in the actual value of `fact-core`. We
    now need to fix this. The expression on that last line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'is close enough — it is `(fact-core (mk mk))`. So we can now try to rewrite
    our `fact` as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '… and would fail in a familiar way! If it’s not familiar enough, just rename
    all those `mk`s as `x`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve run into the eagerness of our language again, as we did before. The solution
    is the same — the `(x x)` is the factorial function, so protect it as we did before,
    and we have a working version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest should not be surprising now… Abstract the recursive making bit in
    a new `make-recursive` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'and now we can do the first reduction inside `make-recursive` and write the
    `fact-core` expression explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: and this is the same code we had before.
  prefs: []
  type: TYPE_NORMAL
