- en: The Elm Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elm 架构
- en: The Elm Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elm 架构
- en: The Elm Architecture is a simple pattern for architecting webapps. It is great
    for modularity, code reuse, and testing. Ultimately, it makes it easy to create
    complex web apps that stay healthy as you refactor and add features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Elm 架构是一种用于构建 web 应用程序的简单模式。它非常适合模块化、代码重用和测试。最终，它使得创建复杂的 web 应用程序变得容易，而且在重构和添加功能时保持健康。
- en: This architecture seems to emerge naturally in Elm. We first observed it in
    the games the Elm community was making. Then in web apps like [TodoMVC](https://github.com/evancz/elm-todomvc)
    and [dreamwriter](https://github.com/rtfeldman/dreamwriter#dreamwriter) too. Now
    we see it running in production at companies like [NoRedInk](https://www.noredink.com/)
    and [Pivotal](https://www.pivotaltracker.com/blog/Elm-pivotal-tracker/). The architecture
    seems to be a consequence of the design of Elm itself, so it will happen to you
    whether you know about it or not. This has proven to be really nice for onboarding
    new developers. Their code just turns out well-architected. It is kind of spooky.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构在 Elm 中似乎是自然而然地出现的。我们最初在 Elm 社区制作的游戏中观察到它。然后在像[TodoMVC](https://github.com/evancz/elm-todomvc)和[dreamwriter](https://github.com/rtfeldman/dreamwriter#dreamwriter)这样的
    web 应用程序中也看到了它。现在我们看到它在像[NoRedInk](https://www.noredink.com/)和[Pivotal](https://www.pivotaltracker.com/blog/Elm-pivotal-tracker/)这样的公司中运行。这种架构似乎是
    Elm 本身设计的结果，所以无论你是否了解它，它都会发生在你身上。这已经被证明对新开发人员的培训非常有帮助。他们的���码总是结构良好的。这有点神奇。
- en: So The Elm Architecture is *easy* in Elm, but it is useful in any front-end
    project. In fact, projects like Redux have been inspired by The Elm Architecture,
    so you may have already seen derivatives of this pattern. Point is, even if you
    ultimately cannot use Elm at work yet, you will get a lot out of using Elm and
    internalizing this pattern.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 Elm 架构在 Elm 中是*简单*的，但在任何前端项目中都很有用。事实上，像 Redux 这样的项目受到了 Elm 架构的启发，所以你可能已经看到了这种模式的衍生物。重点是，即使你最终还不能在工作中使用
    Elm，你也会从使用 Elm 和内化这种模式中获益良多。
- en: The Basic Pattern
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本模式
- en: 'The logic of every Elm program will break up into three cleanly separated parts:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Elm 程序的逻辑都会分为三个清晰分离的部分：
- en: '**Model** — the state of your application'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型** — 应用程序的状态'
- en: '**Update** — a way to update your state'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新** — 更新状态的一种方式'
- en: '**View** — a way to view your state as HTML'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图** — 将状态显示为 HTML 的一种方式'
- en: This pattern is so reliable that I always start with the following skeleton
    and fill in details for my particular case.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式是如此可靠，以至于我总是从以下骨架开始，然后为我的特定情况填充细节。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That is really the essence of The Elm Architecture! We will proceed by filling
    in this skeleton with increasingly interesting logic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的是 Elm 架构的精髓！我们将通过逐渐填充这个骨架来添加越来越有趣的逻辑。
- en: User Input
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户输入
- en: The Elm Architecture + User Input
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elm 架构 + 用户输入
- en: 'Your web app is going to need to deal with user input. This section will get
    you familiar with The Elm Architecture in the context of things like:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 web 应用程序将需要处理用户输入。本节将让你熟悉 Elm 架构在诸如以下情况下的上下文中：
- en: Buttons
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮
- en: Text Fields
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本字段
- en: Check Boxes
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复选框
- en: Radio Buttons
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单选按钮
- en: etc.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等。
- en: We will go through a few examples that build knowledge gradually, so go in order!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步介绍一些逐渐构建知识的例子，所以按顺序进行！
- en: Follow Along
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟随
- en: In the last section we used `elm-repl` to get comfortable with Elm expressions.
    In this section, we are switching to creating Elm files of our own. You can do
    that in [the online editor](http://elm-lang.org/try), or if you have Elm [installed](install.html),
    you can follow [these simple instructions](https://github.com/evancz/elm-architecture-tutorial#run-the-examples)
    to get everything working on your computer!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用 `elm-repl` 来熟悉 Elm 表达式。在本节中，我们将转而创建我们自己的 Elm 文件。你可以在[在线编辑器](http://elm-lang.org/try)中进行操作，或者如果你已经[安装](install.html)了
    Elm，你可以按照[这些简单的说明](https://github.com/evancz/elm-architecture-tutorial#run-the-examples)在你的计算机上让一切正常运行！
- en: Buttons
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮
- en: Buttons
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮
- en: '* * *'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[Clone the code](https://github.com/evancz/elm-architecture-tutorial/) or follow
    along in the [online editor](http://elm-lang.org/examples/buttons).'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[克隆代码](https://github.com/evancz/elm-architecture-tutorial/)或在[在线编辑器](http://elm-lang.org/examples/buttons)中跟随。'
- en: '* * *'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Our first example is a simple counter that can be incremented or decremented.
    I find that it can be helpful to see the entire program in one place, so here
    it is! We will break it down afterwards.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子是一个简单的计数器，可以递增或递减。我发现将整个程序放在一个地方可能会有所帮助，所以这里就是！之后我们将逐步分解它。
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That's everything!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这些了！
- en: '**Note:** This section has `type` and `type alias` declarations. You can read
    all about these in the upcoming section on [types](http://guide.elm-lang.org/types/index.html).
    You do not *need* to deeply understand that stuff now, but you are free to jump
    ahead if it helps.'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** 这一部分有 `type` 和 `type alias` 声明。您可以在即将到来的关于[类型](http://guide.elm-lang.org/types/index.html)的部分中阅读有关这些的所有内容。现在您不*需要*深入理解这些内容，但如果有帮助，您可以提前跳过。'
- en: When writing this program from scratch, I always start by taking a guess at
    the model. To make a counter, we at least need to keep track of a number that
    is going up and down. So let's just start with that!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当从头开始编写这个程序时，我总是先猜测模型。要制作一个计数器，我们至少需要跟踪一个上升和下降的数字。所以让我们从那开始！
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have a model, we need to define how it changes over time. I always
    start my `UPDATE` section by defining a set of messages that we will get from
    the UI:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个模型，我们需要定义它随时间如何变化。我总是从定义我们将从 UI 获取的一组消息开始我的 `UPDATE` 部分：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I definitely know the user will be able to increment and decrement the counter.
    The `Msg` type describes these capabilities as *data*. Important! From there,
    the `update` function just describes what to do when you receive one of these
    messages.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我确信用户能够增加和减少计数器。`Msg` 类型描述了这些功能作为*数据*。重要！从这里开始，`update` 函数只描述了当接收到这些消息时该做什么。
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you get an `Increment` message, you increment the model. If you get a `Decrement`
    message, you decrement the model. Pretty straight-forward stuff.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到 `Increment` 消息，则增加模型。如果收到 `Decrement` 消息，则减少模型。非常直截了当的事情。
- en: 'Okay, so that''s all good, but how do we actually make some HTML and show it
    on screen? Elm has a library called `elm-lang/html` that gives you full access
    to HTML5 as normal Elm functions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那一切都很好，但我们如何实际制作一些 HTML 并在屏幕上显示它？Elm 有一个名为 `elm-lang/html` 的库，它让您可以像普通 Elm
    函数一样完全访问 HTML5：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see more examples of basic HTML [here](http://elm-lang.org/examples).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到更多基本 HTML 的例子 [here](http://elm-lang.org/examples)。
- en: One thing to notice is that our `view` function is producing a `Html Msg` value.
    This means that it is a chunk of HTML that can produce `Msg` values. And when
    you look at the definition, you see the `onClick` attributes are set to give out
    `Increment` and `Decrement` values. These will get fed directly into our `update`
    function, driving our whole app forward.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，我们的 `view` 函数生成了一个 `Html Msg` 值。这意味着它是一个可以生成 `Msg` 值的 HTML 块。当您查看定义时，您会看到
    `onClick` 属性设置为发出 `Increment` 和 `Decrement` 值。这些值将直接传递到我们的 `update` 函数中，推动整个应用程序向前发展。
- en: Another thing to notice is that `div` and `button` are just normal Elm functions.
    These functions take (1) a list of attributes and (2) a list of child nodes. It
    is just HTML with slightly different syntax. Instead of having `<` and `>` everywhere,
    we have `[` and `]`. We have found that folks who can read HTML have a pretty
    easy time learning to read this variation. Okay, but why not have it be *exactly*
    like HTML? **Since we are using normal Elm functions, we have the full power of
    the Elm programming language to help us build our views!** We can refactor repetitive
    code out into functions. We can put helpers in modules and import them just like
    any other code. We can use the same testing frameworks and libraries as any other
    Elm code. Everything that is nice about programming in Elm is 100% available to
    help you with your view. No need for a hacked together templating language!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的是，`div` 和 `button` 只是普通的 Elm 函数。这些函数接受（1）属性列表和（2）子节点列表。它只是具有稍微不同语法的
    HTML。我们不是到处都有 `<` 和 `>`，而是有 `[` 和 `]`。我们发现那些能够阅读 HTML 的人很容易学会阅读这种变体。好吧，但为什么不让它*完全*像
    HTML 呢？**因为我们使用普通的 Elm 函数，我们有 Elm 编程语言的全部功能来帮助我们构建视图！**我们可以将重复的代码重构为函数。我们可以将辅助函数放在模块中，并像任何其他代码一样导入它们。我们可以使用与任何其他
    Elm 代码相同的测试框架和库。编程 Elm 的所有优点都可以帮助您处理视图。不需要一个拼凑在一起的模板语言！
- en: There is also something a bit deeper going on here. **The view code is entirely
    declarative**. We take in a `Model` and produce some `Html`. That is it. There
    is no need to mutate the DOM manually, Elm takes care of that behind the scenes.
    This gives Elm [much more freedom to make clever optimizations](http://elm-lang.org/blog/blazing-fast-html)
    and ends up making rendering *faster* overall. So you write less code and the
    code runs faster. The best kind of abstraction!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些更深层次的东西。**视图代码完全是声明式的**。我们输入一个 `Model` 并生成一些 `Html`。就是这样。不需要手动更改 DOM，Elm
    在幕后会处理这些。这使得 Elm 有了更多的自由来进行聪明的优化，并最终使渲染*更快*。所以你写的代码更少，而且代码运行更快。这是最好的抽象！
- en: 'This pattern is the essence of The Elm Architecture. Every example we see from
    now on will be a slight variation on this basic pattern: `Model`, `update`, `view`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式是 Elm 架构的精髓。从现在开始，我们看到的每个示例都将是对这个基本模式的微小变化：`Model`、`update`、`view`。
- en: '**Exercise:** One cool thing about The Elm Architecture is that it is super
    easy to extend as our product requirements change. Say your product manager has
    come up with this amazing "reset" feature. A new button that will reset the counter
    to zero.'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**练习：**关于 Elm 架构的一个很酷的事情是，随着我们的产品需求的变化，扩展起来非常容易。假设您的产品经理想出了这个惊人的“重置”功能。一个新按钮，可以将计数器重置为零。'
- en: ''
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To add the feature you come back to the `Msg` type and add another possibility:
    `Reset`. You then move on to the `update` function and describe what happens when
    you get that message. Finally you add a button in your view.'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要添加该功能，您回到 `Msg` 类型并添加另一个可能性：`Reset`。然后，您继续 `update` 函数，并描述当您收到该消息时发生的情况。最后，在您的视图中添加一个按钮。
- en: ''
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See if you can implement the "reset" feature!
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 看看你能否实现“重置”功能！
- en: Text Fields
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本字段
- en: Text Fields
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本字段
- en: '* * *'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[Clone the code](https://github.com/evancz/elm-architecture-tutorial/) or follow
    along in the [online editor](http://elm-lang.org/examples/field).'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[克隆代码](https://github.com/evancz/elm-architecture-tutorial/)或在[在线编辑器](http://elm-lang.org/examples/field)中跟随。'
- en: '* * *'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: We are about to create a simple app that reverses the contents of a text field.
    This example also introduces some new stuff that will help us out in our next
    example.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建一个简单的应用程序来颠倒文本字段的内容。这个示例还介绍了一些新东西，将在我们的下一个示例中帮助我们。
- en: Again this is a pretty short program, so I have included the whole thing here.
    Skim through to get an idea of how everything fits together. Right after that
    we will go into much more detail!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这是一个相当简短的程序，所以我在这里包含了整个内容。浏览一下，了解一下所有内容是如何组合在一起的。接下来我们将会更加详细地讨论！
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code is a slight variant of the counter from the previous section. You
    set up a model. You define some messages. You say how to `update`. You make your
    `view`. The difference is just in how we filled this skeleton in. Let's walk through
    that!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是前一节的计数器的轻微变体。你设置一个模型。你定义一些消息。你说出如何`update`。你制作你的 `view`。不同之处只是我们如何填写这个骨架。让我们来详细看看！
- en: As always, you start by guessing at what your `Model` should be. In our case,
    we know we are going to have to keep track of whatever the user has typed into
    the text field. We need that information so we know how to render the reversed
    text.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，你首先猜测你的 `Model` 应该是什么。在我们的情况下，我们知道我们将不得不跟踪用户在文本字段中键入的任何内容。我们需要这些信息，以便知道如何渲染反转后的文本。
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This time I chose to represent the model as a record. (You can read more about
    records [here](http://guide.elm-lang.org/core_language.html#records) and [here](http://elm-lang.org/docs/records).)
    For now, the record stores the user input in the `content` field.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我选择将模型表示为一个记录。（你可以在[这里](http://guide.elm-lang.org/core_language.html#records)和[这里](http://elm-lang.org/docs/records)阅读有关记录的更多信息。）目前，记录将用户输入存储在
    `content` 字段中。
- en: '**Note:** You may be wondering, why bother having a record if it only holds
    one entry? Couldn''t you just use the string directly? Yes, of course! But starting
    with a record makes it easy to add more fields as our app gets more complicated.
    When the time comes where we want *two* text inputs, we will have to do much less
    fiddling around.'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：**你可能会想，为什么要使用记录，如果它只保存一个条目？直接使用字符串不是更方便吗？当然可以！但是从记录开始，可以很容易地在应用程序变得更加复杂时添加更多字段。当我们想要*两个*文本输入时，我们将不必进行太多的摆弄。'
- en: Okay, so we have our model. Now in this app there is only one kind of message
    really. The user can change the contents of the text field.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们有了我们的模型。现在在这个应用中，实际上只有一种消息。用户可以更改文本字段的内容。
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This means our update function just has to handle this one case:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的更新函数只需处理这一种情况：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we receive new content, we use the record update syntax to update the contents
    of `content`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到新内容时，我们使用记录更新语法来更新`content`的内容。
- en: 'Finally we need to say how to view our application:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要说明如何查看我们的应用程序：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We create a `<div>` with two children.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个具有两个子节点的`<div>`。
- en: The interesting child is the `<input>` node. In addition to the `placeholder`
    attribute, it uses `onInput` to declare what messages should be sent when the
    user types into this input.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的子节点是`<input>`节点。除了`placeholder`属性之外，它还使用`onInput`来声明用户在此输入时应发送哪些消息。
- en: 'This `onInput` function is kind of interesting. It takes one argument, in this
    case the `Change` function which was created when we declared the `Msg` type:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`onInput`函数有点有趣。它接受一个参数，在这种情况下是我们声明`Msg`类型时创建的`Change`函数：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function is used to tag whatever is currently in the text field. So let's
    say the text field currently holds `yol` and the user types `o`. This triggers
    an `input` event, so we will get the message `Change "yolo"` in our `update` function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于标记当前在文本字段中的内容。因此，假设文本字段当前包含`yol`，用户键入`o`。这将触发一个`input`事件，因此我们将在我们的`update`函数中收到消息`Change
    "yolo"`。
- en: So now we have a simple text field that can reverse user input. Neat! Now on
    to putting a bunch of text fields together into a more traditional form.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们有了一个简单的文本字段，可以反转用户输入。很棒！现在让我们将一堆文本字段放在一起，形成一个更传统的表单。
- en: Forms
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单
- en: Forms
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单
- en: '* * *'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[Clone the code](https://github.com/evancz/elm-architecture-tutorial/) or follow
    along in the [online editor](http://elm-lang.org/examples/form).'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[克隆代码](https://github.com/evancz/elm-architecture-tutorial/)或在[在线编辑器](http://elm-lang.org/examples/form)中跟随。'
- en: '* * *'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Here we will make a rudimentary form. It has a field for your name, a field
    for your password, and a field to verify that password. We will also do some very
    simple validation (do the two passwords match?) just because it is simple to add.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将制作一个简单的表单。它有一个用于您的姓名的字段，一个用于您的密码的字段，以及一个用于验证该密码的字段。我们还将进行一些非常简单的验证（两个密码是否匹配？）只是因为它很简单添加。
- en: The code is a bit longer in this case, but I still think it is valuable to look
    through it before you get into the description of what is going on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，代码有点长，但我仍然认为在进入描述发生的情况之前浏览一下代码是有价值的。
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is pretty much exactly how our [text field example](text_fields.html) looked,
    just with more fields. Let's walk through how it came to be!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与我们的[文本字段示例](text_fields.html)看起来一样，只是有更多字段。让我们逐步了解它是如何产生的！
- en: 'As always, you start out by guessing at the `Model`. We know there are going
    to be three text fields, so let''s just go with that:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，您首先猜测`Model`。我们知道将有三个文本字段，所以我们就这么做了：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Great, seems reasonable. We expect that each of these fields can be changed
    separately, so our messages should account for each of those scenarios.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，看起来合理。我们期望每个字段都可以单独更改，所以我们的消息应该考虑到每种情况。
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This means our `update` is pretty mechanical. Just update the relevant field:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的`update`相当机械化。只需更新相关字段：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We get a little bit fancier than normal in our `view` though.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`view`中的操作比平常要复杂一些。
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It starts out normal: We create a `<div>` and put a couple `<input>` nodes
    in it. Each one has an `onInput` attribute that will tag any changes appropriately
    for our `update` function. (This is all building off of the text field example
    in the previous section.)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它开始是正常的：我们创建一个`<div>`，在其中放置了几个`<input>`节点。每个节点都有一个`onInput`属性，将任何更改适当地标记为我们的`update`函数。（这一切都是基于前一节中的文本字段示例构建的。）
- en: But for the last child we do not directly use an HTML function. Instead we call
    the `viewValidation` function, passing in the current model.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于最后一个子节点，我们不直接使用HTML函数。相反，我们调用`viewValidation`函数，传入当前的模型。
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function first compares the two passwords. If they match, you want green
    text and a positive message. If they do not match, you want red text and a helpful
    message. With that info, we produce a `<div>` filled with a colorful message explaining
    the situation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先比较两个密码。如果它们匹配，您希望显示绿色文本和积极消息。如果它们不匹配，您希望显示红色文本和有帮助的消息。有了这些信息，我们就会生成一个填满了说明情况的丰富多彩消息的`<div>`。
- en: This starts to show the benefits of having our HTML library be normal Elm code.
    It would have looked really weird to jam all that code into our `view`. In Elm,
    you just refactor like you would with any other code!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始显示出将我们的HTML库作为正常的Elm代码的好处。将所有代码都塞进我们的`view`中会看起来非常奇怪。在Elm中，您只需像处理其他任何代码一样进行重构！
- en: 'On these same lines, you may notice that the `<input>` nodes all are created
    with pretty similar code. Say we made each input fancier: there is an outer `<div>`
    that holds a `<span>` and an `<input>` with certain classes. It would make total
    sense to break that pattern out into a `viewInput` function so you never have
    to repeat yourself. This also means you change it in one place and everyone gets
    the updated HTML.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些相同的线上，你可能会注意到所有的`<input>`节点都是用相似的代码创建的。假设我们让每个输入框更加花哨：有一个外部的`<div>`包含一个带有特定类的`<span>`和一个`<input>`。将这种模式拆分成一个`viewInput`函数是完全合理的，这样你就永远不必重复自己。这也意味着你只需在一个地方进行更改，所有人都会得到更新后的HTML。
- en: '**Exercises:** One cool thing about breaking `viewValidation` out is that it
    is pretty easy to augment. If you are messing with the code as you read through
    this (as you should be!) you should try to:'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**练习：**将`viewValidation`拆分出来的一个很酷的事情是它很容易扩展。如果你在阅读本教程时（你应该这样做！）正在调整代码，你应该尝试：'
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check that the password is longer than 8 characters.
  id: totrans-103
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查密码是否超过8个字符。
- en: Make sure the password contains upper case, lower case, and numeric characters.
  id: totrans-104
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保密码包含大写字母、小写字母和数字字符。
- en: Add an additional field for `age` and check that it is a number.
  id: totrans-105
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个用于`年龄`的额外字段，并检查它是否为数字。
- en: Add a "Submit" button. Only show errors *after* it has been pressed.
  id: totrans-106
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个“提交”按钮。只在按下按钮后显示错误。
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Be sure to use the helpers in [the `String` library](http://package.elm-lang.org/packages/elm-lang/core/latest/String)
    if you try any of these! Also, we need to learn more before we start talking to
    servers, so before you try that here, keep reading until HTTP is introduced. It
    will be significantly easier with proper guidance!
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你尝试任何这些，请务必使用[String库](http://package.elm-lang.org/packages/elm-lang/core/latest/String)中的辅助函数！此外，在开始与服务器通信之前，我们需要学习更多内容，所以��这里尝试之前，请继续阅读直到介绍HTTP。有了适当的指导，这将变得更加容易！
- en: More
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多
- en: More About User Input
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于用户输入的内容
- en: We only covered buttons and text fields, but there are other crazier inputs
    that you will need eventually.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只涵盖了按钮和文本字段，但是你最终会需要其他更疯狂的输入。
- en: So if you want to see examples of radio buttons and check boxes, visit [the
    Elm examples page](http://elm-lang.org/examples) which has a bunch of small examples
    you can mess around with. It is all variations on stuff we have learned in this
    tutorial already, so playing with these examples is a great way to practice and
    become more comfortable with what you have learned so far. Maybe try incorporating
    check boxes into the form example?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想看到单选按钮和复选框的示例，请访问[Elm示例页面](http://elm-lang.org/examples)，其中有许多小例子可以让你尝试。这些例子都是我们在本教程中已经学到的东西的变体，因此玩弄这些例子是练习和更加熟悉你已经学到的东西的好方法。也许尝试将复选框整合到表单示例中？
- en: That said, I want to keep up the momentum of this tutorial and keep introducing
    new concepts, so next we will be looking at how to work with things like HTTP
    and web sockets!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我希望保持本教程的势头并继续介绍新概念，所以下一步我们将看看如何处理HTTP和Web套接字等内容！
- en: Effects
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Effects
- en: The Elm Architecture + Effects
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elm架构 + Effects
- en: 'The last section showed how to handle all sorts of user input. You can think
    of those programs like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节展示了如何处理各种用户输入。你可以将这些程序看作是这样的：
- en: '![](a39099ae.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](a39099ae.png)'
- en: From our perspective, we just receive messages and produce new `Html` to get
    rendered on screen. The “Elm Runtime” is sitting there behind the scenes. When
    it gets `Html` it figures out how to render it on screen [really fast](http://elm-lang.org/blog/blazing-fast-html-round-two).
    When a user clicks on something, it figures out how to pipe that into our program
    as a `Msg`. So the Elm Runtime is in charge of *doing* stuff. We just transform
    data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的角度来看，我们只是接收消息并生成新的`Html`以在屏幕上呈现。在幕后，“Elm Runtime”就坐在那里。当它得到`Html`时，它会快速地在屏幕上呈现它[非常快](http://elm-lang.org/blog/blazing-fast-html-round-two)。当用户点击某些东西时，它会想办法将其作为`Msg`传递到我们的程序中。因此，Elm
    Runtime负责*执行*操作。我们只是转换数据。
- en: 'This section builds on that pattern, giving you the ability to make HTTP requests
    or subscribe to messages from web sockets. Think of it like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本节基于这种模式，让你能够发起HTTP请求或订阅来自Web套接字的消息。可以这样理解：
- en: '![](e9cd743d.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](e9cd743d.png)'
- en: 'Instead of just producing `Html`, we will now be producing commands and subscriptions:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不仅仅是生成`Html`，而是生成命令和订阅：
- en: '**Commands** — A `Cmd` lets you *do* stuff: generate a random number, send
    an HTTP request, etc.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令** —— `Cmd`让你*执行*操作：生成一个随机数，发送一个HTTP请求等等。'
- en: '**Subscriptions** — A `Sub` lets you register that you are interested in something:
    tell me about location changes, listen for web socket messages, etc.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you squint, commands and subscriptions are pretty similar to `Html` values.
    With `Html`, we never touch the DOM by hand. Instead we represent the desired
    HTML as *data* and let the Elm Runtime do some clever stuff to make it render
    [really fast](http://elm-lang.org/blog/blazing-fast-html-round-two). It is the
    same with commands and subscriptions. We create data that *describes* what we
    want to do, and the Elm Runtime does the dirty work.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if it seems a bit confusing for now, the examples will help! So
    first let’s look at how to fit these concepts into the code we have seen before.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Extending the Architecture Skeleton
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far our architecture skeleton has focused on creating `Model` types and
    `update` and `view` functions. To handle commands and subscriptions, we need to
    extend the basic architecture skeleton a little bit:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first three sections are almost exactly the same, but there are a few new
    things overall:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The `update` function now returns more than just a new model. It returns a new
    model and some commands you want to run. These commands are all going to produce
    `Msg` values that will get fed right back into our `update` function.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is a `subscriptions` function. This function lets you declare any event
    sources you need to subscribe to given the current model. Just like with `Html
    Msg` and `Cmd Msg`, these subscriptions will produce `Msg` values that get fed
    right back into our `update` function.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So far `init` has just been the initial model. Now it produces both a model
    and some commands, just like the new `update`. This lets us provide a starting
    value *and* kick off any HTTP requests or whatever that are needed for initialization.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now it is totally okay if this does not really make sense yet! That only really
    happens when you start seeing it in action, so let’s hop right into the examples!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '**Aside:** One crucial detail here is that commands and subscriptions are *data*.
    When you create a command, you do not actually *do* it. Same with commands in
    real life. Let’s try it. Eat an entire watermelon in one bite! Did you do it?
    No! You kept reading before you even *thought* about buying a tiny watermelon.'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Point is, commands and subscriptions are data. You hand them to Elm to actually
    run them, giving Elm a chance to log all of this information. In the end, effects-as-data
    means Elm can:'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Have a general purpose time-travel debugger.
  id: totrans-138
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the "same input, same output" guarantee for all Elm functions.
  id: totrans-139
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid setup/teardown phases when testing `update` logic.
  id: totrans-140
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache and batch effects, minimizing HTTP connections or other resources.
  id: totrans-141
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So without going too crazy on details, pretty much all the nice guarantees and
    tools you have in Elm come from the choice to treat effects as data! I think this
    will make more sense as you get deeper into Elm.
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Random
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Random
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[Clone the code](https://github.com/evancz/elm-architecture-tutorial/) or follow
    along in the [online editor](http://elm-lang.org/examples/random).'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[克隆代码](https://github.com/evancz/elm-architecture-tutorial/)或者在[在线编辑器](http://elm-lang.org/examples/random)中跟随。'
- en: '* * *'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: We are about to make an app that "rolls dice", producing a random number between
    1 and 6.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要制作一个“掷骰子”的应用程序，产生一个介于1和6之间的随机数。
- en: When I write code with effects, I usually break it into two phases. Phase one
    is about getting something on screen, just doing the bare minimum to have something
    to work from. Phase two is filling in details, gradually approaching the actual
    goal. We will use this process here too.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我用效果编写代码时，我通常将其分为两个阶段。第一阶段是将某些东西显示在屏幕上，只做最基本的工作，以便有些东西可以从中工作。第二阶段是填充细节，逐渐接近实际目标。我们在这里也将使用这个过程。
- en: Phase One - The Bare Minimum
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一阶段 - 最低限度
- en: 'As always, you start out by guessing at what your `Model` should be:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 总是从猜测你的`Model`应该是什么开始：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For now we will just track `dieFace` as an integer between 1 and 6\. Then I
    would quickly sketch out the `view` function because it seems like the easiest
    next step.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只是将`dieFace`作为介于1和6之间的整数跟踪。然后，我会很快勾勒出`view`函数，因为它似乎是最容易的下一步。
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So this is typical. Same stuff we have been doing with the user input examples
    of The Elm Architecture. When you click our `<button>` it is going to produce
    a `Roll` message, so I guess it is time to take a first pass at the `update` function
    as well.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是典型的。与我们在The Elm Architecture的用户输入示例中一直做的事情相同。当你点击我们的`<button>`时，它将产生一个`Roll`消息，所以我想现在是时候对`update`函数进行第一次尝试了。
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now the `update` function has the same overall shape as before, but the return
    type is a bit different. Instead of just giving back a `Model`, it produces both
    a `Model` and a command. The idea is: **we still want to step the model forward,
    but we also want to do some stuff.** In our case, we want to ask Elm to give us
    a random value. For now, I just fill it in with [`Cmd.none`](http://package.elm-lang.org/packages/elm-lang/core/latest/Platform-Cmd#none)
    which means "I have no commands, do nothing." We will fill this in with the good
    stuff in phase two.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`update`函数的总体形状与之前相同，但返回类型有点不同。不仅返回一个`Model`，还产生了一个命令。思路是：**我们仍然希望使模型向前发展，但我们也想做一些事情。**在我们的情况下，我们想要求Elm给我们一个随机值。目前，我只用[`Cmd.none`](http://package.elm-lang.org/packages/elm-lang/core/latest/Platform-Cmd#none)填充它，这意味着“我没有命令，什么都不做。”在第二阶段中，我们将用好东西填充它。
- en: 'Finally, I would create an `init` value like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我会创建一个像这样的`init`值：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here we specify both the initial model and some commands we'd like to run immediately
    when the app starts. This is exactly the kind of stuff that `update` is producing
    now too.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们指定了初始模型和一些我们希望在应用程序启动时立即运行的命令。这正是`update`现在也在产生的那种东西。
- en: At this point, it is possible to wire it all up and take a look. You can click
    the `<button>`, but nothing happens. Let's fix that!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，将所有内容连起来并查看是可能的。你可以点击`<button>`，但没有任何反应。让我们来修复它！
- en: Phase Two - Adding the Cool Stuff
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二阶段 - 添加酷炫的东西
- en: 'The obvious thing missing right now is the randomness! When the user clicks
    a button we want to command Elm to reach into its internal random number generator
    and give us a number between 1 and 6\. The first step I would take towards that
    goal would be adding a new kind of message:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，现在缺少的东西是随机性！当用户点击按钮时，我们希望命令Elm到其内部随机数生成器中，并给我们一个介于1和6之间的数字。我朝着这个目标迈出的第一步将是添加一种新的消息：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We still have `Roll` from before, but now we add `NewFace` for when Elm hands
    us our new random number. That is enough to start filling in `update`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有之前的`Roll`，但现在我们添加了`NewFace`用于当Elm将我们的新随机数交给我们时。这已经足够开始填写`update`了：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are two new things here. **First**, there is now a branch for `NewFace`
    messages. When a `NewFace` comes in, we just step the model forward and do nothing.
    **Second**, we have added a real command to the `Roll` branch. This uses a couple
    functions from [the `Random` library](http://package.elm-lang.org/packages/elm-lang/core/latest/Random).
    Most important is `Random.generate`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个新的东西。**首先**，现在有一个`NewFace`消息的分支。当一个`NewFace`进来时，我们只是让模型前进并且什么也不做。**其次**，我们在`Roll`分支中添加了一个真实的命令。这使用了来自[the
    `Random` library](http://package.elm-lang.org/packages/elm-lang/core/latest/Random)的几个函数。最重要的是`Random.generate`：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This function takes two arguments. The first is a function to tag random values.
    In our case we want to use `NewFace : Int -> Msg` to turn the random number into
    a message for our `update` function. The second argument is a "generator" which
    is like a recipe for producing certain types of random values. You can have generators
    for simple types like `Int` or `Float` or `Bool`, but also for fancy types like
    big custom records with lots of fields. In this case, we use one of the simplest
    generators:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '这个函数接受两个参数。第一个是一个函数，用于标记随机值。在我们的情况下，我们想要使用 `NewFace : Int -> Msg` 将随机数转换为我们
    `update` 函数的消息。第二个参数是一个“生成器”，类似于生成某些类型的随机值的配方。你可以为简单类型如 `Int` 或 `Float` 或 `Bool`
    创建生成器，也可以为具有许多字段的大型自定义记录等复杂类型创建生成器。在这种情况下，我们使用最简单的生成器之一：'
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You provide a lower and upper bound on the integer, and now you have a generator
    that produces integers in that range!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你提供一个整数的下限和上限，现在你有一个生成器可以在该范围内生成整数！
- en: That is it. Now we can click and see the number flip to some new value!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在我们可以点击并看到数字翻转到一些新值！
- en: 'So the big lessons here are:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里的重要教训是：
- en: Write your programs bit by bit. Start with a simple skeleton, and gradually
    add the tougher stuff.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步编写你的程序。从一个简单的框架开始，然后逐渐添加更难的内容。
- en: The `update` function now produces a new model *and* a command.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update` 函数现在生成一个新模型 *和* 一个命令。'
- en: You cannot just get random values willy-nilly. You create a command, and Elm
    will go do some work behind the scenes to provide it for you. In fact, any time
    our program needs to get unreliable values (randomness, HTTP, file I/O, database
    reads, etc.) you have to go through Elm.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能随意获取随机值。你创建一个命令，Elm 将在幕后进行一些工作为你提供它。事实上，每当我们的程序需要获取不可靠的值（随机性、HTTP、文件 I/O、数据库读取等），你都必须通过
    Elm。
- en: At this point, the best way to improve your understanding of commands is just
    to see more of them! They will appear prominently with the `Http` and `WebSocket`
    libraries, so if you are feeling shaky, the only path forward is practicing with
    randomness and playing with other examples of commands!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，提高对命令理解的最佳方法就是看更多的命令！它们将在 `Http` �� `WebSocket` 库中显著出现，因此如果你感到不稳定，唯一的前进道路就是练习随机性并尝试其他命令的示例！
- en: '**Exercises:** Here are some that build on stuff that has already been introduced:'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**练习：** 这里有一些基于已经介绍的内容的练习：'
- en: ''
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Instead of showing a number, show the die face as an image.
  id: totrans-181
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要显示一个数字，将骰子面显示为图像。
- en: Add a second die and have them both roll at the same time.
  id: totrans-182
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加第二个骰子，并让它们同时滚动。
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And here are some that require new skills:'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这里还有一些需要新技能的练习：
- en: ''
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Instead of showing an image of a die face, use the `elm-lang/svg` library to
    draw it yourself.
  id: totrans-186
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要显示一个骰子面的图像，使用 `elm-lang/svg` 库自己绘制它。
- en: After you have learned about tasks and animation, have the dice flip around
    randomly before they settle on a final value.
  id: totrans-187
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在学习了任务和动画之后，让骰子在最终停止之前随机翻转。
- en: HTTP
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP
- en: HTTP
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP
- en: '* * *'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[Clone the code](https://github.com/evancz/elm-architecture-tutorial/) or follow
    along in the [online editor](http://elm-lang.org/examples/http).'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[克隆代码](https://github.com/evancz/elm-architecture-tutorial/) 或在 [在线编辑器](http://elm-lang.org/examples/http)
    中跟随。'
- en: '* * *'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: We are about to make an app that fetches a random GIF when the user asks for
    another image.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将制作一个应用程序，在用户请求另一张图片时获取一个随机 GIF。
- en: Now, I am going to assume you just read the randomness example. It (1) introduces
    a two step process for writing apps like this and (2) shows the simplest kind
    of commands possible. Here we will be using the same two step process to build
    up to fancier kinds of commands, so I very highly recommend going back one page.
    I swear you will reach your goals faster if you start with a solid foundation!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我假设你刚刚阅读了随机性示例。它 (1) 介绍了编写这类应用程序的两步过程，(2) 显示了可能的最简单的命令类型。在这里，我们将使用相同的两步过程来构建更复杂的命令类型，因此我强烈建议返回上一页。我发誓，如果你从一个坚实的基础开始，你会更快地实现目标！
- en: '...'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Okay, so you read it now right? Good. Let's get started on our random gif fetcher!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，所以你现在读了吧？很好。让我们开始制作我们的随机 GIF 获取器！
- en: Phase One - The Bare Minimum
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一阶段 - 最低限度
- en: At this point in this guide, you should be pretty comfortable smacking down
    the basic skeleton of an Elm app. Guess at the model, fill in some messages, etc.
    etc.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本指南的这一点上，你应该已经对编写 Elm 应用程序的基本框架感到非常舒适。猜测模型，填写一些消息，等等。
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For the model, I decided to track a `topic` so I know what kind of gifs to fetch.
    I do not want to hard code it to `"cats"`, and maybe later we will want to let
    the user decide the topic too. I also tracked the `gifUrl` which is a URL that
    points at some random gif.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Like in the randomness example, I just made dummy `init` and `update` functions.
    None of them actually produce any commands for now. The point is just to get something
    on screen!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Phase Two - Adding the Cool Stuff
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alright, the obvious thing missing right now is the HTTP request. I think it
    is easiest to start this process by adding new kinds of messages. Now remember,
    **when you give a command, you have to wait for it to happen.** So when we command
    Elm to do an HTTP request, it is eventually going to tell you "hey, here is what
    you wanted" or it is going to say "oops, something went wrong with the HTTP request".
    We need this to be reflected in our messages:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We add a case for `NewGif` that holds a `Result`. You can read more about results
    [here](result.html), but the key idea is that it captures the two possible outcomes
    of an HTTP request. It either (1) succeeded with the URL of a random gif or (2)
    failed with some HTTP error (server is down, bad URL, etc.)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'That is enough to start filling in `update`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So I added branches for our new messages. When `NewGif` holds a success, we
    update the `gifUrl` field to have the new URL. When `NewGif` holds an error, we
    ignore it, giving back the same model and doing nothing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: I also changed the `MorePlease` branch a bit. We need an HTTP command, so I
    called the `getRandomGif` function. The trick is that I made that function up.
    It does not exist yet. That is the next step!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining `getRandomGif` might look something like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With that added, the "More" button actually goes and fetches a random gif. Check
    it out [here](http://elm-lang.org/examples/http)! But how does `getRandomGif`
    work exactly?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'It starts out simple, we define `url` to be some giphy endpoint for random
    gifs. Next we create an HTTP `request` with [`Http.get`](http://package.elm-lang.org/packages/elm-lang/http/latest/Http#get).
    Finally, we turn it into a command with [`Http.send`](http://package.elm-lang.org/packages/elm-lang/http/latest/Http#send).
    Let’s break those steps down a bit more:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '`Http.get : String -> Decode.Decoder value -> Http.Request value`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function takes a URL and a JSON decoder. This is our first time seeing
    a JSON decoder (and we will cover them in depth [later](json.html)), but for now,
    you really just need a high-level understanding. It turns JSON into Elm. In our
    case, we defined `decodeGifUrl` which tries to find a string value at `json.data.image_url`.
    Between the URL and the JSON decoder, we create an `Http.Request`. This is similar
    to a `Random.Generator` like we saw in [the previous example](random.html). It
    does not actually *do* anything. It just describes how to make an HTTP request.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Http.send : (Result Error value -> msg) -> Http.Request value -> Cmd msg`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Http.send：(Result错误值-> msg)-> Http.Request值-> Cmd msg`'
- en: Once we have an HTTP request, we can turn it into a command with `Http.send`.
    This is just like how we used `Random.generate` to create a command with a random
    generator. The first argument is a way to turn the result of the HTTP request
    into a message for our `update` function. In this case, we create a `NewGif` message.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们有了HTTP请求，我们就可以使用`Http.send`将其转换为命令。 这就像我们使用`Random.generate`创建具有随机生成器的命令一样。
    第一个参数是将HTTP请求的结果转换为我们`update`函数的消息的方法。 在这种情况下，我们创建一个`NewGif`消息。
- en: This has been a very quick introduction, but the key idea is that you must (1)
    create an HTTP request and (2) turn that into a command so Elm will actually *do*
    it. You can go pretty far using the basic pattern here, and we will be looking
    into JSON decoders [later on](json.html), which will let you deal with whatever
    crazy JSON you run into.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个非常快速的介绍，但关键思想是您必须（1）创建一个HTTP请求，并且（2）将其转换为命令，以便Elm实际*执行*它。 使用基本模式，您可以走得很远，我们将在[后面](json.html)研究JSON解码器，这将让您处理任何疯狂的JSON。
- en: '**Exercises:** To get more comfortable with this code, try augmenting it with
    skills we learned in previous sections:'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**练习：** 为了更加熟悉这段代码，尝试使用我们在前几节中学到的技能来增强它：'
- en: ''
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show a message explaining why the image didn't change when you get an [`Http.Error`](http://package.elm-lang.org/packages/elm-lang/http/latest/Http#Error).
  id: totrans-221
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您收到[`Http.Error`](http://package.elm-lang.org/packages/elm-lang/http/latest/Http#Error)时，显示一条消息，解释为什么图像没有更改。
- en: Allow the user to modify the `topic` with a text field.
  id: totrans-222
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户使用文本字段修改`topic`。
- en: Allow the user to modify the `topic` with a drop down menu.
  id: totrans-223
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户使用下拉菜单修改`topic`。
- en: Time
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间
- en: Time
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间
- en: '* * *'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[Clone the code](https://github.com/evancz/elm-architecture-tutorial/) or follow
    along in the [online editor](http://elm-lang.org/examples/time).'
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[克隆代码](https://github.com/evancz/elm-architecture-tutorial/)或在[在线编辑器](http://elm-lang.org/examples/time)中跟随。'
- en: '* * *'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: We are going to make a simple clock.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将制作一个简单的时钟。
- en: So far we have focused on commands. With the randomness example, we *asked*
    for a random value. With the HTTP example, we *asked* for info from a server.
    That pattern does not really work for a clock. In this case, we want to sit around
    and hear about clock ticks whenever they happen. This is where **subscriptions**
    come in.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经专注于命令。 在随机示例中，我们*请求*了一个随机值。 在HTTP示例中，我们*请求*了来自服务器的信息。 这种模式对于时钟不太适用。
    在这种情况下，我们希望坐下来听到时钟每次发生时都会发生的事情。 这就是**订阅**的作用所在。
- en: The code is not too crazy here, so I am going to include it in full. After you
    read through, we will come back to normal words that explain it in more depth.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码并不太疯狂，所以我会完整地包含它。在您阅读完之后，我们将回到正常的词语，更深入地解释它。
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There is nothing new in the `MODEL` or `UPDATE` sections. Same old stuff. The
    `view` function is kind of interesting. Instead of using HTML, we use the `Svg`
    library to draw some shapes. It works just like HTML though. You provide a list
    of attributes and a list of children for every node.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MODEL`或`UPDATE`部分没有新内容。 还是老样子。 `view`函数有点有趣。 我们不是使用HTML，而是使用`Svg`库来绘制一些形状。
    但它的工作原理和HTML一样。 您为每个节点提供一组属性和一组子节点。
- en: 'The important thing comes in `SUBSCRIPTIONS` section. The `subscriptions` function
    takes in the model, and instead of returning `Sub.none` like in the examples we
    have seen so far, it gives back a real life subscription! In this case `Time.every`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的事情出现在`SUBSCRIPTIONS`部分。 `subscriptions`函数接受模型，而不是像我们到目前为止看到的例子中返回`Sub.none`，而是返回一个真正的生活订阅！
    在这种情况下，`Time.every`：
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first argument is a time interval. We chose to get ticks every second. The
    second argument is a function that turns the current time into a message for the
    `update` function. We are tagging times with `Tick` so the time 1458863979862
    would become `Tick 1458863979862`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是时间间隔。 我们选择每秒获取一次刻度。 第二个参数是一个函数，它将当前时间转换为`update`函数的消息。 我们使用`Tick`标记时间，因此时间1458863979862将变为`Tick
    1458863979862`。
- en: That is all there is to setting up a subscription! These messages will be fed
    to your `update` function whenever they become available.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 设置订阅就是这么简单！ 这些消息将在可用时提供给您的`update`函数。
- en: '**Exercises:**'
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**练习：**'
- en: ''
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Add a button to pause the clock, turning the `Time` subscription off.
  id: totrans-240
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个按钮来暂停时钟，关闭`Time`订阅。
- en: Make the clock look nicer. Add an hour and minute hand. Etc.
  id: totrans-241
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使时钟看起来更好看。 添加小时和分钟指针。 等等。
- en: Web Sockets
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Sockets
- en: Web Sockets
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Sockets
- en: '* * *'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[Clone the code](https://github.com/evancz/elm-architecture-tutorial/) or follow
    along in the [online editor](http://elm-lang.org/examples/websockets).'
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[克隆代码](https://github.com/evancz/elm-architecture-tutorial/) 或在[在线编辑器](http://elm-lang.org/examples/websockets)中跟随。'
- en: '* * *'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'We are going to make a simple chat app. There will be a text field so you can
    type things in and a region that shows all the messages we have received so far.
    Web sockets are great for this scenario because they let us set up a persistent
    connection with the server. This means:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将制作一个简单的聊天应用程序。将有一个文本字段，因此您可以在其中键入内容，并显示到目前为止我们收到的所有消息的区域。对于这种情况，Web套接字非常适合，因为它们让我们能够与服务器建立持久连接。这意味着：
- en: You can send messages cheaply whenever you want.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以随时廉价地发送消息。
- en: The server can send *you* messages whenever it feels like it.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器可以随时向*您*发送消息。
- en: In other words, `WebSocket` is one of the rare libraries that makes use of both
    commands and subscriptions.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`WebSocket`是少数同时使用命令和订阅的库之一。
- en: 'This program happens to be pretty short, so here is the full thing:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序恰好非常简短，因此这是完整的内容：
- en: '[PRE33]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The interesting parts are probably the uses of `WebSocket.send` and `WebSocket.listen`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最有趣的部分是使用 `WebSocket.send` 和 `WebSocket.listen`。
- en: For simplicity we will target a simple server that just echos back whatever
    you type. So you will not be able to have the most exciting conversations in the
    basic version, but that is why we have exercises on these examples!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们将针对一个简单的服务器，该服务器只是将您键入的任何内容回显。因此，在基本版本中，您将无法进行最激动人心的对话，但这就是为什么我们在这些示例中有练习的原因！
- en: More
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多
- en: More about The Elm Architecture
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于Elm架构
- en: 'The emphasis of this section has been: **how can we get people making cool
    Elm projects as quickly and smoothly as possible?** So we covered:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的重点是：**我们如何能尽快顺利地让人们制作出酷炫的Elm项目？** 所以我们讨论了：
- en: The basic architecture pattern.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本架构模式。
- en: How to create buttons and text fields.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建按钮和文本字段。
- en: How to make HTTP requests.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何发起HTTP请求。
- en: How to work with web sockets.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Web套接字工作。
- en: You can go quite far with this knowledge, but there are many important aspects
    of Elm itself that we have not covered yet. For example, union types are one of
    the most important features in the whole language and we have not focused on them
    at all!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过这些知识走得很远，但是Elm本身还有许多重要方面我们尚未涵盖。例如，联合类型是整个语言中最重要的功能之一，而我们根本没有专注于它们！
- en: So we are going to take a break from The Elm Architecture for a couple chapters
    to get a better understanding of Elm itself. We will come back to The Elm Architecture
    in a few chapters and focus on code reuse in larger applications. In the meantime,
    when a function gets so big it feels unmanageable in practice, make a helper function!
    Elm makes refactoring easy, so it is best to improve architecture as needed rather
    than preemptively. More about that later though!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在几章中暂时离开Elm架构，以更好地理解Elm本身。我们将在几章后回到Elm架构，并专注于在较大的应用程序中重用代码。同时，当一个函数变得如此庞大，以至于在实践中感觉无法管理时，可以创建一个辅助函数！Elm使重构变得容易，因此最好根据需要改进架构，而不是预先行动。稍后再详细了解更多！
- en: P.S. Best not to skip ahead. You can build a bigger house if you have a strong
    foundation!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: P.S. 最好不要提前跳过。如果有一个坚实的基础，你可以建造一个更大的房子！
