- en: The Elm Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Elm Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Elm Architecture is a simple pattern for architecting webapps. It is great
    for modularity, code reuse, and testing. Ultimately, it makes it easy to create
    complex web apps that stay healthy as you refactor and add features.
  prefs: []
  type: TYPE_NORMAL
- en: This architecture seems to emerge naturally in Elm. We first observed it in
    the games the Elm community was making. Then in web apps like [TodoMVC](https://github.com/evancz/elm-todomvc)
    and [dreamwriter](https://github.com/rtfeldman/dreamwriter#dreamwriter) too. Now
    we see it running in production at companies like [NoRedInk](https://www.noredink.com/)
    and [Pivotal](https://www.pivotaltracker.com/blog/Elm-pivotal-tracker/). The architecture
    seems to be a consequence of the design of Elm itself, so it will happen to you
    whether you know about it or not. This has proven to be really nice for onboarding
    new developers. Their code just turns out well-architected. It is kind of spooky.
  prefs: []
  type: TYPE_NORMAL
- en: So The Elm Architecture is *easy* in Elm, but it is useful in any front-end
    project. In fact, projects like Redux have been inspired by The Elm Architecture,
    so you may have already seen derivatives of this pattern. Point is, even if you
    ultimately cannot use Elm at work yet, you will get a lot out of using Elm and
    internalizing this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Basic Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The logic of every Elm program will break up into three cleanly separated parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model** — the state of your application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update** — a way to update your state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View** — a way to view your state as HTML'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern is so reliable that I always start with the following skeleton
    and fill in details for my particular case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That is really the essence of The Elm Architecture! We will proceed by filling
    in this skeleton with increasingly interesting logic.
  prefs: []
  type: TYPE_NORMAL
- en: User Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Elm Architecture + User Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your web app is going to need to deal with user input. This section will get
    you familiar with The Elm Architecture in the context of things like:'
  prefs: []
  type: TYPE_NORMAL
- en: Buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text Fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check Boxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Radio Buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will go through a few examples that build knowledge gradually, so go in order!
  prefs: []
  type: TYPE_NORMAL
- en: Follow Along
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last section we used `elm-repl` to get comfortable with Elm expressions.
    In this section, we are switching to creating Elm files of our own. You can do
    that in [the online editor](http://elm-lang.org/try), or if you have Elm [installed](install.html),
    you can follow [these simple instructions](https://github.com/evancz/elm-architecture-tutorial#run-the-examples)
    to get everything working on your computer!
  prefs: []
  type: TYPE_NORMAL
- en: Buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[Clone the code](https://github.com/evancz/elm-architecture-tutorial/) or follow
    along in the [online editor](http://elm-lang.org/examples/buttons).'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Our first example is a simple counter that can be incremented or decremented.
    I find that it can be helpful to see the entire program in one place, so here
    it is! We will break it down afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That's everything!
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** This section has `type` and `type alias` declarations. You can read
    all about these in the upcoming section on [types](http://guide.elm-lang.org/types/index.html).
    You do not *need* to deeply understand that stuff now, but you are free to jump
    ahead if it helps.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When writing this program from scratch, I always start by taking a guess at
    the model. To make a counter, we at least need to keep track of a number that
    is going up and down. So let's just start with that!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a model, we need to define how it changes over time. I always
    start my `UPDATE` section by defining a set of messages that we will get from
    the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I definitely know the user will be able to increment and decrement the counter.
    The `Msg` type describes these capabilities as *data*. Important! From there,
    the `update` function just describes what to do when you receive one of these
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you get an `Increment` message, you increment the model. If you get a `Decrement`
    message, you decrement the model. Pretty straight-forward stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so that''s all good, but how do we actually make some HTML and show it
    on screen? Elm has a library called `elm-lang/html` that gives you full access
    to HTML5 as normal Elm functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can see more examples of basic HTML [here](http://elm-lang.org/examples).
  prefs: []
  type: TYPE_NORMAL
- en: One thing to notice is that our `view` function is producing a `Html Msg` value.
    This means that it is a chunk of HTML that can produce `Msg` values. And when
    you look at the definition, you see the `onClick` attributes are set to give out
    `Increment` and `Decrement` values. These will get fed directly into our `update`
    function, driving our whole app forward.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to notice is that `div` and `button` are just normal Elm functions.
    These functions take (1) a list of attributes and (2) a list of child nodes. It
    is just HTML with slightly different syntax. Instead of having `<` and `>` everywhere,
    we have `[` and `]`. We have found that folks who can read HTML have a pretty
    easy time learning to read this variation. Okay, but why not have it be *exactly*
    like HTML? **Since we are using normal Elm functions, we have the full power of
    the Elm programming language to help us build our views!** We can refactor repetitive
    code out into functions. We can put helpers in modules and import them just like
    any other code. We can use the same testing frameworks and libraries as any other
    Elm code. Everything that is nice about programming in Elm is 100% available to
    help you with your view. No need for a hacked together templating language!
  prefs: []
  type: TYPE_NORMAL
- en: There is also something a bit deeper going on here. **The view code is entirely
    declarative**. We take in a `Model` and produce some `Html`. That is it. There
    is no need to mutate the DOM manually, Elm takes care of that behind the scenes.
    This gives Elm [much more freedom to make clever optimizations](http://elm-lang.org/blog/blazing-fast-html)
    and ends up making rendering *faster* overall. So you write less code and the
    code runs faster. The best kind of abstraction!
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is the essence of The Elm Architecture. Every example we see from
    now on will be a slight variation on this basic pattern: `Model`, `update`, `view`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** One cool thing about The Elm Architecture is that it is super
    easy to extend as our product requirements change. Say your product manager has
    come up with this amazing "reset" feature. A new button that will reset the counter
    to zero.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To add the feature you come back to the `Msg` type and add another possibility:
    `Reset`. You then move on to the `update` function and describe what happens when
    you get that message. Finally you add a button in your view.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See if you can implement the "reset" feature!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Text Fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text Fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[Clone the code](https://github.com/evancz/elm-architecture-tutorial/) or follow
    along in the [online editor](http://elm-lang.org/examples/field).'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: We are about to create a simple app that reverses the contents of a text field.
    This example also introduces some new stuff that will help us out in our next
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Again this is a pretty short program, so I have included the whole thing here.
    Skim through to get an idea of how everything fits together. Right after that
    we will go into much more detail!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code is a slight variant of the counter from the previous section. You
    set up a model. You define some messages. You say how to `update`. You make your
    `view`. The difference is just in how we filled this skeleton in. Let's walk through
    that!
  prefs: []
  type: TYPE_NORMAL
- en: As always, you start by guessing at what your `Model` should be. In our case,
    we know we are going to have to keep track of whatever the user has typed into
    the text field. We need that information so we know how to render the reversed
    text.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This time I chose to represent the model as a record. (You can read more about
    records [here](http://guide.elm-lang.org/core_language.html#records) and [here](http://elm-lang.org/docs/records).)
    For now, the record stores the user input in the `content` field.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** You may be wondering, why bother having a record if it only holds
    one entry? Couldn''t you just use the string directly? Yes, of course! But starting
    with a record makes it easy to add more fields as our app gets more complicated.
    When the time comes where we want *two* text inputs, we will have to do much less
    fiddling around.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Okay, so we have our model. Now in this app there is only one kind of message
    really. The user can change the contents of the text field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This means our update function just has to handle this one case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When we receive new content, we use the record update syntax to update the contents
    of `content`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally we need to say how to view our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We create a `<div>` with two children.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting child is the `<input>` node. In addition to the `placeholder`
    attribute, it uses `onInput` to declare what messages should be sent when the
    user types into this input.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `onInput` function is kind of interesting. It takes one argument, in this
    case the `Change` function which was created when we declared the `Msg` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This function is used to tag whatever is currently in the text field. So let's
    say the text field currently holds `yol` and the user types `o`. This triggers
    an `input` event, so we will get the message `Change "yolo"` in our `update` function.
  prefs: []
  type: TYPE_NORMAL
- en: So now we have a simple text field that can reverse user input. Neat! Now on
    to putting a bunch of text fields together into a more traditional form.
  prefs: []
  type: TYPE_NORMAL
- en: Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[Clone the code](https://github.com/evancz/elm-architecture-tutorial/) or follow
    along in the [online editor](http://elm-lang.org/examples/form).'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Here we will make a rudimentary form. It has a field for your name, a field
    for your password, and a field to verify that password. We will also do some very
    simple validation (do the two passwords match?) just because it is simple to add.
  prefs: []
  type: TYPE_NORMAL
- en: The code is a bit longer in this case, but I still think it is valuable to look
    through it before you get into the description of what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty much exactly how our [text field example](text_fields.html) looked,
    just with more fields. Let's walk through how it came to be!
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, you start out by guessing at the `Model`. We know there are going
    to be three text fields, so let''s just go with that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Great, seems reasonable. We expect that each of these fields can be changed
    separately, so our messages should account for each of those scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This means our `update` is pretty mechanical. Just update the relevant field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We get a little bit fancier than normal in our `view` though.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It starts out normal: We create a `<div>` and put a couple `<input>` nodes
    in it. Each one has an `onInput` attribute that will tag any changes appropriately
    for our `update` function. (This is all building off of the text field example
    in the previous section.)'
  prefs: []
  type: TYPE_NORMAL
- en: But for the last child we do not directly use an HTML function. Instead we call
    the `viewValidation` function, passing in the current model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This function first compares the two passwords. If they match, you want green
    text and a positive message. If they do not match, you want red text and a helpful
    message. With that info, we produce a `<div>` filled with a colorful message explaining
    the situation.
  prefs: []
  type: TYPE_NORMAL
- en: This starts to show the benefits of having our HTML library be normal Elm code.
    It would have looked really weird to jam all that code into our `view`. In Elm,
    you just refactor like you would with any other code!
  prefs: []
  type: TYPE_NORMAL
- en: 'On these same lines, you may notice that the `<input>` nodes all are created
    with pretty similar code. Say we made each input fancier: there is an outer `<div>`
    that holds a `<span>` and an `<input>` with certain classes. It would make total
    sense to break that pattern out into a `viewInput` function so you never have
    to repeat yourself. This also means you change it in one place and everyone gets
    the updated HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises:** One cool thing about breaking `viewValidation` out is that it
    is pretty easy to augment. If you are messing with the code as you read through
    this (as you should be!) you should try to:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check that the password is longer than 8 characters.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure the password contains upper case, lower case, and numeric characters.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an additional field for `age` and check that it is a number.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a "Submit" button. Only show errors *after* it has been pressed.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Be sure to use the helpers in [the `String` library](http://package.elm-lang.org/packages/elm-lang/core/latest/String)
    if you try any of these! Also, we need to learn more before we start talking to
    servers, so before you try that here, keep reading until HTTP is introduced. It
    will be significantly easier with proper guidance!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More About User Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We only covered buttons and text fields, but there are other crazier inputs
    that you will need eventually.
  prefs: []
  type: TYPE_NORMAL
- en: So if you want to see examples of radio buttons and check boxes, visit [the
    Elm examples page](http://elm-lang.org/examples) which has a bunch of small examples
    you can mess around with. It is all variations on stuff we have learned in this
    tutorial already, so playing with these examples is a great way to practice and
    become more comfortable with what you have learned so far. Maybe try incorporating
    check boxes into the form example?
  prefs: []
  type: TYPE_NORMAL
- en: That said, I want to keep up the momentum of this tutorial and keep introducing
    new concepts, so next we will be looking at how to work with things like HTTP
    and web sockets!
  prefs: []
  type: TYPE_NORMAL
- en: Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Elm Architecture + Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last section showed how to handle all sorts of user input. You can think
    of those programs like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](a39099ae.png)'
  prefs: []
  type: TYPE_IMG
- en: From our perspective, we just receive messages and produce new `Html` to get
    rendered on screen. The “Elm Runtime” is sitting there behind the scenes. When
    it gets `Html` it figures out how to render it on screen [really fast](http://elm-lang.org/blog/blazing-fast-html-round-two).
    When a user clicks on something, it figures out how to pipe that into our program
    as a `Msg`. So the Elm Runtime is in charge of *doing* stuff. We just transform
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section builds on that pattern, giving you the ability to make HTTP requests
    or subscribe to messages from web sockets. Think of it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](e9cd743d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Instead of just producing `Html`, we will now be producing commands and subscriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Commands** — A `Cmd` lets you *do* stuff: generate a random number, send
    an HTTP request, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscriptions** — A `Sub` lets you register that you are interested in something:
    tell me about location changes, listen for web socket messages, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you squint, commands and subscriptions are pretty similar to `Html` values.
    With `Html`, we never touch the DOM by hand. Instead we represent the desired
    HTML as *data* and let the Elm Runtime do some clever stuff to make it render
    [really fast](http://elm-lang.org/blog/blazing-fast-html-round-two). It is the
    same with commands and subscriptions. We create data that *describes* what we
    want to do, and the Elm Runtime does the dirty work.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if it seems a bit confusing for now, the examples will help! So
    first let’s look at how to fit these concepts into the code we have seen before.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the Architecture Skeleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far our architecture skeleton has focused on creating `Model` types and
    `update` and `view` functions. To handle commands and subscriptions, we need to
    extend the basic architecture skeleton a little bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The first three sections are almost exactly the same, but there are a few new
    things overall:'
  prefs: []
  type: TYPE_NORMAL
- en: The `update` function now returns more than just a new model. It returns a new
    model and some commands you want to run. These commands are all going to produce
    `Msg` values that will get fed right back into our `update` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is a `subscriptions` function. This function lets you declare any event
    sources you need to subscribe to given the current model. Just like with `Html
    Msg` and `Cmd Msg`, these subscriptions will produce `Msg` values that get fed
    right back into our `update` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So far `init` has just been the initial model. Now it produces both a model
    and some commands, just like the new `update`. This lets us provide a starting
    value *and* kick off any HTTP requests or whatever that are needed for initialization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now it is totally okay if this does not really make sense yet! That only really
    happens when you start seeing it in action, so let’s hop right into the examples!
  prefs: []
  type: TYPE_NORMAL
- en: '**Aside:** One crucial detail here is that commands and subscriptions are *data*.
    When you create a command, you do not actually *do* it. Same with commands in
    real life. Let’s try it. Eat an entire watermelon in one bite! Did you do it?
    No! You kept reading before you even *thought* about buying a tiny watermelon.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Point is, commands and subscriptions are data. You hand them to Elm to actually
    run them, giving Elm a chance to log all of this information. In the end, effects-as-data
    means Elm can:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Have a general purpose time-travel debugger.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the "same input, same output" guarantee for all Elm functions.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid setup/teardown phases when testing `update` logic.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache and batch effects, minimizing HTTP connections or other resources.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So without going too crazy on details, pretty much all the nice guarantees and
    tools you have in Elm come from the choice to treat effects as data! I think this
    will make more sense as you get deeper into Elm.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Random
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Random
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[Clone the code](https://github.com/evancz/elm-architecture-tutorial/) or follow
    along in the [online editor](http://elm-lang.org/examples/random).'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: We are about to make an app that "rolls dice", producing a random number between
    1 and 6.
  prefs: []
  type: TYPE_NORMAL
- en: When I write code with effects, I usually break it into two phases. Phase one
    is about getting something on screen, just doing the bare minimum to have something
    to work from. Phase two is filling in details, gradually approaching the actual
    goal. We will use this process here too.
  prefs: []
  type: TYPE_NORMAL
- en: Phase One - The Bare Minimum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As always, you start out by guessing at what your `Model` should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For now we will just track `dieFace` as an integer between 1 and 6\. Then I
    would quickly sketch out the `view` function because it seems like the easiest
    next step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So this is typical. Same stuff we have been doing with the user input examples
    of The Elm Architecture. When you click our `<button>` it is going to produce
    a `Roll` message, so I guess it is time to take a first pass at the `update` function
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `update` function has the same overall shape as before, but the return
    type is a bit different. Instead of just giving back a `Model`, it produces both
    a `Model` and a command. The idea is: **we still want to step the model forward,
    but we also want to do some stuff.** In our case, we want to ask Elm to give us
    a random value. For now, I just fill it in with [`Cmd.none`](http://package.elm-lang.org/packages/elm-lang/core/latest/Platform-Cmd#none)
    which means "I have no commands, do nothing." We will fill this in with the good
    stuff in phase two.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I would create an `init` value like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here we specify both the initial model and some commands we'd like to run immediately
    when the app starts. This is exactly the kind of stuff that `update` is producing
    now too.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it is possible to wire it all up and take a look. You can click
    the `<button>`, but nothing happens. Let's fix that!
  prefs: []
  type: TYPE_NORMAL
- en: Phase Two - Adding the Cool Stuff
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The obvious thing missing right now is the randomness! When the user clicks
    a button we want to command Elm to reach into its internal random number generator
    and give us a number between 1 and 6\. The first step I would take towards that
    goal would be adding a new kind of message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We still have `Roll` from before, but now we add `NewFace` for when Elm hands
    us our new random number. That is enough to start filling in `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two new things here. **First**, there is now a branch for `NewFace`
    messages. When a `NewFace` comes in, we just step the model forward and do nothing.
    **Second**, we have added a real command to the `Roll` branch. This uses a couple
    functions from [the `Random` library](http://package.elm-lang.org/packages/elm-lang/core/latest/Random).
    Most important is `Random.generate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes two arguments. The first is a function to tag random values.
    In our case we want to use `NewFace : Int -> Msg` to turn the random number into
    a message for our `update` function. The second argument is a "generator" which
    is like a recipe for producing certain types of random values. You can have generators
    for simple types like `Int` or `Float` or `Bool`, but also for fancy types like
    big custom records with lots of fields. In this case, we use one of the simplest
    generators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You provide a lower and upper bound on the integer, and now you have a generator
    that produces integers in that range!
  prefs: []
  type: TYPE_NORMAL
- en: That is it. Now we can click and see the number flip to some new value!
  prefs: []
  type: TYPE_NORMAL
- en: 'So the big lessons here are:'
  prefs: []
  type: TYPE_NORMAL
- en: Write your programs bit by bit. Start with a simple skeleton, and gradually
    add the tougher stuff.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `update` function now produces a new model *and* a command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot just get random values willy-nilly. You create a command, and Elm
    will go do some work behind the scenes to provide it for you. In fact, any time
    our program needs to get unreliable values (randomness, HTTP, file I/O, database
    reads, etc.) you have to go through Elm.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, the best way to improve your understanding of commands is just
    to see more of them! They will appear prominently with the `Http` and `WebSocket`
    libraries, so if you are feeling shaky, the only path forward is practicing with
    randomness and playing with other examples of commands!
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises:** Here are some that build on stuff that has already been introduced:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Instead of showing a number, show the die face as an image.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a second die and have them both roll at the same time.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And here are some that require new skills:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Instead of showing an image of a die face, use the `elm-lang/svg` library to
    draw it yourself.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: After you have learned about tasks and animation, have the dice flip around
    randomly before they settle on a final value.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[Clone the code](https://github.com/evancz/elm-architecture-tutorial/) or follow
    along in the [online editor](http://elm-lang.org/examples/http).'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: We are about to make an app that fetches a random GIF when the user asks for
    another image.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I am going to assume you just read the randomness example. It (1) introduces
    a two step process for writing apps like this and (2) shows the simplest kind
    of commands possible. Here we will be using the same two step process to build
    up to fancier kinds of commands, so I very highly recommend going back one page.
    I swear you will reach your goals faster if you start with a solid foundation!
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so you read it now right? Good. Let's get started on our random gif fetcher!
  prefs: []
  type: TYPE_NORMAL
- en: Phase One - The Bare Minimum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point in this guide, you should be pretty comfortable smacking down
    the basic skeleton of an Elm app. Guess at the model, fill in some messages, etc.
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For the model, I decided to track a `topic` so I know what kind of gifs to fetch.
    I do not want to hard code it to `"cats"`, and maybe later we will want to let
    the user decide the topic too. I also tracked the `gifUrl` which is a URL that
    points at some random gif.
  prefs: []
  type: TYPE_NORMAL
- en: Like in the randomness example, I just made dummy `init` and `update` functions.
    None of them actually produce any commands for now. The point is just to get something
    on screen!
  prefs: []
  type: TYPE_NORMAL
- en: Phase Two - Adding the Cool Stuff
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alright, the obvious thing missing right now is the HTTP request. I think it
    is easiest to start this process by adding new kinds of messages. Now remember,
    **when you give a command, you have to wait for it to happen.** So when we command
    Elm to do an HTTP request, it is eventually going to tell you "hey, here is what
    you wanted" or it is going to say "oops, something went wrong with the HTTP request".
    We need this to be reflected in our messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We add a case for `NewGif` that holds a `Result`. You can read more about results
    [here](result.html), but the key idea is that it captures the two possible outcomes
    of an HTTP request. It either (1) succeeded with the URL of a random gif or (2)
    failed with some HTTP error (server is down, bad URL, etc.)
  prefs: []
  type: TYPE_NORMAL
- en: 'That is enough to start filling in `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So I added branches for our new messages. When `NewGif` holds a success, we
    update the `gifUrl` field to have the new URL. When `NewGif` holds an error, we
    ignore it, giving back the same model and doing nothing.
  prefs: []
  type: TYPE_NORMAL
- en: I also changed the `MorePlease` branch a bit. We need an HTTP command, so I
    called the `getRandomGif` function. The trick is that I made that function up.
    It does not exist yet. That is the next step!
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining `getRandomGif` might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With that added, the "More" button actually goes and fetches a random gif. Check
    it out [here](http://elm-lang.org/examples/http)! But how does `getRandomGif`
    work exactly?
  prefs: []
  type: TYPE_NORMAL
- en: 'It starts out simple, we define `url` to be some giphy endpoint for random
    gifs. Next we create an HTTP `request` with [`Http.get`](http://package.elm-lang.org/packages/elm-lang/http/latest/Http#get).
    Finally, we turn it into a command with [`Http.send`](http://package.elm-lang.org/packages/elm-lang/http/latest/Http#send).
    Let’s break those steps down a bit more:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Http.get : String -> Decode.Decoder value -> Http.Request value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function takes a URL and a JSON decoder. This is our first time seeing
    a JSON decoder (and we will cover them in depth [later](json.html)), but for now,
    you really just need a high-level understanding. It turns JSON into Elm. In our
    case, we defined `decodeGifUrl` which tries to find a string value at `json.data.image_url`.
    Between the URL and the JSON decoder, we create an `Http.Request`. This is similar
    to a `Random.Generator` like we saw in [the previous example](random.html). It
    does not actually *do* anything. It just describes how to make an HTTP request.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Http.send : (Result Error value -> msg) -> Http.Request value -> Cmd msg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have an HTTP request, we can turn it into a command with `Http.send`.
    This is just like how we used `Random.generate` to create a command with a random
    generator. The first argument is a way to turn the result of the HTTP request
    into a message for our `update` function. In this case, we create a `NewGif` message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This has been a very quick introduction, but the key idea is that you must (1)
    create an HTTP request and (2) turn that into a command so Elm will actually *do*
    it. You can go pretty far using the basic pattern here, and we will be looking
    into JSON decoders [later on](json.html), which will let you deal with whatever
    crazy JSON you run into.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises:** To get more comfortable with this code, try augmenting it with
    skills we learned in previous sections:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show a message explaining why the image didn't change when you get an [`Http.Error`](http://package.elm-lang.org/packages/elm-lang/http/latest/Http#Error).
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the user to modify the `topic` with a text field.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the user to modify the `topic` with a drop down menu.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[Clone the code](https://github.com/evancz/elm-architecture-tutorial/) or follow
    along in the [online editor](http://elm-lang.org/examples/time).'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to make a simple clock.
  prefs: []
  type: TYPE_NORMAL
- en: So far we have focused on commands. With the randomness example, we *asked*
    for a random value. With the HTTP example, we *asked* for info from a server.
    That pattern does not really work for a clock. In this case, we want to sit around
    and hear about clock ticks whenever they happen. This is where **subscriptions**
    come in.
  prefs: []
  type: TYPE_NORMAL
- en: The code is not too crazy here, so I am going to include it in full. After you
    read through, we will come back to normal words that explain it in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing new in the `MODEL` or `UPDATE` sections. Same old stuff. The
    `view` function is kind of interesting. Instead of using HTML, we use the `Svg`
    library to draw some shapes. It works just like HTML though. You provide a list
    of attributes and a list of children for every node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important thing comes in `SUBSCRIPTIONS` section. The `subscriptions` function
    takes in the model, and instead of returning `Sub.none` like in the examples we
    have seen so far, it gives back a real life subscription! In this case `Time.every`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is a time interval. We chose to get ticks every second. The
    second argument is a function that turns the current time into a message for the
    `update` function. We are tagging times with `Tick` so the time 1458863979862
    would become `Tick 1458863979862`.
  prefs: []
  type: TYPE_NORMAL
- en: That is all there is to setting up a subscription! These messages will be fed
    to your `update` function whenever they become available.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises:**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Add a button to pause the clock, turning the `Time` subscription off.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the clock look nicer. Add an hour and minute hand. Etc.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Web Sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web Sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[Clone the code](https://github.com/evancz/elm-architecture-tutorial/) or follow
    along in the [online editor](http://elm-lang.org/examples/websockets).'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to make a simple chat app. There will be a text field so you can
    type things in and a region that shows all the messages we have received so far.
    Web sockets are great for this scenario because they let us set up a persistent
    connection with the server. This means:'
  prefs: []
  type: TYPE_NORMAL
- en: You can send messages cheaply whenever you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server can send *you* messages whenever it feels like it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In other words, `WebSocket` is one of the rare libraries that makes use of both
    commands and subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This program happens to be pretty short, so here is the full thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The interesting parts are probably the uses of `WebSocket.send` and `WebSocket.listen`.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity we will target a simple server that just echos back whatever
    you type. So you will not be able to have the most exciting conversations in the
    basic version, but that is why we have exercises on these examples!
  prefs: []
  type: TYPE_NORMAL
- en: More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More about The Elm Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The emphasis of this section has been: **how can we get people making cool
    Elm projects as quickly and smoothly as possible?** So we covered:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic architecture pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create buttons and text fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make HTTP requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with web sockets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can go quite far with this knowledge, but there are many important aspects
    of Elm itself that we have not covered yet. For example, union types are one of
    the most important features in the whole language and we have not focused on them
    at all!
  prefs: []
  type: TYPE_NORMAL
- en: So we are going to take a break from The Elm Architecture for a couple chapters
    to get a better understanding of Elm itself. We will come back to The Elm Architecture
    in a few chapters and focus on code reuse in larger applications. In the meantime,
    when a function gets so big it feels unmanageable in practice, make a helper function!
    Elm makes refactoring easy, so it is best to improve architecture as needed rather
    than preemptively. More about that later though!
  prefs: []
  type: TYPE_NORMAL
- en: P.S. Best not to skip ahead. You can build a bigger house if you have a strong
    foundation!
  prefs: []
  type: TYPE_NORMAL
