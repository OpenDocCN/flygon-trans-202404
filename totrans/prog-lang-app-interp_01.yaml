- en: 1Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1介绍
- en: 1.1Our Philosophy
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1我们的哲学
- en: Please watch the [video on YouTube](http://www.youtube.com/watch?v=3N__tvmZrzc).
    Someday there will be a textual description here instead.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 请观看[YouTube上的视频](http://www.youtube.com/watch?v=3N__tvmZrzc)。将来这里可能会有文字描述。
- en: 1.2The Structure of This Book
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2本书的结构
- en: 'Unlike some other textbooks, this one does not follow a top-down narrative.
    Rather it has the flow of a conversation, with backtracking. We will often build
    up programs incrementally, just as a pair of programmers would. We will include
    mistakes, not because I don’t know the answer, but because this is the best way
    for you to learn. Including mistakes makes it impossible for you to read passively:
    you must instead engage with the material, because you can never be sure of the
    veracity of what you’re reading.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些教科书不同，这本书不遵循自上而下的叙述。相反，它具有对话的流程，带有回溯。我们经常会逐步构建程序，就像一对程序员会做的那样。我们会包含错误，不是因为我不知道答案，而是因为这是你学习的最佳方式。包含错误使你无法被动阅读：你必须与材料互动，因为你永远不能确定你所阅读的内容的真实性。
- en: At the end, you’ll always get to the right answer. However, this non-linear
    path is more frustrating in the short term (you will often be tempted to say,
    “Just tell me the answer, already!”), and it makes the book a poor reference guide
    (you can’t open up to a random page and be sure what it says is correct). However,
    that feeling of frustration is the sensation of learning. I don’t know of a way
    around it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你总会得到正确的答案。然而，这种非线性的路径在短期内更加令人沮丧（你经常会忍不住说，“告诉我答案吧！”），并且使这本书成为一个糟糕的参考指南（你不能随意翻开一页就确定其正确性）。然而，这种沮丧的感觉就是学习的感觉。我不知道有什么方法可以避免它。
- en: 'At various points you will encounter this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在各个地方你会遇到这样的情况：
- en: Exercise
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: This is an exercise. Do try it.
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是一个练习。请尝试一下。
- en: 'This is a traditional textbook exercise. It’s something you need to do on your
    own. If you’re using this book as part of a course, this may very well have been
    assigned as homework. In contrast, you will also find exercise-like questions
    that look like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个传统的教科书练习。这是你需要自己完成的任务。如果你将这本书作为课程的一部分，这很可能已经被指定为作业。相比之下，你还会发现���似练习的问题，看起来像这样：
- en: Do Now!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就做！
- en: There’s an activity here! Do you see it?
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这里有一个活动！你看到了吗？
- en: When you get to one of these, stop. Read, think, and formulate an answer before
    you proceed. You must do this because this is actually an exercise, but the answer
    is already in the book—<wbr>most often in the text immediately following (i.e.,
    in the part you’re reading right now)—<wbr>or is something you can determine for
    yourself by running a program. If you just read on, you’ll see the answer without
    having thought about it (or not see it at all, if the instructions are to run
    a program), so you will get to neither (a) test your knowledge, nor (b) improve
    your intuitions. In other words, these are additional, explicit attempts to encourage
    active learning. Ultimately, however, I can only encourage it; it’s up to you
    to practice it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遇到这些情况时，请停下来。阅读，思考，并在继续之前制定一个答案。你必须这样做，因为这实际上是一个练习，但答案已经在书中了——<wbr>通常在紧随其后的文本中（即，你正在阅读的部分）——<wbr>或者是你可以通过运行程序自己确定的东西。如果你继续阅读，你会看到答案而没有思考过它（或者根本看不到，如果指令是运行程序），所以你既不能（a）测试你的知识，也不能（b）提高你的直觉。换句话说，这些是鼓励主动学习的额外明确尝试。然而，最终，我只能鼓励它；练习的责任在于你。
- en: 1.3The Language of This Book
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3本书的语言
- en: The main programming language used in this book is [Racket](http://www.racket-lang.org/).
    Like with all operating systems, however, Racket actually supports a host of programming
    languages, so you must tell Racket which language you’re programming in. You inform
    the Unix shell by writing a line like
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中主要使用的编程语言是[Racket](http://www.racket-lang.org/)。然而，与所有操作系统一样，Racket实际上支持一系列编程语言，因此你必须告诉Racket你正在使用哪种语言进行编程。你可以通过写一行像这样的代码来通知Unix
    shell
- en: '| #!/bin/sh |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| #!/bin/sh |'
- en: at the top of a script; you inform the browser by writing, say,
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的顶部；你可以通过写入，比如说，
- en: '| <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" ...> |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" ...> |'
- en: 'Similarly, Racket asks that you declare which language you will be using. Racket
    languages can have the same parenthetical syntax as Racket but with a different
    semantics; the same semantics but a different syntax; or different syntax and
    semantics. Thus every Racket program begins with #lang followed by the name of
    some language: by default, it’s Racket (written as racket). In DrRacket v. 5.3,
    go to Language, then Choose Language, and select “Use the language declared in
    the source”. In this book we’ll almost always use the language'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，Racket 要求您声明将要使用的语言。Racket 语言可以具有与 Racket 相同的括号语法，但语义不同；具有相同的语义但语法不同；或者语法和语义都不同。因此，每个
    Racket 程序都以 `#lang` 开头，后跟某种语言的名称：默认情况下是 Racket（写作 racket）。在 DrRacket v. 5.3 中，转到“语言”，然后选择“选择语言”，并选择“使用源代码中声明的语言”。在本书中，我们几乎总是使用的语言
- en: '| plai-typed |'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| plai-typed |'
- en: . When we deviate we’ll say so explicitly, so unless indicated otherwise, put
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们偏离时，我们会明确说明，因此除非另有说明，否则将
- en: '| #lang plai-typed |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| #lang plai-typed |'
- en: 'at the top of every file (and assume I’ve done the same).The Typed PLAI language
    differs from traditional Racket most importantly by being statically typed. It
    also gives you some useful new constructs: define-type, type-case, and test. There
    are additional commands for controlling the output of testing, for instance. Be
    sure to read the documentation for the language In DrRacket v. 5.3, go to Help,
    then Help Desk, and in the Help Desk search bar, type “plai-typed”. Here’s an
    example of each in use. We can introduce new datatypes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个文件的顶部（并假设我已经做了同样的事情）。Typed PLAI 语言与传统的 Racket 最重要的区别是它是静态类型的。它还为您提供了一些有用的新构造：define-type、type-case
    和 test。例如，还有用于控制测试输出的其他命令。务必阅读语言的文档在 DrRacket v. 5.3 中，转到帮助，然后转到帮助台，在帮助台搜索栏中，键入“plai-typed”。以下是每个用法的示例。我们可以引入新的数据类型：
- en: '| (define-type MisspelledAnimal |'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|（define-type MisspelledAnimal |'
- en: '|   [caml (humps : number)] |'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [caml (humps : number)] |'
- en: '|   [yacc (height : number)]) |'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [yacc (height : number)]) |'
- en: 'You can roughly think of this as analogous to the following in Java: an abstract
    class MisspelledAnimal and two concrete sub-classes caml and yacc, each of which
    has one numeric constructor argument named humps and height, respectively.In this
    language, we construct instances as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以粗略地将此视为 Java 中的以下内容：一个抽象类 MisspelledAnimal 和两个具体的子类 caml 和 yacc，每个类都有一个名为
    humps 和 height 的数值构造函数参数。在此语言中，我们构造实例如下：
- en: '| (caml 2) |'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|（caml 2）|'
- en: '| (yacc 1.9) |'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|（yacc 1.9）|'
- en: 'As the name suggests, define-type creates a type of the given name. We can
    use this when, for instance, binding the above instances to names:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，define-type 创建给定名称的类型。例如，当绑定上述实例到名称时，我们可以使用这个：
- en: '| (define ma1 : MisspelledAnimal (caml 2)) |'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|（define ma1：MisspelledAnimal（caml 2））|'
- en: '| (define ma2 : MisspelledAnimal (yacc 1.9)) |'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|（define ma2：MisspelledAnimal（yacc 1.9））|'
- en: In fact you don’t need these particular type declarations, because Typed PLAI
    will infer types for you here and in many other cases. Thus you could just as
    well have written
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您不需要这些特定的类型声明，因为 Typed PLAI 将在此处和许多其他情况下为您推断类型。因此，您可以写成
- en: '| (define ma1 (caml 2)) |'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|（define ma1（caml 2））|'
- en: '| (define ma2 (yacc 1.9)) |'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|（define ma2（yacc 1.9））|'
- en: but we prefer to write explicit type declarations as a matter of both discipline
    and comprehensibility when we return to programs later.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们更喜欢在以后返回程序时写明确的类型声明，这既是纪律问题，也是可理解性问题。
- en: The type names can even be used recursively, as we will see repeatedly in this
    book (for instance, [Completing the Parser](Everything__We_Will_Say__About_Parsing.html#(part._first-parser))).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 类型名称甚至可以递归使用，正如我们在本书中反复看到的那样（例如，[完成解析器](Everything__We_Will_Say__About_Parsing.html#(part._first-parser))）。
- en: 'The language provides a pattern-matcher for use when writing expressions, such
    as a function’s body:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 该语言为编写表达式（例如函数的主体）提供了模式匹配器：
- en: '| (define (good? [ma : MisspelledAnimal]) : boolean |'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|（define（good？[ma：MisspelledAnimal]）：boolean |'
- en: '|   (type-case MisspelledAnimal ma |'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   （type-case MisspelledAnimal ma |'
- en: '|     [caml (humps) (>= humps 2)] |'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [caml (humps) (>= humps 2)] |'
- en: '|     [yacc (height) (> height 2.1)])) |'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [yacc (height) (> height 2.1)])) |'
- en: 'In the expression (>= humps 2), for instance, humps is the name given to whatever
    value was given as the argument to the constructor caml.Finally, you should write
    test cases, ideally before you’ve defined your function, but also afterwards to
    protect against accidental changes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式（>= humps 2）中，例如，humps 是分配给构造函数 caml 的任何值的名称。最后，你应该编写测试用例，最好在定义函数之前，但也可以在之后以防意外更改：
- en: '| (test (good? ma1) #t) |'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|（测试（好吗？ma1）#t）|'
- en: '| (test (good? ma2) #f) |'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|（测试（好吗？ma2）#f）|'
- en: When you run the above program, the language will give you verbose output telling
    you both tests passed. Read the documentation to learn how to suppress most of
    these messages.Here’s something important that is obscured above. We’ve used the
    same name, humps (and height), in both the datatype definition and in the fields
    of the pattern-match. This is absolutely unnecessary because the two are related
    by position, not name. Thus, we could have as well written the function as
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '当您运行上面的程序时，语言将提供详细的输出，告诉您两个测试都通过了。阅读文档以了解如何抑制大部分这些消息。上面隐藏了一个重要的东西。我们在数据类型定义和模式匹配字段中都使用了相同的名称
    humps（和 height）。这是完全不必要的，因为两者是按位置而不是名称相关的。因此，我们完全可以将函数写成以下形式： '
- en: '| (define (good? [ma : MisspelledAnimal]) : boolean |'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (good? [ma : 拼写错误的动物]) : boolean |'
- en: '|   (type-case MisspelledAnimal ma |'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (type-case 拼写错误的动物 ma |'
- en: '|     [caml (h) (>= h 2)] |'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [caml (h) (>= h 2)] |'
- en: '|     [yacc (h) (> h 2.1)])) |'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [yacc (h) (> h 2.1)])) |'
- en: 'Because each h is only visible in the case branch in which it is introduced,
    the two hs do not in fact clash. You can therefore use convention and readability
    to dictate your choices. In general, it makes sense to provide a long and descriptive
    name when defining the datatype (because you probably won’t use that name again),
    but shorter names in the type-case because you’re likely to use use those names
    one or more times.I did just say you’re unlikely to use the field descriptors
    introduced in the datatype definition, but you can. The language provides selectors
    to extract fields without the need for pattern-matching: e.g., caml-humps. Sometimes,
    it’s much easier to use the selector directly rather than go through the pattern-matcher.
    It often isn’t, as when defining good? above, but just to be clear, let’s write
    it without pattern-matching:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个 h 只在引入它的分支中可见，所以这两个 h 实际上并不冲突。因此，您可以使用约定和可读性来决定您的选择。一般来说，当定义数据类型时提供一个长且描述性的名称是有意义的（因为您可能不会再次使用该名称），但在类型案例中使用较短的名称是有意义的，因为您可能会使用这些名称一次或多次。我刚刚说过，您不太可能使用在数据类型定义中引入的字段描述符，但您可以。语言提供了选择器来提取字段，而无需进行模式匹配：例如，caml-humps。有时，直接使用选择器比经过模式匹配要容易得多。通常不是这样，就像上面定义的
    good? 一样，但为了明确起见，让我们写成没有模式匹配的形式：
- en: '| (define (good? [ma : MisspelledAnimal]) : boolean |'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (good? [ma : 拼写错误的动物]) : boolean |'
- en: '|   (cond |'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (cond |'
- en: '|     [(caml? ma) (>= (caml-humps ma) 2)] |'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(caml? ma) (>= (caml-humps ma) 2)] |'
- en: '|     [(yacc? ma) (> (yacc-height ma) 2.1)])) |'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(yacc? ma) (> (yacc-height ma) 2.1)])) |'
- en: Do Now!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在做！
- en: What happens if you mis-apply functions to the wrong kinds of values? For instance,
    what if you give the caml constructor a string? What if you send a number into
    each version of good? above?
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您将函数错误地应用于错误类型的值会发生什么？例如，如果您给 caml 构造函数一个字符串会发生什么？如果您将一个数字发送到上述每个版本的 good?
    会发生什么？
