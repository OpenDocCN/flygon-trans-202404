- en: Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Measuring Time Efficency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to measure how fast programs runs, we have to devise a reasonable way
    to do so. Using a stopwatch to measure how much time it takes wouldn't work because
    the timings would change each time we had different programs running in the background,
    random fluctuations, solar flares, etc. Moreover, new computers are generally
    faster and old timings wouldn't be applicable.
  prefs: []
  type: TYPE_NORMAL
- en: A better way to approach this is to count the number of steps that a procedure
    takes. Focusing on the procedure allows us to avoid the problem of being tied
    down to any particular computer.
  prefs: []
  type: TYPE_NORMAL
- en: Counting Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some of the procedures we''ll consider as taking "one step":'
  prefs: []
  type: TYPE_NORMAL
- en: All of the following procedures take a single step.
  prefs: []
  type: TYPE_NORMAL
- en: Basic arithmetic operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: defining variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: defining procedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: conditionals?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: user-defined procedure calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: Counting Steps'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the most interesting questions arise when we compare one procedure
    to another, and ask which one is faster. In order to make this comparision, we
    must ask the following for each procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: As we increase the size of the argument, how many steps will this procedure
    take to run?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In other words, if we were to graph the number of steps a procedure takes (with
    the input as the x-axis), what is the shape of that graph?
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Function Runtime'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For `square`, we say this is a *constant* time procedure--`(square 2)` takes
    as many steps as `(square 2000)`. So as we increase the size of our input, the
    number of steps remains *constant*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `last`, the procedure that finds you the last word of a sentence, we say
    this is a *linear* time procedure--as we call `last` on larger and larger inputs,
    the number of steps grows linearly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to formalize this, we have to learn a mathematical construct called
    **Orders of Growth**.
  prefs: []
  type: TYPE_NORMAL
- en: Orders of Growth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Orders of Growth describe the relationship between functions. Given two functions
    *f(n)* and *g(n)*, when we say *f = Θ(g)*, we mean that there exists two numbers,
    *a*, and *b* such that *ag(n) ≤ f(n) ≤ bg(n)* for sufficiently large values of
    *n*.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When *f(n) = n* and *g(n) = 329n*, *f = Θ(g)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When *f(n) = 4n²* and *g(n) = 2n²+n*, *f = Θ(g)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When *f(n) = .0004n³* and *g(n) = 1000n²+30000n*, *f* IS NOT equal to *Θ(g)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on these examples, we have the following rules
  prefs: []
  type: TYPE_NORMAL
- en: We can ignore constant factors in procedures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can ignore lower terms, e.g. in *2n²+n*, we only care about the *n²*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coming back to procedures, we can formally say that `square` is *Θ(1)*, and
    `last` is *Θ(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Exponentiation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the straightforward way to compute `b^n` (`b` to the `n`th power):
    multiply `b` against itself `n` times. Here''s the code for that.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This runs in linear time with respect to the `n` variable. We know this because
    of two observations
  prefs: []
  type: TYPE_NORMAL
- en: If `n` is 2, we make two recursive calls and if `n` is 10, then we make 10 recursive
    calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In each recursive call, there is *Θ(1)* work being done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we do better? Turns out there's a more clever exponentiation algorithm that
    takes advantage of the follow idea of *successive squaring*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we were trying to compute b^8\. Normally, we would do b * b * b
    * b * b * b * b * b. This requires 8 multiplcations. Instead we can do it in 3:
    ![The trick](../Images/4c7b9f6fffa26df3222c4e574f4a63e4.jpg) This method works
    fine for exponents that are powers of 2\. We can also take advantage of successive
    squaring in computing exponentials in general if we use the rule ![The other trick](../Images/0c7f3422c89c551d0277580c39ad5b4a.jpg)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The above tricks give us this procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Squaring every even number allows us to cut down on the number of recursive
    calls. In fact, if you think about it, every other recursive call, we cut down
    `n` by half. This pattern of reducing the problem by half is means that the number
    of recursive calls taken is logarithmic with respect to `n`. Therefore, `fast-expt`
    *= Θ(log(n))*. (If this explanation doesn't make sense, check out 1.2.4\. in the
    Further Reading)
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are short, ungraded exercises for practice with finding the runtime of
    a function.
  prefs: []
  type: TYPE_NORMAL
- en: What is the runtime of bar?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What is the runtime of sort?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[SICP 1.2.3 Orders of Growth](https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_%_sec_1.2.3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SICP 1.2.4 Exponentiation](https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_%_sec_1.2.4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
