["```\nready> def test(x) 1+2+x;\nRead function definition:\ndefine double @test(double %x) {\nentry:\n        %addtmp = fadd double 3.000000e+00, %x\n        ret double %addtmp\n} \n```", "```\nready> def test(x) 1+2+x;\nRead function definition:\ndefine double @test(double %x) {\nentry:\n        %addtmp = fadd double 2.000000e+00, 1.000000e+00\n        %addtmp1 = fadd double %addtmp, %x\n        ret double %addtmp1\n} \n```", "```\nready> def test(x) (1+2+x)*(x+(1+2));\nready> Read function definition:\ndefine double @test(double %x) {\nentry:\n        %addtmp = fadd double 3.000000e+00, %x\n        %addtmp1 = fadd double %x, 3.000000e+00\n        %multmp = fmul double %addtmp, %addtmp1\n        ret double %multmp\n} \n```", "```\nFunctionPassManager OurFPM(TheModule);\n\n// Set up the optimizer pipeline.  Start with registering info about how the\n// target lays out data structures.\nOurFPM.add(new DataLayout(*TheExecutionEngine->getDataLayout()));\n// Provide basic AliasAnalysis support for GVN.\nOurFPM.add(createBasicAliasAnalysisPass());\n// Do simple \"peephole\" optimizations and bit-twiddling optzns.\nOurFPM.add(createInstructionCombiningPass());\n// Reassociate expressions.\nOurFPM.add(createReassociatePass());\n// Eliminate Common SubExpressions.\nOurFPM.add(createGVNPass());\n// Simplify the control flow graph (deleting unreachable blocks, etc).\nOurFPM.add(createCFGSimplificationPass());\n\nOurFPM.doInitialization();\n\n// Set the global so the code gen can use this.\nTheFPM = &OurFPM;\n\n// Run the main \"interpreter loop\" now.\nMainLoop(); \n```", "```\nif (Value *RetVal = Body->Codegen()) {\n  // Finish off the function.\n  Builder.CreateRet(RetVal);\n\n  // Validate the generated code, checking for consistency.\n  verifyFunction(*TheFunction);\n\n  // Optimize the function.\n  TheFPM->run(*TheFunction);\n\n  return TheFunction;\n} \n```", "```\nready> def test(x) (1+2+x)*(x+(1+2));\nready> Read function definition:\ndefine double @test(double %x) {\nentry:\n        %addtmp = fadd double %x, 3.000000e+00\n        %multmp = fmul double %addtmp, %addtmp\n        ret double %multmp\n} \n```", "```\nstatic ExecutionEngine *TheExecutionEngine;\n...\nint main() {\n  ..\n  // Create the JIT.  This takes ownership of the module.\n  TheExecutionEngine = EngineBuilder(TheModule).create();\n  ..\n} \n```", "```\nstatic void HandleTopLevelExpression() {\n  // Evaluate a top-level expression into an anonymous function.\n  if (FunctionAST *F = ParseTopLevelExpr()) {\n    if (Function *LF = F->Codegen()) {\n      LF->dump();  // Dump the function for exposition purposes.\n\n      // JIT the function, returning a function pointer.\n      void *FPtr = TheExecutionEngine->getPointerToFunction(LF);\n\n      // Cast it to the right type (takes no arguments, returns a double) so we\n      // can call it as a native function.\n      double (*FP)() = (double (*)())(intptr_t)FPtr;\n      fprintf(stderr, \"Evaluated to %f\\n\", FP());\n    } \n```", "```\nready> 4+5;\nRead top-level expression:\ndefine double @0() {\nentry:\n  ret double 9.000000e+00\n}\n\nEvaluated to 9.000000 \n```", "```\nready> def testfunc(x y) x + y*2;\nRead function definition:\ndefine double @testfunc(double %x, double %y) {\nentry:\n  %multmp = fmul double %y, 2.000000e+00\n  %addtmp = fadd double %multmp, %x\n  ret double %addtmp\n}\n\nready> testfunc(4, 10);\nRead top-level expression:\ndefine double @1() {\nentry:\n  %calltmp = call double @testfunc(double 4.000000e+00, double 1.000000e+01)\n  ret double %calltmp\n}\n\nEvaluated to 24.000000 \n```", "```\nready> extern sin(x);\nRead extern:\ndeclare double @sin(double)\n\nready> extern cos(x);\nRead extern:\ndeclare double @cos(double)\n\nready> sin(1.0);\nRead top-level expression:\ndefine double @2() {\nentry:\n  ret double 0x3FEAED548F090CEE\n}\n\nEvaluated to 0.841471\n\nready> def foo(x) sin(x)*sin(x) + cos(x)*cos(x);\nRead function definition:\ndefine double @foo(double %x) {\nentry:\n  %calltmp = call double @sin(double %x)\n  %multmp = fmul double %calltmp, %calltmp\n  %calltmp2 = call double @cos(double %x)\n  %multmp4 = fmul double %calltmp2, %calltmp2\n  %addtmp = fadd double %multmp, %multmp4\n  ret double %addtmp\n}\n\nready> foo(4.0);\nRead top-level expression:\ndefine double @3() {\nentry:\n  %calltmp = call double @foo(double 4.000000e+00)\n  ret double %calltmp\n}\n\nEvaluated to 1.000000 \n```", "```\n/// putchard - putchar that takes a double and returns 0.\nextern \"C\"\ndouble putchard(double X) {\n  putchar((char)X);\n  return 0;\n} \n```"]