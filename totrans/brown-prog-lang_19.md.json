["```\ndata BinT:\n  | leaf\n  | node(v, l :: ( -> BinT), r :: ( -> BinT))\nend\n```", "```\nrec tr = node(\"rec\", lam(): tr end, lam(): tr end)\nt0 = node(0, lam(): leaf end, lam(): leaf end)\nt1 = node(1, lam(): t0 end, lam(): t0 end)\nt2 = node(2, lam(): t1 end, lam(): t1 end)\n```", "```\nfun sizeinf(t :: BinT) -> Number:\n  cases (BinT) t:\n    | leaf => 0\n    | node(v, l, r) =>\n      ls = sizeinf(l())\n      rs = sizeinf(r())\n      1 + ls + rs\n  end\nend\n```", "```\ncheck:\n  size(tr) is 1\n  size(t0) is 1\n  size(t1) is 2\n  size(t2) is 3\nend\n```", "```\nfun sizect(t :: BinT) -> Number:\n  fun szacc(shadow t :: BinT, seen :: List<BinT>) -> Number:\n    if has-id(seen, t):\n      0\n    else:\n      cases (BinT) t:\n        | leaf => 0\n        | node(v, l, r) =>\n          ns = link(t, seen)\n          ls = szacc(l(), ns)\n          rs = szacc(r(), ns)\n          1 + ls + rs\n      end\n    end\n  end\n  szacc(t, empty)\nend\n```", "```\nfun has-id<A>(seen :: List<A>, t :: A):\n  cases (List) seen:\n    | empty => false\n    | link(f, r) =>\n      if f <=> t: true\n      else: has-id(r, t)\n      end\n  end\nend\n```", "```\nls = szacc(l(), ns)\nrs = szacc(r(), ns)\n\n```", "```\nfun size(t :: BinT) -> Number:\n  fun szacc(shadow t :: BinT, seen :: List<BinT>)\n    -> {n :: Number, s :: List<BinT>}:\n    if has-id(seen, t):\n      {n: 0, s: seen}\n    else:\n      cases (BinT) t:\n        | leaf => {n: 0, s: seen}\n        | node(v, l, r) =>\n          ns = link(t, seen)\n          ls = szacc(l(), ns)\n          rs = szacc(r(), ls.s)\n          {n: 1 + ls.n + rs.n, s: rs.s}\n      end\n    end\n  end\n  szacc(t, empty).n\nend\n```", "```\ndata KeyedNode:\n  | keyed-node(key :: String, content, adj :: List<String>)\nend\n\ntype KNGraph = List<KeyedNode>\n\ntype Node = KeyedNode\ntype Graph = KNGraph\n```", "```\nkn-cities :: Graph = block:\n  knEWR = keyed-node(\"nwk\", \"Newark\", [list: \"chi\", \"den\", \"saf\", \"hou\"])\n  knORD = keyed-node(\"chi\", \"Chicago\", [list: \"nwk\", \"saf\"])\n  knWOS = keyed-node(\"wor\", \"Worcester\", [list: ])\n  knHOU = keyed-node(\"hou\", \"Houston\", [list: \"nwk\", \"saf\"])\n  knDEN = keyed-node(\"den\", \"Denver\", [list: \"nwk\", \"saf\"])\n  knSFO = keyed-node(\"saf\", \"San Francisco\", [list: \"nwk\", \"den\", \"hou\"])\n  [list: knEWR, knORD, knWOS, knHOU, knDEN, knSFO]\nend\n```", "```\nfun find-kn(key :: Key, graph :: Graph) -> Node:\n  matches = for filter(n from graph):\n    n.key == key\n  end\n  matches.first # there had better be exactly one!\nend\n```", "```\nfun kn-neighbors(city :: Key,  graph :: Graph) -> List<Key>:\n  city-node = find-kn(city, graph)\n  city-node.adj\nend\n```", "```\ncheck:\n  ns = kn-neighbors(\"hou\", kn-cities)\n\n  ns is [list: \"nwk\", \"saf\"]\n\n  map(_.content, map(find-kn(_, kn-cities), ns)) is\n    [list: \"Newark\", \"San Francisco\"]\nend\n```", "```\ndata IndexedNode:\n  | idxed-node(content, adj :: List<Number>)\nend\n\ntype IXGraph = List<IndexedNode>\n\ntype Node = IndexedNode\ntype Graph = IXGraph\n```", "```\nix-cities :: Graph = block:\n  inEWR = idxed-node(\"Newark\", [list: 1, 4, 5, 3])\n  inORD = idxed-node(\"Chicago\", [list: 0, 5])\n  inWOS = idxed-node(\"Worcester\", [list: ])\n  inHOU = idxed-node(\"Houston\", [list: 0, 5])\n  inDEN = idxed-node(\"Denver\", [list: 0, 5])\n  inSFO = idxed-node(\"San Francisco\", [list: 0, 4, 3])\n  [list: inEWR, inORD, inWOS, inHOU, inDEN, inSFO]\nend\n```", "```\nfun find-ix(idx :: Key, graph :: Graph) -> Node:\n  index(graph, idx)\nend\n```", "```\nfun ix-neighbors(city :: Key,  graph :: Graph) -> List<Key>:\n  city-node = find-ix(city, graph)\n  city-node.adj\nend\n```", "```\ncheck:\n  ns = ix-neighbors(3, ix-cities)\n\n  ns is [list: 0, 5]\n\n  map(_.content, map(find-ix(_, ix-cities), ns)) is\n    [list: \"Newark\", \"San Francisco\"]\nend\n```", "```\ndata Edge:\n  | edge(src :: String, dst :: String)\nend\n\ntype LEGraph = List<Edge>\n\ntype Graph = LEGraph\n```", "```\nle-cities :: Graph =\n  [list:\n    edge(\"Newark\", \"Chicago\"),\n    edge(\"Newark\", \"Denver\"),\n    edge(\"Newark\", \"San Francisco\"),\n    edge(\"Newark\", \"Houston\"),\n    edge(\"Chicago\", \"Newark\"),\n    edge(\"Chicago\", \"San Francisco\"),\n    edge(\"Houston\", \"Newark\"),\n    edge(\"Houston\", \"San Francisco\"),\n    edge(\"Denver\", \"Newark\"),\n    edge(\"Denver\", \"San Francisco\"),\n    edge(\"San Francisco\", \"Newark\"),\n    edge(\"San Francisco\", \"Denver\"),\n    edge(\"San Francisco\", \"Houston\") ]\n```", "```\nfun le-neighbors(city :: Key, graph :: Graph) -> List<Key>:\n  neighboring-edges = for filter(e from graph):\n    city == e.src\n  end\n  names = for map(e from neighboring-edges): e.dst end\n  names\nend\n```", "```\ncheck:\n  le-neighbors(\"Houston\", le-cities) is\n    [list: \"Newark\", \"San Francisco\"]\nend\n```", "```\nfun ormap(fun-body, l):\n  cases (List) l:\n    | empty => false\n    | link(f, r) =>\n      if fun-body(f): true else: ormap(fun-body, r) end\n  end\nend\n```", "```\nfor ormap(n from neighbors(src, g)):\n  reach-1(n, dst, g)\nend\n```", "```\n> > if src == dst:\n> >   true\n> > else if visited.member(src):\n> >   false\n> > ```", "```\nfun reach-3(s :: Key, d :: Key, g :: Graph) -> Boolean:\n  fun reacher(src :: Key, dst :: Key, visited :: List<Key>) -> Boolean:\n    if visited.member(src):\n      false\n    else if src == dst:\n      true\n    else:\n      new-visited = link(src, visited)\n      for ormap(n from neighbors(src, g)):\n        reacher(n, dst, new-visited)\n      end\n    end\n  end\n  reacher(s, d, empty)\nend\n```", "```\nw :: Key -> Number\n```", "```\nw :: Key -> Option<Number>\n```", "```\ndata Element<T>:\n  | elt(val :: T, parent :: Option<Element>)\nend\n```", "```\nfun is-same-element(e1, e2): e1.val <=> e2.val end\n```", "```\nfun is-in-same-set(e1 :: Element, e2 :: Element, s :: Sets)\n    -> Boolean:\n  s1 = fynd(e1, s)\n  s2 = fynd(e2, s)\n  identical(s1, s2)\nend\n```", "```\ntype Sets = List<Element>\n```", "```\nfun fynd(e :: Element, s :: Sets) -> Element:\n  cases (List) s:\n    | empty => raise(\"fynd: shouldn't have gotten here\")\n    | link(f, r) =>\n      if is-same-element(f, e):\n        cases (Option) f.parent:\n          | none => f\n          | some(p) => fynd(p, s)\n        end\n      else:\n        fynd(e, r)\n      end\n  end\nend\n```", "```\nfun union(e1 :: Element, e2 :: Element, s :: Sets) -> Sets:\n  s1 = fynd(e1, s)\n  s2 = fynd(e2, s)\n  if identical(s1, s2):\n    s\n  else:\n    update-set-with(s, s1, s2)\n  end\nend\n```", "```\nfun update-set-with(s :: Sets, child :: Element, parent :: Element)\n    -> Sets:\n  cases (List) s:\n    | empty => raise(\"update: shouldn't have gotten here\")\n    | link(f, r) =>\n      if is-same-element(f, child):\n        link(elt(f.val, some(parent)), r)\n      else:\n        link(f, update-set-with(r, child, parent))\n      end\n  end\nend\n```", "```\ncheck:\n  s0 = map(elt(_, none), [list: 0, 1, 2, 3, 4, 5, 6, 7])\n  s1 = union(index(s0, 0), index(s0, 2), s0)\n  s2 = union(index(s1, 0), index(s1, 3), s1)\n  s3 = union(index(s2, 3), index(s2, 5), s2)\n  print(s3)\n  is-same-element(fynd(index(s0, 0), s3), fynd(index(s0, 5), s3)) is true\n  is-same-element(fynd(index(s0, 2), s3), fynd(index(s0, 5), s3)) is true\n  is-same-element(fynd(index(s0, 3), s3), fynd(index(s0, 5), s3)) is true\n  is-same-element(fynd(index(s0, 5), s3), fynd(index(s0, 5), s3)) is true\n  is-same-element(fynd(index(s0, 7), s3), fynd(index(s0, 7), s3)) is true\nend\n```"]