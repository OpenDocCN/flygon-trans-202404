- en: Chapter 2\. Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is an introduction to Scheme for programmers who are new to the
    language. You will get more from this chapter if you are sitting in front of an
    interactive Scheme system, trying out the examples as you go.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter and working the exercises, you should be able to
    start using Scheme. You will have learned the syntax of Scheme programs and how
    they are executed, along with how to use simple data structures and control mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Section 2.1\. Interacting with Scheme
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most Scheme systems provide an interactive programming environment that simplifies
    program development and experimentation. The simplest interaction with Scheme
    follows a "read-evaluate-print" cycle. A program (often called a *read-evaluate-print
    loop*, or REPL) reads each expression you type at the keyboard, evaluates it,
    and prints its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an interactive Scheme system, you can type an expression at the keyboard
    and see its value immediately. You can define a procedure and apply it to arguments
    to see how it works. You can even type in an entire program consisting of a set
    of procedure definitions and test it without leaving the system. When your program
    starts getting longer, it will be more convenient to type it into a file (using
    a text editor), load the file and test it interactively. In most Scheme systems,
    a file may be loaded with the nonstandard procedure `load`, which takes a string
    argument naming the file. Preparing your program in a file has several advantages:
    you have a chance to compose your program more carefully, you can correct errors
    without retyping the program, and you can retain a copy for later use. Most Scheme
    implementations treat expressions loaded from a file the same as expressions typed
    at the keyboard.'
  prefs: []
  type: TYPE_NORMAL
- en: While Scheme provides various input and output procedures, the REPL takes care
    of reading expressions and printing their values. This frees you to concentrate
    on writing your program without worrying about how its results will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this chapter and in the rest of the book follow a regular format.
    An expression you might type from your keyboard is given first, possibly spanning
    several lines. The value of the expression is given after the ![<graphic>](ch2_0.gif),
    to be read as "evaluates to." The ![<graphic>](ch2_0.gif) is omitted for definitions
    and when the value of an expression is unspecified.
  prefs: []
  type: TYPE_NORMAL
- en: The example programs are formatted in a style that "looks nice" and conveys
    the structure of the program. The code is easy to read because the relationship
    between each expression and its subexpressions is clearly shown. Scheme ignores
    indentation and line breaks, however, so there is no need to follow a particular
    style. The important thing is to establish one style and keep to it. Scheme sees
    each program as if it were on a single line, with its subexpressions ordered from
    left to right.
  prefs: []
  type: TYPE_NORMAL
- en: If you have access to an interactive Scheme system, it might be a good idea
    to start it up now and type in the examples as you read. One of the simplest Scheme
    expressions is a string constant. Try typing `"Hi Mom!"` (including the double
    quotes) in response to the prompt. The system should respond with `"Hi Mom!"`;
    the value of any constant is the constant itself.
  prefs: []
  type: TYPE_NORMAL
- en: '`"Hi Mom!" ![<graphic>](ch2_0.gif) "Hi Mom!"`'
  prefs: []
  type: TYPE_NORMAL
- en: Here is a set of expressions, each with Scheme's response. They are explained
    in later sections of this chapter, but for now use them to practice interacting
    with Scheme.
  prefs: []
  type: TYPE_NORMAL
- en: '`"hello" ![<graphic>](ch2_0.gif) "hello"'
  prefs: []
  type: TYPE_NORMAL
- en: 42 ![<graphic>](ch2_0.gif) 42
  prefs: []
  type: TYPE_NORMAL
- en: 22/7 ![<graphic>](ch2_0.gif) 22/7
  prefs: []
  type: TYPE_NORMAL
- en: 3.141592653 ![<graphic>](ch2_0.gif) 3.141592653
  prefs: []
  type: TYPE_NORMAL
- en: + ![<graphic>](ch2_0.gif) #<procedure>
  prefs: []
  type: TYPE_NORMAL
- en: (+ 76 31) ![<graphic>](ch2_0.gif) 107
  prefs: []
  type: TYPE_NORMAL
- en: (* -12 10) ![<graphic>](ch2_0.gif) -120
  prefs: []
  type: TYPE_NORMAL
- en: '''(a b c d) ![<graphic>](ch2_0.gif) (a b c d)`'
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to miss any single quotes ( `'` ), double quotes, or parentheses.
    If you left off a single quote in the last expression, you probably received a
    message indicating that an exception has occurred. Just try again. If you left
    off a closing parenthesis or double quote, the system might still be waiting for
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Here are a few more expressions to try. You can try to figure out on your own
    what they mean or wait to find out later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '`(car ''(a b c)) ![<graphic>](ch2_0.gif) a'
  prefs: []
  type: TYPE_NORMAL
- en: (cdr '(a b c)) ![<graphic>](ch2_0.gif) (b c)
  prefs: []
  type: TYPE_NORMAL
- en: (cons 'a '(b c)) ![<graphic>](ch2_0.gif) (a b c)
  prefs: []
  type: TYPE_NORMAL
- en: (cons (car '(a b c))
  prefs: []
  type: TYPE_NORMAL
- en: (cdr '(d e f))) ![<graphic>](ch2_0.gif) (a e f)`
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Scheme expressions may span more than one line. The Scheme system
    knows when it has an entire expression by matching double quotes and parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's try defining a procedure.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define square'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (* n n)))`
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `square` computes the square *n*² of any number *n*. We say more
    about the expressions that make up this definition later in this chapter. For
    now it suffices to say that `define` establishes variable bindings, `lambda` creates
    procedures, and `*` names the multiplication procedure. Note the form of these
    expressions. All structured forms are enclosed in parentheses and written in *prefix
    notation*, i.e., the operator precedes the arguments. As you can see, this is
    true even for simple arithmetic operations such as `*`.
  prefs: []
  type: TYPE_NORMAL
- en: Try using `square`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(square 5) ![<graphic>](ch2_0.gif) 25'
  prefs: []
  type: TYPE_NORMAL
- en: (square -200) ![<graphic>](ch2_0.gif) 40000
  prefs: []
  type: TYPE_NORMAL
- en: (square 0.5) ![<graphic>](ch2_0.gif) 0.25
  prefs: []
  type: TYPE_NORMAL
- en: (square -1/2) ![<graphic>](ch2_0.gif) 1/4`
  prefs: []
  type: TYPE_NORMAL
- en: Even though the next definition is short, you might enter it into a file. Let's
    assume you call the file "reciprocal.ss."
  prefs: []
  type: TYPE_NORMAL
- en: '`(define reciprocal'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (if (= n 0)
  prefs: []
  type: TYPE_NORMAL
- en: '"oops!"'
  prefs: []
  type: TYPE_NORMAL
- en: (/ 1 n))))`
  prefs: []
  type: TYPE_NORMAL
- en: This procedure, `reciprocal`, computes the quantity 1/*n* for any number *n*
    ≠ 0. For *n* = 0, `reciprocal` returns the string `"oops!"`. Return to Scheme
    and try loading your file with the procedure `load`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(load "reciprocal.ss")`'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, try using the procedure we have just defined.
  prefs: []
  type: TYPE_NORMAL
- en: '`(reciprocal 10) ![<graphic>](ch2_0.gif) 1/10'
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal 1/10) ![<graphic>](ch2_0.gif) 10
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal 0) ![<graphic>](ch2_0.gif) "oops!"
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal (reciprocal 1/10)) ![<graphic>](ch2_0.gif) 1/10`
  prefs: []
  type: TYPE_NORMAL
- en: In the next section we will discuss Scheme expressions in more detail. Throughout
    this chapter, keep in mind that your Scheme system is one of the most useful tools
    for learning Scheme. Whenever you try one of the examples in the text, follow
    it up with your own examples. In an interactive Scheme system, the cost of trying
    something out is relatively small---usually just the time to type it in.
  prefs: []
  type: TYPE_NORMAL
- en: Section 2.2\. Simple Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest Scheme expressions are constant data objects, such as strings,
    numbers, symbols, and lists. Scheme supports other object types, but these four
    are enough for many programs. We saw some examples of strings and numbers in the
    preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss numbers in a little more detail. Numbers are constants. If you
    enter a number, Scheme echoes it back to you. The following examples show that
    Scheme supports several types of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '`123456789987654321 ![<graphic>](ch2_0.gif) 123456789987654321'
  prefs: []
  type: TYPE_NORMAL
- en: 3/4 ![<graphic>](ch2_0.gif) 3/4
  prefs: []
  type: TYPE_NORMAL
- en: 2.718281828 ![<graphic>](ch2_0.gif) 2.718281828
  prefs: []
  type: TYPE_NORMAL
- en: 2.2+1.1i ![<graphic>](ch2_0.gif) 2.2+1.1i`
  prefs: []
  type: TYPE_NORMAL
- en: Scheme numbers include exact and inexact integer, rational, real, and complex
    numbers. Exact integers and rational numbers have arbitrary precision, i.e., they
    can be of arbitrary size. Inexact numbers are usually represented internally using
    IEEE standard floating-point representations.
  prefs: []
  type: TYPE_NORMAL
- en: Scheme provides the names `+`, `-`, `*`, and `/` for the corresponding arithmetic
    procedures. Each procedure accepts two numeric arguments. The expressions below
    are called *procedure applications*, because they specify the application of a
    procedure to a set of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 1/2 1/2) ![<graphic>](ch2_0.gif) 1'
  prefs: []
  type: TYPE_NORMAL
- en: (- 1.5 1/2) ![<graphic>](ch2_0.gif) 1.0
  prefs: []
  type: TYPE_NORMAL
- en: (* 3 1/2) ![<graphic>](ch2_0.gif) 3/2
  prefs: []
  type: TYPE_NORMAL
- en: (/ 1.5 3/4) ![<graphic>](ch2_0.gif) 2.0`
  prefs: []
  type: TYPE_NORMAL
- en: Scheme employs prefix notation even for common arithmetic operations. Any procedure
    application, whether the procedure takes zero, one, two, or more arguments, is
    written as `(*procedure* *arg* ...)`. This regularity simplifies the syntax of
    expressions; one notation is employed regardless of the operation, and there are
    no complicated rules regarding the precedence or associativity of operators.
  prefs: []
  type: TYPE_NORMAL
- en: Procedure applications may be nested, in which case the innermost values are
    computed first. We can thus nest applications of the arithmetic procedures given
    above to evaluate more complicated formulas.
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ (+ 2 2) (+ 2 2)) ![<graphic>](ch2_0.gif) 8'
  prefs: []
  type: TYPE_NORMAL
- en: (- 2 (* 4 1/3)) ![<graphic>](ch2_0.gif) 2/3
  prefs: []
  type: TYPE_NORMAL
- en: (* 2 (* 2 (* 2 (* 2 2)))) ![<graphic>](ch2_0.gif) 32
  prefs: []
  type: TYPE_NORMAL
- en: (/ (* 6/7 7/2) (- 4.5 1.5)) ![<graphic>](ch2_0.gif) 1.0`
  prefs: []
  type: TYPE_NORMAL
- en: These examples demonstrate everything you need to use Scheme as a four-function
    desk calculator. While we will not discuss them in this chapter, Scheme supports
    many other arithmetic procedures. Now might be a good time to turn to Section [6.4](objects.html#g110)
    and experiment with some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Simple numeric objects are sufficient for many tasks, but sometimes aggregate
    data structures containing two or more values are needed. In many languages, the
    basic aggregate data structure is the array. In Scheme, it is the *list*. Lists
    are written as sequences of objects surrounded by parentheses. For instance, `(1 2 3 4 5)`
    is a list of numbers, and `("this" "is" "a" "list")` is a list of strings. Lists
    need not contain only one type of object, so `(4.2 "hi")` is a valid list containing
    a number and a string. Lists may be nested (may contain other lists), so `((1 2) (3 4))`
    is a valid list with two elements, each of which is a list of two elements.
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that lists look just like procedure applications and wonder
    how Scheme tells them apart. That is, how does Scheme distinguish between a list
    of objects, `(*obj[1]* *obj[2]* ...)`, and a procedure application, `(*procedure* *arg* ...)`?
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the distinction might seem obvious. The list of numbers `(1 2 3 4 5)`
    could hardly be confused with a procedure application, since 1 is a number, not
    a procedure. So, the answer might be that Scheme looks at the first element of
    the list or procedure application and makes its decision based on whether that
    first element is a procedure or not. This answer is not good enough, since we
    might even want to treat a valid procedure application such as `(+ 3 4)` as a
    list. The answer is that we must tell Scheme explicitly to treat a list as data
    rather than as a procedure application. We do this with `quote`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(quote (1 2 3 4 5)) ![<graphic>](ch2_0.gif) (1 2 3 4 5)'
  prefs: []
  type: TYPE_NORMAL
- en: (quote ("this" "is" "a" "list")) ![<graphic>](ch2_0.gif) ("this" "is" "a" "list")
  prefs: []
  type: TYPE_NORMAL
- en: (quote (+ 3 4)) ![<graphic>](ch2_0.gif) (+ 3 4)`
  prefs: []
  type: TYPE_NORMAL
- en: The `quote` forces the list to be treated as data. Try entering the above expressions
    without the quote; you will likely receive a message indicating that an exception
    has occurred for the first two and an incorrect answer (`7`) for the third.
  prefs: []
  type: TYPE_NORMAL
- en: Because `quote` is required fairly frequently in Scheme code, Scheme recognizes
    a single quotation mark ( `'` ) preceding an expression as an abbreviation for
    `quote`.
  prefs: []
  type: TYPE_NORMAL
- en: '`''(1 2 3 4) ![<graphic>](ch2_0.gif) (1 2 3 4)'
  prefs: []
  type: TYPE_NORMAL
- en: '''((1 2) (3 4)) ![<graphic>](ch2_0.gif) ((1 2) (3 4))'
  prefs: []
  type: TYPE_NORMAL
- en: '''(/ (* 2 -1) 3) ![<graphic>](ch2_0.gif) (/ (* 2 -1) 3)`'
  prefs: []
  type: TYPE_NORMAL
- en: Both forms are referred to as `quote` expressions. We often say an object is
    *quoted* when it is enclosed in a `quote` expression.
  prefs: []
  type: TYPE_NORMAL
- en: A `quote` expression is *not* a procedure application, since it inhibits the
    evaluation of its subexpression. It is an entirely different syntactic form. Scheme
    supports several other syntactic forms in addition to procedure applications and
    `quote` expressions. Each syntactic form is evaluated differently. Fortunately,
    the number of different syntactic forms is small. We will see more of them later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Not all `quote` expressions involve lists. Try the following expression with
    and without the `quote` wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: '`(quote hello) ![<graphic>](ch2_0.gif) hello`'
  prefs: []
  type: TYPE_NORMAL
- en: The symbol `hello` must be quoted in order to prevent Scheme from treating `hello`
    as a *variable*. Symbols and variables in Scheme are similar to symbols and variables
    in mathematical expressions and equations. When we evaluate the mathematical expression
    1 - *x* for some value of *x*, we think of *x* as a variable. On the other hand,
    when we consider the algebraic equation *x*² - 1 = (*x* - 1)(*x* + 1), we think
    of *x* as a symbol (in fact, we think of the whole equation symbolically). Just
    as quoting a list tells Scheme to treat a parenthesized form as a list rather
    than as a procedure application, quoting an identifier tells Scheme to treat the
    identifier as a symbol rather than as a variable. While symbols are commonly used
    to represent variables in symbolic representations of equations or programs, symbols
    may also be used, for example, as words in the representation of natural language
    sentences.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder why applications and variables share notations with lists and
    symbols. The shared notation allows Scheme programs to be represented as Scheme
    data, simplifying the writing of interpreters, compilers, editors, and other tools
    in Scheme. This is demonstrated by the Scheme interpreter given in Section [12.7](examples.html#g187),
    which is itself written in Scheme. Many people believe this to be one of the most
    important features of Scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers and strings may be quoted, too.
  prefs: []
  type: TYPE_NORMAL
- en: '`''2 ![<graphic>](ch2_0.gif) 2'
  prefs: []
  type: TYPE_NORMAL
- en: '''2/3 ![<graphic>](ch2_0.gif) 2/3'
  prefs: []
  type: TYPE_NORMAL
- en: (quote "Hi Mom!") ![<graphic>](ch2_0.gif) "Hi Mom!"`
  prefs: []
  type: TYPE_NORMAL
- en: Numbers and strings are treated as constants in any case, however, so quoting
    them is unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s discuss some Scheme procedures for manipulating lists. There are
    two basic procedures for taking lists apart: `car` and `cdr` (pronounced *could-er*).
    `car` returns the first element of a list, and `cdr` returns the remainder of
    the list. (The names "car" and "cdr" are derived from operations supported by
    the first computer on which a Lisp language was implemented, the IBM 704.) Each
    requires a nonempty list as its argument.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(car ''(a b c)) ![<graphic>](ch2_0.gif) a'
  prefs: []
  type: TYPE_NORMAL
- en: (cdr '(a b c)) ![<graphic>](ch2_0.gif) (b c)
  prefs: []
  type: TYPE_NORMAL
- en: (cdr '(a)) ![<graphic>](ch2_0.gif) ()
  prefs: []
  type: TYPE_NORMAL
- en: (car (cdr '(a b c))) ![<graphic>](ch2_0.gif) b
  prefs: []
  type: TYPE_NORMAL
- en: (cdr (cdr '(a b c))) ![<graphic>](ch2_0.gif) (c)
  prefs: []
  type: TYPE_NORMAL
- en: (car '((a b) (c d))) ![<graphic>](ch2_0.gif) (a b)
  prefs: []
  type: TYPE_NORMAL
- en: (cdr '((a b) (c d))) ![<graphic>](ch2_0.gif) ((c d))`
  prefs: []
  type: TYPE_NORMAL
- en: The first element of a list is often called the "car" of the list, and the rest
    of the list is often called the "cdr" of the list. The cdr of a list with one
    element is `()`, the *empty list*.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `cons` constructs lists. It takes two arguments. The second argument
    is usually a list, and in that case `cons` returns a list.
  prefs: []
  type: TYPE_NORMAL
- en: '`(cons ''a ''()) ![<graphic>](ch2_0.gif) (a)'
  prefs: []
  type: TYPE_NORMAL
- en: (cons 'a '(b c)) ![<graphic>](ch2_0.gif) (a b c)
  prefs: []
  type: TYPE_NORMAL
- en: (cons 'a (cons 'b (cons 'c '()))) ![<graphic>](ch2_0.gif) (a b c)
  prefs: []
  type: TYPE_NORMAL
- en: (cons '(a b) '(c d)) ![<graphic>](ch2_0.gif) ((a b) c d)
  prefs: []
  type: TYPE_NORMAL
- en: (car (cons 'a '(b c))) ![<graphic>](ch2_0.gif) a
  prefs: []
  type: TYPE_NORMAL
- en: (cdr (cons 'a '(b c))) ![<graphic>](ch2_0.gif) (b c)
  prefs: []
  type: TYPE_NORMAL
- en: (cons (car '(a b c))
  prefs: []
  type: TYPE_NORMAL
- en: (cdr '(d e f))) ![<graphic>](ch2_0.gif) (a e f)
  prefs: []
  type: TYPE_NORMAL
- en: (cons (car '(a b c))
  prefs: []
  type: TYPE_NORMAL
- en: (cdr '(a b c))) ![<graphic>](ch2_0.gif) (a b c)`
  prefs: []
  type: TYPE_NORMAL
- en: Just as "car" and "cdr" are often used as nouns, "cons" is often used as a verb.
    Creating a new list by adding an element to the beginning of a list is referred
    to as *consing* the element onto the list.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the word "usually" in the description of `cons`'s second argument. The
    procedure `cons` actually builds *pairs*, and there is no reason that the cdr
    of a pair must be a list. A list is a sequence of pairs; each pair's cdr is the
    next pair in the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch2_1.gif)'
  prefs: []
  type: TYPE_IMG
- en: The cdr of the last pair in a *proper list* is the empty list. Otherwise, the
    sequence of pairs forms an *improper list*. More formally, the empty list is a
    proper list, and any pair whose cdr is a proper list is a proper list.
  prefs: []
  type: TYPE_NORMAL
- en: An improper list is printed in *dotted-pair notation*, with a period, or *dot*,
    preceding the final element of the list.
  prefs: []
  type: TYPE_NORMAL
- en: '`(cons ''a ''b) ![<graphic>](ch2_0.gif) (a . b)'
  prefs: []
  type: TYPE_NORMAL
- en: (cdr '(a . b)) ![<graphic>](ch2_0.gif) b
  prefs: []
  type: TYPE_NORMAL
- en: (cons 'a '(b . c)) ![<graphic>](ch2_0.gif) (a b . c)`
  prefs: []
  type: TYPE_NORMAL
- en: Because of its printed notation, a pair whose cdr is not a list is often called
    a *dotted pair*. Even pairs whose cdrs are lists can be written in dotted-pair
    notation, however, although the printer always chooses to write proper lists without
    dots.
  prefs: []
  type: TYPE_NORMAL
- en: '`''(a . (b . (c . ()))) ![<graphic>](ch2_0.gif) (a b c)`'
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `list` is similar to `cons`, except that it takes an arbitrary
    number of arguments and always builds a proper list.
  prefs: []
  type: TYPE_NORMAL
- en: '`(list ''a ''b ''c) ![<graphic>](ch2_0.gif) (a b c)'
  prefs: []
  type: TYPE_NORMAL
- en: (list 'a) ![<graphic>](ch2_0.gif) (a)
  prefs: []
  type: TYPE_NORMAL
- en: (list) ![<graphic>](ch2_0.gif) ()`
  prefs: []
  type: TYPE_NORMAL
- en: Section [6.3](objects.html#g109) provides more information on lists and the
    Scheme procedures for manipulating them. This might be a good time to turn to
    that section and familiarize yourself with the other procedures given there.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.2.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Convert the following arithmetic expressions into Scheme expressions and evaluate
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '| *  a*. | 1.2 × (2 - 1/3) + -8.7 |'
  prefs: []
  type: TYPE_TB
- en: '| *  b*. | (2/3 + 4/9) ÷ (5/11 - 4/3) |'
  prefs: []
  type: TYPE_TB
- en: '| *  c*. | 1 + 1 ÷ (2 + 1 ÷ (1 + 1/2)) |'
  prefs: []
  type: TYPE_TB
- en: '| *  d*. | 1 × -2 × 3 × -4 × 5 × -6 × 7 |'
  prefs: []
  type: TYPE_TB
- en: Exercise 2.2.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Experiment with the procedures `+`, `-`, `*`, and `/` to determine Scheme's
    rules for the type of value returned by each when given different types of numeric
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.2.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Determine the values of the following expressions. Use your Scheme system to
    verify your answers.
  prefs: []
  type: TYPE_NORMAL
- en: '| *  a*. | `(cons ''car ''cdr)` |'
  prefs: []
  type: TYPE_TB
- en: '| *  b*. | `(list ''this ''(is silly))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  c*. | `(cons ''is ''(this silly?))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  d*. | `(quote (+ 2 3))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  e*. | `(cons ''+ ''(2 3))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  f*. | `(car ''(+ 2 3))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  g*. | `(cdr ''(+ 2 3))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  h*. | `cons` |'
  prefs: []
  type: TYPE_TB
- en: '| *  i*. | `(quote cons)` |'
  prefs: []
  type: TYPE_TB
- en: '| *  j*. | `(quote (quote cons))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  k*. | `(car (quote (quote cons)))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  l*. | `(+ 2 3)` |'
  prefs: []
  type: TYPE_TB
- en: '| *  m*. | `(+ ''2 ''3)` |'
  prefs: []
  type: TYPE_TB
- en: '| *  n*. | `(+ (car ''(2 3)) (car (cdr ''(2 3))))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  o*. | `((car (list + - * /)) 2 3)` |'
  prefs: []
  type: TYPE_TB
- en: Exercise 2.2.4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`(car (car ''((a b) (c d))))` yields `a`. Determine which compositions of `car`
    and `cdr` applied to `((a b) (c d))` yield `b`, `c`, and `d`.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.2.5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a Scheme expression that evaluates to the following internal list structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch2_2.gif)'
  prefs: []
  type: TYPE_IMG
- en: Exercise 2.2.6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Draw the internal list structure produced by the expression below.
  prefs: []
  type: TYPE_NORMAL
- en: '`(cons 1 (cons ''(2 . ((3) . ())) (cons ''(()) (cons 4 5))))`'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.2.7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The behavior of `(car (car (car '((a b) (c d)))))` is undefined because `(car '((a b) (c d)))`
    is `(a b)`, `(car '(a b))` is `a`, and `(car 'a)` is undefined. Determine all
    legal compositions of `car` and `cdr` applied to `((a b) (c d))`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.2.8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Try to explain how Scheme expressions are evaluated. Does your explanation cover
    the last example in Exercise [2.2.3](start.html#g9)?
  prefs: []
  type: TYPE_NORMAL
- en: Section 2.3\. Evaluating Scheme Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s turn to a discussion of how Scheme evaluates the expressions you type.
    We have already established the rules for constant objects such as strings and
    numbers: the object itself is the value. You have probably also worked out in
    your mind a rule for evaluating procedure applications of the form `(*procedure* *arg[1]* ... *arg[n]*)`.
    Here, `*procedure*` is an expression representing a Scheme procedure, and `*arg[1]* ... *arg[n]*`
    are expressions representing its arguments. One possibility is the following.'
  prefs: []
  type: TYPE_NORMAL
- en: Find the value of `*procedure*`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the value of `*arg[1]*`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![<graphic>](ch2_3.gif)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Find the value of `*arg[n]*`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply the value of `*procedure*` to the values of `*arg[1]* ... *arg[n]*`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, consider the simple procedure application `(+ 3 4)`. The value
    of `+` is the addition procedure, the value of 3 is the number 3, and the value
    of 4 is the number 4. Applying the addition procedure to 3 and 4 yields 7, so
    our value is the object 7.
  prefs: []
  type: TYPE_NORMAL
- en: By applying this process at each level, we can find the value of the nested
    expression `(* (+ 3 4) 2)`. The value of `*` is the multiplication procedure,
    the value of `(+ 3 4)` we can determine to be the number 7, and the value of 2
    is the number 2. Multiplying 7 by 2 we get 14, so our answer is 14.
  prefs: []
  type: TYPE_NORMAL
- en: This rule works for procedure applications but not for `quote` expressions because
    the subexpressions of a procedure application are evaluated, whereas the subexpression
    of a `quote` expression is not. The evaluation of a `quote` expression is more
    similar to the evaluation of constant objects. The value of a `quote` expression
    of the form `(quote *object*)` is simply `*object*`.
  prefs: []
  type: TYPE_NORMAL
- en: Constant objects, procedure applications, and `quote` expressions are only three
    of the many syntactic forms provided by Scheme. Fortunately, only a few of the
    other syntactic forms need to be understood directly by a Scheme programmer; these
    are referred to as *core* syntactic forms. The remaining syntactic forms are *syntactic
    extensions* defined, ultimately, in terms of the core syntactic forms. We will
    discuss the remaining core syntactic forms and a few syntactic extensions in the
    remaining sections of this chapter. Section [3.1](further.html#g50) summarizes
    the core syntactic forms and introduces the syntactic extension mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go on to more syntactic forms and procedures, two points related to
    the evaluation of procedure applications are worthy of note. First, the process
    given above is overspecified, in that it requires the subexpressions to be evaluated
    from left to right. That is, `*procedure*` is evaluated before `*arg[1]*`, `*arg[1]*`
    is evaluated before `*arg[2]*`, and so on. This need not be the case. A Scheme
    evaluator is free to evaluate the expressions in any order---left to right, right
    to left, or any other sequential order. In fact, the subexpressions may be evaluated
    in different orders for different applications, even in the same implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The second point is that `*procedure*` is evaluated in the same way as `*arg[1]* ... *arg[n]*`.
    While `*procedure*` is often a variable that names a particular procedure, this
    need not be the case. Exercise [2.2.3](start.html#g9) had you determine the value
    of the expression `((car (list + - * /)) 2 3)`. Here, `*procedure*` is `(car (list + - * /))`.
    The value of `(car (list + - * /))` is the addition procedure, just as if `*procedure*`
    were simply the variable `+`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.3.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write down the steps necessary to evaluate the expression below.
  prefs: []
  type: TYPE_NORMAL
- en: '`((car (cdr (list + - * /))) 17 5)`'
  prefs: []
  type: TYPE_NORMAL
- en: Section 2.4\. Variables and Let Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose `*expr*` is a Scheme expression that contains a variable `*var*`. Suppose,
    additionally, that we would like `*var*` to have the value `*val*` when we evaluate
    `*expr*`. For example, we might like `x` to have the value 2 when we evaluate
    `(+ x 3)`. Or, we might want `y` to have the value 3 when we evaluate `(+ 2 y)`.
    The following examples demonstrate how to do this using Scheme's `let` syntactic
    form.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ((x 2))'
  prefs: []
  type: TYPE_NORMAL
- en: (+ x 3)) ![<graphic>](ch2_0.gif) 5
  prefs: []
  type: TYPE_NORMAL
- en: (let ((y 3))
  prefs: []
  type: TYPE_NORMAL
- en: (+ 2 y)) ![<graphic>](ch2_0.gif) 5
  prefs: []
  type: TYPE_NORMAL
- en: (let ((x 2) (y 3))
  prefs: []
  type: TYPE_NORMAL
- en: (+ x y)) ![<graphic>](ch2_0.gif) 5`
  prefs: []
  type: TYPE_NORMAL
- en: The `let` syntactic form includes a list of variable-expression pairs, along
    with a sequence of expressions referred to as the *body* of the `let`. The general
    form of a `let` expression is
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: We say the variables are *bound* to the values by the `let`. We refer to variables
    bound by `let` as `let`-*bound* variables.
  prefs: []
  type: TYPE_NORMAL
- en: A `let` expression is often used to simplify an expression that would contain
    two identical subexpressions. Doing so also ensures that the value of the common
    subexpression is computed only once.
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ (* 4 4) (* 4 4)) ![<graphic>](ch2_0.gif) 32'
  prefs: []
  type: TYPE_NORMAL
- en: (let ((a (* 4 4))) (+ a a)) ![<graphic>](ch2_0.gif) 32`
  prefs: []
  type: TYPE_NORMAL
- en: Brackets are often used in place of parentheses to delimit the bindings of a
    `let` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([list1 ''(a b c)] [list2 ''(d e f)])'
  prefs: []
  type: TYPE_NORMAL
- en: (cons (cons (car list1)
  prefs: []
  type: TYPE_NORMAL
- en: (car list2))
  prefs: []
  type: TYPE_NORMAL
- en: (cons (car (cdr list1))
  prefs: []
  type: TYPE_NORMAL
- en: (car (cdr list2))))) ![<graphic>](ch2_0.gif) ((a . d) b . e)`
  prefs: []
  type: TYPE_NORMAL
- en: Scheme treats forms enclosed in brackets just like forms enclosed in parentheses.
    An open bracket must be matched by a close bracket, and an open parenthesis must
    be matched by a close parenthesis. We use brackets for `let` (and, as we'll see,
    several other standard syntactic forms) to improve readability, especially when
    we might otherwise have two or more consecutive open parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Since expressions in the first position of a procedure application are evaluated
    no differently from other expressions, a `let`-bound variable may be used there
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([f +])'
  prefs: []
  type: TYPE_NORMAL
- en: (f 2 3)) ![<graphic>](ch2_0.gif) 5
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f +] [x 2])
  prefs: []
  type: TYPE_NORMAL
- en: (f x 3)) ![<graphic>](ch2_0.gif) 5
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f +] [x 2] [y 3])
  prefs: []
  type: TYPE_NORMAL
- en: (f x y)) ![<graphic>](ch2_0.gif) 5`
  prefs: []
  type: TYPE_NORMAL
- en: The variables bound by `let` are visible only within the body of the `let`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([+ *])'
  prefs: []
  type: TYPE_NORMAL
- en: (+ 2 3)) ![<graphic>](ch2_0.gif) 6
  prefs: []
  type: TYPE_NORMAL
- en: (+ 2 3) ![<graphic>](ch2_0.gif) 5`
  prefs: []
  type: TYPE_NORMAL
- en: This is fortunate, because we would not want the value of `+` to be the multiplication
    procedure everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to nest `let` expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([a 4] [b -3])'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([a-squared (* a a)]
  prefs: []
  type: TYPE_NORMAL
- en: '[b-squared (* b b)])'
  prefs: []
  type: TYPE_NORMAL
- en: (+ a-squared b-squared))) ![<graphic>](ch2_0.gif) 25`
  prefs: []
  type: TYPE_NORMAL
- en: When nested `let` expressions bind the same variable, only the binding created
    by the inner `let` is visible within its body.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 1])'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (+ x 1)])
  prefs: []
  type: TYPE_NORMAL
- en: (+ x x))) ![<graphic>](ch2_0.gif) 4`
  prefs: []
  type: TYPE_NORMAL
- en: The outer `let` expression binds `x` to 1 within its body, which is the second
    `let` expression. The inner `let` expression binds `x` to `(+ x 1)` within its
    body, which is the expression `(+ x x)`. What is the value of `(+ x 1)`? Since
    `(+ x 1)` appears within the body of the outer `let` but not within the body of
    the inner `let`, the value of `x` must be 1 and hence the value of `(+ x 1)` is
    2. What about `(+ x x)`? It appears within the body of both `let` expressions.
    Only the inner binding for `x` is visible, so `x` is 2 and `(+ x x)` is 4.
  prefs: []
  type: TYPE_NORMAL
- en: The inner binding for `x` is said to *shadow* the outer binding. A `let`-bound
    variable is visible everywhere within the body of its `let` expression except
    where it is shadowed. The region where a variable binding is visible is called
    its *scope*. The scope of the first `x` in the example above is the body of the
    outer `let` expression minus the body of the inner `let` expression, where it
    is shadowed by the second `x`. This form of scoping is referred to as *lexical
    scoping*, since the scope of each binding can be determined by a straightforward
    textual analysis of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Shadowing may be avoided by choosing different names for variables. The expression
    above could be rewritten so that the variable bound by the inner `let` is `new-x`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 1])'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([new-x (+ x 1)])
  prefs: []
  type: TYPE_NORMAL
- en: (+ new-x new-x))) ![<graphic>](ch2_0.gif) 4`
  prefs: []
  type: TYPE_NORMAL
- en: Although choosing different names can sometimes prevent confusion, shadowing
    can help prevent the accidental use of an "old" value. For example, with the original
    version of the preceding example, it would be impossible for us to mistakenly
    refer to the outer `x` within the body of the inner `let`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.4.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rewrite the following expressions, using `let` to remove common subexpressions
    and to improve the structure of the code. Do not perform any algebraic simplifications.
  prefs: []
  type: TYPE_NORMAL
- en: '| *  a*. | `(+ (- (* 3 a) b) (+ (* 3 a) b))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  b*. | `(cons (car (list a b c)) (cdr (list a b c)))` |'
  prefs: []
  type: TYPE_TB
- en: Exercise 2.4.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Determine the value of the following expression. Explain how you derived this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 9])'
  prefs: []
  type: TYPE_NORMAL
- en: (* x
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (/ x 3)])
  prefs: []
  type: TYPE_NORMAL
- en: (+ x x))))`
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.4.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rewrite the following expressions to give unique names to each different `let`-bound
    variable so that none of the variables is shadowed. Verify that the value of your
    expression is the same as that of the original expression.
  prefs: []
  type: TYPE_NORMAL
- en: '| *  a*. | `(let ([x ''a] [y ''b])   (list (let ([x ''c]) (cons x y))'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([y 'd]) (cons x y))))` |
  prefs: []
  type: TYPE_NORMAL
- en: '| *  b*. | `(let ([x ''((a b) c)])   (cons (let ([x (cdr x)])'
  prefs: []
  type: TYPE_NORMAL
- en: (car x))
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (car x)])
  prefs: []
  type: TYPE_NORMAL
- en: (cons (let ([x (cdr x)])
  prefs: []
  type: TYPE_NORMAL
- en: (car x))
  prefs: []
  type: TYPE_NORMAL
- en: (cons (let ([x (car x)])
  prefs: []
  type: TYPE_NORMAL
- en: x)
  prefs: []
  type: TYPE_NORMAL
- en: (cdr x))))))` |
  prefs: []
  type: TYPE_NORMAL
- en: Section 2.5\. Lambda Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the expression `(let ([x (* 3 4)]) (+ x x))`, the variable `x` is bound to
    the value of `(* 3 4)`. What if we would like the value of `(+ x x)` where `x`
    is bound to the value of `(/ 99 11)`? Where `x` is bound to the value of `(- 2 7)`?
    In each case we need a different `let` expression. When the body of the `let`
    is complicated, however, having to repeat it can be inconvenient.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can use the syntactic form `lambda` to create a new procedure that
    has `x` as a parameter and has the same body as the `let` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '`(lambda (x) (+ x x)) ![<graphic>](ch2_0.gif) #<procedure>`'
  prefs: []
  type: TYPE_NORMAL
- en: The general form of a `lambda` expression is
  prefs: []
  type: TYPE_NORMAL
- en: '`(lambda (*var* ...) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: The variables `*var* ...` are the *formal parameters* of the procedure, and
    the sequence of expressions `*body[1]* *body[2]* ...` is its body. (Actually,
    the true general form is somewhat more general than this, as you will see later.)
  prefs: []
  type: TYPE_NORMAL
- en: A procedure is just as much an object as a number, string, symbol, or pair.
    It does not have any meaningful printed representation as far as Scheme is concerned,
    however, so this book uses the notation `#<procedure>` to show that the value
    of an expression is a procedure.
  prefs: []
  type: TYPE_NORMAL
- en: The most common operation to perform on a procedure is to apply it to one or
    more values.
  prefs: []
  type: TYPE_NORMAL
- en: '`((lambda (x) (+ x x)) (* 3 4)) ![<graphic>](ch2_0.gif) 24`'
  prefs: []
  type: TYPE_NORMAL
- en: This is no different from any other procedure application. The procedure is
    the value of `(lambda (x) (+ x x))`, and the only argument is the value of `(* 3 4)`,
    or 12. The argument values, or *actual parameters*, are bound to the formal parameters
    within the body of the `lambda` expression in the same way as `let`-bound variables
    are bound to their values. In this case, `x` is bound to 12, and the value of
    `(+ x x)` is 24. Thus, the result of applying the procedure to the value 12 is
    24.
  prefs: []
  type: TYPE_NORMAL
- en: Because procedures are objects, we can establish a procedure as the value of
    a variable and use the procedure more than once.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([double (lambda (x) (+ x x))])'
  prefs: []
  type: TYPE_NORMAL
- en: (list (double (* 3 4))
  prefs: []
  type: TYPE_NORMAL
- en: (double (/ 99 11))
  prefs: []
  type: TYPE_NORMAL
- en: (double (- 2 7)))) ![<graphic>](ch2_0.gif) (24 18 -10)`
  prefs: []
  type: TYPE_NORMAL
- en: Here, we establish a binding for `double` to a procedure, then use this procedure
    to double three different values.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure expects its actual parameter to be a number, since it passes the
    actual parameter on to `+`. In general, the actual parameter may be any sort of
    object. Consider, for example, a similar procedure that uses `cons` instead of
    `+`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([double-cons (lambda (x) (cons x x))])'
  prefs: []
  type: TYPE_NORMAL
- en: (double-cons 'a)) ![<graphic>](ch2_0.gif) (a . a)`
  prefs: []
  type: TYPE_NORMAL
- en: Noting the similarity between `double` and `double-cons`, you should not be
    surprised to learn that they may be collapsed into a single procedure by adding
    an additional argument.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([double-any (lambda (f x) (f x x))])'
  prefs: []
  type: TYPE_NORMAL
- en: (list (double-any + 13)
  prefs: []
  type: TYPE_NORMAL
- en: (double-any cons 'a))) ![<graphic>](ch2_0.gif) (26 (a . a))`
  prefs: []
  type: TYPE_NORMAL
- en: This demonstrates that procedures may accept more than one argument and that
    arguments passed to a procedure may themselves be procedures.
  prefs: []
  type: TYPE_NORMAL
- en: As with `let` expressions, `lambda` expressions become somewhat more interesting
    when they are nested within other `lambda` or `let` expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x ''a])'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda (y) (list x y))])
  prefs: []
  type: TYPE_NORMAL
- en: (f 'b))) ![<graphic>](ch2_0.gif) (a b)`
  prefs: []
  type: TYPE_NORMAL
- en: The occurrence of `x` within the `lambda` expression refers to the `x` outside
    the `lambda` that is bound by the outer `let` expression. The variable `x` is
    said to *occur free* in the `lambda` expression or to be a *free variable* of
    the `lambda` expression. The variable `y` does not occur free in the `lambda`
    expression since it is bound by the `lambda` expression. A variable that occurs
    free in a `lambda` expression should be bound, e.g., by an enclosing `lambda`
    or `let` expression, unless the variable is (like the names of primitive procedures)
    bound outside of the expression, as we discuss in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when the procedure is applied somewhere outside the scope of the
    bindings for variables that occur free within the procedure, as in the following
    expression?
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([f (let ([x ''sam])'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (y z) (list x y z)))])
  prefs: []
  type: TYPE_NORMAL
- en: (f 'i 'am)) ![<graphic>](ch2_0.gif) (sam i am)`
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that the same bindings that were in effect when the procedure
    was created are in effect again when the procedure is applied. This is true even
    if another binding for `x` is visible where the procedure is applied.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([f (let ([x ''sam])'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (y z) (list x y z)))])
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x 'not-sam])
  prefs: []
  type: TYPE_NORMAL
- en: (f 'i 'am))) ![<graphic>](ch2_0.gif) (sam i am)`
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the value of `x` within the procedure named `f` is `sam`.
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, a `let` expression is nothing more than the direct application
    of a `lambda` expression to a set of argument expressions. For example, the two
    expressions below are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x ''a]) (cons x x))` ≡ `((lambda (x) (cons x x)) ''a)`'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, a `let` expression is a syntactic extension defined in terms of `lambda`
    and procedure application, which are both core syntactic forms. In general, any
    expression of the form
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: is equivalent to the following.
  prefs: []
  type: TYPE_NORMAL
- en: '`((lambda (*var* ...) *body[1]* *body[2]* ...)'
  prefs: []
  type: TYPE_NORMAL
- en: '*expr* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: See Section [3.1](further.html#g50) for more about core forms and syntactic
    extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned above, the general form of `lambda` is a bit more complicated
    than the form we saw earlier, in that the formal parameter specification, `(*var* ...)`,
    need not be a proper list, or indeed even a list at all. The formal parameter
    specification can be in any of the following three forms:'
  prefs: []
  type: TYPE_NORMAL
- en: a proper list of variables, `(*var[1]* ... *var[n]*)`, such as we have already
    seen,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a single variable, `*var[r]*`, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an improper list of variables, `(*var[1]* ... *var[n]* . *var[r]*)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case, exactly *n* actual parameters must be supplied, and each
    variable is bound to the corresponding actual parameter. In the second, any number
    of actual parameters is valid; all of the actual parameters are put into a single
    list and the single variable is bound to this list. The third case is a hybrid
    of the first two cases. At least *n* actual parameters must be supplied. The variables
    `*var[1]* ... *var[n]*` are bound to the corresponding actual parameters, and
    the variable `*var[r]*` is bound to a list containing the remaining actual parameters.
    In the second and third cases, `*var[r]*` is sometimes referred to as a "rest"
    parameter because it holds the rest of the actual parameters beyond those that
    are individually named.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a few examples to help clarify the more general syntax of `lambda`
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([f (lambda x x)])'
  prefs: []
  type: TYPE_NORMAL
- en: (f 1 2 3 4)) ![<graphic>](ch2_0.gif) (1 2 3 4)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda x x)])
  prefs: []
  type: TYPE_NORMAL
- en: (f)) ![<graphic>](ch2_0.gif) ()
  prefs: []
  type: TYPE_NORMAL
- en: (let ([g (lambda (x . y) (list x y))])
  prefs: []
  type: TYPE_NORMAL
- en: (g 1 2 3 4)) ![<graphic>](ch2_0.gif) (1 (2 3 4))
  prefs: []
  type: TYPE_NORMAL
- en: (let ([h (lambda (x y . z) (list x y z))])
  prefs: []
  type: TYPE_NORMAL
- en: (h 'a 'b 'c 'd)) ![<graphic>](ch2_0.gif) (a b (c d))`
  prefs: []
  type: TYPE_NORMAL
- en: In the first two examples, the procedure named `f` accepts any number of arguments.
    These arguments are automatically formed into a list to which the variable `x`
    is bound; the value of `f` is this list. In the first example, the arguments are
    1, 2, 3, and 4, so the answer is `(1 2 3 4)`. In the second, there are no arguments,
    so the answer is the empty list `()`. The value of the procedure named `g` in
    the third example is a list whose first element is the first argument and whose
    second element is a list containing the remaining arguments. The procedure named
    `h` is similar but separates out the second argument. While `f` accepts any number
    of arguments, `g` must receive at least one and `h` must receive at least two.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.5.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Determine the values of the expressions below.
  prefs: []
  type: TYPE_NORMAL
- en: '| *  a*. | `(let ([f (lambda (x) x)])   (f ''a))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  b*. | `(let ([f (lambda x x)])   (f ''a))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  c*. | `(let ([f (lambda (x . y) x)])   (f ''a))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  d*. | `(let ([f (lambda (x . y) y)])   (f ''a))` |'
  prefs: []
  type: TYPE_TB
- en: Exercise 2.5.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How might the primitive procedure `list` be defined?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.5.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: List the variables that occur free in each of the `lambda` expressions below.
    Do not omit variables that name primitive procedures such as `+` or `cons`.
  prefs: []
  type: TYPE_NORMAL
- en: '| *  a*. | `(lambda (f x) (f x))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  b*. | `(lambda (x) (+ x x))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  c*. | `(lambda (x y) (f x y))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  d*. | `(lambda (x)   (cons x (f x y)))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  e*. | `(lambda (x)   (let ([z (cons x y)])'
  prefs: []
  type: TYPE_NORMAL
- en: (x y z)))` |
  prefs: []
  type: TYPE_NORMAL
- en: '| *  f*. | `(lambda (x)   (let ([y (cons x y)])'
  prefs: []
  type: TYPE_NORMAL
- en: (x y z)))` |
  prefs: []
  type: TYPE_NORMAL
- en: Section 2.6\. Top-Level Definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The variables bound by `let` and `lambda` expressions are not visible outside
    the bodies of these expressions. Suppose you have created an object, perhaps a
    procedure, that must be accessible anywhere, like `+` or `cons`. What you need
    is a *top-level definition*, which may be established with `define`. Top-level
    definitions, which are supported by most interactive Scheme systems, are visible
    in every expression you enter, except where shadowed by another binding.
  prefs: []
  type: TYPE_NORMAL
- en: Let's establish a top-level definition of the `double-any` procedure of the
    last section.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define double-any'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (f x)
  prefs: []
  type: TYPE_NORMAL
- en: (f x x)))`
  prefs: []
  type: TYPE_NORMAL
- en: The variable `double-any` now has the same status as `cons` or the name of any
    other primitive procedure. We can use `double-any` as if it were a primitive procedure.
  prefs: []
  type: TYPE_NORMAL
- en: '`(double-any + 10) ![<graphic>](ch2_0.gif) 20'
  prefs: []
  type: TYPE_NORMAL
- en: (double-any cons 'a) ![<graphic>](ch2_0.gif) (a . a)`
  prefs: []
  type: TYPE_NORMAL
- en: A top-level definition may be established for any object, not just for procedures.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define sandwich "peanut-butter-and-jelly")'
  prefs: []
  type: TYPE_NORMAL
- en: sandwich ![<graphic>](ch2_0.gif) "peanut-butter-and-jelly"`
  prefs: []
  type: TYPE_NORMAL
- en: Most often, though, top-level definitions are used for procedures.
  prefs: []
  type: TYPE_NORMAL
- en: As suggested above, top-level definitions may be shadowed by `let` or `lambda`
    bindings.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define xyz ''(x y z))'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([xyz '(z y x)])
  prefs: []
  type: TYPE_NORMAL
- en: xyz) ![<graphic>](ch2_0.gif) (z y x)`
  prefs: []
  type: TYPE_NORMAL
- en: Variables with top-level definitions act almost as if they were bound by a `let`
    expression enclosing all of the expressions you type.
  prefs: []
  type: TYPE_NORMAL
- en: Given only the simple tools you have read about up to this point, it is already
    possible to define some of the primitive procedures provided by Scheme and described
    later in this book. If you completed the exercises from the last section, you
    should already know how to define `list`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define list (lambda x x))`'
  prefs: []
  type: TYPE_NORMAL
- en: Also, Scheme provides the abbreviations `cadr` and `cddr` for the compositions
    of `car` with `cdr` and `cdr` with `cdr`. That is, `(cadr *list*)` is equivalent
    to `(car (cdr *list*))`, and, similarly, `(cddr *list*)` is equivalent to `(cdr (cdr *list*))`.
    They are easily defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define cadr'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (car (cdr x))))
  prefs: []
  type: TYPE_NORMAL
- en: (define cddr
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (cdr (cdr x))))`
  prefs: []
  type: TYPE_NORMAL
- en: '`(cadr ''(a b c)) ![<graphic>](ch2_0.gif) b'
  prefs: []
  type: TYPE_NORMAL
- en: (cddr '(a b c)) ![<graphic>](ch2_0.gif) (c)`
  prefs: []
  type: TYPE_NORMAL
- en: Any definition `(define *var* *expr*)` where `*expr*` is a `lambda` expression
    can be written in a shorter form that suppresses the `lambda`. The exact syntax
    depends upon the format of the `lambda` expression's formal parameter specifier,
    i.e., whether it is a proper list of variables, a single variable, or an improper
    list of variables. A definition of the form
  prefs: []
  type: TYPE_NORMAL
- en: '`(define *var[0]*'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (*var[1]* ... *var[n]*)
  prefs: []
  type: TYPE_NORMAL
- en: '*e[1]* *e[2]* ...))`'
  prefs: []
  type: TYPE_NORMAL
- en: may be abbreviated
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (*var[0]* *var[1]* ... *var[n]*)'
  prefs: []
  type: TYPE_NORMAL
- en: '*e[1]* *e[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: while
  prefs: []
  type: TYPE_NORMAL
- en: '`(define *var[0]*'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda *var[r]*
  prefs: []
  type: TYPE_NORMAL
- en: '*e[1]* *e[2]* ...))`'
  prefs: []
  type: TYPE_NORMAL
- en: may be abbreviated
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (*var[0]* . *var[r]*)'
  prefs: []
  type: TYPE_NORMAL
- en: '*e[1]* *e[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '`(define *var[0]*'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (*var[1]* ... *var[n]* . *var[r]*)
  prefs: []
  type: TYPE_NORMAL
- en: '*e[1]* *e[2]* ...))`'
  prefs: []
  type: TYPE_NORMAL
- en: may be abbreviated
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (*var[0]* *var[1]* ... *var[n]* . *var[r]*)'
  prefs: []
  type: TYPE_NORMAL
- en: '*e[1]* *e[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the definitions of `cadr` and `list` might be written as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (cadr x)'
  prefs: []
  type: TYPE_NORMAL
- en: (car (cdr x)))
  prefs: []
  type: TYPE_NORMAL
- en: (define (list . x) x)`
  prefs: []
  type: TYPE_NORMAL
- en: This book does not often employ this alternative syntax. Although it is shorter,
    it tends to mask the reality that procedures are not intimately tied to variables,
    or names, as they are in many other languages. This syntax is often referred to,
    somewhat pejoratively, as the "defun" syntax for `define`, after the `defun` form
    provided by Lisp languages in which procedures are more closely tied to their
    names.
  prefs: []
  type: TYPE_NORMAL
- en: Top-level definitions make it easier for us to experiment with a procedure interactively
    because we need not retype the procedure each time it is used. Let's try defining
    a somewhat more complicated variation of `double-any`, one that turns an "ordinary"
    two-argument procedure into a "doubling" one-argument procedure.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define doubler'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (f)
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x) (f x x))))`
  prefs: []
  type: TYPE_NORMAL
- en: '`doubler` accepts one argument, `f`, which must be a procedure that accepts
    two arguments. The procedure returned by `doubler` accepts one argument, which
    it uses for both arguments in an application of `f`. We can define, with `doubler`,
    the simple `double` and `double-cons` procedures of the last section.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define double (doubler +))'
  prefs: []
  type: TYPE_NORMAL
- en: (double 13/2) ![<graphic>](ch2_0.gif) 13
  prefs: []
  type: TYPE_NORMAL
- en: (define double-cons (doubler cons))
  prefs: []
  type: TYPE_NORMAL
- en: (double-cons 'a) ![<graphic>](ch2_0.gif) (a . a)`
  prefs: []
  type: TYPE_NORMAL
- en: We can also define `double-any` with `doubler`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define double-any'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (f x)
  prefs: []
  type: TYPE_NORMAL
- en: ((doubler f) x)))`
  prefs: []
  type: TYPE_NORMAL
- en: Within `double` and `double-cons`, `f` has the appropriate value, i.e., `+`
    or `cons`, even though the procedures are clearly applied outside the scope of
    `f`.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if you attempt to use a variable that is not bound by a `let` or
    `lambda` expression and that does not have a top-level definition? Try using the
    variable `i-am-not-defined` to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: '`(i-am-not-defined 3)`'
  prefs: []
  type: TYPE_NORMAL
- en: Most Scheme systems print a message indicating that an unbound- or undefined-variable
    exception has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: The system should not, however, complain about the appearance of an undefined
    variable within a `lambda` expression, until and unless the resulting procedure
    is applied. The following should *not* cause an exception, even though we have
    not yet established a top-level definition of `proc2`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define proc1'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y)
  prefs: []
  type: TYPE_NORMAL
- en: (proc2 y x)))`
  prefs: []
  type: TYPE_NORMAL
- en: If you try to apply `proc1` before defining `proc2`, you should get a undefined
    exception message. Let's give `proc2` a top-level definition and try `proc1`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define proc2 cons)'
  prefs: []
  type: TYPE_NORMAL
- en: (proc1 'a 'b) ![<graphic>](ch2_0.gif) (b . a)`
  prefs: []
  type: TYPE_NORMAL
- en: When you define `proc1`, the system accepts your promise to define `proc2`,
    and does not complain unless you use `proc1` before defining `proc2`. This allows
    you to define procedures in any order you please. This is especially useful when
    you are trying to organize a file full of procedure definitions in a way that
    makes your program more readable. It is necessary when two procedures defined
    at top level depend upon each other; we will see some examples of this later.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.6.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What would happen if you were to type
  prefs: []
  type: TYPE_NORMAL
- en: '`(double-any double-any double-any)`'
  prefs: []
  type: TYPE_NORMAL
- en: given the definition of `double-any` from the beginning of this section?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.6.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A more elegant (though possibly less efficient) way to define `cadr` and `cddr`
    than given in this section is to define a procedure that composes two procedures
    to create a third. Write the procedure `compose`, such that `(compose *p[1]* *p[2]*)`
    is the composition of `*p[1]*` and `*p[2]*` (assuming both take one argument).
    That is, `(compose *p[1]* *p[2]*)` should return a new procedure of one argument
    that applies `*p[1]*` to the result of applying `*p[2]*` to the argument. Use
    `compose` to define `cadr` and `cddr`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.6.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Scheme also provides `caar`, `cdar`, `caaar`, `caadr`, and so on, with any combination
    of up to four `a`'s (representing `car`) and `d`'s (representing `cdr`) between
    the `c` and the `r` (see Section [6.3](objects.html#g109)). Define each of these
    with the `compose` procedure of the preceding exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Section 2.7\. Conditional Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far we have considered expressions that perform a given task unconditionally.
    Suppose that we wish to write the procedure `abs`. If its argument *x* is negative,
    `abs` returns -*x*; otherwise, it returns *x*. The most straightforward way to
    write `abs` is to determine whether the argument is negative and if so negate
    it, using the `if` syntactic form.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define abs'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (if (< n 0)
  prefs: []
  type: TYPE_NORMAL
- en: (- 0 n)
  prefs: []
  type: TYPE_NORMAL
- en: n)))
  prefs: []
  type: TYPE_NORMAL
- en: (abs 77) ![<graphic>](ch2_0.gif) 77
  prefs: []
  type: TYPE_NORMAL
- en: (abs -77) ![<graphic>](ch2_0.gif) 77`
  prefs: []
  type: TYPE_NORMAL
- en: An `if` expression has the form `(if *test* *consequent* *alternative*)`, where
    `*consequent*` is the expression to evaluate if `*test*` is true and `*alternative*`
    is the expression to evaluate if `*test*` is false. In the expression above, `*test*`
    is `(< n 0)`, `*consequent*` is `(- 0 n)`, and `*alternative*` is `n`.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `abs` could be written in a variety of other ways. Any of the
    following are valid definitions of `abs`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define abs'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (if (>= n 0)
  prefs: []
  type: TYPE_NORMAL
- en: n
  prefs: []
  type: TYPE_NORMAL
- en: (- 0 n))))
  prefs: []
  type: TYPE_NORMAL
- en: (define abs
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (if (not (< n 0))
  prefs: []
  type: TYPE_NORMAL
- en: n
  prefs: []
  type: TYPE_NORMAL
- en: (- 0 n))))
  prefs: []
  type: TYPE_NORMAL
- en: (define abs
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (if (or (> n 0) (= n 0))
  prefs: []
  type: TYPE_NORMAL
- en: n
  prefs: []
  type: TYPE_NORMAL
- en: (- 0 n))))
  prefs: []
  type: TYPE_NORMAL
- en: (define abs
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (if (= n 0)
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: (if (< n 0)
  prefs: []
  type: TYPE_NORMAL
- en: (- 0 n)
  prefs: []
  type: TYPE_NORMAL
- en: n))))
  prefs: []
  type: TYPE_NORMAL
- en: (define abs
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: ((if (>= n 0) + -)
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: n)))`
  prefs: []
  type: TYPE_NORMAL
- en: The first of these definitions asks if `n` is greater than or equal to zero,
    inverting the test. The second asks if `n` is not less than zero, using the procedure
    `not` with `<`. The third asks if `n` is greater than zero or `n` is equal to
    zero, using the syntactic form `or`. The fourth treats zero separately, though
    there is no benefit in doing so. The fifth is somewhat tricky; `n` is either added
    to or subtracted from zero, depending upon whether `n` is greater than or equal
    to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Why is `if` a syntactic form and not a procedure? In order to answer this, let's
    revisit the definition of `reciprocal` from the first section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define reciprocal'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (if (= n 0)
  prefs: []
  type: TYPE_NORMAL
- en: '"oops!"'
  prefs: []
  type: TYPE_NORMAL
- en: (/ 1 n))))`
  prefs: []
  type: TYPE_NORMAL
- en: The second argument to the division procedure should not be zero, since the
    result is mathematically undefined. Our definition of `reciprocal` avoids this
    problem by testing for zero before dividing. Were `if` a procedure, its arguments
    (including `(/ 1 n)`) would be evaluated before it had a chance to choose between
    the consequent and alternative. Like `quote`, which does not evaluate its only
    subexpression, `if` does not evaluate all of its subexpressions and so cannot
    be a procedure.
  prefs: []
  type: TYPE_NORMAL
- en: The syntactic form `or` operates in a manner similar to `if`. The general form
    of an `or` expression is `(or *expr* ...)`. If there are no subexpressions, i.e.,
    the expression is simply `(or)`, the value is false. Otherwise, each `*expr*`
    is evaluated in turn until either (a) one of the expressions evaluates to true
    or (b) no more expressions are left. In case (a), the value is true; in case (b),
    the value is false.
  prefs: []
  type: TYPE_NORMAL
- en: To be more precise, in case (a), the value of the `or` expression is the value
    of the last subexpression evaluated. This clarification is necessary because there
    are many possible true values. Usually, the value of a test expression is one
    of the two objects `#t`, for true, or `#f`, for false.
  prefs: []
  type: TYPE_NORMAL
- en: '`(< -1 0) ![<graphic>](ch2_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (> -1 0) ![<graphic>](ch2_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: Every Scheme object, however, is considered to be either true or false by conditional
    expressions and by the procedure `not`. Only `#f` is considered false; all other
    objects are considered true.
  prefs: []
  type: TYPE_NORMAL
- en: '`(if #t ''true ''false) ![<graphic>](ch2_0.gif) true'
  prefs: []
  type: TYPE_NORMAL
- en: (if #f 'true 'false) ![<graphic>](ch2_0.gif) false
  prefs: []
  type: TYPE_NORMAL
- en: (if '() 'true 'false) ![<graphic>](ch2_0.gif) true
  prefs: []
  type: TYPE_NORMAL
- en: (if 1 'true 'false) ![<graphic>](ch2_0.gif) true
  prefs: []
  type: TYPE_NORMAL
- en: (if '(a b c) 'true 'false) ![<graphic>](ch2_0.gif) true
  prefs: []
  type: TYPE_NORMAL
- en: (not #t) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (not "false") ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (not #f) ![<graphic>](ch2_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (or) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (or #f) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (or #f #t) ![<graphic>](ch2_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (or #f 'a #f) ![<graphic>](ch2_0.gif) a`
  prefs: []
  type: TYPE_NORMAL
- en: The `and` syntactic form is similar in form to `or`, but an `and` expression
    is true if all its subexpressions are true, and false otherwise. In the case where
    there are no subexpressions, i.e., the expression is simply `(and)`, the value
    is true. Otherwise, the subexpressions are evaluated in turn until either no more
    subexpressions are left or the value of a subexpression is false. The value of
    the `and` expression is the value of the last subexpression evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Using `and`, we can define a slightly different version of `reciprocal`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define reciprocal'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (and (not (= n 0))
  prefs: []
  type: TYPE_NORMAL
- en: (/ 1 n))))
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal 3) ![<graphic>](ch2_0.gif) 1/3
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal 0.5) ![<graphic>](ch2_0.gif) 2.0
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal 0) ![<graphic>](ch2_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: In this version, the value is `#f` if `n` is zero and `1/n` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: The procedures `=`, `<`, `>`, `<=`, and `>=` are called *predicates*. A predicate
    is a procedure that answers a specific question about its arguments and returns
    one of the two values `#t` or `#f`. The names of most predicates end with a question
    mark ( `?` ); the common numeric procedures listed above are exceptions to this
    rule. Not all predicates require numeric arguments, of course. The predicate `null?`
    returns true if its argument is the empty list `()` and false otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '`(null? ''()) ![<graphic>](ch2_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (null? 'abc) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (null? '(x y z)) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (null? (cdddr '(x y z))) ![<graphic>](ch2_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `cdr` must not be passed anything other than a pair, and an exception
    is raised when this happens. Common Lisp, however, defines `(cdr '())` to be `()`.
    The following procedure, `lisp-cdr`, is defined using `null?` to return `()` if
    its argument is `()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define lisp-cdr'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? x)
  prefs: []
  type: TYPE_NORMAL
- en: '''()'
  prefs: []
  type: TYPE_NORMAL
- en: (cdr x))))
  prefs: []
  type: TYPE_NORMAL
- en: (lisp-cdr '(a b c)) ![<graphic>](ch2_0.gif) (b c)
  prefs: []
  type: TYPE_NORMAL
- en: (lisp-cdr '(c)) ![<graphic>](ch2_0.gif) ()
  prefs: []
  type: TYPE_NORMAL
- en: (lisp-cdr '()) ![<graphic>](ch2_0.gif) ()`
  prefs: []
  type: TYPE_NORMAL
- en: Another useful predicate is `eqv?`, which requires two arguments. If the two
    arguments are equivalent, `eqv?` returns true. Otherwise, `eqv?` returns false.
  prefs: []
  type: TYPE_NORMAL
- en: '`(eqv? ''a ''a) ![<graphic>](ch2_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? 'a 'b) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? #f #f) ![<graphic>](ch2_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? #t #t) ![<graphic>](ch2_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? #f #t) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? 3 3) ![<graphic>](ch2_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? 3 2) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x "Hi Mom!"])
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? x x)) ![<graphic>](ch2_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (cons 'a 'b)])
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? x x)) ![<graphic>](ch2_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? (cons 'a 'b) (cons 'a 'b)) ![<graphic>](ch2_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `eqv?` returns true if the arguments are the same symbol, boolean,
    number, pair, or string. Two pairs are not the same by `eqv?` if they are created
    by different calls to `cons`, even if they have the same contents. Detailed equivalence
    rules for `eqv?` are given in Section [6.2](objects.html#g108).
  prefs: []
  type: TYPE_NORMAL
- en: Scheme also provides a set of *type predicates* that return true or false depending
    on the type of the object, e.g., `pair?`, `symbol?`, `number?`, and `string?`.
    The predicate `pair?`, for example, returns true only if its argument is a pair.
  prefs: []
  type: TYPE_NORMAL
- en: '`(pair? ''(a . c)) ![<graphic>](ch2_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (pair? '(a b c)) ![<graphic>](ch2_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (pair? '()) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (pair? 'abc) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (pair? "Hi Mom!") ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (pair? 1234567890) ![<graphic>](ch2_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: Type predicates are useful for deciding if the argument passed to a procedure
    is of the appropriate type. For example, the following version of `reciprocal`
    checks first to see that its argument is a number before testing against zero
    or performing the division.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define reciprocal'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (if (and (number? n) (not (= n 0)))
  prefs: []
  type: TYPE_NORMAL
- en: (/ 1 n)
  prefs: []
  type: TYPE_NORMAL
- en: '"oops!")))'
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal 2/3) ![<graphic>](ch2_0.gif) 3/2
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal 'a) ![<graphic>](ch2_0.gif) "oops!"`
  prefs: []
  type: TYPE_NORMAL
- en: By the way, the code that uses `reciprocal` must check to see that the returned
    value is a number and not a string. To relieve the caller of this obligation,
    it is usually preferable to report the error, using `assertion-violation`, as
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define reciprocal'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (if (and (number? n) (not (= n 0)))
  prefs: []
  type: TYPE_NORMAL
- en: (/ 1 n)
  prefs: []
  type: TYPE_NORMAL
- en: (assertion-violation 'reciprocal
  prefs: []
  type: TYPE_NORMAL
- en: '"improper argument"'
  prefs: []
  type: TYPE_NORMAL
- en: n))))
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal .25) ![<graphic>](ch2_0.gif) 4.0
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal 0) ![<graphic>](ch2_0.gif) *exception in reciprocal: improper argument 0*
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal 'a) ![<graphic>](ch2_0.gif) *exception in reciprocal: improper argument a*`
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to `assertion-violation` is a symbol identifying where the
    message originates, the second is a string describing the error, and the third
    and subsequent arguments are "irritants" to be included with the error message.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at one more conditional expression, `cond`, that is often useful
    in place of `if`. `cond` is similar to `if` except that it allows multiple test
    and alternative expressions. Consider the following definition of `sign`, which
    returns `-1` for negative inputs, `+1` for positive inputs, and `0` for zero.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define sign'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (if (< n 0)
  prefs: []
  type: TYPE_NORMAL
- en: '-1'
  prefs: []
  type: TYPE_NORMAL
- en: (if (> n 0)
  prefs: []
  type: TYPE_NORMAL
- en: '+1'
  prefs: []
  type: TYPE_NORMAL
- en: 0))))`
  prefs: []
  type: TYPE_NORMAL
- en: '`(sign -88.3) ![<graphic>](ch2_0.gif) -1'
  prefs: []
  type: TYPE_NORMAL
- en: (sign 0) ![<graphic>](ch2_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (sign 333333333333) ![<graphic>](ch2_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (* (sign -88.3) (abs -88.3)) ![<graphic>](ch2_0.gif) -88.3`
  prefs: []
  type: TYPE_NORMAL
- en: The two `if` expressions may be replaced by a single `cond` expression as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define sign'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(< n 0) -1]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(> n 0) +1]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else 0])))`'
  prefs: []
  type: TYPE_NORMAL
- en: A `cond` expression usually takes the form
  prefs: []
  type: TYPE_NORMAL
- en: '`(cond (*test* *expr*) ... (else *expr*))`'
  prefs: []
  type: TYPE_NORMAL
- en: though the `else` clause may be omitted. This should be done only when there
    is no possibility that all the tests will fail, as in the new version of `sign`
    below.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define sign'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(< n 0) -1]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(> n 0) +1]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(= n 0) 0])))`'
  prefs: []
  type: TYPE_NORMAL
- en: These definitions of `sign` do not depend on the order in which the tests are
    performed, since only one of the tests can be true for any value of `n`. The following
    procedure computes the tax on a given amount of income in a progressive tax system
    with breakpoints at 10,000, 20,000, and 30,000 dollars.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define income-tax'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (income)
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(<= income 10000) (* income .05)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(<= income 20000) (+ (* (- income 10000) .08) 500.00)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(<= income 30000) (+ (* (- income 20000) .13) 1300.00)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (+ (* (- income 30000) .21) 2600.00)])))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(income-tax 5000) ![<graphic>](ch2_0.gif) 250.0'
  prefs: []
  type: TYPE_NORMAL
- en: (income-tax 15000) ![<graphic>](ch2_0.gif) 900.0
  prefs: []
  type: TYPE_NORMAL
- en: (income-tax 25000) ![<graphic>](ch2_0.gif) 1950.0
  prefs: []
  type: TYPE_NORMAL
- en: (income-tax 50000) ![<graphic>](ch2_0.gif) 6800.0`
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the order in which the tests are performed, left to right (top
    to bottom), is significant.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.7.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Define the predicate `atom?`, which returns true if its argument is not a pair
    and false if it is.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.7.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The procedure `length` returns the length of its argument, which must be a list.
    For example, `(length '(a b c))` is 3. Using `length`, define the procedure `shorter`,
    which returns the shorter of two list arguments. Have it return the first list
    if they have the same length.
  prefs: []
  type: TYPE_NORMAL
- en: '`(shorter ''(a b) ''(c d e)) ![<graphic>](ch2_0.gif) (a b)'
  prefs: []
  type: TYPE_NORMAL
- en: (shorter '(a b) '(c d)) ![<graphic>](ch2_0.gif) (a b)
  prefs: []
  type: TYPE_NORMAL
- en: (shorter '(a b) '(c)) ![<graphic>](ch2_0.gif) (c)`
  prefs: []
  type: TYPE_NORMAL
- en: Section 2.8\. Simple Recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have seen how we can control whether or not expressions are evaluated with
    `if`, `and`, `or`, and `cond`. We can also perform an expression more than once
    by creating a procedure containing the expression and invoking the procedure more
    than once. What if we need to perform some expression repeatedly, say for all
    the elements of a list or all the numbers from one to ten? We can do so via recursion.
    Recursion is a simple concept: the application of a procedure from within that
    procedure. It can be tricky to master recursion at first, but once mastered it
    provides expressive power far beyond ordinary looping constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: A *recursive procedure* is a procedure that applies itself. Perhaps the simplest
    recursive procedure is the following, which we will call `goodbye`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define goodbye'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (goodbye)))
  prefs: []
  type: TYPE_NORMAL
- en: (goodbye) ![<graphic>](ch2_0.gif)`
  prefs: []
  type: TYPE_NORMAL
- en: This procedure takes no arguments and simply applies itself immediately. There
    is no value after the ![<graphic>](ch2_0.gif) because `goodbye` never returns.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, to make practical use out of a recursive procedure, we must have
    some way to terminate the recursion. Most recursive procedures should have at
    least two basic elements, a *base case* and a *recursion step*. The base case
    terminates the recursion, giving the value of the procedure for some base argument.
    The recursion step gives the value in terms of the value of the procedure applied
    to a different argument. In order for the recursion to terminate, the different
    argument must be closer to the base argument in some way.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider the problem of finding the length of a proper list recursively.
    We need a base case and a recursion step. The logical base argument for recursion
    on lists is nearly always the empty list. The length of the empty list is zero,
    so the base case should give the value zero for the empty list. In order to become
    closer to the empty list, the natural recursion step involves the cdr of the argument.
    A nonempty list is one element longer than its cdr, so the recursion step gives
    the value as one more than the length of the cdr of the list.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define length'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: (+ (length (cdr ls)) 1))))`
  prefs: []
  type: TYPE_NORMAL
- en: '`(length ''()) ![<graphic>](ch2_0.gif) 0'
  prefs: []
  type: TYPE_NORMAL
- en: (length '(a)) ![<graphic>](ch2_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (length '(a b)) ![<graphic>](ch2_0.gif) 2`
  prefs: []
  type: TYPE_NORMAL
- en: The `if` expression asks if the list is empty. If so, the value is zero. This
    is the base case. If not, the value is one more than the length of the cdr of
    the list. This is the recursion step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many Scheme implementations allow you to trace the execution of a procedure
    to see how it operates. In Chez Scheme, for example, one way to trace a procedure
    is to type `(trace *name*)`, where `*name*` is the name of a procedure you have
    defined at top level. If you trace `length` as defined above and pass it the argument
    `''(a b c d)`, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`|(length (a b c d))'
  prefs: []
  type: TYPE_NORMAL
- en: '| (length (b c d))'
  prefs: []
  type: TYPE_NORMAL
- en: '| |(length (c d))'
  prefs: []
  type: TYPE_NORMAL
- en: '| | (length (d))'
  prefs: []
  type: TYPE_NORMAL
- en: '| | |(length ())'
  prefs: []
  type: TYPE_NORMAL
- en: '| | |0'
  prefs: []
  type: TYPE_NORMAL
- en: '| | 1'
  prefs: []
  type: TYPE_NORMAL
- en: '| |2'
  prefs: []
  type: TYPE_NORMAL
- en: '| 3'
  prefs: []
  type: TYPE_NORMAL
- en: '|4`'
  prefs: []
  type: TYPE_NORMAL
- en: The indentation shows the nesting level of the recursion; the vertical lines
    associate applications visually with their values. Notice that on each application
    of `length` the list gets smaller until it finally reaches `()`. The value at
    `()` is 0, and each outer level adds 1 to arrive at the final value.
  prefs: []
  type: TYPE_NORMAL
- en: Let's write a procedure, `list-copy`, that returns a copy of its argument, which
    must be a list. That is, `list-copy` returns a new list consisting of the elements
    (but not the pairs) of the old list. Making a copy might be useful if either the
    original list or the copy might be altered via `set-car!` or `set-cdr!`, which
    we discuss later.
  prefs: []
  type: TYPE_NORMAL
- en: '`(list-copy ''()) ![<graphic>](ch2_0.gif) ()'
  prefs: []
  type: TYPE_NORMAL
- en: (list-copy '(a b c)) ![<graphic>](ch2_0.gif) (a b c)`
  prefs: []
  type: TYPE_NORMAL
- en: See if you can define `list-copy` before studying the definition below.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define list-copy'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: '''()'
  prefs: []
  type: TYPE_NORMAL
- en: (cons (car ls)
  prefs: []
  type: TYPE_NORMAL
- en: (list-copy (cdr ls))))))`
  prefs: []
  type: TYPE_NORMAL
- en: The definition of `list-copy` is similar to the definition of `length`. The
    test in the base case is the same, `(null? ls)`. The value in the base case is
    `()`, however, not 0, because we are building up a list, not a number. The recursive
    call is the same, but instead of adding one, `list-copy` conses the car of the
    list onto the value of the recursive call.
  prefs: []
  type: TYPE_NORMAL
- en: There is no reason why there cannot be more than one base case. The procedure
    `memv` takes two arguments, an object and a list. It returns the first sublist,
    or *tail*, of the list whose car is equal to the object, or `#f` if the object
    is not found in the list. The value of `memv` may be used as a list or as a truth
    value in a conditional expression.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define memv'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x ls)
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(null? ls) #f]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(eqv? (car ls) x) ls]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (memv x (cdr ls))])))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(memv ''a ''(a b b d)) ![<graphic>](ch2_0.gif) (a b b d)'
  prefs: []
  type: TYPE_NORMAL
- en: (memv 'b '(a b b d)) ![<graphic>](ch2_0.gif) (b b d)
  prefs: []
  type: TYPE_NORMAL
- en: (memv 'c '(a b b d)) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (memv 'd '(a b b d)) ![<graphic>](ch2_0.gif) (d)
  prefs: []
  type: TYPE_NORMAL
- en: (if (memv 'b '(a b b d))
  prefs: []
  type: TYPE_NORMAL
- en: '"yes"'
  prefs: []
  type: TYPE_NORMAL
- en: '"no") ![<graphic>](ch2_0.gif) "yes"`'
  prefs: []
  type: TYPE_NORMAL
- en: Here there are two conditions to check, hence the use of `cond`. The first cond
    clause checks for the base value of `()`; no object is a member of `()`, so the
    answer is `#f`. The second clause asks if the car of the list is the object, in
    which case the list is returned, being the first tail whose car contains the object.
    The recursion step just continues down the list.
  prefs: []
  type: TYPE_NORMAL
- en: There may also be more than one recursion case. Like `memv`, the procedure `remv`
    defined below takes two arguments, an object and a list. It returns a new list
    with all occurrences of the object removed from the list.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define remv'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x ls)
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(null? ls) ''()]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(eqv? (car ls) x) (remv x (cdr ls))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (cons (car ls) (remv x (cdr ls)))])))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(remv ''a ''(a b b d)) ![<graphic>](ch2_0.gif) (b b d)'
  prefs: []
  type: TYPE_NORMAL
- en: (remv 'b '(a b b d)) ![<graphic>](ch2_0.gif) (a d)
  prefs: []
  type: TYPE_NORMAL
- en: (remv 'c '(a b b d)) ![<graphic>](ch2_0.gif) (a b b d)
  prefs: []
  type: TYPE_NORMAL
- en: (remv 'd '(a b b d)) ![<graphic>](ch2_0.gif) (a b b)`
  prefs: []
  type: TYPE_NORMAL
- en: 'This definition is similar to the definition of `memv` above, except `remv`
    does not quit once it finds the element in the car of the list. Rather, it continues,
    simply ignoring the element. If the element is not found in the car of the list,
    `remv` does the same thing as `list-copy` above: it conses the car of the list
    onto the recursive value.'
  prefs: []
  type: TYPE_NORMAL
- en: Up to now, the recursion has been only on the cdr of a list. It is sometimes
    useful, however, for a procedure to recur on the car as well as the cdr of the
    list. The procedure `tree-copy` defined below treats the structure of pairs as
    a tree rather than as a list, with the left subtree being the car of the pair
    and the right subtree being the cdr of the pair. It performs a similar operation
    to `list-copy`, building new pairs while leaving the elements (leaves) alone.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define tree-copy'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (tr)
  prefs: []
  type: TYPE_NORMAL
- en: (if (not (pair? tr))
  prefs: []
  type: TYPE_NORMAL
- en: tr
  prefs: []
  type: TYPE_NORMAL
- en: (cons (tree-copy (car tr))
  prefs: []
  type: TYPE_NORMAL
- en: (tree-copy (cdr tr))))))`
  prefs: []
  type: TYPE_NORMAL
- en: '`(tree-copy ''((a . b) . c)) ![<graphic>](ch2_0.gif) ((a . b) . c)`'
  prefs: []
  type: TYPE_NORMAL
- en: The natural base argument for a tree structure is anything that is not a pair,
    since the recursion traverses pairs rather than lists. The recursive step in this
    case is *doubly recursive*, finding the value recursively for the car as well
    as the cdr of the argument.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, readers who are familiar with other languages that provide special
    iteration constructs, e.g., *while* or *for* loops, might wonder whether similar
    constructs are required in Scheme. Such constructs are unnecessary; iteration
    in Scheme is expressed more clearly and succinctly via recursion. Recursion is
    more general and eliminates the need for the variable assignments required by
    many other languages' iteration constructs, resulting in code that is more reliable
    and easier to follow. Some recursion is essentially iteration and executes as
    such; Section [3.2](further.html#g55) has more to say about this. Often, there
    is no need to make a distinction, however. Concentrate instead on writing clear,
    concise, and correct programs.
  prefs: []
  type: TYPE_NORMAL
- en: Before we leave the topic of recursion, let's consider a special form of repetition
    called *mapping*. Consider the following procedure, `abs-all`, that takes a list
    of numbers as input and returns a list of their absolute values.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define abs-all'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: '''()'
  prefs: []
  type: TYPE_NORMAL
- en: (cons (abs (car ls))
  prefs: []
  type: TYPE_NORMAL
- en: (abs-all (cdr ls))))))`
  prefs: []
  type: TYPE_NORMAL
- en: '`(abs-all ''(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) (1 2 3 4 5 6)`'
  prefs: []
  type: TYPE_NORMAL
- en: This procedure forms a new list from the input list by applying the procedure
    `abs` to each element. We say that `abs-all` *maps* `abs` over the input list
    to produce the output list. Mapping a procedure over a list is a fairly common
    thing to do, so Scheme provides the procedure `map`, which maps its first argument,
    a procedure, over its second, a list. We can use `map` to define `abs-all`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define abs-all'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (map abs ls)))`
  prefs: []
  type: TYPE_NORMAL
- en: We really do not need `abs-all`, however, since the corresponding direct application
    of `map` is just as short and perhaps clearer.
  prefs: []
  type: TYPE_NORMAL
- en: '`(map abs ''(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) (1 2 3 4 5 6)`'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we can use `lambda` to create the procedure argument to `map`, e.g.,
    to square the elements of a list of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '`(map (lambda (x) (* x x))'
  prefs: []
  type: TYPE_NORMAL
- en: '''(1 -3 -5 7)) ![<graphic>](ch2_0.gif) (1 9 25 49)`'
  prefs: []
  type: TYPE_NORMAL
- en: We can map a multiple-argument procedure over multiple lists, as in the following
    example.
  prefs: []
  type: TYPE_NORMAL
- en: '`(map cons ''(a b c) ''(1 2 3)) ![<graphic>](ch2_0.gif) ((a . 1) (b . 2) (c . 3))`'
  prefs: []
  type: TYPE_NORMAL
- en: The lists must be of the same length, and the procedure should accept as many
    arguments as there are lists. Each element of the output list is the result of
    applying the procedure to corresponding members of the input list.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the first definition of `abs-all` above, you should be able to derive,
    before studying it, the following definition of `map1`, a restricted version of
    `map` that maps a one-argument procedure over a single list.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define map1'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p ls)
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: '''()'
  prefs: []
  type: TYPE_NORMAL
- en: (cons (p (car ls))
  prefs: []
  type: TYPE_NORMAL
- en: (map1 p (cdr ls))))))`
  prefs: []
  type: TYPE_NORMAL
- en: '`(map1 abs ''(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) (1 2 3 4 5 6)`'
  prefs: []
  type: TYPE_NORMAL
- en: All we have done is to replace the call to `abs` in `abs-all` with a call to
    the new parameter `p`. A definition of the more general `map` is given in Section [5.4](control.html#g100).
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.8.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Describe what would happen if you switched the order of the arguments to `cons`
    in the definition of `tree-copy`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.8.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consult Section [6.3](objects.html#g109) for the description of `append` and
    define a two-argument version of it. What would happen if you switched the order
    of the arguments in the call to `append` within your definition of `append`?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.8.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Define the procedure `make-list`, which takes a nonnegative integer `*n*` and
    an object and returns a new list, `*n*` long, each element of which is the object.
  prefs: []
  type: TYPE_NORMAL
- en: '`(make-list 7 ''()) ![<graphic>](ch2_0.gif) (() () () () () () ())`'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Hint*: The base test should be `(= *n* 0)`, and the recursion step should
    involve `(- *n* 1)`. Whereas `()` is the natural base case for recursion on lists,
    0 is the natural base case for recursion on nonnegative integers. Similarly, subtracting
    1 is the natural way to bring a nonnegative integer closer to 0.]'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.8.4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The procedures `list-ref` and `list-tail` return the *n*th element and *n*th
    tail of a list *ls*.
  prefs: []
  type: TYPE_NORMAL
- en: '`(list-ref ''(1 2 3 4) 0) ![<graphic>](ch2_0.gif) 1'
  prefs: []
  type: TYPE_NORMAL
- en: (list-tail '(1 2 3 4) 0) ![<graphic>](ch2_0.gif) (1 2 3 4)
  prefs: []
  type: TYPE_NORMAL
- en: (list-ref '(a short (nested) list) 2) ![<graphic>](ch2_0.gif) (nested)
  prefs: []
  type: TYPE_NORMAL
- en: (list-tail '(a short (nested) list) 2) ![<graphic>](ch2_0.gif) ((nested) list)`
  prefs: []
  type: TYPE_NORMAL
- en: Define both procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.8.5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Exercise [2.7.2](start.html#g31) had you use `length` in the definition of
    `shorter`, which returns the shorter of its two list arguments, or the first if
    the two have the same length. Write `shorter` without using `length`. [*Hint*:
    Define a recursive helper, `shorter?`, and use it in place of the length comparison.]'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.8.6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All of the recursive procedures shown so far have been directly recursive.
    That is, each procedure directly applies itself to a new argument. It is also
    possible to write two procedures that use each other, resulting in indirect recursion.
    Define the procedures `odd?` and `even?`, each in terms of the other. [*Hint*:
    What should each return when its argument is 0?]'
  prefs: []
  type: TYPE_NORMAL
- en: '`(even? 17) ![<graphic>](ch2_0.gif) #f'
  prefs: []
  type: TYPE_NORMAL
- en: (odd? 17) ![<graphic>](ch2_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.8.7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use `map` to define a procedure, `transpose`, that takes a list of pairs and
    returns a pair of lists as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`(transpose ''((a . 1) (b . 2) (c . 3))) ![<graphic>](ch2_0.gif) ((a b c) 1 2 3)`'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Hint*: `((a b c) 1 2 3)` is the same as `((a b c) . (1 2 3))`.]'
  prefs: []
  type: TYPE_NORMAL
- en: Section 2.9\. Assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although many programs can be written without them, assignments to top-level
    variables or `let`-bound and `lambda`-bound variables are sometimes useful. Assignments
    do not create new bindings, as with `let` or `lambda`, but rather change the values
    of existing bindings. Assignments are performed with `set!`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define abcde ''(a b c d e))'
  prefs: []
  type: TYPE_NORMAL
- en: abcde ![<graphic>](ch2_0.gif) (a b c d e)
  prefs: []
  type: TYPE_NORMAL
- en: (set! abcde (cdr abcde))
  prefs: []
  type: TYPE_NORMAL
- en: abcde ![<graphic>](ch2_0.gif) (b c d e)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([abcde '(a b c d e)])
  prefs: []
  type: TYPE_NORMAL
- en: (set! abcde (reverse abcde))
  prefs: []
  type: TYPE_NORMAL
- en: abcde) ![<graphic>](ch2_0.gif) (e d c b a)`
  prefs: []
  type: TYPE_NORMAL
- en: Many languages require the use of assignments to initialize local variables,
    separate from the declaration or binding of the variables. In Scheme, all local
    variables are given a value immediately upon binding. Besides making the separate
    assignment to initialize local variables unnecessary, it ensures that the programmer
    cannot forget to initialize them, a common source of errors in most languages.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, most of the assignments that are either necessary or convenient in
    other languages are both unnecessary and inconvenient in Scheme, since there is
    typically a clearer way to express the same algorithm without assignments. One
    common practice in some languages is to sequence expression evaluation with a
    series of assignments, as in the following procedure that finds the roots of a
    quadratic equation.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define quadratic-formula'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (a b c)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([root1 0] [root2 0] [minusb 0] [radical 0] [divisor 0])
  prefs: []
  type: TYPE_NORMAL
- en: (set! minusb (- 0 b))
  prefs: []
  type: TYPE_NORMAL
- en: (set! radical (sqrt (- (* b b) (* 4 (* a c)))))
  prefs: []
  type: TYPE_NORMAL
- en: (set! divisor (* 2 a))
  prefs: []
  type: TYPE_NORMAL
- en: (set! root1 (/ (+ minusb radical) divisor))
  prefs: []
  type: TYPE_NORMAL
- en: (set! root2 (/ (- minusb radical) divisor))
  prefs: []
  type: TYPE_NORMAL
- en: (cons root1 root2))))`
  prefs: []
  type: TYPE_NORMAL
- en: The roots are computed according to the well-known quadratic formula,
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch2_4.gif)'
  prefs: []
  type: TYPE_IMG
- en: which yields the solutions to the equation 0 = *ax*² + *bx* + *c*. The `let`
    expression in this definition is employed solely to establish the variable bindings,
    corresponding to the declarations required in other languages. The first three
    assignment expressions compute subpieces of the formula, namely -*b*, ![<graphic>](ch2_5.gif),
    and 2*a*. The last two assignment expressions compute the two roots in terms of
    the subpieces. A pair of the two roots is the value of `quadratic-formula`. For
    example, the two roots of 2*x*² - 4*x* - 6 are *x* = 3 and *x* = -1.
  prefs: []
  type: TYPE_NORMAL
- en: '`(quadratic-formula 2 -4 -6) ![<graphic>](ch2_0.gif) (3 . -1)`'
  prefs: []
  type: TYPE_NORMAL
- en: The definition above works, but it can be written more clearly without the assignments,
    as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define quadratic-formula'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (a b c)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([minusb (- 0 b)]
  prefs: []
  type: TYPE_NORMAL
- en: '[radical (sqrt (- (* b b) (* 4 (* a c))))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[divisor (* 2 a)])'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([root1 (/ (+ minusb radical) divisor)]
  prefs: []
  type: TYPE_NORMAL
- en: '[root2 (/ (- minusb radical) divisor)])'
  prefs: []
  type: TYPE_NORMAL
- en: (cons root1 root2)))))`
  prefs: []
  type: TYPE_NORMAL
- en: In this version, the `set!` expressions are gone, and we are left with essentially
    the same algorithm. By employing two `let` expressions, however, the definition
    makes clear the dependency of `root1` and `root2` on the values of `minusb`, `radical`,
    and `divisor`. Equally important, the `let` expressions make clear the *lack*
    of dependencies among `minusb`, `radical`, and `divisor` and between `root1` and
    `root2`.
  prefs: []
  type: TYPE_NORMAL
- en: Assignments do have some uses in Scheme, otherwise the language would not support
    them. Consider the following version of `cons` that counts the number of times
    it is called, storing the count in a variable named `cons-count`. It uses `set!`
    to increment the count; there is no way to achieve the same behavior without assignments.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define kons-count 0)'
  prefs: []
  type: TYPE_NORMAL
- en: (define kons
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y)
  prefs: []
  type: TYPE_NORMAL
- en: (set! kons-count (+ kons-count 1))
  prefs: []
  type: TYPE_NORMAL
- en: (cons x y)))
  prefs: []
  type: TYPE_NORMAL
- en: (kons 'a '(b c)) ![<graphic>](ch2_0.gif) (a b c)
  prefs: []
  type: TYPE_NORMAL
- en: kons-count ![<graphic>](ch2_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (kons 'a (kons 'b (kons 'c '()))) ![<graphic>](ch2_0.gif) (a b c)
  prefs: []
  type: TYPE_NORMAL
- en: kons-count ![<graphic>](ch2_0.gif) 4`
  prefs: []
  type: TYPE_NORMAL
- en: 'Assignments are commonly used to implement procedures that must maintain some
    internal state. For example, suppose we would like to define a procedure that
    returns 0 the first time it is called, 1 the second time, 2 the third time, and
    so on indefinitely. We could write something similar to the definition of `cons-count`
    above:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define next 0)'
  prefs: []
  type: TYPE_NORMAL
- en: (define count
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v next])
  prefs: []
  type: TYPE_NORMAL
- en: (set! next (+ next 1))
  prefs: []
  type: TYPE_NORMAL
- en: v)))
  prefs: []
  type: TYPE_NORMAL
- en: (count) ![<graphic>](ch2_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (count) ![<graphic>](ch2_0.gif) 1`
  prefs: []
  type: TYPE_NORMAL
- en: 'This solution is somewhat undesirable in that the variable `next` is visible
    at top level even though it need not be. Since it is visible at top level, any
    code in the system can change its value, perhaps inadvertently affecting the behavior
    of `count` in a subtle way. We can solve this problem by `let`-binding `next`
    outside of the `lambda` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define count'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([next 0])
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v next])
  prefs: []
  type: TYPE_NORMAL
- en: (set! next (+ next 1))
  prefs: []
  type: TYPE_NORMAL
- en: v))))`
  prefs: []
  type: TYPE_NORMAL
- en: The latter solution also generalizes easily to provide multiple counters, each
    with its own local counter. The procedure `make-counter`, defined below, returns
    a new counting procedure each time it is called.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define make-counter'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (let ([next 0])
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v next])
  prefs: []
  type: TYPE_NORMAL
- en: (set! next (+ next 1))
  prefs: []
  type: TYPE_NORMAL
- en: v)))))`
  prefs: []
  type: TYPE_NORMAL
- en: Since `next` is bound inside of `make-counter` but outside of the procedure
    returned by `make-counter`, each procedure it returns maintains its own unique
    counter.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define count1 (make-counter))'
  prefs: []
  type: TYPE_NORMAL
- en: (define count2 (make-counter))
  prefs: []
  type: TYPE_NORMAL
- en: (count1) ![<graphic>](ch2_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (count2) ![<graphic>](ch2_0.gif) 0
  prefs: []
  type: TYPE_NORMAL
- en: (count1) ![<graphic>](ch2_0.gif) 1
  prefs: []
  type: TYPE_NORMAL
- en: (count1) ![<graphic>](ch2_0.gif) 2
  prefs: []
  type: TYPE_NORMAL
- en: (count2) ![<graphic>](ch2_0.gif) 1`
  prefs: []
  type: TYPE_NORMAL
- en: If a state variable must be shared by more than one procedure defined at top
    level, but we do not want the state variable to be visible at top level, we can
    use `let` to bind the variable and `set!` to make the procedures visible at top
    level.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define shhh #f)'
  prefs: []
  type: TYPE_NORMAL
- en: (define tell #f)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([secret 0])
  prefs: []
  type: TYPE_NORMAL
- en: (set! shhh
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (message)
  prefs: []
  type: TYPE_NORMAL
- en: (set! secret message)))
  prefs: []
  type: TYPE_NORMAL
- en: (set! tell
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: secret)))
  prefs: []
  type: TYPE_NORMAL
- en: (shhh "sally likes harry")
  prefs: []
  type: TYPE_NORMAL
- en: (tell) ![<graphic>](ch2_0.gif) "sally likes harry"
  prefs: []
  type: TYPE_NORMAL
- en: secret ![<graphic>](ch2_0.gif) *exception: variable secret is not bound*`
  prefs: []
  type: TYPE_NORMAL
- en: Variables must be defined before they can be assigned, so we define `shhh` and
    `tell` to be `#f` initially. (Any initial value would do.) We'll see this structure
    again in Section [3.5](further.html#g79) and a better way to structure code like
    this as a library in Section [3.6](further.html#g84).
  prefs: []
  type: TYPE_NORMAL
- en: Local state is sometimes useful for caching computed values or allowing a computation
    to be evaluated *lazily*, i.e., only once and only on demand. The procedure `lazy`
    below accepts a *thunk*, or zero-argument procedure, as an argument. Thunks are
    often used to "freeze" computations that must be delayed for some reason, which
    is exactly what we need to do in this situation. When passed a thunk `*t*`, `lazy`
    returns a new thunk that, when invoked, returns the value of invoking `*t*`. Once
    computed, the value is saved in a local variable so that the computation need
    not be performed again. A boolean flag is used to record whether `*t*` has been
    invoked and its value saved.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define lazy'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (t)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([val #f] [flag #f])
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (if (not flag)
  prefs: []
  type: TYPE_NORMAL
- en: (begin (set! val (t))
  prefs: []
  type: TYPE_NORMAL
- en: (set! flag #t)))
  prefs: []
  type: TYPE_NORMAL
- en: val))))`
  prefs: []
  type: TYPE_NORMAL
- en: The syntactic form `begin`, used here for the first time, evaluates its subexpressions
    in sequence from left to right and returns the value of the last subexpression,
    like the body of a `let` or `lambda` expression. We also see that the `*alternative*`
    subexpression of an `if` expression can be omitted. This should be done only when
    the value of the `if` is discarded, as it is in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation is especially useful for values that require considerable time
    to compute. By delaying the evaluation, we might avoid computing the value altogether,
    and by saving the value, we avoid computing it more than once.
  prefs: []
  type: TYPE_NORMAL
- en: The operation of `lazy` can best be illustrated by printing a message from within
    a thunk passed to `lazy`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define p'
  prefs: []
  type: TYPE_NORMAL
- en: (lazy (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (display "Ouch!")
  prefs: []
  type: TYPE_NORMAL
- en: (newline)
  prefs: []
  type: TYPE_NORMAL
- en: '"got me")))`'
  prefs: []
  type: TYPE_NORMAL
- en: The first time `p` is invoked, the message `Ouch!` is printed and the string
    `"got me"` is returned. Thereafter, `"got me"` is returned but the message is
    not printed. The procedures `display` and `newline` are the first examples of
    explicit input/output we have seen; `display` prints the string without quotation
    marks, and `newline` prints a newline character.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further illustrate the use of `set!`, let''s consider the implementation
    of stack objects whose internal workings are not visible on the outside. A stack
    object accepts one of four *messages*: `empty?`, which returns `#t` if the stack
    is empty; `push!`, which adds an object to the top of the stack; `top`, which
    returns the object on the top of the stack; and `pop!`, which removes the object
    on top of the stack. The procedure `make-stack` given below creates a new stack
    each time it is called in a manner similar to `make-counter`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define make-stack'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls '()])
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (msg . args)
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(eqv? msg ''empty?) (null? ls)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(eqv? msg ''push!) (set! ls (cons (car args) ls))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(eqv? msg ''top) (car ls)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(eqv? msg ''pop!) (set! ls (cdr ls))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else "oops"])))))`'
  prefs: []
  type: TYPE_NORMAL
- en: Each stack is stored as a list bound to the variable `ls`; `set!` is used to
    change this binding for `push!` and `pop!`. Notice that the argument list of the
    inner `lambda` expression uses the improper list syntax to bind `args` to a list
    of all arguments but the first. This is useful here because in the case of `empty?`,
    `top`, and `pop!` there is only one argument (the message), but in the case of
    `push!` there are two (the message and the object to push onto the stack).
  prefs: []
  type: TYPE_NORMAL
- en: '`(define stack1 (make-stack))'
  prefs: []
  type: TYPE_NORMAL
- en: (define stack2 (make-stack))
  prefs: []
  type: TYPE_NORMAL
- en: (list (stack1 'empty?) (stack2 'empty?)) ![<graphic>](ch2_0.giff) (#t #t)
  prefs: []
  type: TYPE_NORMAL
- en: (stack1 'push! 'a)
  prefs: []
  type: TYPE_NORMAL
- en: (list (stack1 'empty?) (stack2 'empty?)) ![<graphic>](ch2_0.gif) (#f #t)
  prefs: []
  type: TYPE_NORMAL
- en: (stack1 'push! 'b)
  prefs: []
  type: TYPE_NORMAL
- en: (stack2 'push! 'c)
  prefs: []
  type: TYPE_NORMAL
- en: (stack1 'top) ![<graphic>](ch2_0.gif) b
  prefs: []
  type: TYPE_NORMAL
- en: (stack2 'top) ![<graphic>](ch2_0.gif) c
  prefs: []
  type: TYPE_NORMAL
- en: (stack1 'pop!)
  prefs: []
  type: TYPE_NORMAL
- en: (stack1 'top) ![<graphic>](ch2_0.gif) a
  prefs: []
  type: TYPE_NORMAL
- en: (list (stack1 'empty?) (stack2 'empty?)) ![<graphic>](ch2_0.gif) (#f #f)
  prefs: []
  type: TYPE_NORMAL
- en: (stack1 'pop!)
  prefs: []
  type: TYPE_NORMAL
- en: (list (stack1 'empty?) (stack2 'empty?)) ![<graphic>](ch2_0.gif) (#t #f)`
  prefs: []
  type: TYPE_NORMAL
- en: As with the counters created by `make-counter`, the state maintained by each
    stack object is directly accessible only within the object. Each reference or
    change to this state is made explicitly by the object itself. One important benefit
    is that we can change the internal structure of the stack, perhaps to use a vector
    (see Section [6.9](objects.html#g115)) instead of a list to hold the elements,
    without changing its external behavior. Because the behavior of the object is
    known abstractly (not operationally), it is known as an *abstract object*. See
    Section [12.8](examples.html#g193) for more about creating abstract objects.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to changing the values of variables, we can also change the values
    of the car and cdr fields of a pair, using the procedures `set-car!` and `set-cdr!`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define p (list 1 2 3))'
  prefs: []
  type: TYPE_NORMAL
- en: (set-car! (cdr p) 'two)
  prefs: []
  type: TYPE_NORMAL
- en: p ![<graphic>](ch2_0.gif) (1 two 3)
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! p '())
  prefs: []
  type: TYPE_NORMAL
- en: p ![<graphic>](ch2_0.gif) (1)`
  prefs: []
  type: TYPE_NORMAL
- en: We can use these operators to define a queue data type, which is like a stack
    except that new elements are added at one end and extracted from the other. The
    following queue implementation uses a *tconc* structure. A tconc consists of a
    nonempty list and a header. The header is a pair whose car points to the first
    pair (head) of the list and whose cdr points to the last pair (end) of the list.
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch2_6.gif)'
  prefs: []
  type: TYPE_IMG
- en: The last element of the list is a placeholder and not considered part of the
    queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Four operations on queues are defined below: `make-queue`, which constructs
    a queue; `putq!`, which adds an element to the end of a queue; `getq`, which retrieves
    the element at the front of a queue; and `delq!`, which removes the element at
    the front of a queue.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define make-queue'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (let ([end (cons 'ignored '())])
  prefs: []
  type: TYPE_NORMAL
- en: (cons end end))))
  prefs: []
  type: TYPE_NORMAL
- en: (define putq!
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (q v)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([end (cons 'ignored '())])
  prefs: []
  type: TYPE_NORMAL
- en: (set-car! (cdr q) v)
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! (cdr q) end)
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! q end))))
  prefs: []
  type: TYPE_NORMAL
- en: (define getq
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (q)
  prefs: []
  type: TYPE_NORMAL
- en: (car (car q))))
  prefs: []
  type: TYPE_NORMAL
- en: (define delq!
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (q)
  prefs: []
  type: TYPE_NORMAL
- en: (set-car! q (cdr (car q)))))`
  prefs: []
  type: TYPE_NORMAL
- en: All are simple operations except for `putq!`, which modifies the end pair to
    contain the new value and adds a new end pair.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define myq (make-queue))'
  prefs: []
  type: TYPE_NORMAL
- en: (putq! myq 'a)
  prefs: []
  type: TYPE_NORMAL
- en: (putq! myq 'b)
  prefs: []
  type: TYPE_NORMAL
- en: (getq myq) ![<graphic>](ch2_0.gif) a
  prefs: []
  type: TYPE_NORMAL
- en: (delq! myq)
  prefs: []
  type: TYPE_NORMAL
- en: (getq myq) ![<graphic>](ch2_0.gif) b
  prefs: []
  type: TYPE_NORMAL
- en: (delq! myq)
  prefs: []
  type: TYPE_NORMAL
- en: (putq! myq 'c)
  prefs: []
  type: TYPE_NORMAL
- en: (putq! myq 'd)
  prefs: []
  type: TYPE_NORMAL
- en: (getq myq) ![<graphic>](ch2_0.gif) c
  prefs: []
  type: TYPE_NORMAL
- en: (delq! myq)
  prefs: []
  type: TYPE_NORMAL
- en: (getq myq) ![<graphic>](ch2_0.gif) d`
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.9.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Modify `make-counter` to take two arguments: an initial value for the counter
    to use in place of 0 and an amount to increment the counter by each time.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.9.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Look up the description of `case` in Section [5.3](control.html#g99). Replace
    the `cond` expression in `make-stack` with an equivalent `case` expression. Add
    `mt?` as a second name for the `empty?` message.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.9.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Modify the `stack` object to allow the two messages `ref` and `set!`. `(*stack* 'ref *i*)`
    should return the `*i*`th element from the top of the stack; `(*stack* 'ref 0)`
    should be equivalent to `(*stack* 'top)`. `(*stack* 'set! *i* *v*)` should change
    the `*i*`th element from the top of the stack to `*v*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define stack (make-stack))'
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'push! 'a)
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'push! 'b)
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'push! 'c)
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'ref 0) ![<graphic>](ch2_0.gif) c
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'ref 2) ![<graphic>](ch2_0.gif) a
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'set! 1 'd)
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'ref 1) ![<graphic>](ch2_0.gif) d
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'top) ![<graphic>](ch2_0.gif) c
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'pop!)
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'top) ![<graphic>](ch2_0.gif) d`
  prefs: []
  type: TYPE_NORMAL
- en: '[*Hint*: Use `list-ref` to implement `ref` and `list-tail` with `set-car!`
    to implement `set!`.]'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.9.4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Scheme supports *vectors* as well as lists. Like lists, vectors are aggregate
    objects that contain other objects. Unlike lists, vectors have a fixed size and
    are laid out in one flat block of memory, typically with a header containing the
    length of the vector, as in the ten-element vector below.
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch2_7.gif)'
  prefs: []
  type: TYPE_IMG
- en: This makes vectors more suitable for applications needing fast access to any
    element of the aggregate but less suitable for applications needing data structures
    that grow and shrink as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Look up the basic vector operations in Section [6.9](objects.html#g115) and
    reimplement the `stack` object to use a vector instead of a list to hold the stack
    contents. Include the `ref` and `set!` messages of Exercise [2.9.3](start.html#g43).
    Have the new `make-stack` accept a size argument *n* and make the vector length
    *n*, but do not otherwise change the external (abstract) interface.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.9.5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Define a predicate, `emptyq?`, for determining if a queue is empty. Modify `getq`
    and `delq!` to raise an exception when an empty queue is found, using `assertion-violation`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.9.6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the queue implementation, the last pair in the encapsulated list is a placeholder,
    i.e., it never holds anything useful. Recode the queue operators to avoid this
    wasted pair. Make sure that the series of queue operations given earlier works
    with the new implementation. Which implementation do you prefer?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.9.7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using `set-cdr!`, it is possible to create *cyclic lists*. For example, the
    following expression evaluates to a list whose car is the symbol `a` and whose
    cdr is the list itself.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([ls (cons ''a ''())])'
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! ls ls)
  prefs: []
  type: TYPE_NORMAL
- en: ls)`
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you enter the above expression during an interactive Scheme
    session? What will the implementation of `length` on page [42](start.html#defn:simplelength)
    do when given a cyclic list? What does the built-in `length` primitive do?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.9.8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Define the predicate `list?`, which returns `#t` if its argument is a proper
    list and `#f` otherwise (see Section [6.3](objects.html#g109)). It should return
    `#f` for cyclic lists as well as for lists terminated by objects other than `()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(list? ''()) ![<graphic>](ch2_0.gif) #t'
  prefs: []
  type: TYPE_NORMAL
- en: (list? '(1 2 3)) ![<graphic>](ch2_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (list? '(a . b)) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (list? (let ([ls (cons 'a '())])
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! ls ls)
  prefs: []
  type: TYPE_NORMAL
- en: ls)) ![<graphic>](ch2_0.gif) #f`
  prefs: []
  type: TYPE_NORMAL
- en: 'First write a simplified version of `list?` that does not handle cyclic lists,
    then extend this to handle cyclic lists correctly. Revise your definition until
    you are satisfied that it is as clear and concise as possible. [*Hint*: Use the
    following "hare and tortoise" algorithm to detect cycles. Define a recursive help
    procedure of two arguments, the hare and the tortoise. Start both the hare and
    the tortoise at the beginning of the list. Have the hare advance by two cdrs each
    time the tortoise advances by one cdr. If the hare catches the tortoise, there
    must be a cycle.]'
  prefs: []
  type: TYPE_NORMAL
