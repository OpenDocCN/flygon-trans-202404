- en: Chapter 2\. Getting Started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 入门
- en: This chapter is an introduction to Scheme for programmers who are new to the
    language. You will get more from this chapter if you are sitting in front of an
    interactive Scheme system, trying out the examples as you go.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是为那些对该语言不熟悉的程序员介绍 Scheme 的。如果你坐在一个交互式 Scheme 系统前，尝试着一边阅读示例一边实践，你会从本章中获得更多。
- en: After reading this chapter and working the exercises, you should be able to
    start using Scheme. You will have learned the syntax of Scheme programs and how
    they are executed, along with how to use simple data structures and control mechanisms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章并完成练习后，你应该能够开始使用 Scheme。你将学会 Scheme 程序的语法以及它们是如何执行的，以及如何使用简单的数据结构和控制机制。
- en: Section 2.1\. Interacting with Scheme
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2.1节 与 Scheme 交互
- en: Most Scheme systems provide an interactive programming environment that simplifies
    program development and experimentation. The simplest interaction with Scheme
    follows a "read-evaluate-print" cycle. A program (often called a *read-evaluate-print
    loop*, or REPL) reads each expression you type at the keyboard, evaluates it,
    and prints its value.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Scheme 系统提供了一个简化程序开发和实验的交互式编程环境。与 Scheme 的最简单交互遵循一个“读取-求值-打印”循环。一个程序（通常称为
    *读取-求值-打印循环*，或 REPL）读取你在键盘上输入的每个表达式，对其进行求值，并打印其值。
- en: 'With an interactive Scheme system, you can type an expression at the keyboard
    and see its value immediately. You can define a procedure and apply it to arguments
    to see how it works. You can even type in an entire program consisting of a set
    of procedure definitions and test it without leaving the system. When your program
    starts getting longer, it will be more convenient to type it into a file (using
    a text editor), load the file and test it interactively. In most Scheme systems,
    a file may be loaded with the nonstandard procedure `load`, which takes a string
    argument naming the file. Preparing your program in a file has several advantages:
    you have a chance to compose your program more carefully, you can correct errors
    without retyping the program, and you can retain a copy for later use. Most Scheme
    implementations treat expressions loaded from a file the same as expressions typed
    at the keyboard.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用交互式 Scheme 系统，你可以在键盘上输入一个表达式并立即看到其值。你可以定义一个过程并将其应用于参数以查看其工作原理。甚至可以键入一个由一组过程定义组成的整个程序，并在不离开系统的情况下进行测试。当你的程序变得更长时，将其键入到一个文件中（使用文本编辑器）并进行交互式加载和测试会更方便。在大多数
    Scheme 系统中，可以使用非标准过程 `load` 加载文件，该过程接受一个字符串参数命名文件。将程序准备在文件中具有几个优点：你有机会更加仔细地组织你的程序，可以在不重新键入程序的情况下纠正错误，并且可以保留一份副本以供以后使用。大多数
    Scheme 实现将从文件加载的表达式视为从键盘输入的表达式。
- en: While Scheme provides various input and output procedures, the REPL takes care
    of reading expressions and printing their values. This frees you to concentrate
    on writing your program without worrying about how its results will be displayed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Scheme 提供了各种输入和输出过程，但 REPL 负责读取表达式并打印它们的值。这使你可以专注于编写程序，而不必担心其结果将如何显示。
- en: The examples in this chapter and in the rest of the book follow a regular format.
    An expression you might type from your keyboard is given first, possibly spanning
    several lines. The value of the expression is given after the ![<graphic>](ch2_0.gif),
    to be read as "evaluates to." The ![<graphic>](ch2_0.gif) is omitted for definitions
    and when the value of an expression is unspecified.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和本书其余部分的示例遵循一种常规格式。首先给出你可能从键盘输入的表达式，可能跨越几行。表达式的值在 ![<graphic>](ch2_0.gif)
    之后给出，可读为“求值为”。对于定义和表达式值未指定的情况，会省略 ![<graphic>](ch2_0.gif)。
- en: The example programs are formatted in a style that "looks nice" and conveys
    the structure of the program. The code is easy to read because the relationship
    between each expression and its subexpressions is clearly shown. Scheme ignores
    indentation and line breaks, however, so there is no need to follow a particular
    style. The important thing is to establish one style and keep to it. Scheme sees
    each program as if it were on a single line, with its subexpressions ordered from
    left to right.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 示例程序采用一种“看起来不错”并传达程序结构的样式进行格式化。代码易于阅读，因为每个表达式与其子表达式之间的关系清晰显示。然而，Scheme 忽略缩进和换行，因此无需遵循特定的样式。重要的是要建立一种样式并坚持下去。Scheme
    将每个程序视为在一行上，其子表达式从左到右排序。
- en: If you have access to an interactive Scheme system, it might be a good idea
    to start it up now and type in the examples as you read. One of the simplest Scheme
    expressions is a string constant. Try typing `"Hi Mom!"` (including the double
    quotes) in response to the prompt. The system should respond with `"Hi Mom!"`;
    the value of any constant is the constant itself.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '`"Hi Mom!" ![<graphic>](ch2_0.gif) "Hi Mom!"`'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Here is a set of expressions, each with Scheme's response. They are explained
    in later sections of this chapter, but for now use them to practice interacting
    with Scheme.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '`"hello" ![<graphic>](ch2_0.gif) "hello"'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 42 ![<graphic>](ch2_0.gif) 42
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 22/7 ![<graphic>](ch2_0.gif) 22/7
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 3.141592653 ![<graphic>](ch2_0.gif) 3.141592653
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: + ![<graphic>](ch2_0.gif) #<procedure>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: (+ 76 31) ![<graphic>](ch2_0.gif) 107
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: (* -12 10) ![<graphic>](ch2_0.gif) -120
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '''(a b c d) ![<graphic>](ch2_0.gif) (a b c d)`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to miss any single quotes ( `'` ), double quotes, or parentheses.
    If you left off a single quote in the last expression, you probably received a
    message indicating that an exception has occurred. Just try again. If you left
    off a closing parenthesis or double quote, the system might still be waiting for
    it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Here are a few more expressions to try. You can try to figure out on your own
    what they mean or wait to find out later in the chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '`(car ''(a b c)) ![<graphic>](ch2_0.gif) a'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: (cdr '(a b c)) ![<graphic>](ch2_0.gif) (b c)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: (cons 'a '(b c)) ![<graphic>](ch2_0.gif) (a b c)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: (cons (car '(a b c))
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: (cdr '(d e f))) ![<graphic>](ch2_0.gif) (a e f)`
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Scheme expressions may span more than one line. The Scheme system
    knows when it has an entire expression by matching double quotes and parentheses.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's try defining a procedure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '`(define square'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: (* n n)))`
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `square` computes the square *n*² of any number *n*. We say more
    about the expressions that make up this definition later in this chapter. For
    now it suffices to say that `define` establishes variable bindings, `lambda` creates
    procedures, and `*` names the multiplication procedure. Note the form of these
    expressions. All structured forms are enclosed in parentheses and written in *prefix
    notation*, i.e., the operator precedes the arguments. As you can see, this is
    true even for simple arithmetic operations such as `*`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Try using `square`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '`(square 5) ![<graphic>](ch2_0.gif) 25'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: (square -200) ![<graphic>](ch2_0.gif) 40000
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: (square 0.5) ![<graphic>](ch2_0.gif) 0.25
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: (square -1/2) ![<graphic>](ch2_0.gif) 1/4`
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Even though the next definition is short, you might enter it into a file. Let's
    assume you call the file "reciprocal.ss."
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '`(define reciprocal'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: (if (= n 0)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '"oops!"'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: (/ 1 n))))`
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: This procedure, `reciprocal`, computes the quantity 1/*n* for any number *n*
    ≠ 0. For *n* = 0, `reciprocal` returns the string `"oops!"`. Return to Scheme
    and try loading your file with the procedure `load`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '`(load "reciprocal.ss")`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Finally, try using the procedure we have just defined.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尝试使用我们刚刚定义的过程。
- en: '`(reciprocal 10) ![<graphic>](ch2_0.gif) 1/10'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`(reciprocal 10) ![<graphic>](ch2_0.gif) 1/10`'
- en: (reciprocal 1/10) ![<graphic>](ch2_0.gif) 10
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`(reciprocal 1/10) ![<graphic>](ch2_0.gif) 10`'
- en: (reciprocal 0) ![<graphic>](ch2_0.gif) "oops!"
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`(reciprocal 0) ![<graphic>](ch2_0.gif) "oops!"`'
- en: (reciprocal (reciprocal 1/10)) ![<graphic>](ch2_0.gif) 1/10`
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`(reciprocal (reciprocal 1/10)) ![<graphic>](ch2_0.gif) 1/10`'
- en: In the next section we will discuss Scheme expressions in more detail. Throughout
    this chapter, keep in mind that your Scheme system is one of the most useful tools
    for learning Scheme. Whenever you try one of the examples in the text, follow
    it up with your own examples. In an interactive Scheme system, the cost of trying
    something out is relatively small---usually just the time to type it in.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地讨论Scheme表达式。在本章中，请记住，你的Scheme系统是学习Scheme最有用的工具之一。每当你尝试文本中的示例之一时，请跟上你自己的示例。在交互式Scheme系统中，尝试某事的成本相对较小---通常只是输入的时间。
- en: Section 2.2\. Simple Expressions
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2.2节。简单表达式
- en: The simplest Scheme expressions are constant data objects, such as strings,
    numbers, symbols, and lists. Scheme supports other object types, but these four
    are enough for many programs. We saw some examples of strings and numbers in the
    preceding section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的Scheme表达式是常量数据对象，如字符串、数字、符号和列表。Scheme支持其他对象类型，但这四种对于许多程序已经足够了。在前一节中，我们看到了一些字符串和数字的示例。
- en: Let's discuss numbers in a little more detail. Numbers are constants. If you
    enter a number, Scheme echoes it back to you. The following examples show that
    Scheme supports several types of numbers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微详细讨论一下数字。数字是常量数据对象。如果你输入一个数字，Scheme会将其回显给你。以下示例显示了Scheme支持几种类型的数字。
- en: '`123456789987654321 ![<graphic>](ch2_0.gif) 123456789987654321'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`123456789987654321 ![<graphic>](ch2_0.gif) 123456789987654321`'
- en: 3/4 ![<graphic>](ch2_0.gif) 3/4
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`3/4 ![<graphic>](ch2_0.gif) 3/4`'
- en: 2.718281828 ![<graphic>](ch2_0.gif) 2.718281828
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`2.718281828 ![<graphic>](ch2_0.gif) 2.718281828`'
- en: 2.2+1.1i ![<graphic>](ch2_0.gif) 2.2+1.1i`
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`2.2+1.1i ![<graphic>](ch2_0.gif) 2.2+1.1i`'
- en: Scheme numbers include exact and inexact integer, rational, real, and complex
    numbers. Exact integers and rational numbers have arbitrary precision, i.e., they
    can be of arbitrary size. Inexact numbers are usually represented internally using
    IEEE standard floating-point representations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme数字包括精确和非精确的整数、有理数、实数和复数。精确整数和有理数具有任意精度，即它们可以是任意大小。非精确数通常使用IEEE标准浮点表示内部表示。
- en: Scheme provides the names `+`, `-`, `*`, and `/` for the corresponding arithmetic
    procedures. Each procedure accepts two numeric arguments. The expressions below
    are called *procedure applications*, because they specify the application of a
    procedure to a set of arguments.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme为相应的算术过程提供了`+`、`-`、`*`和`/`的名称。每个过程接受两个数值参数。下面的表达式称为*过程应用*，因为它们指定了将过程应用于一组参数。
- en: '`(+ 1/2 1/2) ![<graphic>](ch2_0.gif) 1'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`(+ 1/2 1/2) ![<graphic>](ch2_0.gif) 1`'
- en: (- 1.5 1/2) ![<graphic>](ch2_0.gif) 1.0
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`(- 1.5 1/2) ![<graphic>](ch2_0.gif) 1.0`'
- en: (* 3 1/2) ![<graphic>](ch2_0.gif) 3/2
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`(* 3 1/2) ![<graphic>](ch2_0.gif) 3/2`'
- en: (/ 1.5 3/4) ![<graphic>](ch2_0.gif) 2.0`
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`(/ 1.5 3/4) ![<graphic>](ch2_0.gif) 2.0`'
- en: Scheme employs prefix notation even for common arithmetic operations. Any procedure
    application, whether the procedure takes zero, one, two, or more arguments, is
    written as `(*procedure* *arg* ...)`. This regularity simplifies the syntax of
    expressions; one notation is employed regardless of the operation, and there are
    no complicated rules regarding the precedence or associativity of operators.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme甚至对于常见的算术操作也采用前缀表示法。任何过程应用，无论过程接受零个、一个、两个还是更多参数，都写为`(*procedure* *arg*
    ...) `。这种规则简化了表达式的语法；无论操作是什么，都使用一种表示法，并且没有关于运算符的优先级或结合性的复杂规则。
- en: Procedure applications may be nested, in which case the innermost values are
    computed first. We can thus nest applications of the arithmetic procedures given
    above to evaluate more complicated formulas.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 过程应用可以嵌套，此时最内层的值首先计算。因此，我们可以嵌套上述算术过程的应用来评估更复杂的公式。
- en: '`(+ (+ 2 2) (+ 2 2)) ![<graphic>](ch2_0.gif) 8'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`(+ (+ 2 2) (+ 2 2)) ![<graphic>](ch2_0.gif) 8`'
- en: (- 2 (* 4 1/3)) ![<graphic>](ch2_0.gif) 2/3
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`(- 2 (* 4 1/3)) ![<graphic>](ch2_0.gif) 2/3`'
- en: (* 2 (* 2 (* 2 (* 2 2)))) ![<graphic>](ch2_0.gif) 32
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`(* 2 (* 2 (* 2 (* 2 2)))) ![<graphic>](ch2_0.gif) 32`'
- en: (/ (* 6/7 7/2) (- 4.5 1.5)) ![<graphic>](ch2_0.gif) 1.0`
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`(/ (* 6/7 7/2) (- 4.5 1.5)) ![<graphic>](ch2_0.gif) 1.0`'
- en: These examples demonstrate everything you need to use Scheme as a four-function
    desk calculator. While we will not discuss them in this chapter, Scheme supports
    many other arithmetic procedures. Now might be a good time to turn to Section [6.4](objects.html#g110)
    and experiment with some of them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Simple numeric objects are sufficient for many tasks, but sometimes aggregate
    data structures containing two or more values are needed. In many languages, the
    basic aggregate data structure is the array. In Scheme, it is the *list*. Lists
    are written as sequences of objects surrounded by parentheses. For instance, `(1 2 3 4 5)`
    is a list of numbers, and `("this" "is" "a" "list")` is a list of strings. Lists
    need not contain only one type of object, so `(4.2 "hi")` is a valid list containing
    a number and a string. Lists may be nested (may contain other lists), so `((1 2) (3 4))`
    is a valid list with two elements, each of which is a list of two elements.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that lists look just like procedure applications and wonder
    how Scheme tells them apart. That is, how does Scheme distinguish between a list
    of objects, `(*obj[1]* *obj[2]* ...)`, and a procedure application, `(*procedure* *arg* ...)`?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the distinction might seem obvious. The list of numbers `(1 2 3 4 5)`
    could hardly be confused with a procedure application, since 1 is a number, not
    a procedure. So, the answer might be that Scheme looks at the first element of
    the list or procedure application and makes its decision based on whether that
    first element is a procedure or not. This answer is not good enough, since we
    might even want to treat a valid procedure application such as `(+ 3 4)` as a
    list. The answer is that we must tell Scheme explicitly to treat a list as data
    rather than as a procedure application. We do this with `quote`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '`(quote (1 2 3 4 5)) ![<graphic>](ch2_0.gif) (1 2 3 4 5)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: (quote ("this" "is" "a" "list")) ![<graphic>](ch2_0.gif) ("this" "is" "a" "list")
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: (quote (+ 3 4)) ![<graphic>](ch2_0.gif) (+ 3 4)`
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The `quote` forces the list to be treated as data. Try entering the above expressions
    without the quote; you will likely receive a message indicating that an exception
    has occurred for the first two and an incorrect answer (`7`) for the third.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Because `quote` is required fairly frequently in Scheme code, Scheme recognizes
    a single quotation mark ( `'` ) preceding an expression as an abbreviation for
    `quote`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '`''(1 2 3 4) ![<graphic>](ch2_0.gif) (1 2 3 4)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '''((1 2) (3 4)) ![<graphic>](ch2_0.gif) ((1 2) (3 4))'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '''(/ (* 2 -1) 3) ![<graphic>](ch2_0.gif) (/ (* 2 -1) 3)`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Both forms are referred to as `quote` expressions. We often say an object is
    *quoted* when it is enclosed in a `quote` expression.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: A `quote` expression is *not* a procedure application, since it inhibits the
    evaluation of its subexpression. It is an entirely different syntactic form. Scheme
    supports several other syntactic forms in addition to procedure applications and
    `quote` expressions. Each syntactic form is evaluated differently. Fortunately,
    the number of different syntactic forms is small. We will see more of them later
    in this chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`quote` 表达式*不是*过程应用，因为它阻止了其子表达式的评估。这是一个完全不同的语法形式。Scheme 支持除了过程应用和 `quote` 表达式之外的几种其他语法形式。每种语法形式的评估方式都不同。幸运的是，不同的语法形式数量很少。我们将在本章后面看到更多。'
- en: Not all `quote` expressions involve lists. Try the following expression with
    and without the `quote` wrapper.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的 `quote` 表达式都涉及列表。尝试以下表达式，带有和不带有 `quote` 包装。
- en: '`(quote hello) ![<graphic>](ch2_0.gif) hello`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`(quote hello) ![<graphic>](ch2_0.gif) hello`'
- en: The symbol `hello` must be quoted in order to prevent Scheme from treating `hello`
    as a *variable*. Symbols and variables in Scheme are similar to symbols and variables
    in mathematical expressions and equations. When we evaluate the mathematical expression
    1 - *x* for some value of *x*, we think of *x* as a variable. On the other hand,
    when we consider the algebraic equation *x*² - 1 = (*x* - 1)(*x* + 1), we think
    of *x* as a symbol (in fact, we think of the whole equation symbolically). Just
    as quoting a list tells Scheme to treat a parenthesized form as a list rather
    than as a procedure application, quoting an identifier tells Scheme to treat the
    identifier as a symbol rather than as a variable. While symbols are commonly used
    to represent variables in symbolic representations of equations or programs, symbols
    may also be used, for example, as words in the representation of natural language
    sentences.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 `hello` 必须被引用，以防止 Scheme 将 `hello` 视为*变量*。在 Scheme 中，符号和变量类似于数学表达式和方程中的符号和变量。当我们评估数学表达式
    1 - *x* 时，我们将 *x* 视为变量。另一方面，当我们考虑代数方程 *x*² - 1 = (*x* - 1)(*x* + 1) 时，我们将 *x*
    视为符号（实际上，我们将整个方程符号化）。就像引用列表告诉 Scheme 将括号形式视为列表而不是过程应用一样，引用标识符告诉 Scheme 将标识符视为符号而不是变量。虽然符号通常用于代表方程或程序的符号表示中的变量，但符号也可以用作自然语言句子表示中的单词，例如。
- en: You might wonder why applications and variables share notations with lists and
    symbols. The shared notation allows Scheme programs to be represented as Scheme
    data, simplifying the writing of interpreters, compilers, editors, and other tools
    in Scheme. This is demonstrated by the Scheme interpreter given in Section [12.7](examples.html#g187),
    which is itself written in Scheme. Many people believe this to be one of the most
    important features of Scheme.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么应用程序和变量与列表和符号共享符号。共享符号使得 Scheme 程序可以被表示为 Scheme 数据，简化了在 Scheme 中编写解释器、编译器、编辑器和其他工具的过程。这一点在第
    [12.7](examples.html#g187) 节中给出的 Scheme 解释器中有所体现，该解释器本身就是用 Scheme 编写的。许多人认为这是
    Scheme 中最重要的特性之一。
- en: Numbers and strings may be quoted, too.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 数字和字符串也可以被引用。
- en: '`''2 ![<graphic>](ch2_0.gif) 2'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`''2 ![<graphic>](ch2_0.gif) 2'
- en: '''2/3 ![<graphic>](ch2_0.gif) 2/3'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '''2/3 ![<graphic>](ch2_0.gif) 2/3'
- en: (quote "Hi Mom!") ![<graphic>](ch2_0.gif) "Hi Mom!"`
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: (quote "Hi Mom!") ![<graphic>](ch2_0.gif) "Hi Mom!"`
- en: Numbers and strings are treated as constants in any case, however, so quoting
    them is unnecessary.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，数字和字符串在任何情况下都被视为常量，因此引用它们是不必要的。
- en: 'Now let''s discuss some Scheme procedures for manipulating lists. There are
    two basic procedures for taking lists apart: `car` and `cdr` (pronounced *could-er*).
    `car` returns the first element of a list, and `cdr` returns the remainder of
    the list. (The names "car" and "cdr" are derived from operations supported by
    the first computer on which a Lisp language was implemented, the IBM 704.) Each
    requires a nonempty list as its argument.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一些用于操作列表的 Scheme 过程。有两个基本过程用于拆分列表：`car` 和 `cdr`（发音为 *could-er*）。`car`
    返回列表的第一个元素，`cdr` 返回列表的其余部分。（名称 "car" 和 "cdr" 源自第一台实现 Lisp 语言的计算机 IBM 704 支持的操作。）每个过程都需要一个非空列表作为其参数。
- en: '`(car ''(a b c)) ![<graphic>](ch2_0.gif) a'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`(car ''(a b c)) ![<graphic>](ch2_0.gif) a'
- en: (cdr '(a b c)) ![<graphic>](ch2_0.gif) (b c)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr '(a b c)) ![<graphic>](ch2_0.gif) (b c)
- en: (cdr '(a)) ![<graphic>](ch2_0.gif) ()
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr '(a)) ![<graphic>](ch2_0.gif) ()
- en: (car (cdr '(a b c))) ![<graphic>](ch2_0.gif) b
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: (car (cdr '(a b c))) ![<graphic>](ch2_0.gif) b
- en: (cdr (cdr '(a b c))) ![<graphic>](ch2_0.gif) (c)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr (cdr '(a b c))) ![<graphic>](ch2_0.gif) (c)
- en: (car '((a b) (c d))) ![<graphic>](ch2_0.gif) (a b)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: (car '((a b) (c d))) ![<graphic>](ch2_0.gif) (a b)
- en: (cdr '((a b) (c d))) ![<graphic>](ch2_0.gif) ((c d))`
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr '((a b) (c d))) ![<graphic>](ch2_0.gif) ((c d))`
- en: The first element of a list is often called the "car" of the list, and the rest
    of the list is often called the "cdr" of the list. The cdr of a list with one
    element is `()`, the *empty list*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的第一个元素通常称为列表的“car”，列表的其余部分通常称为列表的“cdr”。具有一个元素的列表的cdr是`()`，即*empty list*。
- en: The procedure `cons` constructs lists. It takes two arguments. The second argument
    is usually a list, and in that case `cons` returns a list.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 过程`cons`构建列表。它接受两个参数。第二个参数通常是一个列表，在这种情况下`cons`返回一个列表。
- en: '`(cons ''a ''()) ![<graphic>](ch2_0.gif) (a)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cons ''a ''()) ![<graphic>](ch2_0.gif) (a)'
- en: (cons 'a '(b c)) ![<graphic>](ch2_0.gif) (a b c)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: (cons 'a '(b c)) ![<graphic>](ch2_0.gif) (a b c)
- en: (cons 'a (cons 'b (cons 'c '()))) ![<graphic>](ch2_0.gif) (a b c)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: (cons 'a (cons 'b (cons 'c '()))) ![<graphic>](ch2_0.gif) (a b c)
- en: (cons '(a b) '(c d)) ![<graphic>](ch2_0.gif) ((a b) c d)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: (cons '(a b) '(c d)) ![<graphic>](ch2_0.gif) ((a b) c d)
- en: (car (cons 'a '(b c))) ![<graphic>](ch2_0.gif) a
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: (car (cons 'a '(b c))) ![<graphic>](ch2_0.gif) a
- en: (cdr (cons 'a '(b c))) ![<graphic>](ch2_0.gif) (b c)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr (cons 'a '(b c))) ![<graphic>](ch2_0.gif) (b c)
- en: (cons (car '(a b c))
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (car '(a b c))
- en: (cdr '(d e f))) ![<graphic>](ch2_0.gif) (a e f)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr '(d e f))) ![<graphic>](ch2_0.gif) (a e f)
- en: (cons (car '(a b c))
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (car '(a b c))
- en: (cdr '(a b c))) ![<graphic>](ch2_0.gif) (a b c)`
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr '(a b c))) ![<graphic>](ch2_0.gif) (a b c)`
- en: Just as "car" and "cdr" are often used as nouns, "cons" is often used as a verb.
    Creating a new list by adding an element to the beginning of a list is referred
    to as *consing* the element onto the list.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如“car”和“cdr”经常用作名词一样，“cons”经常用作动词。通过在列表开头添加元素来创建新列表被称为*consing*该元素到列表上。
- en: Notice the word "usually" in the description of `cons`'s second argument. The
    procedure `cons` actually builds *pairs*, and there is no reason that the cdr
    of a pair must be a list. A list is a sequence of pairs; each pair's cdr is the
    next pair in the sequence.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`cons`第二个参数描述中的“通常”一词。实际上，过程`cons`构建*对*，一个对的cdr不一定是列表。列表是一系列对；每个对的cdr是序列中的下一个对。
- en: '![<graphic>](ch2_1.gif)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](ch2_1.gif)'
- en: The cdr of the last pair in a *proper list* is the empty list. Otherwise, the
    sequence of pairs forms an *improper list*. More formally, the empty list is a
    proper list, and any pair whose cdr is a proper list is a proper list.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*proper list*中最后一对的cdr是空列表。否则，一系列对形成一个*improper list*。更正式地说，空列表是proper list，任何cdr是proper
    list的对也是proper list。'
- en: An improper list is printed in *dotted-pair notation*, with a period, or *dot*,
    preceding the final element of the list.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: improper list以*dotted-pair notation*打印，列表的最后一个元素之前有一个句点或*dot*。
- en: '`(cons ''a ''b) ![<graphic>](ch2_0.gif) (a . b)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cons ''a ''b) ![<graphic>](ch2_0.gif) (a . b)'
- en: (cdr '(a . b)) ![<graphic>](ch2_0.gif) b
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr '(a . b)) ![<graphic>](ch2_0.gif) b
- en: (cons 'a '(b . c)) ![<graphic>](ch2_0.gif) (a b . c)`
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: (cons 'a '(b . c)) ![<graphic>](ch2_0.gif) (a b . c)`
- en: Because of its printed notation, a pair whose cdr is not a list is often called
    a *dotted pair*. Even pairs whose cdrs are lists can be written in dotted-pair
    notation, however, although the printer always chooses to write proper lists without
    dots.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其打印表示法，cdr不是列表的对通常被称为*dotted pair*。然而，即使cdr是列表的对也可以用dotted-pair表示法写出，尽管打印机总是选择不带点的方式写出proper
    list。
- en: '`''(a . (b . (c . ()))) ![<graphic>](ch2_0.gif) (a b c)`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`''(a . (b . (c . ()))) ![<graphic>](ch2_0.gif) (a b c)`'
- en: The procedure `list` is similar to `cons`, except that it takes an arbitrary
    number of arguments and always builds a proper list.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 过程`list`类似于`cons`，不同之处在于它接受任意数量的参数并始终构建proper list。
- en: '`(list ''a ''b ''c) ![<graphic>](ch2_0.gif) (a b c)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`(list ''a ''b ''c) ![<graphic>](ch2_0.gif) (a b c)'
- en: (list 'a) ![<graphic>](ch2_0.gif) (a)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: (list 'a) ![<graphic>](ch2_0.gif) (a)
- en: (list) ![<graphic>](ch2_0.gif) ()`
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: (list) ![<graphic>](ch2_0.gif) ()`
- en: Section [6.3](objects.html#g109) provides more information on lists and the
    Scheme procedures for manipulating them. This might be a good time to turn to
    that section and familiarize yourself with the other procedures given there.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第[6.3](objects.html#g109)节提供了有关列表和Scheme程序操作列表的更多信息。现在可能是一个好时机转到该部分，并熟悉那里提供的其他程序。
- en: Exercise 2.2.1
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习2.2.1
- en: Convert the following arithmetic expressions into Scheme expressions and evaluate
    them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下算术表达式转换为Scheme表达式并计算。
- en: '| *  a*. | 1.2 × (2 - 1/3) + -8.7 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| *  a*. | 1.2 × (2 - 1/3) + -8.7 |'
- en: '| *  b*. | (2/3 + 4/9) ÷ (5/11 - 4/3) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| *  b*. | (2/3 + 4/9) ÷ (5/11 - 4/3) |'
- en: '| *  c*. | 1 + 1 ÷ (2 + 1 ÷ (1 + 1/2)) |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| *  c*. | 1 + 1 ÷ (2 + 1 ÷ (1 + 1/2)) |'
- en: '| *  d*. | 1 × -2 × 3 × -4 × 5 × -6 × 7 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| *  d*. | 1 × -2 × 3 × -4 × 5 × -6 × 7 |'
- en: Exercise 2.2.2
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习2.2.2
- en: Experiment with the procedures `+`, `-`, `*`, and `/` to determine Scheme's
    rules for the type of value returned by each when given different types of numeric
    arguments.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用过程`+`、`-`、`*`和`/`来确定当给定不同类型的数值参数时，Scheme 返回的值类型规则。
- en: Exercise 2.2.3
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.2.3
- en: Determine the values of the following expressions. Use your Scheme system to
    verify your answers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 确定以下表达式的值。使用你的 Scheme 系统验证你的答案。
- en: '| *  a*. | `(cons ''car ''cdr)` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| *  a*. | `(cons ''car ''cdr)` |'
- en: '| *  b*. | `(list ''this ''(is silly))` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| *  b*. | `(list ''this ''(is silly))` |'
- en: '| *  c*. | `(cons ''is ''(this silly?))` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| *  c*. | `(cons ''is ''(this silly?))` |'
- en: '| *  d*. | `(quote (+ 2 3))` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| *  d*. | `(quote (+ 2 3))` |'
- en: '| *  e*. | `(cons ''+ ''(2 3))` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| *  e*. | `(cons ''+ ''(2 3))` |'
- en: '| *  f*. | `(car ''(+ 2 3))` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| *  f*. | `(car ''(+ 2 3))` |'
- en: '| *  g*. | `(cdr ''(+ 2 3))` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| *  g*. | `(cdr ''(+ 2 3))` |'
- en: '| *  h*. | `cons` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| *  h*. | `cons` |'
- en: '| *  i*. | `(quote cons)` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| *  i*. | `(quote cons)` |'
- en: '| *  j*. | `(quote (quote cons))` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| *  j*. | `(quote (quote cons))` |'
- en: '| *  k*. | `(car (quote (quote cons)))` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| *  k*. | `(car (quote (quote cons)))` |'
- en: '| *  l*. | `(+ 2 3)` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| *  l*. | `(+ 2 3)` |'
- en: '| *  m*. | `(+ ''2 ''3)` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| *  m*. | `(+ ''2 ''3)` |'
- en: '| *  n*. | `(+ (car ''(2 3)) (car (cdr ''(2 3))))` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| *  n*. | `(+ (car ''(2 3)) (car (cdr ''(2 3))))` |'
- en: '| *  o*. | `((car (list + - * /)) 2 3)` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| *  o*. | `((car (list + - * /)) 2 3)` |'
- en: Exercise 2.2.4
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.2.4
- en: '`(car (car ''((a b) (c d))))` yields `a`. Determine which compositions of `car`
    and `cdr` applied to `((a b) (c d))` yield `b`, `c`, and `d`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`(car (car ''((a b) (c d))))` 得到 `a`。确定应用于 `((a b) (c d))` 的 `car` 和 `cdr`
    的哪些组合得到 `b`、`c` 和 `d`。'
- en: Exercise 2.2.5
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.2.5
- en: Write a Scheme expression that evaluates to the following internal list structure.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 写一个 Scheme 表达式，使其求值为以下内部列表结构。
- en: '![<graphic>](ch2_2.gif)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](ch2_2.gif)'
- en: Exercise 2.2.6
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.2.6
- en: Draw the internal list structure produced by the expression below.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制下面表达式产生的内部列表结构。
- en: '`(cons 1 (cons ''(2 . ((3) . ())) (cons ''(()) (cons 4 5))))`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cons 1 (cons ''(2 . ((3) . ())) (cons ''(()) (cons 4 5))))`'
- en: Exercise 2.2.7
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.2.7
- en: The behavior of `(car (car (car '((a b) (c d)))))` is undefined because `(car '((a b) (c d)))`
    is `(a b)`, `(car '(a b))` is `a`, and `(car 'a)` is undefined. Determine all
    legal compositions of `car` and `cdr` applied to `((a b) (c d))`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`(car (car (car ''((a b) (c d)))))` 的行为是未定义的，因为 `(car ''((a b) (c d)))` 是 `(a b)`，`(car ''(a b))`
    是 `a`，而 `(car ''a)` 是未定义的。确定应用于 `((a b) (c d))` 的所有合法 `car` 和 `cdr` 的组合。'
- en: Exercise 2.2.8
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 2.2.8
- en: Try to explain how Scheme expressions are evaluated. Does your explanation cover
    the last example in Exercise [2.2.3](start.html#g9)?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试解释 Scheme 表达式是如何求值的。你的解释是否涵盖了练习 [2.2.3](start.html#g9) 中的最后一个例子？
- en: Section 2.3\. Evaluating Scheme Expressions
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2.3 节。求值 Scheme 表达式
- en: 'Let''s turn to a discussion of how Scheme evaluates the expressions you type.
    We have already established the rules for constant objects such as strings and
    numbers: the object itself is the value. You have probably also worked out in
    your mind a rule for evaluating procedure applications of the form `(*procedure* *arg[1]* ... *arg[n]*)`.
    Here, `*procedure*` is an expression representing a Scheme procedure, and `*arg[1]* ... *arg[n]*`
    are expressions representing its arguments. One possibility is the following.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下 Scheme 如何评估你输入的表达式。我们已经建立了对于常量对象（如字符串和数字）的规则：对象本身就是值。你可能也已经在脑海中想出了一条规则，用于评估形式为
    `(*procedure* *arg[1]* ... *arg[n]*)` 的过程应用。在这里，`*procedure*` 是表示 Scheme 过程的表���式，`*arg[1]* ... *arg[n]*`
    是表示其参数的表达式。一种可能性是以下内容。
- en: Find the value of `*procedure*`.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到 `*procedure*` 的值。
- en: Find the value of `*arg[1]*`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到 `*arg[1]*` 的值。
- en: '![<graphic>](ch2_3.gif)'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![<graphic>](ch2_3.gif)'
- en: Find the value of `*arg[n]*`.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到`*arg[n]*`的值。
- en: Apply the value of `*procedure*` to the values of `*arg[1]* ... *arg[n]*`.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`*procedure*`的值应用于`*arg[1]* ... *arg[n]*`的值。
- en: For example, consider the simple procedure application `(+ 3 4)`. The value
    of `+` is the addition procedure, the value of 3 is the number 3, and the value
    of 4 is the number 4. Applying the addition procedure to 3 and 4 yields 7, so
    our value is the object 7.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑简单的过程应用 `(+ 3 4)`。`+` 的值是加法过程，3 的值是数字 3，4 的值是数字 4。将加法过程应用于 3 和 4 得到 7，因此我们的值是对象
    7。
- en: By applying this process at each level, we can find the value of the nested
    expression `(* (+ 3 4) 2)`. The value of `*` is the multiplication procedure,
    the value of `(+ 3 4)` we can determine to be the number 7, and the value of 2
    is the number 2. Multiplying 7 by 2 we get 14, so our answer is 14.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在每个级别应用这个过程，我们可以找到嵌套表达式 `(* (+ 3 4) 2)` 的值。`*` 的值是乘法过程，`(+ 3 4)` 我们可以确定为数字
    7，2 的值是数字 2。将 7 乘以 2 得到 14，因此我们的答案是 14。
- en: This rule works for procedure applications but not for `quote` expressions because
    the subexpressions of a procedure application are evaluated, whereas the subexpression
    of a `quote` expression is not. The evaluation of a `quote` expression is more
    similar to the evaluation of constant objects. The value of a `quote` expression
    of the form `(quote *object*)` is simply `*object*`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Constant objects, procedure applications, and `quote` expressions are only three
    of the many syntactic forms provided by Scheme. Fortunately, only a few of the
    other syntactic forms need to be understood directly by a Scheme programmer; these
    are referred to as *core* syntactic forms. The remaining syntactic forms are *syntactic
    extensions* defined, ultimately, in terms of the core syntactic forms. We will
    discuss the remaining core syntactic forms and a few syntactic extensions in the
    remaining sections of this chapter. Section [3.1](further.html#g50) summarizes
    the core syntactic forms and introduces the syntactic extension mechanism.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Before we go on to more syntactic forms and procedures, two points related to
    the evaluation of procedure applications are worthy of note. First, the process
    given above is overspecified, in that it requires the subexpressions to be evaluated
    from left to right. That is, `*procedure*` is evaluated before `*arg[1]*`, `*arg[1]*`
    is evaluated before `*arg[2]*`, and so on. This need not be the case. A Scheme
    evaluator is free to evaluate the expressions in any order---left to right, right
    to left, or any other sequential order. In fact, the subexpressions may be evaluated
    in different orders for different applications, even in the same implementation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The second point is that `*procedure*` is evaluated in the same way as `*arg[1]* ... *arg[n]*`.
    While `*procedure*` is often a variable that names a particular procedure, this
    need not be the case. Exercise [2.2.3](start.html#g9) had you determine the value
    of the expression `((car (list + - * /)) 2 3)`. Here, `*procedure*` is `(car (list + - * /))`.
    The value of `(car (list + - * /))` is the addition procedure, just as if `*procedure*`
    were simply the variable `+`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.3.1
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write down the steps necessary to evaluate the expression below.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '`((car (cdr (list + - * /))) 17 5)`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Section 2.4\. Variables and Let Expressions
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose `*expr*` is a Scheme expression that contains a variable `*var*`. Suppose,
    additionally, that we would like `*var*` to have the value `*val*` when we evaluate
    `*expr*`. For example, we might like `x` to have the value 2 when we evaluate
    `(+ x 3)`. Or, we might want `y` to have the value 3 when we evaluate `(+ 2 y)`.
    The following examples demonstrate how to do this using Scheme's `let` syntactic
    form.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ((x 2))'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: (+ x 3)) ![<graphic>](ch2_0.gif) 5
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: (let ((y 3))
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: (+ 2 y)) ![<graphic>](ch2_0.gif) 5
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: (let ((x 2) (y 3))
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: (+ x y)) ![<graphic>](ch2_0.gif) 5`
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The `let` syntactic form includes a list of variable-expression pairs, along
    with a sequence of expressions referred to as the *body* of the `let`. The general
    form of a `let` expression is
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: We say the variables are *bound* to the values by the `let`. We refer to variables
    bound by `let` as `let`-*bound* variables.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: A `let` expression is often used to simplify an expression that would contain
    two identical subexpressions. Doing so also ensures that the value of the common
    subexpression is computed only once.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ (* 4 4) (* 4 4)) ![<graphic>](ch2_0.gif) 32'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: (let ((a (* 4 4))) (+ a a)) ![<graphic>](ch2_0.gif) 32`
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Brackets are often used in place of parentheses to delimit the bindings of a
    `let` expression.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([list1 ''(a b c)] [list2 ''(d e f)])'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: (cons (cons (car list1)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: (car list2))
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: (cons (car (cdr list1))
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: (car (cdr list2))))) ![<graphic>](ch2_0.gif) ((a . d) b . e)`
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Scheme treats forms enclosed in brackets just like forms enclosed in parentheses.
    An open bracket must be matched by a close bracket, and an open parenthesis must
    be matched by a close parenthesis. We use brackets for `let` (and, as we'll see,
    several other standard syntactic forms) to improve readability, especially when
    we might otherwise have two or more consecutive open parentheses.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Since expressions in the first position of a procedure application are evaluated
    no differently from other expressions, a `let`-bound variable may be used there
    as well.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([f +])'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: (f 2 3)) ![<graphic>](ch2_0.gif) 5
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f +] [x 2])
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: (f x 3)) ![<graphic>](ch2_0.gif) 5
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f +] [x 2] [y 3])
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: (f x y)) ![<graphic>](ch2_0.gif) 5`
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The variables bound by `let` are visible only within the body of the `let`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([+ *])'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: (+ 2 3)) ![<graphic>](ch2_0.gif) 6
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: (+ 2 3) ![<graphic>](ch2_0.gif) 5`
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: This is fortunate, because we would not want the value of `+` to be the multiplication
    procedure everywhere.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to nest `let` expressions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([a 4] [b -3])'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: (let ([a-squared (* a a)]
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[b-squared (* b b)])'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: (+ a-squared b-squared))) ![<graphic>](ch2_0.gif) 25`
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: When nested `let` expressions bind the same variable, only the binding created
    by the inner `let` is visible within its body.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 1])'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (+ x 1)])
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: (+ x x))) ![<graphic>](ch2_0.gif) 4`
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The outer `let` expression binds `x` to 1 within its body, which is the second
    `let` expression. The inner `let` expression binds `x` to `(+ x 1)` within its
    body, which is the expression `(+ x x)`. What is the value of `(+ x 1)`? Since
    `(+ x 1)` appears within the body of the outer `let` but not within the body of
    the inner `let`, the value of `x` must be 1 and hence the value of `(+ x 1)` is
    2. What about `(+ x x)`? It appears within the body of both `let` expressions.
    Only the inner binding for `x` is visible, so `x` is 2 and `(+ x x)` is 4.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The inner binding for `x` is said to *shadow* the outer binding. A `let`-bound
    variable is visible everywhere within the body of its `let` expression except
    where it is shadowed. The region where a variable binding is visible is called
    its *scope*. The scope of the first `x` in the example above is the body of the
    outer `let` expression minus the body of the inner `let` expression, where it
    is shadowed by the second `x`. This form of scoping is referred to as *lexical
    scoping*, since the scope of each binding can be determined by a straightforward
    textual analysis of the program.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Shadowing may be avoided by choosing different names for variables. The expression
    above could be rewritten so that the variable bound by the inner `let` is `new-x`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 1])'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: (let ([new-x (+ x 1)])
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: (+ new-x new-x))) ![<graphic>](ch2_0.gif) 4`
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Although choosing different names can sometimes prevent confusion, shadowing
    can help prevent the accidental use of an "old" value. For example, with the original
    version of the preceding example, it would be impossible for us to mistakenly
    refer to the outer `x` within the body of the inner `let`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.4.1
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rewrite the following expressions, using `let` to remove common subexpressions
    and to improve the structure of the code. Do not perform any algebraic simplifications.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '| *  a*. | `(+ (- (* 3 a) b) (+ (* 3 a) b))` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
- en: '| *  b*. | `(cons (car (list a b c)) (cdr (list a b c)))` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: Exercise 2.4.2
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Determine the value of the following expression. Explain how you derived this
    value.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x 9])'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: (* x
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (/ x 3)])
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: (+ x x))))`
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.4.3
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rewrite the following expressions to give unique names to each different `let`-bound
    variable so that none of the variables is shadowed. Verify that the value of your
    expression is the same as that of the original expression.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '| *  a*. | `(let ([x ''a] [y ''b])   (list (let ([x ''c]) (cons x y))'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: (let ([y 'd]) (cons x y))))` |
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '| *  b*. | `(let ([x ''((a b) c)])   (cons (let ([x (cdr x)])'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: (car x))
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (car x)])
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: (cons (let ([x (cdr x)])
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: (car x))
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: (cons (let ([x (car x)])
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: x)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: (cdr x))))))` |
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Section 2.5\. Lambda Expressions
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the expression `(let ([x (* 3 4)]) (+ x x))`, the variable `x` is bound to
    the value of `(* 3 4)`. What if we would like the value of `(+ x x)` where `x`
    is bound to the value of `(/ 99 11)`? Where `x` is bound to the value of `(- 2 7)`?
    In each case we need a different `let` expression. When the body of the `let`
    is complicated, however, having to repeat it can be inconvenient.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can use the syntactic form `lambda` to create a new procedure that
    has `x` as a parameter and has the same body as the `let` expression.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '`(lambda (x) (+ x x)) ![<graphic>](ch2_0.gif) #<procedure>`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: The general form of a `lambda` expression is
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '`(lambda (*var* ...) *body[1]* *body[2]* ...)`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The variables `*var* ...` are the *formal parameters* of the procedure, and
    the sequence of expressions `*body[1]* *body[2]* ...` is its body. (Actually,
    the true general form is somewhat more general than this, as you will see later.)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: A procedure is just as much an object as a number, string, symbol, or pair.
    It does not have any meaningful printed representation as far as Scheme is concerned,
    however, so this book uses the notation `#<procedure>` to show that the value
    of an expression is a procedure.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The most common operation to perform on a procedure is to apply it to one or
    more values.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '`((lambda (x) (+ x x)) (* 3 4)) ![<graphic>](ch2_0.gif) 24`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: This is no different from any other procedure application. The procedure is
    the value of `(lambda (x) (+ x x))`, and the only argument is the value of `(* 3 4)`,
    or 12. The argument values, or *actual parameters*, are bound to the formal parameters
    within the body of the `lambda` expression in the same way as `let`-bound variables
    are bound to their values. In this case, `x` is bound to 12, and the value of
    `(+ x x)` is 24. Thus, the result of applying the procedure to the value 12 is
    24.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Because procedures are objects, we can establish a procedure as the value of
    a variable and use the procedure more than once.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([double (lambda (x) (+ x x))])'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: (list (double (* 3 4))
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: (double (/ 99 11))
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: (double (- 2 7)))) ![<graphic>](ch2_0.gif) (24 18 -10)`
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Here, we establish a binding for `double` to a procedure, then use this procedure
    to double three different values.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The procedure expects its actual parameter to be a number, since it passes the
    actual parameter on to `+`. In general, the actual parameter may be any sort of
    object. Consider, for example, a similar procedure that uses `cons` instead of
    `+`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([double-cons (lambda (x) (cons x x))])'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: (double-cons 'a)) ![<graphic>](ch2_0.gif) (a . a)`
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Noting the similarity between `double` and `double-cons`, you should not be
    surprised to learn that they may be collapsed into a single procedure by adding
    an additional argument.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([double-any (lambda (f x) (f x x))])'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: (list (double-any + 13)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: (double-any cons 'a))) ![<graphic>](ch2_0.gif) (26 (a . a))`
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: This demonstrates that procedures may accept more than one argument and that
    arguments passed to a procedure may themselves be procedures.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: As with `let` expressions, `lambda` expressions become somewhat more interesting
    when they are nested within other `lambda` or `let` expressions.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x ''a])'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda (y) (list x y))])
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: (f 'b))) ![<graphic>](ch2_0.gif) (a b)`
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The occurrence of `x` within the `lambda` expression refers to the `x` outside
    the `lambda` that is bound by the outer `let` expression. The variable `x` is
    said to *occur free* in the `lambda` expression or to be a *free variable* of
    the `lambda` expression. The variable `y` does not occur free in the `lambda`
    expression since it is bound by the `lambda` expression. A variable that occurs
    free in a `lambda` expression should be bound, e.g., by an enclosing `lambda`
    or `let` expression, unless the variable is (like the names of primitive procedures)
    bound outside of the expression, as we discuss in the following section.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: What happens when the procedure is applied somewhere outside the scope of the
    bindings for variables that occur free within the procedure, as in the following
    expression?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([f (let ([x ''sam])'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (y z) (list x y z)))])
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: (f 'i 'am)) ![<graphic>](ch2_0.gif) (sam i am)`
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that the same bindings that were in effect when the procedure
    was created are in effect again when the procedure is applied. This is true even
    if another binding for `x` is visible where the procedure is applied.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([f (let ([x ''sam])'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (y z) (list x y z)))])
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x 'not-sam])
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: (f 'i 'am))) ![<graphic>](ch2_0.gif) (sam i am)`
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the value of `x` within the procedure named `f` is `sam`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, a `let` expression is nothing more than the direct application
    of a `lambda` expression to a set of argument expressions. For example, the two
    expressions below are equivalent.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x ''a]) (cons x x))` ≡ `((lambda (x) (cons x x)) ''a)`'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: In fact, a `let` expression is a syntactic extension defined in terms of `lambda`
    and procedure application, which are both core syntactic forms. In general, any
    expression of the form
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: is equivalent to the following.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '`((lambda (*var* ...) *body[1]* *body[2]* ...)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '*expr* ...)`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: See Section [3.1](further.html#g50) for more about core forms and syntactic
    extensions.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned above, the general form of `lambda` is a bit more complicated
    than the form we saw earlier, in that the formal parameter specification, `(*var* ...)`,
    need not be a proper list, or indeed even a list at all. The formal parameter
    specification can be in any of the following three forms:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: a proper list of variables, `(*var[1]* ... *var[n]*)`, such as we have already
    seen,
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a single variable, `*var[r]*`, or
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an improper list of variables, `(*var[1]* ... *var[n]* . *var[r]*)`.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first case, exactly *n* actual parameters must be supplied, and each
    variable is bound to the corresponding actual parameter. In the second, any number
    of actual parameters is valid; all of the actual parameters are put into a single
    list and the single variable is bound to this list. The third case is a hybrid
    of the first two cases. At least *n* actual parameters must be supplied. The variables
    `*var[1]* ... *var[n]*` are bound to the corresponding actual parameters, and
    the variable `*var[r]*` is bound to a list containing the remaining actual parameters.
    In the second and third cases, `*var[r]*` is sometimes referred to as a "rest"
    parameter because it holds the rest of the actual parameters beyond those that
    are individually named.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a few examples to help clarify the more general syntax of `lambda`
    expressions.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([f (lambda x x)])'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: (f 1 2 3 4)) ![<graphic>](ch2_0.gif) (1 2 3 4)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: (let ([f (lambda x x)])
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: (f)) ![<graphic>](ch2_0.gif) ()
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: (let ([g (lambda (x . y) (list x y))])
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: (g 1 2 3 4)) ![<graphic>](ch2_0.gif) (1 (2 3 4))
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: (let ([h (lambda (x y . z) (list x y z))])
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: (h 'a 'b 'c 'd)) ![<graphic>](ch2_0.gif) (a b (c d))`
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: In the first two examples, the procedure named `f` accepts any number of arguments.
    These arguments are automatically formed into a list to which the variable `x`
    is bound; the value of `f` is this list. In the first example, the arguments are
    1, 2, 3, and 4, so the answer is `(1 2 3 4)`. In the second, there are no arguments,
    so the answer is the empty list `()`. The value of the procedure named `g` in
    the third example is a list whose first element is the first argument and whose
    second element is a list containing the remaining arguments. The procedure named
    `h` is similar but separates out the second argument. While `f` accepts any number
    of arguments, `g` must receive at least one and `h` must receive at least two.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.5.1
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Determine the values of the expressions below.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '| *  a*. | `(let ([f (lambda (x) x)])   (f ''a))` |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
- en: '| *  b*. | `(let ([f (lambda x x)])   (f ''a))` |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: '| *  c*. | `(let ([f (lambda (x . y) x)])   (f ''a))` |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
- en: '| *  d*. | `(let ([f (lambda (x . y) y)])   (f ''a))` |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: Exercise 2.5.2
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How might the primitive procedure `list` be defined?
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.5.3
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: List the variables that occur free in each of the `lambda` expressions below.
    Do not omit variables that name primitive procedures such as `+` or `cons`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '| *  a*. | `(lambda (f x) (f x))` |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
- en: '| *  b*. | `(lambda (x) (+ x x))` |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
- en: '| *  c*. | `(lambda (x y) (f x y))` |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
- en: '| *  d*. | `(lambda (x)   (cons x (f x y)))` |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
- en: '| *  e*. | `(lambda (x)   (let ([z (cons x y)])'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: (x y z)))` |
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '| *  f*. | `(lambda (x)   (let ([y (cons x y)])'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: (x y z)))` |
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Section 2.6\. Top-Level Definitions
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The variables bound by `let` and `lambda` expressions are not visible outside
    the bodies of these expressions. Suppose you have created an object, perhaps a
    procedure, that must be accessible anywhere, like `+` or `cons`. What you need
    is a *top-level definition*, which may be established with `define`. Top-level
    definitions, which are supported by most interactive Scheme systems, are visible
    in every expression you enter, except where shadowed by another binding.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Let's establish a top-level definition of the `double-any` procedure of the
    last section.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '`(define double-any'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (f x)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: (f x x)))`
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: The variable `double-any` now has the same status as `cons` or the name of any
    other primitive procedure. We can use `double-any` as if it were a primitive procedure.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '`(double-any + 10) ![<graphic>](ch2_0.gif) 20'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: (double-any cons 'a) ![<graphic>](ch2_0.gif) (a . a)`
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: A top-level definition may be established for any object, not just for procedures.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '`(define sandwich "peanut-butter-and-jelly")'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: sandwich ![<graphic>](ch2_0.gif) "peanut-butter-and-jelly"`
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Most often, though, top-level definitions are used for procedures.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: As suggested above, top-level definitions may be shadowed by `let` or `lambda`
    bindings.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '`(define xyz ''(x y z))'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: (let ([xyz '(z y x)])
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: xyz) ![<graphic>](ch2_0.gif) (z y x)`
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Variables with top-level definitions act almost as if they were bound by a `let`
    expression enclosing all of the expressions you type.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Given only the simple tools you have read about up to this point, it is already
    possible to define some of the primitive procedures provided by Scheme and described
    later in this book. If you completed the exercises from the last section, you
    should already know how to define `list`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '`(define list (lambda x x))`'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Also, Scheme provides the abbreviations `cadr` and `cddr` for the compositions
    of `car` with `cdr` and `cdr` with `cdr`. That is, `(cadr *list*)` is equivalent
    to `(car (cdr *list*))`, and, similarly, `(cddr *list*)` is equivalent to `(cdr (cdr *list*))`.
    They are easily defined as follows.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '`(define cadr'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: (car (cdr x))))
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: (define cddr
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: (cdr (cdr x))))`
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '`(cadr ''(a b c)) ![<graphic>](ch2_0.gif) b'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: (cddr '(a b c)) ![<graphic>](ch2_0.gif) (c)`
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Any definition `(define *var* *expr*)` where `*expr*` is a `lambda` expression
    can be written in a shorter form that suppresses the `lambda`. The exact syntax
    depends upon the format of the `lambda` expression's formal parameter specifier,
    i.e., whether it is a proper list of variables, a single variable, or an improper
    list of variables. A definition of the form
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '`(define *var[0]*'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (*var[1]* ... *var[n]*)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '*e[1]* *e[2]* ...))`'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: may be abbreviated
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (*var[0]* *var[1]* ... *var[n]*)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '*e[1]* *e[2]* ...)`'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: while
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '`(define *var[0]*'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: (lambda *var[r]*
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '*e[1]* *e[2]* ...))`'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: may be abbreviated
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (*var[0]* . *var[r]*)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '*e[1]* *e[2]* ...)`'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: and
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '`(define *var[0]*'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (*var[1]* ... *var[n]* . *var[r]*)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '*e[1]* *e[2]* ...))`'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: may be abbreviated
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (*var[0]* *var[1]* ... *var[n]* . *var[r]*)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '*e[1]* *e[2]* ...)`'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: For example, the definitions of `cadr` and `list` might be written as follows.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (cadr x)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: (car (cdr x)))
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: (define (list . x) x)`
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: This book does not often employ this alternative syntax. Although it is shorter,
    it tends to mask the reality that procedures are not intimately tied to variables,
    or names, as they are in many other languages. This syntax is often referred to,
    somewhat pejoratively, as the "defun" syntax for `define`, after the `defun` form
    provided by Lisp languages in which procedures are more closely tied to their
    names.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Top-level definitions make it easier for us to experiment with a procedure interactively
    because we need not retype the procedure each time it is used. Let's try defining
    a somewhat more complicated variation of `double-any`, one that turns an "ordinary"
    two-argument procedure into a "doubling" one-argument procedure.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '`(define doubler'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (f)
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x) (f x x))))`
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '`doubler` accepts one argument, `f`, which must be a procedure that accepts
    two arguments. The procedure returned by `doubler` accepts one argument, which
    it uses for both arguments in an application of `f`. We can define, with `doubler`,
    the simple `double` and `double-cons` procedures of the last section.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '`(define double (doubler +))'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: (double 13/2) ![<graphic>](ch2_0.gif) 13
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: (define double-cons (doubler cons))
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: (double-cons 'a) ![<graphic>](ch2_0.gif) (a . a)`
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: We can also define `double-any` with `doubler`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '`(define double-any'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (f x)
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: ((doubler f) x)))`
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Within `double` and `double-cons`, `f` has the appropriate value, i.e., `+`
    or `cons`, even though the procedures are clearly applied outside the scope of
    `f`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: What happens if you attempt to use a variable that is not bound by a `let` or
    `lambda` expression and that does not have a top-level definition? Try using the
    variable `i-am-not-defined` to see what happens.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '`(i-am-not-defined 3)`'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Most Scheme systems print a message indicating that an unbound- or undefined-variable
    exception has occurred.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: The system should not, however, complain about the appearance of an undefined
    variable within a `lambda` expression, until and unless the resulting procedure
    is applied. The following should *not* cause an exception, even though we have
    not yet established a top-level definition of `proc2`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '`(define proc1'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y)
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: (proc2 y x)))`
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: If you try to apply `proc1` before defining `proc2`, you should get a undefined
    exception message. Let's give `proc2` a top-level definition and try `proc1`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '`(define proc2 cons)'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: (proc1 'a 'b) ![<graphic>](ch2_0.gif) (b . a)`
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: When you define `proc1`, the system accepts your promise to define `proc2`,
    and does not complain unless you use `proc1` before defining `proc2`. This allows
    you to define procedures in any order you please. This is especially useful when
    you are trying to organize a file full of procedure definitions in a way that
    makes your program more readable. It is necessary when two procedures defined
    at top level depend upon each other; we will see some examples of this later.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.6.1
  id: totrans-414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What would happen if you were to type
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '`(double-any double-any double-any)`'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: given the definition of `double-any` from the beginning of this section?
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.6.2
  id: totrans-418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A more elegant (though possibly less efficient) way to define `cadr` and `cddr`
    than given in this section is to define a procedure that composes two procedures
    to create a third. Write the procedure `compose`, such that `(compose *p[1]* *p[2]*)`
    is the composition of `*p[1]*` and `*p[2]*` (assuming both take one argument).
    That is, `(compose *p[1]* *p[2]*)` should return a new procedure of one argument
    that applies `*p[1]*` to the result of applying `*p[2]*` to the argument. Use
    `compose` to define `cadr` and `cddr`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.6.3
  id: totrans-420
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Scheme also provides `caar`, `cdar`, `caaar`, `caadr`, and so on, with any combination
    of up to four `a`'s (representing `car`) and `d`'s (representing `cdr`) between
    the `c` and the `r` (see Section [6.3](objects.html#g109)). Define each of these
    with the `compose` procedure of the preceding exercise.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Section 2.7\. Conditional Expressions
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far we have considered expressions that perform a given task unconditionally.
    Suppose that we wish to write the procedure `abs`. If its argument *x* is negative,
    `abs` returns -*x*; otherwise, it returns *x*. The most straightforward way to
    write `abs` is to determine whether the argument is negative and if so negate
    it, using the `if` syntactic form.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '`(define abs'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: (if (< n 0)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: (- 0 n)
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: n)))
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: (abs 77) ![<graphic>](ch2_0.gif) 77
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: (abs -77) ![<graphic>](ch2_0.gif) 77`
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: An `if` expression has the form `(if *test* *consequent* *alternative*)`, where
    `*consequent*` is the expression to evaluate if `*test*` is true and `*alternative*`
    is the expression to evaluate if `*test*` is false. In the expression above, `*test*`
    is `(< n 0)`, `*consequent*` is `(- 0 n)`, and `*alternative*` is `n`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `abs` could be written in a variety of other ways. Any of the
    following are valid definitions of `abs`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '`(define abs'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: (if (>= n 0)
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: n
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: (- 0 n))))
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: (define abs
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: (if (not (< n 0))
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: n
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: (- 0 n))))
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: (define abs
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: (if (or (> n 0) (= n 0))
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: n
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: (- 0 n))))
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: (define abs
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: (if (= n 0)
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: (if (< n 0)
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: (- 0 n)
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: n))))
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: (define abs
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: ((if (>= n 0) + -)
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: n)))`
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: The first of these definitions asks if `n` is greater than or equal to zero,
    inverting the test. The second asks if `n` is not less than zero, using the procedure
    `not` with `<`. The third asks if `n` is greater than zero or `n` is equal to
    zero, using the syntactic form `or`. The fourth treats zero separately, though
    there is no benefit in doing so. The fifth is somewhat tricky; `n` is either added
    to or subtracted from zero, depending upon whether `n` is greater than or equal
    to zero.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Why is `if` a syntactic form and not a procedure? In order to answer this, let's
    revisit the definition of `reciprocal` from the first section of this chapter.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '`(define reciprocal'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: (if (= n 0)
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '"oops!"'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: (/ 1 n))))`
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: The second argument to the division procedure should not be zero, since the
    result is mathematically undefined. Our definition of `reciprocal` avoids this
    problem by testing for zero before dividing. Were `if` a procedure, its arguments
    (including `(/ 1 n)`) would be evaluated before it had a chance to choose between
    the consequent and alternative. Like `quote`, which does not evaluate its only
    subexpression, `if` does not evaluate all of its subexpressions and so cannot
    be a procedure.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: The syntactic form `or` operates in a manner similar to `if`. The general form
    of an `or` expression is `(or *expr* ...)`. If there are no subexpressions, i.e.,
    the expression is simply `(or)`, the value is false. Otherwise, each `*expr*`
    is evaluated in turn until either (a) one of the expressions evaluates to true
    or (b) no more expressions are left. In case (a), the value is true; in case (b),
    the value is false.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: To be more precise, in case (a), the value of the `or` expression is the value
    of the last subexpression evaluated. This clarification is necessary because there
    are many possible true values. Usually, the value of a test expression is one
    of the two objects `#t`, for true, or `#f`, for false.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '`(< -1 0) ![<graphic>](ch2_0.gif) #t'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: (> -1 0) ![<graphic>](ch2_0.gif) #f`
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Every Scheme object, however, is considered to be either true or false by conditional
    expressions and by the procedure `not`. Only `#f` is considered false; all other
    objects are considered true.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '`(if #t ''true ''false) ![<graphic>](ch2_0.gif) true'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: (if #f 'true 'false) ![<graphic>](ch2_0.gif) false
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: (if '() 'true 'false) ![<graphic>](ch2_0.gif) true
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: (if 1 'true 'false) ![<graphic>](ch2_0.gif) true
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: (if '(a b c) 'true 'false) ![<graphic>](ch2_0.gif) true
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: (not #t) ![<graphic>](ch2_0.gif) #f
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: (not "false") ![<graphic>](ch2_0.gif) #f
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: (not #f) ![<graphic>](ch2_0.gif) #t
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: (or) ![<graphic>](ch2_0.gif) #f
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: (or #f) ![<graphic>](ch2_0.gif) #f
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: (or #f #t) ![<graphic>](ch2_0.gif) #t
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: (or #f 'a #f) ![<graphic>](ch2_0.gif) a`
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: The `and` syntactic form is similar in form to `or`, but an `and` expression
    is true if all its subexpressions are true, and false otherwise. In the case where
    there are no subexpressions, i.e., the expression is simply `(and)`, the value
    is true. Otherwise, the subexpressions are evaluated in turn until either no more
    subexpressions are left or the value of a subexpression is false. The value of
    the `and` expression is the value of the last subexpression evaluated.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Using `and`, we can define a slightly different version of `reciprocal`.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '`(define reciprocal'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: (and (not (= n 0))
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: (/ 1 n))))
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal 3) ![<graphic>](ch2_0.gif) 1/3
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal 0.5) ![<graphic>](ch2_0.gif) 2.0
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal 0) ![<graphic>](ch2_0.gif) #f`
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: In this version, the value is `#f` if `n` is zero and `1/n` otherwise.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: The procedures `=`, `<`, `>`, `<=`, and `>=` are called *predicates*. A predicate
    is a procedure that answers a specific question about its arguments and returns
    one of the two values `#t` or `#f`. The names of most predicates end with a question
    mark ( `?` ); the common numeric procedures listed above are exceptions to this
    rule. Not all predicates require numeric arguments, of course. The predicate `null?`
    returns true if its argument is the empty list `()` and false otherwise.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '`(null? ''()) ![<graphic>](ch2_0.gif) #t'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: (null? 'abc) ![<graphic>](ch2_0.gif) #f
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: (null? '(x y z)) ![<graphic>](ch2_0.gif) #f
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: (null? (cdddr '(x y z))) ![<graphic>](ch2_0.gif) #t`
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `cdr` must not be passed anything other than a pair, and an exception
    is raised when this happens. Common Lisp, however, defines `(cdr '())` to be `()`.
    The following procedure, `lisp-cdr`, is defined using `null?` to return `()` if
    its argument is `()`.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '`(define lisp-cdr'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? x)
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '''()'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: (cdr x))))
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: (lisp-cdr '(a b c)) ![<graphic>](ch2_0.gif) (b c)
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: (lisp-cdr '(c)) ![<graphic>](ch2_0.gif) ()
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: (lisp-cdr '()) ![<graphic>](ch2_0.gif) ()`
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Another useful predicate is `eqv?`, which requires two arguments. If the two
    arguments are equivalent, `eqv?` returns true. Otherwise, `eqv?` returns false.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '`(eqv? ''a ''a) ![<graphic>](ch2_0.gif) #t'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? 'a 'b) ![<graphic>](ch2_0.gif) #f
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? #f #f) ![<graphic>](ch2_0.gif) #t
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? #t #t) ![<graphic>](ch2_0.gif) #t
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? #f #t) ![<graphic>](ch2_0.gif) #f
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? 3 3) ![<graphic>](ch2_0.gif) #t
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? 3 2) ![<graphic>](ch2_0.gif) #f
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x "Hi Mom!"])
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? x x)) ![<graphic>](ch2_0.gif) #t
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x (cons 'a 'b)])
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? x x)) ![<graphic>](ch2_0.gif) #t
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: (eqv? (cons 'a 'b) (cons 'a 'b)) ![<graphic>](ch2_0.gif) #f`
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `eqv?` returns true if the arguments are the same symbol, boolean,
    number, pair, or string. Two pairs are not the same by `eqv?` if they are created
    by different calls to `cons`, even if they have the same contents. Detailed equivalence
    rules for `eqv?` are given in Section [6.2](objects.html#g108).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Scheme also provides a set of *type predicates* that return true or false depending
    on the type of the object, e.g., `pair?`, `symbol?`, `number?`, and `string?`.
    The predicate `pair?`, for example, returns true only if its argument is a pair.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '`(pair? ''(a . c)) ![<graphic>](ch2_0.gif) #t'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: (pair? '(a b c)) ![<graphic>](ch2_0.gif) #t
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: (pair? '()) ![<graphic>](ch2_0.gif) #f
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: (pair? 'abc) ![<graphic>](ch2_0.gif) #f
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: (pair? "Hi Mom!") ![<graphic>](ch2_0.gif) #f
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: (pair? 1234567890) ![<graphic>](ch2_0.gif) #f`
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Type predicates are useful for deciding if the argument passed to a procedure
    is of the appropriate type. For example, the following version of `reciprocal`
    checks first to see that its argument is a number before testing against zero
    or performing the division.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '`(define reciprocal'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: (if (and (number? n) (not (= n 0)))
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: (/ 1 n)
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '"oops!")))'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal 2/3) ![<graphic>](ch2_0.gif) 3/2
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal 'a) ![<graphic>](ch2_0.gif) "oops!"`
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: By the way, the code that uses `reciprocal` must check to see that the returned
    value is a number and not a string. To relieve the caller of this obligation,
    it is usually preferable to report the error, using `assertion-violation`, as
    follows.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '`(define reciprocal'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: (if (and (number? n) (not (= n 0)))
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: (/ 1 n)
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: (assertion-violation 'reciprocal
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '"improper argument"'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: n))))
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal .25) ![<graphic>](ch2_0.gif) 4.0
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal 0) ![<graphic>](ch2_0.gif) *exception in reciprocal: improper argument 0*
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: (reciprocal 'a) ![<graphic>](ch2_0.gif) *exception in reciprocal: improper argument a*`
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to `assertion-violation` is a symbol identifying where the
    message originates, the second is a string describing the error, and the third
    and subsequent arguments are "irritants" to be included with the error message.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at one more conditional expression, `cond`, that is often useful
    in place of `if`. `cond` is similar to `if` except that it allows multiple test
    and alternative expressions. Consider the following definition of `sign`, which
    returns `-1` for negative inputs, `+1` for positive inputs, and `0` for zero.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '`(define sign'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: (if (< n 0)
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '-1'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: (if (> n 0)
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '+1'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 0))))`
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '`(sign -88.3) ![<graphic>](ch2_0.gif) -1'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: (sign 0) ![<graphic>](ch2_0.gif) 0
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: (sign 333333333333) ![<graphic>](ch2_0.gif) 1
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: (* (sign -88.3) (abs -88.3)) ![<graphic>](ch2_0.gif) -88.3`
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: The two `if` expressions may be replaced by a single `cond` expression as follows.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '`(define sign'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '[(< n 0) -1]'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '[(> n 0) +1]'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '[else 0])))`'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: A `cond` expression usually takes the form
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '`(cond (*test* *expr*) ... (else *expr*))`'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: though the `else` clause may be omitted. This should be done only when there
    is no possibility that all the tests will fail, as in the new version of `sign`
    below.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '`(define sign'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '[(< n 0) -1]'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '[(> n 0) +1]'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '[(= n 0) 0])))`'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: These definitions of `sign` do not depend on the order in which the tests are
    performed, since only one of the tests can be true for any value of `n`. The following
    procedure computes the tax on a given amount of income in a progressive tax system
    with breakpoints at 10,000, 20,000, and 30,000 dollars.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '`(define income-tax'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (income)
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '[(<= income 10000) (* income .05)]'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '[(<= income 20000) (+ (* (- income 10000) .08) 500.00)]'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '[(<= income 30000) (+ (* (- income 20000) .13) 1300.00)]'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[else (+ (* (- income 30000) .21) 2600.00)])))`'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '`(income-tax 5000) ![<graphic>](ch2_0.gif) 250.0'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: (income-tax 15000) ![<graphic>](ch2_0.gif) 900.0
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: (income-tax 25000) ![<graphic>](ch2_0.gif) 1950.0
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: (income-tax 50000) ![<graphic>](ch2_0.gif) 6800.0`
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the order in which the tests are performed, left to right (top
    to bottom), is significant.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.7.1
  id: totrans-591
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Define the predicate `atom?`, which returns true if its argument is not a pair
    and false if it is.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.7.2
  id: totrans-593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The procedure `length` returns the length of its argument, which must be a list.
    For example, `(length '(a b c))` is 3. Using `length`, define the procedure `shorter`,
    which returns the shorter of two list arguments. Have it return the first list
    if they have the same length.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '`(shorter ''(a b) ''(c d e)) ![<graphic>](ch2_0.gif) (a b)'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: (shorter '(a b) '(c d)) ![<graphic>](ch2_0.gif) (a b)
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: (shorter '(a b) '(c)) ![<graphic>](ch2_0.gif) (c)`
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: Section 2.8\. Simple Recursion
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have seen how we can control whether or not expressions are evaluated with
    `if`, `and`, `or`, and `cond`. We can also perform an expression more than once
    by creating a procedure containing the expression and invoking the procedure more
    than once. What if we need to perform some expression repeatedly, say for all
    the elements of a list or all the numbers from one to ten? We can do so via recursion.
    Recursion is a simple concept: the application of a procedure from within that
    procedure. It can be tricky to master recursion at first, but once mastered it
    provides expressive power far beyond ordinary looping constructs.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: A *recursive procedure* is a procedure that applies itself. Perhaps the simplest
    recursive procedure is the following, which we will call `goodbye`.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '`(define goodbye'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: (goodbye)))
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: (goodbye) ![<graphic>](ch2_0.gif)`
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: This procedure takes no arguments and simply applies itself immediately. There
    is no value after the ![<graphic>](ch2_0.gif) because `goodbye` never returns.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, to make practical use out of a recursive procedure, we must have
    some way to terminate the recursion. Most recursive procedures should have at
    least two basic elements, a *base case* and a *recursion step*. The base case
    terminates the recursion, giving the value of the procedure for some base argument.
    The recursion step gives the value in terms of the value of the procedure applied
    to a different argument. In order for the recursion to terminate, the different
    argument must be closer to the base argument in some way.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider the problem of finding the length of a proper list recursively.
    We need a base case and a recursion step. The logical base argument for recursion
    on lists is nearly always the empty list. The length of the empty list is zero,
    so the base case should give the value zero for the empty list. In order to become
    closer to the empty list, the natural recursion step involves the cdr of the argument.
    A nonempty list is one element longer than its cdr, so the recursion step gives
    the value as one more than the length of the cdr of the list.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '`(define length'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: (+ (length (cdr ls)) 1))))`
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '`(length ''()) ![<graphic>](ch2_0.gif) 0'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: (length '(a)) ![<graphic>](ch2_0.gif) 1
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: (length '(a b)) ![<graphic>](ch2_0.gif) 2`
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: The `if` expression asks if the list is empty. If so, the value is zero. This
    is the base case. If not, the value is one more than the length of the cdr of
    the list. This is the recursion step.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: 'Many Scheme implementations allow you to trace the execution of a procedure
    to see how it operates. In Chez Scheme, for example, one way to trace a procedure
    is to type `(trace *name*)`, where `*name*` is the name of a procedure you have
    defined at top level. If you trace `length` as defined above and pass it the argument
    `''(a b c d)`, you should see something like this:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '`|(length (a b c d))'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '| (length (b c d))'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '| |(length (c d))'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '| | (length (d))'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '| | |(length ())'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: '| | |0'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '| | 1'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '| |2'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '| 3'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '|4`'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: The indentation shows the nesting level of the recursion; the vertical lines
    associate applications visually with their values. Notice that on each application
    of `length` the list gets smaller until it finally reaches `()`. The value at
    `()` is 0, and each outer level adds 1 to arrive at the final value.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: Let's write a procedure, `list-copy`, that returns a copy of its argument, which
    must be a list. That is, `list-copy` returns a new list consisting of the elements
    (but not the pairs) of the old list. Making a copy might be useful if either the
    original list or the copy might be altered via `set-car!` or `set-cdr!`, which
    we discuss later.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '`(list-copy ''()) ![<graphic>](ch2_0.gif) ()'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: (list-copy '(a b c)) ![<graphic>](ch2_0.gif) (a b c)`
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: See if you can define `list-copy` before studying the definition below.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '`(define list-copy'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '''()'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: (cons (car ls)
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: (list-copy (cdr ls))))))`
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: The definition of `list-copy` is similar to the definition of `length`. The
    test in the base case is the same, `(null? ls)`. The value in the base case is
    `()`, however, not 0, because we are building up a list, not a number. The recursive
    call is the same, but instead of adding one, `list-copy` conses the car of the
    list onto the value of the recursive call.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: There is no reason why there cannot be more than one base case. The procedure
    `memv` takes two arguments, an object and a list. It returns the first sublist,
    or *tail*, of the list whose car is equal to the object, or `#f` if the object
    is not found in the list. The value of `memv` may be used as a list or as a truth
    value in a conditional expression.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '`(define memv'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x ls)
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '[(null? ls) #f]'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '[(eqv? (car ls) x) ls]'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '[else (memv x (cdr ls))])))`'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '`(memv ''a ''(a b b d)) ![<graphic>](ch2_0.gif) (a b b d)'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: (memv 'b '(a b b d)) ![<graphic>](ch2_0.gif) (b b d)
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: (memv 'c '(a b b d)) ![<graphic>](ch2_0.gif) #f
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: (memv 'd '(a b b d)) ![<graphic>](ch2_0.gif) (d)
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: (if (memv 'b '(a b b d))
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '"yes"'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '"no") ![<graphic>](ch2_0.gif) "yes"`'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: Here there are two conditions to check, hence the use of `cond`. The first cond
    clause checks for the base value of `()`; no object is a member of `()`, so the
    answer is `#f`. The second clause asks if the car of the list is the object, in
    which case the list is returned, being the first tail whose car contains the object.
    The recursion step just continues down the list.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: There may also be more than one recursion case. Like `memv`, the procedure `remv`
    defined below takes two arguments, an object and a list. It returns a new list
    with all occurrences of the object removed from the list.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: '`(define remv'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x ls)
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '[(null? ls) ''()]'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '[(eqv? (car ls) x) (remv x (cdr ls))]'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '[else (cons (car ls) (remv x (cdr ls)))])))`'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: '`(remv ''a ''(a b b d)) ![<graphic>](ch2_0.gif) (b b d)'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: (remv 'b '(a b b d)) ![<graphic>](ch2_0.gif) (a d)
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: (remv 'c '(a b b d)) ![<graphic>](ch2_0.gif) (a b b d)
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: (remv 'd '(a b b d)) ![<graphic>](ch2_0.gif) (a b b)`
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: 'This definition is similar to the definition of `memv` above, except `remv`
    does not quit once it finds the element in the car of the list. Rather, it continues,
    simply ignoring the element. If the element is not found in the car of the list,
    `remv` does the same thing as `list-copy` above: it conses the car of the list
    onto the recursive value.'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: Up to now, the recursion has been only on the cdr of a list. It is sometimes
    useful, however, for a procedure to recur on the car as well as the cdr of the
    list. The procedure `tree-copy` defined below treats the structure of pairs as
    a tree rather than as a list, with the left subtree being the car of the pair
    and the right subtree being the cdr of the pair. It performs a similar operation
    to `list-copy`, building new pairs while leaving the elements (leaves) alone.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '`(define tree-copy'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (tr)
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: (if (not (pair? tr))
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: tr
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: (cons (tree-copy (car tr))
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: (tree-copy (cdr tr))))))`
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '`(tree-copy ''((a . b) . c)) ![<graphic>](ch2_0.gif) ((a . b) . c)`'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: The natural base argument for a tree structure is anything that is not a pair,
    since the recursion traverses pairs rather than lists. The recursive step in this
    case is *doubly recursive*, finding the value recursively for the car as well
    as the cdr of the argument.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: At this point, readers who are familiar with other languages that provide special
    iteration constructs, e.g., *while* or *for* loops, might wonder whether similar
    constructs are required in Scheme. Such constructs are unnecessary; iteration
    in Scheme is expressed more clearly and succinctly via recursion. Recursion is
    more general and eliminates the need for the variable assignments required by
    many other languages' iteration constructs, resulting in code that is more reliable
    and easier to follow. Some recursion is essentially iteration and executes as
    such; Section [3.2](further.html#g55) has more to say about this. Often, there
    is no need to make a distinction, however. Concentrate instead on writing clear,
    concise, and correct programs.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: Before we leave the topic of recursion, let's consider a special form of repetition
    called *mapping*. Consider the following procedure, `abs-all`, that takes a list
    of numbers as input and returns a list of their absolute values.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '`(define abs-all'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '''()'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: (cons (abs (car ls))
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: (abs-all (cdr ls))))))`
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '`(abs-all ''(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) (1 2 3 4 5 6)`'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: This procedure forms a new list from the input list by applying the procedure
    `abs` to each element. We say that `abs-all` *maps* `abs` over the input list
    to produce the output list. Mapping a procedure over a list is a fairly common
    thing to do, so Scheme provides the procedure `map`, which maps its first argument,
    a procedure, over its second, a list. We can use `map` to define `abs-all`.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '`(define abs-all'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: (map abs ls)))`
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: We really do not need `abs-all`, however, since the corresponding direct application
    of `map` is just as short and perhaps clearer.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '`(map abs ''(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) (1 2 3 4 5 6)`'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we can use `lambda` to create the procedure argument to `map`, e.g.,
    to square the elements of a list of numbers.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '`(map (lambda (x) (* x x))'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: '''(1 -3 -5 7)) ![<graphic>](ch2_0.gif) (1 9 25 49)`'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: We can map a multiple-argument procedure over multiple lists, as in the following
    example.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '`(map cons ''(a b c) ''(1 2 3)) ![<graphic>](ch2_0.gif) ((a . 1) (b . 2) (c . 3))`'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: The lists must be of the same length, and the procedure should accept as many
    arguments as there are lists. Each element of the output list is the result of
    applying the procedure to corresponding members of the input list.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the first definition of `abs-all` above, you should be able to derive,
    before studying it, the following definition of `map1`, a restricted version of
    `map` that maps a one-argument procedure over a single list.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: '`(define map1'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p ls)
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '''()'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: (cons (p (car ls))
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: (map1 p (cdr ls))))))`
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '`(map1 abs ''(1 -2 3 -4 5 -6)) ![<graphic>](ch2_0.gif) (1 2 3 4 5 6)`'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: All we have done is to replace the call to `abs` in `abs-all` with a call to
    the new parameter `p`. A definition of the more general `map` is given in Section [5.4](control.html#g100).
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.8.1
  id: totrans-706
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Describe what would happen if you switched the order of the arguments to `cons`
    in the definition of `tree-copy`.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.8.2
  id: totrans-708
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consult Section [6.3](objects.html#g109) for the description of `append` and
    define a two-argument version of it. What would happen if you switched the order
    of the arguments in the call to `append` within your definition of `append`?
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.8.3
  id: totrans-710
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Define the procedure `make-list`, which takes a nonnegative integer `*n*` and
    an object and returns a new list, `*n*` long, each element of which is the object.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '`(make-list 7 ''()) ![<graphic>](ch2_0.gif) (() () () () () () ())`'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '[*Hint*: The base test should be `(= *n* 0)`, and the recursion step should
    involve `(- *n* 1)`. Whereas `()` is the natural base case for recursion on lists,
    0 is the natural base case for recursion on nonnegative integers. Similarly, subtracting
    1 is the natural way to bring a nonnegative integer closer to 0.]'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.8.4
  id: totrans-714
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The procedures `list-ref` and `list-tail` return the *n*th element and *n*th
    tail of a list *ls*.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '`(list-ref ''(1 2 3 4) 0) ![<graphic>](ch2_0.gif) 1'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: (list-tail '(1 2 3 4) 0) ![<graphic>](ch2_0.gif) (1 2 3 4)
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: (list-ref '(a short (nested) list) 2) ![<graphic>](ch2_0.gif) (nested)
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: (list-tail '(a short (nested) list) 2) ![<graphic>](ch2_0.gif) ((nested) list)`
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: Define both procedures.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.8.5
  id: totrans-721
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Exercise [2.7.2](start.html#g31) had you use `length` in the definition of
    `shorter`, which returns the shorter of its two list arguments, or the first if
    the two have the same length. Write `shorter` without using `length`. [*Hint*:
    Define a recursive helper, `shorter?`, and use it in place of the length comparison.]'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.8.6
  id: totrans-723
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All of the recursive procedures shown so far have been directly recursive.
    That is, each procedure directly applies itself to a new argument. It is also
    possible to write two procedures that use each other, resulting in indirect recursion.
    Define the procedures `odd?` and `even?`, each in terms of the other. [*Hint*:
    What should each return when its argument is 0?]'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: '`(even? 17) ![<graphic>](ch2_0.gif) #f'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: (odd? 17) ![<graphic>](ch2_0.gif) #t`
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.8.7
  id: totrans-727
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use `map` to define a procedure, `transpose`, that takes a list of pairs and
    returns a pair of lists as follows.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: '`(transpose ''((a . 1) (b . 2) (c . 3))) ![<graphic>](ch2_0.gif) ((a b c) 1 2 3)`'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: '[*Hint*: `((a b c) 1 2 3)` is the same as `((a b c) . (1 2 3))`.]'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: Section 2.9\. Assignment
  id: totrans-731
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although many programs can be written without them, assignments to top-level
    variables or `let`-bound and `lambda`-bound variables are sometimes useful. Assignments
    do not create new bindings, as with `let` or `lambda`, but rather change the values
    of existing bindings. Assignments are performed with `set!`.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: '`(define abcde ''(a b c d e))'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: abcde ![<graphic>](ch2_0.gif) (a b c d e)
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: (set! abcde (cdr abcde))
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: abcde ![<graphic>](ch2_0.gif) (b c d e)
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: (let ([abcde '(a b c d e)])
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: (set! abcde (reverse abcde))
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: abcde) ![<graphic>](ch2_0.gif) (e d c b a)`
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: Many languages require the use of assignments to initialize local variables,
    separate from the declaration or binding of the variables. In Scheme, all local
    variables are given a value immediately upon binding. Besides making the separate
    assignment to initialize local variables unnecessary, it ensures that the programmer
    cannot forget to initialize them, a common source of errors in most languages.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: In fact, most of the assignments that are either necessary or convenient in
    other languages are both unnecessary and inconvenient in Scheme, since there is
    typically a clearer way to express the same algorithm without assignments. One
    common practice in some languages is to sequence expression evaluation with a
    series of assignments, as in the following procedure that finds the roots of a
    quadratic equation.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: '`(define quadratic-formula'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (a b c)
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: (let ([root1 0] [root2 0] [minusb 0] [radical 0] [divisor 0])
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: (set! minusb (- 0 b))
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: (set! radical (sqrt (- (* b b) (* 4 (* a c)))))
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: (set! divisor (* 2 a))
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: (set! root1 (/ (+ minusb radical) divisor))
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: (set! root2 (/ (- minusb radical) divisor))
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: (cons root1 root2))))`
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: The roots are computed according to the well-known quadratic formula,
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch2_4.gif)'
  id: totrans-752
  prefs: []
  type: TYPE_IMG
- en: which yields the solutions to the equation 0 = *ax*² + *bx* + *c*. The `let`
    expression in this definition is employed solely to establish the variable bindings,
    corresponding to the declarations required in other languages. The first three
    assignment expressions compute subpieces of the formula, namely -*b*, ![<graphic>](ch2_5.gif),
    and 2*a*. The last two assignment expressions compute the two roots in terms of
    the subpieces. A pair of the two roots is the value of `quadratic-formula`. For
    example, the two roots of 2*x*² - 4*x* - 6 are *x* = 3 and *x* = -1.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: '`(quadratic-formula 2 -4 -6) ![<graphic>](ch2_0.gif) (3 . -1)`'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: The definition above works, but it can be written more clearly without the assignments,
    as shown below.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: '`(define quadratic-formula'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (a b c)
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: (let ([minusb (- 0 b)]
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: '[radical (sqrt (- (* b b) (* 4 (* a c))))]'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: '[divisor (* 2 a)])'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: (let ([root1 (/ (+ minusb radical) divisor)]
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: '[root2 (/ (- minusb radical) divisor)])'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: (cons root1 root2)))))`
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: In this version, the `set!` expressions are gone, and we are left with essentially
    the same algorithm. By employing two `let` expressions, however, the definition
    makes clear the dependency of `root1` and `root2` on the values of `minusb`, `radical`,
    and `divisor`. Equally important, the `let` expressions make clear the *lack*
    of dependencies among `minusb`, `radical`, and `divisor` and between `root1` and
    `root2`.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: Assignments do have some uses in Scheme, otherwise the language would not support
    them. Consider the following version of `cons` that counts the number of times
    it is called, storing the count in a variable named `cons-count`. It uses `set!`
    to increment the count; there is no way to achieve the same behavior without assignments.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: '`(define kons-count 0)'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: (define kons
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y)
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: (set! kons-count (+ kons-count 1))
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: (cons x y)))
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: (kons 'a '(b c)) ![<graphic>](ch2_0.gif) (a b c)
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: kons-count ![<graphic>](ch2_0.gif) 1
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: (kons 'a (kons 'b (kons 'c '()))) ![<graphic>](ch2_0.gif) (a b c)
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: kons-count ![<graphic>](ch2_0.gif) 4`
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: 'Assignments are commonly used to implement procedures that must maintain some
    internal state. For example, suppose we would like to define a procedure that
    returns 0 the first time it is called, 1 the second time, 2 the third time, and
    so on indefinitely. We could write something similar to the definition of `cons-count`
    above:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: '`(define next 0)'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: (define count
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v next])
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: (set! next (+ next 1))
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: v)))
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: (count) ![<graphic>](ch2_0.gif) 0
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: (count) ![<graphic>](ch2_0.gif) 1`
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: 'This solution is somewhat undesirable in that the variable `next` is visible
    at top level even though it need not be. Since it is visible at top level, any
    code in the system can change its value, perhaps inadvertently affecting the behavior
    of `count` in a subtle way. We can solve this problem by `let`-binding `next`
    outside of the `lambda` expression:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '`(define count'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: (let ([next 0])
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v next])
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: (set! next (+ next 1))
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: v))))`
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: The latter solution also generalizes easily to provide multiple counters, each
    with its own local counter. The procedure `make-counter`, defined below, returns
    a new counting procedure each time it is called.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '`(define make-counter'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: (let ([next 0])
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v next])
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: (set! next (+ next 1))
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: v)))))`
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: Since `next` is bound inside of `make-counter` but outside of the procedure
    returned by `make-counter`, each procedure it returns maintains its own unique
    counter.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: '`(define count1 (make-counter))'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: (define count2 (make-counter))
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: (count1) ![<graphic>](ch2_0.gif) 0
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: (count2) ![<graphic>](ch2_0.gif) 0
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: (count1) ![<graphic>](ch2_0.gif) 1
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: (count1) ![<graphic>](ch2_0.gif) 2
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: (count2) ![<graphic>](ch2_0.gif) 1`
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: If a state variable must be shared by more than one procedure defined at top
    level, but we do not want the state variable to be visible at top level, we can
    use `let` to bind the variable and `set!` to make the procedures visible at top
    level.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: '`(define shhh #f)'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: (define tell #f)
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: (let ([secret 0])
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: (set! shhh
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (message)
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: (set! secret message)))
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: (set! tell
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: secret)))
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: (shhh "sally likes harry")
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: (tell) ![<graphic>](ch2_0.gif) "sally likes harry"
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: secret ![<graphic>](ch2_0.gif) *exception: variable secret is not bound*`
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: Variables must be defined before they can be assigned, so we define `shhh` and
    `tell` to be `#f` initially. (Any initial value would do.) We'll see this structure
    again in Section [3.5](further.html#g79) and a better way to structure code like
    this as a library in Section [3.6](further.html#g84).
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: Local state is sometimes useful for caching computed values or allowing a computation
    to be evaluated *lazily*, i.e., only once and only on demand. The procedure `lazy`
    below accepts a *thunk*, or zero-argument procedure, as an argument. Thunks are
    often used to "freeze" computations that must be delayed for some reason, which
    is exactly what we need to do in this situation. When passed a thunk `*t*`, `lazy`
    returns a new thunk that, when invoked, returns the value of invoking `*t*`. Once
    computed, the value is saved in a local variable so that the computation need
    not be performed again. A boolean flag is used to record whether `*t*` has been
    invoked and its value saved.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: '`(define lazy'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (t)
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: (let ([val #f] [flag #f])
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: (if (not flag)
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: (begin (set! val (t))
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: (set! flag #t)))
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: val))))`
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: The syntactic form `begin`, used here for the first time, evaluates its subexpressions
    in sequence from left to right and returns the value of the last subexpression,
    like the body of a `let` or `lambda` expression. We also see that the `*alternative*`
    subexpression of an `if` expression can be omitted. This should be done only when
    the value of the `if` is discarded, as it is in this case.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation is especially useful for values that require considerable time
    to compute. By delaying the evaluation, we might avoid computing the value altogether,
    and by saving the value, we avoid computing it more than once.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: The operation of `lazy` can best be illustrated by printing a message from within
    a thunk passed to `lazy`.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: '`(define p'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: (lazy (lambda ()
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: (display "Ouch!")
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: (newline)
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: '"got me")))`'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: The first time `p` is invoked, the message `Ouch!` is printed and the string
    `"got me"` is returned. Thereafter, `"got me"` is returned but the message is
    not printed. The procedures `display` and `newline` are the first examples of
    explicit input/output we have seen; `display` prints the string without quotation
    marks, and `newline` prints a newline character.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: 'To further illustrate the use of `set!`, let''s consider the implementation
    of stack objects whose internal workings are not visible on the outside. A stack
    object accepts one of four *messages*: `empty?`, which returns `#t` if the stack
    is empty; `push!`, which adds an object to the top of the stack; `top`, which
    returns the object on the top of the stack; and `pop!`, which removes the object
    on top of the stack. The procedure `make-stack` given below creates a new stack
    each time it is called in a manner similar to `make-counter`.'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: '`(define make-stack'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls '()])
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (msg . args)
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: '[(eqv? msg ''empty?) (null? ls)]'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: '[(eqv? msg ''push!) (set! ls (cons (car args) ls))]'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: '[(eqv? msg ''top) (car ls)]'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: '[(eqv? msg ''pop!) (set! ls (cdr ls))]'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: '[else "oops"])))))`'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: Each stack is stored as a list bound to the variable `ls`; `set!` is used to
    change this binding for `push!` and `pop!`. Notice that the argument list of the
    inner `lambda` expression uses the improper list syntax to bind `args` to a list
    of all arguments but the first. This is useful here because in the case of `empty?`,
    `top`, and `pop!` there is only one argument (the message), but in the case of
    `push!` there are two (the message and the object to push onto the stack).
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: '`(define stack1 (make-stack))'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: (define stack2 (make-stack))
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: (list (stack1 'empty?) (stack2 'empty?)) ![<graphic>](ch2_0.giff) (#t #t)
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: (stack1 'push! 'a)
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: (list (stack1 'empty?) (stack2 'empty?)) ![<graphic>](ch2_0.gif) (#f #t)
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: (stack1 'push! 'b)
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: (stack2 'push! 'c)
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: (stack1 'top) ![<graphic>](ch2_0.gif) b
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: (stack2 'top) ![<graphic>](ch2_0.gif) c
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: (stack1 'pop!)
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: (stack1 'top) ![<graphic>](ch2_0.gif) a
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: (list (stack1 'empty?) (stack2 'empty?)) ![<graphic>](ch2_0.gif) (#f #f)
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: (stack1 'pop!)
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: (list (stack1 'empty?) (stack2 'empty?)) ![<graphic>](ch2_0.gif) (#t #f)`
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: As with the counters created by `make-counter`, the state maintained by each
    stack object is directly accessible only within the object. Each reference or
    change to this state is made explicitly by the object itself. One important benefit
    is that we can change the internal structure of the stack, perhaps to use a vector
    (see Section [6.9](objects.html#g115)) instead of a list to hold the elements,
    without changing its external behavior. Because the behavior of the object is
    known abstractly (not operationally), it is known as an *abstract object*. See
    Section [12.8](examples.html#g193) for more about creating abstract objects.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: In addition to changing the values of variables, we can also change the values
    of the car and cdr fields of a pair, using the procedures `set-car!` and `set-cdr!`.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: '`(define p (list 1 2 3))'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: (set-car! (cdr p) 'two)
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: p ![<graphic>](ch2_0.gif) (1 two 3)
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! p '())
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: p ![<graphic>](ch2_0.gif) (1)`
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: We can use these operators to define a queue data type, which is like a stack
    except that new elements are added at one end and extracted from the other. The
    following queue implementation uses a *tconc* structure. A tconc consists of a
    nonempty list and a header. The header is a pair whose car points to the first
    pair (head) of the list and whose cdr points to the last pair (end) of the list.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch2_6.gif)'
  id: totrans-873
  prefs: []
  type: TYPE_IMG
- en: The last element of the list is a placeholder and not considered part of the
    queue.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: 'Four operations on queues are defined below: `make-queue`, which constructs
    a queue; `putq!`, which adds an element to the end of a queue; `getq`, which retrieves
    the element at the front of a queue; and `delq!`, which removes the element at
    the front of a queue.'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: '`(define make-queue'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: (let ([end (cons 'ignored '())])
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: (cons end end))))
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: (define putq!
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (q v)
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: (let ([end (cons 'ignored '())])
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: (set-car! (cdr q) v)
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! (cdr q) end)
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! q end))))
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: (define getq
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (q)
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: (car (car q))))
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: (define delq!
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (q)
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: (set-car! q (cdr (car q)))))`
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: All are simple operations except for `putq!`, which modifies the end pair to
    contain the new value and adds a new end pair.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: '`(define myq (make-queue))'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: (putq! myq 'a)
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: (putq! myq 'b)
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: (getq myq) ![<graphic>](ch2_0.gif) a
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: (delq! myq)
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: (getq myq) ![<graphic>](ch2_0.gif) b
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: (delq! myq)
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: (putq! myq 'c)
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: (putq! myq 'd)
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: (getq myq) ![<graphic>](ch2_0.gif) c
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: (delq! myq)
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: (getq myq) ![<graphic>](ch2_0.gif) d`
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.9.1
  id: totrans-905
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Modify `make-counter` to take two arguments: an initial value for the counter
    to use in place of 0 and an amount to increment the counter by each time.'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.9.2
  id: totrans-907
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Look up the description of `case` in Section [5.3](control.html#g99). Replace
    the `cond` expression in `make-stack` with an equivalent `case` expression. Add
    `mt?` as a second name for the `empty?` message.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.9.3
  id: totrans-909
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Modify the `stack` object to allow the two messages `ref` and `set!`. `(*stack* 'ref *i*)`
    should return the `*i*`th element from the top of the stack; `(*stack* 'ref 0)`
    should be equivalent to `(*stack* 'top)`. `(*stack* 'set! *i* *v*)` should change
    the `*i*`th element from the top of the stack to `*v*`.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: '`(define stack (make-stack))'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'push! 'a)
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'push! 'b)
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'push! 'c)
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'ref 0) ![<graphic>](ch2_0.gif) c
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'ref 2) ![<graphic>](ch2_0.gif) a
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'set! 1 'd)
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'ref 1) ![<graphic>](ch2_0.gif) d
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'top) ![<graphic>](ch2_0.gif) c
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'pop!)
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: (stack 'top) ![<graphic>](ch2_0.gif) d`
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: '[*Hint*: Use `list-ref` to implement `ref` and `list-tail` with `set-car!`
    to implement `set!`.]'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.9.4
  id: totrans-923
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Scheme supports *vectors* as well as lists. Like lists, vectors are aggregate
    objects that contain other objects. Unlike lists, vectors have a fixed size and
    are laid out in one flat block of memory, typically with a header containing the
    length of the vector, as in the ten-element vector below.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ch2_7.gif)'
  id: totrans-925
  prefs: []
  type: TYPE_IMG
- en: This makes vectors more suitable for applications needing fast access to any
    element of the aggregate but less suitable for applications needing data structures
    that grow and shrink as needed.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: Look up the basic vector operations in Section [6.9](objects.html#g115) and
    reimplement the `stack` object to use a vector instead of a list to hold the stack
    contents. Include the `ref` and `set!` messages of Exercise [2.9.3](start.html#g43).
    Have the new `make-stack` accept a size argument *n* and make the vector length
    *n*, but do not otherwise change the external (abstract) interface.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.9.5
  id: totrans-928
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Define a predicate, `emptyq?`, for determining if a queue is empty. Modify `getq`
    and `delq!` to raise an exception when an empty queue is found, using `assertion-violation`.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.9.6
  id: totrans-930
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the queue implementation, the last pair in the encapsulated list is a placeholder,
    i.e., it never holds anything useful. Recode the queue operators to avoid this
    wasted pair. Make sure that the series of queue operations given earlier works
    with the new implementation. Which implementation do you prefer?
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.9.7
  id: totrans-932
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using `set-cdr!`, it is possible to create *cyclic lists*. For example, the
    following expression evaluates to a list whose car is the symbol `a` and whose
    cdr is the list itself.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([ls (cons ''a ''())])'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! ls ls)
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: ls)`
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you enter the above expression during an interactive Scheme
    session? What will the implementation of `length` on page [42](start.html#defn:simplelength)
    do when given a cyclic list? What does the built-in `length` primitive do?
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.9.8
  id: totrans-938
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Define the predicate `list?`, which returns `#t` if its argument is a proper
    list and `#f` otherwise (see Section [6.3](objects.html#g109)). It should return
    `#f` for cyclic lists as well as for lists terminated by objects other than `()`.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: '`(list? ''()) ![<graphic>](ch2_0.gif) #t'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: (list? '(1 2 3)) ![<graphic>](ch2_0.gif) #t
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: (list? '(a . b)) ![<graphic>](ch2_0.gif) #f
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: (list? (let ([ls (cons 'a '())])
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! ls ls)
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: ls)) ![<graphic>](ch2_0.gif) #f`
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: 'First write a simplified version of `list?` that does not handle cyclic lists,
    then extend this to handle cyclic lists correctly. Revise your definition until
    you are satisfied that it is as clear and concise as possible. [*Hint*: Use the
    following "hare and tortoise" algorithm to detect cycles. Define a recursive help
    procedure of two arguments, the hare and the tortoise. Start both the hare and
    the tortoise at the beginning of the list. Have the hare advance by two cdrs each
    time the tortoise advances by one cdr. If the hare catches the tortoise, there
    must be a cycle.]'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
