- en: Enterprise Tic-Tac-Toe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise Tic-Tac-Toe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*UPDATE: [Slides and video from my talk on this topic](http://fsharpforfunandprofit.com/ettt/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*This post is one of series in I which I hope to close the gap between theory
    and practice in functional programming. I pick a small project and show you my
    thought processes as I go about designing and implementing it from beginning to
    end.*'
  prefs: []
  type: TYPE_NORMAL
- en: For the next project in this series of posts, I'm going to do a walkthrough
    of a Tic-Tac-Toe (aka Noughts and Crosses) implementation, written in a functional
    style.
  prefs: []
  type: TYPE_NORMAL
- en: '![tic-tac-toe](tic-tac-toe.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, to be clear, I'm not a games developer in any shape or form, so I won't
    be focused on performance or UX at all, just on the design process -- taking some
    requirements that we all know (I hope) and translating them to functional code.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, to be very clear, I'll deliberately be going a bit overboard on the
    design just to demonstrate what you can do. There will be no objects. Everything
    will be immutable, Everything will be [typed](designing-with-types.html). There
    will be [capability based security](capability-based-security.html), and more.
    Performance will *definitely* be taking a back seat. Luckily, Tic-Tac-Toe does
    not need to support a high frame rate!
  prefs: []
  type: TYPE_NORMAL
- en: In fact, I'm going to call this version "Enterprise Tic-Tac-Toe"!
  prefs: []
  type: TYPE_NORMAL
- en: 'Why? Well let''s look at what you need for "Enterprise":'
  prefs: []
  type: TYPE_NORMAL
- en: We need **separation of concerns** so that specialist teams can work on different
    parts of the code at the same time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need **a documented API** so that the different teams can work effectively
    in parallel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a **security model** to prevent unauthorized actions from occurring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need **well-documented code** so that the architect can ensure that the implementation
    matches the UML diagrams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need **auditing and logging** to ensure that the system is SOX compliant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need **scalability** to ensure that the system is ready for the challenges
    of rapid customer acquisition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Actually, those are the *stated* reasons, but we all know that this is not
    the whole story. The *real* reasons for an "enterprise design" become apparent
    when you talk to the people involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Development Manager:* "We need separation of concerns because the front-end
    team and back-end team hate each other and refuse to work in the same room."'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Front-end team:* "We need a documented API so that those dummies building
    the back-end won''t keep breaking our code on every commit."'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Back-end team:* "We need a security model because those idiots building the
    front-end will always find a way to do something stupid unless we constrain them."'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Maintenance team:* "We need well-documented code because we''re fed up of
    having to reverse engineer the hacked-up spaghetti being thrown at us."'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Testers and Operations:* "We need auditing and logging so that we can see
    what the effing system is doing inside."'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Everyone:* "We don''t really need scalability at all, but the CTO wants to
    us to be buzzword compliant."'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's true that there are already some wonderful "enterprise" projects out there,
    such as [Easy Plus in PHP](https://github.com/Herzult/SimplePHPEasyPlus) and [Fizz
    Buzz Enterprise Edition in Java](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition),
    but I hope that my own small contribution to this genre will be considered worthy.
  prefs: []
  type: TYPE_NORMAL
- en: Seriously, I hope that the code won't be quite as ~~bad~~ amusing as those other
    enterprise projects. In fact, I hope to demonstrate that you can have "enterprise"
    ready functional code which is still readable!
  prefs: []
  type: TYPE_NORMAL
- en: Designing the domain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '"Write the game such that someone unfamiliar with it could learn the rules
    by looking at the source code" -- [Raganwald](http://raganwald.com/)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As always, let''s use a type-first design. If you recall, this approach means
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: We start with types only -- no implementation code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every use-case or scenario corresponds to a function type, with one input and
    one output (which means I'll use tuples when multiple parameters are needed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We work mostly top-down and outside-in, but occasionally bottom up as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We ignore the UI for now. And there will be no events or observables in the
    design of the core domain. It will be purely functional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fact, an alternative title for this post might be **growing functional software,
    guided by types.**
  prefs: []
  type: TYPE_NORMAL
- en: As I have said before, I like to drive the design by working from the events
    that can happen, rather than the objects involved. I'm old school, so I call them
    use-cases, but I also like the [event-storming approach](http://ziobrando.blogspot.co.uk/2013/11/introducing-event-storming.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Either way, for the Tic-Tac-Toe "domain", we have three different "event-driven
    use-cases" (in this case, just various mouse clicks!) to think about:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player X moves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player O moves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the first: initialization. This is equivalent to a `new`-style
    constructor in an OO program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Tic-Tac-Toe, there are no configuration parameters needed, so the input
    would be "null" (aka `unit`) and the output would be a game ready to play, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, what is this `Game`? Since everything is immutable, the other scenarios
    are going to have to take an existing game as input, and return a slightly changed
    version of the game. So `Game` is not quite appropriate. How about `GameState`
    instead? A "player X moves" function will thus look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You'll see that I added `SomeOtherStuff` to the input parameters because there's
    *always* some other stuff! We'll worry about what the "other stuff" is later.
  prefs: []
  type: TYPE_NORMAL
- en: Ok, What should we do next? Should we look more deeply into the internals of
    `GameState`?
  prefs: []
  type: TYPE_NORMAL
- en: No. Let's stay high-level and do more "outside-in" style design. I like this
    approach in general because it allows me to focus on what's important and not
    get side-tracked by implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the move functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I said originally that we should have a function for each scenario. Which means
    we would have functions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For each player's move, we start with the current game state, plus some other
    input created by the player, and end up with a *new* game state.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that both functions look exactly the same and could be easily
    substituted for each other. To be honest, I don't trust the user interface to
    always call the right one -- or at least, it could be a potential issue.
  prefs: []
  type: TYPE_NORMAL
- en: One approach is to have only *one* function, rather than *two*. That way there's
    nothing to go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'But now we need to handle the two different input cases. How to do that? Easy!
    A discriminated union type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, to process a move, we just pass the user action along with the state,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So now there is only *one* function for the UI to call rather than two, and
    less to get wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is great where there is one user, because it documents all the
    things that they can do. For example, in other games, you might have a type like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: However in this situation, this way doesn't feel quite right. Since there are
    *two* players, what I want to do is give each player their own distinct function
    to call and not allow them to use the other player's function. This not only stops
    the user interface component from messing up, but also gives me my capability-based
    security!
  prefs: []
  type: TYPE_NORMAL
- en: 'But now we are back to the original problem: how can we tell the two functions
    apart?'
  prefs: []
  type: TYPE_NORMAL
- en: 'What I''ll do is to use types to distinguish them. We''ll make the `SomeOtherStuff`
    be *owned* by each player, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This way the two functions are distinct, and also PlayerO cannot call PlayerX's
    function without having some of PlayerX's `Stuff` as well. If this sound's complicated,
    stay tuned -- it's easier than it looks!
  prefs: []
  type: TYPE_NORMAL
- en: What is SomeOtherStuff?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is this mysterious `SomeOtherStuff`? In other words, what information do
    we need to make a move?
  prefs: []
  type: TYPE_NORMAL
- en: For most domains, there might quite a lot of stuff that needs to be passed in,
    and the stuff might vary based on the context and the state of the system.
  prefs: []
  type: TYPE_NORMAL
- en: But for Tic-Tac-Toe, it's easy, it's just the location on the grid where the
    player makes their mark. "Top Left", "Bottom Center", and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How should we define this position using a type?
  prefs: []
  type: TYPE_NORMAL
- en: 'The most obvious approach would be to use a 2-dimensional grid indexed by integers:
    `(1,1) (1,2) (1,3)`, etc. But I have to admit that I''m too lazy to write unit
    tests that deal with bounds-checking, nor can I ever remember which integer in
    the pair is the row and which the column. I want to write code that I don''t have
    to test!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, let''s define a type explicitly listing each position of horizontally
    and vertically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And then the position of a square in the grid (which I''m going to call a "cell")
    is just a pair of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we go back to the "move function" definitions, we now have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'which means: "to play a move, the input is a game state and a selected cell
    position, and the output is an updated game state".'
  prefs: []
  type: TYPE_NORMAL
- en: Both player X and player O can play the *same* cell position, so, as we said
    earlier, we need to make them distinct.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to do that by wrapping them in a [single case union](designing-with-types-single-case-dus.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And with that, our move functions now have different types and can''t be mixed
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What is the GameState?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's focus on the game state. What information do we need to represent
    the game completely between moves?
  prefs: []
  type: TYPE_NORMAL
- en: 'I think it is obvious that the only thing we need is a list of the cells, so
    we can define a game state like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: But now, what do we need to define a `Cell`?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the cell''s position. Second, whether the cell has an "X" or an "O"
    on it. We can therefore define a cell like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Designing the output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What about the output? What does the UI need to know in order to update itself?
  prefs: []
  type: TYPE_NORMAL
- en: One approach is just to pass the entire game state to the UI and let the UI
    redisplay the whole thing from scratch. Or perhaps, to be more efficient, the
    UI could cache the previous state and do a diff to decide what needs to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In more complicated applications, with thousands of cells, we can be more efficient
    and make the UI''s life easier by explicitly returning the cells that changed
    with each move, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since Tic-Tac-Toe is a tiny game, I'm going to keep it simple and just return
    the game state and *not* anything like `ChangedCells` as well.
  prefs: []
  type: TYPE_NORMAL
- en: But as I said at the beginning, I want the UI to be as dumb as possible! The
    UI should not have to "think" -- it should be given everything it needs to know
    by the backend, and to just follow instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it stands, the cells can be fetched directly from the `GameState`, but I''d
    rather that the UI did *not* know how `GameState` is defined. So let''s give the
    UI a function (`GetCells`, say) that can extract the cells from the `GameState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Another approach would be for `GetCells` to return all the cells pre-organized
    into a 2D grid -- that would make life even easier for the UI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: But now the game engine is assuming the UI is using a indexed grid. Just as
    the UI shouldn't know about the internals of the backend, the backend shouldn't
    make assumptions about how the UI works.
  prefs: []
  type: TYPE_NORMAL
- en: It's fair enough to allow the UI to share the same definition of `Cell` as the
    backend, so we can just give the UI a list of `Cell`s and let it display them
    in its own way.
  prefs: []
  type: TYPE_NORMAL
- en: Ok, the UI should have everything it needs to display the game now.
  prefs: []
  type: TYPE_NORMAL
- en: Review of the first version of the design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Great! Let''s look at what we''ve got so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that in order to make this code compile while hiding the implementation
    of `GameState`, I've used a generic exception class (`exn`) as a placeholder for
    the actual implementation of `GameState`. I could also have used `unit` or `string`
    instead, but `exn` is not likely to get mixed up with anything else, and will
    prevent it being accidentally overlooked later!
  prefs: []
  type: TYPE_NORMAL
- en: A note on tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just a reminder that in this design phase, I'm going to combine all the input
    parameters into a single tuple rather than treat them as separate parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that I''ll write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'rather than the more standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: I'm doing this just to make the input and output obvious. When it comes to the
    implementation, it's more than likely that we'll switch to the standard way, so
    that we can take advantage of the techniques in our functional toolbox such as
    partial application.
  prefs: []
  type: TYPE_NORMAL
- en: Doing a design walkthrough
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, with a rough design in place, I like to do a walkthrough as if
    it were being used for real. In a larger design, I might develop a small throwaway
    prototype, but in this case, the design is small enough that I can do it in my
    head.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s pretend that we are the UI and we are given the design above. We
    start by calling the initialization function to get a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Ok, so now we have a `GameState` and we are ready to display the initial grid.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the UI would create, say, a grid of empty buttons, associate
    a cell to each button, and then draw the cell in the "empty" state.
  prefs: []
  type: TYPE_NORMAL
- en: This is fine, because the UI doesn't have to think. We are explicitly giving
    the UI a list of all cells, and also making the initial cell state `Empty`, so
    the UI doesn't have to know which is the default state -- it just displays what
    it is given.
  prefs: []
  type: TYPE_NORMAL
- en: One thing though. Since there is no input needed to set up the game, *and* the
    game state is immutable, we will have exactly the same initial state for every
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore we don't need a function to create the initial game state, just a
    "constant" that gets reused for each game.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When does the game stop?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next in our walkthrough, let's play a move.
  prefs: []
  type: TYPE_NORMAL
- en: A player, "X" or "O", clicks on a cell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We combine the player and `CellPosition` into the appropriate type, such as
    a `PlayerXPos`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then pass that and the `GameState` into the appropriate `Move` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The output is a new `GameState`. The UI then calls `GetCells` to get the new
    cells. We loop through this list, update the display, and now we're ready to try
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent!
  prefs: []
  type: TYPE_NORMAL
- en: Umm... except for the bit about knowing when to stop.
  prefs: []
  type: TYPE_NORMAL
- en: As designed, This game will go on forever. We need to include something in the
    output of the move to let us know whether the game is over!
  prefs: []
  type: TYPE_NORMAL
- en: So let's create a `GameStatus` type to keep track of that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And we need to add it to the output of the move as well, so now we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So now we can keep playing moves repeatedly while `GameStatus` is `InProcess`
    and then stop.
  prefs: []
  type: TYPE_NORMAL
- en: The pseudocode for the UI would look like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: I think we've got everything we need to play a game now, so let's move on to
    error handling.
  prefs: []
  type: TYPE_NORMAL
- en: What kind of errors can happen?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we starting thinking about the internals of the game, let''s think about
    what kinds of errors the UI team could make when using this design:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Could the UI create an invalid `GameState` and corrupt the game?**'
  prefs: []
  type: TYPE_NORMAL
- en: No, because we are going to keep the internals of the game state hidden from
    the UI.
  prefs: []
  type: TYPE_NORMAL
- en: '**Could the UI pass in an invalid `CellPosition`?**'
  prefs: []
  type: TYPE_NORMAL
- en: No, because the horizontal and vertical components of `CellPosition` are restricted
    and therefore it cannot be created in an invalid state. No validation is needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Could the UI pass in a *valid* `CellPosition` but at the *wrong* time?**'
  prefs: []
  type: TYPE_NORMAL
- en: Ah, now you're talking! Yes -- that is totally possible. In the design we have
    so far, there is nothing stopping a player playing the same square twice!
  prefs: []
  type: TYPE_NORMAL
- en: '**Could the UI allow player X to play twice in a row?**'
  prefs: []
  type: TYPE_NORMAL
- en: Again, yes. Nothing in our design prevents this.
  prefs: []
  type: TYPE_NORMAL
- en: '**What about when the game has ended but the dumb UI forgets to check the `GameStatus`
    and doesn''t notice. Should the game logic still accept moves?**'
  prefs: []
  type: TYPE_NORMAL
- en: Of course not, but yet again our design fails to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The big question is: can we fix these three issues *in our design* without
    having to rely on special validation code in the implementation? That is, can
    we encode these rules into *types*.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point you might be thinking "why bother with all these types?"
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using types over validation code is that the types are part
    of the design, which means that business rules like these are self-documenting.
    On the other hand, validation code tends to be scattered around and buried in
    obscure classes, so it is hard to get a big picture of all the constraints.
  prefs: []
  type: TYPE_NORMAL
- en: In general then, I prefer to use types rather than code if I can.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing the rules through types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, can we encode these rules using types? The answer is yes!
  prefs: []
  type: TYPE_NORMAL
- en: To stop someone playing the same square twice we can change the game engine
    so that it outputs a list of valid moves. And then we can require that *only*
    items in this list are allowed to be played in the next turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do this, our move type will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And we can extend this approach to stop player X playing twice in a row too.
    Simply make the `ValidPositionsForNextMove` be a list of `PlayerOPos` rather than
    generic positions. Player X will not be able to play them!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This approach also means that when the game is over, there are *no valid moves*
    available. So the UI cannot just loop forever, it will be forced to stop and deal
    with the situation.
  prefs: []
  type: TYPE_NORMAL
- en: So now we have encoded all three rules into the type system -- no manual validation
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: Some refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's do some refactoring now.
  prefs: []
  type: TYPE_NORMAL
- en: First we have a couple of choice types with a case for Player X and another
    similar case for Player O.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s extract the players into their own type, and then we can parameterize
    the cases to make them look nicer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The second thing we can do is to note that we only need the valid moves in
    the `InProcess` case, not the `Won` or `Tie` cases, so let''s merge `GameStatus`
    and `ValidMovesForPlayer` into a single type called `MoveResult`, say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We've replaced the `InProcess` case with two new cases `PlayerXToMove` and `PlayerOToMove`,
    which I think is actually clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The move functions now look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: I could have had the new `GameState` returned as part of `MoveResult` as well,
    but I left it "outside" to make it clear that is not to be used by the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Also, leaving it outside will give us the option of writing helper code that
    will thread a game state through a series of calls for us. This is a more advanced
    technique, so I'm not going to discuss it in this post.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `InitialGameState` should also take advantage of the `MoveResult`
    to return the available moves for the first player. Since it has both a game state
    and a initial set of moves, let's just call it `NewGame` instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If the initial `MoveResult` is the `PlayerXToMove` case, then we have also constrained
    the UI so that only player X can move first. Again, this allows the UI to be ignorant
    of the rules.
  prefs: []
  type: TYPE_NORMAL
- en: Second recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So now here's the tweaked design we've got after doing the walkthrough.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re not quite done with the outside-in design yet. One question is yet to
    be resolved: how can we hide the implementation of `GameState` from the UI?'
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling shared and private types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In any design, we want to decouple the "interface" from the "implementation".
    In this case, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: A set of shared data structures and functions that are used by both the UI and
    the game engine. (`CellState`, `MoveResult`, `PlayerXPos`, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of private data structures and functions that should only be accessed
    by the game logic. (just `GameState` so far)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's obviously a good idea to keep these types separate. How should we do this?
  prefs: []
  type: TYPE_NORMAL
- en: 'In F#, the easiest way is to put them into separate modules, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: But if we want to keep the internals of the game logic private, what do we do
    with `GameState`? It's used by public functions such as `PlayerXMoves`, but we
    want to keep its structure secret. How can we do that?
  prefs: []
  type: TYPE_NORMAL
- en: Option 1 - put the public and private types in the same module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first choice might be to put the public and private types in the same module,
    and have this module be the "core" domain module that all other modules depend
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s some code that demonstrates what this approach would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: All the types are in one module.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the types, such as `CellState`, will be public by default. That's fine.
  prefs: []
  type: TYPE_NORMAL
- en: But you can see that some of the types, such as `InternalType`, have been marked
    private. That means that they cannot be used outside the module at all.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `GameState` is not private, but its constructor is, which means that
    it *can* be used outside the module, but because its constructor is private, new
    ones can't be created, which sounds like what we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might have appeared to solve the issue, but this approach often causes problems
    of its own. For starters, trying to keep the `public` and `private` qualifiers
    straight can cause annoying compiler errors, such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: And even if this weren't a problem, putting the "interface" and the "implementation"
    in the same file will generally end up creating extra complexity as the implementation
    gets larger.
  prefs: []
  type: TYPE_NORMAL
- en: Option 2 - representing `GameState` with an abstract base class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The object-oriented way of approaching this would be to represent `GameState`
    as an abstract base class or interface, and then have a particular implementation
    inherit from the abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: This allows all the shared types to reference the abstract class or interface
    safely, while any particular implementation is hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you might do this in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: But alas, there are problems with this approach too.
  prefs: []
  type: TYPE_NORMAL
- en: First, it's not very functional, is it? F# does support classes and interfaces
    for those situations when we need them, but we should really be able to find a
    more idiomatic functional solution than this!
  prefs: []
  type: TYPE_NORMAL
- en: Second, it's potentially not safe. The actual implementation would have to downcast
    `GameState` into the type it expects in order to get at the internal data. But
    if I had *two* implementations that inherited `GameState`, what's to stop me passing
    a game state from implementation B into a function that is expecting a game state
    from implementation A? Nothing! Chaos would ensue!
  prefs: []
  type: TYPE_NORMAL
- en: Note that in a pure OO model this situation could not happen because the `GameState`
    itself would have stateful methods instead of the pure functional API that we
    have here.
  prefs: []
  type: TYPE_NORMAL
- en: Option 3 - parameterize the implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s think about the requirements again: "The `GameState` is public but we
    don''t know what the implementation will be."'
  prefs: []
  type: TYPE_NORMAL
- en: When you rephrase it like this, the functional way of modeling this becomes
    clear, which is to use *generic parameters* (aka "parametric polymorphism").
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we make `GameState` a *generic type* which represents a particular
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the UI can work with the `GameState` type, but because the actual
    implementation type used is not known, the UI cannot accidentally "look inside"
    and extract any information, *even if the implementation type is public*.
  prefs: []
  type: TYPE_NORMAL
- en: This last point is important, so I'm going to say it again with another example.
    If I give you a object of type `List<T>` in C#, you can work with the list in
    many ways, but you cannot know what the `T` is, and so you can never accidentally
    write code that assumes that `T` is an `int` or a `string` or a `bool`. And this
    "hidden-ness" has got nothing to do with whether `T` is a public type or not.
  prefs: []
  type: TYPE_NORMAL
- en: If we do take this approach then we can allow the internals of the game state
    to be completely public, safe in the knowledge that the UI cannot use that information
    even if it wanted to!
  prefs: []
  type: TYPE_NORMAL
- en: So here's some code demonstrating this approach.
  prefs: []
  type: TYPE_NORMAL
- en: First the shared types, with `GameState<'T>` being the parameterized version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The types that don't use the game state are unchanged, but you can see that
    `PlayerXMoves<'T>` has been parameterized with the game state.
  prefs: []
  type: TYPE_NORMAL
- en: Adding generics like this can often cause cascading changes to many types, forcing
    them all to be parameterized. Dealing with all these generics is one reason why
    type inference is so helpful in practice!
  prefs: []
  type: TYPE_NORMAL
- en: Now for the types internal to the game logic. They can all be public now, because
    the UI won't be able to know about them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here''s what the implementation of a `playerXMoves` function might
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This function references a particular implementation, but can be passed into
    the UI code because it conforms to the `PlayerXMoves<'T>` type.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, by using generic parameters, we naturally enforce that the same
    implementation, say "GameStateA", is used throughout.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the game state created by `InitGame<GameStateA>` can *only*
    be passed to a `PlayerXMoves<GameStateA>` function which is parameterized on the
    *same* implementation type.
  prefs: []
  type: TYPE_NORMAL
- en: Glueing it all together with "dependency injection"
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, let's talk about how everything can be glued together.
  prefs: []
  type: TYPE_NORMAL
- en: The UI code will be designed to work with a *generic* implementation of `GameState`,
    and thus generic versions of the `newGame` and `move` functions.
  prefs: []
  type: TYPE_NORMAL
- en: But of course, at some point we need to get access to the `newGame` and `move`
    functions for a *specific* implementation. What's the best way to glue all this
    together?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is the functional equivalent of dependency injection. We will have
    an "application" or "program" component as a top-level layer that will construct
    an implementation and pass it to the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of what such code would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: The `GameImplementation` module exports specific implementations of `newGame`
    and the `move` functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `UserInterface` module exports a `TicTacToeForm` class that accepts these
    implementations in its constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Application` module glues everything together. It creates a `TicTacToeForm`
    and passes it the implementations exported from the `GameImplementation` module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s some code to demonstrate this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'A few notes on this code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, I'm using WinForms rather than WPF because it has Mono support and because
    it works without NuGet dependencies. If you want to use something better, check
    out [ETO.Forms](http://picoe.ca/2012/09/11/introducing-eto-forms-a-cross-platform-ui-for-net/).
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can see that I've explicitly added the type parameters to `TicTacToeForm<'T>`
    like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'I could have eliminated the type parameter for the form by doing something
    like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'or even:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'and let the compiler infer the types, but this often causes a "less generic"
    warning like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: By explicitly writing `TicTacToeForm<'T>`, this can be avoided, although it
    is ugly for sure.
  prefs: []
  type: TYPE_NORMAL
- en: Some more refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve got four different functions to export. That''s getting a bit much so
    let''s create a record to store them in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This acts both as a container to pass around functions, *and* as nice documentation
    of what functions are available in the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation now has to create an "api" object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'But the UI code simplifies as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Prototyping a minimal implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It seems like we're getting close to a final version. But let's do one more
    walkthrough to exercise the "dependency injection" design, this time writing some
    minimal code to test the interactions.
  prefs: []
  type: TYPE_NORMAL
- en: For example, here is some minimal code to implement the `newGame` and `playerXMoves`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `newGame` is just an game with no cells and no available moves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The minimal implementation of `move` is easy -- just return game over!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now let's create a minimal implementation of the UI. We won't draw anything
    or respond to clicks, just mock up some functions so that we can test the logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s my first attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I'm planning to use the standard Form event handling approach
    -- each cell will have a "clicked" event handler associated with it. How the control
    or pixel location is converted to a `CellPosition` is something I'm not going
    to worry about right now, so I've just hard-coded some dummy data.
  prefs: []
  type: TYPE_NORMAL
- en: I'm *not* going to be pure here and have a recursive loop. Instead, I'll keep
    the current `gameState` as a mutable which gets updated after each move.
  prefs: []
  type: TYPE_NORMAL
- en: But now we have got a tricky situation... What is the `gameState` when the game
    hasn't started yet? What should we initialize it to? Similarly, when the game
    is over, what should it be set to?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: One choice might be to use a `GameState option` but that seems like a hack,
    and it makes me think that we are failing to think of something.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we have a field to hold the result of the last move (`lastMoveResult`)
    so we can keep track of whose turn it is, or whether the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: But again, what should it be set to when the game hasn't started?
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a step back and look at all the states the user interface can be
    in -- not the state of the *game* itself, but the state of the *user interface*.
  prefs: []
  type: TYPE_NORMAL
- en: We start off in an "idle" state, with no game being played.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then the user starts the game, and we are "playing".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While each move is played, we stay in the "playing" state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the game is over, we show the win or lose message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We wait for the user to acknowledge the end-of-game message, then go back to
    idle again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, this is for the UI only, it has nothing to do with the internal game
    state.
  prefs: []
  type: TYPE_NORMAL
- en: So -- our solution to all problems! -- let's create a type to represent these
    states.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: But do we really need the `Won` and `Lost` states? Why don't we just go straight
    back to `Idle` when the game is over?
  prefs: []
  type: TYPE_NORMAL
- en: 'So now the type looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The nice thing about using a type like this is that we can easily store the
    data that we need for each state.
  prefs: []
  type: TYPE_NORMAL
- en: What data do we need to store in the `Idle` state? Nothing that I can think
    of.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What data do we need to store in the `Playing` state? Well, this would be a
    perfect place to keep track of the `gameState` and `lastMoveResult` that we were
    having problems with earlier. They're only needed when the game is being played,
    but not otherwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So our final version looks like this. We've had to add the `<'GameState>` to
    `UiState` because we don't know what the actual game state is.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: With this type now available, we no longer need to store the game state directly
    as a field in the class. Instead we store a mutable `UiState`, which is initialized
    to `Idle`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'When we start the game, we change the UI state to be `Playing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: And when we handle a click, we only do something if the uiState is in `Playing`
    mode, and then we have no trouble getting the `gameState` and `lastMoveResult`
    that we need, because it is stored as part of the data for that case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the last line of the `PlayerXToMove` case, you can see the global
    `uiState` field being updated with the new game state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: So where have we got to with this bit of prototyping?
  prefs: []
  type: TYPE_NORMAL
- en: It's pretty ugly, but it has served its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The goal was to quickly implement the UI to see if the design held up in use,
    and I think we can say that it did, because the design of the domain types and
    api has remained unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: We also understand the UI requirements a bit better, which is a bonus. I think
    we can stop now!
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete game, part 1: The design'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To finish off, I'll show the code for the complete game, including implementation
    and user interface.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to read this code, you can skip to the [questions and summary](#questions)
    below.
  prefs: []
  type: TYPE_NORMAL
- en: '*All the code shown is available on GitHub in [this gist](https://gist.github.com/swlaschin/3418b549bd222396da82).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with our final domain design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete game, part 2: The game logic implementation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, here's a complete implementation of the design which I will not discuss
    in detail. I hope that the comments are self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete game, part 3: A console based user interface'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: And to complete the implementation, here's the code for a console based user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously this part of the implementation is not pure! I'm writing to and reading
    from the console, duh. If you want to be extra good, it would be easy enough to
    convert this to a pure implementation using `IO` or similar.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I like to focus on the core domain logic being pure and I generally
    don't bother about the UI too much, but that's just me.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the application code that connects all the components together
    and launches the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Example game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s what the output of this game looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Oops! We promised we would add logging to make it enterprise-ready!
  prefs: []
  type: TYPE_NORMAL
- en: That's easy -- all we have to do is replace the api functions with equivalent
    functions that log the data we're interested in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, in a real system you'd replace it with a proper logging tool such
    as `log4net` and generate better output, but I think this demonstrates the idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to use this, all we have to do is change the top level application to transform
    the original api to a logged version of the api:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: And that's it. Logging done!
  prefs: []
  type: TYPE_NORMAL
- en: Oh, and remember that I originally had the initial state created as a function
    rather than as a constant?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: I changed to a constant early on in the design. But I'm regretting that now,
    because it means that I can't hook into the "init game" event and log it. If I
    do want to log the start of each game, I should really change it back to a function
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Question: You went to the trouble of hiding the internal structure of `GameState`,
    yet the `PlayerXPos` and `PlayerOPos` types are public. Why?**'
  prefs: []
  type: TYPE_NORMAL
- en: I forgot! And then laziness kept me from updating the code, since this is really
    just an exercise in design.
  prefs: []
  type: TYPE_NORMAL
- en: It's true that in the current design, a malicious user interface could construct
    a `PlayerXPos` and then play X when it is not player X's turn, or to play a position
    that has already been played.
  prefs: []
  type: TYPE_NORMAL
- en: You could prevent this by hiding the implementation of `PlayerXPos` in the same
    way as we did for game state, using a type parameter. And of course you'd have
    to tweak all the related classes too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a snippet of what that would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We'd also need a way for the UI to see if the `CellPosition` a user selected
    was valid. That is, given a `MoveResult` and the desired `CellPosition`, if the
    position *is* valid, return `Some` move, otherwise return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s getting kind of ugly now, though. That''s one problem with type-first
    design: the type parameters can get complicated!'
  prefs: []
  type: TYPE_NORMAL
- en: So it's a trade-off. How much do you use types to prevent accidental bugs without
    overwhelming the design?
  prefs: []
  type: TYPE_NORMAL
- en: In this case, I do think the `GameState` should be secret, as it is likely to
    change in the future and we want to ensure that the UI is not accidentally coupled
    to implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: For the move types though, (a) I don't see the implementation changing and (b)
    the consequence of a malicious UI action is not very high, so overall I don't
    mind having the implementation be public.
  prefs: []
  type: TYPE_NORMAL
- en: '*UPDATE 2015-02-16: In the [next post](enterprise-tic-tac-toe-2.html) I solve
    this problem in a more elegant way, and get rid of `GameState` as well!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Question: Why are you using that strange syntax for defining the `initGame`
    and `move` functions?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You mean, why I am defining the functions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'rather than in the "normal" way like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m doing this when I want to treat functions as values. Just as we might
    say "*x* is a value of type *int*" like this `x :int = ...`, I''m saying that
    "*playerXMoves* is a value of type *PlayerXMoves*" like this: `playerXMoves :
    PlayerXMoves = ...`. It''s just that in this case, the value is a function rather
    than a simple value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Doing it this way follows from the type-first approach: create a type, then
    implement things that conform to that type.'
  prefs: []
  type: TYPE_NORMAL
- en: Would I recommend doing this for normal code? Probably not!
  prefs: []
  type: TYPE_NORMAL
- en: I'm only doing this as part of an exploratory design process. Once the design
    stabilizes, I would tend to switch back to the normal way of doing things.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question: This seems like a lot of work. Isn''t this just [BDUF](https://en.wikipedia.org/wiki/Big_Design_Up_Front)
    under another guise?**'
  prefs: []
  type: TYPE_NORMAL
- en: This might seem like quite a long winded way of doing design, but in practice,
    it would probably not take very long. Certainly no longer than mocking up an exploratory
    prototype in another language.
  prefs: []
  type: TYPE_NORMAL
- en: We've gone through a number of quick iterations, using types to document the
    design, and using the REPL as a "executable spec checker" to make sure that it
    all works together properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'And at the end of all this, we now have a decent design with some nice properties:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a "API" that separates the UI from the core logic, so that work on
    each part can proceed in parallel if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The types act as documentation and will constrain the implementation in a way
    that UML diagrams could never do!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The design is encoded in types, so that ~~any~~ the inevitable changes that
    occur during development can be made with confidence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I think this whole process is actually pretty agile, once you get used to working
    this way.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question: Come on, would you *really* write Tic-Tac-Toe this way?**'
  prefs: []
  type: TYPE_NORMAL
- en: It depends. If it was just me, maybe not. :-)
  prefs: []
  type: TYPE_NORMAL
- en: But if it was a more complex system with different teams for the front-end and
    back-end, then I would certainly use a design-first approach like this. In cases
    like that, things like data-hiding and abstract interfaces are critical, and I
    think this approach delivers that.
  prefs: []
  type: TYPE_NORMAL
- en: '**Question: Why is the design so specific? It seems like none of it will be
    reusable at all. Why not?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, this code is full of very specific types: `Cell`, `GameState`, etc. And
    it''s true that none of it will be reusable.'
  prefs: []
  type: TYPE_NORMAL
- en: There is always a tension between a very domain-specific and non-reusable design,
    like this one, and an [abstract and reusable library](https://msdn.microsoft.com/en-us/library/ee353738.aspx)
    of things like lists and trees.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, you would start with low-level, reusable components and then compose
    them into larger more-specific ones (e.g. a DSL), from which you can build a application.
    (Tomas has a good post on [exactly this](http://tomasp.net/blog/2015/library-layers/index.html)).
  prefs: []
  type: TYPE_NORMAL
- en: The reasons why I did not do that here is that, first, I always like to start
    with very *concrete* designs. You can't even know what a good abstraction looks
    like until you have built something a few times.
  prefs: []
  type: TYPE_NORMAL
- en: We have separated the UI from the core logic, but going any further than that
    does not make sense to me right now. If I was going to build lots of other kinds
    of games that were similar to Tic-Tac-Toe, then some useful abstractions might
    become apparent.
  prefs: []
  type: TYPE_NORMAL
- en: Second, designs with concrete types are easier for non-experts to understand.
    I'd like to think that I could show these domain types to a non-programmer (e.g.
    a domain expert) and have them understand and comment sensibly on them. If they
    were more abstract, that would not be possible.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want a challenge, here are some exercises for you:'
  prefs: []
  type: TYPE_NORMAL
- en: The `playerXMoves` and `playerOMoves` functions have very similar code. How
    would you refactor them to reduce that?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do a security audit and think of all the ways that a malicious user or UI could
    corrupt the game using the current design. Then fix them!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post, we've seen how to design a system using mostly types, with the
    occasional code fragments to help us clarify issues.
  prefs: []
  type: TYPE_NORMAL
- en: It was definitely an exercise in design overkill but I hope that there are some
    ideas in there that might be applicable to real non-toy projects.
  prefs: []
  type: TYPE_NORMAL
- en: At the start, I claimed that this design would be "enterprise" ready. Is it?
  prefs: []
  type: TYPE_NORMAL
- en: We *do* have separation of concerns via the functions that are exported to the
    UI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We *do* have a well documented API. There are no magic numbers, the names of
    the types are self-documenting, and the list of functions exported is in one place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We *do* have a security model to prevent unauthorized actions from occurring.
    As it stands, it would be hard to accidentally mess up. And if we go the extra
    distance by parameterizing the move types as well, then it becomes really quite
    hard for the game to be corrupted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We *do* have well-documented code, I think. Even though this is "enterprise",
    the code is quite explicit in what it does. There are no wasted abstractions --
    no `AbstractSingletonProxyFactoryBean` to make fun of.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We *did* add auditing and logging easily, and in an elegant way after the fact,
    without interfering with the core design.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get *scalability* for free because there is no global session data. All we
    have to do is persist the game state in the browser (Or we could use MongoDb and
    be web scale).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is not a perfect design -- I can think of a number of ways to improve it
    -- but overall I'm quite happy with it, considering it was a straight brain-to-code
    dump.
  prefs: []
  type: TYPE_NORMAL
- en: What do you think? Let me know in the comments.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATE 2015-02-16: I ended up being unhappy with this design after all. In
    the [next post](enterprise-tic-tac-toe-2.html) I tell you why, and present a better
    design.**'
  prefs: []
  type: TYPE_NORMAL
- en: '*NOTE: The code for this post is available on GitHub in [this gist](https://gist.github.com/swlaschin/3418b549bd222396da82).*'
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise Tic-Tac-Toe, part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise Tic-Tac-Toe, part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*UPDATE: [Slides and video from my talk on this topic](http://fsharpforfunandprofit.com/ettt/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*This post is one of series in I which I hope to close the gap between theory
    and practice in functional programming. I pick a small project and show you my
    thought processes as I go about designing and implementing it from beginning to
    end.*'
  prefs: []
  type: TYPE_NORMAL
- en: In the [previous post](enterprise-tic-tac-toe.html), I did a design for a Tic-Tac-Toe
    (aka Noughts and Crosses) game.
  prefs: []
  type: TYPE_NORMAL
- en: It wasn't bad for a direct-to-code brain dump, but there were a couple of things
    that I wasn't happy with.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the more I thought about it, the more those little niggles became
    full-fledged annoyances, and I got unhappier and unhappier.
  prefs: []
  type: TYPE_NORMAL
- en: In this post, I'll explain why I was so unhappy, and how I arrived at a design
    that I am much more satisfied with.
  prefs: []
  type: TYPE_NORMAL
- en: The old design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To recap the previous post briefly, here is the old design:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a hidden `GameState` known only to the implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some functions that allow the players to move (`PlayerXMoves` and
    `PlayerOMoves`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UI (or other client) passes the game state into each move, and gets a updated
    game state back.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each move also returns a `MoveResult` which contains the game status (in process,
    won, tied), and if the game is still in process, whose turn it is, and what the
    available moves are.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: What's wrong with the old design?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So what's wrong with this design? Why was I so unhappy?
  prefs: []
  type: TYPE_NORMAL
- en: First, I was unhappy about the use of the `PlayerXPos` and `PlayerOPos` types.
    The idea was to wrap a `CellPosition` in a type so that it would be "owned" by
    a particular player. By doing this, and then having the valid moves be one of
    these types, I could prevent player X from playing twice, say. That is, after
    player X has moved, the valid moves for the next run would be wrapped in a `PlayerOPos`
    type so that only player O could use them.
  prefs: []
  type: TYPE_NORMAL
- en: The problem was that the `PlayerXPos` and `PlayerOPos` types are public, so
    that a malicious user could have forged one and played twice anyway!
  prefs: []
  type: TYPE_NORMAL
- en: Yes, these types could have been made private by parameterizing them like the
    game state, but the design would have become very ugly very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Second, even if the moves *were* made unforgeable, there's that game state floating
    about.
  prefs: []
  type: TYPE_NORMAL
- en: It's true that the game state internals are private, but a malicious user could
    have still caused problems by reusing a game state. For example, they could attempt
    to play one of the valid moves with a game state from a previous turn, or vice
    versa.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular case, it would not be dangerous, but in general it might
    be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: So, as you can see, this design was becoming a bit smelly to me, which was why
    I was becoming unhappy.
  prefs: []
  type: TYPE_NORMAL
- en: What's up with this malicious user?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why I am assuming that the user of the API will be so malicious -- forging fake
    moves and all that?
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that I use this as a design guideline. If a malicious user can
    do something I don't want, then the design is probably not good enough.
  prefs: []
  type: TYPE_NORMAL
- en: In my series on [capability based security](capability-based-security.html)
    I point out that by designing for the [Principle Of Least Authority](https://en.wikipedia.org/wiki/Principle_of_least_privilege)
    ("POLA"), you end up with a good design as a side-effect.
  prefs: []
  type: TYPE_NORMAL
- en: That is, if you design the most minimal interface that the caller needs, then
    you will both avoid accidental complexity (good design) and increase security
    (POLA).
  prefs: []
  type: TYPE_NORMAL
- en: 'I had a little tip in that post: **design for malicious callers and you will
    probably end up with more modular code**.'
  prefs: []
  type: TYPE_NORMAL
- en: I think I will follow my own advice and see where I end up!
  prefs: []
  type: TYPE_NORMAL
- en: Designing for POLA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, let's design for POLA -- let's give the user the minimal "capability" to
    do something and no more.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, I want to give the user the capability to mark a specific position
    with an "X" or "O".
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what I had before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The user is passing in the location (`PlayerXPos`) that they want to play.
  prefs: []
  type: TYPE_NORMAL
- en: But let's now take away the user's ability to choose the position. Why don't
    I give the user a function, a `MoveCapability` say, that has the position baked
    in?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In fact, why not bake the game state into the function too? That way a malicious
    user can't pass the wrong game state to me.
  prefs: []
  type: TYPE_NORMAL
- en: This means that there is no "input" at all now -- everything is baked in!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: But now we have to give the user a whole set of capabilities, one for each possible
    move they can make. Where do these capabilities come from?
  prefs: []
  type: TYPE_NORMAL
- en: Answer, the `MoveResult` of course! We'll change the `MoveResult` to return
    a list of capabilities rather than a list of positions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! I'm much happier with this approach.
  prefs: []
  type: TYPE_NORMAL
- en: And now that the `MoveCapability` contains the game state baked in, we don't
    need the game state to be in the output either!
  prefs: []
  type: TYPE_NORMAL
- en: 'So our move function has simplified dramatically and now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Look ma! No `'GameState` parameter! It's gone!
  prefs: []
  type: TYPE_NORMAL
- en: A quick walkthrough from the UI's point of view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So now let's pretend we are the UI, and let's attempt to use the new design.
  prefs: []
  type: TYPE_NORMAL
- en: First, assume that we have a list of available capabilities from the previous
    move.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, the user must pick one of the capabilities (e.g. squares) to play -- they
    can't just create any old cell position and play it, which is good. But how will
    the user know which capability corresponds to which square? The capabilities are
    completely opaque. We can't tell from the outside what they do!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, given that the user has picked a capability somehow, we run it (with no
    parameters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next we update the display to show the result of the move. But again, how are
    we going to know what to display? There is no game state to extract the cells
    from any longer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s some pseudo-code for the UI game loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s deal with the first issue: how does the user know which capability is
    associated with which square?'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is just to create a new structure that "labels" the capability. In
    this case, with the cell position.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we must change the `MoveResult` to return a list of these labelled
    capabilities, rather than the unlabelled ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Note that the cell position is for the user's information only -- the actual
    position is still baked into the capability and cannot be forged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the second issue: how does the UI know what to display as a result
    of the move? Let''s just return that information to it directly in a new structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'And once again, the `MoveResult` must be changed, this time to return the `DisplayInfo`
    for each case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Dealing with circular dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s our final design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: But oops! This won't compile!
  prefs: []
  type: TYPE_NORMAL
- en: '`MoveCapability` depends on `MoveResult` which depends on `NextMoveInfo` which
    in turn depends on `MoveCapability` again. But the F# compiler does not allow
    forward references in general.'
  prefs: []
  type: TYPE_NORMAL
- en: Circular dependencies like this are generally frowned upon (I even have a post
    called ["cyclic dependencies are evil"](cyclic-dependencies.html)!) and there
    are [normally work-arounds which you can use](removing-cyclic-dependencies.html)
    to remove them.
  prefs: []
  type: TYPE_NORMAL
- en: In this case though, I will link them together using the `and` keyword, which
    replaces the `type` keyword and is useful for just these kinds of cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Revisiting the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What does the API look like now?
  prefs: []
  type: TYPE_NORMAL
- en: 'Originally, we had an API with slots for the three use-cases and also a helper
    function `getCells`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: But now, we don't need the `playerXMoves` or `playerOMoves`, because they are
    returned to us in the `MoveResult` of a previous move.
  prefs: []
  type: TYPE_NORMAL
- en: And `getCells` is no longer needed either, because we are returning the `DisplayInfo`
    directly now.
  prefs: []
  type: TYPE_NORMAL
- en: 'So after all these changes, the new API just has a single slot in it and looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: I've changed `NewGame` from a constant to a parameterless function, which is
    in fact, just a `MoveCapability` in disguise.
  prefs: []
  type: TYPE_NORMAL
- en: The new design in full
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the new design in full:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m much happier with this design than with the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no game state for the UI to worry about.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no type parameters to make it look ugly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The api is even more encapsulated -- a malicious UI can do very little now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's shorter -- always a good sign!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have updated the implementation and console application to use this new design.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is available on GitHub in [this gist](https://gist.github.com/swlaschin/7a5233a91912e66ac1e4)
    if you want to play with it.
  prefs: []
  type: TYPE_NORMAL
- en: Surprisingly, the implementation also has become slightly simpler, because all
    the state is now hidden and there is no need to deal with types like `PlayerXPos`
    any more.
  prefs: []
  type: TYPE_NORMAL
- en: Logging revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous post, I demonstrated how logging could be injected into the
    API.
  prefs: []
  type: TYPE_NORMAL
- en: But in this design, the capabilities are opaque and have no parameters, so how
    are we supposed to log that a particular player chose a particular location?
  prefs: []
  type: TYPE_NORMAL
- en: Well, we can't log the capabilities, but we *can* log their context, which we
    have via the `NextMoveInfo`. Let's see how this works in practice.
  prefs: []
  type: TYPE_NORMAL
- en: First, given a `MoveCapability`, we want to transform it into another `MoveCapability`
    that also logs the player and cell position used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This code works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new capability `newCap` function that is parameterless and returns
    a `MoveResult` just like the original one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it is called, log the player and cell position. These are not available
    from the `MoveCapability` that was passed in, so we have to pass them in explicitly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, call the original capability and get the result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result itself contains the capabilities for the next move, so we need to
    recursively transform each capability in the `MoveResult` and return a new `MoveResult`.
    This is done by the `transformMR` function that is passed in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we can transform a `MoveCapability`, we can go up a level and transform
    a `NextMoveInfo`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This code works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Given a `NextMoveInfo`, replace its capability with a transformed one. The output
    of `transformNextMove` is a new `NextMoveInfo`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cellPos comes from the original move.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player and `transformMR` function are not available from the move, so must
    be passed in explicitly again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we need to implement the function that will transform a `MoveResult`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'This code works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Given a `MoveResult`, handle each case. The output is a new `MoveResult`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `GameWon` and `GameTied` cases, log the result and return the original
    moveResult.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `PlayerXToMove` case, take each of the `NextMoveInfo`s and transform
    them, passing in the required player (`PlayerX`) and `transformMR` function. Note
    that the `transformMR` function is a reference to this very function! This means
    that `transformMoveResult` must be marked with `rec` to allow this self-reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `PlayerOToMove` case, do the same as the `PlayerXToMove` case, except
    change the player to `PlayerO`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we can inject logging into the API as a whole by transforming the
    `MoveResult` returned by `newGame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: So there you go. Logging is a bit trickier than before, but still possible.
  prefs: []
  type: TYPE_NORMAL
- en: A warning on recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this code, I've been passing around functions that call each other recursively.
    When you do this, you have to be careful that you don't unwittingly cause a stack
    overflow.
  prefs: []
  type: TYPE_NORMAL
- en: In a game like this, when the number of nested calls is guaranteed to be small,
    then there is no issue. But if you are doing tens of thousands of nested calls,
    then you should worry about potential problems.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the F# compiler will do tail-call optimization, but I suggest
    that you stress test your code to be sure!
  prefs: []
  type: TYPE_NORMAL
- en: Data-centric vs capability-centric designs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an interesting difference between the original design and the new design.
  prefs: []
  type: TYPE_NORMAL
- en: The original design was *data-centric*. Yes, we gave each player a function
    to use, but it was the *same* function used over and over, with different data
    passed in each time.
  prefs: []
  type: TYPE_NORMAL
- en: The new design is *function-centric* (or as I prefer, *capability-centric*).
    There is very little data now. Instead, the result of each function call is *another*
    set of functions than can be used for the next step, and so on, ad infinitum.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, it reminds me somewhat of a [continuation-based](computation-expressions-continuations.html)
    approach, except that rather than passing in a continuation, the function itself
    returns a list of continuations, and then you pick one to use.
  prefs: []
  type: TYPE_NORMAL
- en: Capabilities and RESTful designs -- a match made in heaven
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If for some crazy reason you wanted to turn this design into a web service,
    how would you go about doing that?
  prefs: []
  type: TYPE_NORMAL
- en: In a *data-centric* design, we have a function to call (an endpoint URI in the
    web API) and then we pass data to it (as JSON or XML). The result of the call
    is more data that we use to update the display (e.g. the DOM).
  prefs: []
  type: TYPE_NORMAL
- en: But in a *capability-centric* design, where's the data? And how do we pass functions
    around? It seems like this approach would not work for web services at all.
  prefs: []
  type: TYPE_NORMAL
- en: It might surprise you to know that there *is* a way to do this, and what's more
    it is exactly the same approach used by a RESTful design using [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS).
  prefs: []
  type: TYPE_NORMAL
- en: What happens is that each capability is mapped to a URI by the server, and then
    visiting that URI is the same as exercising that capability (e.g. calling the
    function).
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a web-based application based on this Tic-Tac-Toe design, the
    server would initially return nine URIs, one for each square. Then, when one of
    those squares was clicked, and the associated URI visited, the server would return
    eight new URIs, one for each remaining unplayed square. The URI for the just-played
    square would not be in this list, which means that it could not be clicked on
    again.
  prefs: []
  type: TYPE_NORMAL
- en: And of course when you click on one of the eight unplayed squares, the server
    would now return seven new URIs, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This model is exactly what REST is supposed to be; you decide what to do next
    based on the contents of the returned page rather than hard-code the endpoints
    into your app.
  prefs: []
  type: TYPE_NORMAL
- en: One possible downside of this approach is that it is does not appear to be stateless.
  prefs: []
  type: TYPE_NORMAL
- en: In the data-centric version, all the data needed for a move was passed in each
    time, which means that scaling the backend services would be trivial.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In capability-centric approach though, the state has to be stored somewhere.
    If the complete game state can be encoded into the URI, then this approach will
    allow stateless servers as well, but otherwise, some sort of state-storage will
    be needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some web frameworks have made this function-centred approach a key part of their
    design, most notably [Seaside](https://en.wikipedia.org/wiki/Seaside_%28software%29).
  prefs: []
  type: TYPE_NORMAL
- en: The excellent [WebSharper framework for F#](http://websharper.com) also uses
    [something similar](http://websharper.com/blog-entry/3965), I think (I don't know
    WebSharper as well as I want to, alas, so correct me if I'm wrong).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post, I tore up my original design and replaced it with an even more
    function-centric one, which I like better.
  prefs: []
  type: TYPE_NORMAL
- en: 'But of course it still has all those qualities we love: separation of concerns,
    an API, a watertight security model, self-documenting code, and logging.'
  prefs: []
  type: TYPE_NORMAL
- en: I'm going to stop with Tic-Tac-Toe now -- I think I've wrung it dry! I hope
    you found these two walkthoughs interesting; I learned a lot myself.
  prefs: []
  type: TYPE_NORMAL
- en: '*NOTE: The code for this post is available on GitHub in [this gist](https://gist.github.com/swlaschin/7a5233a91912e66ac1e4).*'
  prefs: []
  type: TYPE_NORMAL
