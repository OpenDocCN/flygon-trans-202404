["```\nint G, H;\nint test(_Bool Condition) {\n  int X;\n  if (Condition)\n    X = G;\n  else\n    X = H;\n  return X;\n} \n```", "```\n@G = weak global i32 0   ; type of @G is i32*\n@H = weak global i32 0   ; type of @H is i32*\n\ndefine i32 @test(i1 %Condition) {\nentry:\n  br i1 %Condition, label %cond_true, label %cond_false\n\ncond_true:\n  %X.0 = load i32* @G\n  br label %cond_next\n\ncond_false:\n  %X.1 = load i32* @H\n  br label %cond_next\n\ncond_next:\n  %X.2 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]\n  ret i32 %X.2\n} \n```", "```\ndefine i32 @example() {\nentry:\n  %X = alloca i32           ; type of %X is i32*.\n  ...\n  %tmp = load i32* %X       ; load the stack value %X from the stack.\n  %tmp2 = add i32 %tmp, 1   ; increment it\n  store i32 %tmp2, i32* %X  ; store it back\n  ... \n```", "```\n@G = weak global i32 0   ; type of @G is i32*\n@H = weak global i32 0   ; type of @H is i32*\n\ndefine i32 @test(i1 %Condition) {\nentry:\n  %X = alloca i32           ; type of %X is i32*.\n  br i1 %Condition, label %cond_true, label %cond_false\n\ncond_true:\n  %X.0 = load i32* @G\n  store i32 %X.0, i32* %X   ; Update X\n  br label %cond_next\n\ncond_false:\n  %X.1 = load i32* @H\n  store i32 %X.1, i32* %X   ; Update X\n  br label %cond_next\n\ncond_next:\n  %X.2 = load i32* %X       ; Read X\n  ret i32 %X.2\n} \n```", "```\n$ llvm-as < example.ll | opt -mem2reg | llvm-dis\n@G = weak global i32 0\n@H = weak global i32 0\n\ndefine i32 @test(i1 %Condition) {\nentry:\n  br i1 %Condition, label %cond_true, label %cond_false\n\ncond_true:\n  %X.0 = load i32* @G\n  br label %cond_next\n\ncond_false:\n  %X.1 = load i32* @H\n  br label %cond_next\n\ncond_next:\n  %X.01 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]\n  ret i32 %X.01\n} \n```", "```\n# Define ':' for sequencing: as a low-precedence operator that ignores operands\n# and just returns the RHS.\ndef binary : 1 (x y) y;\n\n# Recursive fib, we could do this before.\ndef fib(x)\n  if (x < 3) then\n    1\n  else\n    fib(x-1)+fib(x-2);\n\n# Iterative fib.\ndef fibi(x)\n  var a = 1, b = 1, c in\n  (for i = 3, i < x in\n     c = a + b :\n     a = b :\n     b = c) :\n  b;\n\n# Call it.\nfibi(10); \n```", "```\nstatic std::map<std::string, AllocaInst*> NamedValues; \n```", "```\n/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of\n/// the function.  This is used for mutable variables etc.\nstatic AllocaInst *CreateEntryBlockAlloca(Function *TheFunction,\n                                          const std::string &VarName) {\n  IRBuilder<> TmpB(&TheFunction->getEntryBlock(),\n                 TheFunction->getEntryBlock().begin());\n  return TmpB.CreateAlloca(Type::getDoubleTy(getGlobalContext()), 0,\n                           VarName.c_str());\n} \n```", "```\nValue *VariableExprAST::Codegen() {\n  // Look this variable up in the function.\n  Value *V = NamedValues[Name];\n  if (V == 0) return ErrorV(\"Unknown variable name\");\n\n  // Load the value.\n  return Builder.CreateLoad(V, Name.c_str());\n} \n```", "```\nFunction *TheFunction = Builder.GetInsertBlock()->getParent();\n\n// Create an alloca for the variable in the entry block.\nAllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);\n\n  // Emit the start code first, without 'variable' in scope.\nValue *StartVal = Start->Codegen();\nif (StartVal == 0) return 0;\n\n// Store the value into the alloca.\nBuilder.CreateStore(StartVal, Alloca);\n...\n\n// Compute the end condition.\nValue *EndCond = End->Codegen();\nif (EndCond == 0) return EndCond;\n\n// Reload, increment, and restore the alloca.  This handles the case where\n// the body of the loop mutates the variable.\nValue *CurVar = Builder.CreateLoad(Alloca);\nValue *NextVar = Builder.CreateFAdd(CurVar, StepVal, \"nextvar\");\nBuilder.CreateStore(NextVar, Alloca);\n... \n```", "```\n/// CreateArgumentAllocas - Create an alloca for each argument and register the\n/// argument in the symbol table so that references to it will succeed.\nvoid PrototypeAST::CreateArgumentAllocas(Function *F) {\n  Function::arg_iterator AI = F->arg_begin();\n  for (unsigned Idx = 0, e = Args.size(); Idx != e; ++Idx, ++AI) {\n    // Create an alloca for this variable.\n    AllocaInst *Alloca = CreateEntryBlockAlloca(F, Args[Idx]);\n\n    // Store the initial value into the alloca.\n    Builder.CreateStore(AI, Alloca);\n\n    // Add arguments to variable symbol table.\n    NamedValues[Args[Idx]] = Alloca;\n  }\n} \n```", "```\n// Set up the optimizer pipeline.  Start with registering info about how the\n// target lays out data structures.\nOurFPM.add(new DataLayout(*TheExecutionEngine->getDataLayout()));\n// Promote allocas to registers.\nOurFPM.add(createPromoteMemoryToRegisterPass());\n// Do simple \"peephole\" optimizations and bit-twiddling optzns.\nOurFPM.add(createInstructionCombiningPass());\n// Reassociate expressions.\nOurFPM.add(createReassociatePass());\nIt is interesting to see what the code looks like before and after the mem2reg optimization runs. For example, this is the before/after code for our recursive fib function. Before the optimization:\n\ndefine double @fib(double %x) {\nentry:\n  %x1 = alloca double\n  store double %x, double* %x1\n  %x2 = load double* %x1\n  %cmptmp = fcmp ult double %x2, 3.000000e+00\n  %booltmp = uitofp i1 %cmptmp to double\n  %ifcond = fcmp one double %booltmp, 0.000000e+00\n  br i1 %ifcond, label %then, label %else\n\nthen:       ; preds = %entry\n  br label %ifcont\n\nelse:       ; preds = %entry\n  %x3 = load double* %x1\n  %subtmp = fsub double %x3, 1.000000e+00\n  %calltmp = call double @fib(double %subtmp)\n  %x4 = load double* %x1\n  %subtmp5 = fsub double %x4, 2.000000e+00\n  %calltmp6 = call double @fib(double %subtmp5)\n  %addtmp = fadd double %calltmp, %calltmp6\n  br label %ifcont\n\nifcont:     ; preds = %else, %then\n  %iftmp = phi double [ 1.000000e+00, %then ], [ %addtmp, %else ]\n  ret double %iftmp\n} \n```", "```\ndefine double @fib(double %x) {\nentry:\n  %cmptmp = fcmp ult double %x, 3.000000e+00\n  %booltmp = uitofp i1 %cmptmp to double\n  %ifcond = fcmp one double %booltmp, 0.000000e+00\n  br i1 %ifcond, label %then, label %else\n\nthen:\n  br label %ifcont\n\nelse:\n  %subtmp = fsub double %x, 1.000000e+00\n  %calltmp = call double @fib(double %subtmp)\n  %subtmp5 = fsub double %x, 2.000000e+00\n  %calltmp6 = call double @fib(double %subtmp5)\n  %addtmp = fadd double %calltmp, %calltmp6\n  br label %ifcont\n\nifcont:     ; preds = %else, %then\n  %iftmp = phi double [ 1.000000e+00, %then ], [ %addtmp, %else ]\n  ret double %iftmp\n} \n```", "```\ndefine double @fib(double %x) {\nentry:\n  %cmptmp = fcmp ult double %x, 3.000000e+00\n  %booltmp = uitofp i1 %cmptmp to double\n  %ifcond = fcmp ueq double %booltmp, 0.000000e+00\n  br i1 %ifcond, label %else, label %ifcont\n\nelse:\n  %subtmp = fsub double %x, 1.000000e+00\n  %calltmp = call double @fib(double %subtmp)\n  %subtmp5 = fsub double %x, 2.000000e+00\n  %calltmp6 = call double @fib(double %subtmp5)\n  %addtmp = fadd double %calltmp, %calltmp6\n  ret double %addtmp\n\nifcont:\n  ret double 1.000000e+00\n} \n```", "```\nint main() {\n  // Install standard binary operators.\n  // 1 is lowest precedence.\n  BinopPrecedence['='] = 2;\n  BinopPrecedence['<'] = 10;\n  BinopPrecedence['+'] = 20;\n  BinopPrecedence['-'] = 20; \n```", "```\nValue *BinaryExprAST::Codegen() {\n  // Special case '=' because we don't want to emit the LHS as an expression.\n  if (Op == '=') {\n    // Assignment requires the LHS to be an identifier.\n    VariableExprAST *LHSE = dynamic_cast<VariableExprAST*>(LHS);\n    if (!LHSE)\n      return ErrorV(\"destination of '=' must be a variable\"); \n```", "```\n // Codegen the RHS.\n  Value *Val = RHS->Codegen();\n  if (Val == 0) return 0;\n\n  // Look up the name.\n  Value *Variable = NamedValues[LHSE->getName()];\n  if (Variable == 0) return ErrorV(\"Unknown variable name\");\n\n  Builder.CreateStore(Val, Variable);\n  return Val;\n}\n... \n```", "```\n# Function to print a double.\nextern printd(x);\n\n# Define ':' for sequencing: as a low-precedence operator that ignores operands\n# and just returns the RHS.\ndef binary : 1 (x y) y;\n\ndef test(x)\n  printd(x) :\n  x = 4 :\n  printd(x);\n\ntest(123); \n```", "```\nenum Token {\n  ...\n  // var definition\n  tok_var = -13\n...\n}\n...\nstatic int gettok() {\n...\n    if (IdentifierStr == \"in\") return tok_in;\n    if (IdentifierStr == \"binary\") return tok_binary;\n    if (IdentifierStr == \"unary\") return tok_unary;\n    if (IdentifierStr == \"var\") return tok_var;\n    return tok_identifier;\n... \n```", "```\n/// VarExprAST - Expression class for var/in\nclass VarExprAST : public ExprAST {\n  std::vector<std::pair<std::string, ExprAST*> > VarNames;\n  ExprAST *Body;\npublic:\n  VarExprAST(const std::vector<std::pair<std::string, ExprAST*> > &varnames,\n             ExprAST *body)\n  : VarNames(varnames), Body(body) {}\n\n  virtual Value *Codegen();\n}; \n```", "```\n/// primary\n///   ::= identifierexpr\n///   ::= numberexpr\n///   ::= parenexpr\n///   ::= ifexpr\n///   ::= forexpr\n///   ::= varexpr\nstatic ExprAST *ParsePrimary() {\n  switch (CurTok) {\n  default: return Error(\"unknown token when expecting an expression\");\n  case tok_identifier: return ParseIdentifierExpr();\n  case tok_number:     return ParseNumberExpr();\n  case '(':            return ParseParenExpr();\n  case tok_if:         return ParseIfExpr();\n  case tok_for:        return ParseForExpr();\n  case tok_var:        return ParseVarExpr();\n  }\n} \n```", "```\n/// varexpr ::= 'var' identifier ('=' expression)?\n//                    (',' identifier ('=' expression)?)* 'in' expression\nstatic ExprAST *ParseVarExpr() {\n  getNextToken();  // eat the var.\n\n  std::vector<std::pair<std::string, ExprAST*> > VarNames;\n\n  // At least one variable name is required.\n  if (CurTok != tok_identifier)\n    return Error(\"expected identifier after var\");\nThe first part of this code parses the list of identifier/expr pairs into the local VarNames vector.\n\nwhile (1) {\n  std::string Name = IdentifierStr;\n  getNextToken();  // eat identifier.\n\n  // Read the optional initializer.\n  ExprAST *Init = 0;\n  if (CurTok == '=') {\n    getNextToken(); // eat the '='.\n\n    Init = ParseExpression();\n    if (Init == 0) return 0;\n  }\n\n  VarNames.push_back(std::make_pair(Name, Init));\n\n  // End of var list, exit loop.\n  if (CurTok != ',') break;\n  getNextToken(); // eat the ','.\n\n  if (CurTok != tok_identifier)\n    return Error(\"expected identifier list after var\");\n} \n```", "```\n // At this point, we have to have 'in'.\n  if (CurTok != tok_in)\n    return Error(\"expected 'in' keyword after 'var'\");\n  getNextToken();  // eat 'in'.\n\n  ExprAST *Body = ParseExpression();\n  if (Body == 0) return 0;\n\n  return new VarExprAST(VarNames, Body);\n} \n```", "```\nValue *VarExprAST::Codegen() {\n  std::vector<AllocaInst *> OldBindings;\n\n  Function *TheFunction = Builder.GetInsertBlock()->getParent();\n\n  // Register all variables and emit their initializer.\n  for (unsigned i = 0, e = VarNames.size(); i != e; ++i) {\n    const std::string &VarName = VarNames[i].first;\n    ExprAST *Init = VarNames[i].second; \n```", "```\n // Emit the initializer before adding the variable to scope, this prevents\n  // the initializer from referencing the variable itself, and permits stuff\n  // like this:\n  //  var a = 1 in\n  //    var a = a in ...   # refers to outer 'a'.\n  Value *InitVal;\n  if (Init) {\n    InitVal = Init->Codegen();\n    if (InitVal == 0) return 0;\n  } else { // If not specified, use 0.0.\n    InitVal = ConstantFP::get(getGlobalContext(), APFloat(0.0));\n  }\n\n  AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);\n  Builder.CreateStore(InitVal, Alloca);\n\n  // Remember the old variable binding so that we can restore the binding when\n  // we unrecurse.\n  OldBindings.push_back(NamedValues[VarName]);\n\n  // Remember this binding.\n  NamedValues[VarName] = Alloca;\n} \n```", "```\n// Codegen the body, now that all vars are in scope.\nValue *BodyVal = Body->Codegen();\nif (BodyVal == 0) return 0;\nFinally, before returning, we restore the previous variable bindings:\n\n  // Pop all our variables from scope.\n  for (unsigned i = 0, e = VarNames.size(); i != e; ++i)\n    NamedValues[VarNames[i].first] = OldBindings[i];\n\n  // Return the body computation.\n  return BodyVal;\n} \n```"]