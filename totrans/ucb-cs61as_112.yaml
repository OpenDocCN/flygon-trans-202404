- en: Representing Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have mentioned in Unit 2 that we can store data using a 2 dimensional table
    and, given 2 keys, can fetch the desired data. We can use mutable lists to represent
    this data structure by first building a 1 dimensional table and extending the
    idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before We Start: `assoc`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dive in to tables, we have to explore another Scheme compound procedure,
    `assoc`, which will play a huge role. `assoc` accepts a `key` and a list of pairs,
    and returns the first pair that has `key` as its `car`. If no such pairs exist,
    it returns `#f`. Look at the series of examples below to understand what `assoc`
    does.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the formal definition for `assoc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 1-Dimensional Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a **1D table**, values are stored under a single key. A table will be designed
    as a list of pairs. Each pairs' `car` hold the key for each value.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/985d464e8b5ba9010fdb19facebef760.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the above table, the breakdown between the keys and values can be seen below.
  prefs: []
  type: TYPE_NORMAL
- en: '| Keys | Values |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `b` | `2` |'
  prefs: []
  type: TYPE_TB
- en: '| `c` | `3` |'
  prefs: []
  type: TYPE_TB
- en: Why does our table point to a pair that doesn't contain any key-value pair?
    We designed our table so that the first pair holds the symbol `*table*` which
    signifies that the current list structure we're looking at is a table.
  prefs: []
  type: TYPE_NORMAL
- en: '`make-table`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is the simple constructor for our table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`lookup`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To extract information from a table, we use the `lookup` selector, which takes
    a key as argument and returns the associated value (or `#f` if there is no value
    stored under that key). Here's our definition of `lookup`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`insert!`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To insert a key-value pair in a table, we follow this simple algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: If key is already in the list, just update the value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, make a new key-value pair and attach it to the table
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (define (insert! key value table) (let ((record (assoc key (cdr table)))) (if
    record (set-cdr! record value) (set-cdr! table (cons (cons key value) (cdr table)))))
    'ok)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2-Dimensional Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a **2D table**, each value is specified by *two* keys. We can construct
    such a table as a 1 dimensional table in which each key identifies a subtable.
    Say we have 2 tables: "math" and "letters" with the following key-value pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can put them into one big table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ec2e74a211a476ff79993795265f9ed2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`lookup`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To find a value in a 2D table, you will need 2 keys. The first key is used to
    find the correct subtable. The second key is used to find the correct value in
    that subtable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`insert`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To insert into a 2D table, you also need 2 keys. The first key is used to try
    and find the correct subtable. If a subtable with the first key doesn't exist,
    make a new subtable. If the table exists, use the exact same algorithm we have
    for the 1 dimensional `insert!`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Local Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `lookup` and`insert!` operations defined above take the table as an argument.
    This enables us to use programs that access more than one table. Another way to
    deal with multiple tables is to have separate `lookup` and `insert!` procedures
    for each table. We can do this by representing a table procedurally, as an object
    that maintains an internal table as part of its local state. When sent an appropriate
    message, this "table object'''' supplies the procedure with which to operate on
    the internal table. Here is a generator for two-dimensional tables represented
    in this fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`get` and `put`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Unit 2's "Data Directed" subsection, we used a 2D table to store a value
    under 2 keys using the procedures `get` and `put`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can now define these procedures using our tables!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`get` takes as arguments two keys, and `put` takes as arguments two keys and
    a value. Both operations access the same local table, which is encapsulated within
    the object created by the call to `make-table`.'
  prefs: []
  type: TYPE_NORMAL
