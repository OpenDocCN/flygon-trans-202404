- en: Homework 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type the following command at the terminal to copy the template file to the
    current directory (note the period at the end):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Or you can download the template [here](http://inst.eecs.berkeley.edu/~cs61as/templates/hw6.rkt).
  prefs: []
  type: TYPE_NORMAL
- en: Autograder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run the autograder on your computer, download the test file [here](http://inst.eecs.berkeley.edu/~cs61as/autograder/tests/hw6-tests.rkt).
    Follow the instructions from previous lessons.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Exercise 0 consists of problems from the lesson. Highly recommended to do.
    This is NOT for credit.**'
  prefs: []
  type: TYPE_NORMAL
- en: Load the racket-1 interpreter from the file
  prefs: []
  type: TYPE_NORMAL
- en: '`~cs61as/lib/racket1.rkt`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the interpreter, type `(racket-1)`. Familiarize yourself with it by
    evaluating some expressions. Remember: you have all the Racket primitives for
    arithmetic and list manipulation; you have lambda but not higher-order functions;
    you don''t have define. To stop the racket-1 interpreter and return to Racket,
    just evaluate an illegal expression, such as `()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 0a. Trace in detail how a simple procedure call such as
  prefs: []
  type: TYPE_NORMAL
- en: '`((lambda (x) (+ x 3)) 5)`'
  prefs: []
  type: TYPE_NORMAL
- en: is handled in racket-1.
  prefs: []
  type: TYPE_NORMAL
- en: '0b. Try inventing higher-order procedures; since you don''t have define you''ll
    have to use the Y-combinator trick, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '0c. Since all the Racket primitives are automatically available in racket-1,
    you might think you could use Racket''s primitive map function. Try these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Explain the results.
  prefs: []
  type: TYPE_NORMAL
- en: '0d. Modify the interpreter to add the and special form. Test your work. Be
    sure that as soon as a false value is computed, your and returns #f without evaluating
    any further arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Complete the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Abelson & Sussman, exercises [2.74, 2.75, 2.76](http://mitpress.mit.edu/sicp
    /full-text/book/book-Z-H-17.html#%25_thm_2.74), [2.77, 2.79, 2.80](http://mitpress.mit.edu/sicp/full-
    text/book/book-Z-H-18.html#%25_thm_2.77), [2.81, 2.83](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-18.html#%25_thm_2.81)
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Some of these are thought-exercises; you needn''t actually run any Scheme
    programs for them! (Some don''t ask you to write procedures at all; others ask
    for modifications to a program that isn''t online.)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a `map` primitive for `racket-1` (call it `map-1` so you and Racket don't
    get confused about which is which) that works correctly for all mapped procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modify the `racket-1` interpreter to add the `let` special form. Hint: Like
    a procedure call, `let` will have to use `substitute` to replace certain variables
    with their values. Don''t forget to evaluate the expressions that provide those
    values!'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[SICP ex. 2.62](http://mitpress.mit.edu/sicp/full- text/book/book-Z-H-16.html#%25_thm_2.62)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will help: [SICP 2.3.3](http://mitpress.mit.edu/sicp/full- text/book/book-Z-H-16.html#%_sec_2.3.3)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The file `~cs61as/lib/bst.scm` contains the binary search tree procedures from
    SICP 2.3.3\. Using adjoin-set, construct the [trees shown on page 156](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-16.html#%_fig_2.16).
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra for Experts: Exercise 6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Do this if you want to. This is NOT for credit.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach to the problem of type-handling is type inference. If, for
    instance, a procedure includes the expression `(+ n k)`, one can infer that `n`
    and `k` have numeric values. Similarly, the expression`(f a b)` indicates that
    the value of f is a procedure. Write a procedure called inferred-types that, given
    a definition of a Scheme procedure as argument, returns a list of information
    about the parameters of the procedure. The information list should contain one
    element per parameter; each element should be a two-element list whose first element
    is the parameter name and whose second element is a word indicating the type inferred
    for the parameter. Possible types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You should assume for this problem that the body of the procedure to be examined
    does not contain any occurrences of `if` or `cond`, although it may contain arbitrarily
    nested and quoted expressions. (A more ambitious inference procedure both would
    examine a more comprehensive set of procedures and could infer conditions like
    "�nonempty list"�.) Here's an example of what your inference procedure should
    return.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: should return
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you're really ambitious, you could maintain a database of inferred argument
    types and use it when a procedure you've seen is invoked by another procedure
    you're examining!
  prefs: []
  type: TYPE_NORMAL
- en: Submit Your Homework!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For instructions, see [this guide](../submit.html). It covers basic terminal
    commands and assignment submission.
  prefs: []
  type: TYPE_NORMAL
- en: If you have any trouble submitting, do not hesitate to ask a TA!
  prefs: []
  type: TYPE_NORMAL
