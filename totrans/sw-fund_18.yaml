- en: HoareHoare Logic, Part I
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Import Coq.Bool.Bool.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Arith.Arith.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Arith.EqNat.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.omega.Omega.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Imp.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Maps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To talk about specifications of programs, the first thing we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: need is a way of making *assertions* about properties that hold at
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: particular points during a program's execution — i.e., claims
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: about the current state of the memory when execution reaches that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: point.  Formally, an assertion is just a family of propositions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: indexed by a state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star, optional (assertions)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Paraphrase the following assertions in English (or your favorite
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: natural language).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This way of writing assertions can be a little bit heavy,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for two reasons: (1) every single assertion that we ever write is'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: going to begin with fun st ⇒ ; and (2) this state st is the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: only one that we ever use to look up variables in assertions (we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: will never need to talk about two different memory states at the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: same time).  For discussing examples informally, we'll adopt some
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'simplifying conventions: we''ll drop the initial fun st ⇒, and'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we'll write just X to mean st X.  Thus, instead of writing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Z * Z ≤ m ∧ ~((S Z) * (S Z) ≤ m).
  prefs: []
  type: TYPE_NORMAL
- en: This example also illustrates a convention that we'll use
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'throughout the Hoare Logic chapters: in informal assertions,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: capital letters like {X], Y, and Z are Imp variables, while
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lowercase letters like x, y, m, and n are ordinary Coq
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variables (of type nat).  This is why, when translating from
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: informal to formal, we replace X with st X but leave m
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: alone.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Given two assertions P and Q, we say that P *implies* Q,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: written P ⇾ Q (in ASCII, P ->> Q), if, whenever P
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: holds in some state st, Q also holds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: (The hoare_spec_scope annotation here tells Coq that this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: notation is not global but is intended to be used in particular
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: contexts.  The Open Scope tells Coq that this file is one such
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: context.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We'll also want the "iff" variant of implication between
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'assertions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Hoare Triples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we need a way of making formal claims about the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: behavior of commands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In general, the behavior of a command is to transform one state to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: another, so it is natural to express claims about commands in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: terms of assertions that are true before and after the command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'executes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"If command c is started in a state satisfying assertion P, and if c eventually
    terminates in some final state, then this final state will satisfy the assertion
    Q."'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such a claim is called a *Hoare Triple*.  The property P is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: called the *precondition* of c, while Q is the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*postcondition*.  Formally:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Since we'll be working a lot with Hoare triples, it's useful to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'have a compact notation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notation "{{ P }}  c  {{ Q }}" :=
  prefs: []
  type: TYPE_NORMAL
- en: (hoare_triple P c Q) (at level 90, c at next level)
  prefs: []
  type: TYPE_NORMAL
- en: ': hoare_spec_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 1) {{True}} c {{X = 5}}
  prefs: []
  type: TYPE_NORMAL
- en: 2) {{X = m}} c {{X = m + 5)}}
  prefs: []
  type: TYPE_NORMAL
- en: 3) {{X ≤ Y}} c {{Y ≤ X}}
  prefs: []
  type: TYPE_NORMAL
- en: 4) {{True}} c {{False}}
  prefs: []
  type: TYPE_NORMAL
- en: 5) {{X = m}}
  prefs: []
  type: TYPE_NORMAL
- en: c
  prefs: []
  type: TYPE_NORMAL
- en: '{{Y = real_fact m}}'
  prefs: []
  type: TYPE_NORMAL
- en: 6) {{True}}
  prefs: []
  type: TYPE_NORMAL
- en: c
  prefs: []
  type: TYPE_NORMAL
- en: '{{(Z * Z) ≤ m ∧ ¬ (((S Z) * (S Z)) ≤ m)}}'
  prefs: []
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star, optional (valid_triples)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Which of the following Hoare triples are *valid* — i.e., the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: claimed relation between P, c, and Q is true?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem hoare_post_true : ∀(P Q : Assertion) c,'
  prefs: []
  type: TYPE_NORMAL
- en: (∀st, Q st) →
  prefs: []
  type: TYPE_NORMAL
- en: '{{P}} c {{Q}}.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros P Q c H. unfold [hoare_triple](Hoare.html#hoare_triple).
  prefs: []
  type: TYPE_NORMAL
- en: intros st st' Heval HP.
  prefs: []
  type: TYPE_NORMAL
- en: apply H. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem hoare_pre_false : ∀(P Q : Assertion) c,'
  prefs: []
  type: TYPE_NORMAL
- en: (∀st, ~(P st)) →
  prefs: []
  type: TYPE_NORMAL
- en: '{{P}} c {{Q}}.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros P Q c H. unfold [hoare_triple](Hoare.html#hoare_triple).
  prefs: []
  type: TYPE_NORMAL
- en: intros st st' Heval HP.
  prefs: []
  type: TYPE_NORMAL
- en: unfold [not](http://coq.inria.fr/library/Coq.Init.Logic.html#not) in H. apply
    H in HP.
  prefs: []
  type: TYPE_NORMAL
- en: inversion HP. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rule for assignment is the most fundamental of the Hoare logic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proof rules.  Here's how it works.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Consider this valid Hoare triple:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '{{ Y + Z = 1 }}  X ::= Y + Z  {{ X = 1 }}'
  prefs: []
  type: TYPE_NORMAL
- en: the same property (being equal to one) gets transferred to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: X from the expression Y + Z on the right-hand side of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the assignment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: More generally, if a is *any* arithmetic expression, then
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '{{ Q [X ↦ a] }} X ::= a {{ Q }}'
  prefs: []
  type: TYPE_NORMAL
- en: where "Q [X ↦ a]" is pronounced "Q where a is substituted
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for X".
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, these are valid applications of the assignment
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'rule:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition assn_sub X a P : Assertion :='
  prefs: []
  type: TYPE_NORMAL
- en: 'fun (st : state) ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: P (t_update st X (aeval st a)).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "P [ X |-> a ]" := (assn_sub X a P) (at level 10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: fun st ⇒
  prefs: []
  type: TYPE_NORMAL
- en: (fun st' ⇒ st' X ≤ 5)
  prefs: []
  type: TYPE_NORMAL
- en: (t_update st X (aeval st (ANum 3))),
  prefs: []
  type: TYPE_NORMAL
- en: which simplifies to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: fun st ⇒
  prefs: []
  type: TYPE_NORMAL
- en: ((t_update st X 3) X) ≤ 5)
  prefs: []
  type: TYPE_NORMAL
- en: and finally to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: fun st ⇒
  prefs: []
  type: TYPE_NORMAL
- en: (fun st' ⇒ st' X ≤ 5)
  prefs: []
  type: TYPE_NORMAL
- en: (t_update st X (aeval st (APlus (AId X) (ANum 1)))),
  prefs: []
  type: TYPE_NORMAL
- en: which simplifies to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: fun st ⇒
  prefs: []
  type: TYPE_NORMAL
- en: (aeval st (APlus (AId X) (ANum 1))) ≤ 5.
  prefs: []
  type: TYPE_NORMAL
- en: That is, P' is the assertion that X+1 is at most 5.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, using the concept of substitution, we can give the precise
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'proof rule for assignment:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (hoare_asgn)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{Q [X ↦ a]}} X ::= a {{Q}}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We can prove formally that this rule is indeed valid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here's a first formal proof using this rule.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 starsM (hoare_asgn_examples)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Translate these informal Hoare triples...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem hoare_asgn_fwd :'
  prefs: []
  type: TYPE_NORMAL
- en: '(∀{X Y: Type} {f g : X → Y},'
  prefs: []
  type: TYPE_NORMAL
- en: '(∀(x: X), f x = g x) →  f = g) →'
  prefs: []
  type: TYPE_NORMAL
- en: ∀m a P,
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ P st ∧ st X = m}}'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= a
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ P (t_update st X m)'
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st X = aeval (t_update st X m) a }}.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem hoare_asgn_fwd_exists :'
  prefs: []
  type: TYPE_NORMAL
- en: '(∀{X Y: Type} {f g : X → Y},'
  prefs: []
  type: TYPE_NORMAL
- en: '(∀(x: X), f x = g x) →  f = g) →'
  prefs: []
  type: TYPE_NORMAL
- en: ∀a P,
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ P st}}'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= a
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ ∃m, P (t_update st X m) ∧'
  prefs: []
  type: TYPE_NORMAL
- en: st X = aeval (t_update st X m) a }}.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros functional_extensionality a P.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Consequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes the preconditions and postconditions we get from the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Hoare rules won't quite be the ones we want in the particular
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: situation at hand — they may be logically equivalent but have a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: different syntactic form that fails to unify with the goal we are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: trying to prove, or they actually may be logically weaker (for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: preconditions) or stronger (for postconditions) than what we need.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For instance, while
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '{{True}} X ::= 3 {{X = 3}}'
  prefs: []
  type: TYPE_NORMAL
- en: does not.  This triple is valid, but it is not an instance of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hoare_asgn because True and (X = 3) [X ↦ 3] are not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: syntactically equal assertions.  However, they are logically
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*equivalent*, so if one triple is valid, then the other must'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: certainly be as well.  We can capture this observation with the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'following rule:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{P''}} c {{Q}}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: P ⇿ P'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (hoare_consequence_pre_equiv)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{P}} c {{Q}}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Taking this line of thought a bit further, we can see that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: strengthening the precondition or weakening the postcondition of a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: valid triple always produces another valid triple. This
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: observation is captured by two *Rules of Consequence*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{P''}} c {{Q}}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: P ⇾ P'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (hoare_consequence_pre)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{P}} c {{Q}}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{P}} c {{Q''}}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Q' ⇾ Q
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (hoare_consequence_post)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{P}} c {{Q}}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here are the formal versions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we can use the first consequence rule like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Example hoare_asgn_example1 :'
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ True}} (X ::= (ANum 1)) {{fun st ⇒ st X = 1}}.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* WORKED IN CLASS *)
  prefs: []
  type: TYPE_NORMAL
- en: apply hoare_consequence_pre
  prefs: []
  type: TYPE_NORMAL
- en: with (P' := (fun st ⇒ st X = 1) [X ↦ ANum 1]).
  prefs: []
  type: TYPE_NORMAL
- en: apply hoare_asgn.
  prefs: []
  type: TYPE_NORMAL
- en: intros st H. unfold assn_sub, t_update. simpl. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem hoare_consequence : ∀(P P'' Q Q'' : Assertion) c,'
  prefs: []
  type: TYPE_NORMAL
- en: '{{P''}} c {{Q''}} →'
  prefs: []
  type: TYPE_NORMAL
- en: P ⇾ P' →
  prefs: []
  type: TYPE_NORMAL
- en: Q' ⇾ Q →
  prefs: []
  type: TYPE_NORMAL
- en: '{{P}} c {{Q}}.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros P P' Q Q' c Hht HPP' HQ'Q.
  prefs: []
  type: TYPE_NORMAL
- en: apply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre) with (P' :=
    P').
  prefs: []
  type: TYPE_NORMAL
- en: apply [hoare_consequence_post](Hoare.html#hoare_consequence_post) with (Q' :=
    Q').
  prefs: []
  type: TYPE_NORMAL
- en: assumption. assumption. assumption. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Example hoare_asgn_example1'' :'
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ True}}'
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= (ANum 1))
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ st X = 1}}.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: eapply hoare_consequence_pre.
  prefs: []
  type: TYPE_NORMAL
- en: apply hoare_asgn.
  prefs: []
  type: TYPE_NORMAL
- en: intros st H. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma silly1 : ∀(P : nat → nat → Prop) (Q : nat → Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: '(∀x y : nat, P x y) →'
  prefs: []
  type: TYPE_NORMAL
- en: '(∀x y : nat, P x y → Q x) →'
  prefs: []
  type: TYPE_NORMAL
- en: Q 42.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros P Q HP HQ. eapply HQ. apply HP.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma silly2 :'
  prefs: []
  type: TYPE_NORMAL
- en: '∀(P : nat → nat → Prop) (Q : nat → Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (∃y, P 42 y) →
  prefs: []
  type: TYPE_NORMAL
- en: '(∀x y : nat, P x y → Q x) →'
  prefs: []
  type: TYPE_NORMAL
- en: Q 42.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros P Q HP HQ. eapply HQ. destruct HP as [y HP'].
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Error: Impossible to unify "?175" with "y".
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case there is an easy fix: doing destruct HP *before*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: doing eapply HQ.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The apply HP' in the last step unifies the existential variable
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in the goal with the variable y.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the assumption tactic doesn't work in this case, since
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it cannot handle existential variables.  However, Coq also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: provides an eassumption tactic that solves the goal if one of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the premises matches the goal up to instantiations of existential
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variables. We can use it instead of apply HP' if we like.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 starsM (hoare_asgn_examples_2)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Translate these informal Hoare triples...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Skip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since SKIP doesn't change the state, it preserves any
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'property P:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (hoare_skip)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{ P }} SKIP {{ P }}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Sequencing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More interestingly, if the command c[1] takes any state where
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: P holds to a state where Q holds, and if c[2] takes any
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: state where Q holds to one where R holds, then doing c[1]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: followed by c[2] will take any state where P holds to one
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'where R holds:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{ P }} c[1] {{ Q }}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{ Q }} c[2] {{ R }}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (hoare_seq)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{ P }} c[1];;c[2] {{ R }}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in the formal rule hoare_seq, the premises are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: given in backwards order (c[2] before c[1]).  This matches the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: natural flow of information in many of the situations where we'll
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: use the rule, since the natural way to construct a Hoare-logic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proof is to begin at the end of the program (with the final
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postcondition) and push postconditions backwards through commands
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: until we reach the beginning.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Informally, a nice way of displaying a proof using the sequencing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rule is as a "decorated program" where the intermediate assertion
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Q is written between c[1] and c[2]:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Example hoare_asgn_example3 : ∀a n,'
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ aeval st a = n}}'
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= a;; SKIP)
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ st X = n}}.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros a n. eapply hoare_seq.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* right part of seq *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply hoare_skip.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* left part of seq *)'
  prefs: []
  type: TYPE_NORMAL
- en: eapply hoare_consequence_pre. apply hoare_asgn.
  prefs: []
  type: TYPE_NORMAL
- en: intros st H. subst. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '{{ True }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ 1 = 1 }}'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= 1;;
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X = 1 }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X = 1 ∧ 2 = 2 }}'
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= 2
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X = 1 ∧ Y = 2 }}'
  prefs: []
  type: TYPE_NORMAL
- en: (Note the use of "⇾" decorations, each marking a use of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hoare_consequence_pre.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars (swap_exercise)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write an Imp program c that swaps the values of X and Y and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'show that it satisfies the following specification:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition swap_program : com'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem swap_exercise :'
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ st X ≤ st Y}}'
  prefs: []
  type: TYPE_NORMAL
- en: swap_program
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ st Y ≤ st X}}.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: ∀(a : aexp) (n : nat),
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ aeval st a = n}}'
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= (ANum 3);; Y ::= a)
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ st Y = n}}.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '{{ True }}'
  prefs: []
  type: TYPE_NORMAL
- en: IFB X == 0
  prefs: []
  type: TYPE_NORMAL
- en: THEN Y ::= 2
  prefs: []
  type: TYPE_NORMAL
- en: ELSE Y ::= X + 1
  prefs: []
  type: TYPE_NORMAL
- en: FI
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X ≤ Y }}'
  prefs: []
  type: TYPE_NORMAL
- en: since the rule tells us nothing about the state in which the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assignments take place in the "then" and "else" branches.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we can say something more precise.  In the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"then" branch, we know that the boolean expression b evaluates to'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: true, and in the "else" branch, we know it evaluates to false.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Making this information available in the premises of the rule gives
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: us more information to work with when reasoning about the behavior
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of c[1] and c[2] (i.e., the reasons why they establish the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postcondition Q).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{P ∧  b}} c[1] {{Q}}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{P ∧ ~b}} c[2] {{Q}}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (hoare_if)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{P}} IFB b THEN c[1] ELSE c[2] FI {{Q}}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: To interpret this rule formally, we need to do a little work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Strictly speaking, the assertion we've written, P ∧ b, is the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: conjunction of an assertion and a boolean expression — i.e., it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: doesn't typecheck.  To fix this, we need a way of formally
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"lifting" any bexp b to an assertion.  We''ll write bassn b for'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the assertion "the boolean expression b evaluates to true (in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the given state)."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of useful facts about bassn:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now we can formalize the Hoare proof rule for conditionals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and prove it correct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is a formal proof that the program we used to motivate the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rule satisfies the specification we gave.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars (if_minus_plus)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prove the following hoare triple using hoare_if.  Do not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: use unfold hoare_triple.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Module If[1].
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive com : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| CSkip : com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CAss : id → aexp → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CSeq : com → com → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CIf : bexp → com → com → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CWhile : bexp → com → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CIf1 : bexp → com → com.'
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'SKIP'" :=
  prefs: []
  type: TYPE_NORMAL
- en: CSkip.
  prefs: []
  type: TYPE_NORMAL
- en: Notation "c1 ;; c2" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CSeq c[1] c[2]) (at level 80, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "X '::=' a" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CAss X a) (at level 60).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'WHILE' b 'DO' c 'END'" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CWhile b c) (at level 80, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'IFB' e1 'THEN' e2 'ELSE' e3 'FI'" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CIf e[1] e[2] e[3]) (at level 80, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'IF1' b 'THEN' c 'FI'" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CIf1 b c) (at level 80, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Reserved Notation "c1 '/' st '⇓' st'" (at level 40, st at level 39).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive ceval : com → state → state → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| E_Skip : ∀st : state, SKIP / st ⇓ st'
  prefs: []
  type: TYPE_NORMAL
- en: '| E_Ass : ∀(st : state) (a[1] : aexp) (n : nat) (X : id),'
  prefs: []
  type: TYPE_NORMAL
- en: aeval st a[1] = n → (X ::= a[1]) / st ⇓ t_update st X n
  prefs: []
  type: TYPE_NORMAL
- en: '| E_Seq : ∀(c[1] c[2] : com) (st st'' st'''' : state),'
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / st ⇓ st' → c[2] / st' ⇓ st'' → (c[1] ;; c[2]) / st ⇓ st''
  prefs: []
  type: TYPE_NORMAL
- en: '| E_IfTrue : ∀(st st'' : state) (b[1] : bexp) (c[1] c[2] : com),'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = true →
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / st ⇓ st' → (IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'
  prefs: []
  type: TYPE_NORMAL
- en: '| E_IfFalse : ∀(st st'' : state) (b[1] : bexp) (c[1] c[2] : com),'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = false →
  prefs: []
  type: TYPE_NORMAL
- en: c[2] / st ⇓ st' → (IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'
  prefs: []
  type: TYPE_NORMAL
- en: '| E_WhileEnd : ∀(b[1] : bexp) (st : state) (c[1] : com),'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = false → (WHILE b[1] DO c[1] END) / st ⇓ st
  prefs: []
  type: TYPE_NORMAL
- en: '| E_WhileLoop : ∀(st st'' st'''' : state) (b[1] : bexp) (c[1] : com),'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = true →
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / st ⇓ st' →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b[1] DO c[1] END) / st' ⇓ st'' →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b[1] DO c[1] END) / st ⇓ st''
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: where "c1 '/' st '⇓' st'" := (ceval c[1] st st').
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition hoare_triple (P:Assertion) (c:com) (Q:Assertion) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: ∀st st',
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st'  →
  prefs: []
  type: TYPE_NORMAL
- en: P st  →
  prefs: []
  type: TYPE_NORMAL
- en: Q st'.
  prefs: []
  type: TYPE_NORMAL
- en: Notation "{{ P }}  c  {{ Q }}" := (hoare_triple P c Q)
  prefs: []
  type: TYPE_NORMAL
- en: (at level 90, c at next level)
  prefs: []
  type: TYPE_NORMAL
- en: ': hoare_spec_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '{{ X + Y = Z }}'
  prefs: []
  type: TYPE_NORMAL
- en: IF[1] Y ≠ 0 THEN
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X + Y
  prefs: []
  type: TYPE_NORMAL
- en: FI
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X = Z }}'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Your proof of this triple may need to use the other proof'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rules also. Because we're working in a separate module, you'll
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: need to copy here the rules you find necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: WHILE b DO c END
  prefs: []
  type: TYPE_NORMAL
- en: and we want to find a pre-condition P and a post-condition
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Q such that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '{{P}} WHILE b DO c END {{P}}.'
  prefs: []
  type: TYPE_NORMAL
- en: But, as we remarked above for the conditional, we know a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: little more at the end — not just P, but also the fact
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that b is false in the current state.  So we can enrich the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'postcondition a little:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma hoare_while : ∀P b c,'
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ P st ∧ bassn b st}} c {{P}} →'
  prefs: []
  type: TYPE_NORMAL
- en: '{{P}} WHILE b DO c END {{fun st ⇒ P st ∧ ¬ (bassn b st)}}.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros P b c Hhoare st st' He HP.
  prefs: []
  type: TYPE_NORMAL
- en: (* Like we've seen before, we need to reason by induction      on He, because, in the "keep looping" case, its hypotheses
         talk about the whole loop instead of just c. *)
  prefs: []
  type: TYPE_NORMAL
- en: remember ([WHILE](Imp.html#::'WHILE'_x_'DO'_x_'END') b DO c END) as wcom eqn:Heqwcom.
  prefs: []
  type: TYPE_NORMAL
- en: induction He;
  prefs: []
  type: TYPE_NORMAL
- en: try (inversion Heqwcom); subst; clear Heqwcom.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E_WhileEnd *)'
  prefs: []
  type: TYPE_NORMAL
- en: split. assumption. apply [bexp_eval_false](Hoare.html#bexp_eval_false). assumption.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E_WhileLoop *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply IHHe2. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: apply (Hhoare st st'). assumption.
  prefs: []
  type: TYPE_NORMAL
- en: split. assumption. apply [bexp_eval_true](Hoare.html#bexp_eval_true). assumption.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: WHILE X = 2 DO X := 1 END
  prefs: []
  type: TYPE_NORMAL
- en: although it is clearly *not* preserved by the body of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We can use the WHILE rule to prove the following Hoare triple...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this result is not surprising if we remember that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the definition of hoare_triple asserts that the postcondition
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: must hold *only* when the command terminates.  If the command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: doesn't terminate, we can prove anything we like about the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: post-condition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Hoare rules that only talk about terminating commands are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: often said to describe a logic of "partial" correctness.  It is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: also possible to give Hoare rules for "total" correctness, which
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: build in the fact that the commands terminate. However, in this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: course we will only talk about partial correctness.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Module RepeatExercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive com : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| CSkip : com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CAsgn : id → aexp → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CSeq : com → com → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CIf : bexp → com → com → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CWhile : bexp → com → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CRepeat : com → bexp → com.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Notation "'SKIP'" :=
  prefs: []
  type: TYPE_NORMAL
- en: CSkip.
  prefs: []
  type: TYPE_NORMAL
- en: Notation "c1 ;; c2" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CSeq c[1] c[2]) (at level 80, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "X '::=' a" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CAsgn X a) (at level 60).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'WHILE' b 'DO' c 'END'" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CWhile b c) (at level 80, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'IFB' e1 'THEN' e2 'ELSE' e3 'FI'" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CIf e[1] e[2] e[3]) (at level 80, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'REPEAT' e1 'UNTIL' b2 'END'" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CRepeat e[1] b[2]) (at level 80, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive ceval : state → com → state → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| E_Skip : ∀st,'
  prefs: []
  type: TYPE_NORMAL
- en: ceval st SKIP st
  prefs: []
  type: TYPE_NORMAL
- en: '| E_Ass  : ∀st a[1] n X,'
  prefs: []
  type: TYPE_NORMAL
- en: aeval st a[1] = n →
  prefs: []
  type: TYPE_NORMAL
- en: ceval st (X ::= a[1]) (t_update st X n)
  prefs: []
  type: TYPE_NORMAL
- en: '| E_Seq : ∀c[1] c[2] st st'' st'''','
  prefs: []
  type: TYPE_NORMAL
- en: ceval st c[1] st' →
  prefs: []
  type: TYPE_NORMAL
- en: ceval st' c[2] st'' →
  prefs: []
  type: TYPE_NORMAL
- en: ceval st (c[1] ;; c[2]) st''
  prefs: []
  type: TYPE_NORMAL
- en: '| E_IfTrue : ∀st st'' b[1] c[1] c[2],'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = true →
  prefs: []
  type: TYPE_NORMAL
- en: ceval st c[1] st' →
  prefs: []
  type: TYPE_NORMAL
- en: ceval st (IFB b[1] THEN c[1] ELSE c[2] FI) st'
  prefs: []
  type: TYPE_NORMAL
- en: '| E_IfFalse : ∀st st'' b[1] c[1] c[2],'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = false →
  prefs: []
  type: TYPE_NORMAL
- en: ceval st c[2] st' →
  prefs: []
  type: TYPE_NORMAL
- en: ceval st (IFB b[1] THEN c[1] ELSE c[2] FI) st'
  prefs: []
  type: TYPE_NORMAL
- en: '| E_WhileEnd : ∀b[1] st c[1],'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = false →
  prefs: []
  type: TYPE_NORMAL
- en: ceval st (WHILE b[1] DO c[1] END) st
  prefs: []
  type: TYPE_NORMAL
- en: '| E_WhileLoop : ∀st st'' st'''' b[1] c[1],'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b[1] = true →
  prefs: []
  type: TYPE_NORMAL
- en: ceval st c[1] st' →
  prefs: []
  type: TYPE_NORMAL
- en: ceval st' (WHILE b[1] DO c[1] END) st'' →
  prefs: []
  type: TYPE_NORMAL
- en: ceval st (WHILE b[1] DO c[1] END) st''
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Notation "c1 '/' st '⇓' st'" := (ceval st c[1] st')
  prefs: []
  type: TYPE_NORMAL
- en: (at level 40, st at level 39).
  prefs: []
  type: TYPE_NORMAL
- en: Definition hoare_triple (P:Assertion) (c:com) (Q:Assertion)
  prefs: []
  type: TYPE_NORMAL
- en: ': Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: ∀st st', (c / st ⇓ st') → P st → Q st'.
  prefs: []
  type: TYPE_NORMAL
- en: Notation "{{ P }}  c  {{ Q }}" :=
  prefs: []
  type: TYPE_NORMAL
- en: (hoare_triple P c Q) (at level 90, c at next level).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Definition ex1_repeat :=
  prefs: []
  type: TYPE_NORMAL
- en: REPEAT
  prefs: []
  type: TYPE_NORMAL
- en: X ::= ANum 1;;
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= APlus (AId Y) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: UNTIL (BEq (AId X) (ANum 1)) END.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem ex1_repeat_works :'
  prefs: []
  type: TYPE_NORMAL
- en: ex1_repeat / empty_state ⇓
  prefs: []
  type: TYPE_NORMAL
- en: t_update (t_update empty_state X 1) Y 1.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '{{ X > 0 }}'
  prefs: []
  type: TYPE_NORMAL
- en: REPEAT
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= X;;
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  prefs: []
  type: TYPE_NORMAL
- en: UNTIL X = 0 END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X = 0 ∧ Y > 0 }}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Additional Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars (himp_hoare)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this exercise, we will derive proof rules for the HAVOC
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: command, which we studied in the last chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, we enclose this work in a separate module, and recall the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: syntax and big-step semantics of Himp commands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The definition of Hoare triples is exactly as before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Complete the Hoare rule for HAVOC commands below by defining
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: havoc_pre and prove that the resulting rule is correct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
