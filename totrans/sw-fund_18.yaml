- en: HoareHoare Logic, Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 霍尔逻辑，第一部分
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Require Import Coq.Bool.Bool.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Coq.Bool.Bool。
- en: Require Import Coq.Arith.Arith.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Coq.Arith.Arith。
- en: Require Import Coq.Arith.EqNat.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Coq.Arith.EqNat。
- en: Require Import Coq.omega.Omega.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Coq.omega.Omega。
- en: Require Import Imp.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Imp。
- en: Require Import Maps.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Maps.
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Assertions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断言
- en: To talk about specifications of programs, the first thing we
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要谈论程序的规范，第一件事
- en: need is a way of making *assertions* about properties that hold at
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要的是一种对在
- en: particular points during a program's execution — i.e., claims
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序执行期间的特定点 — 即，声明
- en: about the current state of the memory when execution reaches that
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当执行到达那时，关于内存的当前状态
- en: point.  Formally, an assertion is just a family of propositions
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点。形式上，一个断言只是一组命题
- en: indexed by a state.
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由状态索引。
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Exercise: 1 star, optional (assertions)'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1星，可选（断言）
- en: Paraphrase the following assertions in English (or your favorite
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用英语（或您喜欢的语言）改写以下断言
- en: natural language).
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自然语言）。
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ☐
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: This way of writing assertions can be a little bit heavy,
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种写断言的方式可能有点繁重，
- en: 'for two reasons: (1) every single assertion that we ever write is'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 出于两个原因：（1）我们写的每个断言都是
- en: going to begin with fun st ⇒ ; and (2) this state st is the
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 开始fun st ⇒；和（2）这个状态st是
- en: only one that we ever use to look up variables in assertions (we
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们唯一用来查找断言中变量的方法（我们
- en: will never need to talk about two different memory states at the
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 永远不需要谈论两个不同的内存状态
- en: same time).  For discussing examples informally, we'll adopt some
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时）。为了非正式讨论示例，我们将采用一些
- en: 'simplifying conventions: we''ll drop the initial fun st ⇒, and'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简化约定：我们会省略初始的fun st ⇒，和
- en: we'll write just X to mean st X.  Thus, instead of writing
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们只写X来表示st X。因此，而不是写
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Z * Z ≤ m ∧ ~((S Z) * (S Z) ≤ m).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Z * Z ≤ m ∧ ~((S Z) * (S Z) ≤ m)。
- en: This example also illustrates a convention that we'll use
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个例子还说明了我们将使用的一个约定
- en: 'throughout the Hoare Logic chapters: in informal assertions,'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在霍尔逻辑章节中始终：在非正式断言中，
- en: capital letters like {X], Y, and Z are Imp variables, while
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 像{X]，Y和Z这样的大写字母是Imp变量，而
- en: lowercase letters like x, y, m, and n are ordinary Coq
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小写字母如x，y，m和n是普通的Coq
- en: variables (of type nat).  This is why, when translating from
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变量（类型为nat）。这就是为什么在从
- en: informal to formal, we replace X with st X but leave m
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从非正式到正式，我们用st X替换X，但保留m
- en: alone.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单独。
- en: Given two assertions P and Q, we say that P *implies* Q,
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给定两个断言P和Q，我们说P *蕴含* Q，
- en: written P ⇾ Q (in ASCII, P ->> Q), if, whenever P
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 写作 P ⇾ Q（在ASCII中，P ->> Q），如果每当P
- en: holds in some state st, Q also holds.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在某个状态st中成立，Q也成立。
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: (The hoare_spec_scope annotation here tells Coq that this
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （hoare_spec_scope注释告诉Coq这
- en: notation is not global but is intended to be used in particular
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示不是全局的，而是打算在特定情况下使用
- en: contexts.  The Open Scope tells Coq that this file is one such
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上下文。Open Scope告诉Coq这是这样一个
- en: context.)
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上下文。）
- en: We'll also want the "iff" variant of implication between
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还希望在
- en: 'assertions:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 断言：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Hoare Triples
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 霍尔三元组
- en: Next, we need a way of making formal claims about the
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种对
- en: behavior of commands.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令的行为。
- en: In general, the behavior of a command is to transform one state to
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一般来说，命令的行为是将一个状态转换为
- en: another, so it is natural to express claims about commands in
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个，因此自然地表达关于命令的声明
- en: terms of assertions that are true before and after the command
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在命令之前和之后为真的断言条件
- en: 'executes:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行：
- en: '"If command c is started in a state satisfying assertion P, and if c eventually
    terminates in some final state, then this final state will satisfy the assertion
    Q."'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “如果命令c在满足断言P的状态下启动，并且如果c最终在某个最终状态中终止，那么这个最终状态将满足断言Q。”
- en: Such a claim is called a *Hoare Triple*.  The property P is
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样的声明称为*霍尔三元组*。属性P是
- en: called the *precondition* of c, while Q is the
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 称为c的*前置条件*，而Q是
- en: '*postcondition*.  Formally:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*后置条件*。形��上：'
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since we'll be working a lot with Hoare triples, it's useful to
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们将大量使用霍尔三元组，因此有用的是
- en: 'have a compact notation:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有一个紧凑的表示法：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notation "{{ P }}  c  {{ Q }}" :=
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 "{{ P }}  c  {{ Q }}" :=
- en: (hoare_triple P c Q) (at level 90, c at next level)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: （hoare_triple P c Q）（在级别90处，下一个级别的c）
- en: ': hoare_spec_scope.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ：hoare_spec_scope。
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 1) {{True}} c {{X = 5}}
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 1) {{True}} c {{X = 5}}
- en: 2) {{X = m}} c {{X = m + 5)}}
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 2) {{X = m}} c {{X = m + 5)}}
- en: 3) {{X ≤ Y}} c {{Y ≤ X}}
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 3) {{X ≤ Y}} c {{Y ≤ X}}
- en: 4) {{True}} c {{False}}
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 4) {{True}} c {{False}}
- en: 5) {{X = m}}
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 5) {{X = m}}
- en: c
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: c
- en: '{{Y = real_fact m}}'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '{{Y = real_fact m}}'
- en: 6) {{True}}
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 6) {{True}}
- en: c
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: c
- en: '{{(Z * Z) ≤ m ∧ ¬ (((S Z) * (S Z)) ≤ m)}}'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '{{(Z * Z) ≤ m ∧ ¬ (((S Z) * (S Z)) ≤ m)}}'
- en: ☐
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 1 star, optional (valid_triples)'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1星，可选（有效三元组）
- en: Which of the following Hoare triples are *valid* — i.e., the
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下哪些霍尔三元组是*有效*的 — 即，这些
- en: claimed relation between P, c, and Q is true?
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声称的P、c和Q之间的关系是真实的吗？
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Theorem hoare_post_true : ∀(P Q : Assertion) c,'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 定理hoare_post_true：∀(P Q：断言) c，
- en: (∀st, Q st) →
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: （∀st，Q st）→
- en: '{{P}} c {{Q}}.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '{{P}} c {{Q}}。'
- en: Proof.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: intros P Q c H. unfold [hoare_triple](Hoare.html#hoare_triple).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: intros P Q c H. unfold [hoare_triple](Hoare.html#hoare_triple).
- en: intros st st' Heval HP.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: intros st st' Heval HP。
- en: apply H. Qed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 应用H。已证明。
- en: 'Theorem hoare_pre_false : ∀(P Q : Assertion) c,'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 定理hoare_pre_false：∀(P Q：断言) c，
- en: (∀st, ~(P st)) →
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: （∀st, ~(P st)）→
- en: '{{P}} c {{Q}}.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '{{P}} c {{Q}}。'
- en: Proof.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: intros P Q c H. unfold [hoare_triple](Hoare.html#hoare_triple).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: intros P Q c H. unfold [hoare_triple](Hoare.html#hoare_triple).
- en: intros st st' Heval HP.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: intros st st' Heval HP。
- en: unfold [not](http://coq.inria.fr/library/Coq.Init.Logic.html#not) in H. apply
    H in HP.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在H中展开[not](http://coq.inria.fr/library/Coq.Init.Logic.html#not)。将H应用于HP。
- en: inversion HP. Qed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 反演HP。已证明。
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Assignment
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值
- en: The rule for assignment is the most fundamental of the Hoare logic
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 赋值的规则是霍尔逻辑中最基本的规则
- en: proof rules.  Here's how it works.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明规则。这是它的工作原理。
- en: 'Consider this valid Hoare triple:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑这个有效的霍尔三元组：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '{{ Y + Z = 1 }}  X ::= Y + Z  {{ X = 1 }}'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ Y + Z = 1 }}  X ::= Y + Z  {{ X = 1 }}'
- en: the same property (being equal to one) gets transferred to
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相同的属性（等于一）被转移到
- en: X from the expression Y + Z on the right-hand side of
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从右侧的表达式Y + Z转移到X
- en: the assignment.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 赋值。
- en: More generally, if a is *any* arithmetic expression, then
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更一般地说，如果a是*任何*算术表达式，那么
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '{{ Q [X ↦ a] }} X ::= a {{ Q }}'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ Q [X ↦ a] }} X ::= a {{ Q }}'
- en: where "Q [X ↦ a]" is pronounced "Q where a is substituted
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中“Q [X ↦ a]”发音为“Q其中a被替换
- en: for X".
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于X”。
- en: For example, these are valid applications of the assignment
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，这些是赋值的有效应用
- en: 'rule:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 规则：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Definition assn_sub X a P : Assertion :='
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 定义assn_sub X a P：断言 :=
- en: 'fun (st : state) ⇒'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'fun (st : state) ⇒'
- en: P (t_update st X (aeval st a)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: P（t_update st X（aeval st a））。
- en: Notation "P [ X |-> a ]" := (assn_sub X a P) (at level 10).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 符号“P [ X |-> a ]”：=（assn_sub X a P）（在级别10处）。
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: fun st ⇒
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: fun st ⇒
- en: (fun st' ⇒ st' X ≤ 5)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: （fun st' ⇒ st' X ≤ 5）
- en: (t_update st X (aeval st (ANum 3))),
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: （t_update st X （aeval st （ANum 3））），
- en: which simplifies to
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这简化为
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: fun st ⇒
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: fun st ⇒
- en: ((t_update st X 3) X) ≤ 5)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ((t_update st X 3) X) ≤ 5）
- en: and finally to
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后到
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: fun st ⇒
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: fun st ⇒
- en: (fun st' ⇒ st' X ≤ 5)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: (fun st' ⇒ st' X ≤ 5)
- en: (t_update st X (aeval st (APlus (AId X) (ANum 1)))),
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: （t_update st X (aeval st (APlus (AId X) (ANum 1))），
- en: which simplifies to
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这简化为
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: fun st ⇒
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: fun st ⇒
- en: (aeval st (APlus (AId X) (ANum 1))) ≤ 5.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: (aeval st (APlus (AId X) (ANum 1))) ≤ 5。
- en: That is, P' is the assertion that X+1 is at most 5.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也就是说，P'是X+1最多为5的断言。
- en: Now, using the concept of substitution, we can give the precise
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，使用替换的概念，我们可以给出精确的
- en: 'proof rule for assignment:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 赋值的证明规则：
- en: '|'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (hoare_asgn)
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （hoare_asgn）
- en: '|'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '{{Q [X ↦ a]}} X ::= a {{Q}}'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{Q [X ↦ a]}} X ::= a {{Q}}'
- en: '|'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: We can prove formally that this rule is indeed valid.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以正式证明这个规则确实是有效的。
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here's a first formal proof using this rule.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是使用这个规则的第一个正式证明。
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Exercise: 2 starsM (hoare_asgn_examples)'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2星M（hoare_asgn_examples）
- en: Translate these informal Hoare triples...
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 翻译这些非正式的霍尔三元组...
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: (* FILL IN HERE *)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*)
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: (* FILL IN HERE *)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*)
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Theorem hoare_asgn_fwd :'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 定理hoare_asgn_fwd：
- en: '(∀{X Y: Type} {f g : X → Y},'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '（∀{X Y: Type} {f g : X → Y}，'
- en: '(∀(x: X), f x = g x) →  f = g) →'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '（∀(x: X), f x = g x) →  f = g) →'
- en: ∀m a P,
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ∀m a P,
- en: '{{fun st ⇒ P st ∧ st X = m}}'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '{{fun st ⇒ P st ∧ st X = m}}'
- en: X ::= a
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= a
- en: '{{fun st ⇒ P (t_update st X m)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '{{fun st ⇒ P（t_update st X m）'
- en: ∧ st X = aeval (t_update st X m) a }}.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ∧ st X = aeval（t_update st X m）a }}。
- en: Proof.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已承认。
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Theorem hoare_asgn_fwd_exists :'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 定理hoare_asgn_fwd_exists：
- en: '(∀{X Y: Type} {f g : X → Y},'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '（∀{X Y: Type} {f g : X → Y}，'
- en: '(∀(x: X), f x = g x) →  f = g) →'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '（∀(x: X), f x = g x) →  f = g) →'
- en: ∀a P,
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ∀a P，
- en: '{{fun st ⇒ P st}}'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '{{fun st ⇒ P st}}'
- en: X ::= a
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= a
- en: '{{fun st ⇒ ∃m, P (t_update st X m) ∧'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '{{fun st ⇒ ∃m, P (t_update st X m) ∧'
- en: st X = aeval (t_update st X m) a }}.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: st X = aeval（t_update st X m）a }}。
- en: Proof.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros functional_extensionality a P.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: intros functional_extensionality a P。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已承认。
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Consequence
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: Sometimes the preconditions and postconditions we get from the
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时我们从中获得的前提条件和后置条件
- en: Hoare rules won't quite be the ones we want in the particular
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 霍尔规则在特定情况下不会完全是我们想要的
- en: situation at hand — they may be logically equivalent but have a
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 手头的情况 — 它们可能在逻辑上等价，但有一个
- en: different syntactic form that fails to unify with the goal we are
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与我们要解决的目标不一致的不同语法形式
- en: trying to prove, or they actually may be logically weaker (for
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试证明，或者它们实际上可能在逻辑上较弱（对于
- en: preconditions) or stronger (for postconditions) than what we need.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前提条件）或更强（对于后置条件）比我们需要的。
- en: For instance, while
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，当
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '{{True}} X ::= 3 {{X = 3}}'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '{{True}} X ::= 3 {{X = 3}}'
- en: does not.  This triple is valid, but it is not an instance of
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不是。这个三元组是有效的，但它不是
- en: hoare_asgn because True and (X = 3) [X ↦ 3] are not
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: hoare_asgn 因为 True 和 (X = 3) [X ↦ 3] 不是
- en: syntactically equal assertions.  However, they are logically
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 语法上相等的断言。然而，它们在逻辑上是
- en: '*equivalent*, so if one triple is valid, then the other must'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*等价*，因此如果一个三元组有效，则另一个必须'
- en: certainly be as well.  We can capture this observation with the
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 肯定也是如此。我们可以用两个*推论规则*来捕捉这一观察。
- en: 'following rule:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 遵循规则：
- en: '{{P''}} c {{Q}}'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{P''}} c {{Q}}'
- en: '|'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: P ⇿ P'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: P ⇿ P'
- en: '|'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (hoare_consequence_pre_equiv)
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: (hoare_consequence_pre_equiv)
- en: '|'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '{{P}} c {{Q}}'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{P}} c {{Q}}'
- en: '|'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Taking this line of thought a bit further, we can see that
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 进一步思考这一点，我们可以看到
- en: strengthening the precondition or weakening the postcondition of a
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 加强前置条件或减弱后置条件的
- en: valid triple always produces another valid triple. This
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有效的三元组总是产生另一个有效的三元组。这
- en: observation is captured by two *Rules of Consequence*.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 观察由两个*推论规则*捕捉。
- en: '{{P''}} c {{Q}}'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{P''}} c {{Q}}'
- en: '|'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: P ⇾ P'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: P ⇾ P'
- en: '|'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (hoare_consequence_pre)
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: (hoare_consequence_pre)
- en: '|'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '{{P}} c {{Q}}'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{P}} c {{Q}}'
- en: '|'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '{{P}} c {{Q''}}'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{P}} c {{Q''}}'
- en: '|'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: Q' ⇾ Q
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Q' ⇾ Q
- en: '|'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (hoare_consequence_post)
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: (hoare_consequence_post)
- en: '|'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '{{P}} c {{Q}}'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{P}} c {{Q}}'
- en: '|'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: 'Here are the formal versions:'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是正式版本：
- en: '[PRE27]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For example, we can use the first consequence rule like this:'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，我们可以像这样使用第一个推论规则：
- en: '[PRE28]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Example hoare_asgn_example1 :'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 例 hoare_asgn_example1：
- en: '{{fun st ⇒ True}} (X ::= (ANum 1)) {{fun st ⇒ st X = 1}}.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '{{fun st ⇒ True}} (X ::= (ANum 1)) {{fun st ⇒ st X = 1}}。'
- en: Proof.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* WORKED IN CLASS *)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在课堂上运行 *)
- en: apply hoare_consequence_pre
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 hoare_consequence_pre
- en: with (P' := (fun st ⇒ st X = 1) [X ↦ ANum 1]).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 (P' := (fun st ⇒ st X = 1) [X ↦ ANum 1])。
- en: apply hoare_asgn.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 hoare_asgn。
- en: intros st H. unfold assn_sub, t_update. simpl. reflexivity.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: intros st H。展开 assn_sub, t_update。简化。一致性。
- en: Qed.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: '[PRE29]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Theorem hoare_consequence : ∀(P P'' Q Q'' : Assertion) c,'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 hoare_consequence : ∀(P P'' Q Q'' : Assertion) c，'
- en: '{{P''}} c {{Q''}} →'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '{{P''}} c {{Q''}} →'
- en: P ⇾ P' →
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: P ⇾ P' →
- en: Q' ⇾ Q →
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Q' ⇾ Q →
- en: '{{P}} c {{Q}}.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '{{P}} c {{Q}}。'
- en: Proof.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: intros P P' Q Q' c Hht HPP' HQ'Q.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: intros P P' Q Q' c Hht HPP' HQ'Q。
- en: apply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre) with (P' :=
    P').
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [hoare_consequence_pre](https://Hoare.html#hoare_consequence_pre) 应用 (P'
    := P')。
- en: apply [hoare_consequence_post](Hoare.html#hoare_consequence_post) with (Q' :=
    Q').
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [hoare_consequence_post](https://Hoare.html#hoare_consequence_post) 应用 (Q'
    := Q')。
- en: assumption. assumption. assumption. Qed.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 假设。假设。假设。Qed。
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Example hoare_asgn_example1'' :'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 例 hoare_asgn_example1'：
- en: '{{fun st ⇒ True}}'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '{{fun st ⇒ True}}'
- en: (X ::= (ANum 1))
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: (X ::= (ANum 1))
- en: '{{fun st ⇒ st X = 1}}.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '{{fun st ⇒ st X = 1}}。'
- en: Proof.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: eapply hoare_consequence_pre.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: eapply hoare_consequence_pre。
- en: apply hoare_asgn.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 hoare_asgn。
- en: intros st H. reflexivity. Qed.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: intros st H。一致性。Qed。
- en: '[PRE31]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Lemma silly1 : ∀(P : nat → nat → Prop) (Q : nat → Prop),'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 silly1 : ∀(P : nat → nat → Prop) (Q : nat → Prop),'
- en: '(∀x y : nat, P x y) →'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '(∀x y : nat, P x y) →'
- en: '(∀x y : nat, P x y → Q x) →'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '(∀x y : nat, P x y → Q x) →'
- en: Q 42.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Q 42。
- en: Proof.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros P Q HP HQ. eapply HQ. apply HP.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: intros P Q HP HQ。eapply HQ。应用 HP。
- en: '[PRE32]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Abort.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 中止。
- en: '[PRE33]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Lemma silly2 :'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 引理 silly2：
- en: '∀(P : nat → nat → Prop) (Q : nat → Prop),'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '∀(P : nat → nat → Prop) (Q : nat → Prop)，'
- en: (∃y, P 42 y) →
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: (∃y, P 42 y) →
- en: '(∀x y : nat, P x y → Q x) →'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '(∀x y : nat, P x y → Q x) →'
- en: Q 42.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Q 42。
- en: Proof.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros P Q HP HQ. eapply HQ. destruct HP as [y HP'].
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: intros P Q HP HQ。eapply HQ。破坏 HP 为 [y HP']。
- en: '[PRE34]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Error: Impossible to unify "?175" with "y".
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：无法将"?175"统一为"y"。
- en: 'In this case there is an easy fix: doing destruct HP *before*'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下有一个简单的解决方法：在*之前*执行破坏 HP
- en: doing eapply HQ.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行 eapply HQ。
- en: '[PRE35]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The apply HP' in the last step unifies the existential variable
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一步中的 apply HP' 统一了存在变量
- en: in the goal with the variable y.
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在目标中的变量 y。
- en: Note that the assumption tactic doesn't work in this case, since
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在这种情况下假设策略不起作用，因为
- en: it cannot handle existential variables.  However, Coq also
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它无法处理存在变量。然而，Coq 也
- en: provides an eassumption tactic that solves the goal if one of
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提供了一个 eassumption 策略，如果其中一个解决目标
- en: the premises matches the goal up to instantiations of existential
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前提与目标匹配直到存在变量的实例化
- en: variables. We can use it instead of apply HP' if we like.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变量。我们可以使用它来代替 apply HP'。
- en: '[PRE36]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Exercise: 2 starsM (hoare_asgn_examples_2)'
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2 星 M (hoare_asgn_examples_2)
- en: Translate these informal Hoare triples...
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 翻译这些非正式的 Hoare 三元组...
- en: '[PRE37]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: (* FILL IN HERE *)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *)
- en: '[PRE38]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Skip
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳过
- en: Since SKIP doesn't change the state, it preserves any
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 SKIP 不改变状态，它保留任何
- en: 'property P:'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 属性 P：
- en: '|'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (hoare_skip)
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: (hoare_skip)
- en: '|'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '{{ P }} SKIP {{ P }}'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ P }} SKIP {{ P }}'
- en: '|'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE39]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Sequencing
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顺序
- en: More interestingly, if the command c[1] takes any state where
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更有趣的是，如果命令 c[1] 接受任何状态，其中
- en: P holds to a state where Q holds, and if c[2] takes any
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: P 成立到一个状态，其中 Q 成立，如果 c[2] 接受任何
- en: state where Q holds to one where R holds, then doing c[1]
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Q 成立到一个状态，其中 R 成立，然后执行 c[1]
- en: followed by c[2] will take any state where P holds to one
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后 c[2] 将接受任何状态，其中 P 成立到一个
- en: 'where R holds:'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中 R 成立：
- en: '{{ P }} c[1] {{ Q }}'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ P }} c[1] {{ Q }}'
- en: '|'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{ Q }} c[2] {{ R }}'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (hoare_seq)
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{ P }} c[1];;c[2] {{ R }}'
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that, in the formal rule hoare_seq, the premises are
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: given in backwards order (c[2] before c[1]).  This matches the
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: natural flow of information in many of the situations where we'll
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: use the rule, since the natural way to construct a Hoare-logic
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proof is to begin at the end of the program (with the final
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postcondition) and push postconditions backwards through commands
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: until we reach the beginning.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Informally, a nice way of displaying a proof using the sequencing
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rule is as a "decorated program" where the intermediate assertion
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Q is written between c[1] and c[2]:'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Example hoare_asgn_example3 : ∀a n,'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ aeval st a = n}}'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= a;; SKIP)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ st X = n}}.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: intros a n. eapply hoare_seq.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '- (* right part of seq *)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: apply hoare_skip.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '- (* left part of seq *)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: eapply hoare_consequence_pre. apply hoare_asgn.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: intros st H. subst. reflexivity.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '{{ True }} ⇾'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '{{ 1 = 1 }}'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: X ::= 1;;
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X = 1 }} ⇾'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X = 1 ∧ 2 = 2 }}'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= 2
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X = 1 ∧ Y = 2 }}'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: (Note the use of "⇾" decorations, each marking a use of
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hoare_consequence_pre.)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ☐
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars (swap_exercise)'
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write an Imp program c that swaps the values of X and Y and
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'show that it satisfies the following specification:'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Definition swap_program : com'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem swap_exercise :'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ st X ≤ st Y}}'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: swap_program
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ st Y ≤ st X}}.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ∀(a : aexp) (n : nat),
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ aeval st a = n}}'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= (ANum 3);; Y ::= a)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ st Y = n}}.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ☐
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '{{ True }}'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: IFB X == 0
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: THEN Y ::= 2
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: ELSE Y ::= X + 1
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: FI
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X ≤ Y }}'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: since the rule tells us nothing about the state in which the
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assignments take place in the "then" and "else" branches.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we can say something more precise.  In the
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"then" branch, we know that the boolean expression b evaluates to'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: true, and in the "else" branch, we know it evaluates to false.
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Making this information available in the premises of the rule gives
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: us more information to work with when reasoning about the behavior
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of c[1] and c[2] (i.e., the reasons why they establish the
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postcondition Q).
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{P ∧  b}} c[1] {{Q}}'
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{P ∧ ~b}} c[2] {{Q}}'
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (hoare_if)
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{P}} IFB b THEN c[1] ELSE c[2] FI {{Q}}'
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: To interpret this rule formally, we need to do a little work.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Strictly speaking, the assertion we've written, P ∧ b, is the
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: conjunction of an assertion and a boolean expression — i.e., it
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: doesn't typecheck.  To fix this, we need a way of formally
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"lifting" any bexp b to an assertion.  We''ll write bassn b for'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the assertion "the boolean expression b evaluates to true (in
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the given state)."
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A couple of useful facts about bassn:'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now we can formalize the Hoare proof rule for conditionals
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and prove it correct.
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Example
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is a formal proof that the program we used to motivate the
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rule satisfies the specification we gave.
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Exercise: 2 stars (if_minus_plus)'
  id: totrans-437
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prove the following hoare triple using hoare_if.  Do not
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 hoare_if 证明以下 hoare 三元组。不要
- en: use unfold hoare_triple.
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 unfold hoare_triple。
- en: '[PRE52]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ☐
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE53]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Module If[1].
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 模块 If[1]。
- en: 'Inductive com : Type :='
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 'Inductive com : Type :='
- en: '| CSkip : com'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '| CSkip : com'
- en: '| CAss : id → aexp → com'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '| CAss : id → aexp → com'
- en: '| CSeq : com → com → com'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '| CSeq : com → com → com'
- en: '| CIf : bexp → com → com → com'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '| CIf : bexp → com → com → com'
- en: '| CWhile : bexp → com → com'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '| CWhile : bexp → com → com'
- en: '| CIf1 : bexp → com → com.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '| CIf1 : bexp → com → com。'
- en: Notation "'SKIP'" :=
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: Notation "'SKIP'" :=
- en: CSkip.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: CSkip。
- en: Notation "c1 ;; c2" :=
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: Notation "c1 ;; c2" :=
- en: (CSeq c[1] c[2]) (at level 80, right associativity).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: (CSeq c[1] c[2]) (at level 80, right associativity)。
- en: Notation "X '::=' a" :=
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: Notation "X '::=' a" :=
- en: (CAss X a) (at level 60).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: (CAss X a) (at level 60)。
- en: Notation "'WHILE' b 'DO' c 'END'" :=
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: Notation "'WHILE' b 'DO' c 'END'" :=
- en: (CWhile b c) (at level 80, right associativity).
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: (CWhile b c) (at level 80, right associativity)。
- en: Notation "'IFB' e1 'THEN' e2 'ELSE' e3 'FI'" :=
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: Notation "'IFB' e1 'THEN' e2 'ELSE' e3 'FI'" :=
- en: (CIf e[1] e[2] e[3]) (at level 80, right associativity).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: (CIf e[1] e[2] e[3]) (at level 80, right associativity).
- en: Notation "'IF1' b 'THEN' c 'FI'" :=
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: Notation "'IF1' b 'THEN' c 'FI'" :=
- en: (CIf1 b c) (at level 80, right associativity).
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: (CIf1 b c) (at level 80, right associativity)。
- en: '[PRE54]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Reserved Notation "c1 '/' st '⇓' st'" (at level 40, st at level 39).
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: Reserved Notation "c1 '/' st '⇓' st'" (at level 40, st at level 39).
- en: 'Inductive ceval : com → state → state → Prop :='
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 'Inductive ceval : com → state → state → Prop :='
- en: '| E_Skip : ∀st : state, SKIP / st ⇓ st'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_Skip : ∀st : state, SKIP / st ⇓ st'
- en: '| E_Ass : ∀(st : state) (a[1] : aexp) (n : nat) (X : id),'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_Ass : ∀(st : state) (a[1] : aexp) (n : nat) (X : id),'
- en: aeval st a[1] = n → (X ::= a[1]) / st ⇓ t_update st X n
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: aeval st a[1] = n → (X ::= a[1]) / st ⇓ t_update st X n
- en: '| E_Seq : ∀(c[1] c[2] : com) (st st'' st'''' : state),'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_Seq : ∀(c[1] c[2] : com) (st st'' st'''' : state),'
- en: c[1] / st ⇓ st' → c[2] / st' ⇓ st'' → (c[1] ;; c[2]) / st ⇓ st''
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / st ⇓ st' → c[2] / st' ⇓ st'' → (c[1] ;; c[2]) / st ⇓ st''
- en: '| E_IfTrue : ∀(st st'' : state) (b[1] : bexp) (c[1] c[2] : com),'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_IfTrue : ∀(st st'' : state) (b[1] : bexp) (c[1] c[2] : com),'
- en: beval st b[1] = true →
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b[1] = true →
- en: c[1] / st ⇓ st' → (IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / st ⇓ st' → (IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'
- en: '| E_IfFalse : ∀(st st'' : state) (b[1] : bexp) (c[1] c[2] : com),'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_IfFalse : ∀(st st'' : state) (b[1] : bexp) (c[1] c[2] : com),'
- en: beval st b[1] = false →
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b[1] = false →
- en: c[2] / st ⇓ st' → (IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: c[2] / st ⇓ st' → (IFB b[1] THEN c[1] ELSE c[2] FI) / st ⇓ st'
- en: '| E_WhileEnd : ∀(b[1] : bexp) (st : state) (c[1] : com),'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_WhileEnd : ∀(b[1] : bexp) (st : state) (c[1] : com),'
- en: beval st b[1] = false → (WHILE b[1] DO c[1] END) / st ⇓ st
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b[1] = false → (WHILE b[1] DO c[1] END) / st ⇓ st
- en: '| E_WhileLoop : ∀(st st'' st'''' : state) (b[1] : bexp) (c[1] : com),'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_WhileLoop : ∀(st st'' st'''' : state) (b[1] : bexp) (c[1] : com),'
- en: beval st b[1] = true →
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b[1] = true →
- en: c[1] / st ⇓ st' →
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / st ⇓ st' →
- en: (WHILE b[1] DO c[1] END) / st' ⇓ st'' →
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b[1] DO c[1] END) / st' ⇓ st'' →
- en: (WHILE b[1] DO c[1] END) / st ⇓ st''
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b[1] DO c[1] END) / st ⇓ st''
- en: (* FILL IN HERE *)
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此处填写 *)
- en: where "c1 '/' st '⇓' st'" := (ceval c[1] st st').
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: where "c1 '/' st '⇓' st'" := (ceval c[1] st st')。
- en: '[PRE55]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Definition hoare_triple (P:Assertion) (c:com) (Q:Assertion) : Prop :='
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 hoare_triple (P:Assertion) (c:com) (Q:Assertion) : Prop :='
- en: ∀st st',
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: ∀st st'，
- en: c / st ⇓ st'  →
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: c / st ⇓ st'  →
- en: P st  →
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: P st  →
- en: Q st'.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: Q st'。
- en: Notation "{{ P }}  c  {{ Q }}" := (hoare_triple P c Q)
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: Notation "{{ P }}  c  {{ Q }}" := (hoare_triple P c Q)
- en: (at level 90, c at next level)
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: (at level 90, c at next level)
- en: ': hoare_spec_scope.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: ': hoare_spec_scope。'
- en: '[PRE56]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: (* FILL IN HERE *)
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此处填写 *)
- en: '[PRE57]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '{{ X + Y = Z }}'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ X + Y = Z }}'
- en: IF[1] Y ≠ 0 THEN
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: IF[1] Y ≠ 0 THEN
- en: X ::= X + Y
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= X + Y
- en: FI
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: FI
- en: '{{ X = Z }}'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ X = Z }}'
- en: 'Hint: Your proof of this triple may need to use the other proof'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示：你对这个三元组的证明可能需要使用其他证明
- en: rules also. Because we're working in a separate module, you'll
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也是规则。因为我们是在一个单独的模块中工作，你会
- en: need to copy here the rules you find necessary.
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要在此处复制你认为必要的规则。
- en: '[PRE58]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ☐
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE59]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: WHILE b DO c END
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: WHILE b DO c END
- en: and we want to find a pre-condition P and a post-condition
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而我们想要找到一个前置条件 P 和一个后置条件
- en: Q such that
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Q，使得
- en: '[PRE60]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '{{P}} WHILE b DO c END {{P}}.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '{{P}} WHILE b DO c END {{P}}。'
- en: But, as we remarked above for the conditional, we know a
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，正如我们上面对条件语句所述，我们知道一个
- en: little more at the end — not just P, but also the fact
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结尾处再多一点 —— 不仅仅是 P，还有事实
- en: that b is false in the current state.  So we can enrich the
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在当前状态下 b 是 false。所以我们可以丰富
- en: 'postcondition a little:'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将后置条件稍微修改一下：
- en: '[PRE61]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Lemma hoare_while : ∀P b c,'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma hoare_while : ∀P b c，'
- en: '{{fun st ⇒ P st ∧ bassn b st}} c {{P}} →'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '{{fun st ⇒ P st ∧ bassn b st}} c {{P}} →'
- en: '{{P}} WHILE b DO c END {{fun st ⇒ P st ∧ ¬ (bassn b st)}}.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '{{P}} WHILE b DO c END {{fun st ⇒ P st ∧ ¬ (bassn b st)}}。'
- en: Proof.
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: intros P b c Hhoare st st' He HP.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 P b c Hhoare st st' He HP。
- en: (* Like we've seen before, we need to reason by induction      on He, because, in the "keep looping" case, its hypotheses
         talk about the whole loop instead of just c. *)
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: (* 就像我们以前见过的那样，我们需要通过对 He 的归纳推理      进行推理，因为，在“继续循环”情况下，其假设      谈论整个循环而不仅仅是
    c。*)
- en: remember ([WHILE](Imp.html#::'WHILE'_x_'DO'_x_'END') b DO c END) as wcom eqn:Heqwcom.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 ([WHILE](Imp.html#::'WHILE'_x_'DO'_x_'END') b DO c END) 作为 wcom eqn:Heqwcom。
- en: induction He;
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 He;
- en: try (inversion Heqwcom); subst; clear Heqwcom.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（反转 Heqwcom）; 替换; 清除 Heqwcom。
- en: '- (* E_WhileEnd *)'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* E_WhileEnd *)'
- en: split. assumption. apply [bexp_eval_false](Hoare.html#bexp_eval_false). assumption.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 分割。假设。应用 [bexp_eval_false](Hoare.html#bexp_eval_false)。假设。
- en: '- (* E_WhileLoop *)'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* E_WhileLoop *)'
- en: apply IHHe2. reflexivity.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHHe2。一致性。
- en: apply (Hhoare st st'). assumption.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 (Hhoare st st')。假设。
- en: split. assumption. apply [bexp_eval_true](Hoare.html#bexp_eval_true). assumption.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 分割。假设。应用 [bexp_eval_true](Hoare.html#bexp_eval_true)。假设。
- en: Qed.
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结论。
- en: '[PRE62]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: WHILE X = 2 DO X := 1 END
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: WHILE X = 2 DO X := 1 END
- en: although it is clearly *not* preserved by the body of the
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管很明显 *不是* 被循环体保留的
- en: loop.
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 循环。
- en: '[PRE63]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We can use the WHILE rule to prove the following Hoare triple...
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用 WHILE 规则来证明以下 Hoare 三元组...
- en: '[PRE64]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Of course, this result is not surprising if we remember that
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，如果我们记得这一点，这个结果就不足为奇
- en: the definition of hoare_triple asserts that the postcondition
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: hoare_triple 的定义断言后条件
- en: must hold *only* when the command terminates.  If the command
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只有当命令终止时才能成立。如果命令
- en: doesn't terminate, we can prove anything we like about the
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不终止，我们可以证明任何我们想要的关于
- en: post-condition.
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 后条件。
- en: Hoare rules that only talk about terminating commands are
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只谈论终止命令的 Hoare 规则是
- en: often said to describe a logic of "partial" correctness.  It is
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 常常被描述为“部分”正确性的逻辑。这是
- en: also possible to give Hoare rules for "total" correctness, which
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还有可能为“完全”正确性制定 Hoare 规则，即
- en: build in the fact that the commands terminate. However, in this
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建在命令终止的事实之上。然而，在这个
- en: course we will only talk about partial correctness.
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然我们只会谈论部分正确性。
- en: '[PRE65]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Module RepeatExercise.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 模块 RepeatExercise。
- en: 'Inductive com : Type :='
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '诱导 com : Type :='
- en: '| CSkip : com'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '| CSkip : com'
- en: '| CAsgn : id → aexp → com'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '| CAsgn : id → aexp → com'
- en: '| CSeq : com → com → com'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '| CSeq : com → com → com'
- en: '| CIf : bexp → com → com → com'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '| CIf : bexp → com → com → com'
- en: '| CWhile : bexp → com → com'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '| CWhile : bexp → com → com'
- en: '| CRepeat : com → bexp → com.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '| CRepeat : com → bexp → com。'
- en: '[PRE66]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Notation "'SKIP'" :=
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 注释 "'SKIP'" :=
- en: CSkip.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: CSkip。
- en: Notation "c1 ;; c2" :=
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 注释 "c1 ;; c2" :=
- en: (CSeq c[1] c[2]) (at level 80, right associativity).
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: (CSeq c[1] c[2]) (at level 80, right associativity).
- en: Notation "X '::=' a" :=
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 注释 "X '::=' a" :=
- en: (CAsgn X a) (at level 60).
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: (CAsgn X a) (at level 60).
- en: Notation "'WHILE' b 'DO' c 'END'" :=
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 注释 "'WHILE' b 'DO' c 'END'" :=
- en: (CWhile b c) (at level 80, right associativity).
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: (CWhile b c) (at level 80, right associativity).
- en: Notation "'IFB' e1 'THEN' e2 'ELSE' e3 'FI'" :=
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 注释 "'IFB' e1 'THEN' e2 'ELSE' e3 'FI'" :=
- en: (CIf e[1] e[2] e[3]) (at level 80, right associativity).
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: (CIf e[1] e[2] e[3]) (at level 80, right associativity).
- en: Notation "'REPEAT' e1 'UNTIL' b2 'END'" :=
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 注释 "'REPEAT' e1 'UNTIL' b2 'END'" :=
- en: (CRepeat e[1] b[2]) (at level 80, right associativity).
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: (CRepeat e[1] b[2]) (at level 80, right associativity).
- en: '[PRE67]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Inductive ceval : state → com → state → Prop :='
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '诱导 ceval : state → com → state → Prop :='
- en: '| E_Skip : ∀st,'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_Skip : ∀st,'
- en: ceval st SKIP st
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: ceval st SKIP st
- en: '| E_Ass  : ∀st a[1] n X,'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_Ass  : ∀st a[1] n X,'
- en: aeval st a[1] = n →
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: aeval st a[1] = n →
- en: ceval st (X ::= a[1]) (t_update st X n)
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: ceval st (X ::= a[1]) (t_update st X n)
- en: '| E_Seq : ∀c[1] c[2] st st'' st'''','
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_Seq : ∀c[1] c[2] st st'' st'''','
- en: ceval st c[1] st' →
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: ceval st c[1] st' →
- en: ceval st' c[2] st'' →
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: ceval st' c[2] st'' →
- en: ceval st (c[1] ;; c[2]) st''
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: ceval st (c[1] ;; c[2]) st''
- en: '| E_IfTrue : ∀st st'' b[1] c[1] c[2],'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_IfTrue : ∀st st'' b[1] c[1] c[2],'
- en: beval st b[1] = true →
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b[1] = true →
- en: ceval st c[1] st' →
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: ceval st c[1] st' →
- en: ceval st (IFB b[1] THEN c[1] ELSE c[2] FI) st'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: ceval st (IFB b[1] THEN c[1] ELSE c[2] FI) st'
- en: '| E_IfFalse : ∀st st'' b[1] c[1] c[2],'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_IfFalse : ∀st st'' b[1] c[1] c[2],'
- en: beval st b[1] = false →
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b[1] = false →
- en: ceval st c[2] st' →
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: ceval st c[2] st' →
- en: ceval st (IFB b[1] THEN c[1] ELSE c[2] FI) st'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: ceval st (IFB b[1] THEN c[1] ELSE c[2] FI) st'
- en: '| E_WhileEnd : ∀b[1] st c[1],'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_WhileEnd : ∀b[1] st c[1],'
- en: beval st b[1] = false →
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b[1] = false →
- en: ceval st (WHILE b[1] DO c[1] END) st
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: ceval st (WHILE b[1] DO c[1] END) st
- en: '| E_WhileLoop : ∀st st'' st'''' b[1] c[1],'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_WhileLoop : ∀st st'' st'''' b[1] c[1],'
- en: beval st b[1] = true →
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b[1] = true →
- en: ceval st c[1] st' →
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: ceval st c[1] st' →
- en: ceval st' (WHILE b[1] DO c[1] END) st'' →
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: ceval st' (WHILE b[1] DO c[1] END) st'' →
- en: ceval st (WHILE b[1] DO c[1] END) st''
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: ceval st (WHILE b[1] DO c[1] END) st''
- en: (* FILL IN HERE *)
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: (* 填写这里 *)
- en: .
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 。
- en: '[PRE68]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Notation "c1 '/' st '⇓' st'" := (ceval st c[1] st')
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 注释 "c1 '/' st '⇓' st'" := (ceval st c[1] st')
- en: (at level 40, st at level 39).
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: (at level 40, st at level 39).
- en: Definition hoare_triple (P:Assertion) (c:com) (Q:Assertion)
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 hoare_triple (P:Assertion) (c:com) (Q:Assertion)
- en: ': Prop :='
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: ': Prop :='
- en: ∀st st', (c / st ⇓ st') → P st → Q st'.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: ∀st st', (c / st ⇓ st') → P st → Q st'。
- en: Notation "{{ P }}  c  {{ Q }}" :=
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 注释 "{{ P }}  c  {{ Q }}" :=
- en: (hoare_triple P c Q) (at level 90, c at next level).
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: (hoare_triple P c Q) (at level 90, c at next level).
- en: '[PRE69]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Definition ex1_repeat :=
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 ex1_repeat :=
- en: REPEAT
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 重复
- en: X ::= ANum 1;;
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= ANum 1;;
- en: Y ::= APlus (AId Y) (ANum 1)
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= APlus (AId Y) (ANum 1)
- en: UNTIL (BEq (AId X) (ANum 1)) END.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: UNTIL (BEq (AId X) (ANum 1)) END。
- en: 'Theorem ex1_repeat_works :'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 ex1_repeat_works：
- en: ex1_repeat / empty_state ⇓
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: ex1_repeat / empty_state ⇓
- en: t_update (t_update empty_state X 1) Y 1.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: t_update (t_update empty_state X 1) Y 1.
- en: Proof.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: (*填写这里*) 已证明。
- en: '[PRE70]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: (* FILL IN HERE *)
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: (*填写这里*)
- en: '[PRE71]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '{{ X > 0 }}'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ X > 0 }}'
- en: REPEAT
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 重复
- en: Y ::= X;;
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= X;;
- en: X ::= X - 1
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= X - 1
- en: UNTIL X = 0 END
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 X = 0 结束
- en: '{{ X = 0 ∧ Y > 0 }}'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ X = 0 ∧ Y > 0 }}'
- en: '[PRE72]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: ☐
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE73]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Additional Exercises
  id: totrans-634
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加练习
- en: 'Exercise: 3 stars (himp_hoare)'
  id: totrans-635
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3 颗星（himp_hoare）
- en: In this exercise, we will derive proof rules for the HAVOC
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将为 HAVOC 命令推导证明规则
- en: command, which we studied in the last chapter.
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在上一章中学习了的命令。
- en: First, we enclose this work in a separate module, and recall the
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们将这项工作放在一个单独的模块中，并回顾一下
- en: syntax and big-step semantics of Himp commands.
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Himp 命令的语法和大步语义。
- en: '[PRE74]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The definition of Hoare triples is exactly as before.
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Himp 三元组的定义与以前完全相同。
- en: '[PRE75]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Complete the Hoare rule for HAVOC commands below by defining
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过定义以下 HAVOC 命令的 Hoare 规则来完成以下任务
- en: havoc_pre and prove that the resulting rule is correct.
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: havoc_pre，并证明得到的规则是正确的。
- en: '[PRE76]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: ☐
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE77]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
