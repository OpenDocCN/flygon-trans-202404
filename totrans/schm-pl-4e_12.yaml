- en: Chapter 12\. Extended Examples
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 扩展示例
- en: This chapter presents a series of programs that perform more complicated tasks
    than most of the examples found throughout the earlier chapters of the book. They
    illustrate a variety of programming techniques and demonstrate a particular programming
    style.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一系列执行比本书前几章中大多数示例更复杂任务的程序。它们展示了各种编程技术，并演示了特定的编程风格。
- en: Each section of this chapter describes one program in detail and gives examples
    of its use. This is followed by a listing of the code. At the end of each section
    are exercises intended to stimulate thought about the program and to suggest possible
    extensions. These exercises are generally more difficult than those found in Chapters [2](start.html#g4)
    and [3](further.html#g49), and a few are major projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的每个部分都详细描述了一个程序，并给出了其使用示例。然后列出了代码清单。在每个部分的末尾都有旨在激发对程序的思考并提出可能扩展的练习。这些练习通常比第[2](start.html#g4)章和[3](further.html#g49)章中的练习更困难，有些是重大项目。
- en: Section [12.1](examples.html#g152) presents a simple matrix multiplication package.
    It demonstrates a set of procedures that could be written in almost any language.
    Its most interesting features are that all multiplication operations are performed
    by calling a single *generic* procedure, `mul`, which calls the appropriate help
    procedure depending upon the dimensions of its arguments, and that it dynamically
    allocates results of the proper size. Section [12.2](examples.html#g158) presents
    a merge sorting algorithm for ordering lists according to arbitrary predicates.
    Section [12.3](examples.html#g162) describes a syntactic form that is used to
    construct sets. It demonstrates a simple but efficient syntactic transformation
    from set notation to Scheme code. Section [12.4](examples.html#g169) presents
    a word-counting program borrowed from *The C Programming Language* [[19](bibliography.html#g237)],
    translated from C into Scheme. It shows character and string manipulation, data
    structure creation and manipulation, and basic file input and output. Section
    [12.5](examples.html#g176) presents a Scheme printer that implements basic versions
    of `put-datum`, `write`, and `display`. Section [12.6](examples.html#g180) presents
    a simple formatted output facility similar to those found in many Scheme systems
    and in other languages. Section [12.7](examples.html#g187) presents a simple interpreter
    for Scheme that illustrates Scheme as a language implementation vehicle while
    giving an informal operational semantics for Scheme as well as a useful basis
    for investigating extensions to Scheme. Section [12.8](examples.html#g193) presents
    a small, extensible abstract object facility that could serve as the basis for
    an entire object-oriented subsystem. Section [12.9](examples.html#g198) presents
    a recursive algorithm for computing the Fourier transform of a sequence of input
    values. It highlights the use of Scheme's complex arithmetic. Section [12.10](examples.html#g204)
    presents a concise unification algorithm that shows how procedures can be used
    as continuations and as substitutions (unifiers) in Scheme. Section [12.11](examples.html#g208)
    describes a multitasking facility and its implementation in terms of continuations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第[12.1](examples.html#g152)节介绍了一个简单的矩阵乘法包。它展示了一组几乎可以用任何语言编写的过程。其最有趣的特点是，所有乘法操作都是通过调用一个*通用*过程`mul`来执行的，该过程根据其参数的维度调用适当的辅助过程，并且动态分配适当大小的结果。第[12.2](examples.html#g158)节介绍了一个用于根据任意谓词对列表进行排序的归并排序算法。第[12.3](examples.html#g162)节描述了一种用于构建集合的语法形式。它展示了从集合表示到Scheme代码的简单但高效的语法转换。第[12.4](examples.html#g169)节介绍了从*C语言程序设计*[[19](bibliography.html#g237)]中借鉴的一个单词计数程序，将其从C语言翻译成Scheme。它展示了字符和字符串操作，数据结构的创建和操作，以及基本的文件输入和输出。第[12.5](examples.html#g176)节介绍了一个实现`put-datum`、`write`和`display`基本版本的Scheme打印机。第[12.6](examples.html#g180)节介绍了一个类似于许多Scheme系统和其他语言中找到的简单格式化输出工具。第[12.7](examples.html#g187)节介绍了一个用于Scheme的简单解释器，展示了Scheme作为一种语言实现工具，同时为Scheme提供了一种非正式的操作语义以及用于研究Scheme扩展的有用基础。第[12.8](examples.html#g193)节介绍了一个小型、可扩展的抽象对象工具，可以作为整个面向对象子系统的基础。第[12.9](examples.html#g198)节介绍了一个用于计算输入值序列的傅立叶变换的递归算法。它突出了Scheme的复数算术的使用。第[12.10](examples.html#g204)节介绍了一个简洁的统一算法，展示了如何在Scheme中将过程用作延续和替换（统一器）。第[12.11](examples.html#g208)节描述了一个多任务设施及其以延续为基础的实现。
- en: Section 12.1\. Matrix and Vector Multiplication
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第12.1节 矩阵和向量乘法
- en: This example program involves mostly basic programming techniques. It demonstrates
    simple arithmetic and vector operations, looping with the `do` syntactic form,
    dispatching based on object type, and raising exceptions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例程序主要涉及基本的编程技术。它演示了简单的算术和向量操作、使用`do`语法形式进行循环、基于对象类型进行分派以及引发异常。
- en: Multiplication of scalar to scalar, scalar to matrix, or matrix to matrix is
    performed by a single *generic* procedure, called `mul`. `mul` is called with
    two arguments, and it decides based on the types of its arguments what operation
    to perform. Because scalar operations use Scheme's multiplication procedure, `*`,
    `mul` scalars can be any built-in numeric type (exact or inexact complex, real,
    rational, or integer).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 标量乘以标量、标量乘以矩阵或矩阵乘以矩阵是通过一个名为`mul`的单一*通用*过程执行的。`mul`接受两个参数，并根据其参数的类型决定执行什么操作。因为标量操作使用Scheme的乘法过程`*`，`mul`的标量可以是任何内置数值类型（精确或非精确复数、实数、有理数或整数）。
- en: The product of an *m* × *n* matrix *A* and an *n* × *p* matrix *B* is the *m*
    × *p* matrix *C* whose entries are defined by
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*m*×*n*矩阵*A*和*n*×*p*矩阵*B*的乘积是由以下定义的*m*×*p*矩阵*C*的元素'
- en: '![<graphic>](26.gif)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](26.gif)'
- en: The product of a scalar *x* and an *m* × *n* matrix *A* is the *m* × *n* matrix
    *C* whose entries are defined by the equation
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 标量*x*和*m*×*n*矩阵*A*的乘积是由以下方程定义的*m*×*n*矩阵*C*，其元素为
- en: '*C*[*ij*] = *xA*[*ij*].'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*C*[*ij*] = *xA*[*ij*].'
- en: That is, each element of *C* is the product of *x* and the corresponding element
    of *A*. Vector-vector, vector-matrix, and matrix-vector multiplication may be
    considered special cases of matrix-matrix multiplication, where a vector is represented
    as a 1 × *n* or *n* × 1 matrix.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*C*的每个元素是*x*和*A*对应元素的乘积。向量-向量、向量-矩阵和矩阵-向量乘法可以看作是矩阵-矩阵乘法的特殊情况，其中向量表示为1 ×
    *n*或*n* × 1矩阵。
- en: Here are a few examples, each preceded by the equivalent operation in standard
    mathematical notation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例，每个示例前面都有标准数学符号表示的等效操作。
- en: 'Scalar times scalar:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量乘以标量：
- en: 3 × 4 = 12
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 × 4 = 12
- en: '`(mul 3 4) ![<graphic>](ch2_0.gif) 12`'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`(mul 3 4) ![<graphic>](ch2_0.gif) 12`'
- en: 'Scalar times vector (1 × 3 matrix):'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量乘以向量（1 × 3矩阵）：
- en: '![<graphic>](27.gif)'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![<graphic>](27.gif)'
- en: '`(mul 1/2 ''#(#(1 2 3))) ![<graphic>](ch2_0.gif) #(#(1/2 1 3/2))`'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`(mul 1/2 ''#(#(1 2 3))) ![<graphic>](ch2_0.gif) #(#(1/2 1 3/2))`'
- en: 'Scalar times matrix:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量乘以矩阵：
- en: '![<graphic>](28.gif)'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![<graphic>](28.gif)'
- en: '`(mul -2'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`(mul -2'
- en: '''#(#(3 -2 -1)'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''#(#(3 -2 -1)'
- en: '#(-3 0 -5)'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#(-3 0 -5)'
- en: '#(7 -1 -1))) ![<graphic>](ch2_0.gif) #(#(-6 4 2)'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#(7 -1 -1))) ![<graphic>](ch2_0.gif) #(#(-6 4 2)'
- en: '![](ch3_ghostRightarrow.gif)   #(6 0 10)'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](ch3_ghostRightarrow.gif)   #(6 0 10)'
- en: '![](ch3_ghostRightarrow.gif)   #(-14 2 2))`'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![](ch3_ghostRightarrow.gif)   #(-14 2 2))`'
- en: 'Vector times matrix:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量乘以矩阵：
- en: '![<graphic>](29.gif)'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![<graphic>](29.gif)'
- en: '`(mul ''#(#(1 2 3))'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`(mul ''#(#(1 2 3))'
- en: '''#(#(2 3)'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''#(#(2 3)'
- en: '#(3 4)'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#(3 4)'
- en: '#(4 5))) ![<graphic>](ch2_0.gif) #(#(20 26))`'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#(4 5))) ![<graphic>](ch2_0.gif) #(#(20 26))`'
- en: 'Matrix times vector:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵乘以向量：
- en: '![<graphic>](30.gif)'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![<graphic>](30.gif)'
- en: '`(mul ''#(#(2 3 4)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`(mul ''#(#(2 3 4)'
- en: '#(3 4 5))'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#(3 4 5))'
- en: '''#(#(1) #(2) #(3))) ![<graphic>](ch2_0.gif) #(#(20) #(26))`'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''#(#(1) #(2) #(3))) ![<graphic>](ch2_0.gif) #(#(20) #(26))`'
- en: 'Matrix times matrix:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵乘以矩阵：
- en: '![<graphic>](31.gif)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![<graphic>](31.gif)'
- en: '`(mul ''#(#(1 2 3)'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`(mul ''#(#(1 2 3)'
- en: '#(4 5 6))'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#(4 5 6))'
- en: '''#(#(1 2 3 4)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''#(#(1 2 3 4)'
- en: '#(2 3 4 5)'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#(2 3 4 5)'
- en: '#(3 4 5 6))) ![<graphic>](ch2_0.gif) #(#(14 20 26 32)'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#(3 4 5 6))) ![<graphic>](ch2_0.gif) #(#(14 20 26 32)'
- en: '![](ch3_ghostRightarrow.gif)   #(32 47 62 77))`'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![](ch3_ghostRightarrow.gif)   #(32 47 62 77))`'
- en: The code for `mul` and its helpers, which is structured as a library, appears
    below. The first few definitions establish a set of procedures that support the
    matrix data type. A matrix is a vector of vectors. Included are a procedure to
    create matrices, procedures to access and assign matrix elements, and a matrix
    predicate. Following these definitions is the definition of `mul` itself. Inside
    the `lambda` expression for `mul` are a set of definitions for help procedures
    that support `mul`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`mul`及其辅助程序的代码，结构化为一个库，如下所示。前几个定义建立了一组支持矩阵数据类型的过程。矩阵是向量的向量。包括创建矩阵的过程、访问和分配矩阵元素的过程以及矩阵谓词。在这些定义之后是`mul`本身的定义。在`mul`的`lambda`表达式内部是一组支持`mul`的辅助程序的定义。'
- en: '`mul` checks the types of its arguments and chooses the appropriate help procedure
    to do the work. Each helper operates on arguments of specific types. For example,
    `mat-sca-mul` multiplies a matrix by a scalar. If the type of either argument
    is invalid or the arguments are incompatible, e.g., rows or columns do not match
    up, `mul` or one of its helpers raises an exception.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`mul`检查其参数的类型，并选择适当的辅助过程来完成工作。每个辅助程序都操作特定类型的参数。例如，`mat-sca-mul`将矩阵乘以标量。如果任一参数的类型无效或参数不兼容，例如，行或列不匹配，`mul`或其其中一个辅助程序会引发异常。'
- en: '`(library (tspl matrix)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`(library (tspl matrix)'
- en: (export make-matrix matrix? matrix-rows matrix-columns
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: (export make-matrix matrix? matrix-rows matrix-columns
- en: matrix-ref matrix-set! mul)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: matrix-ref matrix-set! mul)
- en: (import (rnrs))
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: (import (rnrs))
- en: ; make-matrix creates a matrix (a vector of vectors).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ; make-matrix 创建一个矩阵（向量的向量）。
- en: (define make-matrix
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: (define make-matrix
- en: (lambda (rows columns)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (rows columns)
- en: (do ([m (make-vector rows)]
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([m (make-vector rows)]
- en: '[i 0 (+ i 1)])'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[i 0 (+ i 1)])'
- en: ((= i rows) m)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ((= i rows) m)
- en: (vector-set! m i (make-vector columns)))))
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: (vector-set! m i (make-vector columns)))))
- en: ; matrix? checks to see if its argument is a matrix.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ; matrix? 检查其参数是否为矩阵。
- en: ; It isn't foolproof, but it's generally good enough.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ; 虽然不是绝对可靠，但通常足够好。
- en: (define matrix?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: (define matrix?
- en: (lambda (x)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (and (vector? x)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: (and (vector? x)
- en: (> (vector-length x) 0)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: (> (vector-length x) 0)
- en: (vector? (vector-ref x 0)))))
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: (vector? (vector-ref x 0)))))
- en: ; matrix-rows returns the number of rows in a matrix.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ; matrix-rows 返回矩阵中的行数。
- en: (define matrix-rows
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: (define matrix-rows
- en: (lambda (x)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (vector-length x)))
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: (vector-length x)))
- en: ; matrix-columns returns the number of columns in a matrix.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ; matrix-columns 返回矩阵中的列数。
- en: (define matrix-columns
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: (define matrix-columns
- en: (lambda (x)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (what)
- en: (vector-length (vector-ref x 0))))
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: (vector-length (vector-ref x 0))))
- en: ; matrix-ref returns the jth element of the ith row.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ; matrix-ref 返回第i行的第j个元素。
- en: (define matrix-ref
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: (define matrix-ref
- en: (lambda (m i j)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (m i j)
- en: (vector-ref (vector-ref m i) j)))
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: (vector-ref (vector-ref m i) j)))
- en: ; matrix-set! changes the jth element of the ith row.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ; matrix-set! changes the jth element of the ith row.
- en: (define matrix-set!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: (define matrix-set!
- en: (lambda (m i j x)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (m i j x)
- en: (vector-set! (vector-ref m i) j x)))
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: (vector-set! (vector-ref m i) j x)))
- en: ; mat-sca-mul multiplies a matrix by a scalar.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ; mat-sca-mul 将矩阵乘以标量。
- en: (define mat-sca-mul
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: (define mat-sca-mul
- en: (lambda (m x)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (m x)
- en: (let* ([nr (matrix-rows m)]
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: (let* ([nr (matrix-rows m)]
- en: '[nc (matrix-columns m)]'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[nc (matrix-columns m)]'
- en: '[r (make-matrix nr nc)])'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[r (make-matrix nr nc)])'
- en: (do ([i 0 (+ i 1)])
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([i 0 (+ i 1)])
- en: ((= i nr) r)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ((= i nr) r)
- en: (do ([j 0 (+ j 1)])
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([j 0 (+ j 1)])
- en: ((= j nc))
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ((= j nc))
- en: (matrix-set! r i j (* x (matrix-ref m i j))))))))
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: (matrix-set! r i j (* x (matrix-ref m i j))))))))
- en: ; mat-mat-mul multiplies one matrix by another, after verifying
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ; mat-mat-mul 将一个矩阵乘以另一个矩阵，在验证后进行
- en: ; that the first matrix has as many columns as the second
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ; 第一个矩阵的列数与第二个矩阵的列数相同
- en: ; matrix has rows.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ; 矩阵有行。
- en: (define mat-mat-mul
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: (define mat-mat-mul
- en: (lambda (m1 m2)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (m1 m2)
- en: (let* ([nr1 (matrix-rows m1)]
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: (let* ([nr1 (matrix-rows m1)]
- en: '[nr2 (matrix-rows m2)]'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[nr2 (matrix-rows m2)]'
- en: '[nc2 (matrix-columns m2)]'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[nc2 (矩阵列数 m2)]'
- en: '[r (make-matrix nr1 nc2)])'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[r (make-matrix nr1 nc2)])'
- en: (unless (= (matrix-columns m1) nr2) (match-error m1 m2))
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: (unless (= (matrix-columns m1) nr2) (match-error m1 m2))
- en: (do ([i 0 (+ i 1)])
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([i 0 (+ i 1)])
- en: ((= i nr1) r)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ((= i nr1) r)
- en: (do ([j 0 (+ j 1)])
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([j 0 (+ j 1)])
- en: ((= j nc2))
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ((= j nc2))
- en: (do ([k 0 (+ k 1)]
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([k 0 (+ k 1)]
- en: '[a 0 (+ a'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[a 0 (+ a'
- en: (* (matrix-ref m1 i k)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: (* (matrix-ref m1 i k)
- en: (matrix-ref m2 k j)))])
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: (matrix-ref m2 k j)))])
- en: ((= k nr2)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ((= k nr2)
- en: (matrix-set! r i j a))))))))
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: (matrix-set! r i j a))))))))
- en: ; type-error is called to complain when mul receives an invalid
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ; 当mul接收到无效的参数时，调用type-error进行投诉
- en: ; type of argument.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ; 参数的类型。
- en: (define type-error
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: (define type-error
- en: (lambda (what)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (what)
- en: (assertion-violation 'mul
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: (assertion-violation 'mul
- en: '"not a number or matrix"'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '"不是数字或矩阵"'
- en: what)))
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: what)))
- en: ; match-error is called to complain when mul receives a pair of
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ; match-error 在mul接收到一对
- en: ; incompatible arguments.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ; 不兼容的参数。
- en: (define match-error
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: (define match-error
- en: (lambda (what1 what2)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (what1 what2)
- en: (assertion-violation 'mul
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: (assertion-violation 'mul
- en: '"incompatible operands" what1'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '"不兼容的操作数" what1'
- en: what2)))
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: what2)))
- en: ; mul is the generic matrix/scalar multiplication procedure
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ; mul is the generic matrix/scalar multiplication procedure
- en: (define mul
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: (define mul
- en: (lambda (x y)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x y)
- en: (cond
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(number? x)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[(number? x)'
- en: (cond
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(number? y) (* x y)]'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[(number? y) (* x y)]'
- en: '[(matrix? y) (mat-sca-mul y x)]'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[(matrix? y) (mat-sca-mul y x)]'
- en: '[else (type-error y)])]'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (type-error y)])]'
- en: '[(matrix? x)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[(matrix? x)'
- en: (cond
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(number? y) (mat-sca-mul x y)]'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[(number? y) (mat-sca-mul x y)]'
- en: '[(matrix? y) (mat-mat-mul x y)]'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[(matrix? y) (mat-mat-mul x y)]'
- en: '[else (type-error y)])]'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (type-error y)])]'
- en: '[else (type-error x)]))))`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (type-error x)]))))`'
- en: Exercise 12.1.1
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.1.1
- en: Make the necessary changes to rename `mul` to `*`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 进行必要的更改，将`mul`重命名为`*`。
- en: Exercise 12.1.2
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.1.2
- en: The predicate `matrix?` is usually sufficient but not completely reliable, since
    it may return `#t` for objects that are not matrices. In particular, it does not
    verify that all of the matrix rows are vectors, that each row has the same number
    of elements, or that the elements themselves are numbers. Modify `matrix?` to
    perform each of these additional checks.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词`matrix?`通常足够，但不完全可靠，因为它可能对不是矩阵的对象返回`#t`。特别是，它不验证所有矩阵行是否为向量，每行是否具有相同数量的元素，或元素本身是否为数字。修改`matrix?`以执行这些额外检查。
- en: Exercise 12.1.3
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.1.3
- en: Another solution to Exercise [12.1.2](examples.html#g154) is to define a matrix
    record type encapsulating the vectors of the matrix. If the matrix creation routine
    never allows a malformed matrix record to be created, a matrix record check is
    the only check needed to ensure that the input is well formed. Define a matrix
    record type and recode the library to use it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 练习[12.1.2](examples.html#g154)的另一个解决方案是定义一个封装矩阵向量的矩阵记录类型。如果矩阵创建例程永远不允许创建格式不正确的矩阵记录，则矩阵记录检查是确保输入格式正确所需的唯一检查。定义一个矩阵记录类型并重新编写库以使用它。
- en: Exercise 12.1.4
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.1.4
- en: Write similar generic procedures for addition and subtraction. Devise a generic
    `dispatch` procedure or syntactic form so that the type dispatching code need
    not be rewritten for each new operation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为加法和减法编写类似的通用过程。设计一个通用的`dispatch`过程或语法形式，以便类型分派代码不需要为每个新操作重新编写。
- en: Exercise 12.1.5
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.1.5
- en: This version of `mul` uses vectors of vectors to represent matrices. Rewrite
    the system, using nested lists to represent matrices. What efficiency is gained
    or lost by this change?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`mul`的版本使用向量的向量来表示矩阵。使用嵌套列表来表示矩阵重新编写系统。通过这种改变获得或失去了什么效率？
- en: Section 12.2\. Sorting
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 12.2 节。排序
- en: 'This section illustrates a list sorting algorithm based on a simple technique
    known as merge sorting. The procedure `sort` defined here accepts two arguments:
    a predicate and a list, just like the built-in `list-sort`. It returns a list
    containing the elements of the old list sorted according to the predicate. As
    with `list-sort`, the predicate should be a procedure that expects two arguments
    and returns `#t` if its first argument must precede its second in the sorted list
    and false otherwise. That is, if the predicate is applied to two elements `*x*`
    and `*y*`, where `*x*` appears after `*y*` in the input list, it should return
    true only if `*x*` should appear before `*y*` in the output list. If this constraint
    is met, `sort` will perform a *stable sort*; with a stable sort, two elements
    that are already sorted with respect to each other will appear in the output in
    the same order in which they appeared in the input. Thus, sorting a list that
    is already sorted will result in no reordering, even if there are equivalent elements.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了一种基于称为归并排序的简单技术的列表排序算法。这里定义的`sort`过程接受两个参数：一个谓词和一个列表，就像内置的`list-sort`一样。它返回一个包含旧列表元素的列表，根据谓词排序。与`list-sort`一样，谓词应该是一个期望两个参数并在排序列表中第一个参数必须在第二个参数之前的过程，否则返回`#t`的过程。也就是说，如果谓词应用于两个元素`*x*`和`*y*`，其中`*x*`在输入列表中出现在`*y*`之后，则仅当`*x*`应该在输出列表中出现在`*y*`之前时才返回true。如果满足此约束条件，`sort`将执行*稳定排序*；对于稳定排序，已经相对于彼此排序的两个元素将以它们在输入中出现的顺序出现在输出中。因此，对已经排序的列表进行排序将导致不重新排序，即使存在等效元素。
- en: '`(sort < ''(3 4 2 1 2 5)) ![<graphic>](ch2_0.gif) (1 2 2 3 4 5)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`(sort < ''(3 4 2 1 2 5)) ![<graphic>](ch2_0.gif) (1 2 2 3 4 5)'
- en: (sort > '(0.5 1/2)) ![<graphic>](ch2_0.gif) (0.5 1/2)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: (sort > '(0.5 1/2)) ![<graphic>](ch2_0.gif) (0.5 1/2)
- en: (sort > '(1/2 0.5)) ![<graphic>](ch2_0.gif) (1/2 0.5)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: (sort > '(1/2 0.5)) ![<graphic>](ch2_0.gif) (1/2 0.5)
- en: (list->string
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: (list->string
- en: (sort char>?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: (sort char>?
- en: (string->list "coins"))) ![<graphic>](ch2_0.gif) "sonic"`
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: (string->list "coins"))) ![<graphic>](ch2_0.gif) "sonic"`
- en: A companion procedure, `merge`, is also defined by the code. `merge` accepts
    a predicate and two sorted lists and returns a merged list in sorted order of
    the elements of the two lists. With a properly defined predicate, `merge` is also
    stable in the sense that an item from the first list will appear before an item
    from the second list unless it is necessary that the item from the second list
    appear first.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 代码还定义了一个伴随过程`merge`。`merge`接受一个谓词和两个排序列表，并返回两个列表元素按排序顺序合并的列表。通过正确定义的谓词，`merge`也是稳定的，即第一个列表中的项目将出现在第二个列表中的项目之前，除非必须使第二个列表中的项目首先出现。
- en: '`(merge char<?'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`(merge char<?'
- en: '''(#\a #\c)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '''(#\a #\c)'
- en: '''(#\b #\c #\d)) ![<graphic>](ch2_0.gif) (#\a #\b #\c #\c #\d)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '''(#\b #\c #\d)) ![<graphic>](ch2_0.gif) (#\a #\b #\c #\c #\d)'
- en: (merge <
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: (merge <
- en: '''(1/2 2/3 3/4)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`''(1/2 2/3 3/4)`'
- en: '''(0.5 0.6 0.7)) ![<graphic>](ch2_0.gif) (1/2 0.5 0.6 2/3 0.7 3/4)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`''(0.5 0.6 0.7))` ![<graphic>](ch2_0.gif) `(1/2 0.5 0.6 2/3 0.7 3/4)`'
- en: (list->string
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`(list->string`'
- en: (merge char>?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`(merge char>?`'
- en: (string->list "old")
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`(string->list "old")`'
- en: (string->list "toe"))) ![<graphic>](ch2_0.gif) "tooled"`
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`(string->list "toe")))` ![<graphic>](ch2_0.gif) `"tooled"`'
- en: The merge sorting algorithm is simple and elegant. The input list is split into
    two approximately equal sublists. These sublists are sorted recursively, yielding
    two sorted lists. The sorted lists are then merged to form a single sorted list.
    The base case for the recursion is a list of one element, which is already sorted.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序算法简单而优雅。输入列表被拆分成两个大致相等的子列表。这些子列表被递归排序，产生两个排序好的列表。然后将这些排序好的列表合并成一个排序好的列表。递归的基本情况是一个元素的列表，这个列表已经排序好了。
- en: To reduce overhead, the implementation computes the length of the input list
    once, in `sort`, rather than at each step of the recursion, in `dosort`. This
    also allows `dosort` to isolate the first half of the list merely by halving the
    length, saving the cost of allocating a new list containing half of the elements.
    As a result, `ls` may contain more than `n` elements, but only the first `n` elements
    are considered part of the list.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少开销，实现在 `sort` 中一次计算输入列表的长度，而不是在递归的每一步中都计算，这样做也允许 `dosort` 仅通过将长度减半来隔离列表的前一半，从而节省了分配新列表包含一半元素的成本。因此，`ls`
    可能包含超过 `n` 个元素，但只有前 `n` 个元素被视为列表的一部分。
- en: '`(library (tspl sort)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: \`(library (tspl sort)`
- en: (export sort merge)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`(export sort merge)`'
- en: (import (rnrs))
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`(import (rnrs))`'
- en: (define dosort
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define dosort`'
- en: (lambda (pred? ls n)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (pred? ls n)`'
- en: (if (= n 1)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`(if (= n 1)`'
- en: (list (car ls))
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`(list (car ls))`'
- en: (let ([i (div n 2)])
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([i (div n 2)])`'
- en: (domerge pred?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`(domerge pred?`'
- en: (dosort pred? ls i)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`(dosort pred? ls i)`'
- en: (dosort pred? (list-tail ls i) (- n i)))))))
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`(dosort pred? (list-tail ls i) (- n i)))))))`'
- en: (define domerge
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define domerge`'
- en: (lambda (pred? l1 l2)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (pred? l1 l2)`'
- en: (cond
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cond`'
- en: '[(null? l1) l2]'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`[(null? l1) l2]`'
- en: '[(null? l2) l1]'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`[else (cons (car l2) (domerge pred? l1 (cdr l2)))]`'
- en: '[(pred? (car l2) (car l1))'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`[(pred? (car l2) (car l1))`'
- en: (cons (car l2) (domerge pred? l1 (cdr l2)))]
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`(cons (car l2) (domerge pred? l1 (cdr l2)))]`'
- en: '[else (cons (car l1) (domerge pred? (cdr l1) l2))])))'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`[else (cons (car l1) (domerge pred? (cdr l1) l2))])))`'
- en: (define sort
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define sort`'
- en: (lambda (pred? l)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (pred? l)`'
- en: (if (null? l) l (dosort pred? l (length l)))))
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`(if (null? l) l (dosort pred? l (length l)))))`'
- en: (define merge
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define merge`'
- en: (lambda (pred? l1 l2)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: (define (pred? l1 l2)
- en: (domerge pred? l1 l2))))`
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`(domerge pred? l1 l2))))`'
- en: Exercise 12.2.1
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.2.1
- en: In `dosort`, when `n` is 1, why is `(list (car ls))` returned instead of just
    `ls`? How much allocation would be saved overall by replacing `(list (car ls))`
    with `(if (null? (cdr ls)) ls (list (car ls)))`?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `dosort` 中，当 `n` 为 1 时，为什么返回 `(list (car ls))` 而不仅仅是 `ls`？通过将 `(list (car ls))`
    替换为 `(if (null? (cdr ls)) ls (list (car ls)))`，总共可以节省多少内存分配？
- en: Exercise 12.2.2
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.2.2
- en: How much work is actually saved by not copying the first part of the input list
    when splitting it in `dosort`?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `dosort` 中分割输入列表时，不复制输入列表的前半部分实际上节省了多少工作？
- en: Exercise 12.2.3
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.2.3
- en: All or nearly all allocation could be saved if the algorithm were to work destructively,
    using `set-cdr!` to separate and join lists. Write destructive versions `sort!`
    and `merge!` of the `sort` and `merge`. Determine the difference between the two
    sets of procedures in terms of allocation and run time for various inputs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果算法使用 `set-cdr!` 来进行破坏性操作，分离和连接列表，那么几乎所有的内存分配都可以节省下来。编写 `sort` 和 `merge` 的破坏性版本
    `sort!` 和 `merge!`。确定这两组程序在不同输入情况下在内存分配和运行时间方面的差异。
- en: Section 12.3\. A Set Constructor
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 12.3\. 节 一个集合构造器
- en: This example describes a syntactic extension, `set-of`, that allows the construction
    of sets represented as lists with no repeated elements [[22](bibliography.html#g240)].
    It uses `define-syntax` and `syntax-rules` to compile set expressions into recursion
    expressions. The expanded code is often as efficient as that which can be produced
    by hand.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例描述了一种语法扩展，`set-of`，它允许构造表示为无重复元素列表的集合 [[22](bibliography.html#g240)]。它使用
    `define-syntax` 和 `syntax-rules` 将集合表达式编译为递归表达式。展开的代码通常与手工编写的代码一样高效。
- en: A `set-of` expression takes the following form.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `set-of` 表达式采用以下形式。
- en: '`(set-of *expr* *clause* ...)`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`\`(set-of *expr* *clause* ...)`'
- en: '`*expr*` describes the elements of the set in terms of the bindings established
    by the `set-of` clauses `*clause* ...`. Each `*clause*` can take one of three
    forms:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`*expr*` 描述了集合的元素，这些元素是由 `set-of` 子句 `*clause* ...` 所建立的绑定所确定的。每个 `*clause*`
    可以采取三种形式之一：'
- en: A clause of the form `(*x* in *s*)` establishes a binding for `*x*` to each
    element of the set `*s*` in turn. This binding is visible within the remaining
    clauses and the expression `*expr*`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以形式`(*x* in *s*)`的从句为每个元素`*s*`依次建立绑定到`*x*`。这个绑定在剩余的从句和表达式`*expr*`中可见。
- en: A clause of the form `(*x* is *e*)` establishes a binding for `*x*` to `*e*`.
    This binding is visible within the remaining clauses and the expression `*expr*`.
    This form is essentially an abbreviation for `(*x* in (list *e*))`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以形式`(*x* is *e*)`的从句为`*x*`建立到`*e*`的绑定。这个绑定在剩余的从句和表达式`*expr*`中可见。这种形式本质上是`(*x* in (list *e*))`的缩写。
- en: A clause taking any other form is treated as a predicate; this is used to force
    refusal of certain elements as in the second of the examples below.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何其他形式的从句都被视为谓语；这用于强制拒绝某些元素，如下面的第二个例子中所示。
- en: '`(set-of x'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`(set-of x'
- en: (x in '(a b c))) ![<graphic>](ch2_0.gif) (a b c)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: (x in '(a b c))) ![<graphic>](ch2_0.gif) (a b c)
- en: (set-of x
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: (set-of x
- en: (x in '(1 2 3 4))
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: (x in '(1 2 3 4))
- en: (even? x)) ![<graphic>](ch2_0.gif) (2 4)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: (even? x)) ![<graphic>](ch2_0.gif) (2 4)
- en: (set-of (cons x y)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: (set-of (cons x y)
- en: (x in '(1 2 3))
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: (x in '(1 2 3))
- en: (y is (* x x))) ![<graphic>](ch2_0.gif) ((1 . 1) (2 . 4) (3 . 9))`
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: (y is (* x x))) ![<graphic>](ch2_0.gif) ((1 . 1) (2 . 4) (3 . 9))`
- en: '`(set-of (cons x y)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`(set-of (cons x y)'
- en: (x in '(a b))
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: (x in '(a b))
- en: (y in '(1 2))) ![<graphic>](ch2_0.gif) ((a . 1) (a . 2) (b . 1) (b . 2))`
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: (y in '(1 2))) ![<graphic>](ch2_0.gif) ((a . 1) (a . 2) (b . 1) (b . 2))`
- en: A `set-of` expression is transformed into nested `let`, named `let`, and `if`
    expressions, corresponding to each `is`, `in`, or predicate subexpression. For
    example, the simple expression
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`set-of`表达式被转换为嵌套的`let`、命名为`let`和`if`表达式，对应于每个`is`、`in`或谓词子表达式。例如，简单表达式'
- en: '`(set-of x (x in ''(a b c)))`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`(set-of x (x in ''(a b c)))`'
- en: is transformed into
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 被转换为
- en: '`(let loop ([set ''(a b c)])'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let loop ([set ''(a b c)])'
- en: (if (null? set)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? set)
- en: '''()'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (let ([x (car set)])
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (car set)])
- en: (set-cons x (loop (cdr set))))))`
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cons x (loop (cdr set))))))`
- en: The expression
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式
- en: '`(set-of x (x in ''(1 2 3 4)) (even? x))`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`(set-of x (x in ''(1 2 3 4)) (even? x))`'
- en: is transformed into
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 被转换为
- en: '`(let loop ([set ''(1 2 3 4)])'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let loop ([set ''(1 2 3 4)])'
- en: (if (null? set)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? set)
- en: '''()'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (let ([x (car set)])
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (car set)])
- en: (if (even? x)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: (if (even? x)
- en: (set-cons x (loop (cdr set)))
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cons x (loop (cdr set)))
- en: (loop (cdr set))))))`
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: (loop (cdr set))))))`
- en: The more complicated expression
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的表达式
- en: '`(set-of (cons x y) (x in ''(1 2 3)) (y is (* x x)))`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`(set-of (cons x y) (x in ''(1 2 3)) (y is (* x x)))`'
- en: is transformed into
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 被转换为
- en: '`(let loop ([set ''(1 2 3)])'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let loop ([set ''(1 2 3)])'
- en: (if (null? set)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? set)
- en: '''()'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (let ([x (car set)])
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (car set)])
- en: (let ([y (* x x)])
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([y (* x x)])
- en: (set-cons (cons x y)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cons (cons x y)
- en: (loop (cdr set)))))))`
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: (loop (cdr set)))))))`
- en: Finally, the expression
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，表达式
- en: '`(set-of (cons x y) (x in ''(a b)) (y in ''(1 2)))`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`(set-of (cons x y) (x in ''(a b)) (y in ''(1 2)))`'
- en: 'is transformed into nested named `let` expressions:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 被转换为嵌套的命名`let`表达式：
- en: '`(let loop1 ([set1 ''(a b)])'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let loop1 ([set1 ''(a b)])'
- en: (if (null? set1)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? set1)
- en: '''()'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (let ([x (car set1)])
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (car set1)])
- en: (let loop2 ([set2 '(1 2)])
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: (let loop2 ([set2 '(1 2)])
- en: (if (null? set2)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? set2)
- en: (loop1 (cdr set1))
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: (loop1 (cdr set1))
- en: (let ([y (car set2)])
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([y (car set2)])
- en: (set-cons (cons x y)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cons (cons x y)
- en: (loop2 (cdr set2)))))))))`
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: (loop2 (cdr set2)))))))))`
- en: These are fairly straightforward transformations, except that the base case
    for the recursion on nested named `let` expressions varies depending upon the
    level. The base case for the outermost named `let` is always the empty list `()`,
    while the base case for an internal named `let` is the recursion step for the
    next outer named `let`. In order to handle this, the definition of `set-of` employs
    a help syntactic extension `set-of-help`. `set-of-help` takes an additional expression,
    `base`, which is the base case for recursion at the current level.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是相当直接的转换，只是递归在嵌套的命名`let`表达式上的基本情况取决于级别。最外层命名`let`的基本情况始终是空列表`()`，而内部命名`let`的基本情况是下一个外部命名`let`的递归步骤。为了处理这个问题，`set-of`的定义使用了一个帮助语法扩展`set-of-help`。`set-of-help`接受一个额外的表达式`base`，这是当前级别递归的基本情况。
- en: '`(library (tspl sets)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`(library (tspl sets)'
- en: (export set-of set-cons in is)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: (export set-of set-cons in is)
- en: (import (rnrs))
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: (import (rnrs))
- en: ; set-of uses helper syntactic extension set-of-help, passing it
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ; set-of 使用辅助语法扩展`set-of-help`，将其传递给
- en: ; an initial base expression of '()
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ; 一个初始的基本表达式为'()
- en: (define-syntax set-of
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax set-of
- en: (syntax-rules ()
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ e m ...)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e m ...)'
- en: (set-of-help e '() m ...)]))
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: (set-of-help e '() m ...)]))
- en: ; set-of-help recognizes in, is, and predicate expressions and
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ; set-of-help recognizes in, is, and predicate expressions and
- en: ; changes them into nested named let, let, and if expressions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ; 将它们转换为嵌套的命名`let`、`let`和`if`表达式。
- en: (define-syntax set-of-help
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax set-of-help
- en: (syntax-rules (in is)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules (in is)
- en: '[(_ e base) (set-cons e base)]'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e base) (set-cons e base)]'
- en: '[(_ e base (x in s) m ...)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e base (x in s) m ...)'
- en: (let loop ([set s])
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: (let loop ([set s])
- en: (if (null? set)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? set)
- en: base
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 基础
- en: (let ([x (car set)])
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x (car set)])
- en: (set-of-help e (loop (cdr set)) m ...))))]
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: (set-of-help e (loop (cdr set)) m ...))))]
- en: '[(_ e base (x is y) m ...)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e base (x is y) m ...)'
- en: (let ([x y]) (set-of-help e base m ...))]
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x y]) (set-of-help e base m ...))]
- en: '[(_ e base p m ...)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ e base p m ...)'
- en: (if p (set-of-help e base m ...) base)]))
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: (if p (set-of-help e base m ...) base)]))
- en: ; since in and is are used as auxiliary keywords by set-of, the
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ; 由于`in`和`is`被`set-of`用作辅助关键字，因此
- en: ; library must export definitions for them as well
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ; 库必须导出它们的定义
- en: (define-syntax in
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax in
- en: (lambda (x)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (syntax-violation 'in "misplaced auxiliary keyword" x)))
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-violation 'in "错误的辅助关键字" x)))
- en: (define-syntax is
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax is
- en: (lambda (x)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (syntax-violation 'is "misplaced auxiliary keyword" x)))
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-violation 'is "错误的辅助关键字" x)))
- en: ; set-cons returns the original set y if x is already in y.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ; 如果x已经在y中，则`set-cons`返回原始集合y。
- en: (define set-cons
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: (define set-cons
- en: (lambda (x y)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x y)
- en: (if (memv x y)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: (if (memv x y)
- en: y
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: y
- en: (cons x y)))))`
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: (cons x y)))))`
- en: Exercise 12.3.1
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习12.3.1
- en: 'Write a procedure, `union`, that takes an arbitrary number of sets (lists)
    as arguments and returns the union of the sets, using only the `set-of` syntactic
    form. For example:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个过程`union`，它接受任意数量的集合（列表）作为参数，并仅使用`set-of`语法形式返回集合的并集。 例如：
- en: '`(union) ![<graphic>](ch2_0.gif) ()'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`(union) ![<graphic>](ch2_0.gif) ()'
- en: (union '(a b c)) ![<graphic>](ch2_0.gif) (a b c)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: (union '(a b c)) ![<graphic>](ch2_0.gif) (a b c)
- en: (union '(2 5 4) '(9 4 3)) ![<graphic>](ch2_0.gif) (2 5 9 4 3)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: (union '(2 5 4) '(9 4 3)) ![<graphic>](ch2_0.gif) (2 5 9 4 3)
- en: (union '(1 2) '(2 4) '(4 8)) ![<graphic>](ch2_0.gif) (1 2 4 8)`
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: (union '(1 2) '(2 4) '(4 8)) ![<graphic>](ch2_0.gif) (1 2 4 8)`
- en: Exercise 12.3.2
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习12.3.2
- en: A single-list version of `map` can (almost) be defined as follows.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`的单列表版本可以（几乎）定义如下。'
- en: '`(define map1'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define map1'
- en: (lambda (f ls)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (f ls)
- en: (set-of (f x) (x in ls))))
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: (set-of (f x) (x in ls))))
- en: (map1 - '(1 2 3 2)) ![<graphic>](ch2_0.gif) (-1 -3 -2)`
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: (map1 - '(1 2 3 2)) ![<graphic>](ch2_0.gif) (-1 -3 -2)`
- en: Why does this not work? What could be changed to make it work?
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这不起作用？ 有什么可以改变使其起作用吗？
- en: Exercise 12.3.3
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习12.3.3
- en: Devise a different definition of `set-cons` that maintains sets in some sorted
    order, making the test for set membership, and hence `set-cons` itself, potentially
    more efficient.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个不同的`set-cons`定义，以维护一些排序顺序的集合，使得集合成员的测试，因此`set-cons`本身可能更有效。
- en: Section 12.4\. Word Frequency Counting
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第12.4节。 单词频率计数
- en: This program demonstrates several basic programming techniques, including string
    and character manipulation, file input/output, data structure manipulation, and
    recursion. The program is adapted from Chapter 6 of *The C Programming Language* [[19](bibliography.html#g237)].
    One reason for using this particular example is to show how a C program might
    look when converted almost literally into Scheme.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序演示了几种基本的编程技术，包括字符串和字符操作，文件输入/输出，数据结构操作和递归。 该程序改编自《C程序设计语言》第6章[[19](bibliography.html#g237)]。
    使用这个特定示例的一个原因是展示将C程序几乎直接转换为Scheme时的外观。
- en: 'A few differences between the Scheme program and the original C program are
    worth noting. First, the Scheme version employs a different protocol for file
    input and output. Rather than implicitly using the standard input and output ports,
    it requires that filenames be passed in, thus demonstrating the opening and closing
    of files. Second, the procedure `get-word` returns one of three values: a string
    (the word), a nonalphabetic character, or an eof value. The original C version
    returned a flag for letter (to say that a word was read) or a nonalphabetic character.
    Furthermore, the C version passed in a string to fill and a limit on the number
    of characters in the string; the Scheme version builds a new string of whatever
    length is required (the characters in the word are held in a list until the end
    of the word has been found, then converted into a string with `list->string`).
    Finally, `char-type` uses the primitive Scheme character predicates `char-alphabetic?`
    and `char-numeric?` to determine whether a character is a letter or digit.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme程序和原始C程序之间有一些值得注意的区别。首先，Scheme版本使用不同的文件输入和输出协议。它不像隐式地使用标准输入和输出端口，而是需要传入文件名，从而演示文件的打开和关闭。其次，`get-word`过程返回三个值之一：一个字符串（单词）、一个非字母字符或一个eof值。原始的C版本返回一个标志来表示字母（表示已读取一个单词）或一个非字母字符。此外，C版本传入一个要填充的字符串和字符串中字符数的限制；而Scheme版本会构建一个所需长度的新字符串（单词中的字符被保存在列表中，直到找到单词的结尾，然后用`list->string`转换为字符串）。最后，`char-type`使用原始的Scheme字符谓词`char-alphabetic?`和`char-numeric?`来确定一个字符是字母还是数字。
- en: The main program, `frequency`, takes an input filename and an output filename
    as arguments, e.g., `(frequency "pickle" "freq.out")` prints the frequency count
    for each word in the file "pickle" to the file "freq.out." As `frequency` reads
    words from the input file, it inserts them into a binary tree structure (using
    a binary sorting algorithm). Duplicate entries are recorded by incrementing the
    count associated with each word. Once end of file is reached, the program traverses
    the tree, printing each word with its count.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序`frequency`以输入文件名和输出文件名作为参数，例如，`(frequency "pickle" "freq.out")`将文件"pickle"中每个单词的频率计数打印到文件"freq.out"中。当`frequency`从输入文件中读取��词时，它将它们插入到二叉树结构中（使用二进制排序算法）。重复条目通过增加与每个单词关联的计数来记录。一旦到达文件结尾，程序遍历树，打印每个单词及其计数。
- en: Assume that the file "pickle" contains the following text.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 假设文件"pickle"包含以下文本。
- en: '`Peter Piper picked a peck of pickled peppers;'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`彼得·派普挑选了一撮泡菜辣椒；'
- en: A peck of pickled peppers Peter Piper picked.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 彼得·派普挑选了一撮泡菜辣椒。
- en: If Peter Piper picked a peck of pickled peppers,
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果彼得·派普挑选了一撮泡菜辣椒，
- en: Where's the peck of pickled peppers Peter Piper picked?`
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 彼得·派普挑选了一撮泡菜辣椒在哪里？
- en: Then, after typing `(frequency "pickle" "freq.out")`, the file "freq.out" should
    contain the following.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在键入`(frequency "pickle" "freq.out")`之后，文件"freq.out"应包含以下内容。
- en: '`1 A'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`1 一个'
- en: 1 If
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 1 如果
- en: 4 Peter
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 4 彼得
- en: 4 Piper
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 4 派普
- en: 1 Where
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 1 哪里
- en: 2 a
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 2 一个
- en: 4 of
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 4 的
- en: 4 peck
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 4 撮
- en: 4 peppers
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 4 辣椒
- en: 4 picked
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 4 挑选
- en: 4 pickled
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 4 泡菜
- en: 1 s
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 1 s
- en: 1 the`
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 1 这个`
- en: The code for the word-counting program is structured as a top-level program,
    with the script header recommended in the scripts chapter of the nonnormative
    appendices to the Revised⁶ Report [[25](bibliography.html#g243)]. It takes the
    names of input and output files from the command line.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 单词计数程序的代码结构化为顶层程序，脚本头部建议在修订⁶报告的非规范附录中的脚本章节中使用。它从命令行获取输入和输出文件的名称。
- en: '`#! /usr/bin/env scheme-script'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`#! /usr/bin/env scheme-script'
- en: (import (rnrs))
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: (import (rnrs))
- en: ;;; If the next character on p is a letter, get-word reads a word
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 如果p上的下一个字符是字母，get-word读取一个单词
- en: ;;; from p and returns it in a string.  If the character is not a
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 从p中读取一个字符串并将其作为字符串返回。如果字符不是
- en: ;;; letter, get-word returns the character (on eof, the eof-object).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 字母，get-word返回字符（在eof时返回eof对象）。
- en: (define get-word
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: (define get-word
- en: (lambda (p)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (p)
- en: (let ([c (get-char p)])
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([c (get-char p)])
- en: (if (eq? (char-type c) 'letter)
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: (if (eq? (char-type c) 'letter)
- en: (list->string
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: (list->string
- en: (let loop ([c c])
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: (let loop ([c c])
- en: (cons
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: (cons
- en: c
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: c
- en: (if (memq (char-type (lookahead-char p))
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: (if (memq (char-type (lookahead-char p))
- en: '''(letter digit))'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '''(letter digit))'
- en: (loop (get-char p))
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: (loop (get-char p))
- en: '''()))))'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '''()))))'
- en: c))))
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: c))))
- en: ;;; char-type tests for the eof-object first, since the eof-object
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; char-type 首先测试eof对象，因为eof对象
- en: ;;; may not be a valid argument to char-alphabetic? or char-numeric?
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 可能不是char-alphabetic?或char-numeric?的有效参数
- en: ;;; It returns the eof-object, the symbol letter, the symbol digit,
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 它返回eof对象、符号letter、符号digit，
- en: ;;; or the argument itself if it is not a letter or digit.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 或者如果它不是字母或数字，则是参数本身。
- en: (define char-type
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 char-type
- en: (lambda (c)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (c)
- en: (cond
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: (条件
- en: '[(eof-object? c) c]'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[(eof-object? c) c]'
- en: '[(char-alphabetic? c) ''letter]'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '[(char-alphabetic? c) ''字母]'
- en: '[(char-numeric? c) ''digit]'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[(char-numeric? c) ''数字]'
- en: '[else c])))'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '[其他 c])))'
- en: ;;; Tree nodes are represented as a record type with four fields: word,
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 树节点表示为具有四个字段的记录类型：单词，
- en: ;;; left, right, and count.  Only one field, word, is initialized by an
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 左、���和计数。只有一个字段，单词，由
- en: ;;; argument to the constructor procedure make-tnode.  The remaining
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 构造函数过程 make-tnode 的参数。其余
- en: ;;; fields are initialized by the constructor and changed by subsequent
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 字段由构造函数初始化，并由后续更改
- en: ;;; operations.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 操作。
- en: (define-record-type tnode
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: (定义记录类型 tnode
- en: (fields (immutable word)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: (字段 (不可变的单词)
- en: (mutable left)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: (可变的左)
- en: (mutable right)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: (可变的右)
- en: (mutable count))
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: (可变的计数))
- en: (protocol
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: (协议
- en: (lambda (new)
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (new)
- en: (lambda (word)
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (word)
- en: (new word '() '() 1)))))
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: (new word '() '() 1)))))
- en: ;;; If the word already exists in the tree, tree increments its
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 如果单词已经存在于树中，则树会增加其
- en: ;;; count.  Otherwise, a new tree node is created and put into the
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 计数。否则，创建一个新的树节点并放入
- en: ;;; tree.  In any case, the new or modified tree is returned.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 树。在任何情况下，返回新的或修改后的树。
- en: (define tree
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: (定义树
- en: (lambda (node word)
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (node word)
- en: (cond
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: (条件
- en: '[(null? node) (make-tnode word)]'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '[(null? node) (make-tnode word)]'
- en: '[(string=? word (tnode-word node))'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[(string=? word (tnode-word node))'
- en: (tnode-count-set! node (+ (tnode-count node) 1))
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: (tnode-count-set! node (+ (tnode-count node) 1))
- en: node]
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 节点]
- en: '[(string<? word (tnode-word node))'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[(string<? word (tnode-word node))'
- en: (tnode-left-set! node (tree (tnode-left node) word))
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: (tnode-left-set! node (tree (tnode-left node) word))
- en: node]
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 节点]
- en: '[else'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[其他'
- en: (tnode-right-set! node (tree (tnode-right node) word))
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: (tnode-right-set! node (tree (tnode-right node) word))
- en: node])))
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: node])))
- en: ;;; tree-print prints the tree in "in-order," i.e., left subtree,
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; tree-print 按“中序”打印树，即左子树，
- en: ;;; then node, then right subtree.  For each word, the count and the
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 然后节点，然后右子树。对于每个单词，计数和
- en: ;;; word are printed on a single line.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 单行打印单词。
- en: (define tree-print
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 tree-print
- en: (lambda (node p)
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (node p)
- en: (unless (null? node)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: (除非 (null? node)
- en: (tree-print (tnode-left node) p)
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: (tree-print (tnode-left node) p)
- en: (put-datum p (tnode-count node))
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: (put-datum p (tnode-count node))
- en: (put-char p #\space)
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '(put-char p #\space)'
- en: (put-string p (tnode-word node))
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: (put-string p (tnode-word node))
- en: (newline p)
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: (newline p)
- en: (tree-print (tnode-right node) p))))
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: (tree-print (tnode-right node) p))))
- en: ;;; frequency is the driver routine.  It opens the files, reads the
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 频率是驱动程序。它打开文件，读取
- en: ;;; words, and enters them into the tree.  When the input port
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 单词，并将它们输入树中。当输入端口
- en: ;;; reaches end-of-file, it prints the tree and closes the ports.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: ;;; 到达文件末尾，打印树并关闭端口。
- en: (define frequency
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: (定义频率
- en: (lambda (infn outfn)
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (infn outfn)
- en: (let ([ip (open-file-input-port infn (file-options)
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: (让([ip (open-file-input-port infn (file-options))
- en: (buffer-mode block) (native-transcoder))]
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: (buffer-mode block) (native-transcoder))]
- en: '[op (open-file-output-port outfn (file-options)'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '[op (open-file-output-port outfn (file-options))'
- en: (buffer-mode block) (native-transcoder))])
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: (buffer-mode block) (native-transcoder))])
- en: (let loop ([root '()])
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: (让循环 ([root '()])
- en: (let ([w (get-word ip)])
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: (让([w (get-word ip)])
- en: (cond
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: (条件
- en: '[(eof-object? w) (tree-print root op)]'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '[(eof-object? w) (tree-print root op)]'
- en: '[(string? w) (loop (tree root w))]'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '[(string? w) (循环 (tree root w))]'
- en: '[else (loop root)])))'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '[其他 (循环 root)])))'
- en: (close-port ip)
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: (close-port ip)
- en: (close-port op))))
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: (close-port op))))
- en: (unless (= (length (command-line)) 3)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: (除非 (= (length (command-line)) 3)
- en: (put-string (current-error-port) "usage: ")
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: (put-string (current-error-port) "用法：")
- en: (put-string (current-error-port) (car (command-line)))
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: (put-string (current-error-port) (car (command-line)))
- en: (put-string (current-error-port) " input-filename output-filename\n")
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: (put-string (current-error-port) " 输入文件名 输出文件名\n")
- en: (exit #f))
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '(退出 #f))'
- en: (frequency (cadr (command-line)) (caddr (command-line)))`
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: (频率 (cadr (command-line)) (caddr (command-line)))`
- en: Exercise 12.4.1
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.4.1
- en: In the output file shown earlier, the capitalized words appeared before the
    others in the output file, and the capital `A` was not recognized as the same
    word as the lower-case `a`. Modify `tree` to use the case-insensitive versions
    of the string comparisons so that this does not happen.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前显示的输出文件中，大写单词出现在其他单词之前，并且大写的 `A` 未被识别为与小写的 `a` 相同的单词。修改 `tree` 以使用不区分大小写的字符串比较版本，以防止这种情况发生。
- en: Exercise 12.4.2
  id: totrans-438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.4.2
- en: The "word" `s` appears in the file "freq.out," although it is really just a
    part of the contraction `Where's`. Adjust `get-word` to allow embedded single
    quote marks.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: “word” `s` 出现在文件 “freq.out” 中，尽管它实际上只是缩写 `Where's` 的一部分。调整 `get-word` 以允许嵌入的单引号标记。
- en: Exercise 12.4.3
  id: totrans-440
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.4.3
- en: Modify this program to "weed out" certain common words such as `a`, `an`, `the`,
    `is`, `of`, etc., in order to reduce the amount of output for long input files.
    Try to devise other ways to cut down on useless output.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 修改此程序以“清除”某些常见单词，如 `a`、`an`、`the`、`is`、`of` 等，以减少长输入文件的输出量。 尝试想出其他减少无用输出的方法。
- en: Exercise 12.4.4
  id: totrans-442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.4.4
- en: '`get-word` buffers characters in a list, allocating a new pair (with `cons`)
    for each character. Make it more efficient by using a string to buffer the characters.
    Devise a way to allow the string to grow if necessary. [*Hint*: Use `string-append`
    or a string output port.]'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`get-word` 将字符缓冲在列表中，为每个字符分配一个新对（使用 `cons`）。 通过使用字符串来缓冲字符，使其更有效率。 设计一种允许字符串在必要时增长的方法。
    [*提示*：使用 `string-append` 或字符串输出端口。]'
- en: Exercise 12.4.5
  id: totrans-444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.4.5
- en: The `tree` implementation works by creating trees and later filling in their
    `left` and `right` fields. This requires many unnecessary assignments. Rewrite
    the `tree` procedure to avoid `tree-left-set!` and `tree-right-set!` entirely.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree` 实现通过创建树并稍后填充它们的 `left` 和 `right` 字段来工作。 这需要许多不必要的赋值。 重新编写 `tree` 程序，完全避免使用
    `tree-left-set!` 和 `tree-right-set!`。'
- en: Exercise 12.4.6
  id: totrans-446
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.4.6
- en: Recode the program to use a hashtable (Section [6.13](objects.html#g119)) in
    place of a binary tree, and compare the running times of the new and old programs
    on large input files. Are hashtables always faster or always slower? Is there
    a break-even point? Does the break-even point depend on the size of the file or
    on some other characteristic of the file?
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写程序，使用哈希表（第 [6.13](objects.html#g119) 节）代替二叉树，并比较新旧程序在大型输入文件上的运行时间。 哈希表总是更快还是总是更慢？
    是否存在盈亏平衡点？ 盈亏平衡点是否取决于文件的大小或文件的其他特征？
- en: Section 12.5\. Scheme Printer
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 12.5 节。 Scheme 打印机
- en: Printing Scheme objects may seem like a complicated process, but in fact a rudimentary
    printer is straightforward, as this example demonstrates. `put-datum`, `write`,
    and `display` are all implemented by the same code. Sophisticated printers often
    support various printer controls and handle printing of cyclic objects, but the
    one given here is completely basic.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 Scheme 对象可能看起来是一个复杂的过程，但实际上，一个基本的打印机是直截了当的，正如这个例子所示。 `put-datum`、`write`
    和 `display` 都由相同的代码实现。 复杂的打印机通常支持各种打印控件，并处理循环对象的打印，但这里给出的是完全基本的。
- en: The main driver for the program is a procedure `wr`, which takes an object to
    print `x`, a flag `d?`, and a port `p`. The flag `d?` (for display) is `#t` if
    the code is to *display* the object, `#f` otherwise. The `d?` flag is important
    only for characters and strings. Recall from Section [7.8](io.html#g129) that
    `display` prints strings without the enclosing quote marks and characters without
    the `#\` syntax.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的主要驱动程序是一个过程 `wr`，它接受要打印的对象 `x`、一个标志 `d?` 和一个端口 `p`。 标志 `d?`（用于显示）如果代码要 *显示*
    该对象，则为 `#t`，否则为 `#f`。 对于字符和字符串，`d?` 标志很重要。 请回顾第 [7.8](io.html#g129) 节，`display`
    打印字符串时不包含引号，字符不使用 `#\` 语法。
- en: The entry points for `write` and `display` handle the optionality of the second
    (port) argument, passing the value of `current-output-port` when no port argument
    is provided.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`write` 和 `display` 的入口点处理第二个（端口）参数的可选性，在未提供端口参数时传递 `current-output-port` 的值。'
- en: Procedures, ports, and the end-of-file object are printed as `#<procedure>`,
    `#<port>`, and `#<eof>`. Unrecognized types of values are printed as `#<unknown>`.
    So, for example, a hashtable, enumeration set, and object of some implementation-specific
    type will all print as `#<unknown>`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 过程、端口和文件结束对象被打印为 `#<procedure>`、`#<port>` 和 `#<eof>`。 未识别的值类型被打印为 `#<unknown>`。
    因此，例如，哈希表、枚举集和某些特定实现类型的对象都将打印为 `#<unknown>`。
- en: '`(library (tspl printer)'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`(library (tspl printer)'
- en: (export put-datum write display)
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: (export put-datum write display)
- en: (import (except (rnrs) put-datum write display))
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: (import (except (rnrs) put-datum write display))
- en: ; define these here to avoid confusing paren-balancers
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ; 在此处定义这些，以避免混淆括号平衡器
- en: (define lparen #\()
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: (define lparen #\()
- en: (define rparen #\))
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: (define rparen #\))
- en: ; wr is the driver, dispatching on the type of x
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: ; wr 是驱动程序，根据 x 的类型进行分派
- en: (define wr
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: (define wr
- en: (lambda (x d? p)
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x d? p)
- en: (cond
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(symbol? x) (put-string p (symbol->string x))]'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '[(symbol? x) (put-string p (symbol->string x))]'
- en: '[(pair? x) (wrpair x d? p)]'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '[(pair? x) (wrpair x d? p)]'
- en: '[(number? x) (put-string p (number->string x))]'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '[(number? x) (put-string p (number->string x))]'
- en: '[(null? x) (put-string p "()")]'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '[(null? x) (put-string p "()")]'
- en: '[(boolean? x) (put-string p (if x "#t" "#f"))]'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '[(boolean? x) (put-string p (if x "#t" "#f"))]'
- en: '[(char? x) (if d? (put-char p x) (wrchar x p))]'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '[(char? x) (if d? (put-char p x) (wrchar x p))]'
- en: '[(string? x) (if d? (put-string p x) (wrstring x p))]'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[(string? x) (if d? (put-string p x) (wrstring x p))]'
- en: '[(vector? x) (wrvector x d? p)]'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '[(vector? x) (wrvector x d? p)]'
- en: '[(bytevector? x) (wrbytevector x d? p)]'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[(bytevector? x) (wrbytevector x d? p)]'
- en: '[(eof-object? x) (put-string p "#<eof>")]'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '[(eof-object? x) (put-string p "#<eof>")]'
- en: '[(port? x) (put-string p "#<port>")]'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '[(port? x) (put-string p "#<port>")]'
- en: '[(procedure? x) (put-string p "#<procedure>")]'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '[(procedure? x) (put-string p "#<procedure>")]'
- en: '[else (put-string p "#<unknown>")])))'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (put-string p "#<unknown>")])))'
- en: ; wrpair handles pairs and nonempty lists
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: ; wrpair 处理对和非空列表
- en: (define wrpair
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: (define wrpair
- en: (lambda (x d? p)
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x d? p)
- en: (put-char p lparen)
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: (put-char p lparen)
- en: (let loop ([x x])
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: (let loop ([x x])
- en: (wr (car x) d? p)
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: (wr (car x) d? p)
- en: (cond
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(pair? (cdr x)) (put-char p #\space) (loop (cdr x))]'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '[(pair? (cdr x)) (put-char p #\space) (loop (cdr x))]'
- en: '[(null? (cdr x))]'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '[(null? (cdr x))]'
- en: '[else (put-string p " . ") (wr (cdr x) d? p)]))'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (put-string p " . ") (wr (cdr x) d? p)]))'
- en: (put-char p rparen)))
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: (put-char p rparen)))
- en: ; wrchar handles characters.  Used only when d? is #f.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: ; wrchar 处理字符。仅在d?为#f时使用。
- en: (define wrchar
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: (define wrchar
- en: (lambda (x p)
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x p)
- en: (put-string p "#\\")
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: (put-string p "#\\")
- en: (cond
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(assq x ''((#\alarm . "alarm") (#\backspace . "backspace")'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '[(assq x ''((#\alarm . "alarm") (#\backspace . "backspace")'
- en: (#\delete . "delete") (#\esc . "esc")
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: (#\delete . "删除") (#\esc . "esc")
- en: (#\newline . "newline") (#\nul . "nul")
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: (#\newline . "换行") (#\nul . "nul")
- en: (#\page . "page") (#\return . "return")
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: (#\page . "分页") (#\return . "回车")
- en: (#\space . "space") (#\tab . "tab")
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: (#\space . "空格") (#\tab . "制表符")
- en: (#\vtab . "vtab"))) =>
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: (#\vtab . "垂直制表符"))) =>
- en: (lambda (a) (put-string p (cdr a)))]
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (a) (put-string p (cdr a)))]
- en: '[else (put-char p x)])))'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (put-char p x)])))'
- en: ; wrstring handles strings.  Used only when d? is #f.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: ; wrstring 处理字符串。仅在d?为#f时使用。
- en: (define wrstring
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: (define wrstring
- en: (lambda (x p)
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x p)
- en: (put-char p #\")
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: (put-char p #\")
- en: (let ([n (string-length x)])
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([n (string-length x)])
- en: (do ([i 0 (+ i 1)])
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([i 0 (+ i 1)])
- en: ((= i n))
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: ((= i n))
- en: (let ([c (string-ref x i)])
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([c (string-ref x i)])
- en: (case c
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: (case c
- en: '[(#\alarm) (put-string p "\\a")]'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '[(#\alarm) (put-string p "\\a")]'
- en: '[(#\backspace) (put-string p "\\b")]'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '[(#\backspace) (put-string p "\\b")]'
- en: '[(#\newline) (put-string p "\\n")]'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '[(#\newline) (put-string p "\\n")]'
- en: '[(#\page) (put-string p "\\f")]'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '[(#\page) (put-string p "\\f")]'
- en: '[(#\return) (put-string p "\\r")]'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '[(#\return) (put-string p "\\r")]'
- en: '[(#\tab) (put-string p "\\t")]'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '[(#\tab) (put-string p "\\t")]'
- en: '[(#\vtab) (put-string p "\\v")]'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '[(#\vtab) (put-string p "\\v")]'
- en: '[(#\") (put-string p "\\\"")]'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '[(#\") (put-string p "\\\"")]'
- en: '[(#\\) (put-string p "\\\\")]'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '[(#\\) (put-string p "\\\\")]'
- en: '[else (put-char p c)]))))'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (put-char p c)]))))'
- en: (put-char p #\")))
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: (put-char p #\")))
- en: (define wrvector
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: (define wrvector
- en: (lambda (x d? p)
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x d? p)
- en: (put-char p #\#)
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: (put-char p #\#)
- en: (let ([n (vector-length x)])
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([n (vector-length x)])
- en: (do ([i 0 (+ i 1)] [sep lparen #\space])
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([i 0 (+ i 1)] [sep lparen #\space])
- en: ((= i n))
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: ((= i n))
- en: (put-char p sep)
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: (put-char p sep)
- en: (wr (vector-ref x i) d? p)))
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: (wr (vector-ref x i) d? p)))
- en: (put-char p rparen)))
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: (put-char p rparen)))
- en: (define wrbytevector
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: (define wrbytevector
- en: (lambda (x d? p)
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x d? p)
- en: (put-string p "#vu8")
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: (put-string p "#vu8")
- en: (let ([n (bytevector-length x)])
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([n (bytevector-length x)])
- en: (do ([i 0 (+ i 1)] [sep lparen #\space])
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: (do ([i 0 (+ i 1)] [sep lparen #\space])
- en: ((= i n))
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: ((= i n))
- en: (put-char p sep)
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: (put-char p sep)
- en: (wr (bytevector-u8-ref x i) d? p)))
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: (wr (bytevector-u8-ref x i) d? p)))
- en: (put-char p rparen)))
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: (put-char p rparen)))
- en: ; check-and-wr is called when the port is supplied
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: ; check-and-wr 在提供端口时调用
- en: (define check-and-wr
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: (define check-and-wr
- en: (lambda (who x d? p)
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (who x d? p)
- en: (unless (and (output-port? p) (textual-port? p))
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: (unless (and (output-port? p) (textual-port? p))
- en: (assertion-violation who "invalid argument" p))
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: (assertion-violation who "无效参数" p))
- en: (wr x d? p)))
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: (wr x d? p)))
- en: ; put-datum calls wr with d? set to #f
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: ; put-datum 调用wr，d?设置为#f
- en: (define put-datum
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: (define put-datum
- en: (lambda (p x)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (p x)
- en: (check-and-wr 'put-datum x #f p)))
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: (check-and-wr 'put-datum x #f p)))
- en: ; write calls wr with d? set to #f
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: ; write 调用wr，d?设置为#f
- en: (define write
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: (define write
- en: (case-lambda
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: (case-lambda
- en: '[(x) (wr x #f (current-output-port))]'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '[(x) (wr x #f (current-output-port))]'
- en: '[(x p) (check-and-wr ''write x #f p)]))'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '[(x p) (check-and-wr ''write x #f p)]))'
- en: ; display calls wr with d? set to #t
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: ; display 调用wr，d?设置为#t
- en: (define display
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: (define display
- en: (case-lambda
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: (case-lambda
- en: '[(x) (wr x #t (current-output-port))]'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '[(x) (wr x #t (current-output-port))]'
- en: '[(x p) (check-and-wr ''display x #t p)])))`'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '[(x p) (check-and-wr ''display x #t p)])))`'
- en: Exercise 12.5.1
  id: totrans-558
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.5.1
- en: Numbers are printed with the help of `number->string`. Correct printing of all
    Scheme numeric types, especially inexact numbers, is a complicated task. Handling
    exact integers and ratios is fairly straightforward, however. Modify the code
    to print exact integers and ratios numbers directly (without `number->string`),
    but continue to use `number->string` for inexact and complex numbers.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是通过`number->string`来打印的。正确打印所有Scheme数值类型，特别是不精确数值，是一项复杂的任务。然而，处理精确整数和比率相对简单。修改代码以直接打印精确整数和比率数值（不使用`number->string`），但继续对不精确和复数数值使用`number->string`。
- en: Exercise 12.5.2
  id: totrans-560
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.5.2
- en: 'Modify `wr` and its helpers to direct their output to an internal buffer rather
    than to a port. Use the modified versions to implement a procedure `object->string`
    that, like `number->string`, returns a string containing a printed representation
    of its input. For example:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`wr`及其辅助程序，将它们的输出定向到内部缓冲区而不是端口。使用修改后的版本来实现一个名为`object->string`的过程，类似于`number->string`，返回一个包含其输入的打印表示的字符串。例如：
- en: '`(object->string ''(a b c)) ![<graphic>](ch2_0.gif) "(a b c)"'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '`(object->string ''(a b c)) ![<graphic>](ch2_0.gif) "(a b c)"'
- en: (object->string "hello") ![<graphic>](ch2_0.gif) "\"hello\""`
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: (object->string "hello") ![<graphic>](ch2_0.gif) "\"hello\""`
- en: You may be surprised just how easy this change is to make.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶于这种改变是多么容易实现。
- en: Exercise 12.5.3
  id: totrans-565
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习12.5.3
- en: Some symbols are not printed properly by `wr`, including those that start with
    digits or contain whitespace. Modify `wr` to call a `wrsymbol` helper that uses
    hex scalar escapes as necessary to handle such symbols. A hex scalar escape takes
    the form `#\x*n*;`, where `*n*` is the Unicode scalar value of a character expressed
    in hexadecimal notation. Consult the grammar for symbols on page [458](grammar.html#grammar:symbols)
    to determine when hex scalar escapes are necessary.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 一些符号由`wr`不正确打印，包括以数字开头或包含空格的符号。修改`wr`以调用`wrsymbol`辅助程序，根据需要使用十六进制标量转义来处理这些符号。十六进制标量转义采用`#\x*n*;`的形式，其中`*n*`是以十六进制表示的字符的Unicode标量值。请参考第[458](grammar.html#grammar:symbols)页上的符号语法确定何时需要十六进制标量转义。
- en: Section 12.6\. Formatted Output
  id: totrans-567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第12.6节。格式化输出
- en: 'It is often necessary to print strings containing the printed representations
    of Scheme objects, especially numbers. Doing so with Scheme''s standard output
    routines can be tedious. For example, the `tree-print` procedure of Section [12.4](examples.html#g169)
    requires a sequence of four calls to output routines to print a simple one-line
    message:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要打印包含Scheme对象的打印表示的字符串，特别是数字。使用Scheme的标准输出例程这样做可能很繁琐。例如，第[12.4](examples.html#g169)节的`tree-print`过程需要四个调用输出例程来打印一个简单的单行消息：
- en: '`(put-datum p (tnode-count node))'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`(put-datum p (tnode-count node))'
- en: (put-char p #\space)
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: (put-char p #\space)
- en: (put-string p (tnode-word node))
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: (put-string p (tnode-word node))
- en: (newline p)`
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: (换行 p)`
- en: The formatted output facility defined in this section allows these four calls
    to be replaced by the single call to `fprintf` below.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节中定义的格式化输出功能允许将这四个调用替换为下面的单个`fprintf`调用。
- en: '`(fprintf p "~s ~a~%" (tnode-count node) (tnode-word node))`'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '`(fprintf p "~s ~a~%" (tnode-count node) (tnode-word node))`'
- en: '`fprintf` expects a port argument, a *control string*, and an indefinite number
    of additional arguments that are inserted into the output as specified by the
    control string. In the example, the value of `(tnode-count node)` is written first,
    in place of `~s`. This is followed by a space and the displayed value of `(tnode-word node)`,
    in place of `~a`. The `~%` is replaced in the output with a newline.'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '`fprintf`期望一个端口参数，一个*控制字符串*，以及一个不确定数量的额外参数，这些参数根据控制字符串的规定插入到输出中。在示例中，`(tnode-count node)`的值首先被写入，代替`~s`。然后是一个空格和`(tnode-word node)`的显示值，代替`~a`。`~%`在输出中被换行符替换。'
- en: The procedure `printf`, also defined in this section, is like `fprintf` except
    that no port argument is expected and output is sent to the current output port.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节中还定义的`printf`过程类似于`fprintf`，只是不需要端口参数，输出发送到当前输出端口。
- en: '`~s`, `~a`, and `~%` are *format directives*; `~s` causes the first unused
    argument after the control string to be printed to the output via `write`, `~a`
    causes the first unused argument to be printed via `display`, and `~%` simply
    causes a newline character to be printed. The simple implementation of `fprintf`
    below recognizes only one other format directive, `~~`, which inserts a tilde
    into the output. For example,'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '`~s`、`~a`和`~%`是*格式指令*；`~s`导致控制字符串后未使用的第一个参数通过`write`打印到输出中，`~a`导致未使用的第一个参数通过`display`打印，而`~%`只是导致打印一个换行字符。下面的`fprintf`的简单实现仅识别另一个格式指令，`~~`，它在输出中插入一个波浪号。例如，'
- en: '`(printf "The string ~s displays as ~~.~%" "~")`'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`(printf "The string ~s displays as ~~.~%" "~")`'
- en: prints
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 打印
- en: '`The string "~" displays as ~.`'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '`字符串"~"显示为~。`'
- en: '`(library (tspl formatted-output)'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '`(库 (tspl formatted-output)'
- en: (export printf fprintf)
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: (导出 printf fprintf)
- en: (import (rnrs))
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: (导入 (rnrs))
- en: ; dofmt does all of the work.  It loops through the control string
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: ; dofmt 完成所有工作。它循环遍历控制字符串
- en: ; recognizing format directives and printing all other characters
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: ; 识别格式指令并打印所有其���字符
- en: ; without interpretation.  A tilde at the end of a control string is
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: ; 而不解释。控制字符串末尾的波浪号是
- en: ; treated as an ordinary character.  No checks are made for proper
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: ; 被视为普通字符。  不进行正确性检查
- en: ; inputs.  Directives may be given in either lower or upper case.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: ; 输入。  指令可以使用小写或大写字母。
- en: (define dofmt
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: (define dofmt
- en: (lambda (p cntl args)
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (p cntl args)
- en: (let ([nmax (- (string-length cntl) 1)])
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([nmax (- (string-length cntl) 1)])
- en: (let loop ([n 0] [a args])
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: (let loop ([n 0] [a args])
- en: (if (<= n nmax)
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: (if (<= n nmax)
- en: (let ([c (string-ref cntl n)])
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([c (string-ref cntl n)])
- en: (if (and (char=? c #\~) (< n nmax))
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: (if (and (char=? c #\~) (< n nmax))
- en: (case (string-ref cntl (+ n 1))
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: (case (string-ref cntl (+ n 1))
- en: '[(#\a #\A)'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '[(#\a #\A)'
- en: (display (car a) p)
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: (display (car a) p)
- en: (loop (+ n 2) (cdr a))]
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: (loop (+ n 2) (cdr a))]
- en: '[(#\s #\S)'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '[(#\s #\S)'
- en: (write (car a) p)
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: (write (car a) p)
- en: (loop (+ n 2) (cdr a))]
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: (loop (+ n 2) (cdr a))]
- en: '[(#\%)'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '[(#\%)'
- en: (newline p)
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: (newline p)
- en: (loop (+ n 2) a)]
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: (loop (+ n 2) a)]
- en: '[(#\~)'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '[(#\~)'
- en: (put-char p #\~) (loop (+ n 2) a)]
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: (put-char p #\~) (loop (+ n 2) a)]
- en: '[else'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '[else'
- en: (put-char p c) (loop (+ n 1) a)])
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: (put-char p c) (loop (+ n 1) a)])
- en: (begin
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: (begin
- en: (put-char p c)
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: (put-char p c)
- en: (loop (+ n 1) a)))))))))
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: (loop (+ n 1) a)))))))))
- en: ; printf and fprintf differ only in that fprintf passes its
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: ; `printf` 和 `fprintf` 之间的唯一区别在于 `fprintf` 传递它的
- en: ; port argument to dofmt while printf passes the current output
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: ; 端口参数传递给 `dofmt`，而 `printf` 传递给当前输出端口
- en: ; port.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: ; 端口。
- en: (define printf
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: (define printf
- en: (lambda (control . args)
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (control . args)
- en: (dofmt (current-output-port) control args)))
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: (dofmt (current-output-port) control args)))
- en: (define fprintf
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: (define fprintf
- en: (lambda (p control . args)
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (p control . args)
- en: (dofmt p control args))))`
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: (dofmt p control args))))`
- en: Exercise 12.6.1
  id: totrans-622
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.6.1
- en: Add error checking to the code for invalid port arguments (`fprintf`), invalid
    tilde escapes, and extra or missing arguments.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 添加错误检查到代码中，用于无效的端口参数（`fprintf`），无效的波浪线转义和额外或缺失的参数。
- en: Exercise 12.6.2
  id: totrans-624
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.6.2
- en: 'Using the optional radix argument to `number->string`, augment `printf` and
    `fprintf` with support for the following new format directives:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `number->string` 的可选基数参数，增强 `printf` 和 `fprintf`，支持以下新的格式指令：
- en: '| *  a*. | `~b` or `~B`: print the next unused argument, which must be a number,
    in binary; |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
  zh: '| *  a*. | `~b` 或 `~B`：打印下一个未使用的参数，该参数必须是一个二进制数； |'
- en: '| *  b*. | `~o` or `~O`: print the next unused argument, which must be a number,
    in octal; and |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '| *  b*. | `~o` 或 `~O`：打印下一个未使用的参数，该参数必须是一个八进制数；和 |'
- en: '| *  c*. | `~x` or `~X`: print the next unused argument, which must be a number,
    in hexadecimal. |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
  zh: '| *  c*. | `~x` 或 `~X`：打印下一个未使用的参数，该参数必须是一个十六进制数。 |'
- en: 'For example:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '`(printf "#x~x #o~o #b~b~%" 16 8 2)`'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '`(printf "#x~x #o~o #b~b~%" 16 8 2)`'
- en: would print
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 会打印
- en: '`#x10 #o10 #b10`'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '`#x10 #o10 #b10`'
- en: Exercise 12.6.3
  id: totrans-633
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.6.3
- en: 'Add an "indirect" format directive, `~@`, that treats the next unused argument,
    which must be a string, as if it were spliced into the current format string.
    For example:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个"间接"格式指令，`~@`，将下一个未使用的参数（必须是字符串）视为被拼接到当前格式字符串中。例如：
- en: '`(printf "--- ~@ ---" "> ~s <" ''(a b c))`'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '`(printf "--- ~@ ---" "> ~s <" ''(a b c))`'
- en: would print
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 会打印
- en: '`---> (a b c) <---`'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '`---> (a b c) <---`'
- en: Exercise 12.6.4
  id: totrans-638
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.6.4
- en: Implement `format`, a version of `fprintf` that places its output into a string
    instead of writing to a port. Make use of `object->string` from Exercise [12.5.2](examples.html#g178)
    to support the `~s` and `~a` directives.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `format`，`fprintf` 的一个版本，将其输出放入一个字符串而不是写入端口。利用练习 [12.5.2](examples.html#g178)
    中的 `object->string` 来支持 `~s` 和 `~a` 指令。
- en: '`(let ([x 3] [y 4])'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x 3] [y 4])'
- en: (format "~s + ~s = ~s" x y (+ x y))) ![<graphic>](ch2_0.gif) "3 + 4 = 7"`
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: (format "~s + ~s = ~s" x y (+ x y))) ![<graphic>](ch2_0.gif) "3 + 4 = 7"`
- en: Exercise 12.6.5
  id: totrans-642
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.6.5
- en: Instead of using `object->string`, define `format` using a string output port.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用 `object->string`，定义 `format` 使用一个字符串输出端口。
- en: Exercise 12.6.6
  id: totrans-644
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.6.6
- en: Modify `format`, `fprintf`, and `printf` to allow a field size to be specified
    after the tilde in the `~a` and `~s` format directives. For example, the directive
    `~10s` would cause the next unused argument to be inserted into the output left-justified
    in a field of size 10. If the object requires more spaces than the amount specified,
    allow it to extend beyond the field.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `format`、`fprintf` 和 `printf`，允许在 `~a` 和 `~s` 格式指令的波浪号后指定字段大小。例如，指令 `~10s`
    会导致下一个未使用的参数被插入到输出中，左对齐在大小为 10 的字段中。如果对象需要的空间超过指定的数量，则允许其扩展到字段之外。
- en: '`(let ([x ''abc] [y ''(def)])'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '`(let ([x ''abc] [y ''(def)])'
- en: (format "(cons '~5s '~5s) = ~5s"
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: (format "(cons '~5s '~5s) = ~5s"
- en: x y (cons x y))) ![<graphic>](ch2_0.gif) "(cons 'abc   '(def)) = (abc def)"`
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: x y (cons x y))) ![<graphic>](ch2_0.gif) "(cons 'abc   '(def)) = (abc def)"`
- en: '[*Hint*: Use `format` recursively.]'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '[*提示*：使用递归的 `format`。]'
- en: Section 12.7\. A Meta-Circular Interpreter for Scheme
  id: totrans-650
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 12.7 节。Scheme 的元循环解释器
- en: The program described in this section is a *meta-circular* interpreter for Scheme,
    i.e., it is an interpreter *for* Scheme written *in* Scheme. The interpreter shows
    how small Scheme is when the core structure is considered independently from its
    syntactic extensions and primitives. It also illustrates interpretation techniques
    that can be applied equally well to languages other than Scheme.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述的程序是Scheme的*元循环*解释器，即，它是用Scheme编写的Scheme解释器。该解释器展示了当核心结构独立于其语法扩展和原语时，Scheme有多小。它还说明了可以同样适用于除Scheme以外的语言的解释技术。
- en: The relative simplicity of the interpreter is somewhat misleading. An interpreter
    for Scheme written in Scheme can be quite a bit simpler than one written in most
    other languages. Here are a few reasons why this one is simpler.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器的相对简单性有点具有误导性。用Scheme编写的Scheme解释器可能比大多数其他语言中的解释器简单得多。以下是一些这个解释器更简单的原因。
- en: Tail calls are handled properly only because tail calls in the interpreter are
    handled properly by the host implementation. All that is required is that the
    interpreter itself be tail-recursive.
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尾调用之所以能够正确处理，只是因为解释器中的尾调用由主机实现正确处理。唯一需要的就是解释器本身必须是尾递归的。
- en: First-class procedures in interpreted code are implemented by first-class procedures
    in the interpreter, which in turn are supported by the host implementation.
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释代码中的一流程序是由解释器中的一流程序实现的，而解释器本身又由主机实现支持。
- en: First-class continuations created with `call/cc` are provided by the host implementation's
    `call/cc`.
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用`call/cc`创建的一流延续由主机实现的`call/cc`提供。
- en: Primitive procedures such as `cons` and `assq` and services such as storage
    management are provided by the host implementation.
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cons`和`assq`等原语过程以及存储管理等服务由主机实现提供。'
- en: Converting the interpreter to run in a language other than Scheme may require
    explicit support for some or all of these items.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 转换解释器以在除Scheme以外的语言中运行可能需要显式支持这些项目的一些或全部。
- en: The interpreter stores lexical bindings in an *environment*, which is simply
    an *association list* (see page [165](objects.html#page:assq)). Evaluation of
    a `lambda` expression results in the creation of a procedure within the scope
    of variables holding the environment and the `lambda` body. Subsequent application
    of the procedure combines the new bindings (the actual parameters) with the saved
    environment.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器在一个*环境*中存储词法绑定，它只是一个*关联列表*（见页面[165](objects.html#page:assq)）。对`lambda`表达式的求值导致在保存环境和`lambda`主体的变量范围内创建一个过程。随后的过程应用将新绑定（实际参数）与保存的环境相结合。
- en: The interpreter handles only the core syntactic forms described in Section [3.1](further.html#g50),
    and it recognizes bindings for only a handful of primitive procedures. It performs
    no error checking.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器仅处理第[3.1](further.html#g50)节中描述的核心语法形式，并且仅识别一些原语过程的绑定。它不执行错误检查。
- en: '`(interpret 3) ![<graphic>](ch2_0.gif) 3'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '`(interpret 3) ![<graphic>](ch2_0.gif) 3'
- en: (interpret '(cons 3 4)) ![<graphic>](ch2_0.gif) (3 . 4)
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: (interpret '(cons 3 4)) ![<graphic>](ch2_0.gif) (3 . 4)
- en: (interpret
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: (interpret
- en: '''((lambda (x . y)'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '''((lambda (x . y)'
- en: (list x y))
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: (list x y))
- en: '''a ''b ''c ''d)) ![<graphic>](ch2_0.gif) (a (b c d))'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '''a ''b ''c ''d)) ![<graphic>](ch2_0.gif) (a (b c d))'
- en: (interpret
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: (interpret
- en: '''(((call/cc (lambda (k) k))'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '''(((call/cc (lambda (k) k))'
- en: (lambda (x) x))
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x) x))
- en: '"HEY!")) ![<graphic>](ch2_0.gif) "HEY!"'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '"HEY!")) ![<graphic>](ch2_0.gif) "HEY!"'
- en: (interpret
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: (interpret
- en: '''((lambda (memq)'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '''((lambda (memq)'
- en: (memq memq 'a '(b c a d e)))
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: (memq memq 'a '(b c a d e)))
- en: (lambda (memq x ls)
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (memq x ls)
- en: (if (null? ls) #f
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls) #f
- en: (if (eq? (car ls) x)
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: (if (eq? (car ls) x)
- en: ls
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: ls
- en: (memq memq x (cdr ls))))))) ![<graphic>](ch2_0.gif) (a d e)
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: (memq memq x (cdr ls))))))) ![<graphic>](ch2_0.gif) (a d e)
- en: (interpret
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: (interpret
- en: '''((lambda (reverse)'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '''((lambda (reverse)'
- en: (set! reverse
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: (set! reverse
- en: (lambda (ls new)
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls new)
- en: (if (null? ls)
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? ls)
- en: new
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: new
- en: (reverse (cdr ls) (cons (car ls) new)))))
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: (reverse (cdr ls) (cons (car ls) new)))))
- en: (reverse '(a b c d e) '()))
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: (reverse '(a b c d e) '()))
- en: '#f)) ![<graphic>](ch2_0.gif) (e d c b a)`'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '#f)) ![<graphic>](ch2_0.gif) (e d c b a)`'
- en: '`(library (tspl interpreter)'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '`(library (tspl interpreter)'
- en: (export interpret)
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: (export interpret)
- en: (import (rnrs) (rnrs mutable-pairs))
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: (import (rnrs) (rnrs mutable-pairs))
- en: ; primitive-environment contains a small number of primitive
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: ; primitive-environment 包含了一小部分原语
- en: ; procedures; it can be extended easily with additional primitives.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: ; 过程; 可以很容易地通过添加额外的原语来扩展。
- en: (define primitive-environment
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: (define primitive-environment
- en: '`((apply . ,apply) (assq . ,assq) (call/cc . ,call/cc)'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '`((apply . ,apply) (assq . ,assq) (call/cc . ,call/cc)'
- en: (car . ,car) (cadr . ,cadr) (caddr . ,caddr)
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: (car . ,car) (cadr . ,cadr) (caddr . ,caddr)
- en: (cadddr . ,cadddr) (cddr . ,cddr) (cdr . ,cdr)
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: (cadddr . ,cadddr) (cddr . ,cddr) (cdr . ,cdr)
- en: (cons . ,cons) (eq? . ,eq?) (list . ,list) (map . ,map)
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: (cons . ,cons) (eq? . ,eq?) (list . ,list) (map . ,map)
- en: (memv . ,memv) (null? . ,null?) (pair? . ,pair?)
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: (memv . ,memv) (null? . ,null?) (pair? . ,pair?)
- en: (read . ,read) (set-car! . ,set-car!)
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: (read . ,read) (set-car! . ,set-car!)
- en: (set-cdr! . ,set-cdr!) (symbol? . ,symbol?)))
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cdr! . ,set-cdr!) (symbol? . ,symbol?)))
- en: ; new-env returns a new environment from a formal parameter
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: ; new-env 从形式参数返回一个新环境
- en: ; specification, a list of actual parameters, and an outer
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: ; 规范，实际参数列表和外部
- en: ; environment.  The symbol? test identifies "improper"
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: ; 环境。symbol? 测试识别“不正确的”
- en: ; argument lists.  Environments are association lists,
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: ; 参数列表。环境是关联列表，
- en: ; associating variables with values.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: ; 将变量与值关联起来。
- en: (define new-env
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: (define new-env
- en: (lambda (formals actuals env)
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (formals actuals env)
- en: (cond
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(null? formals) env]'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '[(null? formals) env]'
- en: '[(symbol? formals) (cons (cons formals actuals) env)]'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '[(symbol? formals) (cons (cons formals actuals) env)]'
- en: '[else'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '[else'
- en: (cons
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: (cons
- en: (cons (car formals) (car actuals))
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (car formals) (car actuals))
- en: (new-env (cdr formals) (cdr actuals) env))])))
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: (new-env (cdr formals) (cdr actuals) env))])))
- en: ; lookup finds the value of the variable var in the environment
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: ; lookup 在环境中查找变量 var 的值
- en: ; env, using assq.  Assumes var is bound in env.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: ; env，使用 assq。假设 var 在 env 中绑定。
- en: (define lookup
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: (define lookup
- en: (lambda (var env)
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (var env)
- en: (cdr (assq var env))))
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: (cdr (assq var env))))
- en: ; assign is similar to lookup but alters the binding of the
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: ; assign 类似于 lookup 但改变了变量的绑定
- en: ; variable var by changing the cdr of the association pair
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: ; 通过更改关联对的 cdr 来更改变量 var 的绑定
- en: (define assign
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: (define assign
- en: (lambda (var val env)
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (var val env)
- en: (set-cdr! (assq var env) val)))
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cdr! (assq var env) val)))
- en: ; exec evaluates the expression, recognizing a small set of core forms.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: ; exec 评估表达式，识别一小组核心形式。
- en: (define exec
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: (define exec
- en: (lambda (expr env)
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (expr env)
- en: (cond
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(symbol? expr) (lookup expr env)]'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '[(symbol? expr) (lookup expr env)]'
- en: '[(pair? expr)'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '[(pair? expr)'
- en: (case (car expr)
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: (case (car expr)
- en: '[(quote) (cadr expr)]'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '[(quote) (cadr expr)]'
- en: '[(lambda)'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '[(lambda)'
- en: (lambda vals
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda vals
- en: (let ([env (new-env (cadr expr) vals env)])
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([env (new-env (cadr expr) vals env)])
- en: (let loop ([exprs (cddr expr)])
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: (let loop ([exprs (cddr expr)])
- en: (if (null? (cdr exprs))
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? (cdr exprs))
- en: (exec (car exprs) env)
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: (exec (car exprs) env)
- en: (begin
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: (begin
- en: (exec (car exprs) env)
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: (exec (car exprs) env)
- en: (loop (cdr exprs)))))))]
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: (loop (cdr exprs)))))))]
- en: '[(if)'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '[(if)'
- en: (if (exec (cadr expr) env)
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: (if (exec (cadr expr) env)
- en: (exec (caddr expr) env)
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: (exec (caddr expr) env)
- en: (exec (cadddr expr) env))]
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: (exec (cadddr expr) env))]
- en: '[(set!) (assign (cadr expr) (exec (caddr expr) env) env)]'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '[(set!) (assign (cadr expr) (exec (caddr expr) env) env)]'
- en: '[else'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '[else'
- en: (apply
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: (apply
- en: (exec (car expr) env)
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: (exec (car expr) env)
- en: (map (lambda (x) (exec x env)) (cdr expr)))])]
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: (map (lambda (x) (exec x env)) (cdr expr))))]
- en: '[else expr])))'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '[else expr])))'
- en: ; interpret starts execution with the primitive environment.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: ; 解释器从基本环境开始执行。
- en: (define interpret
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: (define interpret
- en: (lambda (expr)
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (expr)
- en: (exec expr  primitive-environment))))`
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: (exec expr  primitive-environment))))`
- en: Exercise 12.7.1
  id: totrans-755
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.7.1
- en: 'As written, the interpreter cannot interpret itself because it does not support
    several of the syntactic forms used in its implementation: `let` (named and unnamed),
    internal `define`, `case`, `cond`, and `begin`. Rewrite the code for the interpreter,
    using only the syntactic forms it supports.'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 如写的那样，解释器无法解释自身，因为它不支持其实现中使用的几种语法形式：`let`（命名和未命名）、内部 `define`、`case`、`cond`
    和 `begin`。重新编写解释器的代码，只使用它支持的语法形式。
- en: Exercise 12.7.2
  id: totrans-757
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.7.2
- en: After completing the preceding exercise, use the interpreter to run a copy of
    the interpreter, and use the copy to run another copy of the interpreter. Repeat
    this process to see how many levels deep it will go before the system grinds to
    a halt.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成前面的练习后，使用解释器运行一个解释器的副本，并使用该副本运行另一个解释器的副本。重复此过程，看看系统在停止之前会深入多少级。
- en: Exercise 12.7.3
  id: totrans-759
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.7.3
- en: At first glance, it might seem that the `lambda` case could be written more
    simply as follows.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，似乎 `lambda` 情况可以更简单地写成如下。
- en: '`[(lambda)'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '`[(lambda)'
- en: (lambda vals
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda vals
- en: (let ([env (new-env (cadr expr) vals env)])
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([env (new-env (cadr expr) vals env)])
- en: (let loop ([exprs (cddr expr)])
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: (let loop ([exprs (cddr expr)])
- en: (let ([val (exec (car exprs) env)])
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([val (exec (car exprs) env)])
- en: (if (null? (cdr exprs))
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? (cdr exprs))
- en: val
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: val
- en: (loop (cdr exprs)))))))]`
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: (loop (cdr exprs)))))))]`
- en: 'Why would this be incorrect? [*Hint*: What property of Scheme would be violated?]'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这样是不正确的？[*提示*：Scheme 的哪个属性会被违反？]
- en: Exercise 12.7.4
  id: totrans-770
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.7.4
- en: 'Try to make the interpreter more efficient by looking for ways to ask fewer
    questions or to allocate less storage space. [*Hint*: Before evaluation, convert
    lexical variable references into `(access *n*)`, where `*n*` represents the number
    of values in the environment association list in front of the value in question.]'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过寻找方法减少提问或分配更少的存储空间来使解释器更高效。[*提示*：在评估之前，将词法变量引用转换为`(access *n*)`，其中`*n*`表示问题值前面的环境关联列表中的值的数量。
- en: Exercise 12.7.5
  id: totrans-772
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习12.7.5
- en: 'Scheme evaluates arguments to a procedure before applying the procedure and
    applies the procedure to the values of these arguments (*call-by-value*). Modify
    the interpreter to pass arguments unevaluated and arrange to evaluate them upon
    reference (*call-by-name*). [*Hint*: Use `lambda` to delay evaluation.] You will
    need to create versions of the primitive procedures (`car`, `null?`, etc.) that
    take their arguments unevaluated.'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme在应用过程之前评估过程的参数，并将过程应用于这些参数的值（*按值调用*）。修改解释器以传递未评估的参数，并安排在引用时评估它们（*按名调用*）。[*提示*：使用`lambda`延迟评估。]
    您需要创建接受未评估参数的原始过程（`car`、`null?`等）的版本。
- en: Section 12.8\. Defining Abstract Objects
  id: totrans-774
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第12.8节。定义抽象对象
- en: This example demonstrates a syntactic extension that facilitates the definition
    of simple abstract objects (see Section [2.9](start.html#g40)). This facility
    has unlimited potential as the basis for a complete object-oriented subsystem
    in Scheme.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例演示了一种语法扩展，有助于定义简单的抽象对象（参见第[2.9](start.html#g40)节）。这种功能具有作为Scheme中完整面向对象子系统基础的无限潜力。
- en: Abstract objects are similar to basic data structures such as pairs and vectors.
    Rather than being manipulated via access and assignment operators, however, abstract
    objects respond to *messages*. The valid messages and the actions to be taken
    for each message are defined by code within the object itself rather than by code
    outside the object, resulting in more modular and potentially more secure programming
    systems. The data local to an abstract object is accessible only through the actions
    performed by the object in response to the messages.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象对象类似于基本数据结构，如对和向量。然而，与通过访问和赋值运算符进行操作不同，抽象对象响应*消息*。有效的消息及每个消息所采取的操作由对象本身内部的代码定义，而不是由对象外部的代码定义，从而产生更模块化和潜在更安全的编程系统。抽象对象本地的数据只能通过对象响应消息时执行的操作访问。
- en: A particular type of abstract object is defined with `define-object`, which
    has the general form
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`define-object`定义了一种特定类型的抽象对象，其一般形式为
- en: '`(define-object (*name* *var[1]* ...)'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-object (*name* *var[1]* ...)'
- en: ((*var[2]* *expr*) ...)
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: ((*var[2]* *expr*) ...)
- en: ((*msg* *action*) ...))`
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: ((*msg* *action*) ...))`
- en: The first set of bindings `((*var[2]* *expr*) ...)` may be omitted. `define-object`
    defines a procedure that is called to create new abstract objects of the given
    type. This procedure is called `*name*`, and the arguments to this procedure become
    the values of the local variables `*var[1]* ...`. After the procedure is invoked,
    the variables `*var[2]* ...` are bound to the values `*expr* ...` in sequence
    (as with `let*`) and the messages `*msg* ...` are bound to the procedure values
    `*action* ...` in a mutually recursive fashion (as with `letrec`). Within these
    bindings, the new abstract object is created; this object is the value of the
    creation procedure.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组绑定`((*var[2]* *expr*) ...)`可以省略。`define-object`定义了一个过程，用于创建给定类型的新抽象对象。此过程称为`*name*`，并且此过程的参数成为本地变量`*var[1]* ...`的值。在调用过程之后，变量`*var[2]* ...`按顺序绑定到值`*expr* ...`（与`let*`一样），并且消息`*msg* ...`以相互递归的方式绑定到过程值`*action* ...`（与`letrec`一样）。在这些绑定内部，创建新的抽象对象；此对象是创建过程的值。
- en: The syntactic form `send-message` is used to send messages to abstract objects.
    `(send-message *object* *msg* *arg* ...)` sends `*object*` the message `*msg*`
    with arguments `*arg* ...`. When an object receives a message, the `*arg* ...`
    become the parameters to the action procedure associated with the message, and
    the value returned by this procedure is returned by `send-message`.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 语法形式`send-message`用于向抽象对象发送消息。`(send-message *object* *msg* *arg* ...)`向`*object*`发送带有参数`*arg* ...`的消息`*msg*`。当对象接收消息时，`*arg* ...`成为与消息相关联的操作过程的参数，并且此过程返回的值由`send-message`返回。
- en: The following examples should help to clarify how abstract objects are defined
    and used. The first example is a simple `kons` object that is similar to Scheme's
    built-in pair object type, except that to access or assign its fields requires
    sending it messages.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例应有助于澄清如何定义和使用抽象对象。第一个示例是一个简单的`kons`对象，类似于Scheme内置的对对象类型，除了访问或分配其字段需要发送消息外。
- en: '`(define-object (kons kar kdr)'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-object (kons kar kdr)'
- en: ((get-car (lambda () kar))
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: ((get-car (lambda () kar))
- en: (get-cdr (lambda () kdr))
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: (get-cdr (lambda () kdr))
- en: (set-car! (lambda (x) (set! kar x)))
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: (set-car! (lambda (x) (set! kar x)))
- en: (set-cdr! (lambda (x) (set! kdr x)))))
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cdr! (lambda (x) (set! kdr x)))))
- en: (define p (kons 'a 'b))
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: (define p (kons 'a 'b))
- en: (send-message p get-car) ![<graphic>](ch2_0.gif) a
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: (send-message p get-car) ![<graphic>](ch2_0.gif) a
- en: (send-message p get-cdr) ![<graphic>](ch2_0.gif) b
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: (send-message p get-cdr) ![<graphic>](ch2_0.gif) b
- en: (send-message p set-cdr! 'c)
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: (send-message p set-cdr! 'c)
- en: (send-message p get-cdr) ![<graphic>](ch2_0.gif) c`
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: (send-message p get-cdr) ![<graphic>](ch2_0.gif) c`
- en: The simple `kons` object does nothing but return or assign one of the fields
    as requested. What makes abstract objects interesting is that they can be used
    to restrict access or perform additional services. The following version of `kons`
    requires that a password be given with any request to assign one of the fields.
    This password is a parameter to the `kons` procedure.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的`kons`对象除了按请求返回或分配字段之外什么也不做。抽象对象有趣的地方在于它们可以用来限制访问或执行其他服务。下面的`kons`版本要求在对字段进行任何分配请求时都提供密码。此密码是`kons`过程的参数。
- en: '`(define-object (kons kar kdr pwd)'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-object (kons kar kdr pwd)'
- en: ((get-car (lambda () kar))
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: ((get-car (lambda () kar))
- en: (get-cdr (lambda () kar))
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: (get-cdr (lambda () kar))
- en: (set-car!
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: (set-car!
- en: (lambda (x p)
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x p)
- en: (if (string=? p pwd)
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: (if (string=? p pwd)
- en: (set! kar x))))
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: (set! kar x))))
- en: (set-cdr!
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: (set-cdr!
- en: (lambda (x p)
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x p)
- en: (if (string=? p pwd)
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: (if (string=? p pwd)
- en: (set! kar x))))))
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: (set! kar x))))))
- en: (define p1 (kons 'a 'b "magnificent"))
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: (define p1 (kons 'a 'b "magnificent"))
- en: (send-message p1 set-car! 'c "magnificent")
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: (send-message p1 set-car! 'c "magnificent")
- en: (send-message p1 get-car) ![<graphic>](ch2_0.gif) c
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: (send-message p1 get-car) ![<graphic>](ch2_0.gif) c
- en: (send-message p1 set-car! 'd "please")
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: (send-message p1 set-car! 'd "please")
- en: (send-message p1 get-car) ![<graphic>](ch2_0.gif) c
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: (send-message p1 get-car) ![<graphic>](ch2_0.gif) c
- en: (define p2 (kons 'x 'y "please"))
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: (define p2 (kons 'x 'y "please"))
- en: (send-message p2 set-car! 'z "please")
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: (send-message p2 set-car! 'z "please")
- en: (send-message p2 get-car) ![<graphic>](ch2_0.gif) z`
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: (send-message p2 get-car) ![<graphic>](ch2_0.gif) z`
- en: One important ability of an abstract object is that it can keep statistics on
    messages sent to it. The following version of `kons` counts accesses to the two
    fields. This version also demonstrates the use of explicitly initialized local
    bindings.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 一个抽象对象的一个重要能力是它可以对发送给它的消息进行统计。下面的`kons`版本计算对两个字段的访问次数。这个版本还演示了明确初始化局部绑定的用法。
- en: '`(define-object (kons kar kdr)'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-object (kons kar kdr)'
- en: ((count 0))
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: ((count 0))
- en: ((get-car
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: ((get-car
- en: (lambda ()
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (set! count (+ count 1))
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: (set! count (+ count 1))
- en: kar))
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: kar))
- en: (get-cdr
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: (get-cdr
- en: (lambda ()
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (set! count (+ count 1))
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: (set! count (+ count 1))
- en: kdr))
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: kdr))
- en: (accesses
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: (accesses
- en: (lambda () count))))
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () count))))
- en: (define p (kons 'a 'b))
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: (define p (kons 'a 'b))
- en: (send-message p get-car) ![<graphic>](ch2_0.gif) a
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: (send-message p get-car) ![<graphic>](ch2_0.gif) a
- en: (send-message p get-cdr) ![<graphic>](ch2_0.gif) b
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: (send-message p get-cdr) ![<graphic>](ch2_0.gif) b
- en: (send-message p accesses) ![<graphic>](ch2_0.gif) 2
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: (send-message p accesses) ![<graphic>](ch2_0.gif) 2
- en: (send-message p get-cdr) ![<graphic>](ch2_0.gif) b
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: (send-message p get-cdr) ![<graphic>](ch2_0.gif) b
- en: (send-message p accesses) ![<graphic>](ch2_0.gif) 3`
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: (send-message p accesses) ![<graphic>](ch2_0.gif) 3`
- en: The implementation of `define-object` is straightforward. The object definition
    is transformed into a definition of the object creation procedure. This procedure
    is the value of a `lambda` expression whose arguments are those specified in the
    definition. The body of the `lambda` consists of a `let*` expression to bind the
    local variables and a `letrec` expression to bind the message names to the action
    procedures. The body of the `letrec` is another `lambda` expression whose value
    represents the new object. The body of this `lambda` expression compares the messages
    passed in with the expected messages using a `case` expression and applies the
    corresponding action procedure to the remaining arguments.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`define-object`是直接的。对象定义被转换为对象创建过程的定义。这个过程是一个`lambda`表达式的值，其参数是在定义中指定的那些。`lambda`的主体由一个`let*`表达式组成，用于绑定局部变量，以及一个`letrec`表达式，用于将消息名称绑定到动作过程。`letrec`的主体是另一个`lambda`表达式，其值代表新对象。这个`lambda`表达式的主体将传入的消息与预期的消息进行比较，使用`case`表达式，并将相应的动作过程应用于剩余的参数。
- en: For example, the definition
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，定义
- en: '`(define-object (kons kar kdr)'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-object (kons kar kdr)'
- en: ((count 0))
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: ((count 0))
- en: ((get-car
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: ((get-car
- en: (lambda ()
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (set! count (+ count 1))
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: (set! count (+ count 1))
- en: kar))
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: kar))
- en: (get-cdr
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: (get-cdr
- en: (lambda ()
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (set! count (+ count 1))
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: (set! count (+ count 1))
- en: kdr))
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: kdr))
- en: (accesses
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: (accesses
- en: (lambda () count))))`
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () count))))`
- en: is transformed into
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 被转换为
- en: '`(define kons'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define kons'
- en: (lambda (kar kdr)
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (kar kdr)
- en: (let* ([count 0])
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: (let* ([count 0])
- en: (letrec ([get-car
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: (letrec ([get-car
- en: (lambda ()
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (set! count (+ count 1)) kar)]
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: (set! count (+ count 1)) kar)]
- en: '[get-cdr'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: '[get-cdr'
- en: (lambda ()
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (set! count (+ count 1)) kdr)]
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: (set! count (+ count 1)) kdr)]
- en: '[accesses (lambda () count)])'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '[accesses (lambda () count)])'
- en: (lambda (msg . args)
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (msg . args)
- en: (case msg
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: (case msg
- en: '[(get-car) (apply get-car args)]'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '[(get-car) (apply get-car args)]'
- en: '[(get-cdr) (apply get-cdr args)]'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '[(get-cdr) (apply get-cdr args)]'
- en: '[(accesses) (apply accesses args)]'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '[(accesses) (apply accesses args)]'
- en: '[else (assertion-violation ''kons'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (assertion-violation ''kons'
- en: '"invalid message"'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '"无效消息"'
- en: (cons msg args))]))))))`
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: (cons msg args))]))))))`
- en: '`(library (tspl oop)'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '`(library (tspl oop)'
- en: (export define-object send-message)
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: (export define-object send-message)
- en: (import (rnrs))
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: (import (rnrs))
- en: ; define-object creates an object constructor that uses let* to bind
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: ; define-object 创建一个对象构造函数，使用let*绑定
- en: ; local fields and letrec to define the exported procedures.  An
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: ; 本地字段和letrec用于定义导出的过程。一个
- en: ; object is itself a procedure that accepts messages corresponding
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: ; 对象本身是一个接受与应用程序对应的消息的过程
- en: ; to the names of the exported procedures.  The second pattern is
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: ; 到导出过程的名称。第二个模式是
- en: ; used to allow the set of local fields to be omitted.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: ; 用于允许省略本地字段集。
- en: (define-syntax define-object
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax define-object
- en: (syntax-rules ()
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ (name . varlist)'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ (name . varlist)'
- en: ((var1 val1) ...)
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: ((var1 val1) ...)
- en: ((var2 val2) ...))
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: ((var2 val2) ...))
- en: (define name
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: (define name
- en: (lambda varlist
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda varlist
- en: (let* ([var1 val1] ...)
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: (let* ([var1 val1] ...)
- en: (letrec ([var2 val2] ...)
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: (letrec ([var2 val2] ...)
- en: (lambda (msg . args)
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (msg . args)
- en: (case msg
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: (case msg
- en: '[(var2) (apply var2 args)]'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '[(var2) (apply var2 args)]'
- en: '...'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[else'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '[else'
- en: (assertion-violation 'name
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: (assertion-violation 'name
- en: '"invalid message"'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '"无效消息"'
- en: (cons msg args))]))))))]
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: (cons msg args))]))))))]
- en: '[(_ (name . varlist) ((var2 val2) ...))'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ (name . varlist) ((var2 val2) ...))'
- en: (define-object (name . varlist)
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: (define-object (name . varlist)
- en: ()
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: ()
- en: ((var2 val2) ...))]))
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: ((var2 val2) ...))]))
- en: ; send-message abstracts the act of sending a message from the act
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: ; send-message 将发送消息的行为从发送行为中抽象出来
- en: ; of applying a procedure and allows the message to be unquoted.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: ; 并允许取消引用消息。
- en: (define-syntax send-message
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax send-message
- en: (syntax-rules ()
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ obj msg arg ...)'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ obj msg arg ...)'
- en: (obj 'msg arg ...)])))`
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: (obj 'msg arg ...)])))`
- en: Exercise 12.8.1
  id: totrans-901
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.8.1
- en: Use `define-object` to define the `stack` object type from Section [2.9](start.html#g40).
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`define-object`来定义第[2.9](start.html#g40)节中的`stack`对象类型。
- en: Exercise 12.8.2
  id: totrans-903
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.8.2
- en: Use `define-object` to define a `queue` object type with operations similar
    to those described in Section [2.9](start.html#g40).
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`define-object`来定义一个`queue`对象类型，其操作类似于第[2.9](start.html#g40)节中描述的操作。
- en: Exercise 12.8.3
  id: totrans-905
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.8.3
- en: It is often useful to describe one object in terms of another. For example,
    the second `kons` object type could be described as the same as the first but
    with a password argument and different actions associated with the `set-car!`
    and `set-cdr!` messages. This is called *inheritance*; the new type of object
    is said to *inherit* attributes from the first. Modify `define-object` to support
    inheritance by allowing the optional declaration `(inherit object-name)` to appear
    after the message/action pairs. This will require saving some information about
    each object definition for possible use in subsequent object definitions. Conflicting
    argument names should be disallowed, but other conflicts should be resolved by
    using the initialization or action specified in the new object definition.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 描述一个对象以另一个对象为基础通常很有用。例如，第二个`kons`对象类型可以描述为与第一个相同，但具有密码参数和与`set-car!`和`set-cdr!`消息关联的不同操作。这称为*继承*；新类型的对象被称为*继承*第一个的属性。修改`define-object`以支持继承，允许在消息/操作对之后出现可选声明`(inherit object-name)`。这将需要保存有关每个对象定义的一些信息，以便可能在后续对象定义中使用。应禁止冲突的参数名称，但其他冲突应通过使用新对象定义中指定的初始化或操作来解决。
- en: Exercise 12.8.4
  id: totrans-907
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.8.4
- en: Based on the definition of `method` on page [317](syntax.html#defn:method),
    define a complete object system, but use records rather than vectors to represent
    object instances. If done well, the resulting object system should be more efficient
    and easier to use than the system given above.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 基于第 [317](syntax.html#defn:method) 页的 `method` 定义，定义一个完整的对象系统，但使用记录而不是向量来表示对象实例。如果做得好，得到的对象系统应该比上面给出的系统更有效和更易于使用。
- en: Section 12.9\. Fast Fourier Transform
  id: totrans-909
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 12.9 节。快速傅里叶变换
- en: The procedure described in this section uses Scheme's complex arithmetic to
    compute the discrete *Fourier transform* (DFT) of a sequence of values [[4](bibliography.html#g222)].
    Discrete Fourier transforms are used to analyze and process sampled signal sequences
    in a wide variety of digital electronics applications such as pattern recognition,
    bandwidth compression, radar target detection, and weather surveillance.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述的过程使用 Scheme 的复数算术来计算一系列值的离散*傅里叶变换* (DFT) [[4](bibliography.html#g222)]。离散傅里叶变换用于分析和处理采样信号序列，在数字电子应用中应用广泛，如模式识别、带宽压缩、雷达目标检测和天气监测。
- en: The DFT of a sequence of *N* input values,
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '*N* 个输入值的 DFT 序列，'
- en: '{*x*(*n*)}[*n*=0]^(*N*-1),'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '{*x*(*n*)}[*n*=0]^(*N*-1),'
- en: is the sequence of *N* output values,
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 是 *N* 输出值的序列，
- en: '{*X*(*m*)}[*m*=0]^(*N*-1),'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '{*X*(*m*)}[*m*=0]^(*N*-1),'
- en: each defined by the equation
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都由等式定义
- en: '![<graphic>](32.gif)'
  id: totrans-916
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](32.gif)'
- en: It is convenient to abstract away the constant amount (for given *N*)
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的 *N*，将常量量抽象化是方便的
- en: '![<graphic>](33.gif)'
  id: totrans-918
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](33.gif)'
- en: in order to obtain the more concise but equivalent equation
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 以获得更简洁但等效的方程式
- en: '![<graphic>](34.gif)'
  id: totrans-920
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](34.gif)'
- en: A straightforward computation of the *N* output values, each as a sum of *N*
    intermediate values, requires on the order of *N*² operations. A *fast* Fourier
    transform (FFT), applicable when *N* is a power of 2, requires only on the order
    of *N*log[2]*N* operations. Although usually presented as a rather complicated
    iterative algorithm, the fast Fourier transform is most concisely and elegantly
    expressed as a recursive algorithm.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 对 *N* 个输出值的直接计算，每个值都是 *N* 个中间值的和，需要约 *N*² 次操作。*快速* 傅里叶变换 (FFT)，当 *N* 是 2 的幂时适用，只需要约
    *N*log[2]*N* 次操作。虽然通常呈现为相当复杂的迭代算法，但快速傅里叶变换最简洁、优雅地表达为递归算法。
- en: The recursive algorithm, which is due to Sam Daniel [[7](bibliography.html#g225)],
    can be derived by manipulating the preceding summation as follows. We first split
    the summation into two summations and recombine them into one summation from 0
    to *N*/2 - 1.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 递归算法，归因于 Sam Daniel [[7](bibliography.html#g225)]，可以通过以下方式操纵前述求和推导得出。我们首先将求和拆分为两个求和，并将它们重新组合成一个求和从
    0 到 *N*/2 - 1。
- en: '![<graphic>](35.gif)'
  id: totrans-923
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](35.gif)'
- en: We then pull out the common factor ![<graphic>](36.gif).
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们提取出公共因子 ![<graphic>](36.gif)。
- en: '![<graphic>](37.gif)'
  id: totrans-925
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](37.gif)'
- en: We can reduce ![<graphic>](38.gif) to 1 when *m* is even and -1 when *m* is
    odd, since
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 ![<graphic>](38.gif) 减少到当 *m* 是偶数时为 1，当 *m* 是奇数时为 -1，因为
- en: '![<graphic>](39.gif)'
  id: totrans-927
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](39.gif)'
- en: This allows us to specialize the summation for the even and odd cases of *m*
    = 2*k* and *m* = 2*k* + 1, 0 ≤ *k* ≤ *N*/2 - 1.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够专门为 *m* = 2*k* 和 *m* = 2*k* + 1 的偶数和奇数情况定制求和，其中 0 ≤ *k* ≤ *N*/2 - 1。
- en: '![<graphic>](40.gif)'
  id: totrans-929
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](40.gif)'
- en: The resulting summations are DFTs of the *N*/2-element sequences
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的求和是*N*/2元素序列的 DFT
- en: '{*x*(*n*) + *x*(*n* + *N*/2)}[*n*=0]^(*N*/2-1)'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '{*x*(*n*) + *x*(*n* + *N*/2)}[*n*=0]^(*N*/2-1)'
- en: and
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '![<graphic>](41.gif)'
  id: totrans-933
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](41.gif)'
- en: Thus, the DFT of an N-element sequence can be computed recursively by interlacing
    the DFTs of two *N*/2-element sequences. If we select a base case of two elements,
    we can describe a recursive fast Fourier transformation (RFFT) algorithm as follows.
    For *N* = 2,
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以通过交错两个 *N*/2 元素序列的 DFT 来递归地计算 N 元素序列的 DFT。如果我们选择两个元素作为基本情况，我们可以描述一个递归快速傅里叶变换
    (RFFT) 算法如下。对于 *N* = 2，
- en: '![<graphic>](42.gif)'
  id: totrans-935
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](42.gif)'
- en: since ![<graphic>](43.gif). For *N* > 2,
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ![<graphic>](43.gif)。对于 *N* > 2，
- en: '![<graphic>](44.gif)'
  id: totrans-937
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](44.gif)'
- en: with the attendant interlacing of even and odd components.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随着偶数和奇数分量的交错。
- en: '![<graphic>](45.gif)'
  id: totrans-939
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](45.gif)'
- en: The diagram above is adapted from one by Sam Daniel [[7](bibliography.html#g225)]
    and shows the computational structure of the RFFT algorithm. The first stage computes
    pairwise sums and differences of the first and second halves of the input; this
    stage is labeled the *butterfly* stage. The second stage recurs on the resulting
    subsequences. The third stage interlaces the output of the two recursive calls
    to RFFT, thus yielding the properly ordered sequence {*X*(*m*)}[*m*=0]^(*N*-1).
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 上图改编自Sam Daniel的一幅图[[7](bibliography.html#g225)]，展示了RFFT算法的计算结构。第一阶段计算输入的前半部分和后半部分的成对和差；这个阶段被标记为*butterfly*阶段。第二阶段对结果子序列进行递归。第三阶段将两个递归调用的RFFT的输出交错，从而产生正确排序的序列{*X*(*m*)}[*m*=0]^(*N*-1)。
- en: The procedure `dft` accepts a sequence (list) of values, `x`, the length of
    which is assumed to be a power of 2. `dft` precomputes a sequence of powers of
    ![<graphic>](46.gif), ![<graphic>](47.gif), and calls `rfft` to initiate the recursion.
    `rfft` follows the algorithm outlined above.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 过程`dft`接受一个值序列（列表），`x`，其长度被假定为2的幂。`dft`预先计算一系列的![<graphic>](46.gif)的幂，![<graphic>](47.gif)，并调用`rfft`来启动递归。`rfft`遵循上述算法。
- en: '`(define (dft x)'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define (dft x)'
- en: (define (w-powers n)
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: (define (w-powers n)
- en: (let ([pi (* (acos 0.0) 2)])
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([pi (* (acos 0.0) 2)])
- en: (let ([delta (/ (* -2.0i pi) n)])
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([delta (/ (* -2.0i pi) n)])
- en: (let f ([n n] [x 0.0])
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([n n] [x 0.0])
- en: (if (= n 0)
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: (if (= n 0)
- en: '''()'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (cons (exp x) (f (- n 2) (+ x delta))))))))
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (exp x) (f (- n 2) (+ x delta))))))))
- en: (define (evens w)
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: (define (evens w)
- en: (if (null? w)
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? w)
- en: '''()'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (cons (car w) (evens (cddr w)))))
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (car w) (evens (cddr w)))))
- en: (define (interlace x y)
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: (define (interlace x y)
- en: (if (null? x)
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? x)
- en: '''()'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: (cons (car x) (cons (car y) (interlace (cdr x) (cdr y))))))
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (car x) (cons (car y) (interlace (cdr x) (cdr y))))))
- en: (define (split ls)
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: (define (split ls)
- en: (let split ([fast ls] [slow ls])
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: (let split ([fast ls] [slow ls])
- en: (if (null? fast)
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? fast)
- en: (values '() slow)
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: (values '() slow)
- en: (let-values ([(front back) (split (cddr fast) (cdr slow))])
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: (let-values ([(front back) (split (cddr fast) (cdr slow))])
- en: (values (cons (car slow) front) back)))))
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: (values (cons (car slow) front) back)))))
- en: (define (butterfly x w)
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: (define (butterfly x w)
- en: (let-values ([(front back) (split x)])
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: (let-values ([(front back) (split x)])
- en: (values
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: (values
- en: (map + front back)
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: (map + front back)
- en: (map * (map - front back) w))))
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: (map * (map - front back) w))))
- en: (define (rfft x w)
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: (define (rfft x w)
- en: (if (null? (cddr x))
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: (if (null? (cddr x))
- en: (let ([x0 (car x)] [x1 (cadr x)])
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x0 (car x)] [x1 (cadr x)])
- en: (list (+ x0 x1) (- x0 x1)))
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: (list (+ x0 x1) (- x0 x1)))
- en: (let-values ([(front back) (butterfly x w)])
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: (let-values ([(front back) (butterfly x w)])
- en: (let ([w (evens w)])
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([w (evens w)])
- en: (interlace (rfft front w) (rfft back w))))))
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: (interlace (rfft front w) (rfft back w))))))
- en: (rfft x (w-powers (length x))))`
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: (rfft x (w-powers (length x))))`
- en: Exercise 12.9.1
  id: totrans-977
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.9.1
- en: Alter the algorithm to employ a base case of four points. What simplifications
    can be made to avoid multiplying any of the base case outputs by elements of `w`?
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 修改算法以使用四个点作为基本情况。如何简化以避免将任何基本情况的输出乘以`w`的元素？
- en: Exercise 12.9.2
  id: totrans-979
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.9.2
- en: Recode `dft` to accept a vector rather than a list as input, and have it produce
    a vector as output. Use lists internally if necessary, but do not simply convert
    the input to a list on entry and the output to a vector on exit.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编码`dft`以接受向量而不是列表作为输入，并产生向量作为输出。必要时在内部使用列表，但不要简单地在输入时将其转换为列表，然后在退出时将输出转换为向量。
- en: Exercise 12.9.3
  id: totrans-981
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.9.3
- en: Rather than recomputing the powers of `w` on each step for a new number of points,
    the code simply uses the even-numbered elements of the preceding list of powers.
    Show that doing so yields the proper list of powers. That is, show that `(evens (w-powers n))`
    is equal to `(w-powers (/ n 2))`.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在每一步为新的点数重新计算`w`的幂，代码简单地使用前一个幂列表的偶数元素。展示这样做会产生正确的幂列表。也就是说，展示`(evens (w-powers n))`等于`(w-powers (/ n 2))`。
- en: Exercise 12.9.4
  id: totrans-983
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.9.4
- en: The recursion step creates several intermediate lists that are immediately discarded.
    Recode the recursion step to avoid any unnecessary allocation.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 递归步骤创建了几个立即丢弃的中间列表。重新编码递归步骤以避免任何不必要的分配。
- en: Exercise 12.9.5
  id: totrans-985
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.9.5
- en: Each element of a sequence of input values may be regenerated from the discrete
    Fourier transform of the sequence via the equation
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 输入值序列的每个元素可以通过离散傅立叶变换的方程重新生成
- en: '![<graphic>](48.gif)'
  id: totrans-987
  prefs: []
  type: TYPE_IMG
  zh: '![<graphic>](48.gif)'
- en: Noting the similarity between this equation and the original equation defining
    *X*(*m*), create a modified version of `dft`, `inverse-dft`, that performs the
    inverse transformation. Verify that `(inverse-dft (dft *seq*))` returns `*seq*`
    for several input sequences `*seq*`.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这个方程与定义*X*(*m*)的原始方程之间的相似性，创建一个修改版本的`dft`，`inverse-dft`，执行逆变换。验证`(inverse-dft (dft *seq*))`对几个输入序列`*seq*`返回`*seq*`。
- en: Section 12.10\. A Unification Algorithm
  id: totrans-989
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第12.10节。统一算法
- en: '*Unification* [[23](bibliography.html#g241)] is a pattern-matching technique
    used in automated theorem proving, type-inference systems, computer algebra, and
    logic programming, e.g., Prolog [[6](bibliography.html#g224)].'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: '*统一*是一种模式匹配技术，用于自动定理证明、类型推断系统、计算机代数和逻辑编程，例如，Prolog。'
- en: A unification algorithm attempts to make two symbolic expressions equal by computing
    a unifying substitution for the expressions. A *substitution* is a function that
    replaces variables with other expressions. A substitution must treat all occurrences
    of a variable the same way, e.g., if it replaces one occurrence of the variable
    *x* by *a*, it must replace all occurrences of *x* by *a*. A unifying substitution,
    or *unifier*, for two expressions *e*[1] and *e*[2] is a substitution, ![<graphic>](22.gif),
    such that ![<graphic>](49.gif).
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 一个统一算法尝试通过计算表达式的统一替换来使两个符号表达式相等。*替换*是一个将变量替换为其他表达式的函数。替换必须以相同的方式处理变量的所有出现，例如，如果它用*a*替换变量*x*的一个出现，它必须用*a*替换*x*的所有出现。两个表达式*e*[1]和*e*[2]的统一替换，或*统一器*，是一个替换，![<graphic>](22.gif)，使得![<graphic>](49.gif)。
- en: For example, the two expressions *f*(*x*) and *f*(*y*) can be unified by substituting
    *x* for *y* (or *y* for *x*). In this case, the unifier ![<graphic>](22.gif) could
    be described as the function that replaces *y* with *x* and leaves other variables
    unchanged. On the other hand, the two expressions *x* + 1 and *y* + 2 cannot be
    unified. It might appear that substituting 3 for *x* and 2 for *y* would make
    both expressions equal to 4 and hence equal to each other. The symbolic expressions,
    3 + 1 and 2 + 2, however, still differ.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，两个表达式*f*(*x*)和*f*(*y*)可以通过将*y*替换为*x*（或*x*替换为*y*）统一。在这种情况下，统一器![<graphic>](22.gif)可以描述为将*y*替换为*x*并保持其他变量不变的函数。另一方面，两个表达式*x*
    + 1和*y* + 2无法统一。看起来，将3替换为*x*和2替换为*y*会使两个表达式都等于4，因此相互相等。然而，符号表达式3 + 1和2 + 2仍然不同。
- en: Two expressions may have more than one unifier. For example, the expressions
    *f*(*x*,*y*) and *f*(1,*y*) can be unified to *f*(1,*y*) with the substitution
    of 1 for *x*. They may also be unified to *f*(1,5) with the substitution of 1
    for *x* and 5 for *y*. The first substitution is preferable, since it does not
    commit to the unnecessary replacement of *y*. Unification algorithms typically
    produce the *most general unifier*, or *mgu*, for two expressions. The mgu for
    two expressions makes no unnecessary substitutions; all other unifiers for the
    expressions are special cases of the mgu. In the example above, the first substitution
    is the mgu and the second is a special case.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 两个表达式可能有多个统一器。例如，表达式*f*(*x*,*y*)和*f*(1,*y*)可以通过将1替换为*x*统一为*f*(1,*y*)。它们也可以通过将1替换为*x*和5替换为*y*统一为*f*(1,5)。第一个替换是首选的，因为它不会对*y*进行不必要的替换。统一算法通常为两个表达式生成*最一般统一器*，或*mgu*。两个表达式的mgu不进行不必要的替换；表达式的所有其他统一器都是mgu的特例。在上面的例子中，第一个替换是mgu，第二个是特例。
- en: For the purposes of this program, a symbolic expression can be a variable, a
    constant, or a function application. Variables are represented by Scheme symbols,
    e.g., `x`; a function application is represented by a list with the function name
    in the first position and its arguments in the remaining positions, e.g., `(f x)`;
    and constants are represented by zero-argument functions, e.g., `(a)`.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个程序的目的，符号表达式可以是变量、常量或函数应用。变量由Scheme符号表示，例如，`x`；函数应用由列表表示，函数名在第一个位置，参数在其余位置，例如，`(f x)`；常量由零参数函数表示，例如，`(a)`。
- en: The algorithm presented here finds the mgu for two terms, if it exists, using
    a continuation-passing style, or CPS (see Section [3.4](further.html#g75)), approach
    to recursion on subterms. The procedure `unify` takes two terms and passes them
    to a help procedure, `uni`, along with an initial (identity) substitution, a success
    continuation, and a failure continuation. The success continuation returns the
    result of applying its argument, a substitution, to one of the terms, i.e., the
    unified result. The failure continuation simply returns its argument, a message.
    Because control passes by explicit continuation within `unify` (always with tail
    calls), a return from the success or failure continuation is a return from `unify`
    itself.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍的算法使用传递继续风格或CPS（参见第[3.4](further.html#g75)节）的方法，在子术语上递归找到两个术语的mgu（如果存在）。过程`unify`接受两个术语，并将它们传递给一个帮助过程`uni`，同时还有一个初始（身份）替换、一个成功继续和一个失败继续。成功继续返回将其参数，一个替换，应用于其中一个术语的结果，即统一的结果。失败继续简单地返回其参数，一个消息。因为在`unify`内部通过显式继续传递控制（始终使用尾调用），从成功或失败继续返回就是从`unify`本身返回。
- en: Substitutions are procedures. Whenever a variable is to be replaced by another
    term, a new substitution is formed from the variable, the term, and the existing
    substitution. Given a term as an argument, the new substitution replaces occurrences
    of its saved variable with its saved term in the result of invoking the saved
    substitution on the argument expression. Intuitively, a substitution is a chain
    of procedures, one for each variable in the substitution. The chain is terminated
    by the initial, identity substitution.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 替换是过程。每当一个变量需要被另一个术语替换时，就会从变量、术语和现有替换中形成一个新替换。给定一个术语作为参数，新替换将在调用保存的变量的出现次数中用保存的术语替换其保存的变量的结果上。直观地说，替换是一系列过程，每个变量在替换中对应一个过程。链由初始的身份替换终止。
- en: '`(unify ''x ''y) ![<graphic>](ch2_0.gif) y'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '`(统一 ''x ''y) ![<graphic>](ch2_0.gif) y'
- en: (unify '(f x y) '(g x y)) ![<graphic>](ch2_0.gif) "clash"
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: (统一 '(f x y) '(g x y)) ![<graphic>](ch2_0.gif) "clash"
- en: (unify '(f x (h)) '(f (h) y)) ![<graphic>](ch2_0.gif) (f (h) (h))
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: (统一 '(f x (h)) '(f (h) y)) ![<graphic>](ch2_0.gif) (f (h) (h))
- en: (unify '(f (g x) y) '(f y x)) ![<graphic>](ch2_0.gif) "cycle"
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: (统一 '(f (g x) y) '(f y x)) ![<graphic>](ch2_0.gif) "cycle"
- en: (unify '(f (g x) y) '(f y (g x))) ![<graphic>](ch2_0.gif) (f (g x) (g x))
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: (统一 '(f (g x) y) '(f y (g x))) ![<graphic>](ch2_0.gif) (f (g x) (g x))
- en: (unify '(f (g x) y) '(f y z)) ![<graphic>](ch2_0.gif) (f (g x) (g x))`
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: (统一 '(f (g x) y) '(f y z)) ![<graphic>](ch2_0.gif) (f (g x) (g x))`
- en: '`(library (tspl unification)'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: '`(库 (tspl unification)'
- en: (export unify)
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: (导出 unify)
- en: (import (rnrs))
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: (导入 (rnrs))
- en: ; occurs? returns true if and only if u occurs in v
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: ; occurs? 仅在u出现在v中时返回true
- en: (define occurs?
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 occurs?
- en: (lambda (u v)
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (u v)
- en: (and (pair? v)
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: (并且 (pair? v)
- en: (let f ([l (cdr v)])
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: (让 f ([l (cdr v)])
- en: (and (pair? l)
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: (并且 (pair? l)
- en: (or (eq? u (car l))
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: (或 (eq? u (car l))
- en: (occurs? u (car l))
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: (occurs? u (car l))
- en: (f (cdr l))))))))
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: (f (cdr l))))))))
- en: ; sigma returns a new substitution procedure extending s by
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: ; sigma 通过返回一个扩展s的新替换过程来返回
- en: ; the substitution of u with v
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: ; 用v替换u的替换
- en: (define sigma
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 sigma
- en: (lambda (u v s)
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (u v s)
- en: (lambda (x)
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (let f ([x (s x)])
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: (让 f ([x (s x)])
- en: (if (symbol? x)
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 (symbol? x)
- en: (if (eq? x u) v x)
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 (eq? x u) v x)
- en: (cons (car x) (map f (cdr x))))))))
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (car x) (map f (cdr x))))))))
- en: ; try-subst tries to substitute u for v but may require a
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: ; try-subst 尝试用v替换u，但可能需要
- en: ; full unification if (s u) is not a variable, and it may
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: ; 如果 (s u) 不是一个变量，则进行完全统一
- en: ; fail if it sees that u occurs in v.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: ; 如果看到u出现在v中，则失败。
- en: (define try-subst
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 try-subst
- en: (lambda (u v s ks kf)
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (u v s ks kf)
- en: (let ([u (s u)])
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: (让 ([u (s u)])
- en: (if (not (symbol? u))
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 (不 (symbol? u))
- en: (uni u v s ks kf)
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: (uni u v s ks kf)
- en: (let ([v (s v)])
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: (让 ([v (s v)])
- en: (cond
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: (条件
- en: '[(eq? u v) (ks s)]'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: '[(eq? u v) (ks s)]'
- en: '[(occurs? u v) (kf "cycle")]'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '[(occurs? u v) (kf "cycle")]'
- en: '[else (ks (sigma u v s))]))))))'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '[其他 (ks (sigma u v s))]))))))'
- en: ; uni attempts to unify u and v with a continuation-passing
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: ; uni 尝试使用传递继续统一u和v
- en: ; style that returns a substitution to the success argument
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: ; 返回一个将替换返回给成功参数的样式
- en: ; ks or an error message to the failure argument kf.  The
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: ; ks 或者错误消息返回给失败参数kf。 
- en: ; substitution itself is represented by a procedure from
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: ; 替换本身由一个过程表示
- en: ; variables to terms.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: ; 变量到术语。
- en: (define uni
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: (定义 uni
- en: (lambda (u v s ks kf)
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (u v s ks kf)
- en: (cond
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: (条件
- en: '[(symbol? u) (try-subst u v s ks kf)]'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '[(symbol? u) (try-subst u v s ks kf)]'
- en: '[(symbol? v) (try-subst v u s ks kf)]'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '[(symbol? v) (try-subst v u s ks kf)]'
- en: '[(and (eq? (car u) (car v))'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '[(并且 (eq? (car u) (car v))'
- en: (= (length u) (length v)))
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: (= (length u) (length v)))
- en: (let f ([u (cdr u)] [v (cdr v)] [s s])
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: (让 f ([u (cdr u)] [v (cdr v)] [s s])
- en: (if (null? u)
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 (null? u)
- en: (ks s)
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: (ks s)
- en: (uni (car u)
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: (uni (car u)
- en: (car v)
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: (car v)
- en: s
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: s
- en: (lambda (s) (f (cdr u) (cdr v) s))
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (s) (f (cdr u) (cdr v) s))
- en: kf)))]
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: kf)))]
- en: '[else (kf "clash")])))'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (kf "clash")])))'
- en: ; unify shows one possible interface to uni, where the initial
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: ; unify 展示了 uni 的一个可能接口，其中初始
- en: ; substitution is the identity procedure, the initial success
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: ; 替换是恒等过程，初始成功
- en: ; continuation returns the unified term, and the initial failure
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: ; 延续返回统一的术语，初始失败
- en: ; continuation returns the error message.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: ; 延续返回错误消息。
- en: (define unify
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: (define unify
- en: (lambda (u v)
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (u v)
- en: (uni u
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: (uni u
- en: v
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: v
- en: (lambda (x) x)
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x) x)
- en: (lambda (s) (s u))
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (s) (s u))
- en: (lambda (msg) msg)))))`
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (msg) msg)))))`
- en: Exercise 12.10.1
  id: totrans-1069
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.10.1
- en: Modify `unify` so that it returns its substitution rather than the unified term.
    Apply this substitution to both input terms to verify that it returns the same
    result for each.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `unify`，使其返回其替换而不是统一的术语。将此替换应用于两个输入术语，以验证它对每个输入返回相同的结果。
- en: Exercise 12.10.2
  id: totrans-1071
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.10.2
- en: As mentioned above, substitutions on a term are performed sequentially, requiring
    one entire pass through the input expression for each substituted variable. Represent
    the substitution differently so that only one pass through the expression need
    be made. Make sure that substitutions are performed not only on the input expression
    but also on any expressions you insert during substitution.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，对术语的替换是顺序执行的，每替换一个变量需要对输入表达式进行一整个遍历。以不同方式表示替换，使得只需对表达式进行一次遍历。确保替换不仅在输入表达式上执行，还在替换过程中插入的任何表达式上执行。
- en: Exercise 12.10.3
  id: totrans-1073
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 12.10.3
- en: Extend the continuation-passing style unification algorithm into an entire continuation-passing
    style logic programming system.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 将延续传递风格的统一算法扩展为整个延续传递风格逻辑编程系统。
- en: Section 12.11\. Multitasking with Engines
  id: totrans-1075
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 12.11 节。使用引擎进行多任务处理
- en: Engines are a high-level process abstraction supporting *timed preemption* [[10](bibliography.html#g228),[15](bibliography.html#g233)].
    Engines may be used to simulate multiprocessing, implement light-weight threads,
    implement operating system kernels, and perform nondeterministic computations.
    The engine implementation is one of the more interesting applications of continuations
    in Scheme.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎是支持*定时抢占*的高级进程抽象[[10](bibliography.html#g228),[15](bibliography.html#g233)]。引擎可用于模拟多处理，实现轻量级线程，实现操作系统内核，并执行非确定性计算。引擎实现是
    Scheme 中延续的更有趣的应用之一。
- en: 'An engine is created by passing a thunk (procedure of no arguments) to the
    procedure `make-engine`. The body of the thunk is the computation to be performed
    by the engine. An engine itself is a procedure of three arguments:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将一个 thunk（无参数过程）传递给 `make-engine` 过程来创建一个引擎。thunk 的主体是引擎执行的计算。引擎本身是一个带有三个参数的过程：
- en: '`*ticks*`, a positive integer that specifies the amount of *fuel* to be given
    to the engine. An engine executes until this fuel runs out or until its computation
    finishes.'
  id: totrans-1078
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*ticks*`，一个正整数，指定要提供给引擎的*燃料*量。引擎执行直到燃料耗尽或计算完成。'
- en: '`*complete*`, a procedure of two arguments that specifies what to do if the
    computation finishes. Its arguments will be the amount of fuel left over and the
    result of the computation.'
  id: totrans-1079
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*complete*`，一个带有两个参数的过程，指定计算完成时要执行的操作。其参数将是剩余的燃料量和计算的结果。'
- en: '`*expire*`, a procedure of one argument that specifies what to do if the fuel
    runs out before the computation finishes. Its argument will be a new engine capable
    of continuing the computation from the point of interruption.'
  id: totrans-1080
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*expire*`，一个带有一个参数的过程，指定如果计算完成前燃料耗尽时要执行的操作。其参数将是一个新的引擎，能够从中断点继续计算。'
- en: When an engine is applied to its arguments, it sets up a timer to fire in `*ticks*`
    time units. If the engine computation completes before the timer goes off, the
    system invokes `*complete*`, passing it the number of `*ticks*` left over and
    the value of the computation. If, on the other hand, the timer goes off before
    the engine computation completes, the system creates a new engine from the continuation
    of the interrupted computation and passes this engine to `*expire*`. `*complete*`
    and `*expire*` are invoked in the continuation of the engine invocation.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 当引擎应用于其参数时，它设置一个定时器，在`*ticks*`时间单位后触发。如果引擎计算在定时器触发之前完成，系统调用 `*complete*`，传递剩余的`*ticks*`数量和计算的值。另一方面，如果定时器在引擎计算完成之前触发，系统将从中断的计算的延续创建一个新的引擎，并将此引擎传递给
    `*expire*`。`*complete*` 和 `*expire*` 在引擎调用的延续中被调用。
- en: The following example creates an engine from a trivial computation, 3, and gives
    the engine 10 ticks.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例从一个微不足道的计算（3）创建了一个引擎，并为该引擎提供了 10 个滴答。
- en: '`(define eng'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define eng'
- en: (make-engine
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: (make-engine
- en: (lambda () 3)))
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda () 3)))
- en: (eng 10
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: (eng 10
- en: (lambda (ticks value) value)
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ticks value) value)
- en: (lambda (x) x)) ![<graphic>](ch2_0.gif) 3`
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x) x)) ![<graphic>](ch2_0.gif) 3`
- en: It is often useful to pass `list` as the `*complete*` procedure to an engine,
    causing the engine to return a list of the ticks remaining and the value if the
    computation completes.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `list` 作为引擎的 `*complete*` 过程传递通常是有用的，这会导致引擎返回剩余的滴答数以及计算完成后的值列表。
- en: '`(eng 10'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: '`(eng 10'
- en: list
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: list
- en: (lambda (x) x)) ![<graphic>](ch2_0.gif) (9 3)`
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x) x)) ![<graphic>](ch2_0.gif) (9 3)`
- en: In the example above, the value was 3 and there were 9 ticks left over, i.e.,
    it took only one unit of fuel to evaluate 3. (The fuel amounts given here are
    for illustration only. The actual amount may differ.)
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，值为 3，剩余 9 个滴答，也就是说，只需要一个单位的燃料来评估 3。（这里给出的燃料数量仅供参考。实际数量可能有所不同。）
- en: Typically, the engine computation does not finish in one try. The following
    example displays the use of an engine to compute the 10th Fibonacci number (see
    Section [3.2](further.html#g55)) in steps.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，引擎计算不会在一次尝试中完成。以下示例显示了使用引擎在步骤中计算第 10 个斐波那契数（参见第 [3.2](further.html#g55) 节）的用法。
- en: '`(define fibonacci'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define fibonacci'
- en: (lambda (n)
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (n)
- en: (if (< n 2)
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: (if (< n 2)
- en: n
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: n
- en: (+ (fibonacci (- n 1))
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: (+ (fibonacci (- n 1))
- en: (fibonacci (- n 2))))))
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: (fibonacci (- n 2))))))
- en: (define eng
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: (define eng
- en: (make-engine
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: (make-engine
- en: (lambda ()
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (fibonacci 10))))
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: (fibonacci 10))))
- en: (eng 50
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: (eng 50
- en: list
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: list
- en: (lambda (new-eng)
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (new-eng)
- en: (set! eng new-eng)
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: (set! eng new-eng)
- en: '"expired")) ![<graphic>](ch2_0.gif) "expired"'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '"expired")) ![<graphic>](ch2_0.gif) "expired"'
- en: (eng 50
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: (eng 50
- en: list
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: list
- en: (lambda (new-eng)
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (new-eng)
- en: (set! eng new-eng)
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: (set! eng new-eng)
- en: '"expired")) ![<graphic>](ch2_0.gif) "expired"'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '"expired")) ![<graphic>](ch2_0.gif) "expired"'
- en: (eng 50
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: (eng 50
- en: list
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: list
- en: (lambda (new-eng)
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (new-eng)
- en: (set! eng new-eng)
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: (set! eng new-eng)
- en: '"expired")) ![<graphic>](ch2_0.gif) "expired"'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '"expired")) ![<graphic>](ch2_0.gif) "expired"'
- en: (eng 50
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: (eng 50
- en: list
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: list
- en: (lambda (new-eng)
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (new-eng)
- en: (set! eng new-eng)
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: (set! eng new-eng)
- en: '"expired")) ![<graphic>](ch2_0.gif) (22 55)`'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '"expired")) ![<graphic>](ch2_0.gif) (22 55)`'
- en: Each time the engine's fuel ran out, the `*expire*` procedure assigned `eng`
    to the new engine. The entire computation required four allotments of 50 ticks
    to complete; of the last 50 it used all but 23. Thus, the total amount of fuel
    used was 177 ticks. This leads us to the following procedure, `mileage`, which
    uses engines to "time" a computation.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 每当引擎的燃料耗尽时，`*expire*` 过程将 `eng` 分配给新引擎。整个计算需要四个 50 个滴答的分配才能完成；在最后的 50 个滴答中，除了
    23 个之外，全部用完了。因此，总共使用的燃料量为 177 个滴答。这导致了以下程序 `mileage`，该程序使用引擎来"计时"计算。
- en: '`(define mileage'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define mileage'
- en: (lambda (thunk)
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (thunk)
- en: (let loop ([eng (make-engine thunk)] [total-ticks 0])
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看，循环([eng](thunk)] [total-ticks 0])
- en: (eng 50
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: (eng 50
- en: (lambda (ticks value)
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ticks value)
- en: (+ total-ticks (- 50 ticks)))
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: (+ total-ticks (- 50 ticks)))
- en: (lambda (new-eng)
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (new-eng)
- en: (loop new-eng (+ total-ticks 50)))))))
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: (loop new-eng (+ total-ticks 50)))))))
- en: (mileage (lambda () (fibonacci 10))) ![<graphic>](ch2_0.gif) 178`
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: (mileage (lambda () (fibonacci 10))) ![<graphic>](ch2_0.gif) 178`
- en: The choice of 50 for the number of ticks to use each time is arbitrary, of course.
    It might make more sense to pass a much larger number, say 10000, in order to
    reduce the number of times the computation is interrupted.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 选择每次使用 50 个滴答的数量是任意的，当然也可以选择一个更大的数字，例如 10000，以减少计算被中断的次数。
- en: The next procedure, `round-robin`, could be the basis for a simple time-sharing
    operating system. `round-robin` maintains a queue of processes (a list of engines)
    and cycles through the queue in a *round-robin* fashion, allowing each process
    to run for a set amount of time. `round-robin` returns a list of the values returned
    by the engine computations in the order that the computations complete.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个过程 `round-robin` 可以成为一个简单的时间共享操作系统的基础。 `round-robin` 维护一个进程队列（引擎列表），并以*轮转*方式循环遍历队列，允许每个进程运行一段时间。
    `round-robin` 返回引擎计算返回的值列表，按计算完成的顺序排列。
- en: '`(define round-robin'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define round-robin'
- en: (lambda (engs)
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (engs)
- en: (if (null? engs)
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `engs` 为 `null`，
- en: '''()'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: '''()'
- en: ((car engs) 1
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: ((car engs) 1
- en: (lambda (ticks value)
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ticks value)
- en: (cons value (round-robin (cdr engs))))
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: (cons value (round-robin (cdr engs))))
- en: (lambda (eng)
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (eng)
- en: (round-robin
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: (round-robin
- en: (append (cdr engs) (list eng))))))))`
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: (append (cdr engs) (list eng))))))))`
- en: Assuming the amount of computation corresponding to one tick is constant, the
    effect of `round-robin` is to return a list of the values sorted from the quickest
    to complete to the slowest to complete. Thus, when we call `round-robin` on a
    list of engines, each computing one of the Fibonacci numbers, the output list
    is sorted with the earlier Fibonacci numbers first, regardless of the order of
    the input list.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: '''假设与一个 tick 相对应的计算量是恒定的，则 `round-robin` 的效果是返回一个列表，其中包含从最快完成到最慢完成的值。因此，当我们对一个引擎列表调用
    `round-robin`，每个引擎计算一个斐波那契数时，输出列表按照较早的斐波那契数排在前面，而不管输入列表的顺序如何。'''
- en: '`(round-robin'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '''`（round-robin'''
- en: (map (lambda (x)
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '`(map (lambda (x)`'
- en: (make-engine
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '`(make-engine`'
- en: (lambda ()
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda ()`'
- en: (fibonacci x))))
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: '`(fibonacci x))))`'
- en: '''(4 5 2 8 3 7 6 2))) ![<graphic>](ch2_0.gif) (1 1 2 3 5 8 13 21)`'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: '`''（4 5 2 8 3 7 6 2）` ![<graphic>](ch2_0.gif) `(1 1 2 3 5 8 13 21)`'
- en: More interesting things could happen if the amount of fuel varied each time
    through the loop. In this case, the computation would be nondeterministic, i.e.,
    the results would vary from call to call.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: '''如果燃料的数量每次循环都不同，则可能会发生更有趣的事情。在这种情况下，计算将是非确定性的，即结果会因调用而异。'''
- en: The following syntactic form, `por` (parallel-or), returns the first of its
    expressions to complete with a true value. `por` is implemented with the procedure
    `first-true`, which is similar to `round-robin` but quits when any of the engines
    completes with a true value. If all of the engines complete, but none with a true
    value, `first-true` (and hence `por`) returns `#f`.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: '''以下语法形式 `por`（并行或）返回首个完成并具有真值的表达式。`por` 是用过程 `first-true` 实现的，它类似于 `round-robin`，但是当任何一个引擎完成并具有真值时就退出。如果所有引擎都完成，但没有一个具有真值，`first-true`（因此
    `por`）返回 `#f`。'''
- en: '`(define-syntax por'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: '''`（define-syntax por`'''
- en: (syntax-rules ()
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: '''`（syntax-rules ()）`'
- en: '[(_ x ...)'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: '`[(_ x ...)`'
- en: (first-true
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: '`(first-true`'
- en: (list (make-engine (lambda () x)) ...))]))
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: '`(list (make-engine (lambda () x)) ...))]))`'
- en: (define first-true
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define first-true`'
- en: (lambda (engs)
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (engs)`'
- en: (if (null? engs)
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '`(if (null? engs)`'
- en: '#f'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: '`#f`'
- en: ((car engs) 1
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: '`((car engs) 1`'
- en: (lambda (ticks value)
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (ticks value)`'
- en: (or value (first-true (cdr engs))))
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '`(or value (first-true (cdr engs))))`'
- en: (lambda (eng)
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (eng)`'
- en: (first-true
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '`(first-true`'
- en: (append (cdr engs) (list eng))))))))`
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: '`(append (cdr engs) (list eng))))))))`'
- en: Even if one of the expressions is an infinite loop, `por` can still finish (as
    long as one of the other expressions completes and returns a true value).
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: '''即使其中一个表达式是无限循环，`por` 仍然可以完成（只要另一个表达式完成并返回真值即可）。'''
- en: '`(por 1 2) ![<graphic>](ch2_0.gif) 1'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '''`（por 1 2）` ![<graphic>](ch2_0.gif) `1'''
- en: (por ((lambda (x) (x x)) (lambda (x) (x x)))
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '`(por ((lambda (x) (x x)) (lambda (x) (x x)))`'
- en: (fibonacci 10)) ![<graphic>](ch2_0.gif) 55`
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: '`(fibonacci 10))` ![<graphic>](ch2_0.gif) `55`'
- en: The first subexpression of the second `por` expression is nonterminating, so
    the answer is the value of the second subexpression.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '''第二个 `por` 表达式的第一个子表达式是非终止的，因此答案是第二个子表达式的值。'''
- en: Let's turn to the implementation of engines. Any preemptive multitasking primitive
    must have the ability to interrupt a running process after a given amount of computation.
    This ability is provided by a primitive timer interrupt mechanism in some Scheme
    implementations. We will construct a suitable one here.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: '''让我们转向引擎的实现。任何抢占式多任务原语都必须具有在给定计算量后中断运行的能力。某些 Scheme 实现提供了原始计时器中断机制来提供此功能。我们将在此构建一个合适的计时器中断机制。'''
- en: 'Our timer system defines three procedures: `start-timer`, `stop-timer`, and
    `decrement-timer`, which can be described operationally as follows.'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '''我们的计时器系统定义了三个过程：`start-timer`、`stop-timer` 和 `decrement-timer`，它们的操作如下所述。'''
- en: '`(start-timer *ticks* *handler*)` sets the timer to `*ticks*` and installs
    `*handler*` as the procedure to be invoked (without arguments) when the timer
    expires, i.e., reaches zero.'
  id: totrans-1178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''`（start-timer *ticks* *handler*）` 将计时器设置为 `*ticks*` 并安装 `*handler*` 作为计时器到期时调用的过程（不带参数）。'''
- en: '`(stop-timer)` resets the timer and returns the number of ticks remaining.'
  id: totrans-1179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''`（stop-timer）` 重置计时器并返回剩余的 tick 数。'''
- en: '`(decrement-timer)` decrements the timer by one tick if the timer is on, i.e.,
    if it is not zero. When the timer reaches zero, `decrement-timer` invokes the
    saved handler. If the timer has already reached zero, `decrement-timer` returns
    without changing the timer.'
  id: totrans-1180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''`(decrement-timer)` 函数将计时器减少一个 tick，如果计时器开启，即计时器不为零。当计时器达到零时，`decrement-timer`
    调用保存的处理程序。如果计时器已经达到零，则 `decrement-timer` 在不改变计时器的情况下返回。'''
- en: Code to implement these procedures is given along with the engine implementation
    below.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: '''这些过程的实现代码与下面的引擎实现一起给出。'''
- en: Using the timer system requires inserting calls to `decrement-timer` in appropriate
    places. Consuming a timer tick on entry to a procedure usually provides a sufficient
    level of granularity. This can be accomplished by using `timed-lambda` as defined
    below in place of `lambda`. `timed-lambda` simply invokes `decrement-timer` before
    executing the expressions in its body.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计时器系统需要在适当的位置插入对`decrement-timer`的调用。在进入过程时消耗一个计时器滴答通常提供了足够的粒度。这可以通过在`lambda`的位置使用下面定义的`timed-lambda`来实现。`timed-lambda`在执行其主体中的表达式之前简单地调用`decrement-timer`。
- en: '`(define-syntax timed-lambda'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-syntax timed-lambda'
- en: (syntax-rules ()
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ formals exp1 exp2 ...)'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ 形式参数 表达式1 表达式2 ...)'
- en: (lambda formals (decrement-timer) exp1 exp2 ...)]))`
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda 形式参数 (decrement-timer) 表达式1 表达式2 ...)]))`
- en: It may be useful to redefine named `let` and `do` to use `timed-lambda` as well,
    so that recursions expressed with these constructs are timed. If you use this
    mechanism, do not forget to use the timed versions of `lambda` and other forms
    in code run within an engine, or no ticks will be consumed.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 重新定义命名的`let`和`do`以使用`timed-lambda`可能很有用，以便用这些构造表达的递归被计时。如果使用此机制，请不要忘记在引擎内运行的代码中使用`lambda`和其他形式的计时版本，否则将不会消耗任何滴答。
- en: 'Now that we have a suitable timer, we can implement engines in terms of the
    timer and continuations. We use `call/cc` in two places in the engine implementation:
    (1) to obtain the continuation of the computation that invokes the engine so that
    we can return to that continuation when the engine computation completes or the
    timer expires, and (2) to obtain the continuation of the engine computation when
    the timer expires so that we can return to this computation if the newly created
    engine is subsequently run.'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个合适的计时器，我们可以根据计时器和继续实现引擎。在引擎实现中，我们在两个地方使用`call/cc`：(1)获取调用引擎的计算的继续，以便在引擎计算完成或计时器到期时返回到该继续，以及(2)获取计时器到期时引擎计算的继续，以便在随后运行新创建的引擎时返回到此计算。
- en: 'The state of the engine system is contained in two variables local to the engine
    system: `do-complete` and `do-expire`. When an engine is started, the engine assigns
    to `do-complete` and `do-expire` procedures that, when invoked, return to the
    continuation of the engine''s caller to invoke `*complete*` or `*expire*`. The
    engine starts (or restarts) the computation by invoking the procedure passed as
    an argument to `make-engine` with the specified number of ticks. The ticks and
    the local procedure `timer-handler` are then used to start the timer.'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎系统的状态包含在引擎系统内部的两个变量中：`do-complete`和`do-expire`。当启动引擎时，引擎为`do-complete`和`do-expire`分配了一些过程，当调用时，返回到引擎的调用者的继续，以调用`*complete*`或`*expire*`。引擎通过调用传递给`make-engine`的参数中的过程以指定数量的滴答来启动（或重新启动）计算。然后使用滴答和本地过程`timer-handler`来启动计时器。
- en: Suppose that the timer expires before the engine computation completes. The
    procedure `timer-handler` is then invoked. It initiates a call to `start-timer`
    but obtains the ticks by calling `call/cc` with `do-expire`. Consequently, `do-expire`
    is called with a continuation that, if invoked, will restart the timer and continue
    the interrupted computation. `do-expire` creates a new engine from this continuation
    and arranges for the engine's `*expire*` procedure to be invoked with the new
    engine in the correct continuation.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设引擎计算完成之前计时器到期。然后调用过程`timer-handler`。它通过使用`call/cc`和`do-expire`获取滴答。因此，`do-expire`被调用并传入一个继续，如果调用，将重新启动计时器并继续中断的计算。`do-expire`从这个继续创建一个新的引擎，并安排引擎的`*expire*`过程在正确的继续中被调用。
- en: If, on the other hand, the engine computation completes before the timer expires,
    the timer is stopped and the number of ticks remaining is passed along with the
    value to `do-complete`; `do-complete` arranges for the engine's `*complete*` procedure
    to be invoked with the ticks and value in the correct continuation.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果引擎计算在计时器到期之前完成，计时器将停止，并将剩余的滴答数与值一起传递给`do-complete`；`do-complete`安排引擎的`*complete*`过程在正确的继续中使用滴答和值被调用。
- en: Let's discuss a couple of subtle aspects to this code. The first concerns the
    method used to start the timer when an engine is invoked. The code would apparently
    be simplified by letting `new-engine` start the timer before it initiates or resumes
    the engine computation, instead of passing the ticks to the computation and letting
    it start the timer. Starting the timer within the computation, however, prevents
    ticks from being consumed prematurely. If the engine system itself consumes fuel,
    then an engine provided with a small amount of fuel may not progress toward completion.
    (It may, in fact, make negative progress.) If the software timer described above
    is used, this problem is actually avoided by compiling the engine-making code
    with the untimed version of `lambda`.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下这段代码的一些微妙之处。首先涉及到的是当引擎被调用时启动计时器的方法。如果让`new-engine`在启动计时器之前启动计时器，而不是将ticks传递给计算并让其启动计时器，代码似乎会更简化。然而，在计算内部启动计时器可以防止ticks被过早消耗。如果引擎系统本身消耗燃料，则提供少量燃料的引擎可能不会向完成进展（实际上可能是负进展）。如果使用上面描述的软件计时器，通过使用`lambda`的无计时版本编译引擎制造代码，实际上可以避免这个问题。
- en: The second subtlety concerns the procedures created by `do-complete` and `do-expire`
    and subsequently applied by the continuation of the `call/cc` application. It
    may appear that `do-complete` could first invoke the engine's `*complete*` procedure,
    then pass the result to the continuation (and similarly for `do-expire`) as follows.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个微妙之处涉及到由`do-complete`和`do-expire`创建并随后由`call/cc`应用的过程。看起来`do-complete`可以首先调用引擎的`*complete*`过程，然后将结果传递给延续（对于`do-expire`也是如此），如下所示。
- en: '`(escape (complete value ticks))`'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '`(escape (complete value ticks))`'
- en: This would result in improper treatment of tail recursion, however. The problem
    is that the current continuation would not be replaced with the continuation stored
    in `escape` until the call to the `complete` procedure returns. Consequently,
    both the continuation of the running engine and the continuation of the engine
    invocation could be retained for an indefinite period of time, when in fact the
    actual engine invocation may appear to be tail-recursive. This is especially inappropriate
    because the engine interface encourages use of continuation-passing style and
    hence tail recursion. The round-robin scheduler and `first-true` provide good
    examples of this, since the `*expire*` procedure in each invokes engines tail-recursively.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将导致对尾递归的不正确处理。问题在于，在调用`complete`过程返回之前，当前延续不会被替换为存储在`escape`中的延续。因此，当引擎实际调用可能看起来是尾递归时，正在运行的引擎的延续和引擎调用的延续都可能被保留很长时间。这尤其不合适，因为引擎接口鼓励使用传递风格和因此尾递归。循环调度程序和`first-true`提供了很好的例子，因为其中的每个`*expire*`过程都尾递归地调用引擎。
- en: We maintain proper treatment of tail recursion by arranging for `do-complete`
    and `do-expire` to escape from the continuation of the running engine before invoking
    the `complete` or `expire` procedures. Since the continuation of the engine invocation
    is a procedure application, passing it a procedure of no arguments results in
    application of the procedure in the continuation of the engine invocation.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过安排`do-complete`和`do-expire`在调用`complete`或`expire`过程之前从正在运行的引擎的延续中逃逸来保持对尾递归的正确处理。由于引擎调用的延续是一个过程应用，将一个没有参数的过程传递给它将导致在引擎调用的延续中应用该过程。
- en: '`(library (tspl timer)'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: '`(library (tspl timer)'
- en: (export start-timer stop-timer decrement-timer)
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: (export start-timer stop-timer decrement-timer)
- en: (import (rnrs))
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: (import (rnrs))
- en: (define clock 0)
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: (define clock 0)
- en: (define handler #f)
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: (define handler #f)
- en: (define start-timer
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: (define start-timer
- en: (lambda (ticks new-handler)
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ticks new-handler)
- en: (set! handler new-handler)
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: (set! handler new-handler)
- en: (set! clock ticks)))
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: (set! clock ticks)))
- en: (define stop-timer
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: (define stop-timer
- en: (lambda ()
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (let ([time-left clock])
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([time-left clock])
- en: (set! clock 0)
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: (set! clock 0)
- en: time-left)))
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: time-left)))
- en: (define decrement-timer
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: (define decrement-timer
- en: (lambda ()
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (when (> clock 0)
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: (when (> clock 0)
- en: (set! clock (- clock 1))
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: (set! clock (- clock 1))
- en: (when (= clock 0) (handler)))))
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: (when (= clock 0) (handler)))))
- en: (define-syntax timed-lambda
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax timed-lambda
- en: (syntax-rules ()
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ formals exp1 exp2 ...)'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ formals exp1 exp2 ...)'
- en: (lambda formals (decrement-timer) exp1 exp2 ...)])))
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda formals (decrement-timer) exp1 exp2 ...)])))
- en: (library (tspl engines)
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: (library (tspl engines)
- en: (export make-engine timed-lambda)
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: (export make-engine timed-lambda)
- en: (import (rnrs) (tspl timer))
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: (import (rnrs) (tspl timer))
- en: (define make-engine
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: (define make-engine
- en: (let ([do-complete #f] [do-expire #f])
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([do-complete #f] [do-expire #f])
- en: (define timer-handler
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: (define timer-handler
- en: (lambda ()
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: (start-timer (call/cc do-expire) timer-handler)))
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: (define new-engine
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (resume)
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ticks complete expire)
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: ((call/cc
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (escape)
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: (set! do-complete
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ticks value)
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: (escape (lambda () (complete ticks value)))))
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: (set! do-expire
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (resume)
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: (escape (lambda ()
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: (expire (new-engine resume))))))
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: (resume ticks)))))))
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (proc)
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: (new-engine
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ticks)
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: (start-timer ticks timer-handler)
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: (let ([value (proc)])
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ticks (stop-timer)])
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: (do-complete ticks value))))))))
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: (define-syntax timed-lambda
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ formals exp1 exp2 ...)'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: (lambda formals (decrement-timer) exp1 exp2 ...)])))`
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.11.1
  id: totrans-1252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If your Scheme implementation allows definition and import of libraries in the
    interactive top level, try defining the libraries above, then type
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: '`(import (rename (tspl engines) (timed-lambda lambda)))`'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: to define `make-engine` and redefine `lambda`. Then try out the examples given
    earlier in this section.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.11.2
  id: totrans-1256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It may appear that the nested `let` expressions in the body of `make-engine`:'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([value (proc)])'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ticks (stop-timer)])
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: (do-complete ticks value)))`
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: could be replaced with the following.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([value (proc)] [ticks (stop-timer)])'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: (do-complete value ticks))`
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: Why is this not correct?
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.11.3
  id: totrans-1265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It would also be incorrect to replace the nested `let` expressions discussed
    in the preceding exercise with the following.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([value (proc)])'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: (do-complete value (stop-timer)))`
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: Why?
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.11.4
  id: totrans-1270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Modify the engine implementation to provide a procedure, `engine-return`, that
    returns immediately from an engine.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.11.5
  id: totrans-1272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Implement the kernel of a small operating system using engines for processes.
    Processes should request services (such as reading input from the user) by evaluating
    an expression of the form `(trap 'request)`. Use `call/cc` and `engine-return`
    from the preceding exercise to implement `trap`.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.11.6
  id: totrans-1274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write the same operating-system kernel without using engines, building instead
    from continuations and timer interrupts.
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.11.7
  id: totrans-1276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This implementation of engines does not allow one engine to call another, i.e.,
    nested engines [[10](bibliography.html#g228)]. Modify the implementation to allow
    nested engines.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
