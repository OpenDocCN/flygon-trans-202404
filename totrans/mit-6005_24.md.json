["```\n/**\n * Find all the files in the filesystem subtree rooted at folder.\n * @param folder root of subtree, requires folder.isDirectory() == true\n * @return list of all ordinary files (not folders) that have folder as\n *         their ancestor\n */\npublic static List<File> allFilesIn(File folder) {\n    List<File> files = new ArrayList<>();\n    for (File f : folder.listFiles()) {\n        if (f.isDirectory()) {\n            files.addAll(allFilesIn(f));\n        } else if (f.isFile()) {\n            files.add(f);\n        }\n    }\n    return files;\n}\n```", "```\n/**\n * Filter a list of files to those that end with suffix.\n * @param files list of files (all non-null)\n * @param suffix string to test\n * @return a new list consisting of only those files whose names end with\n *         suffix\n */\npublic static List<File> onlyFilesWithSuffix(List<File> files, String suffix) {\n    List<File> result = new ArrayList<>();\n    for (File f : files) {\n        if (f.getName().endsWith(suffix)) {\n            result.add(f);\n        }\n    }\n    return result;\n}\n```", "```\nfor (int ii = 0; ii < files.size(); ii++) {\n    File f = files.get(ii);\n    // ...\n```", "```\nIterator<File> iter = files.iterator();\nwhile (iter.hasNext()) {\n    File f = iter.next();\n    // ...\n```", "```\n>>> from math import sqrt\n>>> map(sqrt, [1, 4, 9, 16])\n[1.0, 2.0, 3.0, 4.0]\n>>> map(str.lower, ['A', 'b', 'C'])\n['a', 'b', 'c']\n```", "```\ndef map(f, seq):\n    result = []\n    for elt in seq:\n        result.append(f(elt))\n    return result\n```", "```\nmap(sqrt, [1, 4, 9, 16])\n```", "```\n>>> mySquareRoot = sqrt\n>>> mySquareRoot(25)\n5.0\n```", "```\n>>> def powerOfTwo(k):\n...     return 2**k\n... \n>>> powerOfTwo(5)                 \n32\n>>> map(powerOfTwo, [1, 2, 3, 4])\n[2, 4, 8, 16]\n```", "```\nlambda k: 2**k\n```", "```\n>>> (lambda k: 2**k)(5)\n32\n>>> map(lambda k: 2**k, [1, 2, 3, 4])\n[2, 4, 8, 16]\n```", "```\nmap(IOBase.close, streams) # closes each stream on the list\nmap(Thread.join, threads)  # waits for each thread to finish\n```", "```\n>>> import operator\n>>> map(operator.add, [1, 2, 3], [4, 5, 6])\n[5, 7, 9]\n```", "```\n>>> filter(str.isalpha, ['x', 'y', '2', '3', 'a']) \n['x', 'y', 'a']\n```", "```\n>>> def isOdd(x): return x % 2 == 1\n... \n>>> filter(isOdd, [1, 2, 3, 4])\n[1, 3]\n```", "```\n>>> filter(lambda s: len(s)>0, ['abc', '', 'd'])\n['abc', 'd']\n```", "```\ndef filter(f, seq):\n    result = []\n    for elt in seq:\n        if f(elt):\n            result.append(elt)\n    return result\n```", "```\nx1 = {'x': 1}\ny2 = {'y': 2}\nx3_y4 = {'x': 3, 'y': 4}\n```", "```\nx1 = {'x': 1}\ny2 = {'y': 2}\nx3_y4 = {'x': 3, 'y': 4}\n```", "```\n>>> reduce(lambda x,y: x+y, [1, 2, 3], 0)\n6\n# --or--\n>>> import operator\n>>> reduce(operator.add, [1, 2, 3], 0)\n6\n```", "```\n>>> reduce(max, [5, 8, 3, 1])\n8\n```", "```\n>>> reduce(lambda s,x: s+str(x), [1, 2, 3, 4], '') \n'1234'\n```", "```\n>>> reduce(operator.concat, [[1, 2], [3, 4], [], [5]], [])\n[1, 2, 3, 4, 5]\n```", "```\ndef flatten(list):\n    return reduce(operator.concat, list, [])\n```", "```\ndef evaluate(a, x):\n    xi = map(lambda i: x**i, range(0, len(a))) # [x^0, x^1, x^2, ..., x^(n-1)]\n    axi = map(operator.mul, a, xi)             # [a[0]*x^0, a[1]*x^1, ..., a[n-1]*x^(n-1)]\n    return reduce(operator.add, axi, 0)        # sum of axi\n```", "```\n# What's the highest resolution Nikon sells? \nreduce(max, map(Camera.pixels, filter(lambda c: c.brand() == \"Nikon\", cameras)))\n```", "```\nselect max(pixels) from cameras where brand = \"Nikon\" \n```", "```\nreduce(lambda x, y: x and (y == 'True'), [ ... ], True)\n```", "```\nreduce(lambda a,b: a * b, [1, 2, 3], 0)\n```", "```\nreduce(lambda a,b: a if len(a) > len(b) else b, [\"oscar\", \"papa\", \"tango\"])\n```", "```\ndef fileEndsWith(suffix):\n    return lambda file: file.getName().endsWith(suffix)\n```", "```\nfilter(fileEndsWith(\".java\"), files)\n```", "```\ndef allFilesIn(folder):\n    children = folder.listFiles()\n    subfolders = filter(File.isDirectory, children)\n    descendants = flatten(map(allFilesIn, subfolders))\n    return descendants + filter(File.isFile, children)\n```", "```\n[\"src/client\", \"src/server\", \"src/Main.java\", ...] \n```", "```\n[[\"src/client/MyClient.java\", ...], [\"src/server/MyServer.java\", ...], ...] \n```", "```\npathnames = map(File.getPath, files)\nstreams = map(open, pathnames)\nlines = map(list, streams)\n```", "```\ndef compose(f, g):\n    \"\"\"Requires that f and g are functions, f:A->B and g:B->C.\n    Returns a function A->C by composing f with g.\"\"\" \n    return lambda x: g(f(x))\n```", "```\nlines = map(compose(compose(File.getPath, open), list), files)\n```", "```\ndef chain(funcs):\n    \"\"\"Requires funcs is a list of functions [A->B, B->C, ..., Y->Z]. \n    Returns a fn A->Z that is the left-to-right composition of funcs.\"\"\"\n    return reduce(compose, funcs)\n```", "```\nlines = map(chain([File.getPath, open, list]), files)\n```", "```\nallLines = flatten(map(chain([File.getPath, open, list]), files))\n```", "```\nwords = flatten(map(str.split, lines))\n```", "```\ndef productOfOdds(list):\n    result = 1\n    for x in list:\n        if x % 2 == 1:\n            result *= x\n    return result\n```", "```\ndef productOfOdds(list):\n    return reduce(r_func, filter(f_func, map(m_func, list)))\n```", "```\nlist\n```", "```\ndef is_odd(x):\n  return x % 2 == 1\n```", "```\nx\n```", "```\nx_is_odd = x % 2 == 1\n```", "```\ny\n```", "```\ndef odd_or_identity(x):\n  return x if is_odd(x) else 1\n```", "```\ndef identity_function(x):\n  return x\n```", "```\ndef sum(x, y):\n  return x + y\n```", "```\nidentity = lambda x: x\n```", "```\ndef product(x, y):\n  return x * y\n```", "```\ndef always_true(x):\n  return True\n```", "```\noperator.mul\n```", "```\ndef modulus_tester(i):\n  return lambda x: x % 2 == i\n```", "```\nx * y\n```", "```\ndef productOfOdds(list):\n    return reduce(r_func, filter(f_func, map(m_func, list)))\n```", "```\nnew Thread(new Runnable() {\n    public void run() {\n        System.out.println(\"Hello!\");\n    }\n}).start();\n```", "```\nnew Thread(() -> {\n    System.out.println(\"Hello\");\n}).start();\n```", "```\n/**\n * Apply a function to every element of a list.\n * @param f function to apply\n * @param list list to iterate over\n * @return [f(list[0]), f(list[1]), ..., f(list[n-1])]\n */\npublic static <T,R> List<R> map(Function<T,R> f, List<T> list) {\n    List<R> result = new ArrayList<>();\n    for (T t : list) {\n        result.add(f.apply(t));\n    }\n    return result;\n}\n```", "```\n// anonymous classes like this one are effectively lambda expressions\nFunction<String,String> toLowerCase = new Function<>() {\n    public String apply(String s) { return s.toLowerCase(); }\n};\nmap(toLowerCase, Arrays.asList(new String[] {\"A\", \"b\", \"C\"}));\n```", "```\nmap(s -> s.toLowerCase(), Arrays.asList(new String[] {\"A\", \"b\", \"C\"}));\n// --or--\nmap((s) -> s.toLowerCase(), Arrays.asList(new String[] {\"A\", \"b\", \"C\"}));\n// --or--\nmap((s) -> { return s.toLowerCase(); }, Arrays.asList(new String[] {\"A\", \"b\", \"C\"}));\n```", "```\nmap(String::toLowerCase, Arrays.asList(new String[] {\"A\", \"b\", \"C\"}));\n```", "```\npublic class Words {\n    static Stream<File> allFilesIn(File folder) {\n        File[] children = folder.listFiles();\n        Stream<File> descendants = Arrays.stream(children)\n                                         .filter(File::isDirectory)\n                                         .flatMap(Words::allFilesIn);\n        return Stream.concat(descendants,\n                             Arrays.stream(children).filter(File::isFile));\n    }\n```", "```\n static Predicate<File> endsWith(String suffix) {\n        return f -> f.getPath().endsWith(suffix);\n    }\n```", "```\n/**\n * Compose two functions.\n * @param f function A->B\n * @param g function B->C\n * @return new function A->C formed by composing f with g\n */\npublic static <A,B,C> Function<A,C> compose(Function<A,B> f,\n                                            Function<B,C> g) {\n    return t -> g.apply(f.apply(t));\n    // --or--\n    // return new Function<A,C>() {\n    //     public C apply(A t) { return g.apply(f.apply(t)); }\n    // };\n}\n```", "```\n/**\n * Compose a chain of functions.\n * @param funcs list of functions A->A to compose\n * @return function A->A made by composing list[0] ... list[n-1]\n */\npublic static <A> Function<A,A> chain(List<Function<A,A>> funcs) {\n    return funcs.stream().reduce(Function.identity(), Function::compose);\n}\n```", "```\npublic interface Dog {\n    public String name();\n    public Breed breed();\n    public int loudnessOfBark();\n}\n```", "```\nSortedSet<Dog> dogsQuietToLoud = new TreeSet<>(COMPARATOR);\ndogsQuietToLoud.add(...);\ndogsQuietToLoud.add(...);\ndogsQuietToLoud.add(...);\n// ...\n```", "```\nnew TreeSet<>(new Comparator<Dog>() {\n  public int compare(Dog dog1, Dog dog2) {\n    return dog2.loudnessOfBark() - dog1.loudnessOfBark();\n  }\n});\n```", "```\nnew TreeSet<>(new Comparator<Dog>() {\n  public Dog compare(Dog dog1, Dog dog2) {\n    return dog1.loudnessOfBark() > dog2.loudnessOfBark() ? dog1 : dog2;\n  }\n});\n```", "```\nnew TreeSet<>((dog1, dog2) -> {\n  return dog1.loudnessOfBark() - dog2.loudnessOfBark();\n});\n```", "```\npublic class DogBarkComparator implements Comparator<Dog> {\n  public int compare(Dog dog1, Dog dog2) {\n    return dog1.loudnessOfBark() - dog2.loudnessOfBark();\n  }\n}\n// ...\nnew TreeSet<>(new DogBarkComparator());\n```"]