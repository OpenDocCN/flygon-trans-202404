- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6.824 2015 Lecture 1: Introduction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Note:** These lecture notes were slightly modified from the ones posted on
    the 6.824 [course website](http://nil.csail.mit.edu/6.824/2015/schedule.html)
    from Spring 2015.'
  prefs: []
  type: TYPE_NORMAL
- en: Distributed systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is a distributed system?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: multiple networked cooperating computers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example:* Internet E-Mail, Athena file server, Google MapReduce, Dropbox,
    etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why distribute?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: to connect physically separate entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: to achieve security via physical isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: to tolerate faults via replication at separate sites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: to increase performance via parallel CPUs/mem/disk/net
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '...but:'
  prefs: []
  type: TYPE_NORMAL
- en: complex, hard to debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: new classes of problems, e.g. partial failure (did he accept my e-mail?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Leslie Lamport: *"A distributed system is one in which the failure of a computer
    you didn''t even know existed can render your own computer unusable."*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Advice:* don''t distribute if a central system will work'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why take this course?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: interesting -- hard problems, non-obvious solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: active research area -- lots of progress + big unsolved problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: used by real systems -- unlike 10 years ago -- driven by the rise of big Web
    sites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: hands-on -- you'll build a real system in the labs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Course structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the course [website](http://pdos.csail.mit.edu/6.824).
  prefs: []
  type: TYPE_NORMAL
- en: Course components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lectures about big ideas, papers, labs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Readings: research papers as case studies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: please read papers before class
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'paper for today: [MapReduce paper](papers/mapreduce.pdf)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: each paper has a question for you to answer and one for you to ask (see web
    site)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: submit question & answer before class, one or two paragraphs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Mid-term quiz in class, and final exam
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Labs: build increasingly sophisticated fault-tolerant services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First lab is due on Monday
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project: design and build a distributed system of your choice or the system
    we pose in the last month of the course'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: teams of two or three
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: project meetings with course staff
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: demo in last class meeting
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Main topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Example:*'
  prefs: []
  type: TYPE_NORMAL
- en: a shared file system, so users can cooperate, like Dropbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: but this lecture isn't about dropbox specifically
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: just an example goal to get feel for distributed system problems
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: lots of client computers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Choice of interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monolithic file server?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Block server(s) -> FS logic in clients?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate naming + file servers?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate FS + block servers?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Single machine room or unified wide area system?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wide-area dramatically more difficult.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Client/server or peer-to-peer?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interact w/ performance, security, fault behavior.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How do clients/servers communicate?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct network communication is pretty painful
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Want to hide network stuff from application logic
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Most systems organize distribution with some structuring framework(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RPC, RMI, DSM, MapReduce, etc.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Distribution can hurt: network b/w and latency bottlenecks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lots of tricks, e.g. caching, threaded servers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Distribution can help: parallelism, pick server near client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Idea: scalable design'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We would like performance to scale linearly with the addition of machines
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`N x` servers `-> N x` total performance'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Need a way to divide the load by N
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: divide the state by N
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: split by user
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: split by file name
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"sharding" or "partitioning"'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rarely perfect `->` only scales so far
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global operations, e.g. search
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Load imbalance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One very active user
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One very popular file
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`->` one server 100%, added servers mostly idle'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-> N x` servers `->` `1 x` performance'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fault tolerance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dropbox: ~10,000 servers; [some fail](http://www.datacenterknowledge.com/archives/2013/10/23/how-dropbox-stores-stuff-for-200-million-users/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can I use my files if there's a failure?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some part of network, some set of servers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Maybe: replicate the data on multiple servers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps client sends every operation to both
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Maybe only needs to wait for one reply
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Opportunity:* operate from two "replicas" independently if partitioned?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Opportunity:* can 2 servers yield 2x availability **AND** 2x performance?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Contract w/ apps/users about meaning of operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: e.g. "read yields most recently written value"
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: hard due to partial failure, replication/caching, concurrency
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Problem:* keep replicas identical'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If one is down, it will miss operations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Must be brought up to date after reboot
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If net is broken, *both* replicas maybe live, and see different ops
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete file, still visible via other replica
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*"split brain"* -- usually bad'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Problem:* clients may see updates in different orders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to caching or replication
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: I make `grades.txt` unreadable, then TA writes grades to it
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What if the operations run in different order on different replicas?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistency often hurts performance (communication, blocking)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many systems cut corners -- "relaxed consistency"
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Shifts burden to applications
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Labs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Focus: fault tolerance and consistency -- central to distributed systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'lab 1: MapReduce'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'labs 2/3/4: storage servers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: progressively more sophisticated (tolerate more kinds of faults)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: progressively harder too!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: patterned after real systems, e.g. MongoDB
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lab 4 has core of a real-world design for 1000s of servers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What you''ll learn from the labs:'
  prefs: []
  type: TYPE_NORMAL
- en: easy to listen to lecture / read paper and think you understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: building forces you to really understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*"I hear and I forget, I see and I remember, I do and I understand"* (Confucius?)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: you'll have to do some design yourself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: we supply skeleton, requirements, and tests
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: but we leave you substantial scope to solve problems your own way
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: you'll get experience debugging distributed systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Test cases simulate failure scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: 'distributed systems are tricky to debug: concurrency and failures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: many client and servers operating in parallel
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: test cases make servers fail at the "most" inopportune time
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*think first* before starting to code!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: otherwise your solution will be a mess
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: and/or, it will take you a lot of time
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: code review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: learn from others
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: judge other solutions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve tried to ensure that the hard problems have to do w/ distributed systems:'
  prefs: []
  type: TYPE_NORMAL
- en: not e.g. fighting against language, libraries, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: thus Go (type-safe, garbage collected, slick RPC library)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: thus fairly simple services (MapReduce, key/value store)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lab 1: MapReduce'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: help you get up to speed on Go and distributed programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: first exposure to some fault tolerance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: motivation for better fault tolerance in later labs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: motivating app for many papers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: popular distributed programming framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: many descendants frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computational model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: aimed at document processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: split doc `-> K1 k, list<V1> values`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: run `Map(K1 key, list<V1> values)` on each split `-> list<K2, V2> kvps`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: run `Reduce(K2 key, list<V2> values)` on each partition `-> list<V2>`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: merge result
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: write a map function and reduce function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: framework takes care of parallelism, distribution, and fault tolerance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'some computations are not targeted, such as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: anything that updates a document
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: `wc`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: word count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Go''s implementation, we have:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Map(value string) *list.List`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: the input is *a split* of the file `wc` is called on
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a split is just a partion of the file, as decided by MapReduce's splitter (can
    be customized, etc.)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: returns a list of *key-value pairs*
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: the key is the word (like 'pen')
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: the value is 1 (to indicate 'pen' occurred once)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note:** there will be multiple `<''pen'', 1>` entries in the list if ''pen''
    shows up more times'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func Reduce(key string, values *list.List) string`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: the input is a key and a list of (all? ) the values mapped to that key in the
    `Map()` phase
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: so here, we would expect a `Reduce('pen', [1,1,1,1])` call if pen appeared 4
    times in the input file
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TODO**: not clear if it''s also possible to get three reduce calls as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reduce(''pen'', [1,1]) -> 2` + `Reduce(''pen'', [1,1]) -> 2`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Reduce(''pen'', [2,2])`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: the paper seems to indicate `Reduce`'s return value is just a list of values
    and so it seems that the association of those values with the key 'pen' in this
    case would be lost, which would prevent the 3rd `Reduce('pen')` call
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: `grep`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: map phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: master splits input in `M` partitions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: calls Map on each partition
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map(partition) -> list(k1,v1)`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: search partition for word
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: produce a list with one item if word shows up, `nil` if not
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: partition results among `R` reducers
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: reduce phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce job collects 1/R output from each Map job
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: all map jobs have completed!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduce(k1, v1) -> v2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'identity function: `v1` in, `v1` out'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: merge phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: master merges `R` outputs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'number of jobs: `M x R` map jobs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how much speed up do we get on `N` machines?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ideally: `N`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'bottlenecks:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: stragglers
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: network calls to collect a Reduce partition
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: network calls to interact with FS
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: disk I/O calls
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fault tolerance model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: master is not fault tolerant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*assumption:* this single machine won''t fail during running a MapReduce app'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: but many workers, so have to handle their failures
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'assumption: workers are fail stop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: they fail and stop (e.g., don't send garbled weird packets after a failure)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: they may reboot
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What kinds of faults might we want to tolerate?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'network:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lost packets
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: duplicated packets
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: temporary network failure
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: server disconnected
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: network partitioned
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'server:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: server crash+restart (master versus worker?)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: server fails permanently (master versus worker?)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: all servers fail simultaneously -- power/earthquake
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'bad case: crash mid-way through complex operation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: what happens if we fail in the middle of map or reduce?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: bugs -- but not in this course
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: what happens when bug in map or reduce?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: same bug in Map over and over?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: management software kills app
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: malice -- but not in this course
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools for dealing with faults?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**retry** -- e.g. if packet is lost, or server crash+restart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: packets (TCP) and MapReduce jobs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'may execute MapReduce job twice: must account for this'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**replicate** -- e.g. if one server or part of net has failed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: next labs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**replace** -- for long-term health'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: e.g., worker
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Retry jobs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'network falure: oops execute job twice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ok for MapReduce, because `map()/reduce()` produces same output
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map()/reduce()` are "functional" or "deterministic"'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: how about intermediate files?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: atomic rename
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'worker failure: may have executed job or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: so, we may execute job more than once!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: but ok for MapReduce as long as `map()` and `reduce()` functions are deterministic
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: what would make `map() or reduce()` not deterministic?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: is executing a request twice in general ok?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: no. in fact, often not.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: unhappy customer if you execute one credit card transaction several times
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: adding servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: easy in MapReduce -- just tell master
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: hard in general
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: server may have lost state (need to get new state)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: server may have rebooted quickly
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: may need to recognize that to bring server up to date
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: server may have a new role after reboot (e.g., not the primary)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: these harder issues you would have to deal with to make the MapReduce master
    fault tolerant
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: topic of later labs
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lab 1 code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The lab 1 app (see `main/wc.go`):'
  prefs: []
  type: TYPE_NORMAL
- en: stubs for `map() and reduce()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: you fill them out to implement word count (wc)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how would you write grep?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The lab 1 sequential implementation (see `mapreduce/mapreduce.go`):'
  prefs: []
  type: TYPE_NORMAL
- en: 'demo: `run wc.go`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: code walk through start with `RunSingle()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The lab 1 worker (see `mapreduce/worker.go`):'
  prefs: []
  type: TYPE_NORMAL
- en: the remote procedure calls (RPCs) arguments and replies (see `mapreduce/common.go`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server side of RPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RPC handlers have a particular signature
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoJob`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Shutdown`'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RunWorker`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rpcs.Register`: register named handlers -- so Call() can find them'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Listen`: create socket on which to listen for RPC requests'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: for distributed implementation, replace "unix" w. "tcp"
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: replace "me" with a `<dns,port>` tuple name
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServeConn`: runs in a separate thread (why?)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: serve RPC concurrently
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a RPC may block
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Client side of RPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Register()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`call()` (see `common.go`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: make an RPC
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: lab code dials for each request
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: typical code uses a network connection for several requests
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: but, real must be prepared to redial anyway
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a network connection failure, doesn't imply a server failure!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: we also do this to introduce failure scenarios easily
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: intermittent network failures
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: just loosing the reply, but not the request
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The lab 1 master (see mapreduce/master.go)
  prefs: []
  type: TYPE_NORMAL
- en: You write it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will have to deal with distributing jobs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will have to deal with worker failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
