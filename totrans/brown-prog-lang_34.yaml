- en: 34Pyret for Racketeers and Schemers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|     [34.1 Numbers, Strings, and Booleans](#%28part._.Numbers__.Strings__and_.Booleans%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|     [34.2 Infix Expressions](#%28part._.Infix_.Expressions%29) |'
  prefs: []
  type: TYPE_TB
- en: '|     [34.3 Function Definition and Application](#%28part._.Function_.Definition_and_.Application%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|     [34.4 Variable Names](#%28part._.Variable_.Names%29) |'
  prefs: []
  type: TYPE_TB
- en: '|     [34.5 Data Definitions](#%28part._.Data_.Definitions%29) |'
  prefs: []
  type: TYPE_TB
- en: '|     [34.6 Conditionals](#%28part._.Conditionals%29) |'
  prefs: []
  type: TYPE_TB
- en: '|     [34.7 Annotations](#%28part._.Annotations%29) |'
  prefs: []
  type: TYPE_TB
- en: '|     [34.8 What Else?](#%28part._.What_.Else_%29) |'
  prefs: []
  type: TYPE_TB
- en: If you’ve programmed before in a language like Scheme or the student levels
    of Racket (or the WeScheme programming environment), or for that matter even in
    certain parts of OCaml, Haskell, Scala, Erlang, Clojure, or other languages, you
    will find many parts of Pyret very familiar. This chapter is specifically written
    to help you make the transition from (student) Racket/Scheme/WeScheme (abbreviated
    “RSW”) to Pyret by showing you how to convert the syntax. Most of what we say
    applies to all these languages, though in some cases we will refer specifically
    to Racket (and WeScheme) features not found in Scheme.
  prefs: []
  type: TYPE_NORMAL
- en: In every example below, the two programs will produce the same results.
  prefs: []
  type: TYPE_NORMAL
- en: 34.1Numbers, Strings, and Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numbers are very similar between the two. Like Scheme, Pyret implements arbitrary-precision
    numbers and rationals. Some of the more exotic numeric systems of Scheme (such
    as complex numbers) aren’t in Pyret; Pyret also treats imprecise numbers slightly
    differently.
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| 1/2 | 1/2 |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| #i3.14 | ~3.14 |'
  prefs: []
  type: TYPE_TB
- en: Strings are also very similar, though Pyret allows you to use single-quotes
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| "Hello, world!" | "Hello, world!" |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| "\"Hello\", he said" | "\"Hello\", he said" |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| "\"Hello\", he said" | ''"Hello", he said'' |'
  prefs: []
  type: TYPE_TB
- en: 'Booleans have the same names:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| true | true |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| false | false |'
  prefs: []
  type: TYPE_TB
- en: 34.2Infix Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pyret uses an infix syntax, reminiscent of many other textual programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (+ 1 2) | 1 + 2 |'
  prefs: []
  type: TYPE_TB
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (* (- 4 2) 5) | (4 - 2) * 5 |'
  prefs: []
  type: TYPE_TB
- en: 'Note that Pyret does not have rules about orders of precedence between operators,
    so when you mix operators, you have to parenthesize the expression to make your
    intent clear. When you chain the same operator you don’t need to parenthesize;
    chaining associates to the left in both languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (/ 1 2 3 4) | 1 / 2 / 3 / 4 |'
  prefs: []
  type: TYPE_TB
- en: These both evaluate to 1/24.
  prefs: []
  type: TYPE_NORMAL
- en: 34.3Function Definition and Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Function definition and application in Pyret have an infix syntax, more reminiscent
    of many other textual programming languages. Application uses a syntax familiar
    from conventional algebra books:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (dist 3 4) | dist(3, 4) |'
  prefs: []
  type: TYPE_TB
- en: 'Application correspondingly uses a similar syntax in function headers, and
    infix in the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (define (dist x y) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124;   (sqrt (+ (* x x) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124;            (* y y)))) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 34.4Variable Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both languages have a fairly permissive system for naming variables. While
    you can use CamelCase and under_scores in both, it is conventional to instead
    use what is known as [kebab-case](http://c2.com/cgi/wiki?KebabCase).This name
    is inaccurate. The word “kebab” just means “meat”. The skewer is the “shish”.
    Therefore, it ought to at least be called “shish kebab case”. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| this-is-a-name | this-is-a-name |'
  prefs: []
  type: TYPE_TB
- en: Even though Pyret has infix subtraction, the language can unambiguously tell
    apart this-name (a variable) from this - name (a subtraction expression) because
    the - in the latter must be surrounded by spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Despite this spacing convention, Pyret does not permit some of the more exotic
    names permitted by Scheme. For instance, one can write
  prefs: []
  type: TYPE_NORMAL
- en: '| (define e^i*pi -1) |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: in Scheme but that is not a valid variable name in Pyret.
  prefs: []
  type: TYPE_NORMAL
- en: 34.5Data Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pyret diverges from Racket (and even more so from Scheme) in its handling of
    data definitions. First, we will see how to define a structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (define-struct pt (x y)) |'
  prefs: []
  type: TYPE_TB
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'This might seem like a fair bit of overkill, but we’ll see in a moment why
    it’s useful. Meanwhile, it’s worth observing that when you have only a single
    kind of datum in a data definition, it feels unwieldy to take up so many lines.
    Writing it on one line is valid, but now it feels ugly to have the | in the middle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, Pyret permits you to drop the initial |, resulting in the more readable
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now suppose we have two kinds of points. In the student languages of Racket,
    we would describe this with a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ;; A Point is either |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ;; - (pt number number), or |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ;; - (pt3d number number number) |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'In Pyret, we can express this directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In short, Racket optimizes for the single-variant case, whereas Pyret optimizes
    for the multi-variant case. As a result, it is difficult to clearly express the
    multi-variant case in Racket, while it is unwieldy to express the single-variant
    case in Pyret.For structures, both Racket and Pyret expose constructors, selectors,
    and predicates. Constructors are just functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (pt 1 2) | pt(1, 2) |'
  prefs: []
  type: TYPE_TB
- en: 'Predicates are also functions with a particular naming scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (pt? x) | is-pt(x) |'
  prefs: []
  type: TYPE_TB
- en: 'and they behave the same way (returning true if the argument was constructed
    by that constructor, and false otherwise). In contrast, selection is different
    in the two languages (and we will see more about selection below, with cases):'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '| (pt-x v) | v.x |'
  prefs: []
  type: TYPE_TB
- en: Note that in the Racket case, pt-x checks that the parameter was constructed
    by pt before extracting the value of the x field. Thus, pt-x and pt3d-x are two
    different functions and neither one can be used in place of the other. In contast,
    in Pyret, .x extracts an x field of any value that has such a field, without attention
    to how it was constructed. Thus, we can use .x on a value whether it was constructed
    by pt or pt3d (or indeed anything else with that field). In contrast, cases does
    pay attention to this distinction.
  prefs: []
  type: TYPE_NORMAL
- en: 34.6Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several kinds of conditionals in Pyret, one more than in the Racket
    student languages.
  prefs: []
  type: TYPE_NORMAL
- en: General conditionals can be written using if, corresponding to Racket’s if but
    with more syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (if full-moon &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124;     "howl" &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124;     "meow") &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| RSW | Pyret |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; (if full-moon &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124;     "howl" &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124;     (if new-moon &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124;         "bark" &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '&#124;         "meow")) &#124;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Note that if includes else if, which makes it possible to list a collection
    of questions at the same level of indentation, which if in Racket does not have.
    The corresponding code in Racket would be written
  prefs: []
  type: TYPE_NORMAL
- en: '| (cond |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [full-moon "howl"] |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [new-moon "bark"] |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [else "meow"]) |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'to restore the indentation. There is a similar construct in Pyret called ask,
    designed to parallel cond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In Racket, we also use cond to dispatch on a datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '| (cond |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [(pt? v)   (+ (pt-x v) (pt-y v))] |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [(pt3d? v) (+ (pt-x v) (pt-z v))]) |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'We could write this in close parallel in Pyret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'or even as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '(As in Racket student languages, the Pyret versions will signal an error if
    no branch of the conditional matched.)However, Pyret provides a special syntax
    just for data definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This checks that v is a Point, provides a clean syntactic way of identifying
    the different branches, and makes it possible to give a concise local name to
    each field position instead of having to use selectors like .x. In general, in
    Pyret we prefer to use cases to process data definitions. However, there are times
    when, for instance, there many variants of data but a function processes only
    very few of them. In such cases, it makes more sense to explicitly use predicates
    and selectors.
  prefs: []
  type: TYPE_NORMAL
- en: 34.7Annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In student Racket languages, annotations are usually written as comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ; square: Number -> Number |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ; sort-nums: List<Number> -> List<Number> |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ; sort: List<T> * (T * T -> Boolean) -> List<T> |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: In Pyret, we can write the annotations directly on the parameters and return
    values. Pyret will check them to a limited extent dynamically, and can check them
    statically with its type checker. The corresponding annotations to those above
    would be written as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Though Pyret does have a notation for writing annotations by themselves (analogous
    to the commented syntax in Racket), they aren’t currently enforced by the language,
    so we don’t include it here.
  prefs: []
  type: TYPE_NORMAL
- en: 34.8What Else?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there are other parts of Scheme or Racket syntax that you would like to see
    translated, please [let us know](http://cs.brown.edu/~sk/Contact/).
  prefs: []
  type: TYPE_NORMAL
