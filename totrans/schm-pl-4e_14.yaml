- en: Answers to Selected Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Exercise [2.2.1](start.html#g7). **(page [20](start.html#./start:s34))'
  prefs: []
  type: TYPE_NORMAL
- en: '| *  a*. | `(+ (* 1.2 (- 2 1/3)) -8.7)` |'
  prefs: []
  type: TYPE_TB
- en: '| *  b*. | `(/ (+ 2/3 4/9) (- 5/11 4/3))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  c*. | `(+ 1 (/ 1 (+ 2 (/ 1 (+ 1 1/2)))))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  d*. | `(* (* (* (* (* (* 1 -2) 3) -4) 5) -6) 7)` or `(* 1 -2 3 -4 5 -6 7)`
    |'
  prefs: []
  type: TYPE_TB
- en: '**Exercise [2.2.2](start.html#g8). **(page [20](start.html#./start:s35))'
  prefs: []
  type: TYPE_NORMAL
- en: See Section [6.4](objects.html#g110).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.2.3](start.html#g9). **(page [20](start.html#./start:s36))'
  prefs: []
  type: TYPE_NORMAL
- en: '| *  a*. | `(car . cdr)` |'
  prefs: []
  type: TYPE_TB
- en: '| *  b*. | `(this (is silly))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  c*. | `(is this silly?)` |'
  prefs: []
  type: TYPE_TB
- en: '| *  d*. | `(+ 2 3)` |'
  prefs: []
  type: TYPE_TB
- en: '| *  e*. | `(+ 2 3)` |'
  prefs: []
  type: TYPE_TB
- en: '| *  f*. | `+` |'
  prefs: []
  type: TYPE_TB
- en: '| *  g*. | `(2 3)` |'
  prefs: []
  type: TYPE_TB
- en: '| *  h*. | `#<procedure>` |'
  prefs: []
  type: TYPE_TB
- en: '| *  i*. | `cons` |'
  prefs: []
  type: TYPE_TB
- en: '| *  j*. | `''cons` |'
  prefs: []
  type: TYPE_TB
- en: '| *  k*. | `quote` |'
  prefs: []
  type: TYPE_TB
- en: '| *  l*. | `5` |'
  prefs: []
  type: TYPE_TB
- en: '| *  m*. | `5` |'
  prefs: []
  type: TYPE_TB
- en: '| *  n*. | `5` |'
  prefs: []
  type: TYPE_TB
- en: '| *  o*. | `5` |'
  prefs: []
  type: TYPE_TB
- en: '**Exercise [2.2.4](start.html#g10). **(page [21](start.html#./start:s37))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(car (cdr (car ''((a b) (c d))))) ![<graphic>](ch2_0.gif) b'
  prefs: []
  type: TYPE_NORMAL
- en: (car (car (cdr '((a b) (c d))))) ![<graphic>](ch2_0.gif) c
  prefs: []
  type: TYPE_NORMAL
- en: (car (cdr (car (cdr '((a b) (c d)))))) ![<graphic>](ch2_0.gif) d`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.2.5](start.html#g11). **(page [21](start.html#./start:s38))'
  prefs: []
  type: TYPE_NORMAL
- en: '`''((a . b) ((c) d) ())`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.2.6](start.html#g12). **(page [21](start.html#./start:s39))'
  prefs: []
  type: TYPE_NORMAL
- en: '![<graphic>](ans_50.gif)'
  prefs: []
  type: TYPE_IMG
- en: '**Exercise [2.2.7](start.html#g13). **(page [21](start.html#./start:s40))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(car ''((a b) (c d))) ![<graphic>](ch2_0.gif) (a b)'
  prefs: []
  type: TYPE_NORMAL
- en: (car (car '((a b) (c d)))) ![<graphic>](ch2_0.gif) a
  prefs: []
  type: TYPE_NORMAL
- en: (cdr (car '((a b) (c d)))) ![<graphic>](ch2_0.gif) (b)
  prefs: []
  type: TYPE_NORMAL
- en: (car (cdr (car '((a b) (c d))))) ![<graphic>](ch2_0.gif) b
  prefs: []
  type: TYPE_NORMAL
- en: (cdr (cdr (car '((a b) (c d))))) ![<graphic>](ch2_0.gif) ()
  prefs: []
  type: TYPE_NORMAL
- en: (cdr '((a b) (c d))) ![<graphic>](ch2_0.gif) ((c d))
  prefs: []
  type: TYPE_NORMAL
- en: (car (cdr '((a b) (c d)))) ![<graphic>](ch2_0.gif) (c d)
  prefs: []
  type: TYPE_NORMAL
- en: (car (car (cdr '((a b) (c d))))) ![<graphic>](ch2_0.gif) c
  prefs: []
  type: TYPE_NORMAL
- en: (cdr (car (cdr '((a b) (c d))))) ![<graphic>](ch2_0.gif) (d)
  prefs: []
  type: TYPE_NORMAL
- en: (car (cdr (car (cdr '((a b) (c d)))))) ![<graphic>](ch2_0.gif) d
  prefs: []
  type: TYPE_NORMAL
- en: (cdr (cdr (car (cdr '((a b) (c d)))))) ![<graphic>](ch2_0.gif) ()
  prefs: []
  type: TYPE_NORMAL
- en: (cdr (cdr '((a b) (c d)))) ![<graphic>](ch2_0.gif) ()`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.2.8](start.html#g14). **(page [21](start.html#./start:s41))'
  prefs: []
  type: TYPE_NORMAL
- en: See Section [2.3](start.html#g15).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.3.1](start.html#g16). **(page [23](start.html#./start:s49))'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the variables `list`, `+`, `-`, `*`, and `/`, yielding the list, addition,
    subtraction, multiplication, and division procedures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the list procedure to the addition, subtraction, multiplication, and division
    procedures, yielding a list containing these procedures in order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Evaluate the variable `cdr`, yielding the cdr procedure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the cdr procedure to the list produced in step [2](answers.html#g252),
    yielding a list containing the subtraction, multiplication, and division procedures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Evaluate the variable `car`, yielding the car procedure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the car procedure to the list produced in step [4](answers.html#g254),
    yielding the subtraction procedure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Evaluate the constants `17` and `5`, yielding `17` and `5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the subtraction procedure to `17` and `5`, yielding `12`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other orders are possible. For example, the variable `car` could have been evaluated
    before its argument.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.4.1](start.html#g18). **(page [25](start.html#./start:s57))'
  prefs: []
  type: TYPE_NORMAL
- en: '| *  a*. | `(let ([x (* 3 a)]) (+ (- x b) (+ x b)))` |'
  prefs: []
  type: TYPE_TB
- en: '| *  b*. | `(let ([x (list a b c)]) (cons (car x) (cdr x)))` |'
  prefs: []
  type: TYPE_TB
- en: '**Exercise [2.4.2](start.html#g19). **(page [25](start.html#./start:s58))'
  prefs: []
  type: TYPE_NORMAL
- en: The value is 54\. The outer `let` binds `x` to 9, while the inner `let` binds
    `x` to 3 (9/3). The inner `let` evaluates to 6 (3 + 3), and the outer `let` evaluates
    to 54 (9 × 6).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.4.3](start.html#g20). **(page [26](start.html#./start:s59))'
  prefs: []
  type: TYPE_NORMAL
- en: '| *  a*. | `(let ([x0 ''a] [y0 ''b])   (list (let ([x1 ''c]) (cons x1 y0))'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([y1 'd]) (cons x0 y1))))` |
  prefs: []
  type: TYPE_NORMAL
- en: '| *  b*. | `(let ([x0 ''((a b) c)])   (cons (let ([x1 (cdr x0)])'
  prefs: []
  type: TYPE_NORMAL
- en: (car x1))
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x2 (car x0)])
  prefs: []
  type: TYPE_NORMAL
- en: (cons (let ([x3 (cdr x2)])
  prefs: []
  type: TYPE_NORMAL
- en: (car x3))
  prefs: []
  type: TYPE_NORMAL
- en: (cons (let ([x4 (car x2)])
  prefs: []
  type: TYPE_NORMAL
- en: x4)
  prefs: []
  type: TYPE_NORMAL
- en: (cdr x2))))))` |
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.5.1](start.html#g22). **(page [30](start.html#./start:s72))'
  prefs: []
  type: TYPE_NORMAL
- en: '| *  a*. | `a` |'
  prefs: []
  type: TYPE_TB
- en: '| *  b*. | `(a)` |'
  prefs: []
  type: TYPE_TB
- en: '| *  c*. | `a` |'
  prefs: []
  type: TYPE_TB
- en: '| *  d*. | `()` |'
  prefs: []
  type: TYPE_TB
- en: '**Exercise [2.5.2](start.html#g23). **(page [30](start.html#./start:s73))'
  prefs: []
  type: TYPE_NORMAL
- en: See page [31](start.html#defn:list).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.5.3](start.html#g24). **(page [30](start.html#./start:s74))'
  prefs: []
  type: TYPE_NORMAL
- en: '| *  a*. | no free variables |'
  prefs: []
  type: TYPE_TB
- en: '| *  b*. | `+` |'
  prefs: []
  type: TYPE_TB
- en: '| *  c*. | `f` |'
  prefs: []
  type: TYPE_TB
- en: '| *  d*. | `cons`, `f`, and `y` |'
  prefs: []
  type: TYPE_TB
- en: '| *  e*. | `cons` and `y` |'
  prefs: []
  type: TYPE_TB
- en: '| *  f*. | `cons`, `y`, and `z` (`y` also appears as a bound variable) |'
  prefs: []
  type: TYPE_TB
- en: '**Exercise [2.6.1](start.html#g26). **(page [34](start.html#./start:s91))'
  prefs: []
  type: TYPE_NORMAL
- en: The program would loop indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.6.2](start.html#g27). **(page [34](start.html#./start:s92))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define compose'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p1 p2)
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (p1 (p2 x)))))
  prefs: []
  type: TYPE_NORMAL
- en: (define cadr (compose car cdr))
  prefs: []
  type: TYPE_NORMAL
- en: (define cddr (compose cdr cdr))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.6.3](start.html#g28). **(page [34](start.html#./start:s96))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define caar (compose car car))'
  prefs: []
  type: TYPE_NORMAL
- en: (define cadr (compose car cdr))
  prefs: []
  type: TYPE_NORMAL
- en: (define cdar (compose cdr car))
  prefs: []
  type: TYPE_NORMAL
- en: (define cddr (compose cdr cdr))
  prefs: []
  type: TYPE_NORMAL
- en: (define caaar (compose car caar))
  prefs: []
  type: TYPE_NORMAL
- en: (define caadr (compose car cadr))
  prefs: []
  type: TYPE_NORMAL
- en: (define cadar (compose car cdar))
  prefs: []
  type: TYPE_NORMAL
- en: (define caddr (compose car cddr))
  prefs: []
  type: TYPE_NORMAL
- en: (define cdaar (compose cdr caar))
  prefs: []
  type: TYPE_NORMAL
- en: (define cdadr (compose cdr cadr))
  prefs: []
  type: TYPE_NORMAL
- en: (define cddar (compose cdr cdar))
  prefs: []
  type: TYPE_NORMAL
- en: (define cdddr (compose cdr cddr))
  prefs: []
  type: TYPE_NORMAL
- en: (define caaaar (compose caar caar))
  prefs: []
  type: TYPE_NORMAL
- en: (define caaadr (compose caar cadr))
  prefs: []
  type: TYPE_NORMAL
- en: (define caadar (compose caar cdar))
  prefs: []
  type: TYPE_NORMAL
- en: (define caaddr (compose caar cddr))
  prefs: []
  type: TYPE_NORMAL
- en: (define cadaar (compose cadr caar))
  prefs: []
  type: TYPE_NORMAL
- en: (define cadadr (compose cadr cadr))
  prefs: []
  type: TYPE_NORMAL
- en: (define caddar (compose cadr cdar))
  prefs: []
  type: TYPE_NORMAL
- en: (define cadddr (compose cadr cddr))
  prefs: []
  type: TYPE_NORMAL
- en: (define cdaaar (compose cdar caar))
  prefs: []
  type: TYPE_NORMAL
- en: (define cdaadr (compose cdar cadr))
  prefs: []
  type: TYPE_NORMAL
- en: (define cdadar (compose cdar cdar))
  prefs: []
  type: TYPE_NORMAL
- en: (define cdaddr (compose cdar cddr))
  prefs: []
  type: TYPE_NORMAL
- en: (define cddaar (compose cddr caar))
  prefs: []
  type: TYPE_NORMAL
- en: (define cddadr (compose cddr cadr))
  prefs: []
  type: TYPE_NORMAL
- en: (define cdddar (compose cddr cdar))
  prefs: []
  type: TYPE_NORMAL
- en: (define cddddr (compose cddr cddr))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.7.1](start.html#g30). **(page [41](start.html#./start:s126))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define atom?'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (not (pair? x))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.7.2](start.html#g31). **(page [41](start.html#./start:s128))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define shorter'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls1 ls2)
  prefs: []
  type: TYPE_NORMAL
- en: (if (< (length ls2) (length ls1))
  prefs: []
  type: TYPE_NORMAL
- en: ls2
  prefs: []
  type: TYPE_NORMAL
- en: ls1)))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.8.1](start.html#g33). **(page [46](start.html#./start:s149))'
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the output would be the mirror image of the structure of the
    input. For example, `(a . b)` would become `(b . a)` and `((a . b) . (c . d))`
    would become `((d . c) . (b . a))`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.8.2](start.html#g34). **(page [46](start.html#./start:s150))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define append'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls1 ls2)
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls1)
  prefs: []
  type: TYPE_NORMAL
- en: ls2
  prefs: []
  type: TYPE_NORMAL
- en: (cons (car ls1) (append (cdr ls1) ls2)))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.8.3](start.html#g35). **(page [46](start.html#./start:s152))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define make-list'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n x)
  prefs: []
  type: TYPE_NORMAL
- en: (if (= n 0)
  prefs: []
  type: TYPE_NORMAL
- en: '''()'
  prefs: []
  type: TYPE_NORMAL
- en: (cons x (make-list (- n 1) x)))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.8.4](start.html#g36). **(page [47](start.html#./start:s154))'
  prefs: []
  type: TYPE_NORMAL
- en: See the description of `list-ref` on page [160](objects.html#defn:list-ref)
    and the description of `list-tail` on page [160](objects.html#defn:list-tail).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.8.5](start.html#g37). **(page [47](start.html#./start:s155))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define shorter?'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls1 ls2)
  prefs: []
  type: TYPE_NORMAL
- en: (and (not (null? ls2))
  prefs: []
  type: TYPE_NORMAL
- en: (or (null? ls1)
  prefs: []
  type: TYPE_NORMAL
- en: (shorter? (cdr ls1) (cdr ls2))))))
  prefs: []
  type: TYPE_NORMAL
- en: (define shorter
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls1 ls2)
  prefs: []
  type: TYPE_NORMAL
- en: (if (shorter? ls2 ls1)
  prefs: []
  type: TYPE_NORMAL
- en: ls2
  prefs: []
  type: TYPE_NORMAL
- en: ls1)))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.8.6](start.html#g38). **(page [47](start.html#./start:s158))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define even?'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (or (= x 0)
  prefs: []
  type: TYPE_NORMAL
- en: (odd? (- x 1)))))
  prefs: []
  type: TYPE_NORMAL
- en: (define odd?
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (and (not (= x 0))
  prefs: []
  type: TYPE_NORMAL
- en: (even? (- x 1)))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.8.7](start.html#g39). **(page [47](start.html#./start:s161))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define transpose'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (cons (map car ls) (map cdr ls))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.9.1](start.html#g41). **(page [54](start.html#./start:s186))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define make-counter'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (init incr)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([next init])
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v next])
  prefs: []
  type: TYPE_NORMAL
- en: (set! next (+ next incr))
  prefs: []
  type: TYPE_NORMAL
- en: v)))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.9.2](start.html#g42). **(page [55](start.html#./start:s188))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define make-stack'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls '()])
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (msg . args)
  prefs: []
  type: TYPE_NORMAL
- en: (case msg
  prefs: []
  type: TYPE_NORMAL
- en: '[(empty? mt?) (null? ls)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(push!) (set! ls (cons (car args) ls))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(top) (car ls)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(pop!) (set! ls (cdr ls))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else "oops"])))))`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.9.3](start.html#g43). **(page [55](start.html#./start:s191))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define make-stack'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls '()])
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (msg . args)
  prefs: []
  type: TYPE_NORMAL
- en: (case msg
  prefs: []
  type: TYPE_NORMAL
- en: '[(empty? mt?) (null? ls)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(push!) (set! ls (cons (car args) ls))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(top) (car ls)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(pop!) (set! ls (cdr ls))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(ref) (list-ref ls (car args))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(set!) (set-car! (list-tail ls (car args)) (cadr args))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else "oops"])))))`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.9.4](start.html#g44). **(page [55](start.html#./start:s192))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define make-stack'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([v (make-vector n)] [i -1])
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (msg . args)
  prefs: []
  type: TYPE_NORMAL
- en: (case msg
  prefs: []
  type: TYPE_NORMAL
- en: '[(empty? mt?) (= i -1)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(push!)'
  prefs: []
  type: TYPE_NORMAL
- en: (set! i (+ i 1))
  prefs: []
  type: TYPE_NORMAL
- en: (vector-set! v i (car args))]
  prefs: []
  type: TYPE_NORMAL
- en: '[(top) (vector-ref v i)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(pop!) (set! i (- i 1))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(ref) (vector-ref v (- i (car args)))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(set!) (vector-set! v (- i (car args)) (cadr args))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else "oops"])))))`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.9.5](start.html#g45). **(page [56](start.html#./start:s194))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define emptyq?'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (q)
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (car q) (cdr q))))
  prefs: []
  type: TYPE_NORMAL
- en: (define getq
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (q)
  prefs: []
  type: TYPE_NORMAL
- en: (if (emptyq? q)
  prefs: []
  type: TYPE_NORMAL
- en: (assertion-violation 'getq "the queue is empty")
  prefs: []
  type: TYPE_NORMAL
- en: (car (car q)))))
  prefs: []
  type: TYPE_NORMAL
- en: (define delq!
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (q)
  prefs: []
  type: TYPE_NORMAL
- en: (if (emptyq? q)
  prefs: []
  type: TYPE_NORMAL
- en: (assertion-violation 'delq! "the queue is empty")
  prefs: []
  type: TYPE_NORMAL
- en: (set-car! q (cdr (car q))))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.9.6](start.html#g46). **(page [56](start.html#./start:s195))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define make-queue'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (cons '() '())))
  prefs: []
  type: TYPE_NORMAL
- en: (define putq!
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (q v)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([p (cons v '())])
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? (car q))
  prefs: []
  type: TYPE_NORMAL
- en: (begin
  prefs: []
  type: TYPE_NORMAL
- en: (set-car! q p)
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! q p))
  prefs: []
  type: TYPE_NORMAL
- en: (begin
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! (cdr q) p)
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! q p))))))
  prefs: []
  type: TYPE_NORMAL
- en: (define getq
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (q)
  prefs: []
  type: TYPE_NORMAL
- en: (car (car q))))
  prefs: []
  type: TYPE_NORMAL
- en: (define delq!
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (q)
  prefs: []
  type: TYPE_NORMAL
- en: (if (eq? (car q) (cdr q))
  prefs: []
  type: TYPE_NORMAL
- en: (begin
  prefs: []
  type: TYPE_NORMAL
- en: (set-car! q '())
  prefs: []
  type: TYPE_NORMAL
- en: (set-cdr! q '()))
  prefs: []
  type: TYPE_NORMAL
- en: (set-car! q (cdr (car q))))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.9.7](start.html#g47). **(page [56](start.html#./start:s196))'
  prefs: []
  type: TYPE_NORMAL
- en: When asked to print a cyclic structure, some implementations print a representation
    of the output that reflects its cyclic structure. Other implementations do not
    detect the cycle and produce either no output or an infinite stream of output.
    When `length` is passed a cyclic list, an exception is raised, likely with a message
    indicating that the list is not proper. The definition of `length` on page [42](start.html#defn:simplelength)
    will, however, simply loop indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [2.9.8](start.html#g48). **(page [56](start.html#./start:s199))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define race'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (hare tortoise)
  prefs: []
  type: TYPE_NORMAL
- en: (if (pair? hare)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([hare (cdr hare)])
  prefs: []
  type: TYPE_NORMAL
- en: (if (pair? hare)
  prefs: []
  type: TYPE_NORMAL
- en: (and (not (eq? hare tortoise))
  prefs: []
  type: TYPE_NORMAL
- en: (race (cdr hare) (cdr tortoise)))
  prefs: []
  type: TYPE_NORMAL
- en: (null? hare)))
  prefs: []
  type: TYPE_NORMAL
- en: (null? hare))))
  prefs: []
  type: TYPE_NORMAL
- en: (define list?
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (race x x)))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.1.1](further.html#g51). **(page [64](further.html#./further:s25))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x (memv ''a ls)]) (and x (memv ''b x))) ![<graphic>](ans_9.gif)'
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda (x) (and x (memv 'b x))) (memv 'a ls)) ![<graphic>](ans_9.gif)
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda (x) (if x (and (memv 'b x)) #f)) (memv 'a ls)) ![<graphic>](ans_9.gif)
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda (x) (if x (memv 'b x) #f)) (memv 'a ls))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.1.2](further.html#g52). **(page [64](further.html#./further:s26))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(or (memv x ''(a b c)) (list x)) ![<graphic>](ans_9.gif)'
  prefs: []
  type: TYPE_NORMAL
- en: (let ((t (memv x '(a b c)))) (if t t (or (list x)))) ![<graphic>](ans_9.gif)
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda (t) (if t t (or (list x)))) (memv x '(a b c))) ![<graphic>](ans_9.gif)
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda (t) (if t t (list x))) (memv x '(a b c)))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.1.3](further.html#g53). **(page [64](further.html#./further:s27))'
  prefs: []
  type: TYPE_NORMAL
- en: See page [97](binding.html#defn:let*).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.1.4](further.html#g54). **(page [64](further.html#./further:s29))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax when'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e0 e1 e2 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (if e0 (begin e1 e2 ...))]))
  prefs: []
  type: TYPE_NORMAL
- en: (define-syntax unless
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ e0 e1 e2 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (when (not e0) e1 e2 ...)]))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.2.1](further.html#g56). **(page [72](further.html#./further:s52))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tail-recursive: `even?` and `odd?`, `race`, `fact` in second definition of
    `factorial`, `fib` in second version of `fibonacci`. Nontail-recursive: `sum`,
    `factorial`, `fib` in first version of `fibonacci`. Both: `factor`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.2.2](further.html#g57). **(page [72](further.html#./further:s53))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define factor'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (letrec ([f (lambda (n i)
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(>= i n) (list n)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(integer? (/ n i))'
  prefs: []
  type: TYPE_NORMAL
- en: (cons i (f (/ n i) i))]
  prefs: []
  type: TYPE_NORMAL
- en: '[else (f n (+ i 1))]))])'
  prefs: []
  type: TYPE_NORMAL
- en: (f n 2))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.2.3](further.html#g58). **(page [72](further.html#./further:s55))'
  prefs: []
  type: TYPE_NORMAL
- en: Yes, but we need two named `let` expressions, one for `even?` and one for `odd?`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let even? ([x 20])'
  prefs: []
  type: TYPE_NORMAL
- en: (or (= x 0)
  prefs: []
  type: TYPE_NORMAL
- en: (let odd? ([x (- x 1)])
  prefs: []
  type: TYPE_NORMAL
- en: (and (not (= x 0))
  prefs: []
  type: TYPE_NORMAL
- en: (even? (- x 1))))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.2.4](further.html#g59). **(page [72](further.html#./further:s56))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define fibcount1 0)'
  prefs: []
  type: TYPE_NORMAL
- en: (define fibonacci1
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (let fib ([i n])
  prefs: []
  type: TYPE_NORMAL
- en: (set! fibcount1 (+ fibcount1 1))
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(= i 0) 0]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(= i 1) 1]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (+ (fib (- i 1)) (fib (- i 2)))]))))'
  prefs: []
  type: TYPE_NORMAL
- en: (define fibcount2 0)
  prefs: []
  type: TYPE_NORMAL
- en: (define fibonacci2
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (if (= n 0)
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: (let fib ([i n] [a1 1] [a2 0])
  prefs: []
  type: TYPE_NORMAL
- en: (set! fibcount2 (+ fibcount2 1))
  prefs: []
  type: TYPE_NORMAL
- en: (if (= i 1)
  prefs: []
  type: TYPE_NORMAL
- en: a1
  prefs: []
  type: TYPE_NORMAL
- en: (fib (- i 1) (+ a1 a2) a1))))))`
  prefs: []
  type: TYPE_NORMAL
- en: The counts for `(fibonacci 10)` are 177 and 10, for `(fibonacci 20)` are 21891
    and 20, and for `(fibonacci 30)` are 2692537 and 30\. While the number of calls
    made by the second is directly proportional to the input, the number of calls
    made by the first grows rapidly (exponentially, in fact) as the input value increases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.2.5](further.html#g60). **(page [73](further.html#./further:s57))'
  prefs: []
  type: TYPE_NORMAL
- en: See page [312](syntax.html#defn:let).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.2.6](further.html#g61). **(page [73](further.html#./further:s58))'
  prefs: []
  type: TYPE_NORMAL
- en: A call in the last subexpression of an `or` expression in tail position would
    not be a tail call with the modified definition of `or`. For the `even?`/`odd?`
    example, the resulting definition of `even?` would no longer be tail-recursive
    and for very large inputs might exhaust available space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expansion performed by this definition is incorrect in another way, which
    has to do with multiple return values (Section [5.8](control.html#g104)): if the
    last subexpression returns multiple values, the `or` expression should return
    multiple values, but with the incorrect definition, each subexpression appears
    on the right-hand side of a `let`, which expects a single return value. The simpler
    and incorrect definition of `and` has the same problem.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.2.7](further.html#g62). **(page [73](further.html#./further:s59))'
  prefs: []
  type: TYPE_NORMAL
- en: The first of the three versions of `factor` below directly addresses the identified
    problems by stopping at ![<graphic>](ans_10.gif), avoiding the redundant division,
    and skipping the even factors after 2\. Stopping at ![<graphic>](ans_10.gif) probably
    yields the biggest savings, followed by skipping even factors greater than 2\.
    Avoiding the redundant division is less important, since it occurs only when a
    factor is found.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define factor'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([n n] [i 2] [step 1])
  prefs: []
  type: TYPE_NORMAL
- en: (if (> i (sqrt n))
  prefs: []
  type: TYPE_NORMAL
- en: (list n)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([n/i (/ n i)])
  prefs: []
  type: TYPE_NORMAL
- en: (if (integer? n/i)
  prefs: []
  type: TYPE_NORMAL
- en: (cons i (f n/i i step))
  prefs: []
  type: TYPE_NORMAL
- en: (f n (+ i step) 2)))))))`
  prefs: []
  type: TYPE_NORMAL
- en: The second version replaces `(> i (sqrt n))` with `(> (* i i) n)`, since `*`
    is typically much faster than `sqrt`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define factor'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([n n] [i 2] [step 1])
  prefs: []
  type: TYPE_NORMAL
- en: (if (> (* i i) n)
  prefs: []
  type: TYPE_NORMAL
- en: (list n)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([n/i (/ n i)])
  prefs: []
  type: TYPE_NORMAL
- en: (if (integer? n/i)
  prefs: []
  type: TYPE_NORMAL
- en: (cons i (f n/i i step))
  prefs: []
  type: TYPE_NORMAL
- en: (f n (+ i step) 2)))))))`
  prefs: []
  type: TYPE_NORMAL
- en: The third version uses `gcd` (see page [179](objects.html#page:gcd)) to avoid
    most of the divisions, since `gcd` should be faster than `/`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define factor'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([n n] [i 2] [step 1])
  prefs: []
  type: TYPE_NORMAL
- en: (if (> (* i i) n)
  prefs: []
  type: TYPE_NORMAL
- en: (list n)
  prefs: []
  type: TYPE_NORMAL
- en: (if (= (gcd n i) 1)
  prefs: []
  type: TYPE_NORMAL
- en: (f n (+ i step) 2)
  prefs: []
  type: TYPE_NORMAL
- en: (cons i (f (/ n i) i step)))))))`
  prefs: []
  type: TYPE_NORMAL
- en: To see the difference these changes make, time each version of `factor`, including
    the original, in your Scheme system to see which performs better. Try a variety
    of inputs, including larger ones like `(+ (expt 2 100) 1)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.3.1](further.html#g70). **(page [77](further.html#./further:s66))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([k.n (call/cc (lambda (k) (cons k 0)))])'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([k (car k.n)] [n (cdr k.n)])
  prefs: []
  type: TYPE_NORMAL
- en: (write n)
  prefs: []
  type: TYPE_NORMAL
- en: (newline)
  prefs: []
  type: TYPE_NORMAL
- en: (k (cons k (+ n 1)))))`
  prefs: []
  type: TYPE_NORMAL
- en: 'Or with multiple values (see Section [5.8](control.html#g104)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`(call-with-values'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda () (call/cc (lambda (k) (values k 0))))
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (k n)
  prefs: []
  type: TYPE_NORMAL
- en: (write n)
  prefs: []
  type: TYPE_NORMAL
- en: (newline)
  prefs: []
  type: TYPE_NORMAL
- en: (k k (+ n 1))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.3.2](further.html#g71). **(page [77](further.html#./further:s67))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define product'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: (if (= (car ls) 0)
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([n (product (cdr ls))])
  prefs: []
  type: TYPE_NORMAL
- en: (if (= n 0) 0 (* n (car ls))))))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.3.3](further.html#g72). **(page [77](further.html#./further:s68))'
  prefs: []
  type: TYPE_NORMAL
- en: If one of the processes returns without calling `pause`, it returns to the call
    to `pause` that first caused it to run, or to the original call to `start` if
    it was the first process in the list. Here is a reimplementation of the system
    that allows a process to `quit` explicitly. If other processes are active, the
    `lwp` system continues to run. Otherwise, control returns to the continuation
    of the original call to `start`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define lwp-list ''())'
  prefs: []
  type: TYPE_NORMAL
- en: (define lwp
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (thunk)
  prefs: []
  type: TYPE_NORMAL
- en: (set! lwp-list (append lwp-list (list thunk)))))
  prefs: []
  type: TYPE_NORMAL
- en: (define start
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (k)
  prefs: []
  type: TYPE_NORMAL
- en: (set! quit-k k)
  prefs: []
  type: TYPE_NORMAL
- en: (next)))))
  prefs: []
  type: TYPE_NORMAL
- en: (define next
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (let ([p (car lwp-list)])
  prefs: []
  type: TYPE_NORMAL
- en: (set! lwp-list (cdr lwp-list))
  prefs: []
  type: TYPE_NORMAL
- en: (p))))
  prefs: []
  type: TYPE_NORMAL
- en: (define pause
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (k)
  prefs: []
  type: TYPE_NORMAL
- en: (lwp (lambda () (k #f)))
  prefs: []
  type: TYPE_NORMAL
- en: (next)))))
  prefs: []
  type: TYPE_NORMAL
- en: (define quit
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (v)
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? lwp-list)
  prefs: []
  type: TYPE_NORMAL
- en: (quit-k v)
  prefs: []
  type: TYPE_NORMAL
- en: (next))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.3.4](further.html#g73). **(page [77](further.html#./further:s69))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define lwp-queue (make-queue))'
  prefs: []
  type: TYPE_NORMAL
- en: (define lwp
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (thunk)
  prefs: []
  type: TYPE_NORMAL
- en: (putq! lwp-queue thunk)))
  prefs: []
  type: TYPE_NORMAL
- en: (define start
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (let ([p (getq lwp-queue)])
  prefs: []
  type: TYPE_NORMAL
- en: (delq! lwp-queue)
  prefs: []
  type: TYPE_NORMAL
- en: (p))))
  prefs: []
  type: TYPE_NORMAL
- en: (define pause
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (k)
  prefs: []
  type: TYPE_NORMAL
- en: (lwp (lambda () (k #f)))
  prefs: []
  type: TYPE_NORMAL
- en: (start)))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.4.1](further.html#g76). **(page [80](further.html#./further:s75))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define reciprocal'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n success failure)
  prefs: []
  type: TYPE_NORMAL
- en: (if (= n 0)
  prefs: []
  type: TYPE_NORMAL
- en: (failure)
  prefs: []
  type: TYPE_NORMAL
- en: (success (/ 1 n)))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.4.2](further.html#g77). **(page [80](further.html#./further:s77))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define retry #f)'
  prefs: []
  type: TYPE_NORMAL
- en: (define factorial
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (let f ([x x] [k (lambda (x) x)])
  prefs: []
  type: TYPE_NORMAL
- en: (if (= x 0)
  prefs: []
  type: TYPE_NORMAL
- en: (begin (set! retry k) (k 1))
  prefs: []
  type: TYPE_NORMAL
- en: (f (- x 1) (lambda (y) (k (* x y))))))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.4.3](further.html#g78). **(page [80](further.html#./further:s79))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define map/k'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (p ls k)
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: (k '())
  prefs: []
  type: TYPE_NORMAL
- en: (p (car ls)
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (map/k p (cdr ls)
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (k (cons x ls)))))))))
  prefs: []
  type: TYPE_NORMAL
- en: (define reciprocals
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (map/k (lambda (x k) (if (= x 0) "zero found" (k (/ 1 x))))
  prefs: []
  type: TYPE_NORMAL
- en: ls
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x) x))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.5.1](further.html#g80). **(page [85](further.html#./further:s86))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax complain'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ ek msg expr) (ek (list msg expr))]))`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.5.2](further.html#g81). **(page [85](further.html#./further:s87))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define calc'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (expr)
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ek)
  prefs: []
  type: TYPE_NORMAL
- en: (define do-calc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (expr)
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(number? expr) expr]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(and (list? expr) (= (length expr) 3))'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([op (car expr)] [args (cdr expr)])
  prefs: []
  type: TYPE_NORMAL
- en: (case op
  prefs: []
  type: TYPE_NORMAL
- en: '[(add) (apply-op + args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(sub) (apply-op - args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(mul) (apply-op * args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(div) (apply-op / args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (complain "invalid operator" op)]))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (complain "invalid expression" expr)])))'
  prefs: []
  type: TYPE_NORMAL
- en: (define apply-op
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (op args)
  prefs: []
  type: TYPE_NORMAL
- en: (op (do-calc (car args)) (do-calc (cadr args)))))
  prefs: []
  type: TYPE_NORMAL
- en: (define complain
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (msg expr)
  prefs: []
  type: TYPE_NORMAL
- en: (ek (list msg expr))))
  prefs: []
  type: TYPE_NORMAL
- en: (do-calc expr)))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.5.3](further.html#g82). **(page [85](further.html#./further:s88))'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define calc #f)'
  prefs: []
  type: TYPE_NORMAL
- en: (let ()
  prefs: []
  type: TYPE_NORMAL
- en: (define do-calc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (expr)
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(number? expr) expr]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(and (list? expr) (= (length expr) 3))'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([op (car expr)] [args (cdr expr)])
  prefs: []
  type: TYPE_NORMAL
- en: (case op
  prefs: []
  type: TYPE_NORMAL
- en: '[(add) (apply-op + args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(sub) (apply-op - args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(mul) (apply-op * args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(div) (apply-op / args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (complain "invalid operator" op)]))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (complain "invalid expression" expr)])))'
  prefs: []
  type: TYPE_NORMAL
- en: (define apply-op
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (op args)
  prefs: []
  type: TYPE_NORMAL
- en: (op (do-calc (car args)) (do-calc (cadr args)))))
  prefs: []
  type: TYPE_NORMAL
- en: (define complain
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (msg expr)
  prefs: []
  type: TYPE_NORMAL
- en: (assertion-violation 'calc msg expr)))
  prefs: []
  type: TYPE_NORMAL
- en: (set! calc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (expr)
  prefs: []
  type: TYPE_NORMAL
- en: (do-calc expr))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.5.4](further.html#g83). **(page [85](further.html#./further:s89))'
  prefs: []
  type: TYPE_NORMAL
- en: This adds `sqrt`, `times` (an alias for `mul`), and `expt` along with `minus`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ()'
  prefs: []
  type: TYPE_NORMAL
- en: (define do-calc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ek expr)
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(number? expr) expr]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(and (list? expr) (= (length expr) 2))'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([op (car expr)] [args (cdr expr)])
  prefs: []
  type: TYPE_NORMAL
- en: (case op
  prefs: []
  type: TYPE_NORMAL
- en: '[(minus) (apply-op1 ek - args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(sqrt) (apply-op1 ek sqrt args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (complain ek "invalid unary operator" op)]))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(and (list? expr) (= (length expr) 3))'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([op (car expr)] [args (cdr expr)])
  prefs: []
  type: TYPE_NORMAL
- en: (case op
  prefs: []
  type: TYPE_NORMAL
- en: '[(add) (apply-op2 ek + args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(sub) (apply-op2 ek - args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(mul times) (apply-op2 ek * args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(div) (apply-op2 ek / args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(expt) (apply-op2 ek expt args)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (complain ek "invalid binary operator" op)]))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (complain ek "invalid expression" expr)])))'
  prefs: []
  type: TYPE_NORMAL
- en: (define apply-op1
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ek op args)
  prefs: []
  type: TYPE_NORMAL
- en: (op (do-calc ek (car args)))))
  prefs: []
  type: TYPE_NORMAL
- en: (define apply-op2
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ek op args)
  prefs: []
  type: TYPE_NORMAL
- en: (op (do-calc ek (car args)) (do-calc ek (cadr args)))))
  prefs: []
  type: TYPE_NORMAL
- en: (define complain
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ek msg expr)
  prefs: []
  type: TYPE_NORMAL
- en: (ek (list msg expr))))
  prefs: []
  type: TYPE_NORMAL
- en: (set! calc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (expr)
  prefs: []
  type: TYPE_NORMAL
- en: (call/cc
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ek)
  prefs: []
  type: TYPE_NORMAL
- en: (do-calc ek expr))))))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.6.1](further.html#g85). **(page [87](further.html#./further:s90))'
  prefs: []
  type: TYPE_NORMAL
- en: This version of `gpa` returns `x` when all of the input letter grades are `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax gpa'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ g1 g2 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ls (map letter->number (remq 'x '(g1 g2 ...)))])
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: '''x'
  prefs: []
  type: TYPE_NORMAL
- en: (/ (apply + ls) (length ls))))]))`
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.6.2](further.html#g86). **(page [87](further.html#./further:s91))'
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining `$distribution` and `distribution` within the library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define $distribution'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (ls)
  prefs: []
  type: TYPE_NORMAL
- en: (let loop ([ls ls] [a 0] [b 0] [c 0] [d 0] [f 0])
  prefs: []
  type: TYPE_NORMAL
- en: (if (null? ls)
  prefs: []
  type: TYPE_NORMAL
- en: (list (list a 'a) (list b 'b) (list c 'c)
  prefs: []
  type: TYPE_NORMAL
- en: (list d 'd) (list f 'f))
  prefs: []
  type: TYPE_NORMAL
- en: (case (car ls)
  prefs: []
  type: TYPE_NORMAL
- en: '[(a) (loop (cdr ls) (+ a 1) b c d f)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(b) (loop (cdr ls) a (+ b 1) c d f)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(c) (loop (cdr ls) a b (+ c 1) d f)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(d) (loop (cdr ls) a b c (+ d 1) f)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(f) (loop (cdr ls) a b c d (+ f 1))]'
  prefs: []
  type: TYPE_NORMAL
- en: ; ignore x grades, per preceding exercise
  prefs: []
  type: TYPE_NORMAL
- en: '[(x) (loop (cdr ls) a b c d f)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else (assertion-violation ''distribution'
  prefs: []
  type: TYPE_NORMAL
- en: '"unrecognized grade letter"'
  prefs: []
  type: TYPE_NORMAL
- en: (car ls))])))))
  prefs: []
  type: TYPE_NORMAL
- en: (define-syntax distribution
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ g1 g2 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: ($distribution '(g1 g2 ...))]))`
  prefs: []
  type: TYPE_NORMAL
- en: modify the `export` line to add `distribution` (but not `$distribution`).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise [3.6.3](further.html#g87). **(page [87](further.html#./further:s92))'
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining `histogram` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define histogram'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (port distr)
  prefs: []
  type: TYPE_NORMAL
- en: (for-each
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n g)
  prefs: []
  type: TYPE_NORMAL
- en: (put-datum port g)
  prefs: []
  type: TYPE_NORMAL
- en: (put-string port ": ")
  prefs: []
  type: TYPE_NORMAL
- en: (let loop ([n n])
  prefs: []
  type: TYPE_NORMAL
- en: (unless (= n 0)
  prefs: []
  type: TYPE_NORMAL
- en: (put-char port #\*)
  prefs: []
  type: TYPE_NORMAL
- en: (loop (- n 1))))
  prefs: []
  type: TYPE_NORMAL
- en: (put-string port "\n"))
  prefs: []
  type: TYPE_NORMAL
- en: (map car distr)
  prefs: []
  type: TYPE_NORMAL
- en: (map cadr distr))))`
  prefs: []
  type: TYPE_NORMAL
- en: modify the `export` line to add `histogram`. The solution uses `for-each`, which
    is described on page [118](control.html#desc:for-each)
  prefs: []
  type: TYPE_NORMAL
