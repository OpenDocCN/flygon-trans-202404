- en: Module 0x1 | Basic Ruby Kung Fu
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Module 0x1 | Basic Ruby Kung Fu
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ruby has awesome abilities and tricks for dealing with string and array scenarios.
    In this chapter we'll present some tricks we may need in our hacking life.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Terminal
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terminal size
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some different ways to get terminal size from ruby:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: By IO/console standard library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By readline standard library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By environment like IRB or Pry
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By tput command line
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Console with tab completion
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can''t stop being jealous of Metasploit console (msfconsole), where we take
    a rest from command line switches. Fortunately, here is the main idea of console
    tab completion in ruby:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Readline
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Readline module provides an interface for GNU Readline. This module defines
    a number of methods to facilitate completion and accesses input history from the
    Ruby interpreter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**console-basic1.rb**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now run it and try out the tab completion!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Well, the main idea for tab completion is to make things easier, not just "press
    tab". Here is a simple thought...
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '**console-basic2.rb**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Things can go much farther, like *msfconsole*, maybe?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[Ruby Readline Documentation and Tutorial](http://bogojoker.com/readline/)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Colorize your outputs
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we mostly work with the command-line, we need our output to be more elegant.
    Here are the main colors you may need to do so. You can always add to this set.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All you need is to call the color when you `puts` it
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To understand this code, let's explain it with a diagram
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Or you can use an external gem called [colorized] for fancier options
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then just require it in your script
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Overwriting Console Output
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's awesome to have more flexibility in your terminal, and sometimes we need
    to do more with our scripts.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Overwriting console output makes our applications elegant and less noisy for
    repeated outputs like counting and loading progress bars.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: I've read a how-to about [bash Prompt cursor movement](http://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/x361.html)
    and I found it is convenient to have in our scripts. Here's what I've found so
    far
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So to test these I created the following PoC
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So far so good, but why don't we make these as Ruby methods for more elegant
    usage? So I came up with the following
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Then as a PoC, I've used the same previous PoC code (after updating String class
    on-the-fly in the same script)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It's much more elegant, isn't it? Say yes plz
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Some application...
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Create Progress Percent
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Another example
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using our elegant way (after updating String class on-the-fly)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '* * *'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Conversion
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conversion
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String conversion and/or encoding is an important part of exploitation and firewall
    bypasses.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Convert String/Binary to Hex
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If no prefix is needed, you just do the following
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Otherwise, see the below ways
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: For a single character
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Note:** the symbols `*""` are equal of `.join`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: or
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: or
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: or
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: or
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: or
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: or
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: or
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: or
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Convert Hex to String/Binary
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: or
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: or for raw socket
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: in-case of binary that is out of `.chr` range. For example you may need to convert
    an IP-address to hex raw then send it through the socket. The case of just converting
    it to hex would not work for you
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于超出`.chr`范围的二进制情况。例如，你可能需要将IP地址转换为十六进制原始数据，然后通过套接字发送。仅仅将其转换为十六进制是行不通的
- en: '[PRE32]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, Ruby reads returns `"\\xc0\\xa8\\x64\\x0a"` which doesn't equal
    `"\xc0\xa8\x64\x0a"`. Try to enter this value (with double-quotes) `"\xc0\xa8\x64\x0a"`
    into your irb directly and you'll notice that the return is `"\xC0\xA8d\n"` which
    is what should be passed to the raw socket, not the `"\\xc0\\xa8\\x64\\x0a"`.
    The main cause is ruby escapes the backslash(`\`).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Ruby读取返回`"\\xc0\\xa8\\x64\\x0a"`，这与`"\xc0\xa8\x64\x0a"`不相等。尝试直接在irb中输入这个值（带双引号）`"\xc0\xa8\x64\x0a"`，你会注意到返回值是`"\xC0\xA8d\n"`，这才是应该传递给原始套接字的值，而不是`"\\xc0\\xa8\\x64\\x0a"`。主要原因是Ruby转义了反斜杠（`\`）。
- en: To solve this issue, use pack to convert integers to 8-bit unsigned (unsigned
    char)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，使用打包将整数转换为8位无符号（无符号字符）
- en: '[PRE33]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Note about hex:** Sometimes you might face non-printable characters, especially
    when dealing with binary raw. In this case, append **(**`# -*- coding: binary
    -*-`**)** at the top of your file to fix any interpretation issues.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于十六进制的注意事项：** 有时你可能会遇到非可打印字符，特别是在处理二进制原始数据时。在这种情况下，在文件顶部添加**(**`# -*- coding:
    binary -*-`**)**可以解决任何解释问题。'
- en: Convert Hex (Return address) to Little-Endian format
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将十六进制（返回地址）转换为小端格式
- en: Little-endian format is simply reversing the string such as reversing/backwarding
    "Rubyfu" to "ufybuR" which can be done by calling the `reverse` method of the
    `String` class
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 小端格式就是简单地反转字符串，比如将"Rubyfu"反转为"ufybuR"，可以通过调用`String`类的`reverse`方法来实现
- en: '[PRE34]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In exploitation, this is not as simple as that since we're dealing with hex
    values that may not represent printable characters.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在利用中，这并不像看起来那么简单，因为我们处理的是可能不代表可打印字符的十六进制值。
- en: So assume we have `0x77d6b141` as the return address which we want to convert
    to Little-Endian format to allow the CPU to read it correctly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有`0x77d6b141`作为返回地址，我们想将其转换为小端格式以使CPU正确读取它。
- en: Generally speaking, it's really a trivial task to convert `0x77d6b141` to `\x41\xb1\xd6\x77`
    since it's a one time process, but this is not the case if you have a ROP chain
    that has to be staged in your exploit. To do so simply `pack` it as an array
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，将`0x77d6b141`转换为`\x41\xb1\xd6\x77`是一个微不足道的任务，因为这是一个一次性过程，但如果你有一个需要在利用中分阶段的ROP链，情况就不同了。要做到这一点，只需将其作为数组`pack`
- en: '[PRE35]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It happens that sometimes you get an error because of a non-Unicode string issue.
    To solve this issue, just force encoding to UTF-8, but most of the time you will
    not face this issue
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会因为非Unicode字符串问题而出现错误。要解决这个问题，只需强制编码为UTF-8，但大多数情况下你不会遇到这个问题
- en: '[PRE36]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you have a ROP chain, then it''s not decent to apply this each time - so
    you can use the first way and append **(**`# -*- coding: binary -*-`**)** at top
    of your exploit file.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你有一个ROP链，那么每次应用这个方法并不合适 - 所以你可以使用第一种方法，并在你的利用文件顶部添加**(**`# -*- coding: binary
    -*-`**)**。'
- en: Convert to Unicode Escape
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换为Unicode转义
- en: '**Hexadecimal unicode escape**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**十六进制Unicode转义**'
- en: '[PRE37]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Or using unpack
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用解包
- en: '[PRE38]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A shorter way
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更短的方法
- en: '[PRE39]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Octal unicode escape**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**八进制Unicode转义**'
- en: An octal escape is exactly the same, except we convert the string to octal instead
    of hexadecimal
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 八进制转义与十六进��转义完全相同，只是我们将字符串转换为八进制而不是十六进制
- en: '[PRE40]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Escape Sequences in Double-Quoted Strings**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**双引号字符串中的转义序列**'
- en: '[PRE41]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: En/Decode base-64 String
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码/解码base-64字符串
- en: We'll present this in a few ways.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以几种方式呈现这个问题。
- en: '**Encode string**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码字符串**'
- en: '[PRE42]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: or
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE43]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Decode**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**解码**'
- en: '[PRE44]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: or
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE45]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**TIP:**'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示：**'
- en: The string unpack method is incredibly useful for converting data we read as
    strings back to their original form. To read more, visit the String class reference
    at www.ruby-doc.org/core/classes/String.html.
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 字符串解包方法对于将我们读取的数据作为字符串转换回其原始形式非常有用。要了解更多，请访问www.ruby-doc.org/core/classes/String.html上的String类参考。
- en: En/Decode URL String
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码/解码URL字符串
- en: URL encoding/decoding is well known. From a hacker's point of view, we need
    it often for client-side vulnerabilities.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: URL编码/解码是众所周知的。从黑客的角度来看，我们经常需要它来处理客户端漏洞。
- en: '**Encoding string**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码字符串**'
- en: '[PRE46]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Decoding string**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**解码字符串**'
- en: '[PRE47]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You can encode/decode any non-URL string, of-course.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编码/解码任何非URL字符串，当然。
- en: The above way will encode any non-URL standard strings only (ex. `<>"{}`) however
    if you want to encode the full string use `URI.encode_www_form_component`
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法仅对任何非URL标准字符串进行编码（例如`<>"{}`），但如果要对整个字符串进行编码，请使用`URI.encode_www_form_component`
- en: '[PRE48]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: HTML En/Decode
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML编码/解码
- en: '**Encoding HTML**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码HTML**'
- en: '[PRE49]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Returns
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: '[PRE50]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Decoding HTML**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Returns
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: En/Decode SAML String
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Decoding SAML**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Returns
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[Source](http://stackoverflow.com/questions/3253298/base64-decode64-in-ruby-returning-strange-results)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[More about SAML][3]'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[3]: [http://dev.gettinderbox.com/2013/12/16/introduction-to-saml/](http://dev.gettinderbox.com/2013/12/16/introduction-to-saml/)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Extraction
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extraction
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String extraction is one of the main tasks that all programmers need. It's often
    difficult because we don't get an easy string presentation from which to extract
    useful data/information. Here are some helpful Ruby string-extraction cases.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Extracting Network Strings
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extracting MAC address from string
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to extract all MAC addresses from an arbitrary string
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**Using Regular Expressions**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: This regular expression should support Windows and Linux MAC address formats.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Lets to find our mac
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Returns
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Extracting IPv4 address from string
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to extract all IPv4 addresses from an arbitrary string
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Let's find our IPs
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Returns
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Extracting IPv6 address from string
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[Source](https://github.com/rapid7/rex-socket/blob/master/lib/rex/socket.rb)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://gist.github.com/cpetschnig/294476](https://gist.github.com/cpetschnig/294476)'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://snipplr.com/view/43003/regex--match-ipv6-address/](http://snipplr.com/view/43003/regex--match-ipv6-address/)'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting Web Strings
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extracting URLs from a file
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assume we have the following string
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**Using Regular Expressions**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**Using standard URI module**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: This returns an array of URLs
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Extracting URLs from web page
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using above tricks
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: or using a regular expression
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Extracting email addresses from web page
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Extracting strings from HTML tags
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assume we have the following HTML contents and we need to get strings only and
    eliminate all HTML tags
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Returns
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Parsing colon separated data from a file
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During a pentest, you may need to parse text that has a very common format as
    follows
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The main idea is to remove *repeated* keys and pass to one key with an array
    of values.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: For one-liner lovers
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Array
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Array
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pattern create
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Assume the pattern length = 500 (you can change it to any value). By default
    this will create 20280 probabilities max.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In case you need longer a pattern (ex. 30000) you can do the following
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Pattern offset
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I'll assume the pattern was equal or less than “20280” and we are looking for
    “9Ak0” pattern characters. The pattern_create should be initialized from above
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Note: This does not consider the Little-endian format, for that there is extra
    code that should be written. For more info, please take a look at the following
    [code][1].'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Generate all hexadecimal values from `\x00` to `\xff`
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '**Notes:**'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To change value presentation from `\xea` to `0xea`, change `\x%x` to `0x%x`
  id: totrans-232
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: To make all letters capital (`\xea` to `\xEA`) , change `\x%x` to `\x%X`
  id: totrans-233
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate all printable characters
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: short and unclean
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '* * *'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[1]: [https://github.com/KINGSABRI/BufferOverflow-Kit/blob/master/lib/pattern.rb](https://github.com/KINGSABRI/BufferOverflow-Kit/blob/master/lib/pattern.rb)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
