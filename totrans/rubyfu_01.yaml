- en: Module 0x1 | Basic Ruby Kung Fu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Module 0x1 | Basic Ruby Kung Fu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ruby has awesome abilities and tricks for dealing with string and array scenarios.
    In this chapter we'll present some tricks we may need in our hacking life.
  prefs: []
  type: TYPE_NORMAL
- en: Terminal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terminal size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are some different ways to get terminal size from ruby:'
  prefs: []
  type: TYPE_NORMAL
- en: By IO/console standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By readline standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By environment like IRB or Pry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By tput command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Console with tab completion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can''t stop being jealous of Metasploit console (msfconsole), where we take
    a rest from command line switches. Fortunately, here is the main idea of console
    tab completion in ruby:'
  prefs: []
  type: TYPE_NORMAL
- en: Readline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Readline module provides an interface for GNU Readline. This module defines
    a number of methods to facilitate completion and accesses input history from the
    Ruby interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: '**console-basic1.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now run it and try out the tab completion!
  prefs: []
  type: TYPE_NORMAL
- en: Well, the main idea for tab completion is to make things easier, not just "press
    tab". Here is a simple thought...
  prefs: []
  type: TYPE_NORMAL
- en: '**console-basic2.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Things can go much farther, like *msfconsole*, maybe?
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[Ruby Readline Documentation and Tutorial](http://bogojoker.com/readline/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Colorize your outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we mostly work with the command-line, we need our output to be more elegant.
    Here are the main colors you may need to do so. You can always add to this set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: All you need is to call the color when you `puts` it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To understand this code, let's explain it with a diagram
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Or you can use an external gem called [colorized] for fancier options
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Then just require it in your script
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Overwriting Console Output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's awesome to have more flexibility in your terminal, and sometimes we need
    to do more with our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Overwriting console output makes our applications elegant and less noisy for
    repeated outputs like counting and loading progress bars.
  prefs: []
  type: TYPE_NORMAL
- en: I've read a how-to about [bash Prompt cursor movement](http://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/x361.html)
    and I found it is convenient to have in our scripts. Here's what I've found so
    far
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So to test these I created the following PoC
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So far so good, but why don't we make these as Ruby methods for more elegant
    usage? So I came up with the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Then as a PoC, I've used the same previous PoC code (after updating String class
    on-the-fly in the same script)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It's much more elegant, isn't it? Say yes plz
  prefs: []
  type: TYPE_NORMAL
- en: Some application...
  prefs: []
  type: TYPE_NORMAL
- en: Create Progress Percent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Another example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using our elegant way (after updating String class on-the-fly)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String conversion and/or encoding is an important part of exploitation and firewall
    bypasses.
  prefs: []
  type: TYPE_NORMAL
- en: Convert String/Binary to Hex
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If no prefix is needed, you just do the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, see the below ways
  prefs: []
  type: TYPE_NORMAL
- en: For a single character
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Note:** the symbols `*""` are equal of `.join`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Convert Hex to String/Binary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: or for raw socket
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: in-case of binary that is out of `.chr` range. For example you may need to convert
    an IP-address to hex raw then send it through the socket. The case of just converting
    it to hex would not work for you
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Ruby reads returns `"\\xc0\\xa8\\x64\\x0a"` which doesn't equal
    `"\xc0\xa8\x64\x0a"`. Try to enter this value (with double-quotes) `"\xc0\xa8\x64\x0a"`
    into your irb directly and you'll notice that the return is `"\xC0\xA8d\n"` which
    is what should be passed to the raw socket, not the `"\\xc0\\xa8\\x64\\x0a"`.
    The main cause is ruby escapes the backslash(`\`).
  prefs: []
  type: TYPE_NORMAL
- en: To solve this issue, use pack to convert integers to 8-bit unsigned (unsigned
    char)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Note about hex:** Sometimes you might face non-printable characters, especially
    when dealing with binary raw. In this case, append **(**`# -*- coding: binary
    -*-`**)** at the top of your file to fix any interpretation issues.'
  prefs: []
  type: TYPE_NORMAL
- en: Convert Hex (Return address) to Little-Endian format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Little-endian format is simply reversing the string such as reversing/backwarding
    "Rubyfu" to "ufybuR" which can be done by calling the `reverse` method of the
    `String` class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In exploitation, this is not as simple as that since we're dealing with hex
    values that may not represent printable characters.
  prefs: []
  type: TYPE_NORMAL
- en: So assume we have `0x77d6b141` as the return address which we want to convert
    to Little-Endian format to allow the CPU to read it correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, it's really a trivial task to convert `0x77d6b141` to `\x41\xb1\xd6\x77`
    since it's a one time process, but this is not the case if you have a ROP chain
    that has to be staged in your exploit. To do so simply `pack` it as an array
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It happens that sometimes you get an error because of a non-Unicode string issue.
    To solve this issue, just force encoding to UTF-8, but most of the time you will
    not face this issue
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a ROP chain, then it''s not decent to apply this each time - so
    you can use the first way and append **(**`# -*- coding: binary -*-`**)** at top
    of your exploit file.'
  prefs: []
  type: TYPE_NORMAL
- en: Convert to Unicode Escape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Hexadecimal unicode escape**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Or using unpack
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: A shorter way
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**Octal unicode escape**'
  prefs: []
  type: TYPE_NORMAL
- en: An octal escape is exactly the same, except we convert the string to octal instead
    of hexadecimal
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**Escape Sequences in Double-Quoted Strings**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: En/Decode base-64 String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll present this in a few ways.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encode string**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '**Decode**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '**TIP:**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The string unpack method is incredibly useful for converting data we read as
    strings back to their original form. To read more, visit the String class reference
    at www.ruby-doc.org/core/classes/String.html.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: En/Decode URL String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: URL encoding/decoding is well known. From a hacker's point of view, we need
    it often for client-side vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encoding string**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '**Decoding string**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: You can encode/decode any non-URL string, of-course.
  prefs: []
  type: TYPE_NORMAL
- en: The above way will encode any non-URL standard strings only (ex. `<>"{}`) however
    if you want to encode the full string use `URI.encode_www_form_component`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: HTML En/Decode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Encoding HTML**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '**Decoding HTML**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: En/Decode SAML String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Decoding SAML**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[Source](http://stackoverflow.com/questions/3253298/base64-decode64-in-ruby-returning-strange-results)'
  prefs: []
  type: TYPE_NORMAL
- en: '[More about SAML][3]'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[3]: [http://dev.gettinderbox.com/2013/12/16/introduction-to-saml/](http://dev.gettinderbox.com/2013/12/16/introduction-to-saml/)'
  prefs: []
  type: TYPE_NORMAL
- en: Extraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String extraction is one of the main tasks that all programmers need. It's often
    difficult because we don't get an easy string presentation from which to extract
    useful data/information. Here are some helpful Ruby string-extraction cases.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting Network Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extracting MAC address from string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to extract all MAC addresses from an arbitrary string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '**Using Regular Expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: This regular expression should support Windows and Linux MAC address formats.
  prefs: []
  type: TYPE_NORMAL
- en: Lets to find our mac
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Extracting IPv4 address from string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to extract all IPv4 addresses from an arbitrary string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Let's find our IPs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Extracting IPv6 address from string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[Source](https://github.com/rapid7/rex-socket/blob/master/lib/rex/socket.rb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://gist.github.com/cpetschnig/294476](https://gist.github.com/cpetschnig/294476)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://snipplr.com/view/43003/regex--match-ipv6-address/](http://snipplr.com/view/43003/regex--match-ipv6-address/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting Web Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extracting URLs from a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assume we have the following string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '**Using Regular Expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '**Using standard URI module**'
  prefs: []
  type: TYPE_NORMAL
- en: This returns an array of URLs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Extracting URLs from web page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using above tricks
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: or using a regular expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Extracting email addresses from web page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Extracting strings from HTML tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assume we have the following HTML contents and we need to get strings only and
    eliminate all HTML tags
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Parsing colon separated data from a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During a pentest, you may need to parse text that has a very common format as
    follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The main idea is to remove *repeated* keys and pass to one key with an array
    of values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: For one-liner lovers
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pattern create
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Assume the pattern length = 500 (you can change it to any value). By default
    this will create 20280 probabilities max.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In case you need longer a pattern (ex. 30000) you can do the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Pattern offset
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I'll assume the pattern was equal or less than “20280” and we are looking for
    “9Ak0” pattern characters. The pattern_create should be initialized from above
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: This does not consider the Little-endian format, for that there is extra
    code that should be written. For more info, please take a look at the following
    [code][1].'
  prefs: []
  type: TYPE_NORMAL
- en: Generate all hexadecimal values from `\x00` to `\xff`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '**Notes:**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To change value presentation from `\xea` to `0xea`, change `\x%x` to `0x%x`
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: To make all letters capital (`\xea` to `\xEA`) , change `\x%x` to `\x%X`
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate all printable characters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: short and unclean
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[1]: [https://github.com/KINGSABRI/BufferOverflow-Kit/blob/master/lib/pattern.rb](https://github.com/KINGSABRI/BufferOverflow-Kit/blob/master/lib/pattern.rb)'
  prefs: []
  type: TYPE_NORMAL
