["```\n    class MonadTrans t where  lift :: Monad m => m a -> t m a\n    ```", "```\n    newtype StateT s m a = StateT { runStateT :: s -> m (a,s) } instance (Monad m) => Monad (StateT s m) where return a = StateT $ \\s -> return (a, s) m >>= k = StateT $ \\s0 -> do -- in monad m ~(a, s1) <- runStateT m s0 runStateT (k a) s1 instance MonadTrans (StateT s) where lift ma = StateT $ \\s -> do -- in monad m a <- ma return (a, s)\n    ```", "```\n    get :: (Monad m) => StateT s m s put :: (Monad m) => s -> StateT s m ()\n    ```", "```\n    import Control.Monad.Trans import Control.Monad.Trans.State main :: IO () main = runStateT go 0 >>= print where go = do xplusplus >>= lift . print xplusplus >>= lift . print xplusplus = do n <- get; put (n + 1); return n\n    ```", "```\n    *Main> main 0 1 ((),2)\n    ```", "```\nnewtype StateT s m a = StateT { runStateT :: s -> m (a,s) } instance (Monad m) => Monad (StateT s m) where return a = StateT $ \\s -> return (a, s) m >>= k = StateT $ \\s0 -> do -- in monad m ~(a, s1) <- runStateT m s0 runStateT (k a) s1\n```", "```\nget :: (Monad m) => StateT s m s put :: (Monad m) => s -> StateT s m ()\n```", "```\nnewtype StateT s m a = StateT { runStateT :: s -> m (a,s) } instance (Monad m) => Monad (StateT s m) where return a = StateT $ \\s -> return (a, s) m >>= k = StateT $ \\s0 -> do -- in monad m ~(a, s1) <- runStateT m s0 runStateT (k a) s1\n```", "```\nget :: (Monad m) => StateT s m s get = StateT $ \\s -> return (s, s) put :: (Monad m) => s -> StateT s m () put s = StateT $ \\_ -> return ((), s)\n```", "```\nclass (Monad m) => MonadIO m where  liftIO :: IO a -> m a instance MonadIO IO where liftIO = id\n```", "```\n    instance (MonadIO m) => MonadIO (StateT s m) where liftIO = lift . liftIO\n    ```", "```\n    myprint :: (Show a, MonadIO m) => a -> m () myprint a = liftIO $ print $ show a\n    ```", "```\n    oneTwo :: (Int, Int) oneTwo = (fst y, snd x) where x = (1, snd y) -- mutual recursion y = (fst x, 2) nthFib :: Int -> Integer nthFib n = fibList !! n where fibList = 1 : 1 : zipWith (+) fibList (tail fibList)\n    ```", "```\n        fix :: (a -> a) -> a fix f = let x = f x in x\n        ```", "```\n        oneTwo' :: (Int, Int) oneTwo' = (fst y, snd x) where (x, y) = fix $ \\ ~(x0, y0) -> let x1 = (1, snd y0) y1 = (fst x0, 2) in (x1, y1) nthFib' n = fibList !! n where fibList = fix $ \\l -> 1 : 1 : zipWith (+) l (tail l)\n        ```", "```\n    do fibList <- return $ 1 : 1 : zipWith (+) fibList (tail fibList) ... -- error, fibList not in scope ^^^^^^^ ^^^^^^^\n    ```", "```\n    class Monad m => MonadFix m where  mfix :: (a -> m a) -> m a\n    ```", "```\n    mfib :: (MonadFix m) => Int -> m Integer mfib n = do fibList <- mfix $ \\l -> return $ 1 : 1 : zipWith (+) l (tail l) return $ fibList !! n -- ^^^^^\n    ```", "```\n    oneTwo'' :: (MonadFix m) => m (Int, Int) oneTwo'' = do rec x <- return (1, snd y) y <- return (fst x, 2) return (fst y, snd x)\n    ```", "```\n    oneTwo''' :: (MonadFix m) => m (Int, Int) oneTwo''' = do (x, y) <- mfix $ \\ ~(x0, y0) -> do x1 <- return (1, snd y0) y1 <- return (fst x0, 2) return (x1, y1) return (fst y, snd x)\n    ```", "```\n    data Link a = Link !a !(MVar (Link a)) -- note ! is okay mkCycle :: IO (MVar (Link Int)) mkCycle = do rec l1 <- newMVar $ Link 1 l2 -- but $! would diverge l2 <- newMVar $ Link 2 l1 return l1\n    ```", "```\n    class MyClass t where  myTypeName :: t -> String -- non-strict in argument  myDefaultValue :: t instance MyClass Int where myTypeName _ = \"Int\" myDefaultValue = 0 getVal :: (MyClass t) => IO t getVal = mfix $ \\t -> do -- doesn't use mfix's full power putStrLn $ \"Caller wants type \" ++ myTypeName t return myDefaultValue\n    ```", "```\n    newtype Identity a = Identity { runIdentity :: a } instance Monad Identity where return = Identity m >>= k = k (runIdentity m)\n    ```", "```\n    instance MonadFix Identity where mfix f = let x = f (runIdentity x) in x\n    ```", "```\n    unsafeInterleaveIO :: IO a -> IO a\n    ```", "```\n        weird :: IO String weird = do xxx <- unsafeInterleaveIO $ do putStrLn \"Gotcha!\"; return [] return $ 'a':'b':'c':xxx\n        ```", "```\n    fixIO :: (a -> IO a) -> IO a fixIO k = do ref <- newIORef (throw NonTermination) ans <- unsafeInterleaveIO (readIORef ref) result <- k ans writeIORef ref result return result\n    ```", "```\n    mbroken :: (Monad m) => (a -> m a) -> m a -- equivalent to mfix? mbroken f = fix (>>= f)\n    ```", "```\n    mbroken f = mbroken f >>= f\n    ```", "```\n    *Main> mfix $ const (return 0) 0 *Main> mbroken $ const (return 0) *** Exception: stack overflow\n    ```", "```\n    newtype StateT s m a = StateT { runStateT :: s -> m (a,s) } instance (Monad m) => Monad (StateT s m) where return a = StateT $ \\s -> return (a, s) m >>= k = StateT $ \\s0 -> do -- in monad m ~(a, s1) <- runStateT m s0 runStateT (k a) s1\n    ```", "```\n    instance MonadFix m => MonadFix (StateT s m) where mfix f = StateT $ \\s0 -> do -- in monad m rec ~(a, s1) <- runStateT (f a) s0 return (a, s1)\n    ```", "```\n    instance MonadFix m => MonadFix (StateT s m) where mfix f = StateT $ \\s -> mfix $ \\ ~(a, _) -> runStateT (f a) s\n    ```", "```\n    class ClassName var where  methodName :: Type {- where type references var -}\n    ```", "```\n    class (SuperClass var) => ClassName var where ... class (Super1 var, Super2 var) => ClassName var where ... ...\n    ```", "```\n        Prelude> :t return return :: Monad m => a -> m a\n        ```", "```\n    instance [context =>] ClassName (TypeCon v1 ... vk) where ...\n    ```", "```\n    {-# LANGUAGE MultiParamTypeClasses #-} class Convert a b where convert :: a -> b instance Convert Int Bool where convert = (/= 0) instance Convert Int Integer where convert = toInteger instance (Convert a b) => Convert [a] [b] where convert = map convert\n    ```", "```\n        class MyClass a b where  aDefault :: a -- can never use (without more extensions...)\n        ```", "```\n         convert 0 :: Bool -- error, 0 has type (Num a) => a\n        ```", "```\n        instance Convert Int [Char] where convert = show -- error bad param\n        ```", "```\n    {-# LANGUAGE FlexibleInstances #-} instance Convert Int [Char] where convert = show\n    ```", "```\n    instance Convert a a where convert a = a\n    ```", "```\n    *Main> convert () :: () () *Main> convert ([1,2,3]::[Int]) :: [Integer] [1,2,3] *Main> convert ([1,2,3]::[Int]) :: [Int] <interactive>:1:1: Overlapping instances for Convert [Int] [Int] instance Convert a a instance Convert a b => Convert [a] [b]\n    ```", "```\n    class MyShow a where myShow :: a -> String instance MyShow Char where myShow = show instance MyShow Int where myShow = show instance MyShow [Char] where myShow = id instance (MyShow a) => MyShow [a] where myShow [] = \"[]\" myShow (x:xs) = \"[\" ++ myShow x ++ go xs where go (y:ys) = \",\" ++ myShow y ++ go ys go [] = \"]\"\n    ```", "```\n    {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE FlexibleInstances #-} {-# LANGUAGE OverlappingInstances #-} instance Convert a a where ... instance (Convert a b) => Convert [a] [b] where ...\n    ```", "```\n    *Main> convert ([1,2,3]::[Int]) :: [Int] <interactive>:1:1: Overlapping instances for Convert [Int] [Int] instance [overlap ok] Convert a a instance [overlap ok] Convert a b => Convert [a] [b]\n    ```", "```\n    instance Convert [a] [a] where convert = id\n    ```", "```\n    *Main> convert ([1,2,3]::[Int]) :: [Int] [1,2,3]\n    ```", "```\nmodule Help where class MyShow a where  myshow :: a -> String instance MyShow a => MyShow [a] where myshow xs = concatMap myshow xs  showHelp :: MyShow a => [a] -> String showHelp xs = myshow xs -- doesn't see overlapping instance module Main where import Help data T = MkT instance MyShow T where myshow x = \"Used generic instance\" instance MyShow [T] where myshow xs = \"Used more specific instance\" main = do { print (myshow [MkT]); print (showHelp [MkT]) }\n```", "```\n*Main> main \"Used more specific instance\" \"Used generic instance\"\n```", "```\nclass Show a where  show :: a -> String  showList :: [a] -> ShowS showList as = '[' : intercalate \", \" (map show as) ++ \"]\" -- Note actual implementation more efficient but equivalent instance (Show a) => Show [a] where show as = showList as\n```", "```\n    toInt val = convert val :: Int\n    ```", "```\n    toInt :: (Convert a Int) => a -> Int\n    ```", "```\n        sym :: forall a. Eq a => Int -- illegal\n        ```", "```\n        sym :: Eq Int => Bool -- illegal\n        ```", "```\n    {-# LANGUAGE MultiParamTypeClasses #-} {-# LANGUAGE FlexibleInstances #-} class (Monad m) => MonadState s m where  get :: m s  put :: s -> m () instance (Monad m) => MonadState s (StateT s m) where get = StateT $ \\s -> return (s, s) put s = StateT $ \\_ -> return ((), s)\n    ```", "```\n    instance (MonadIO m) => MonadIO (ReaderT r m) where liftIO = lift . liftIO instance (MonadState s m) => MonadState s (ReaderT r m) where get = lift get put = lift . put\n    ```", "```\n     xplusplus = do n <- get; put (n + 1); return n\n    ```", "```\n        instance MonadState Double (StateT Int IO) where -- would be legal, but exists only in compiler's imagination\n        ```", "```\n     xplusplus = do n <- get :: StateT Int IO Int put (n + 1) return n\n    ```", "```\n    class (Monad m) => MonadState s m | m -> s where  get :: m s  put :: s -> m ()\n    ```", "```\n        class Class a b instance (Class a a) => Class [a] Bool -- bad: 2 * a > 1 * a instance (Class a b) => Class [a] Bool -- bad: 1 * b > 0 * b\n        ```", "```\n        instance (Class a Int) => Class a Integer -- bad: 2 >= 2\n        ```", "```\n    class Class a b | a -> b instance Class a (Maybe a) -- ok: a \"covered\" by left instance Class Int (Maybe b) -- bad: b not covered instance Class a (Either a b) -- bad: b not covered\n    ```", "```\n    crash = f5 () where f0 x = (x, x) -- type size 2^{2^0} f1 x = f0 (f0 x) -- type size 2^{2^1} f2 x = f1 (f1 x) -- type size 2^{2^2} f3 x = f2 (f2 x) -- type size 2^{2^3} f4 x = f3 (f3 x) -- type size 2^{2^4} f5 x = f4 (f4 x) -- type size 2^{2^5}\n    ```", "```\n        {-# OPTIONS_GHC -fcontext-stack=1024 #-} {-# LANGUAGE UndecidableInstances #-}\n        ```", "```\n    class (Monad m) => MonadIO m where  liftIO :: IO a -> m a instance MonadIO IO where liftIO = id\n    ```", "```\n    instance MonadIO m => MonadIO (StateT s m) where liftIO = lift . liftIO instance MonadIO m => MonadIO (ReaderT t m) where liftIO = lift . liftIO instance MonadIO m => MonadIO (WriterT w m) where liftIO = lift . liftIO ...\n    ```", "```\n    {-# LANGUAGE FlexibleInstances #-} {-# LANGUAGE UndecidableInstances #-} -- undecidable: assertion Monad (t m) no smaller than head instance (MonadTrans t, MonadIO m, Monad (t m)) => MonadIO (t m) where liftIO = lift . liftIO\n    ```", "```\n    {-# LANGUAGE MultiParamTypeClasses #-} -- very conservative {-# LANGUAGE FlexibleInstances #-} -- conservative {-# LANGUAGE FlexibleContexts #-} -- conservative {-# LANGUAGE FunctionalDependencies #-} -- frowned upon {-# LANGUAGE UndecidableInstances #-} -- very frowned upon {-# LANGUAGE OverlappingInstances #-} -- the most controversial\n    ```", "```\ndata HFalse = HFalse deriving Show data HTrue = HTrue deriving Show class HNot a b | a -> b where hNot :: a -> b instance HNot HFalse HTrue where hNot _ = HTrue instance HNot HTrue HFalse where hNot _ = HFalse\n```", "```\n*Main> hNot HTrue HFalse *Main> hNot HFalse HTrue\n```", "```\n    class TypeEq a b c | a b -> c where typeEq :: a -> b -> c instance TypeEq a a HTrue where typeEq _ _ = HTrue instance TypeEq a b HFalse where typeEq _ _ = HFalse\n    ```", "```\n    class TypeCast a b | a -> b where typeCast :: a -> b instance TypeCast a a where typeCast = id instance TypeEq a a HTrue where typeEq _ _ = HTrue -- as before instance (TypeCast HFalse c) => TypeEq a b c where typeEq _ _ = typeCast HFalse\n    ```", "```\n    -- If t is StateT, then do one thing for (t s m) (base case): instance (Monad m) => MonadState s (StateT s m) where get = StateT $ \\s -> return (s, s) put = StateT $ \\_ -> return ((), s) -- If t is not StateT, do something else (recursive case): instance (MonadTrans t, MonadState s m, Monad (t m)) => MonadState s (t m) where get = lift get put = lift . put\n    ```", "```\n    data a :*: b = Foo a b type a :+: b = Either a b\n    ```", "```\n    data HNil = HNil deriving Show data (:*:) h t = h :*: !t deriving Show infixr 9 :*: -- Example: data A = A deriving Show data B = B deriving Show data C = C deriving Show foo = (A, \"Hello\") :*: (B, 7) :*: (C, 3.0) :*: HNil\n    ```", "```\n    *Main> foo (A,\"Hello\") :*: ((B,7) :*: ((C,3.0) :*: HNil)) *Main> :t foo foo :: (A, [Char]) :*: ((B, Integer) :*: ((C, Double) :*: HNil))\n    ```", "```\n    foo :: (A, [Char]) :*: (B, Integer) :*: (C, Double) :*: HNil foo = (A, \"Hello\") :*: (B, 7) :*: (C, 3.0) :*: HNil\n    ```", "```\n    class Select k h v | k h -> v where  (.!) :: h -> k -> v instance Select k ((k, v) :*: t) v where (.!) ((_, v) :*: _) _ = v instance (Select k h v) => Select k (kv' :*: h) v where (.!) (kv' :*: h) k = h .! k\n    ```", "```\n    *Main> foo .! A \"Hello\"\n    ```", "```\n    returnIO :: a -> IO a returnIO = return data GetVal = GetVal deriving Show data SetVal = SetVal deriving Show data ClearVal = ClearVal deriving Show mkVal n self = do val <- newIORef (n :: Int) returnIO $ (GetVal, readIORef val) :*: (SetVal, writeIORef val) :*: (ClearVal, self .! SetVal $ 0) :*: HNil test = do -- prints 7, then 0 x <- mfix $ mkVal 7 x .! GetVal >>= print x .! ClearVal x .! GetVal >>= print\n    ```", "```\n    mkConstVal n self = do super <- mkVal n self returnIO $ (SetVal, const $ return ()) :*: super test2 = do x <- mfix $ mkConstVal 7 x .! GetVal >>= print x .! ClearVal x .! GetVal >>= print\n    ```", "```\n    *Main> test 7 0 *Main> test2 7 7 \n    ```"]