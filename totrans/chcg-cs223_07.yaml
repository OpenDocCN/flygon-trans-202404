- en: Basic Animations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of our renderings so far have been "static" in the sense that the state,
    or model, values have been independent of time (though they have been dependent
    on other time-varying values, such as mouse position and clicks).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We will now work through an example where we will keep track of time in order
    to *animate* what we render. Our goal will be to draw circles around each mouse
    click that fade out gradually over time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Clicks with Timestamps
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll start by defining the `State` in our application to be a list of `Click`s,
    where each value records the `Time` and position of the click.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The definitions of the initial `State` as well as the function to update it
    upon each `Click` are both trivial.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To help during the development process, let's render the most recent `Click`
    to see how the `State` of our application changes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We now need to use primitive signals to "drive" our application. In particular,
    we need to track time and mouse clicks. [One way to define time](http://elm-lang.org/edit/examples/Reactive/Fps.elm)
    is to sum the time deltas returned by [`Time.fps`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Time).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we can generate timestamps for clicks by sampling both `time` and `Mouse.position`
    whenever `Mouse.clicks` is updated. Notice how we use the `(<~)` and `(~)` operators
    to call [`Signal.map2`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Signal)
    (with, arguably, nicer syntax) in order to pair time and position values.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can now base our `State` updates on the `clicks` signal in order to render
    the latest one to the screen.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This pattern of attaching timestamps to time-varying values lends itself to
    the following generalization:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Indeed, the [`Time`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Time)
    library provides a `timestamp` function, albeit with slightly different behavior:
    the timestamps attached to values record system time (via `Time.every`) rather
    than application time (computed via `Time.fps`).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Drawing All Dots
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll start by drawing circles for all clicks, irrespective of their timestamps.
    There are several factors to consider:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: mouse coordinates (produced by `Mouse.position`) are specified relative to the
    top-left corner of the window,
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collage` (which we will use to draw the entire window) is centered in the
    middle of the window, and'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`move` (supplied with positive arguments) translates `Shapes` in a collage
    up and to the right.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Taking these into account, we draw dots as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The source code for this milestone can be found in [`FadingDots0.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Animations/FadingDots0.elm),
    and [here](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Animations/FadingDots0.html)
    is a demo in action.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Drawing Recent Dots
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to display only the most recent dots, we need to track the current
    time in `State` — there's nowhere else to put it!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The upstating function stores the timestamp `t` of a new `Click` as the current
    time (that is, the most recently updated current time).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we have the `now` time in our `State`, we can draw dots for only those
    clicks that occurred within the last, say, two seconds. The `tfade` binding allows
    us to twiddle this parameter if desired.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The source code for this milestone can be found in [`FadingDots1.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Animations/FadingDots1.elm),
    and [here](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Animations/FadingDots1.html)
    is a demo in action.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: This is good progress, but dots can linger for more than two seconds; old dots
    are "discarded" only when the next click occurs, which can be arbitrarily far
    in the future. So, what can we do?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Merging Signals
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `State` of our application is defined (in `main`) to react only to changes
    in `clicks`, but we also want to react to changes in `time` so that we can promptly
    "discard" old clicks. The following function combines two signals into one:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We cannot `merge` the signals `time` and `clicks` straight away, because they
    produce different types of values. Not to worry, however, because we can define
    a new datatype to describe values produced by either signal. And our upstating
    function will then handle each kind of value separately.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice how both `NewTime` and `NewClick` values carry the new time `t` to track
    in the updated `State`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: While we're modifying `upstate`, we might as well optimize our `State` representation
    so that it contains only those points that will be rendered. The `pruneOld` function
    below takes advantage of the invariant that the clicks in `State` are ordered
    from youngest to oldest. Therefore, it stops traversing clicks as soon as the
    first "stale" one is found.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We now update our `main` to `merge` the two signals, where their values are
    appropriately wrapped with the `NewTime` and `NewClick` data constructors.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Animation: Fade'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have reached the home stretch. Dots will now disappear expediently, but let's
    have them fade out gradually and, at the same time, grow in size to achieve a
    nice diffusion effect.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: For each mouse click, we define `pct` to be the percentage of time that has
    passed between when the dot first appears (its timestamp `t`) and when it completely
    disappears (`t + tfade`). We use this coefficient to compute the transparency
    of the circle as well its increased radius.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that `view` no longer needs to filter old dots, because `upstate` has
    already taken care of it. A much more pleasing factoring of work!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[![](../Images/34b82a1328e5ff6ada076d9f967a0287.jpg)](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Animations/FadingDots2.html)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Now that we're drawing larger circles, the delay between frames becomes more
    noticeable. So, let's crank it up.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The final version is contained in [`FadingDots2.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Animations/FadingDots2.elm).
    Check it out [in action](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Animations/FadingDots2.html)!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最终版本包含在 [`FadingDots2.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Animations/FadingDots2.elm)
    中。看看它在[action](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Animations/FadingDots2.html)中的效果！
- en: Different Ways of Tracking Time
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跟踪时间的不同方式
- en: 'Notice that there are two different ways to keep track of how long an Elm application
    has been running: by summing the time deltas produced by `Time.fps` (as we did
    in this example), and by comparing the current value of `Time.every` to its intial
    value. These two approaches do not always yield the same result! To investigate,
    try out the [`Lag.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Animations/Lag.elm)
    example by Stuart Kurtz.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有两种不同的方法来跟踪 Elm 应用程序运行了多长时间：一种是通过累加由`Time.fps`产生的时间增量（就像我们在这个例子中做的那样），另一种是将`Time.every`的当前值与其初始值进行比较。这两种方法并不总是产生相同的结果！要进行调查，请尝试
    Stuart Kurtz 的[`Lag.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Animations/Lag.elm)
    示例。
