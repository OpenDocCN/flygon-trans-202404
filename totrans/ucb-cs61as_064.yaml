- en: Hierarchical Structures - Capital-T Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intro to Capital-T Trees (The Abstract Data Type)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you continue reading, note that the capital-T Trees we talk about in
    this section are different than the trees from SICP. In SICP (and in the previous
    sections), trees are simply a fancy word for deep lists. In this section, we introduce
    a new concept, Trees, which are an abstract data type (ADT). These Trees must
    respect certain abstraction barriers. When you hear most computer scientists talk
    about Trees in the real-world, they are typically talking about this ADT.
  prefs: []
  type: TYPE_NORMAL
- en: As with lists and sentences, we can also store data in the Trees data structure.
    They are generally useful for providing hierarchy, ordering, and composition.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree diagram of the US. US is at the top, with California and Massechusetts
    underneath it. Underneath CA are San JOse and Berkeley. Underneath MA is Boston.](/static/trees_hierarchy.png)'
  prefs: []
  type: TYPE_IMG
- en: The name comes from the downwards branching structure, similar to real trees
    but upside down. A **node** is a point at the Tree. Each node contains a **datum**
    ("U.S.A", "California" are some datums). Notice that a node can contain another
    Tree. The node with "California" can be regarded as a Tree with "California" at
    the top. Because of this, nodes and Trees are the same thing! We generally use
    'Tree' to refer to the whole structure. Another synonym for a node is subtree.
  prefs: []
  type: TYPE_NORMAL
- en: The **root** of a Tree is the topmost node. All Trees have only one root. In
    this case, it is "U.S.A"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **parent** of a node is the node directly above it. All nodes have exactly
    one parent, except for the root which has no parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **children** of a node are the nodes that are directly beneath it. The children
    of "California" are "Berkeley" and "San Jose".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **branch** node is a node that has at least one child (like "U.S.A","California"
    and "Massachusetts").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **leaf** node is a node that no children. (like "Berkeley", "San Jose", and
    "Boston")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Tree ADT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have our own ADT to represent Trees that we will use for the rest of this
    lesson, but there is no official way to represent Trees. Why? This is because
    there are several different design choices to make when creating a Tree ADT:'
  prefs: []
  type: TYPE_NORMAL
- en: Branch nodes may or may not have data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary Trees (2 branches) vs N-way Trees (N branches)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order of children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can Trees be empty?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '... and many more'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different representations of Trees will give you different limitations, features,
    and functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the built-in constructors and selectors for Trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructor:** `make-tree` takes in two arguments, a datum and a list of
    its children, and creates a Tree ADT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selector:** `datum` takes in a node and returns the datum that the node stores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selector:** `children` takes in a node and returns the list of its children.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under the Hood
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way to implement the Trees described above is with the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The selector `children` accepts a node as its single argument and returns its
    children, **a list of Trees**. A list of Trees is called a **forest**. Remember
    that Trees and forests are two different data structures! In addition, you **should**
    think of a forest as a list of Trees, but you **should NOT** think of a Tree as
    a bunch of `cons`, `cars`, and `cdrs`.
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, the constructor and selectors for forests are `list`, `car`, and
    `cdr`, while the constructor and selectors for (this ADT of) Trees are `make-tree`,
    `datum`, and `children`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, since a leaf is a node with no children, we could use a predicate
    like this to check whether a node is a leaf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Remember that using lists is *just one way* to represent Trees. We can't assume
    that someone who designed the ADT would use a list. For example, if `maple` is
    a Tree, we can't assume that `(cdr maple)` will give us the children. Instead,
    we must respect the data abstraction and use the constructors and selectors they
    provide for us.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction Barrier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![A real-life tree with a caution tape around it.](http://www.alienspouse.com/.a/
    6a00d8345216fc69e201310f6497b3970c-300wi)'
  prefs: []
  type: TYPE_IMG
- en: We cannot stress enough that you cannot make **any** assumptions on how a Tree
    ADT is implemented. When working on Trees, you can only use the constructors/selectors
    that are provided. Since forests are implemented as a list of Trees, you can use
    `car` of a forest to find the first Tree, or `cdr` to find a list of the rest
    of the Trees.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming pine refers to a Tree, which of the following is a data abstraction
    violation (DAV)?
  prefs: []
  type: TYPE_NORMAL
- en: Mapping over Trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Something useful that we do to Trees often is to map a certain operation to
    it, akin to mapping over a list. We can achieve this by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We apply the function to our datum, and map the function recursively on the
    children.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you stare at the above code until it makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Mutual Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is an alternative way to define `treemap` that applies a function `fn`
    throughout the tree. Observe how the overall process is recursive, but `treemap`
    does not directly call itself. `treemap` will be (mostly) responsible for applying
    `fn` to the datum of a single Tree. Who handles the forest? Well, `treemap` will
    call a helper procedure, `forest-map`, which applies `fn` to all elements in the
    forest.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How does `forest-map` apply `fn` to the forest? Well, a forest is just a list
    of Trees, and we know that we have `treemap` that handles a single Tree. So, all
    we need to do is recursively call `treemap` on all Trees in the forest!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `treemap` calls `forest-map`, and `forest-map` calls `treemap`.
    The pattern of **A** calling **B** and **B** calling **A** is called **mutual
    recursion**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Penguins making the LEAP OF FAITH into icy waters](http://images.nationalgeographic.com/wpf/media-
    live/photos/000/247/cache/gentoo-penguins-jumping-in-water_24700_600x450.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`count-leaves`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's use mutual recursion to write the procedure `count-leaves`, which returns
    the number of leaves in a tree. Let's take this step by step. Since we're using
    mutual recursion, that means we'll need a procedure to manage Trees, `count-leaves`,
    and a procedure to manage forests, `count-leaves-in-forest`.
  prefs: []
  type: TYPE_NORMAL
- en: '`count-leaves`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base case:** If the node is a leaf node, then just return 1\.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recursive call:** Otherwise, it calls `count-leaves-in-forest`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code for `count-leaves`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`count-leaves-in-forest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base case:** If the forest is `null?`, return 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recursive call:** Otherwise, we need to find the total number of leaves in
    all of the trees in the forest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We call `count-leaves` on the `car` of the forest to find how many leaves are
    in the first Tree of the forest.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We recursively call `count-leaves-in-forest` on the `cdr` of the forest to find
    the number of leaves in the rest of the forest.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add these two values together to find the total number of leaves.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the code for `count-leaves-in-forest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tree Traversals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen how we can store and find elements in Trees. Now, many situations
    that use the Tree data structure involves visiting all of our nodes and do something
    with all of the elements. The obvious way is to go up-down and left-right, but
    there are many other ways we can traverse a Tree.
  prefs: []
  type: TYPE_NORMAL
- en: Depth First Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depth First Search (DFS) is when you explore a node's children before its siblings.
    The name comes from the fact that you are going as deep as you can in one branch
    before looking at other branches. The gif below demonstrates this. The numbers
    indicate the order in which the nodes are visited.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ef6204646633c23ca1cc54d642f2c7c1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that it finishes exploring one branch before exploring other branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can demonstrate this in Racket. Lets say we want to print every single node.
    Our Tree ADT actually follows the same structure, so our implementation of dfs
    is rather simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Breadth First Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Breadth First Search (BFS) explores the siblings before its children. It''s
    easier to imagine this as looking at the graph in ''layers''. First we look at
    the Tree''s root, then its children, followed by its grandchildren, and so on.
    The gif below demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](http://upload.wikimedia.org/wikipedia/commons/5/5d/Breadth-First-Search-
    Algorithm.gif)'
  prefs: []
  type: TYPE_IMG
- en: Implementing BFS in Racket is slightly harder because our ADT stores information
    in a different order than the order in which BFS traverses. One way around this
    is to use another data structure called a [queue](https://mitpress.mit.edu/sicp/full-text/sicp/book/node62.html),
    which stores (in order) the nodes that are going to be checked next.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: BFS Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lets walk through how the code above works using the example Tree below. The
    arrows in the diagram indicate the parent --> child relationships.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fe248a6227e06996d75ce25926bf94ba.svg)'
  prefs: []
  type: TYPE_IMG
- en: When `bfs-iter` is first called, the whole Tree is put into the `queue`. To
    simplify things, let's say a tree is denoted by its root.
  prefs: []
  type: TYPE_NORMAL
- en: '`queue`: F'
  prefs: []
  type: TYPE_NORMAL
- en: It dequeues node F, prints the value of node F, and recursively calls `bfs-iter`
    with the rest of the queue and the children of F. The rest of the queue is empty,
    but the children of F is B G.
  prefs: []
  type: TYPE_NORMAL
- en: '`queue`: B G'
  prefs: []
  type: TYPE_NORMAL
- en: '`bfs-iter` will print the node of the first tree in the queue, B and recursively
    calls `bfs-iter` with the rest of the queue, G, and the children of B, A D.'
  prefs: []
  type: TYPE_NORMAL
- en: '`queue`: G A D'
  prefs: []
  type: TYPE_NORMAL
- en: And so on until the queue is empty. Once the queue is empty, we will have printed
    out each node's datum exactly once.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the siblings are always first in the queue and the children are entered
    from the back. This ensures that siblings are checked first before children.
  prefs: []
  type: TYPE_NORMAL
- en: DFS vs BFS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![xkcd.com](../Images/5ab4fb493705420056e50f6bae12b442.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Is one better than the other? It depends on what you are trying to do with your
    Trees and how you are storing elements in the Tree.
  prefs: []
  type: TYPE_NORMAL
- en: The Tree below represents things in a house. In a "House" you can find a "Kitchen"
    and "Cat Food". In a "Kitchen" you can find a "Drawer", "Trash Can", etc. The
    leaves contain food and the deeper you go, the more filling the foods are.
  prefs: []
  type: TYPE_NORMAL
- en: '![](/static/cat_tree_search.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: Consider a Tree with a structure similar to the one above. Imagine you are a
    starving cat searching for **any** food to fill your stomach as soon as possible.
    What kind of Tree traversal is more appropriate for the following situation?
  prefs: []
  type: TYPE_NORMAL
- en: You are still a cat, but now you're on a quest to find the most delicious food
    in the house. Which Tree traversal will help you find it the fastest?
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the takeaways from this subsection:'
  prefs: []
  type: TYPE_NORMAL
- en: Remember your constructor and selectors (`make-tree`, `datum`, and `children`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To map over Trees, we use mutual recursion, where the two procedures are written
    in terms of each other. Typically, one of those procedures takes in a Tree, and
    the other takes in a forest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breadth First Search looks at the nodes in the same level first, whereas Depth
    First Search goes through each branch until it hits the leaf node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
