["```\nclass ModelStageShape() extends Shape {\n var dataRecordIn = Inlet[WineRecord](\"dataRecordIn\")\n var modelRecordIn = Inlet[ModelToServe](\"modelRecordIn\")\n var scoringResultOut = Outlet[Option[Double]](\"scoringOut\")\n\ndef this(dataRecordIn: Inlet[WineRecord], modelRecordIn:\n  Inlet[ModelToServe],scoringResultOut: Outlet[Option[Double]]) {\n\n   this()\n   this.dataRecordIn = dataRecordIn\n   this.modelRecordIn = modelRecordIn\n   this.scoringResultOut = scoringResultOut\n }\n\n override def deepCopy(): Shape =\n   new ModelFanInShape(dataRecordIn.carbonCopy(),\n   modelRecordIn.carbonCopy(), scoringResultOut)\n\n override def copyFromPorts(inlets: immutable.Seq[Inlet[_]],\n   outlets: immutable.Seq[Outlet[_]]): Shape =\n   new ModelFanInShape(\n     inlets(0).asInstanceOf[Inlet[WineRecord]],\n     inlets(1).asInstanceOf[Inlet[ModelToServe]],\n     outlets(0).asInstanceOf[Outlet[Option[Double]]])\n\n override val inlets = List(dataRecordIn, modelRecordIn)\n override val outlets = List(scoringResultOut)\n}\n```", "```\nclass ModelStage\n  extends GraphStageWithMaterializedValue[ModelStageShape] {\n\n private val factories = ...\n\n override val shape: ModelStageShape = new ModelStageShape\n\n override def createLogicAndMaterializedValue\n   (inheritedAttributes: Attributes): (GraphStageLogic) = {\n\n   new GraphStageLogicWithLogging(shape) {\n     // State must be kept in the Logic instance\n     private var currentModel : Option[Model] = None\n     private var newModel : Option[Model] = None\n     // Start pulling input streams\n     override def preStart(): Unit = {\n       tryPull(shape.modelRecordIn)\n       tryPull(shape.dataRecordIn)\n     }\n\n     setHandler(shape.modelRecordIn, new InHandler {\n       override def onPush(): Unit = {\n         val model = grab(shape.modelRecordIn)\n         newModel = factories.get(model.modelType) match{\n           case Some(factory) => factory.create(model)\n           case _ => None\n         }\n         pull(shape.modelRecordIn)\n       }\n     })\n\n     setHandler(shape.dataRecordIn, new InHandler {\n       override def onPush(): Unit = {\n         val record = grab(shape.dataRecordIn)\n         newModel match {\n           case Some(model) => {\n             // Close current model first\n             currentModel match {\n               case Some(m) => m.cleanup()\n               case _ =>\n             }\n             // Update model\n             currentModel = Some(model)\n             newModel = None\n           }\n           case _ =>\n         }\n         currentModel match {\n           case Some(model) => {\n             val quality =\n              model.score(record.asInstanceOf[AnyVal])\n                .asInstanceOf[Double]\n             push(shape.scoringResultOut, Some(quality))\n           }\n           case _ => {\n             push(shape.scoringResultOut, None)\n           }\n         }\n         pull(shape.dataRecordIn)\n       }\n     })\n\n     setHandler(shape.scoringResultOut, new OutHandler {\n       override def onPull(): Unit = {}\n     })\n   }\n  }\n}\n```", "```\nobject AkkaModelServer {\n\n implicit val system = ActorSystem(\"ModelServing\")\n implicit val materializer = ActorMaterializer()\n implicit val executionContext = system.dispatcher\n\n val dataConsumerSettings = ConsumerSettings(system,\n  new ByteArrayDeserializer, new ByteArrayDeserializer)\n   .withBootstrapServers(LOCAL_KAFKA_BROKER)\n   .withGroupId(DATA_GROUP)\n   .withProperty(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"latest\")\n\n val modelConsumerSettings = ConsumerSettings(\n  system, new ByteArrayDeserializer, new ByteArrayDeserializer)\n   .withBootstrapServers(LOCAL_KAFKA_BROKER)\n   .withGroupId(MODELS_GROUP)\n   .withProperty(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"latest\")\n\n def main(args: Array[String]): Unit = {\n   import ApplicationKafkaParameters._\n   val modelStream: Source[ModelToServe, Consumer.Control] =Consumer\n       .atMostOnceSource(modelConsumerSettings,Subscriptions\n       .topics(MODELS_TOPIC))\n       .map(record => ModelToServe.fromByteArray(record.value()))\n       .filter(_.isSuccess).map(_.get)\n\n   val dataStream: Source[WineRecord, Consumer.Control] = Consumer\n       .atMostOnceSource(dataConsumerSettings, Subscriptions\n       .topics(DATA_TOPIC))\n       .map(record => DataRecord.fromByteArray(record.value()))\n       .filter(_.isSuccess).map(_.get)\n   val model = new ModelStage()\n\n   def dropMaterializedValue[M1, M2, M3](m1: M1, m2: M2, m3: M3):\n     NotUsed = NotUsed\n\n   val modelPredictions  = Source.fromGraph(\n     GraphDSL.create(dataStream, modelStream, model)(\n      dropMaterializedValue) {\n       implicit builder => (d, m, w) =>\n         import GraphDSL.Implicits._\n         // Wire input streams with the model stage (2 in, 1 out)\n         d ~> w.dataRecordIn\n         m ~> w.modelRecordIn\n         SourceShape(w.scoringResultOut)\n     }\n   )\n}\n```"]