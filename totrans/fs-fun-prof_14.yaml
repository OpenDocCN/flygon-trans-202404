- en: The "Computation Expressions" Series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “计算表达式”系列
- en: In this series, you'll learn what computation expressions are, some common patterns,
    and how to make your own. In the process, we'll also look at continuations, the
    bind function, wrapper types, and more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系列中，你将学习什么是计算表达式，一些常见模式，以及如何制作自己的计算表达式。在这个过程中，我们还将看看延续、绑定函数、包装类型等内容。
- en: '[Computation expressions: Introduction](computation-expressions-intro.html).
    Unwrapping the enigma....'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[计算表达式：介绍](computation-expressions-intro.html)。揭开谜团....'
- en: '[Understanding continuations](computation-expressions-continuations.html).
    How ''let'' works behind the scenes.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[理解延续](computation-expressions-continuations.html)。''let''在幕后是如何工作的。'
- en: '[Introducing ''bind''](computation-expressions-bind.html). Steps towards creating
    our own ''let!'' .'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[介绍''bind''](computation-expressions-bind.html)。迈向创建我们自己的''let!''的步骤。'
- en: '[Computation expressions and wrapper types](computation-expressions-wrapper-types.html).
    Using types to assist the workflow.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[计算表达式和包装类型](computation-expressions-wrapper-types.html)。使用类型来辅助工作流程。'
- en: '[More on wrapper types](computation-expressions-wrapper-types-part2.html).
    We discover that even lists can be wrapper types.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[更多关于包装类型](computation-expressions-wrapper-types-part2.html)。我们发现即使列表也可以是包装类型。'
- en: '[Implementing a builder: Zero and Yield](computation-expressions-builder-part1.html).
    Getting started with the basic builder methods.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实现一个构建器：Zero和Yield](computation-expressions-builder-part1.html)。开始使用基本构建器方法。'
- en: '[Implementing a builder: Combine](computation-expressions-builder-part2.html).
    How to return multiple values at once.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实现一个构建器：组合](computation-expressions-builder-part2.html)。如何一次返回多个值。'
- en: '[Implementing a builder: Delay and Run](computation-expressions-builder-part3.html).
    Controlling when functions execute.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实现一个构建器：延迟和运行](computation-expressions-builder-part3.html)。控制函数何时执行。'
- en: '[Implementing a builder: Overloading](computation-expressions-builder-part4.html).
    Stupid method tricks.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实现一个构建器：重载](computation-expressions-builder-part4.html)。愚蠢的方法技巧。'
- en: '[Implementing a builder: Adding laziness](computation-expressions-builder-part5.html).
    Delaying a workflow externally.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实现一个构建器：添加延迟](computation-expressions-builder-part5.html)。外部延迟工作流程。'
- en: '[Implementing a builder: The rest of the standard methods](computation-expressions-builder-part6.html).
    Implementing While, Using, and exception handling.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实现一个构建器：标准方法的其余部分](computation-expressions-builder-part6.html)。实现While、Using和异常处理。'
- en: 'Computation expressions: Introduction'
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算表达式：介绍
- en: 'Computation expressions: Introduction'
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算表达式：介绍
- en: By popular request, it is time to talk about the mysteries of computation expressions,
    what they are, and how they can be useful in practice (and I will try to avoid
    using the [forbidden m-word](../about/index.md#banned)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 受到广泛请求，现在是时候谈谈计算表达式的奥秘，它们是什么，以及它们如何在实践中有用（我将尽量避免使用[被禁止的m字词](../about/index.md#banned)）。
- en: In this series, you'll learn what computation expressions are, how to make your
    own, and what some common patterns involving them. In the process, we'll also
    look at continuations, the bind function, wrapper types, and more.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系列中，你将学习什么是计算表达式，如何制作自己的计算表达式，以及涉及它们的一些常见模式。在这个过程中，我们还将看看延续、绑定函数、包装类型等内容。
- en: Background
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: Computation expressions seem to have a reputation for being abstruse and difficult
    to understand.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 计算表达式似乎以晦涩难懂而闻名。
- en: On one hand, they're easy enough to use. Anyone who has written much F# code
    has certainly used standard ones like `seq{...}` or `async{...}`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，它们很容易使用。任何写过很多F#���码的人肯定使用过标准的像`seq{...}`或`async{...}`这样的方法。
- en: But how do you make a new one of these things? How do they work behind the scenes?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如何制作一个新的这些东西？它们在幕后是如何工作的？
- en: Unfortunately, many explanations seem to make things even more confusing. There
    seems to be some sort of mental bridge that you have to cross. Once you are on
    the other side, it is all obvious, but to someone on this side, it is baffling.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，许多解释似乎让事情变得更加混乱。似乎有一种心理桥梁你必须跨越。一旦你站在另一边，一切都显而易见，但对于站在这边的人来说，这是令人困惑的。
- en: If we turn for guidance to the [official MSDN documention](http://msdn.microsoft.com/en-us/library/dd233182.aspx),
    it is explicit, but quite unhelpful to a beginner.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们求助于[官方MSDN文档](http://msdn.microsoft.com/en-us/library/dd233182.aspx)，它是明确的，但对于初学者来说并不是很有帮助。
- en: 'For example, it says that when you see the following code within a computation
    expression:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，它说当你在计算表达式中看到以下代码时：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'it is simply syntactic sugar for this method call:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是这个方法调用的语法糖：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: But... what does this mean exactly?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但...这到底是什么意思？
- en: I hope that by the end of this series, the documentation above will become obvious.
    Don't believe me? Read on!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望在本系列结束时，上面的文档将变得明显。不相信我？继续阅读！
- en: Computation expressions in practice
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践中的计算表达式
- en: Before going into the mechanics of computation expressions, let's look at a
    few trivial examples that show the same code before and after using computation
    expressions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究计算表达式的机制之前，让我们看一些简单的示例，展示使用计算表达式前后相同的代码。
- en: 'Let''s start with a simple one. Let''s say we have some code, and we want to
    log each step. So we define a little logging function, and call it after every
    value is created, like so:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的开始。假设我们有一些代码，我们想要在每一步记录日志。所以我们定义一个小的记录函数，并在每个值创建后调用它，如下所示：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you run this, you will see the output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个，你会看到输出：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Simple enough.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 简单明了。
- en: But it is annoying to have to explicitly write all the log statements each time.
    Is there a way to hide them?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但是每次都要明确写出所有的日志语句很烦人。有没有办法隐藏它们？
- en: Funny you should ask... A computation expression can do that. Here's one that
    does exactly the same thing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你问得好...计算表达式可以做到这一点。这里有一个完全相同的做法。
- en: 'First we define a new type called `LoggingBuilder`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们定义一个名为`LoggingBuilder`的新类型：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Don''t worry about what the mysterious `Bind` and `Return` are for yet --
    they will be explained soon.*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在不要担心神秘的`Bind`和`Return`是用来做什么的--它们很快就会被解释清楚。*'
- en: Next we create an instance of the type, `logger` in this case.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们创建类型的一个实例，在这种情况下是`logger`。
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So with this `logger` value, we can rewrite the original logging example like
    this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所以有了这个`logger`值，我们可以像这样重写原始的日志示例：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you run this, you get exactly the same output, but you can see that the use
    of the `logger{...}` workflow has allowed us to hide the repetitive code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个，你会得到完全相同的输出，但你可以看到`logger{...}`工作流的使用使我们能够隐藏重复的代码。
- en: Safe division
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全除法
- en: Now let's look at an old chestnut.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个老生常谈。
- en: Say that we want to divide a series of numbers, one after another, but one of
    them might be zero. How can we handle it? Throwing an exception is ugly. Sounds
    like a good match for the `option` type though.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要依次除以一系列数字，但其中一个可能为零。我们该如何处理？抛出异常很丑陋。听起来很适合`option`类型。
- en: First we need to create a helper function that does the division and gives us
    back an `int option`. If everything is OK, we get a `Some` and if the division
    fails, we get a `None`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们需要创建一个帮助函数，它执行除法并返回一个`int option`。如果一切正常，我们得到一个`Some`，如果除法失败，我们得到一个`None`。
- en: Then we can chain the divisions together, and after each division we need to
    test whether it failed or not, and keep going only if it was successful.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将这些除法链接在一起，每次除法后我们需要测试它是否失败，只有在成功时才继续进行。
- en: 'Here''s the helper function first, and then the main workflow:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是帮助函数，然后是主要工作流：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that I have put the divisor first in the parameter list. This is so we
    can write an expression like `12 |> divideBy 3`, which makes chaining easier.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我已经在参数列表中首先放置了除数。这样我们就可以写出类似`12 |> divideBy 3`的表达式，这样链式调用更容易。
- en: 'Let''s put it to use. Here is a workflow that attempts to divide a starting
    number three times:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把它用起来。这里是一个尝试三次除以一个起始数字的工作流：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And here it is in use:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的使用方式：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `bad` workflow fails on the third step and returns `None` for the whole
    thing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`bad`工作流在第三步失败，并为整个事情返回`None`。'
- en: It is very important to note that the *entire workflow* has to return an `int
    option` as well. It can't just return an `int` because what would it evaluate
    to in the bad case? And can you see how the type that we used "inside" the workflow,
    the option type, has to be the same type that comes out finally at the end. Remember
    this point -- it will crop up again later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的一点是*整个工作流*也必须返回一个`int option`。它不能只返回一个`int`，因为在坏情况下它会评估为什么？你能看到我们在工作流中使用的类型“内部”类型，选项类型，必须是最终最终返回的相同类型。记住这一点--它以后会再次出现。
- en: Anyway, this continual testing and branching is really ugly! Does turning it
    into a computation expression help?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这种持续的测试和分支真的很丑陋！将其转换为计算表达式有帮助吗？
- en: Once more we define a new type (`MaybeBuilder`) and make an instance of the
    type (`maybe`).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 再次我们定义一个新类型（`MaybeBuilder`）并创建类型的一个实例（`maybe`）。
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I have called this one `MaybeBuilder` rather than `divideByBuilder` because
    the issue of dealing with option types this way, using a computation expression,
    is quite common, and `maybe` is the standard name for this thing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我将其称为`MaybeBuilder`而不是`divideByBuilder`，因为以这种方式处理选项类型的问题，使用计算表达式是相当常见的，而`maybe`是这个东西的标准名称。
- en: So now that we have defined the `maybe` workflow, let's rewrite the original
    code to use it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`maybe`工作流程，让我们重写原始代码以使用它。
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Much, much nicer. The `maybe` expression has completely hidden the branching
    logic!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 非常非常好。`maybe`表达式完全隐藏了分支逻辑！
- en: 'And if we test it we get the same result as before:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们测试它，我们会得到与之前相同的结果：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Chains of "or else" tests
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “否则”测试链
- en: In the previous example of "divide by", we only wanted to continue if each step
    was successful.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在“除以”之前的示例中，我们只想在每个步骤成功时继续。
- en: But sometimes it is the other way around. Sometimes the flow of control depends
    on a series of "or else" tests. Try one thing, and if that succeeds, you're done.
    Otherwise try another thing, and if that fails, try a third thing, and so on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时情况恰恰相反。有时控制流取决于一系列“否则”测试。尝试一件事情，如果成功，就完成了。否则尝试另一件事情，如果失败了，尝试第三件事情，依此类推。
- en: Let's look at a simple example. Say that we have three dictionaries and we want
    to find the value corresponding to a key. Each lookup might succeed or fail, so
    we need to chain the lookups in a series.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子。假设我们有三个字典，我们想找到与一个键对应的值。每次查找可能成功也可能失败，因此我们需要将查找链接成一个系列。
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because everything is an expression in F# we can't do an early return, we have
    to cascade all the tests in a single expression.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在F#中一切都是表达式，我们无法进行早期返回���我们必须在单个表达式中级联所有测试。
- en: 'Here''s how this might be used:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用的示例：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It works fine, but can it be simplified?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它运行良好，但能简化吗？
- en: 'Yes indeed. Here is an "or else" builder that allows us to simplify these kinds
    of lookups:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，确实。这是一个“否则”构建器，可以让我们简化这种查找：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s how the lookup code could be altered to use it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是查找代码如何修改以使用它的方式：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Again we can confirm that the code works as expected.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以确认代码按预期工作。
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Asynchronous calls with callbacks
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带回调的异步调用
- en: Finally, let's look at callbacks. The standard approach for doing asynchronous
    operations in .NET is to use a [AsyncCallback delegate](http://msdn.microsoft.com/en-us/library/ms228972.aspx)
    which gets called when the async operation is complete.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看回调。在.NET中进行异步操作的标准方法是使用[AsyncCallback委托](http://msdn.microsoft.com/en-us/library/ms228972.aspx)，当异步操作完成时调用它。
- en: 'Here is an example of how a web page might be downloaded using this technique:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用这种技术下载网页的示例：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Lots of calls to `BeginGetResponse` and `EndGetResponse`, and the use of nested
    lambdas, makes this quite complicated to understand. The important code (in this
    case, just print statements) is obscured by the callback logic.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 大量调用`BeginGetResponse`和`EndGetResponse`，以及嵌套lambda的使用，使得理解起来相当复杂。重要的代码（在这种情况下，只是打印语句）被回调逻辑所掩盖。
- en: In fact, managing this cascading approach is always a problem in code that requires
    a chain of callbacks; it has even been called the ["Pyramid of Doom"](http://raynos.github.com/presentation/shower/controlflow.htm?full#PyramidOfDoom)
    (although [none of the solutions are very elegant](http://adamghill.com/callbacks-considered-a-smell/),
    IMO).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在需要一系列回调链的代码中管理这种级联方法始终是一个问题；它甚至被称为["毁灭金字塔"](http://raynos.github.com/presentation/shower/controlflow.htm?full#PyramidOfDoom)（尽管在我看来[没有一个解决方案是非常优雅的](http://adamghill.com/callbacks-considered-a-smell/)）。
- en: Of course, we would never write that kind of code in F#, because F# has the
    `async` computation expression built in, which both simplifies the logic and flattens
    the code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们永远不会在F#中编写这种代码，因为F#内置了`async`计算表达式，这既简化了逻辑，又使代码扁平化。
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We'll see exactly how the `async` workflow is implemented later in this series.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将看到`async`工作流程是如何实现的。
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: So we've seen some very simple examples of computation expressions, both "before"
    and "after", and they are quite representative of the kinds of problems that computation
    expressions are useful for.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些非常简单的计算表达式示例，分别是“之前”和“之后”，它们相当代表了计算表达式适用于的问题类型。
- en: In the logging example, we wanted to perform some side-effect between each step.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在日志示例中，我们希望在每个步骤之间执行一些副作用。
- en: In the safe division example, we wanted to handle errors elegantly so that we
    could focus on the happy path.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在安全除法示例中，我们希望优雅地处理错误，以便我们可以专注于快乐路径。
- en: In the multiple dictionary lookup example, we wanted to return early with the
    first success.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多字典查找示例中，我们想要在第一次成功时提前返回。
- en: And finally, in the async example, we wanted to hide the use of callbacks and
    avoid the "pyramid of doom".
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在异步示例中，我们想要隐藏回调的使用并避免"地狱金字塔"。
- en: What all the cases have in common is that the computation expression is "doing
    something behind the scenes" between each expression.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些情况的共同点是计算表达式在每个表达式之间"在幕后做一些事情"。
- en: 'If you want a bad analogy, you can think of a computation expression as somewhat
    like a post-commit hook for SVN or git, or a database trigger that gets called
    on every update. And really, that''s all that a computation expression is: something
    that allows you to sneak your own code in to be called *in the background*, which
    in turn allows you to focus on the important code in the foreground.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个不太恰当的类比，你可以将计算表达式想象成类似于SVN或git的提交后钩子，或者在每次更新时调用的数据库触发器。实际上，计算表达式就是这样：允许你偷偷地插入自己的代码以便*在后台*被调用，从而让你专注于前台的重要代码。
- en: Why are they called "computation expressions"? Well, it's obviously some kind
    of expression, so that bit is obvious. I believe that the F# team did originally
    want to call it "expression-that-does-something-in-the-background-between-each-let"
    but for some reason, people thought that was a bit unwieldy, so they settled on
    the shorter name "computation expression" instead.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么称之为"计算表达式"？嗯，显然是某种表达式，所以这一点很明显。我相信F#团队最初确实想要称之为"在每个let之间做一些后台工作的表达式"，但出于某种原因，人们认为那有点笨拙，所以他们最终选择了更短的名字"计算表达式"。
- en: And as to the difference between a "computation expression" and a "workflow",
    I use *"computation expression"* to mean the `{...}` and `let!` syntax, and reserve
    *"workflow"* for particular implementations where appropriate. Not all computation
    expression implementations are workflows. For example, it is appropriate to talk
    about the "async workflow" or the "maybe workflow", but the "seq workflow" doesn't
    sound right.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 至于"计算表达式"和"工作流"之间的区别，我使用*"计算表达式"*来表示`{...}`和`let!`语法，而将*"工作流"*保留给特定的实现。并非所有的计算表达式实现都是工作流。例如，谈论"异步工作流"或"可能性工作流"是合适的，但"序列工作流"听起来不对。
- en: In other words, in the following code, I would say that `maybe` is the workflow
    we are using, and the particular chunk of code `{ let! a = .... return c }` is
    the computation expression.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在下面的代码中，我会说`maybe`是我们正在使用的工作流，而特定的代码块`{ let! a = .... return c }`是计算表达式。
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You probably want to start creating your own computation expressions now, but
    first we need to take a short detour into continuations. That's up next.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要开始创建自己的计算表达式了，但首先我们需要稍微偏离一下，进入延续。接下来就是这个。
- en: '*Update on 2015-01-11: I have removed the counting example that used a "state"
    computation expression. It was too confusing and distracted from the main concepts.*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*2015-01-11更新：我已经删除了使用"状态"计算表达式的计数示例。它太令人困惑，分散了主要概念的注意力。*'
- en: Understanding continuations
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解延续
- en: Understanding continuations
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解延续
- en: In the previous post we saw how some complex code could be condensed using computation
    expressions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇文章中，我们看到了如何使用计算表达式来简化一些复杂的代码。
- en: 'Here''s the code before using a computation expression:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用计算表达式之前的代码如下：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And here''s the same code after using a computation expression:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用计算表达式之后的同样代码如下：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The use of `let!` rather than a normal `let` is important. Can we emulate this
    ourselves so we can understand what is going on? Yes, but we need to understand
    continuations first.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let!`而不是普通的`let`很重要。我们能够自己模拟这个过程以便理解发生了什么吗？是的，但我们需要先理解延续。
- en: Continuations
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延续
- en: In imperative programming, we have the concept of "returning" from a function.
    When you call a function, you "go in", and then you "come out", just like pushing
    and popping a stack.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，我们有"从函数返回"的概念。当你调用一个函数时，你"进入"，然后你"出来"，就像推入和弹出栈一样。
- en: Here is some typical C# code which works like this. Notice the use of the `return`
    keyword.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些典型的C#代码，它的工作方式如此。请注意`return`关键字的使用。
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You''ve seen this a million times, but there is a subtle point about this approach
    that you might not have considered: *the called function always decides what to
    do*.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能见过这种情况无数次，但这种方法有一个微妙的地方你可能没有考虑到：*被调用的函数总是决定要做什么*。
- en: For example, the implemention of `Divide` has decided that it is going to throw
    an exception. But what if I don't want an exception? Maybe I want a `nullable<int>`,
    or maybe I am going to display it on a screen as "#DIV/0". Why throw an exception
    that I am immediately going to have to catch? In other words, why not let the
    *caller* decide what should happen, rather the callee.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Divide`的实现已经决定要抛出异常。但如果我不想要异常呢？也许我想要一个`nullable<int>`，或者我要在屏幕上显示为“#DIV/0”。为什么要抛出一个我立即要捕获的异常呢？换句话说，为什么不让*调用者*决定应该发生什么，而不是被调用者。
- en: Similarly in the `IsEven` example, what am I going to do with the boolean return
    value? Branch on it? Or maybe print it in a report? I don't know, but again, rather
    than returning a boolean that the caller has to deal with, why not let the caller
    tell the callee what to do next?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 同样在`IsEven`的例子中，我要怎么处理布尔返回值？根据它进行分支？或者在报告中打印它？我不知道，但是，与其返回一个布尔值让调用者处理，为什么不让调用者告诉被调用者接下来该做什么呢？
- en: So this is what continuations are. A **continuation** is simply a function that
    you pass into another function to tell it what to do next.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是延续。**延续**只是一个你传递给另一个函数的函数，告诉它接下来该做什么。
- en: Here's the same C# code rewritten to allow the caller to pass in functions which
    the callee uses to handle each case. If it helps, you can think of this as somewhat
    analogous to a visitor pattern. Or maybe not.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相同的C#代码重写，允许调用者传递函数，被调用者使用这些函数来处理每种情况。如果有帮助的话，你可以将其视为与访问者模式有些类似。或者也可能不是。
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that the C# functions have been changed to return a generic `T` now, and
    both continuations are a `Func` that returns a `T`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，C#函数现在已更改为返回通用的`T`，并且两个延续都是返回`T`的`Func`。
- en: Well, passing in lots of `Func` parameters always looks pretty ugly in C#, so
    it is not done very often. But passing functions is easy in F#, so let's see how
    this code ports over.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，在C#中传递许多`Func`参数看起来总是很丑陋，所以并不经常这样做。但在F#中传递函数很容易，所以让我们看看这段代码如何移植过来。
- en: 'Here''s the "before" code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是“之前”的代码：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'and here''s the "after" code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是“之后”的代码：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A few things to note. First, you can see that I have put the extra functions
    (`ifZero`, etc) *first* in the parameter list, rather than last, as in the C#
    example. Why? Because I am probably going to want to use [partial application](partial-application.html).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要注意。首先，你可以看到我将额外的函数（`ifZero`等）*放在*参数列表的第一位，而不是最后，就像C#示例中那样。为什么？因为我可能会想要使用[部分应用](partial-application.html)。
- en: And also, in the `isEven` example, I wrote `aNumber |> ifEven` and `aNumber
    |> ifOdd`. This makes it clear that we are piping the current value into the continuation
    and the continuation is always the very last step to be evaluated. *We will be
    using this exact same pattern later in this post, so make sure you understand
    what is going on here.*
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，在`isEven`的例子中，我写了`aNumber |> ifEven`和`aNumber |> ifOdd`。这清楚地表明我们正在将当前值传递给延续函数，而延续函数始终是最后要评估的步骤。*我们将在本文稍后使用完全相同的模式，所以确保你理解这里发生了什么。*
- en: Continuation examples
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 延续示例
- en: With the power of continuations at our disposal, we can use the same `divide`
    function in three completely different ways, depending on what the caller wants.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有了延续的强大功能，我们可以以三种完全不同的方式使用相同的`divide`函数，取决于调用者想要什么。
- en: 'Here are three scenarios we can create quickly:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三种我们可以快速创建的场景：
- en: pipe the result into a message and print it,
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果传递给消息并打印出来，
- en: convert the result to an option using `None` for the bad case and `Some` for
    the good case,
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果转换为一个选项，使用`None`表示糟糕的情况，使用`Some`表示好的情况，
- en: or throw an exception in the bad case and just return the result in the good
    case.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或在糟糕的情况下抛出异常，只在好的情况下返回结果。
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that with this approach, the caller *never* has to catch an exception
    from `divide` anywhere. The caller decides whether an exception will be thrown,
    not the callee. So not only has the `divide` function become much more reusable
    in different contexts, but the cyclomatic complexity has just dropped a level
    as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，采用这种方法，调用者*永远*不必在任何地方捕获`divide`的异常。调用者决定是否抛出异常，而不是被调用者。因此，`divide`函数不仅在不同的上下文中变得更具可重用性，而且圈复杂度也降低了一个级别。
- en: 'The same three scenarios can be applied to the `isEven` implementation:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的三种情况可以应用于`isEven`的实现：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this case, the benefits are subtler, but the same: the caller never had
    to handle booleans with an `if/then/else` anywhere. There is less complexity and
    less chance of error.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，好处更微妙，但相同：调用者从未在任何地方处理布尔值与`if/then/else`。复杂性更少，出错的机会更少。
- en: It might seem like a trivial difference, but by passing functions around like
    this, we can use all our favorite functional techniques such as composition, partial
    application, and so on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是微不足道的差异，但通过这样传递函数，我们可以使用所有我们喜欢的函数技术，如组合，部分应用等。
- en: We have also met continuations before, in the series on [designing with types](designing-with-types-single-case-dus.html).
    We saw that their use enabled the caller to decide what would happen in case of
    possible validation errors in a constructor, rather than just throwing an exception.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前也遇到过继续，在[设计类型](designing-with-types-single-case-dus.html)系列中。��们看到它们的使用使调用者能够决定在构造函数可能出现验证错误的情况下会发生什么，而不仅仅是抛出异常。
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The success function takes the email as a parameter and the error function takes
    a string. Both functions must return the same type, but the type is up to you.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 成功函数以电子邮件作为参数，错误函数以字符串作为参数。这两个函数必须返回相同类型，但类型由你决定。
- en: And here is a simple example of the continuations in use. Both functions do
    a printf, and return nothing (i.e. unit).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用继续的简单示例。两个函数都执行printf，并返回空（即单元）。
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Continuation passing style
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继续传递风格
- en: Using continuations like this leads to a style of programming called "[continuation
    passing style](http://en.wikipedia.org/wiki/Continuation-passing_style)" (or CPS),
    whereby *every* function is called with an extra "what to do next" function parameter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式的继续会导致一种称为"[继续传递风格](http://en.wikipedia.org/wiki/Continuation-passing_style)"（或CPS）的编程风格，其中*每个*函数都带有额外的"下一步该做什么"函数参数。
- en: To see the difference, let's look at the standard, direct style of programming.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到区别，让我们看看标准的直接编程风格。
- en: When you use the direct style, you go "in" and "out" of functions, like this
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用直接风格时，你会像这样"进入"和"退出"函数
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In continuation passing style, on the other hand, you end up with a chain of
    functions, like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在继续传递风格中，你最终会得到一系列函数，就像这样：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There is obviously a big difference between the two styles.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这两种风格之间有很大的区别。
- en: In the direct style, there is a hierarchy of functions. The top level function
    is a sort of "master controller" who calls one subroutine, and then another, deciding
    when to branch, when to loop, and generally coordinating the control flow explicitly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在直接风格中，有一系列函数的层次结构。顶层函数是一种"主控制器"，它调用一个子例程，然后另一个，决定何时分支，何时循环，并明确协调控制流。
- en: In the contination passing style, though, there is no "master controller". Instead
    there is a sort of "pipeline", not of data but of control flow, where the "function
    in charge" changes as the execution logic flows through the pipe.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在继续传递风格中，没有"主控制器"。相反，有一种"管道"，不是数据的管道，而是控制流的管道，在这个管道中，"负责的函数"随着执行逻辑流经管道而改变。
- en: If you have ever attached a event handler to a button click in a GUI, or used
    a callback with [BeginInvoke](http://msdn.microsoft.com/en-us/library/2e08f6yc.aspx),
    then you have used this style without being aware of it. And in fact, this style
    will be key to understanding the `async` workflow, which I'll discuss later in
    this series.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经在GUI中为按钮点击附加事件处理程序，或者在[BeginInvoke](http://msdn.microsoft.com/en-us/library/2e08f6yc.aspx)中使用回调，那么你已经使用了这种风格而不自知。实际上，这种风格将是理解`async`工作流的关键，我将在本系列中稍后讨论。
- en: Continuations and 'let'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续和'let'
- en: So how does all this fit in with `let`?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 那么所有这些如何与`let`结合？
- en: Let's go back and [revisit](let-use-do.html) what 'let` actually does.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下[let](let-use-do.html)实际上做了什么。
- en: Remember that a (non-top-level) "let" can never be used in isolation -- it must
    always be part of a larger code block.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，（非顶层）"let"永远不能单独使用--它必须始终是较大代码块的一部分。
- en: 'That is:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'really means:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 真正意味着：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And then every time you see the `x` in the second expression (the body expression),
    substitute it with the first expression (`someExpression`).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每次你在第二个表达式（主体表达式）中看到`x`时，用第一个表达式（`someExpression`）替换它。
- en: 'So for example, the expression:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所以例如，表达式：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'really means (using the verbose `in` keyword):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 真正意味着（使用冗长的`in`关键字）：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now funnily enough, a lambda looks very similar to a `let`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有趣的是，lambda看起来与`let`非常相似：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'and if we pipe in the value of `x` as well, we get the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们也将`x`的值传入，我们会得到以下结果：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Doesn''t this look awfully like a `let` to you? Here is a let and a lambda
    side by side:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很像`let`吗？这里是一个 let 和一个 lambda 并排：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: They both have an `x`, and a `someExpression`, and everywhere you see `x` in
    the body of the lambda you replace it with `someExpression`. Yes, the `x` and
    the `someExpression` are reversed in the lambda case, but otherwise it is basically
    the same thing as a `let`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都有一个`x`，和一个`someExpression`，在 lambda 的主体中每当你看到`x`时，你就将它替换为`someExpression`。是的，在
    lambda 情况下，`x`和`someExpression`是颠倒的，但除此之外，基本上与`let`是相同的。
- en: 'So, using this technique, we can rewrite the original example in this style:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用这种技术，我们可以以这种方式重写原始示例：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When it is written this way, you can see that we have transformed the `let`
    style into a continuation passing style!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当以这种方式写时，你会看到我们已经将`let`风格转换为 continuation 传递风格！
- en: In the first line we have a value `42` -- what do we want to do with it? Let's
    pass it into a continuation, just as we did with the `isEven` function earlier.
    And in the context of the continuation, we will relabel `42` as `x`.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一行中，我们有一个值`42`——我们想对它做什么？让我们像我们之前对`isEven`函数所做的那样，将其传递给 continuation。并且在 continuation
    的上下文中，我们将`42`重新标记为`x`。
- en: In the second line we have a value `43` -- what do we want to do with it? Let's
    pass it too into a continuation, calling it `y` in that context.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二行中，我们有一个值`43`——我们想对它做什么？让我们也将其传递到 continuation 中，在那个上下文中称之为`y`。
- en: In the third line we add the x and y together to create a new value. And what
    do we want to do with it? Another continuation, another label (`z`).
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三行中，我们将 x 和 y 相加以创建一个新值。我们想要做什么？另一个 continuation，另一个标签（`z`）。
- en: Finally in the last line we are done and the whole expression evaluates to `z`.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后在最后一行，我们完成了，整个表达式的求值结果是`z`。
- en: Wrapping the continuation in a function
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 continuation 包装在一个函数中
- en: Let's get rid of the explicit pipe and write a little function to wrap this
    logic. We can't call it "let" because that is a reserved word, and more importantly,
    the parameters are backwards from 'let'. The "x" is on the right hand side, and
    the "someExpression" is on the left hand side. So we'll call it `pipeInto` for
    now.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去掉显式的管道，并写一个小函数来包装这个逻辑。我们不能称其为“let”，因为那是一个保留字，而且更重要的是，参数与'let'相反。"x"在右侧，"someExpression"在左侧。所以我们现在叫它`pipeInto`。
- en: 'The definition of `pipeInto` is really obvious:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipeInto`的定义非常明显：'
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Note that we are passing both parameters in at once using a tuple rather than
    as two distinct parameters separated by whitespace. They will always come as a
    pair.*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，我们使用元组一次性传递了两个参数，而不是作为由空格分隔的两个不同参数。它们将始终成对出现。*'
- en: 'So, with this `pipeInto` function we can then rewrite the example once more
    as:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，有了这个`pipeInto`函数，我们可以再次将示例重写为：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'or we can eliminate the indents and write it like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以取消缩进，像这样写：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You might be thinking: so what? Why bother to wrap the pipe into a function?'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在想：那又怎样？为什么要将管道包装成一个函数？
- en: The answer is that we can add *extra code* in the `pipeInto` function to do
    stuff "behine the scenes", just as in a computation expression.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是我们可以在`pipeInto`函数中添加*额外的代码*来在“幕后”执行一些操作，就像在计算表达式中一样。
- en: The "logging" example revisited
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “日志记录”示例重访
- en: 'Let''s redefine `pipeInto` to add a little bit of logging, like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新定义`pipeInto`来添加一点日志记录，就像这样：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now... run that code again.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在... 再次运行那段代码。
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: What is the output?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是什么？
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is exactly the same output as we had in the earlier implementations. We
    have created our own little computation expression workflow!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前的实现完全相同的输出。我们创建了我们自己的小型计算表达式工作流！
- en: If we compare this side by side with the computation expression version, we
    can see that our homebrew version is very similar to the `let!`, except that we
    have the parameters reversed, and we have the explicit arrow for the continuation.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个与计算表达式版本并排比较，我们会发现我们的自制版本与`let!`非常相似，除了我们将参数颠倒了，而且我们为 continuation 明确地使用了箭头。
- en: '![computation expression: logging](compexpr_logging.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![计算表达式：日志记录](compexpr_logging.png)'
- en: The "safe divide" example revisited
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “安全除法”示例重访
- en: 'Let''s do the same thing with the "safe divide" example. Here was the original
    code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用“安全除法”示例做同样的事情。这是原始代码：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You should see now that this "stepped" style is an obvious clue that we really
    should be using continuations.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该看到，这种“分步”风格是一个明显的暗示，我们真的应该使用 continuation。
- en: 'Let''s see if we can add extra code to `pipeInto` to do the matching for us.
    The logic we want is:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看是否可以向 `pipeInto` 添加额外的代码来为我们进行匹配。我们想要的逻辑是：
- en: If the `someExpression` parameter is `None`, then don't call the continuation
    lambda.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `someExpression` parameter is `Some`, then do call the continuation lambda,
    passing in the contents of the `Some`.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here it is:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With this new version of `pipeInto` we can rewrite the original code like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can clean this up quite a bit.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'First we can eliminate the `a`, `b` and `c`, and replace them with the `divideBy`
    expression directly. So that this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'becomes just this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we can relabel `a''` as just `a`, and so on, and we can also remove the
    stepped indentation, so that we get this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, we''ll create a little helper function called `return''` to wrap the
    result in an option. Putting it all together, the code looks like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Again, if we compare this side by side with the computation expression version,
    we can see that our homebrew version is identical in meaning. Only the syntax
    is different.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![computation expression: logging](compexpr_safedivide.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this post, we talked about continuations and continuation passing style,
    and how we can think of `let` as a nice syntax for doing continuations behind
    scenes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: So now we have everything we need to start creating our *own* version of `let`.
    In the next post, we'll put this knowledge into practice.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Introducing 'bind'
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing 'bind'
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last post we talked about how we can think of `let` as a nice syntax
    for doing continuations behind scenes. And we introduced a `pipeInto` function
    that allowed us to add hooks into the continuation pipeline.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to look at our first builder method, `Bind`, which formalizes
    this approach and is the core of any computation expression.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Introducing "Bind "
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [MSDN page on computation expressions](http://msdn.microsoft.com/en-us/library/dd233182.aspx)
    describes the `let!` expression as syntactic sugar for a `Bind` method. Let''s
    look at this again:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `let!` expression documentation, along with a real example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'And here''s the `Bind` method documentation, along with a real example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Notice a few interesting things about this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '`Bind` takes two parameters, an expression (`43`) and a lambda.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameter of the lambda (`x`) is bound to the expression passed in as the
    first parameter. (In this case at least. More on this later.)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameters of `Bind` are reversed from the order they are in `let!`.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So in other words, if we chain a number of `let!` expressions together like
    this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'the compiler converts it to calls to `Bind`, like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: I think you can see where we are going with this by now.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, our `pipeInto` function is exactly the same as the `Bind` method.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a key insight: *computation expressions are just a way to create nice
    syntax for something that we could do ourselves*.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: A standalone bind function
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having a "bind" function like this is actually a standard functional pattern,
    and it is not dependent on computation expressions at all.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: First, why is it called "bind"? Well, as we've seen, a "bind" function or method
    can be thought of as feeding an input value to a function. This is known as "[binding](function-values-and-simple-values.html)"
    a value to the parameter of the function (recall that all functions have only
    [one parameter](currying.html)).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为什么称其为“bind”？嗯，正如我们所见，一个“bind”函数或方法可以被视为将输入值传递给函数。这被称为将值“[绑定](function-values-and-simple-values.html)”到函数的参数（回想一下，所有函数只有[一个参数](currying.html)）。
- en: So when you think of `bind` this this way, you can see that it is similar to
    piping or composition.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你这样考虑`bind`时，你会发现它类似于管道或组合。
- en: 'In fact, you can turn it into an infix operation like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以将其转换为中缀操作，如下所示：
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '*By the way, this symbol ">>=" is the standard way of writing bind as an infix
    operator. If you ever see it used in other F# code, that is probably what it represents.*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*顺便说一句，这个符号“>>=”是将`bind`写成中缀运算符���标准方式。如果你在其他 F# 代码中看到它被使用，那可能就是它的含义。*'
- en: 'Going back to the safe divide example, we can now write the workflow on one
    line, like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 回到安全除法示例，现在我们可以将工作流程写成一行，就像这样：
- en: '[PRE59]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You might be wondering exactly how this is different from normal piping or composition?
    It's not immediately obvious.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这与正常的管道或组合有什么不同？这并不是立即明显的。
- en: 'The answer is twofold:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是双重的：
- en: First, the `bind` function has *extra* customized behavior for each situation.
    It is not a generic function, like pipe or composition.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，`bind` 函数对每种情况都有*额外*的定制行为。它不是一个通用函数，像管道或组合那样。
- en: Second, the input type of the value parameter (`m` above) is not necessarily
    the same as the output type of the function parameter (`f` above), and so one
    of the things that bind does is handle this mismatch elegantly so that functions
    can be chained.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，值参数（上面的`m`）的输入类型不一定与函数参数（上面的`f`）的输出类型相同，因此`bind`的一项工作是优雅地处理这种不匹配，以便可以链接函数。
- en: As we will see in the next post, bind generally works with some "wrapper" type.
    The value parameter might be of `WrapperType<TypeA>`, and then the signature of
    the function parameter of `bind` function is always `TypeA -> WrapperType<TypeB>`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一篇文章中看到的，`bind`通常与某种“包装”类型一起使用。值参数可能是`WrapperType<TypeA>`，然后`bind`函数的函数参数的签名始终是`TypeA
    -> WrapperType<TypeB>`。
- en: In the particular case of the `bind` for safe divide, the wrapper type is `Option`.
    The type of the value parameter (`m` above) is `Option<int>` and the signature
    of the function parameter (`f` above) is `int -> Option<int>`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全除法的`bind`特定情况下，包装类型是`Option`。值参数（上面的`m`）的类型是`Option<int>`，函数参数（上面的`f`）的签名是`int
    -> Option<int>`。
- en: 'To see bind used in a different context, here is an example of the logging
    workflow expressed using a infix bind function:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看在不同上下文中使用`bind`，这里是使用中缀`bind`函数表达的日志记录工作流程的示例：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this case, there is no wrapper type. Everything is an `int`. But even so,
    `bind` has the special behavior that performs the logging behind the scenes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，没有包装类型。一切都是`int`。但即便如此，`bind` 有一个特殊的行为，可以在幕后执行日志记录。
- en: Option.bind and the "maybe" workflow revisited
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Option.bind 和“maybe”工作流程重访
- en: In the F# libraries, you will see `Bind` functions or methods in many places.
    Now you know what they are for!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 库中，你会在许多地方看到`Bind`函数或方法。现在你知道它们的用途了！
- en: A particularly useful one is `Option.bind`, which does exactly what we wrote
    by hand above, namely
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别有用的是`Option.bind`，它恰好做了我们手工编写的事情，即
- en: If the input parameter is `None`, then don't call the continuation function.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入参数是`None`，那么不要调用续延函数。
- en: If the input parameter is `Some`, then do call the continuation function, passing
    in the contents of the `Some`.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入参数是`Some`，那么调用续延函数，传入`Some`的内容。
- en: 'Here was our hand-crafted function:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们手工制作的函数：
- en: '[PRE61]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And here is the implementation of `Option.bind`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Option.bind`的实现：
- en: '[PRE62]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There is a moral in this -- don't be too hasty to write your own functions.
    There may well be library functions that you can reuse.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个道理--不要太急于编写自己的函数。很可能有可以重用的库函数。
- en: 'Here is the "maybe" workflow, rewritten to use `Option.bind`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这是“maybe”工作流程，重新编写以使用`Option.bind`：
- en: '[PRE63]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Reviewing the different approaches so far
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾迄今为止的不同方法
- en: We've used four different approaches for the "safe divide" example so far. Let's
    put them together side by side and compare them once more.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了四种不同的方法来处理“安全除法”示例。让我们将它们放在一起并再次进行比较。
- en: '*Note: I have renamed the original `pipeInto` function to `bind`, and used
    `Option.bind` instead of our original custom implementation.*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：我已将原始的`pipeInto`函数重命名为`bind`，并使用`Option.bind`代替我们原始的自定义实现。*'
- en: 'First the original version, using an explicit workflow:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是原始版本，使用显式工作流：
- en: '[PRE64]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Next, using our own version of "bind" (a.k.a. "pipeInto")
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用我们自己的版本的“bind”（又名“pipeInto”）
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, using a computation expression:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用计算表达式：
- en: '[PRE66]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'And finally, using bind as an infix operation:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将bind作为中缀操作使用：
- en: '[PRE67]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Bind functions turn out to be very powerful. In the next post we'll see that
    combining `bind` with wrapper types creates an elegant way of passing extra information
    around in the background.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Bind函数被证明是非常强大的。在下一篇文章中，我们将看到将`bind`与包装类型结合起来，创造了一种优雅的方式在后台传递额外的信息。
- en: 'Exercise: How well do you understand?'
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习：你对此了解如何？
- en: Before you move on to the next post, why don't you test yourself to see if you
    have understood everything so far?
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续下一篇文章之前，为什么不测试一下自己，看看你是否已经完全理解了？
- en: Here is a little exercise for you.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小练习给你。
- en: '**Part 1 - create a workflow**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一部分 - 创建工作流**'
- en: 'First, create a function that parses a string into a int:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个将字符串解析为整数的函数：
- en: '[PRE68]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: and then create your own computation expression builder class so that you can
    use it in a workflow, as shown below.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建你自己的计算表达式构建器类，这样你就可以在工作流中使用它，如下所示。
- en: '[PRE69]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '**Part 2 -- create a bind function**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二部分 - 创建一个bind函数**'
- en: 'Once you have the first part working, extend the idea by adding two more functions:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你让第一部分工作起来，通过添加另外两个函数来扩展这个想法：
- en: '[PRE70]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'And then with these functions, you should be able to write code like this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用这些函数，你应该能够编写类似这样的代码：
- en: '[PRE71]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'Here''s a summary of the points covered in this post:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本文中涵盖的要点总结：
- en: Computation expressions provide a nice syntax for continuation passing, hiding
    the chaining logic for us.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算表达式为我们提供了一个很好的语法，用于继续传递，为我们隐藏了链接逻辑。
- en: '`bind` is the key function that links the output of one step to the input of
    the next step.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bind`是将一个步骤的输出链接到下一个步骤的关键函数。'
- en: The symbol `>>=` is the standard way of writing bind as an infix operator.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号`>>=`是写bind作为中缀运算符的标准方式。
- en: Computation expressions and wrapper types
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算表达式和包装类型
- en: Computation expressions and wrapper types
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算表达式和包装类型
- en: In the previous post, we were introduced to the "maybe" workflow, which allowed
    us to hide the messiness of chaining together option types.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇文章中，我们介绍了“maybe”工作流，它允许我们隐藏将选项类型链接在一起的混乱。
- en: 'A typical use of the "maybe" workflow looked something like this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: “maybe”工作流的典型用法看起来像这样：
- en: '[PRE72]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As we saw before, there is some apparently strange behavior going on here:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，这里发生了一些明显奇怪的行为：
- en: In the `let!` lines, the expression on the *right* of the equals is an `int
    option`, but the value on the *left* is just an `int`. The `let!` has "unwrapped"
    the option before binding it to the value.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`let!`行中，等号右侧的表达式是一个`int option`，但左侧的值只是一个`int`。在绑定值之前，`let!`已经“展开”了选项。
- en: And in the `return` line, the opposite occurs. The expression being returned
    is an `int`, but the value of the whole workflow (`result`) is an `int option`.
    That is, the `return` has "wrapped" the raw value back into an option.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`return`行中，相反的情况发生。被返回的表达式是一个`int`，但整个工作流的值（`result`）是���个`int option`。也就是说，`return`已经将原始值“包装”回一个选项中。
- en: 'We will follow up these observations in this post, and we will see that this
    leads to one of the major uses of computation expressions: namely, to implicitly
    unwrap and rewrap values that are stored in some sort of wrapper type.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本文中跟进这些观察结果，并且我们将看到这导致了计算表达式的主要用途之一：即，隐式解包和重新包装存储在某种包装类型中的值。
- en: Another example
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一个例子
- en: 'Let''s look at another example. Say that we are accessing a database, and we
    want to capture the result in a Success/Error union type, like this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。假设我们正在访问数据库，并且我们想要将结果捕获在一个Success/Error联合类型中，就像这样：
- en: '[PRE73]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We then use this type in our database access methods. Here are some very simple
    stubs to give you an idea of how the `DbResult` type might be used:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在我们的数据库访问方法中使用这种类型。以下是一些非常简单的存根，让你了解`DbResult`类型可能如何使用：
- en: '[PRE74]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now let's say we want to chain these calls together. First get the customer
    id from the name, and then get the order for the customer id, and then get the
    product from the order.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要将这些调用链接在一起。首先从名称获取客户ID，然后从客户ID获取订单，然后从订单获取产品。
- en: Here's the most explicit way of doing it. As you can see, we have to have pattern
    matching at each step.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Really ugly code. And the top-level flow has been submerged in the error handling
    logic.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Computation expressions to the rescue! We can write one that handles the branching
    of Success/Error behind the scenes:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'And with this workflow, we can focus on the big picture and write much cleaner
    code:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'And if there are errors, the workflow traps them nicely and tells us where
    the error was, as in this example below:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The role of wrapper types in workflows
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So now we have seen two workflows (the `maybe` workflow and the `dbresult` workflow),
    each with their own corresponding wrapper type (`Option<T>` and `DbResult<T>`
    respectively).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: These are not just special cases. In fact, *every* computation expression *must*
    have an associated wrapper type. And the wrapper type is often designed specifically
    to go hand-in-hand with the workflow that we want to manage.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: The example above demonstrates this clearly. The `DbResult` type we created
    is more than just a simple type for return values; it actually has a critical
    role in the workflow by "storing" the current state of the workflow, and whether
    it is succeeding or failing at each step. By using the various cases of the type
    itself, the `dbresult` workflow can manage the transitions for us, hiding them
    from view and enabling us to focus on the big picture.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn how to design a good wrapper type later in the series, but first
    let's look at how they are manipulated.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Bind and Return and wrapper types
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look again at the definition of the `Bind` and `Return` methods of a computation
    expression.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start off with the easy one, `Return`. The signature of `Return` [as
    documented on MSDN](http://msdn.microsoft.com/en-us/library/dd233182.aspx) is
    just this:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In other words, for some type `T`, the `Return` method just wraps it in the
    wrapper type.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: In signatures, the wrapper type is normally called `M`, so `M<int>`
    is the wrapper type applied to `int` and `M<string>` is the wrapper type applied
    to `string`, and so on.*'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: And we've seen two examples of this usage. The `maybe` workflow returns a `Some`,
    which is an option type, and the `dbresult` workflow returns `Success`, which
    is part of the `DbResult` type.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now let''s look at `Bind`. The signature of `Bind` is this:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: It looks complicated, so let's break it down. It takes a tuple `M<'T> * ('T
    -> M<'U>)` and returns a `M<'U>`, where `M<'U>` means the wrapper type applied
    to type `U`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'The tuple in turn has two parts:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '`M<''T>` is a wrapper around type `T`, and'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''T -> M<''U>` is a function that takes a *unwrapped* `T` and creates a *wrapped*
    `U`.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words, what `Bind` does is:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Take a *wrapped* value.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unwrap it and do any special "behind the scenes" logic.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, optionally apply the function to the *unwrapped* value to create a new
    *wrapped* value.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if the function is *not* applied, `Bind` must still return a *wrapped*
    `U`.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this understanding, here are the `Bind` methods that we have seen already:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个理解，这里是我们已经看到的`Bind`方法：
- en: '[PRE82]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Look over this code and make sure that you understand why these methods do indeed
    follow the pattern described above.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看这段代码，确保你理解为什么这些方法确实遵循上面描述的模式。
- en: 'Finally, a picture is always useful. Here is a diagram of the various types
    and functions:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，图片总是有用的。这是各种类型和函数的图表：
- en: '![diagram of bind](bind.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![绑定的图表](bind.png)'
- en: For `Bind`, we start with a wrapped value (`m` here), unwrap it to a raw value
    of type `T`, and then (maybe) apply the function `f` to it to get a wrapped value
    of type `U`.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`Bind`，我们从一个包装值（这里是`m`）开始，将其解包为类型`T`的原始值，然后（可能）应用函数`f`到它，以获得类型`U`的包装值。
- en: For `Return`, we start with a value (`x` here), and simply wrap it.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`Return`，我们从一个值（这里是`x`）开始，然后简单地包装它。
- en: The type wrapper is generic
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型包装是泛型的
- en: Note that all the functions use generic types (`T` and `U`) other than the wrapper
    type itself, which must be the same throughout. For example, there is nothing
    stopping the `maybe` binding function from taking an `int` and returning a `Option<string>`,
    or taking a `string` and then returning an `Option<bool>`. The only requirement
    is that it always return an `Option<something>`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有函数都使用泛型类型（`T`和`U`），除了包装类型本身，它必须始终保持一致。例如，没有任何限制`maybe`绑定函数接受一个`int`并返回一个`Option<string>`，或者接受一个`string`然后返回一个`Option<bool>`。唯一的要求是它始终返回一个`Option<something>`。
- en: To see this, we can revisit the example above, but rather than using strings
    everywhere, we will create special types for the customer id, order id, and product
    id. This means that each step in the chain will be using a different type.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这一点，我们可以重新审视上面的例子，但是不是到处都使用字符串，而是为客户ID、订单ID和产品ID创建特殊类型。这意味着链中的每个步骤将使用不同的类型。
- en: We'll start with the types again, this time defining `CustomerId`, etc.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次从类型开始，这次定义`CustomerId`等。
- en: '[PRE83]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The code is almost identical, except for the use of the new types in the `Success`
    line.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 代码几乎相同，只是在`Success`行中使用了新类型。
- en: '[PRE84]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Here's the long-winded version again.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是冗长版本。
- en: '[PRE85]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'There are a couple of changes worth discussing:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个值得讨论的变化：
- en: First, the `printfn` at the bottom uses the "%A" format specifier rather than
    "%s". This is required because the `ProductId` type is a union type now.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，底部的`printfn`使用"%A"格式说明符而不是"%s"。这是因为`ProductId`类型现在是一个联合类型。
- en: More subtly, there seems to be unnecessary code in the error lines. Why write
    `| Error e -> Error e`? The reason is that the incoming error that is being matched
    against is of type `DbResult<CustomerId>` or `DbResult<OrderId>`, but the *return*
    value must be of type `DbResult<ProductId>`. So, even though the two `Error`s
    look the same, they are actually of different types.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更微妙的是，错误行中似乎有不必要的代码。为什么要写`| Error e -> Error e`？原因是被匹配的传入错误是`DbResult<CustomerId>`或`DbResult<OrderId>`类型，但*返回*值必须是`DbResult<ProductId>`类型。因此，即使这两个`Error`看起来相同，它们实际上是不同类型的。
- en: Next up, the builder, which hasn't changed at all except for the `| Error e
    -> Error e` line.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是构建器，除了`| Error e -> Error e`行之外，一切都没有改变。
- en: '[PRE86]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Finally, we can use the workflow as before.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以像以前一样使用工作流。
- en: '[PRE87]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: At each line, the returned value is of a *different* type (`DbResult<CustomerId>`,`DbResult<OrderId>`,
    etc), but because they have the same wrapper type in common, the bind works as
    expected.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一行，返回的值是*不同*类型的（`DbResult<CustomerId>`，`DbResult<OrderId>`等），但因为它们有一个共同的相同包装类型，绑定按预期工作。
- en: And finally, here's the workflow with an error case.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是带有错误情况的工作流。
- en: '[PRE88]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Composition of computation expressions
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算表达式的组合
- en: 'We''ve seen that every computation expression *must* have an associated wrapper
    type. This wrapper type is used in both `Bind` and `Return`, which leads to a
    key benefit:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到每个计算表达式*必须*有一个关联的包装类型。这个包装类型在`Bind`和`Return`中都被使用，这���来了一个关键的好处：
- en: '*the output of a `Return` can be fed to the input of a `Bind`*'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`Return`的输出可以作为`Bind`的输入*'
- en: In other words, because a workflow returns a wrapper type, and because `let!`
    consumes a wrapper type, you can put a "child" workflow on the right hand side
    of a `let!` expression.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，因为工作流返回一个包装类型，而`let!`消耗一个包装类型，你可以将一个“子”工作流放在`let!`表达式的右侧。
- en: 'For example, say that you have a workflow called `myworkflow`. Then you can
    write the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个名为`myworkflow`的工作流。然后你可以写下以下内容：
- en: '[PRE89]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Or you can even "inline" them, like this:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你甚至可以像这样“内联”它们：
- en: '[PRE90]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'If you have used the `async` workflow, you probably have done this already,
    because an async workflow typically contains other asyncs embedded in it:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用过`async`工作流程，你可能已经这样做了，因为`async`工作流程通常包含嵌套的其他asyncs：
- en: '[PRE91]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Introducing "ReturnFrom"
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入“ReturnFrom”
- en: We have been using `return` as a way of easily wrapping up an unwrapped return
    value.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用`return`作为一种轻松包装未包装返回值的方式。
- en: But sometimes we have a function that already returns a wrapped value, and we
    want to return it directly. `return` is no good for this, because it requires
    an unwrapped type as input.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时我们有一个已经返回包装值的函数，并且我们想直接返回它。`return`对此无济于事，因为它需要一个未包装类型作为输入。
- en: The solution is a variant on `return` called `return!`, which takes a *wrapped
    type* as input and returns it.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是`return`的一个变体称为`return!`，它接受一个*包装类型*作为输入并返回它。
- en: The corresponding method in the "builder" class is called `ReturnFrom`. Typically
    the implementation just returns the wrapped type "as is" (although of course,
    you can always add extra logic behind the scenes).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: “builder”类中对应的方法称为`ReturnFrom`。通常情况下，实现只是直接返回包装类型“原样”（尽管当然，你总是可以在幕后添加额外的逻辑）。
- en: 'Here is a variant on the "maybe" workflow to show how it can be used:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是“maybe”工作流程的一个变体，展示了它如何被使用：
- en: '[PRE92]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: And here it is in use, compared with a normal `return`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这是它的使用方式，与普通的`return`进行比较。
- en: '[PRE93]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'For a more realistic example, here is `return!` used in conjunction with `divideBy`:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 举个更实际的例子，这里是`return!`与`divideBy`一起使用：
- en: '[PRE94]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Summary
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: This post introduced wrapper types and how they related to `Bind`, `Return`
    and `ReturnFrom`, the core methods of any builder class.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 本文介绍了包装类型及其与`Bind`、`Return`和`ReturnFrom`的关系，这是任何构建器类的核心方法。
- en: In the next post, we'll continue to look at wrapper types, including using lists
    as wrapper types.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一篇文章中，我们将继续探讨包装类型，包括使用列表作为包装类型。
- en: More on wrapper types
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于包装类型的内容
- en: More on wrapper types
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于包装类型的内容
- en: In the previous post, we looked at the concept of "wrapper types" and their
    relation to computation expressions. In this post, we'll investigate what types
    are suitable for being wrapper types.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇文章中，我们讨论了“包装类型”的概念及其与计算表达式的关系。在本文中，我们将研究哪些类型适合作为包装类型。
- en: What kinds of types can be wrapper types?
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么类型可以作为包装类型？
- en: If every computation expression must have an associated wrapper type, then what
    kinds of type can be used as wrapper types? Are there any special constraints
    or limitations that apply?
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个计算表达式必须有一个关联的包装类型，那么可以用什么类型作为包装类型？是否有任何特殊的约束或限制适用？
- en: 'There is one general rule, which is:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个通用规则，即：
- en: '**Any type with a generic parameter can be used as a wrapper type**'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任何带有泛型参数的类型都可以作为包装类型**'
- en: So for example, you can use `Option<T>`, `DbResult<T>`, etc., as wrapper types,
    as we have seen. And you can use wrapper types that restrict the type parameter,
    such as `Vector<int>`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 所以例如，你可以使用`Option<T>`，`DbResult<T>`等作为包装类型，正如我们所见。你还可以使用限制类型参数的包装类型，比如`Vector<int>`。
- en: But what about other generic types like `List<T>` or `IEnumerable<T>`? Surely
    they can't be used? Actually, yes, they *can* be used! We'll see how shortly.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 但是其他泛型类型如`List<T>`或`IEnumerable<T>`呢？它们肯定不能被使用吧？实际上，是的，它们*可以*被使用！我们很快就会看到。
- en: Can non-generic wrapper types work?
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非泛型包装类型能够工作吗？
- en: Is it possible to use a wrapper type that does *not* have a generic parameter?
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 是否可以使用一个不带泛型参数的包装类型？
- en: 'For example, we saw in an earlier example an attempt to do addition on strings,
    like this: `"1" + "2"`. Can''t we be clever and treat `string` as a wrapper type
    for `int` in this case? That would be cool, yes?'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们在早前的一个例子中看到了尝试对字符串进行加法操作，就像这样：`"1" + "2"`。我们不能聪明地将`string`在这种情况下视为`int`的包装类型吗？那将很酷，对吧？
- en: Let's try. We can use the signatures of `Bind` and `Return` to guide our implementation.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试。我们可以使用`Bind`和`Return`的签名来指导我们的实现。
- en: '`Bind` takes a tuple. The first part of the tuple is the wrapped type (`string`
    in this case), and the second part of the tuple is a function that takes an unwrapped
    type and converts it to a wrapped type. In this case, that would be `int -> string`.'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bind`接受一个元组。元组的第一部分是包装类型（在本例中为`string`），元组的第二部分是一个接受未包装类型并将其转换为包装类型的函数。在这种情况下，那将是`int
    -> string`。'
- en: '`Return` takes an unwrapped type (`int` in this case) and converts it to a
    wrapped type. So in this case, the signature of `Return` would be `int -> string`.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Return`接受一个未包装类型（在本例中为`int`）并将其转换为包装类型。所以在这种情况下，`Return`的签名将是`int -> string`。'
- en: How does this guide the implementation?
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何指导实现？
- en: The implementation of the "rewrapping" function, `int -> string`, is easy. It
    is just "toString" on an int.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bind function has to unwrap a string to an int, and then pass it to the
    function. We can use `int.Parse` for that.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But what happens if the bind function *can't* unwrap a string, because it is
    not a valid number? In this case, the bind function *must* still return a wrapped
    type (a string), so we can just return a string such as "error".
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the implementation of the builder class:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now we can try using it:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: And what happens if one of the strings is invalid?
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: That looks really good -- we can treat strings as ints inside our workflow!
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: But hold on, there is a problem.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we give the workflow an input, unwrap it (with `let!`) and then immediately
    rewrap it (with `return`) without doing anything else. What should happen?
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: No problem. The input `g1` and the output `g2` are the same value, as we would
    expect.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: But what about the error case?
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: In this case we have got some unexpected behavior. The input `b1` and the output
    `b2` are *not* the same value. We have introduced an inconsistency.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Would this be a problem in practice? I don't know. But I would avoid it and
    use a different approach, like options, that are consistent in all cases.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: Rules for workflows that use wrapper types
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here's a question? What is the difference between these two code fragments,
    and should they behave differently?
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The answer is no, they should not behave differently. The only difference is
    that in the second example, the `unwrapped` value has been refactored away and
    the `wrapped` value is returned directly.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'But as we just saw in the previous section, you can get inconsistencies if
    you are not careful. So, any implementation you create should be sure to follow
    some standard rules, which are:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1: If you start with an unwrapped value, and then you wrap it (using
    `return`), then unwrap it (using `bind`), you should always get back the original
    unwrapped value.**'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: This rule and the next are about not losing information as you wrap and unwrap
    the values. Obviously, a sensible thing to ask, and required for refactoring to
    work as expected.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'In code, this would be expressed as something like this:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '**Rule 2: If you start with a wrapped value, and then you unwrap it (using
    `bind`), then wrap it (using `return`), you should always get back the original
    wrapped value.**'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: This is the rule that the `stringInt` workflow broke above. As with rule 1,
    this should obviously be a requirement.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'In code, this would be expressed as something like this:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '**Rule 3: If you create a child workflow, it must produce the same result as
    if you had "inlined" the logic in the main workflow.**'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: This rule is required for composition to behave properly, and again, "extraction"
    refactoring will only work correctly if this is true.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: In general, you will get this for free if you follow some guidelines (which
    will be explained in a later post).
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'In code, this would be expressed as something like this:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Lists as wrapper types
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I said earlier that types like `List<T>` or `IEnumerable<T>` can be used as
    wrapper types. But how can this be? There is no one-to-one correspondence between
    the wrapper type and the unwrapped type!
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: This is where the "wrapper type" analogy becomes a bit misleading. Instead,
    let's go back to thinking of `bind` as a way of connecting the output of one expression
    with the input of another.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, the `bind` function "unwraps" the type, and applies the continuation
    function to the unwrapped value. But there is nothing in the definition that says
    that there has to be only *one* unwrapped value. There is no reason that we can't
    apply the continuation function to each item of the list in turn.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, we should be able to write a `bind` that takes a list and a
    continuation function, where the continuation function processes one element at
    a time, like this:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'And with this concept, we should be able to chain some binds together like
    this:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: But we've missed something important. The continuation function passed into
    `bind` is required to have a certain signature. It takes an unwrapped type, but
    it produces a *wrapped* type.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the continuation function must *always create a new list* as
    its result.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'And the chained example would have to be written like this, with the `elem1
    + elem2` result turned into a list:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'So the logic for our bind method now looks like this:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: We have another issue now. `Bind` itself must produce a wrapped type, which
    means that the "list of lists" is no good. We need to turn them back into a simple
    "one-level" list.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: But that is easy enough -- there is a list module function that does just that,
    called `concat`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'So putting it together, we have this:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Now that we understand how the `bind` works on its own, we can create a "list
    workflow".
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '`Bind` applies the continuation function to each element of the passed in list,
    and then flattens the resulting list of lists into a one-level list. `List.collect`
    is a library function that does exactly that.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Return` converts from unwrapped to wrapped. In this case, that just means
    wrapping a single element in a list.'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Here is the workflow in use:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'And the results show that every element in the first collection has been combined
    with every element in the second collection:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: That's quite amazing really. We have completely hidden the list enumeration
    logic, leaving just the workflow itself.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Syntactic sugar for "for"
  id: totrans-493
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we treat lists and sequences as a special case, we can add some nice syntactic
    sugar to replace `let!` with something a bit more natural.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 'What we can do is replace the `let!` with a `for..in..do` expression:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Both variants mean exactly the same thing, they just look different.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: To enable the F# compiler to do this, we need to add a `For` method to our builder
    class. It generally has exactly the same implementation as the normal `Bind` method,
    but is required to accept a sequence type.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'And here is how it is used:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: LINQ and the "list workflow"
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Does the `for element in collection do` look familiar? It is very close to the
    `from element in collection ...` syntax used by LINQ. And indeed LINQ uses basically
    the same technique to convert from a query expression syntax like `from element
    in collection ...` to actual method calls behine the scenes.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: In F#, as we saw, the `bind` uses the `List.collect` function. The equivalent
    of `List.collect` in LINQ is the `SelectMany` extension method. And once you understand
    how `SelectMany` works, you can implement the same kinds of queries yourself.
    Jon Skeet has written a [helpful blog post](http://codeblog.jonskeet.uk/2010/12/27/reimplementing-linq-to-objects-part-9-selectmany/)
    explaining this.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: The identity "wrapper type"
  id: totrans-505
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So we've seen a number of wrapper types in this post, and have said that *every*
    computation expression *must* have an associated wrapper type.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: But what about the logging example in the previous post? There was no wrapper
    type there. There was a `let!` that did things behind the scenes, but the input
    type was the same as the output type. The type was left unchanged.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: The short answer to this is that you can treat any type as its own "wrapper".
    But there is another, deeper way to understand this.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Let's step back and consider what a wrapper type definition like `List<T>` really
    means.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: If you have a type such as `List<T>`, it is in fact not a "real" type at all.
    `List<int>` is a real type, and `List<string>` is a real type. But `List<T>` on
    its own is incomplete. It is missing the parameter it needs to become a real type.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: One way to think about `List<T>` is that it is a *function*, not a type. It
    is a function in the abstract world of types, rather than the concrete world of
    normal values, but just like any function it maps values to other values, except
    in this case, the input values are types (say `int` or `string`) and the output
    values are other types (`List<int>` and `List<string>`). And like any function
    it takes a parameter, in this case a "type parameter". Which is why the concept
    that .NET developers call "generics" is known as "[parametric polymorphism](http://en.wikipedia.org/wiki/Parametric_polymorphism)"
    in computer science terminology.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Once we grasp the concept of functions that generate one type from another type
    (called "type constructors"), we can see that what we really mean by a "wrapper
    type" is just a type constructor.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: But if a "wrapper type" is just a function that maps one type to another type,
    surely a function that maps a type to the *same* type fits into this category?
    And indeed it does. The "identity" function for types fits our definition and
    can be used as a wrapper type for computation expressions.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: Going back to some real code then, we can define the "identity workflow" as
    the simplest possible implementation of a workflow builder.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: With this in place, you can see that the logging example discussed earlier is
    just the identity workflow with some logging added in.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another long post, and we covered a lot of topics, but I hope that the role
    of wrapper types is now clearer. We will see how the wrapper types can be used
    in practice when we come to look at common workflows such as the "writer workflow"
    and the "state workflow" later in this series.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a summary of the points covered in this post:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: A major use of computation expressions is to unwrap and rewrap values that are
    stored in some sort of wrapper type.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can easily compose computation expressions, because the output of a `Return`
    can be fed to the input of a `Bind`.
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every computation expression *must* have an associated wrapper type.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any type with a generic parameter can be used as a wrapper type, even lists.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When creating workflows, you should ensure that your implementation conforms
    to the three sensible rules about wrapping and unwrapping and composition.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implementing a builder: Zero and Yield'
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing a builder: Zero and Yield'
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having covered bind and continuations, and the use of wrapper types, we're finally
    ready to take on the full set of methods associated with "builder" classes.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the [MSDN documentation](http://msdn.microsoft.com/en-us/library/dd233182.aspx),
    you'll see not just `Bind` and `Return`, but also other strangely named methods
    like `Delay` and `Zero`. What are *they* for? That's what this and the next few
    posts will answer.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: The plan of action
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate how to create a builder class, we will create a custom workflow
    which uses all of the possible builder methods.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: But rather than starting at the top and trying to explain what these methods
    mean without context, we'll work from the bottom up, starting with a simple workflow
    and adding methods only as needed to solve a problem or an error. In the process,
    you'll come to understand how F# processes computation expressions in detail.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: 'The outline of this process is:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 1: In this first part, we''ll look at what methods are needed for a basic
    workflow. We''ll introduce `Zero`, `Yield`, `Combine` and `For`.'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Next, we''ll look at how to delay the execution of your code, so that
    it is only evaluated when needed. We''ll introduce `Delay` and `Run`, and look
    at lazy computations.'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Finally, we''ll cover the rest of the methods: `While`, `Using`, and
    exception handling.'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we get started
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we dive into creating the workflow, here are some general comments.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: The documentation for computation expressions
  id: totrans-538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, as you might have noticed, the MSDN documentation for computation expressions
    is meagre at best, and although not inaccurate, can be misleading. For example,
    the signatures of the builder methods are *more* flexible than they appear to
    be, and this can be used to implement some features that might not be obvious
    if you work from the documentation alone. We will show an example of this later.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: If you want more detailed documentation, there are two sources I can recommend.
    For an detailed overview of the concepts behind computation expressions, a great
    resource is the [paper "The F# Expression Zoo" by Tomas Petricek and Don Syme](http://tomasp.net/academic/papers/computation-zoo/computation-zoo.pdf).
    And for the most accurate up-to-date technical documentation, you should read
    the [F# language specification](http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/spec.pdf),
    which has a section on computation expressions.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: Wrapped and unwrapped types
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you are trying to understand the signatures as documented, remember that
    what I have been calling the "unwrapped" type is normally written as `'T` and
    the "wrapped" type is normally written `M<'T>`. That is, when you see that the
    `Return` method has the signature `'T -> M<'T>` it means `Return` takes an unwrapped
    type and returns a wrapped type.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: As I have in the earlier posts in this series, I will continue to use "unwrapped"
    and "wrapped" to describe the relationship between these types, but as we move
    forward these terms will be stretched to the breaking point, so I will also start
    using other terminology, such as "computation type" instead of "wrapped type".
    I hope that when we reach this point, the reason for the change will be clear
    and understandable.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in my examples, I will generally try to keep things simple by using code
    such as:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: But this is actually an oversimplification. To be precise, the "x" can be any
    *pattern* not just a single value, and the "wrapped type" value can, of course,
    be an *expression* that evaluates to a wrapped type. The MSDN documentation uses
    this more precise approach. It uses "pattern" and "expression" in the definitions,
    such as `let! pattern = expr in cexpr`.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of using patterns and expressions in a `maybe` computation
    expression, where `Option` is the wrapped type, and the right hand side expressions
    are `options`:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Having said this, I will continue to use the oversimplified examples, so as
    not to add extra complication to an already complicated topic!
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: Implementing special methods in the builder class (or not)
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MSDN documentation shows that each special operation (such as `for..in`,
    or `yield`) is translated into one or more calls to methods in the builder class.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: There is not always a one-to-one correspondence, but generally, to support the
    syntax for a special operation, you *must* implement a corresponding method in
    the builder class, otherwise the compiler will complain and give you an error.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you do *not* need to implement every single method if you
    don't need the syntax. For example, we have already implemented the `maybe` workflow
    quite nicely by only implementing the two methods `Bind` and `Return`. We don't
    need to implement `Delay`, `Use`, and so on, if we don't need to use them.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what happens if you have not implemented a method, let''s try to use
    the `for..in..do` syntax in our `maybe` workflow like this:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'We will get the compiler error:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Sometimes you get will errors that might be cryptic unless you know what is
    going on behind the scenes. For example, if you forget to put `return` in your
    workflow, like this:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'You will get the compiler error:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'You might be asking: what is the `Zero` method? And why do I need it? The answer
    to that is coming right up.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: Operations with and without '!'
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Obviously, many of the special operations come in pairs, with and without a
    "!" symbol. For example: `let` and `let!` (pronounced "let-bang"), `return` and
    `return!`, `yield` and `yield!` and so on.'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: The difference is easy to remember when you realize that the operations *without*
    a "!" always have *unwrapped* types on the right hand side, while the ones *with*
    a "!" always have *wrapped* types.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: 'So for example, using the `maybe` workflow, where `Option` is the wrapped type,
    we can compare the different syntaxes:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The "!" versions are particularly important for composition, because the wrapped
    type can be the result of *another* computation expression of the same type.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Diving in - creating a minimal implementation of a workflow
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start! We'll begin by creating a minimal version of the "maybe" workflow
    (which we'll rename as "trace") with every method instrumented, so we can see
    what is going on. We'll use this as our testbed throughout this post.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code for the first version of the `trace` workflow:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Nothing new here, I hope. We have already seen all these methods before.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s run some sample code through it:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Everything should work as expected, in particular, you should be able to see
    that the use of `None` in the 4th example caused the next two lines (`let! y =
    ... return x+y`) to be skipped and the result of the whole expression was `None`.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: Introducing "do!"
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our expression supports `let!`, but what about `do!`?
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: In normal F#, `do` is just like `let`, except that the expression doesn't return
    anything useful (namely, a unit value).
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: Inside a computation expression, `do!` is very similar. Just as `let!` passes
    a wrapped result to the `Bind` method, so does `do!`, except that in the case
    of `do!` the "result" is the unit value, and so a *wrapped* version of unit is
    passed to the bind method.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple demonstration using the `trace` workflow:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Here is the output:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: You can verify for yourself that a `unit option` is being passed to `Bind` as
    a result of each `do!`.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: Introducing "Zero"
  id: totrans-587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What is the smallest computation expression you can get away with? Let''s try
    nothing at all:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'We get an error immediately:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Fair enough. If you think about it, it doesn't make sense to have nothing at
    all in a computation expression. After all, it's purpose is to chain expressions
    together.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Next, what about a simple expression with no `let!` or `return`?
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Now we get a different error:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: So why is the `Zero` method needed now but we haven't needed it before? The
    answer is that in this particular case we haven't returned anything explicitly,
    yet the computation expression as a whole *must* return a wrapped value. So what
    value should it return?
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this situation will occur any time the return value of the computation
    expression has not been explicitly given. The same thing happens if you have an
    `if..then` expression without an else clause.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: In normal F# code, an "if..then" without an "else" would result in a unit value,
    but in a computation expression, the particular return value must be a member
    of the wrapped type, and the compiler does not know what value this is.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: The fix is to tell the compiler what to use -- and that is the purpose of the
    `Zero` method.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: What value should you use for Zero?
  id: totrans-602
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So which value *should* you use for `Zero`? It depends on the kind of workflow
    you are creating.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some guidelines that might help:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '**Does the workflow have a concept of "success" or "failure"?** If so, use
    the "failure" value for `Zero`. For example, in our `trace` workflow, we use `None`
    to indicate failure, and so we can use `None` as the Zero value.'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Does the workflow have a concept of "sequential processing"?** That is, in
    your workflow you do one step and then another, with some processing behind the
    scenes. In normal F# code, an expression that did return anything explicitly would
    evaluate to unit. So to parallel this case, your `Zero` should be the *wrapped*
    version of unit. For example, in a variant on an option-based workflow, we might
    use `Some ()` to mean `Zero` (and by the way, this would always be the same as
    `Return ()` as well).'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Is the workflow primarily concerned with manipulating data structures?**
    If so, `Zero` should be the "empty" data structure. For example, in a "list builder"
    workflow, we would use the empty list as the Zero value.'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Zero` value also has an important role to play when combining wrapped types.
    So stay tuned, and we'll revisit Zero in the next post.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: A Zero implementation
  id: totrans-609
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So now let's extend our testbed class with a `Zero` method that returns `None`,
    and try again.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The test code makes it clear that `Zero` is being called behind the scenes.
    And `None` is the return value for the expression as whole. *Note: `None` may
    print out as `<null>`. You can ignore this.*'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: Do you always need a Zero?
  id: totrans-613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember, you *not required* to have a `Zero`, but only if it makes sense in
    the context of the workflow. For example `seq` does not allow zero, but `async`
    does:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Introducing "Yield"
  id: totrans-616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, there is a "yield" statement that, within an iterator, is used to return
    early and then picks up where you left off when you come back.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: And looking at the docs, there is a "yield" available in F# computation expressions
    as well. What does it do? Let's try it and see.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'And we get the error:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: No surprise there. So what should the implementation of "yield" method look
    like? The MSDN documentation says that it has the signature `'T -> M<'T>`, which
    is exactly the same as the signature for the `Return` method. It must take an
    unwrapped value and wrap it.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: So let's implement it the same way as `Return` and retry the test expression.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: This works now, and it seems that it can be used as an exact substitute for
    `return`.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: There is a also a `YieldFrom` method that parallels the `ReturnFrom` method.
    And it behaves the same way, allowing you to yield a wrapped value rather than
    a unwrapped one.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s add that to our list of builder methods as well:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'At this point you might be wondering: if `return` and `yield` are basically
    the same thing, why are there two different keywords? The answer is mainly so
    that you can enforce appropriate syntax by implementing one but not the other.
    For example, the `seq` expression *does* allow `yield` but *doesn''t* allow `return`,
    while the `async` does allow `return`, but does not allow `yield`, as you can
    see from the snippets below.'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: In fact, you could create slightly different behavior for `return` vs. `yield`,
    so that, for example, using `return` stops the rest of the computation expression
    from being evaluated, while `yield` doesn't.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: More generally, of course, `yield` should be used for sequence/enumeration semantics,
    while `return` is normally used once per expression. (We'll see how `yield` can
    be used multiple times in the next post.)
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting "For"
  id: totrans-633
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We talked about the `for..in..do` syntax in the last post. So now let's revisit
    the "list builder" that we discussed earlier and add the extra methods. We already
    saw how to define `Bind` and `Return` for a list in a previous post, so we just
    need to implement the additional methods.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: The `Zero` method just returns an empty list.
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Yield` method can be implemented in the same way as `Return`.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `For` method can be implemented the same as `Bind`.
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'And here is the code using `let!`:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'And here is the equivalent code using `for`:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: You can see that both approaches give the same result.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-644
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post, we've seen how to implement the basic methods for a simple computation
    expression.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: 'Some points to reiterate:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: For simple expressions you don't need to implement all the methods.
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Things with bangs have wrapped types on the right hand side.
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Things without bangs have unwrapped types on the right hand side.
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to implement `Zero` if you want a workflow that doesn't explicitly
    return a value.
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Yield` is basically equivalent to `Return`, but `Yield` should be used for
    sequence/enumeration semantics.'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`For` is basically equivalent to `Bind` in simple cases.'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next post, we'll look at what happens when we need to combine multiple
    values.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing a builder: Combine'
  id: totrans-654
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing a builder: Combine'
  id: totrans-655
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this post we're going to look at returning multiple values from a computation
    expression using the `Combine` method.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: The story so far...
  id: totrans-657
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, our expression builder class looks like this:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: And this class has worked fine so far. But we are about to run into a problem...
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: A problem with two 'yields'
  id: totrans-661
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, we saw how `yield` could be used to return values just like `return`.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, `yield` is not used just once, of course, but multiple times in order
    to return values at different stages of a process such as an enumeration. So let''s
    try that:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'But uh-oh, we get an error message:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: And if you use `return` instead of `yield`, you get the same error.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'And this problem occurs in other contexts too. For example, if we want to do
    something and then return, like this:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: We get the same error message about a missing 'Combine' method.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem
  id: totrans-672
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So what's going on here?
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand, let''s go back to the behind-the-scenes view of the computation
    expression. We have seen that `return` and `yield` are really just the last step
    in a series of continuations, like this:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'You can think of `return` (or `yield`) as "resetting" the indentation, if you
    like. So when we `return/yield` and then `return/yield` again, we are generating
    code like this:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'But really this can be simplified to:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: In other words, we now have *two* values in our computation expression. And
    then the obvious question is, how should these two values be combined to give
    a single result for the computation expression as a whole?
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: This is a very important point. **Return and yield do *not* generate an early
    return from a computation expression**. No, the entire computation expression,
    all the way to the last curly brace, is *always* evaluated and results in a *single*
    value. Let me repeat that. Every part of the computation expression is *always
    evaluated* -- there is no short circuiting going on. If we want to short circuit
    and return early, we have to write our own code to do that (and we'll see how
    to do that later).
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: 'So, back to the pressing question. We have two expressions resulting in two
    values: how should those multiple values be combined into one?'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: Introducing "Combine"
  id: totrans-683
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The answer is by using the `Combine` method, which takes two *wrapped* values
    and combines them to make another wrapped value. Exactly how this works is up
    to us.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we are dealing specifically with `int options`, so one simple
    implementation that leaps to mind it just to add the numbers together. Each parameter
    is an `option` of course (the wrapped type), so we need to pick them apart and
    handle the four possible cases:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Running the test code again:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'But now we get a different error message:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'The `Delay` method is a hook that allows you to delay evaluation of a computation
    expression until needed -- we''ll discuss this in detail very soon; but for now,
    let''s create a default implementation:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Running the test code again:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: And finally we get the code to complete.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The result of the entire workflow is the sum of all the yields, namely `Some
    3`.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: If we have a "failure" in the workflow (e.g. a `None`), the second yield doesn't
    occur and the overall result is `Some 1` instead.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'We can have three `yields` rather than two:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The result is what you would expect, `Some 6`.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: We can even try mixing up `yield` and `return` together. Other than the syntax
    difference, the overall effect is the same.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Using Combine for sequence generation
  id: totrans-705
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding numbers up is not really the point of `yield`, although you might perhaps
    use a similar idea for constructing concatenated strings, somewhat like `StringBuilder`.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: No, `yield` is naturally used as part of sequence generation, and now that we
    understand `Combine`, we can extend our "ListBuilder" workflow (from last time)
    with the required methods.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: The `Combine` method is just list concatenation.
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Delay` method can use a default implementation for now.
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the full class:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'And here it is in use:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: And here's a more complicated example with a `for` loop and some `yield`s.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'And the result is:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: You can see that by combining `for..in..do` with `yield`, we are not too far
    away from the built-in `seq` expression syntax (except that `seq` is lazy, of
    course).
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: I would strongly encourage you to play around with this a bit until you are
    clear on what is going on behind the scenes. As you can see from the example above,
    you can use `yield` in creative ways to generate all sorts of irregular lists,
    not just simple ones.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: If you''re wondering about `While`, we''re going to hold off on it for
    a bit, until after we have looked at `Delay` in an upcoming post*.'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: Order of processing for "combine"
  id: totrans-721
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Combine` method only has two parameters. So what happens when you combine
    more than two values? For example, here are four values to combine:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: If you look at the output you can see that the values are combined pair-wise,
    as you might expect.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: A subtle but important point is that they are combined "backwards", starting
    from the last value. First "3" is combined with "4", and the result of that is
    then combined with "2", and so on.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '![Combine](combine.png)'
  id: totrans-727
  prefs: []
  type: TYPE_IMG
- en: Combine for non-sequences
  id: totrans-728
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the second of our earlier problematic examples, we didn't have a sequence;
    we just had two separate expressions in a row.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: How should these expressions be combined?
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of common ways of doing this, depending on the concepts that
    the workflow supports.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: Implementing combine for workflows with "success" or "failure"
  id: totrans-733
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the workflow has some concept of "success" or "failure", then a standard
    approach is:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: If the first expression "succeeds" (whatever that means in context), then use
    that value.
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise use the value of the second expression.
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, we also generally use the "failure" value for `Zero`.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: This approach is useful for chaining together a series of "or else" expressions
    where the first success "wins" and becomes the overall result.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'For example, for the `maybe` workflow, it is common to return the first expression
    if it is `Some`, but otherwise the second expression, like this:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '**Example: Parsing**'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try a parsing example with this implementation:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'We get the following result:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: You can see that the first `return!` expression is `None`, and ignored. So the
    overall result is the second expression, `Some (I 42)`.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '**Example: Dictionary lookup**'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll try looking up the same key in a number of dictionaries,
    and return when we find a value:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'We get the following result:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: You can see that the first lookup is `None`, and ignored. So the overall result
    is the second lookup.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this technique is very convenient when doing parsing or evaluating
    a sequence of (possibly unsuccessful) operations.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: Implementing combine for workflows with sequential steps
  id: totrans-755
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the workflow has the concept of sequential steps, then the overall result
    is just the value of the last step, and all the previous steps are evaluated only
    for their side effects.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: 'In normal F#, this would be written:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Or using the semicolon syntax, just:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: In normal F#, each expression (other than the last) evaluates to the unit value.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: The equivalent approach for a computation expression is to treat each expression
    (other than the last) as a *wrapped* unit value, and "pass it into" the next expression,
    and so on, until you reach the last expression.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly what bind does, of course, and so the easiest implementation
    is just to reuse the `Bind` method itself. Also, for this approach to work it
    is important that `Zero` is the wrapped unit value.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: The difference from a normal bind is that the continuation has a unit parameter,
    and evaluates to `b`. This in turn forces `a` to be of type `WrapperType<unit>`
    in general, or `unit option` in our case.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of sequential processing that works with this implementation
    of `Combine`:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Here's the following trace. Note that the result of the whole expression was
    the result of the last expression in the sequence, just like normal F# code.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Implementing combine for workflows that build data structures
  id: totrans-770
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, another common pattern for workflows is that they build data structures.
    In this case, `Combine` should merge the two data structures in whatever way is
    appropriate. And the `Zero` method should create an empty data structure, if needed
    (and if even possible).
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: In the "list builder" example above, we used exactly this approach. `Combine`
    was just list concatenation and `Zero` was the empty list.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines for mixing "Combine" and "Zero"
  id: totrans-773
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have looked at two different implementations for `Combine` for option types.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: The first one used options as "success/failure" indicators, when the first success
    "won". In this case `Zero` was defined as `None`
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one was sequential, In this case `Zero` was defined as `Some ()`
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both cases worked nicely, but was that luck, or are there are any guidelines
    for implementing `Combine` and `Zero` correctly?
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: First, note that `Combine` does *not* have to give the same result if the parameters
    are swapped. That is, `Combine(a,b)` need not be the same as `Combine(b,a)`. The
    list builder is a good example of this.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand there is a useful rule that connects `Zero` and `Combine`.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule: `Combine(a,Zero)` should be the same as `Combine(Zero,a)` which should
    the same as just `a`.**'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: 'To use an analogy from arithmetic, you can think of `Combine` like addition
    (which is not a bad analogy -- it really is "adding" two values). And `Zero` is
    just the number zero, of course! So the rule above can be expressed as:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule: `a + 0` is the same as `0 + a` is the same as just `a`, where `+` means
    `Combine` and `0` means `Zero`.**'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the first `Combine` implementation ("success/failure") for option
    types, you'll see that it does indeed comply with this rule, as does the second
    implementation ("bind" with `Some()`).
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we had used the "bind" implementation of `Combine` but
    left `Zero` defined as `None`, it would *not* have obeyed the addition rule, which
    would be a clue that we had got something wrong.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '"Combine" without bind'
  id: totrans-785
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with all the builder methods, if you don't need them, you don't need to implement
    them. So for a workflow that is strongly sequential, you could easily create a
    builder class with `Combine`, `Zero`, and `Yield`, say, without having to implement
    `Bind` and `Return` at all.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a minimal implementation that works:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'And here it is in use:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Similarly, if you have a data-structure oriented workflow, you could just implement
    `Combine` and some other helpers. For example, here is a minimal implementation
    of our list builder class:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'And even with the minimal implementation, we can write code like this:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: A standalone "Combine" function
  id: totrans-795
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a previous post, we saw that the "bind" function is often used as standalone
    function, and is normally given the operator `>>=`.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: The `Combine` function too, is often used as a standalone function. Unlike bind,
    there is no standard symbol -- it can vary depending on how the combine function
    works.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: A symmetric combination operation is often written as `++` or `<+>`. And the
    "left-biased" combination (that is, only do the second expression if the first
    one fails) that we used earlier for options is sometimes written as `<++`.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: So here is an example of a standalone left-biased combination of options, as
    used in a dictionary lookup example.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Summary
  id: totrans-801
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What have we learned about `Combine` in this post?
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: You need to implement `Combine` (and `Delay`) if you need to combine or "add"
    more than one wrapped value in a computation expression.
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Combine` combines values pairwise, from last to first.'
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no universal implementation of `Combine` that works in all cases --
    it needs to be customized according the particular needs of the workflow.
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a sensible rule that relates `Combine` with `Zero`.
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Combine` doesn''t require `Bind` to be implemented.'
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Combine` can be exposed as a standalone function'
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next post, we'll add logic to control exactly when the internal expressions
    get evaluated, and introduce true short circuiting and lazy evaluation.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing a builder: Delay and Run'
  id: totrans-810
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing a builder: Delay and Run'
  id: totrans-811
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last few posts we have covered all the basic methods (Bind, Return, Zero,
    and Combine) needed to create your own computation expression builder. In this
    post, we'll look at some of the extra features needed to make the workflow more
    efficient, by controlling when expressions get evaluated.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem: avoiding unnecessary evaluations'
  id: totrans-813
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say that we have created a "maybe" style workflow as before. But this
    time we want to use the "return" keyword to return early and stop any more processing
    being done.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: Here is our complete builder class. The key method to look at is `Combine`,
    in which we simply ignore any secondary expressions after the first return.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Let''s see how it works by printing something, returning, and then printing
    something else:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'The debugging output should look something like the following, which I have
    annotated:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'We can see a problem here. The "Part 2: after return" was printed, even though
    we were trying to return early.'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: 'Why? Well I''ll repeat what I said in the last post: **return and yield do
    *not* generate an early return from a computation expression**. The entire computation
    expression, all the way to the last curly brace, is *always* evaluated and results
    in a single value.'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: This is a problem, because you might get unwanted side effects (such as printing
    a message in this case) and your code is doing something unnecessary, which might
    cause performance problems.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we avoid evaluating the second part until we need it?
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: Introducing "Delay"
  id: totrans-825
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The answer to the question is straightforward -- simply wrap part 2 of the expression
    in a function and only call this function when needed, like this.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Using this technique, part 2 of the computation expression can be processed
    completely, but because the expression returns a function, nothing actually *happens*
    until the function is called.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: But the `Combine` method will never call it, and so the code inside it does
    not run at all.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: And this is exactly what the `Delay` method is for. Any result from `Return`
    or `Yield` is immediately wrapped in a "delay" function like this, and then you
    can choose whether to run it or not.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the builder to implement a delay:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: As you can see, the `Delay` method is given a function to execute. Previously,
    we executed it immediately. What we're doing now is wrapping this function in
    another function and returning the delayed function instead. I have added a number
    of trace statements before and after the function is wrapped.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: If you compile this code, you can see that the signature of `Delay` has changed.
    Before the change, it returned a concrete value (an option in this case), but
    now it returns a function.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'By the way, we could have implemented `Delay` in a much simpler way, without
    any tracing, just by returning the same function that was passed in, like this:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Much more concise! But in this case, I wanted to add some detailed tracing information
    as well.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try again:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Uh-oh. This time nothing happens at all! What went wrong?
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the output we see this:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: '`Result for Part1 without Part2: <fun:Delay@84-5>`'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: Hmmm. The output of the whole `trace` expression is now a *function*, not an
    option. Why? Because we created all these delays, but we never "undelayed" them
    by actually calling the function!
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: One way to do this is to assign the output of the computation expression to
    a function value, say `f`, and then evaluate it.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: This works as expected, but is there a way to do this from inside the computation
    expression itself? Of course there is!
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: Introducing "Run"
  id: totrans-848
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Run` method exists for exactly this reason. It is called as the final step
    in the process of evaluating a computation expression, and can be used to undo
    the delay.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an implementation:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Let''s try one more time:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: And the result is exactly what we wanted. The first part is evaluated, but the
    second part is not. And the result of the entire computation expression is an
    option, not a function.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: When is delay called?
  id: totrans-855
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way that `Delay` is inserted into the workflow is straightforward, once
    you understand it.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: The bottom (or innermost) expression is delayed.
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this is combined with a prior expression, the output of `Combine` is also
    delayed.
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And so on, until the final delay is fed into `Run`.
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using this knowledge, let''s review what happened in the example above:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the expression is the print statement plus `return 1`.
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second part of the expression is the print statement without an explicit
    return, which means that `Zero()` is called
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `None` from the `Zero` is fed into `Delay`, resulting in a "delayed option",
    that is, a function that will evaluate to an `option` when called.
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The option from part 1 and the delayed option from part 2 are combined in `Combine`
    and the second one is discarded.
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result of the combine is turned into another "delayed option".
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the delayed option is fed to `Run`, which evaluates it and returns
    a normal option.
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a diagram that represents this process visually:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: '![Delay](ce_delay.png)'
  id: totrans-868
  prefs: []
  type: TYPE_IMG
- en: If we look at the debug trace for the example above, we can see in detail what
    happened. It's a little confusing, so I have annotated it. Also, it helps to remember
    that working *down* this trace is the same as working *up* from the bottom of
    the diagram above, because the outermost code is run first.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '"Delay" changes the signature of "Combine"'
  id: totrans-871
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When `Delay` is introduced into the pipeline like this, it has an effect on
    the signature of `Combine`.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: When we originally wrote `Combine` we were expecting it to handle `options`.
    But now it is handling the output of `Delay`, which is a function.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see this if we hard-code the types that `Combine` expects, with `int
    option` type annotations like this:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'If this is done, we get an compiler error in the "return" expression:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'The error is:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: In other words, the `Combine` is being passed a delayed function (`unit -> 'a`),
    which doesn't match our explicit signature.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: So what happens when we *do* want to combine the parameters, but they are passed
    in as a function instead of as a simple value?
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is straightforward: just call the function that was passed in to
    get the underlying value.'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: Let's demonstrate that using the adding example from the previous post.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: In this new version of `Combine`, the *second* parameter is now a function,
    not an `int option`. So to combine them, we must first evaluate the function before
    doing the combination logic.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: 'If we test this out:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'We get the following (annotated) trace:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Understanding the type constraints
  id: totrans-890
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to now, we have used only our "wrapped type" (e.g. `int option`) and the
    delayed version (e.g. `unit -> int option`) in the implementation of our builder.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: But in fact we can use other types if we like, subject to certain constraints.
    In fact, understanding exactly what the type constraints are in a computation
    expression can clarify how everything fits together.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we have seen that:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: The output of `Return` is passed into `Delay`, so they must have compatible
    types.
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output of `Delay` is passed into the second parameter of `Combine`.
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output of `Delay` is also passed into `Run`.
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But the output of `Return` does *not* have to be our "public" wrapped type.
    It could be an internally defined type instead.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: '![Delay](ce_return.png)'
  id: totrans-898
  prefs: []
  type: TYPE_IMG
- en: Similarly, the delayed type does not have to be a simple function, it could
    be any type that satisfies the constraints.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: 'So, given a simple set of return expressions, like this:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Then a diagram that represents the various types and their flow would look
    like this:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: '![Delay](ce_types.png)'
  id: totrans-903
  prefs: []
  type: TYPE_IMG
- en: 'And to prove that this is valid, here is an implementation with distinct types
    for `Internal` and `Delayed`:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'And the method signatures in the builder class methods look like this:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Creating this artifical builder is overkill of course, but the signatures clearly
    show how the various methods fit together.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-909
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this post, we''ve seen that:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: You need to implement `Delay` and `Run` if you want to delay execution within
    a computation expression.
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Delay` changes the signature of `Combine`.
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Delay` and `Combine` can use internal types that are not exposed to clients
    of the computation expression.'
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next logical step is wanting to delay execution *outside* a computation
    expression until you are ready, and that will be the topic on the next but one
    post. But first, we'll take a little detour to discuss method overloads.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing a builder: Overloading'
  id: totrans-915
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing a builder: Overloading'
  id: totrans-916
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this post, we'll take a detour and look at some tricks you can do with methods
    in a computation expression builder.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, this detour will lead to a dead end, but I hope the journey might
    provide some more insight into good practices for designing your own computation
    expressions.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: 'An insight: builder methods can be overloaded'
  id: totrans-919
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At some point, you might have an insight:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: The builder methods are just normal class methods, and unlike standalone functions,
    methods can support [overloading with different parameter types](type-extensions.html#method-overloading),
    which means we can create *different implementations* of any method, as long as
    the parameter types are different.
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So then you might get excited about this and how it could be used. But it turns
    out to be less useful than you might think. Let's look at some examples.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: Overloading "return"
  id: totrans-923
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Say that you have a union type. You might consider overloading `Return` or `Yield`
    with multiple implementations for each union case.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here''s a very simple example where `Return` has two overloads:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'And here it is in use:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: What's wrong with this, you might think?
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: Well, first, if we go back to the [discussion on wrapper types](computation-expressions-wrapper-types-part2.html),
    we made the point that wrapper types should be *generic*. Workflows should be
    reusable as much as possible -- why tie the implementation to any particular primitive
    type?
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: 'What that means in this case is that the union type should be resigned to look
    like this:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: But as a consequence of the generics, the `Return` method can't be overloaded
    any more!
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, it''s probably not a good idea to expose the internals of the type
    inside the expression like this anyway. The concept of "success" and "failure"
    cases is useful, but a better way would be to hide the "failure" case and handle
    it automatically inside `Bind`, like this:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: In this approach, `Return` is only used for success, and the failure cases are
    hidden.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: We'll see more of this technique in an upcoming post.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Combine implementations
  id: totrans-939
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another time when you might be tempted to overload a method is when implementing
    `Combine`.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: Let's revisit the `Combine` method for the `trace` workflow. If you remember,
    in the previous implementation of `Combine`, we just added the numbers together.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we change our requirements, and say that:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: if we yield multiple values in the `trace` workflow, then we want to combine
    them into a list.
  id: totrans-943
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A first attempt using combine might look this:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: In the `Combine` method, we unwrap the value from the passed-in option and combine
    them into a list wrapped in a `Some` (e.g. `Some [a';b']`).
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: 'For two yields it works as expected:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'And for a yielding a `None`, it also works as expected:'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'But what happens if there are *three* values to combine? Like this:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'If we try this, we get a compiler error:'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: What is the problem?
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that after combining the 2nd and 3rd values (`yield 2; yield 3`),
    we get an option containing a *list of ints* or `int list option`. The error happens
    when we attempt to combine the first value (`Some 1`) with the combined value
    (`Some [2;3]`). That is, we are passing a `int list option` as the second parameter
    of `Combine`, but the first parameter is still a normal `int option`. The compiler
    is telling you that it wants the second parameter to be the same type as the first.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: But, here's where we might want use our overloading trick. We can create *two*
    different implementations of `Combine`, with different types for the second parameter,
    one that takes an `int option` and the other taking an `int list option`.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: 'So here are the two methods, with different parameter types:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Now if we try combining three results, as before, we get what we expect.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Unfortunately, this trick has broken some previous code! If you try yielding
    a `None` now, you will get a compiler error.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'The error is:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: But hold on, before you get too annoyed, try thinking like the compiler. If
    you were the compiler, and you were given a `None`, which method would *you* call?
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: There is no correct answer, because a `None` could be passed as the second parameter
    to *either* method. The compiler does not know where this is a None of type `int
    list option` (the first method) or a None of type `int option` (the second method).
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: As the compiler reminds us, a type annotation will help, so let's give it one.
    We'll force the None to be an `int option`.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: This is ugly, of course, but in practice might not happen very often.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, this is a clue that we have a bad design. Sometimes the computation
    expression returns an `'a option` and sometimes it returns an `'a list option`.
    We should be consistent in our design, so that the computation expression always
    returns the *same* type, no matter how many `yield`s are in it.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: That is, if we *do* want to allow multiple `yield`s, then we should use `'a
    list option` as the wrapper type to begin with rather than just a plain option.
    In this case the `Yield` method would create the list option, and the `Combine`
    method could be collapsed to a single method again.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code for our third version:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'And now the examples work as expected without any special tricks:'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: Not only is the code cleaner, but as in the `Return` example, we have made our
    code more generic as well, having gone from a specific type (`int option`) to
    a more generic type (`'a option`).
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: Overloading "For"
  id: totrans-978
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One legitimate case where overloading might be needed is the `For` method.
    Some possible reasons:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: You might want to support different kinds of collections (e.g. list *and* `IEnumerable`)
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might have a more efficient looping implementation for certain kinds of
    collections.
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might have a "wrapped" version of a list (e.g. LazyList) and you want support
    looping for both unwrapped and wrapped values.
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example of our list builder that has been extended to support sequences
    as well as lists:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'And here is it in use:'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: If you comment out the second `For` method, you will see the "sequence` example
    will indeed fail to compile. So the overload is needed.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-988
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So we've seen that methods can be overloaded if needed, but be careful at jumping
    to this solution immediately, because having to doing this may be a sign of a
    weak design.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: In the next post, we'll go back to controlling exactly when the expressions
    get evaluated, this time using a delay *outside* the builder.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing a builder: Adding laziness'
  id: totrans-991
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing a builder: Adding laziness'
  id: totrans-992
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a [previous post](computation-expressions-builder-part3.html), we saw how
    to avoid unnecessary evaluation of expressions in a workflow until needed.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: But that approach was designed for expressions *inside* a workflow. What happens
    if we want to delay the *whole workflow itself* until needed.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: The problem
  id: totrans-995
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is the code from our "maybe" builder class. This code is based on the `trace`
    builder from the earlier post, but with all the tracing taken out, so that it
    is nice and clean.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'Before moving on, make sure that you understand how this works. If we analyze
    this using the terminology of the earlier post, we can see that the types used
    are:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrapper type: `''a option`'
  id: totrans-999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Internal type: `''a option`'
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Delayed type: `unit -> ''a option`'
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's check this code and make sure everything works as expected.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'But what happens if we refactor the code into a child workflow, like this:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: The output shows that the child workflow was evaluated even though it wasn't
    needed in the end. This might not be a problem in this case, but in many cases,
    we may not want this to happen.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: So, how to avoid it?
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping the inner type in a delay
  id: totrans-1008
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The obvious approach is to wrap the *entire result of the builder* in a delay
    function, and then to "run" the result, we just evaluate the delay function.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here''s our new wrapper type:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: We've replaced a simple `option` with a function that evaluates to an option,
    and then wrapped that function in a [single case union](designing-with-types-single-case-dus.html)
    for good measure.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: 'And now we need to change the `Run` method as well. Previously, it evaluated
    the delay function that was passed in to it, but now it should leave it unevaluated
    and wrap it in our new wrapper type:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '*I''ve forgotten to fix up another method -- do you know which one? We''ll
    bump into it soon!*'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: One more thing -- we'll need a way to "run" the result now.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'Let''s try out our new type on our previous examples:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'Running this, we get something like this:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: That looks good; nothing else was printed.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: 'And now run it:'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'and we get the output:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: Perfect. Part 2 did not run.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: 'But we run into a problem with the next example:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Oops! We forgot to fix up `ReturnFrom`! As we know, that method takes a *wrapped
    type*, and we have redefined the wrapped type now.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the fix:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: We are going to accept a `Maybe` from outside, and then immediately run it to
    get at the option.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: But now we have another problem -- we can't return an explicit `None` anymore
    in `return! None`, we have to return a `Maybe` type instead. How are we going
    to create one of these?
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, we could create a helper function that constructs one for us. But there
    is a much simpler answer: you can create a new `Maybe` type by using a `maybe`
    expression!'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: This is why the `Zero` method is useful. With `Zero` and the builder instance,
    you can create new instances of the type even if they don't do anything.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: 'But now we have one more error -- the dreaded "value restriction":'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-1039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: The reason why this has happened is that *both* expressions are returning `None`.
    But the compiler does not know what type `None` is. The code is using `None` of
    type `Option<obj>` (presumably because of implicit boxing) yet the compiler knows
    that the type can be more generic than that.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two fixes. One is to make the type explicit:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'Or we can just return some non-None value instead:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Both of these solutions will fix the problem.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: Now if we run the example, we see that the result is as expected. The second
    part *is* run this time.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'The trace output:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'Finally, we''ll try the child workflow examples again:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: And now the child workflow is not evaluated, just as we wanted.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: 'And if we *do* need the child workflow to be evaluated, this works too:'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: Reviewing the builder class
  id: totrans-1055
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at all the code in the new builder class again:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'If we analyze this new builder using the terminology of the earlier post, we
    can see that the types used are:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrapper type: `Maybe<''a>`'
  id: totrans-1059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Internal type: `''a option`'
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Delayed type: `unit -> ''a option`'
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that in this case it was convenient to use the standard `'a option` as
    the internal type, because we didn't need to modify `Bind` or `Return` at all.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: An alternative design might use `Maybe<'a>` as the internal type as well, which
    would make things more consistent, but makes the code harder to read.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: True laziness
  id: totrans-1064
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at a variant of the last example:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: What should happen? How many times should the child workflow be run?
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: The delayed implementation above does ensure that the child workflow is only
    be evaluated on demand, but it does not stop it being run twice.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: In some situations, you might require that the workflow is guaranteed to only
    run *at most once*, and then cached ("memoized"). This is easy enough to do using
    the `Lazy` type that is built into F#.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes we need to make are:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: Change `Maybe` to wrap a `Lazy` instead of a delay
  id: totrans-1071
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change `ReturnFrom` and `run` to force the evaluation of the lazy value
  id: totrans-1072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change `Run` to run the delay from inside a `lazy`
  id: totrans-1073
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the new class with the changes:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'And if we run the "child twice` code from above, we get:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: from which it is clear that the child workflow only ran once.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: 'Summary: Immediate vs. Delayed vs. Lazy'
  id: totrans-1079
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On this page, we've seen three different implementations of the `maybe` workflow.
    One that is always evaluated immediately, one that uses a delay function, and
    one that uses laziness with memoization.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: So... which approach should you use?
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no single "right" answer. Your choice depends on a number of things:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: '*Is the code in the expression cheap to execute, and without important side-effects?*
    If so, stick with the first, immediate version. It''s simple and easy to understand,
    and this is exactly what most implementations of the `maybe` workflow use.'
  id: totrans-1083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Is the code in the expression expensive to execute, might the result vary
    with each call (e.g. non-deterministic), or are there important side-effects?*
    If so, use the second, delayed version. This is exactly what most other workflows
    do, especially those relating to I/O (such as `async`).'
  id: totrans-1084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: F# does not attempt to be a purely functional language, so almost all F# code
    will fall into one of these two categories. But, *if you need to code in a guaranteed
    side-effect free style, or you just want to ensure that expensive code is evaluated
    at most once*, then use the third, lazy option.
  id: totrans-1085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whatever your choice, do make it clear in the documentation. For example, the
    delayed vs. lazy implementations appear exactly the same to the client, but they
    have very different semantics, and the client code must be written differently
    for each case.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have finished with delays and laziness, we can go back to the builder
    methods and finish them off.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing a builder: The rest of the standard methods'
  id: totrans-1088
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing a builder: The rest of the standard methods'
  id: totrans-1089
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're coming into the home stretch now. There are only a few more builder methods
    that need to be covered, and then you will be ready to tackle anything!
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods are:'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: '`While` for repetition.'
  id: totrans-1092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryWith` and `TryFinally` for handling exceptions.'
  id: totrans-1093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Use` for managing disposables'
  id: totrans-1094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, as always, that not all methods need to be implemented. If `While`
    is not relevant to you, don't bother with it.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: 'One important note before we get started: **all the methods discussed here
    rely on [delays](computation-expressions-builder-part3.html)** being used. If
    you are not using delay functions, then none of the methods will give the expected
    results.'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: Implementing "While"
  id: totrans-1097
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We all know what "while" means in normal code, but what does it mean in the
    context of a computation expression? To understand, we have to revisit the concept
    of continuations again.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: 'In previous posts, we saw that a series of expressions is converted into a
    chain of continuations like this:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: And this is the key to understanding a "while" loop -- it can be expanded in
    the same way.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: 'First, some terminology. A while loop has two parts:'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: There is a test at the top of the "while" loop which is evaluated each time
    to determine whether the body should be run. When it evaluates to false, the while
    loop is "exited". In computation expressions, the test part is known as the **"guard"**.
    The test function has no parameters, and returns a bool, so its signature is `unit
    -> bool`, of course.
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And there is the body of the "while" loop, evaluated each time until the "while"
    test fails. In computation expressions, this is a delay function that evaluates
    to a wrapped value. Since the body of the while loop is always the same, the same
    function is evaluated each time. The body function has no parameters, and returns
    nothing, and so its signature is just `unit -> wrapped unit`.
  id: totrans-1104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this in place, we can create pseudo-code for a while loop using continuations:'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'One question that is immediately apparent is: what should be returned when
    the while loop test fails? Well, we have seen this before with `if..then..`, and
    the answer is of course to use the `Zero` value.'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: The next thing is that the `body()` result is being discarded. Yes, it is a
    unit function, so there is no value to return, but even so, in our expressions,
    we want to be able to hook into this so we can add behavior behind the scenes.
    And of course, this calls for using the `Bind` function.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: 'So here is a revised version of the pseudo-code, using `Zero` and `Bind`:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: In this case, the continuation function passed into `Bind` has a unit parameter,
    because the `body` function does not have a value.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the pseudo-code can be simplified by collapsing it into a recursive
    function like this:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: And indeed, this is the standard "boiler-plate" implementation for `While` in
    almost all builder classes.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: It is a subtle but important point that the value of `Zero` must be chosen properly.
    In previous posts, we saw that we could set the value for `Zero` to be `None`
    or `Some ()` depending on the workflow. For `While` to work however, the `Zero`
    *must be* set to `Some ()` and not `None`, because passing `None` into `Bind`
    will cause the whole thing to aborted early.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: Also note that, although this is a recursive function, we didn't need the `rec`
    keyword. It is only needed for standalone functions that are recursive, not methods.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: '"While" in use'
  id: totrans-1117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at it being used in the `trace` builder. Here''s the complete builder
    class, with the `While` method:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: If you look at the signature for `While`, you will see that the `body` parameter
    is `unit -> unit option`, that is, a delayed function. As noted above, if you
    don't implement `Delay` properly, you will get unexpected behavior and cryptic
    compiler errors.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: And here is a simple loop using a mutable value that is incremented each time
    round.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Handling exceptions with "try..with"
  id: totrans-1124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exception handling is implemented in a similar way.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at a `try..with` expression for example, it has two parts:'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: There is the body of the "try", evaluated once. In a computation expressions,
    this will be a delayed function that evaluates to a wrapped value. The body function
    has no parameters, and so its signature is just `unit -> wrapped type`.
  id: totrans-1127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "with" part handles the exception. It has an exception as a parameters,
    and returns the same type as the "try" part, so its signature is `exception ->
    wrapped type`.
  id: totrans-1128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this in place, we can create pseudo-code for the exception handler:'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  id: totrans-1130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'And this maps exactly to a standard implementation:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: As you can see, it is common to use pass the returned value through `ReturnFrom`
    so that it gets the same treatment as other wrapped values.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example snippet to test how the handling works:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: Implementing "try..finally"
  id: totrans-1136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`try..finally` is very similar to `try..with`.'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: There is the body of the "try", evaluated once. The body function has no parameters,
    and so its signature is `unit -> wrapped type`.
  id: totrans-1138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "finally" part is always called. It has no parameters, and returns a unit,
    so its signature is `unit -> unit`.
  id: totrans-1139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just as with `try..with`, the standard implementation is obvious.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  id: totrans-1141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'Another little snippet:'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: Implementing "using"
  id: totrans-1144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final method to implement is `Using`. This is the builder method for implementing
    the `use!` keyword.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the MSDN documentation says about `use!`:'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'is translated to:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: In other words, the `use!` keyword triggers both a `Bind` and a `Using`. First
    a `Bind` is done to unpack the wrapped value, and then the unwrapped disposable
    is passed into `Using` to ensure disposal, with the continuation function as the
    second parameter.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: Implementing this is straightforward. Similar to the other methods, we have
    a body, or continuation part, of the "using" expression, which is evaluated once.
    This body function has a "disposable" parameter, and so its signature is `#IDisposable
    -> wrapped type`.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: Of course we want to ensure that the disposable value is always disposed no
    matter what, so we need to wrap the call to the body function in a `TryFinally`.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a standard implementation:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  id: totrans-1154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'Notes:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: The parameter to `TryFinally` is a `unit -> wrapped`, with a *unit* as the first
    parameter, so we created a delayed version of the body that is passed in.
  id: totrans-1156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disposable is a class, so it could be `null`, and we have to handle that case
    specially. Otherwise we just dispose it in the "finally" continuation.
  id: totrans-1157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here's a demonstration of `Using` in action. Note that the `makeResource` makes
    a *wrapped* disposable. If it wasn't wrapped, we wouldn't need the special `use!`
    and could just use a normal `use` instead.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '"For" revisited'
  id: totrans-1160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we can revisit how `For` is implemented. In the previous examples,
    `For` took a simple list parameter. But with `Using` and `While` under our belts,
    we can change it to accept any `IEnumerable<_>` or sequence.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the standard implementation for `For` now:'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]fsharp'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: type TraceBuilder() =
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: member this.Bind(m, f) =
  id: totrans-1165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Option.bind f m
  id: totrans-1166
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: member this.Return(x) = Some x
  id: totrans-1167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: member this.ReturnFrom(x) = x
  id: totrans-1168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: member this.Yield(x) = Some x
  id: totrans-1169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: member this.YieldFrom(x) = x
  id: totrans-1170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: member this.Zero() = this.Return ()
  id: totrans-1171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: member this.Delay(f) = f
  id: totrans-1172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: member this.Run(f) = f()
  id: totrans-1173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: member this.While(guard, body) =
  id: totrans-1174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if not (guard())
  id: totrans-1175
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: then this.Zero()
  id: totrans-1176
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: else this.Bind( body(), fun () ->
  id: totrans-1177
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: this.While(guard, body))
  id: totrans-1178
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: member this.TryWith(body, handler) =
  id: totrans-1179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: try this.ReturnFrom(body())
  id: totrans-1180
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: with e -> handler e
  id: totrans-1181
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: member this.TryFinally(body, compensation) =
  id: totrans-1182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: try this.ReturnFrom(body())
  id: totrans-1183
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: finally compensation()
  id: totrans-1184
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: member this.Using(disposable:#System.IDisposable, body) =
  id: totrans-1185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let body' = fun () -> body disposable
  id: totrans-1186
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: this.TryFinally(body', fun () ->
  id: totrans-1187
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: match disposable with
  id: totrans-1188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| null -> ()'
  id: totrans-1189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| disp -> disp.Dispose())'
  id: totrans-1190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: member this.For(sequence:seq<_>, body) =
  id: totrans-1191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this.Using(sequence.GetEnumerator(),fun enum ->
  id: totrans-1192
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: this.While(enum.MoveNext,
  id: totrans-1193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: this.Delay(fun () -> body enum.Current)))
  id: totrans-1194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '```'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: After all this discussion, the code seems quite tiny now. And yet this builder
    implements every standard method, uses delayed functions. A lot of functionality
    in a just a few lines!
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
