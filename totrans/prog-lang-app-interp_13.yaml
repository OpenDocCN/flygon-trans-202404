- en: 13Desugaring as a Language Feature
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13解糖作为一种语言特性
- en: 'We have thus far extensively discussed and relied upon desugaring, but our
    current desguaring mechanism have been weak. We have actually used desugaring
    in two different ways. One, we have used it to shrink the language: to take a
    large language and distill it down to its core [REF]. But we have also used it
    to grow the language: to take an existing language and add new features to it
    [REF]. This just shows that desugaring is a tremendously useful feature to have.
    Indeed, it is so useful that we might ask two questions:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经广泛讨论并依赖解糖，但我们当前的解糖机制很弱。我们实际上以两种不同的方式使用了解糖。一种是我们用它来缩小语言：将一个大语言提炼到其核心[REF]。但我们还用它来扩展语言：将现有语言并添加新功能[REF]。这只是表明解糖是一个非常有用的功能。事实上，它是如此有用，以至于我们可能会提出两个问题：
- en: Because we create languages to simplify the creation of common tasks, what would
    a language designed to support desugaring look like? Note that by “look” we don’t
    mean only syntax but also its key behavioral properties.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为我们创建语言是为了简化常见任务的创建，那么一个旨在支持解糖的语言会是什么样子呢？请注意，通过“外观”我们不仅指语法，还指其关键行为特性。
- en: Given that general-purpose languages are often used as a target for desugaring,
    why don’t they offer desugaring capabilities in the language itself? For instance,
    this might mean extending a base language with the additional language that is
    the response to the previous question.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鉴于通用语言通常被用作解糖的目标，为什么它们自身不提供解糖功能呢？例如，这可能意味着用前一问题的响应作为附加语言扩展基础语言。
- en: We are going to explore the answer to both questions simultaneously, by studying
    the facilities provided for this by Racket.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过研究Racket提供的这些功能来同时探讨这两个问题的答案。
- en: 13.1A First Example
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1第一个例子
- en: 'DrRacket has a very useful tool called the Macro Stepper, which shows the step-by-step
    expansion of programs. You should try all the examples in this chapter using the
    Macro Stepper. For now, however, you should run them in #lang plai rather than
    #lang plai-typed.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: DrRacket有一个非常有用的工具称为宏步进器，它显示程序的逐步展开。您应该尝试使用宏步进器运行本章中的所有示例。但是，目前，您应该在#lang plai而不是#lang
    plai-typed中运行它们。
- en: 'Remember that in [REF] we added let as syntactic sugar over lambda. The pattern
    we followed was this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在[REF]中，我们将let作为lambda的语法糖添加。我们遵循的模式是这样的：
- en: '| (let (var val) body) |'
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let (var val) body) |'
- en: is transformed into
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 被转换为
- en: '| ((lambda (var) body) val) |'
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ((lambda (var) body) val) |'
- en: Do Now!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就动手！
- en: If this doesn’t sound familiar, now would be a good time to refresh your memory
    of why this works.
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果这听起来不熟悉，现在是恢复对为什么这样工作的记忆的好时机。
- en: 'The simplest way of describing this transformation would be to state it directly:
    to write, somehow,'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 描述这种转换的最简单方法是直接陈述：以某种方式写出，
- en: '| (let (var val) body) |'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let (var val) body) |'
- en: '| -> |'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| -> |'
- en: '| ((lambda (var) body) val) |'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ((lambda (var) body) val) |'
- en: In fact, this is almost precisely what Racket enables you to do. We’ll use the
    name my-let instead of let Because the latter is already defined in Racket.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这几乎正是Racket让您能够做的事情。我们将使用my-let而不是let的名称，因为后者已经在Racket中定义了。
- en: '| (define-syntax my-let-1 |'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-syntax my-let-1 |'
- en: '|   (syntax-rules () |'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (syntax-rules () |'
- en: '|     [(my-let-1 (var val) body) |'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(my-let-1 (var val) body) |'
- en: '|      ((lambda (var) body) val)])) |'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      ((lambda (var) body) val)])) |'
- en: 'syntax-rules tells Racket that whenever it sees an expression with my-let-1
    immediately after the opening parenthesis, it should check that it follows the
    pattern (my-let-1 (var val) body). The var, val and body are syntactic variables:
    they are variables that stand for bodies of code. In particular, they match whatever
    s-expression is in that position. If the expression matches the pattern, then
    the syntactic variables are bound to the corresponding parts of the expression,
    and become available for use in the right-hand side.You may have noticed some
    additional syntax, such as (). We’ll explain this later.The right-hand side—<wbr>in
    this case, ((lambda (var) body) val)—<wbr>is the output generated. Each of the
    syntactic variables are replaced with the corresponding parts of the input using
    our old friend, substitution. This substitution is utterly simplistic: it makes
    no attempt to. Thus, if we were to try using it with'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: syntax-rules 告诉 Racket，每当它看到一个表达式，紧跟在开括号后面的是 my-let-1，它应该检查它是否符合模式 (my-let-1
    (var val) body)。var、val 和 body 是语法变量：它们是代表代码主体的变量。特别地，它们匹配该位置上的任何 s-表达式。如果表达式符合模式，那么语法变量将绑定到表达式的相应部分，并可用于右侧。你可能已经注意到了一些额外的语法，比如
    ()。我们稍后会解释这个。右侧—<wbr>在这种情况下，((lambda (var) body) val)—<wbr>是生成的输出。每个语法变量都会使用我们的老朋友，替换，替换为输入的相应部分。这种替换非常简单：它不会尝试。因此，如果我们尝试使用它
- en: '| (my-let-1 (3 4) 5) |'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (my-let-1 (3 4) 5) |'
- en: Racket would not initially complain that 3 is provided in an identifier position;
    rather, it would let the identifier percolate through, desugaring this into
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Racket 最初不会抱怨 3 被提供在标识符位置；相反，它会让标识符渗透，将其解糖为
- en: '| ((lambda (3) 5) 4) |'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ((lambda (3) 5) 4) |'
- en: 'which in turn produces an error:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这反过来产生了一个错误：
- en: '| lambda: expected either <id> or `[<id> : <type>]'' |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: 'lambda: 预期是 <id> 或 `[<id> : <type>]'''
- en: '|   for function argument in: 3 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|   for function argument in: 3 |'
- en: 'This immediately tells us that the desugaring process is straightforward in
    its function: it doesn’t attempt to guess or be clever, but instead simply rewrites
    while substituting. The output is an expression that is again subject to desugaring.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这立即告诉我们，解糖过程在功能上是直接的：它不会试图猜测或聪明，而是简单地重写并替换。输出是一个再次经过解糖的表达式。
- en: As a matter of terminology, this simple form of expression-rewriting is often
    called a macro, as we mentioned earlier in [REF]. Traditionally this form of desugaring
    is called macro expansion, though this term is misleading because the output of
    desugaring can be smaller than the input (though it is usually larger).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 术语上，这种简单的表达式重写形式通常被称为宏，正如我们之前在 [REF] 中提到的。传统上，这种解糖形式被称为宏展开，尽管这个术语有误导性，因为解糖的输出可能比输入更小（尽管通常更大）。
- en: 'Of course, in Racket, a let can bind multiple identifiers, not just one. If
    we were to write this informally, say on a board, we might write something like
    (let ([var val] ...) body) -> ((lambda (var ...) body) val ...) with the ... meaning
    “zero or more”, and the intent being that the var ... in the output should correspond
    to the sequence of vars in the input. Again, this is almost precisely Racket syntax:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在 Racket 中，let 可以绑定多个标识符，而不仅仅是一个。如果我们非正式地写下这个，比如在白板上，我们可能会写出类似 (let ([var
    val] ...) body) -> ((lambda (var ...) body) val ...) 的东西，其中 ... 的意思是“零个或多个”，意图是输出中的
    var ... 应该对应于输入中的 var 序列。再次，这几乎是 Racket 语法：
- en: '| (define-syntax my-let-2 |'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-syntax my-let-2 |'
- en: '|   (syntax-rules () |'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (syntax-rules () |'
- en: '|     [(my-let-2 ([var val] ...) body) |'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(my-let-2 ([var val] ...) body) |'
- en: '|      ((lambda (var ...) body) val ...)])) |'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      ((lambda (var ...) body) val ...)])) |'
- en: 'Observe the power of the ... notation: the sequence of “pairs” in the input
    is turned into a pair of sequences in the output; put differently, Racket “unzips”
    the input sequence. Conversely, this same notation can be used to zip together
    sequences.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 观察 ... 符号的威力：输入序列中的“对”被转换为输出序列的一对；换句话说，Racket “解压缩”了输入序列。反过来，这个符号也可以用来将序列合并在一起。
- en: 13.2Syntax Transformers as Functions
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 语法变换器作为函数
- en: Earlier we saw that my-let-1 does not even attempt to ensure that the syntax
    in the identifier position is truly (i.e., syntactically) an identifier. We cannot
    remedy that with the syntax-rules mechanism, but we can with a much more powerful
    mechanism called syntax-case. Because syntax-case exhibits many other useful features
    as well, we’ll introduce it and then grow it gradually.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候我们看到 my-let-1 甚至不尝试确保标识符位置的语法是否真正（即，语法上）是标识符。我们无法用语法规则机制来纠正这一点，但是我们可以用一个更强大的机制——语法情况来纠正。因为语法情况还展示了许多其他有用的功能，所以我们将介绍它，然后逐渐增加它。
- en: 'The first thing to understand is that a macro is actually a function. It is
    not, however, a function from regular run-time values to other run-time values,
    but rather a function from syntax to syntax. These functions execute in a world
    whose purpose is to create the program to execute. Observe that we’re talking
    about the program to execute: the actual execution of the program may only occur
    much later (or never at all). This point is actually extremely clear when we examine
    desugaring, which is very explicitly a function from (one kind of) syntax to (another
    kind of) syntax. This is perhaps obscured above in two ways:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要理解的是宏实际上是一个函数。然而，它不是从常规运行时值到其他运行时值的函数，而是从语法到语法的函数。这些函数在一个旨在创建要执行的程序的世界中执行。请注意，我们谈论的是要执行的程序：实际执行程序可能要晚得多（或根本不执行）。当我们检查解糖化时，这一点实际上非常清楚，解糖化非常明确地是从一种语法到另一种语法的函数。这在上面可能以两种方式被掩盖：
- en: The notation of syntax-rules, with no explicit parameter name or other “function
    header”, may not make clear that it is a functional transformation (though the
    rewriting rule format does allude to this fact).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无参数名或其他“函数头”的语法规则符号的表示形式可能并不清楚它是一个函数变换（尽管重写规则格式确实暗示了这一事实）。
- en: In desugaring, we specify one atomic function for the entire process. Here,
    we are actually writing several little functions, one for each kind of new syntactic
    construct (such as my-let-1), and these pieces are woven together by an invisible
    function that controls the overall rewriting process. (As a concrete example,
    it is not inherently clear that the output of a macro is expanded further—<wbr>though
    a simple example immediately demonstrates that this is indeed the case.)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在解糖化中，我们为整个过程指定了一个原子函数。在这里，我们实际上编写了几个小函数，每个新的语法构造（如 my-let-1）一个，这些部分由一个控制整体重写过程的隐式函数编织在一起。（作为一个具体的例子，不明显的是宏的输出是否进一步扩展——虽然一个简单的例子立即证明了这确实是这样的。）
- en: Exercise
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Write one or more macros to confirm that the output of a macro is expanded further.
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 写一个或多个宏来确认宏的输出是否进一步扩展。
- en: There is one more subtlety. Because the form of a macro looks rather like Racket
    code, it is not immediately clear that it “lives in another world”. In the abstract,
    it may be helpful to imagine that the macro definitions are actually written in
    an entirely different language that processes only syntax. This simplicity is,
    however, misleading. In practice, program transformers—<wbr>also called compilers—<wbr>are
    full-blown programs, too, and need all the power of ordinary programs. This would
    have necessitated the creation of a parallel language purely for processing programs.
    This would be wasteful and pointless; therefore, Racket instead endows syntax-transforming
    programs with the full power of Racket itself.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个细微之处。因为宏的形式看起来很像 Racket 代码，所以不会立即清楚它“存在于另一个世界”中。在抽象层面上，想象宏定义实际上是用一种完全不同的语言编写的，该语言仅处理语法。然而，这种简单性是误导性的。在实践中，程序转换器——也称为编译器——也是完整的程序，并且需要所有普通程序的功能。这将不得不创建一个纯粹用于处理程序的平行语言。这是浪费和无意义的；因此，Racket
    取而代之地赋予语法转换程序与 Racket 本身的全部功能。
- en: 'With that prelude, let’s now introduce syntax-case. We’ll begin by simply rewriting
    my-let-1 (under the name my-let-3) using this new notation. First, we have to
    write a header for the definition; notice already the explicit parameter:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个前提，现在让我们介绍一下语法情况。我们将从简单地使用这种新符号重写 my-let-1（以 my-let-3 的名称）开始。首先，我们必须为定义写一个头部；请注意已经存在的显式参数：
- en: '[<sc-macro-eg>](#(elem._(chunk._~3csc-macro-eg~3e~3a1))) ::='
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[<sc-macro-eg>](#(elem._(chunk._~3csc-macro-eg~3e~3a1))) ::='
- en: '| (define-syntax (my-let-3 x) |'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-syntax (my-let-3 x) |'
- en: '|   [<sc-macro-eg-body>](#(elem._(chunk._~3csc-macro-eg-body~3e~3a1)))) |'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [<sc-macro-eg-body>](#(elem._(chunk._~3csc-macro-eg-body~3e~3a1)))) |'
- en: This binds x to the entire (my-let-3 ...) expression.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 x 绑定到整个（my-let-3 ...）表达式。
- en: 'As you might imagine, define-syntax simply tells Racket you’re about to define
    a new macro. It does not pick precisely how you want to implement it, leaving
    you free to use any mechanism that’s convenient. Earlier we used syntax-rules;
    now we’re going to use syntax-case. In particular, syntax-case needs to explicitly
    be given access to the expression to pattern-match:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的那样，define-syntax 只是告诉Racket你要定义一个新的宏。它不会精确地挑选你想要实现它的方式，让你可以自由地使用任何方便的机制。之前我们使用了语法规则；现在我们要使用语法案例。特别是，语法案例需要显式地获得对表达式进行模式匹配的权限：
- en: '[<sc-macro-eg-body>](#(elem._(chunk._~3csc-macro-eg-body~3e~3a1))) ::='
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[<sc-macro-eg-body>](#(elem._(chunk._~3csc-macro-eg-body~3e~3a1))) ::='
- en: '| (syntax-case x () |'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (syntax-case x () |'
- en: '|   [<sc-macro-eg-rule>](#(elem._(chunk._~3csc-macro-eg-rule~3e~3a1)))) |'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [<sc-macro-eg-rule>](#(elem._(chunk._~3csc-macro-eg-rule~3e~3a1)))) |'
- en: 'Now we’re ready to express the rewrite we wanted. Previously a rewriting rule
    had two parts: the structure of the input and the corresponding output. The same
    holds here. The first (matching the input) is the same as before, but the second
    (the output) is a little different:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备表达我们想要的重写。先前的重写规则有两个部分：输入的结构和相应的输出。这里也是一样。第一个（匹配输入）与以前相同，但第二个（输出）有一点不同：
- en: '[<sc-macro-eg-rule>](#(elem._(chunk._~3csc-macro-eg-rule~3e~3a1))) ::='
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[<sc-macro-eg-rule>](#(elem._(chunk._~3csc-macro-eg-rule~3e~3a1))) ::='
- en: '| [(my-let-3 (var val) body) |'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(my-let-3 (var val) body) |'
- en: '|  #''((lambda (var) body) val)] |'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''((lambda (var) body) val)] |'
- en: 'Observe the crucial extra characters: #’. Let’s examine what that means.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 观察关键的额外字符：#’。让我们来看看这意味着什么。
- en: In syntax-rules, the entire output part simply specifies the structure of the
    output. In contrast, because syntax-case is laying bare the functional nature
    of transformation, the output part is in fact an arbitrary expression that may
    perform any computations it wishes. It must simply evaluate to a piece of syntax.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法规则中，整个输出部分仅仅指定了输出的结构。相比之下，因为语法案例暴露了转换的功能性质，输出部分实际上是一个任意表达式，可以执行任何它想要的计算。它只需要求值为一段语法。
- en: 'Syntax is actually a distinct datatype. As with any distinct dataype, it has
    its own rules for construction. Concretely, we construct syntax values by writing
    #’; the following s-expression is treated as a syntax value. (In case you were
    wondering, the x bound in the macro definition above is also of this datatype.)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '语法实际上是一个独立的数据类型。与任何独立数据类型一样，它有自己的构造规则。具体来说，我们通过编写 #’ 来构造语法值；以下的s表达式被视为语法值。（如果你在想，上面宏定义中的x也是这种数据类型。）'
- en: 'The syntax constructor, #’, enjoys a special property. Inside the output part
    of the macro, all syntax variables in the input are automatically bound, and replaced
    on occurrence. As a result, when the expander encounters var in the output, say,
    it replaces var with the corresponding part of the input expression.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 语法构造器，#’，具有特殊的属性。在宏的输出部分内，所有输入中的语法变量都会自动绑定，并在出现时替换。因此，当扩展器遇到输出中的变量时，比如说，它会用输入表达式的对应部分替换变量。
- en: Do Now!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始！
- en: 'Remove the #’ and try using the above macro definition. What happens?'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '去掉 #’ 然后尝试使用上述宏定义。会发生什么？'
- en: 'So far, syntax-case merely appears to be a more complicated form of syntax-rules:
    perhaps slightly better in that it more cleanly delineates the functional nature
    of expansion, and the type of output, but otherwise simply more unwieldy. As we
    will see, however, it also offers significant power.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，语法案例似乎只是语法规则的一个更复杂的形式：也许在更清晰地界定扩展的功能性质和输出类型方面稍微更好一些，但其他方面仅仅更加笨重。然而，正如我们将看到的，它也提供了显著的功能。
- en: Exercise
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: syntax-rules can actually be expressed as a macro over syntax-case. Define it.
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实际上，语法规则可以表达为对语法案例的宏。定义它。
- en: 13.3Guards
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3卫兵
- en: 'Now we can return to the problem that originally motivated the introduction
    of syntax-case: ensuring that the binding position of a my-let-3 is syntactically
    an identifier. For this, you need to know one new feature of syntax-case: each
    rewriting rule can have two parts (as above), or three. If there are three present,
    the middle one is treated as a guard: a predicate that must evaluate to true for
    expansion to proceed rather than signal a syntax error. Especially useful in this
    context is the predicate identifier?, which determines whether a syntax object
    is syntactically an identifier (or variable).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以回到最初引入 syntax-case 的问题：确保 my-let-3 的绑定位置在语法上是一个标识符。为此，你需要了解 syntax-case
    的一个新特性：每个重写规则可以有两部分（如上所示），或三部分。如果有三部分存在，中间的部分被视为保护条件：一个必须评估为真才能继续扩展而不是发出语法错误信号的谓词。在这种情况下特别有用的是谓词
    identifier?，它确定一个语法对象在语法上是否是标识符（或变量）。
- en: Do Now!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在！
- en: Write the guard and rewrite the rule to incorporate it.
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写保护条件并重写规则以包含它。
- en: 'Hopefully you stumbled on a subtlety: the argument to identifier? is of type
    syntax. It needs to refer to the actual fragment of syntax bound to var. Recall
    that var is bound in the syntax space, and #’ substitutes identifiers bound there.
    Therefore, the correct way to write the guard is:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你碰巧发现了一个微妙之处：identifier? 的参数是语法类型。它需要引用绑定到 var 的实际语法片段。回想一下，var 在语法空间中被绑定，#’
    用于替换那里绑定的标识符。因此，编写保护条件的正确方式是：
- en: '| (identifier? #''var) |'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (identifier? #''var) |'
- en: With this information, we can now write the entire rule:[<sc-macro-eg-guarded-rule>](#(elem._(chunk._~3csc-macro-eg-guarded-rule~3e~3a1)))
    ::=
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们现在可以编写整个规则：[<sc-macro-eg-guarded-rule>](#(elem._(chunk._~3csc-macro-eg-guarded-rule~3e~3a1)))
    ::=
- en: '| [(my-let-3 (var val) body) |'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [(my-let-3 (var val) body) |'
- en: '|  (identifier? #''var) |'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  (identifier? #''var) |'
- en: '|  #''((lambda (var) body) val)] |'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  #''((lambda (var) body) val)] |'
- en: Do Now!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在！
- en: Now that you have a guarded rule definition, try to use the macro with a non-identifier
    in the binding position and see what happens.
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在你有了一个受保护的规则定义，尝试在绑定位置使用一个非标识符的宏，看看会发生什么。
- en: '13.4Or: A Simple Macro with Many Features'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4Or：一个具有许多特性的简单宏
- en: Consider or, which implements disjunction. It is natural, with prefix syntax,
    to allow or to have an arbitrary number of sub-terms. We expand or into nested
    conditionals that determine the truth of the expression.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 or，它实现了析取。自然地，使用前缀语法，允许 or 有任意数量的子项。我们将 or 展开为嵌套的条件语句，以确定表达式的真值。
- en: 13.4.1A First Attempt
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.1第一次尝试
- en: 'Let’s try a first version of or:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试 or 的第一个版本：
- en: '| (define-syntax (my-or-1 x) |'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-syntax (my-or-1 x) |'
- en: '|   (syntax-case x () |'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (syntax-case x () |'
- en: '|     [(my-or-1 e0 e1 ...) |'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(my-or-1 e0 e1 ...) |'
- en: '|      #''(if e0 |'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      #''(if e0 |'
- en: '|            e0 |'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            e0 |'
- en: '|            (my-or-1 e1 ...))])) |'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            (my-or-1 e1 ...))])) |'
- en: 'It says that we can provide any number of sub-terms (more on this in a moment).
    Expansion rewrites this into a conditional that tests the first sub-term; if this
    is a true value it returns that value (more on this in a moment!), otherwise it
    is the disjunction of the remaining terms.Let’s try this on a simple example.
    We would expect this to evaluate to true, but instead:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它说我们可以提供任意数量的子项（稍后会详细介绍）。扩展将其重写为一个条件语句，测试第一个子项；如果这是一个真值，则返回该值（稍后会详细介绍！），否则是剩余项的析取。让我们在一个简单的例子上尝试一下。我们期望这将评估为真，但实际上：
- en: '| > (my-or-1 #f #t) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| > (my-or-1 #f #t) |'
- en: '| my-or-1: bad syntax in: (my-or-1) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| my-or-1: bad syntax in: (my-or-1) |'
- en: What happened? This expression turned into
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？这个表达式变成了
- en: '| (if #f |'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (if #f |'
- en: '|     #f |'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     #f |'
- en: '|     (my-or-1 #t)) |'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (my-or-1 #t)) |'
- en: which in turn expanded into
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这反过来又扩展为
- en: '| (if #f |'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (if #f |'
- en: '|     #f |'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     #f |'
- en: '|     (if #t |'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (if #t |'
- en: '|         #t |'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         #t |'
- en: '|         (my-or-1))) |'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         (my-or-1))) |'
- en: for which there is no definition. That’s because the pattern e0 e1 ... means
    one or more sub-terms, but we ignored the case when there are zero. What happens
    when there are no sub-terms? The identity for disjunction is falsehood.Exercise
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有定义的情况。这是因为模式 e0 e1 ... 意味着一个或多个子项，但我们忽略了当子项为零时的情况。当没有子项时会发生什么？析取的恒等式是 falsehood。练习
- en: 'Why is #f the right default?'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '为什么 #f 是正确的默认值？'
- en: 'By filling it in below, we illustrate a macro that has more than one rule.
    Macro rules are matched sequentially, so we should be sure to put the most specific
    rules first, lest they get overridden by more general ones (though in this particular
    case, the two rules are non-overlapping). This yields our improved macro:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过下面的填充，我们演示了一个具有多个规则的宏。宏规则是按顺序匹配的，因此我们应该确保首先放置最具体的规则，以免它们被更一般的规则覆盖（尽管在这种特殊情况下，这两个规则是不重叠的）。这产生了我们改进的宏：
- en: '| (define-syntax (my-or-2 x) |'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-syntax (my-or-2 x) |'
- en: '|   (syntax-case x () |'
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (syntax-case x () |'
- en: '|     [(my-or-2) |'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(my-or-2) |'
- en: '|      #''#f] |'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      #''#f] |'
- en: '|     [(my-or-2 e0 e1 ...) |'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(my-or-2 e0 e1 ...) |'
- en: '|      #''(if e0 |'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      #''(if e0 |'
- en: '|            e0 |'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            e0 |'
- en: '|            (my-or-2 e1 ...))])) |'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            (my-or-2 e1 ...))])) |'
- en: 'which now expands as we expect. In what follows, we will find it useful to
    have a special case when there is only a single sub-term:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在展开如我们所期望的那样。在接下来的内容中，当只有一个子项时，我们会发现有一个特殊情况是很有用的：
- en: '| (define-syntax (my-or-3 x) |'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-syntax (my-or-3 x) |'
- en: '|   (syntax-case x () |'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (syntax-case x () |'
- en: '|     [(my-or-3) |'
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(my-or-3) |'
- en: '|      #''#f] |'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      #''#f] |'
- en: '|     [(my-or-3 e) |'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(my-or-3 e) |'
- en: '|      #''e] |'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      #''e] |'
- en: '|     [(my-or-3 e0 e1 ...) |'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(my-or-3 e0 e1 ...) |'
- en: '|      #''(if e0 |'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      #''(if e0 |'
- en: '|            e0 |'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            e0 |'
- en: '|            (my-or-3 e1 ...))])) |'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            (my-or-3 e1 ...))])) |'
- en: 'This keeps the output of expansion more concise, which we will find useful
    below.Observe that in this version of the macro, the patterns are not disjoint:
    the third (one-or-more sub-terms) subsumes the second (one sub-term). Therefore,
    it is essential that the second rule not swap with the third.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得展开的输出更加简洁，这在下面会发现很有用。请注意，在这个版本的宏中，模式不是不相交的：第三个（一个或多个子项）包含第二个（一个子项）。因此，第二个规则不要与第三个规则交换是至关重要的。
- en: 13.4.2Guarding Evaluation
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.2Guarding Evaluation
- en: 'We said above that this expands as we expect. Or does it? Let’s try the following
    example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面说过，这展开如我们所期望的。但是真的吗？让我们尝试以下示例：
- en: '| (let ([init #f]) |'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([init #f]) |'
- en: '|   (my-or-3 (begin (set! init (not init)) |'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (my-or-3 (begin (set! init (not init)) |'
- en: '|                   init) |'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                   init) |'
- en: '|            #f)) |'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            #f)) |'
- en: 'Observe that or returns the actual value of the first “truthy” value, so the
    developer can use it in further computations. Therefore, this returns the value
    of init. What do we expect it to be? Naturally, because we’ve negated the value
    of init once, we expect it to be #t. But evaluating it produces #f! This problem
    is not an artifact of set!. If instead of internal mutation we had, say, printed
    output, the printing would have occurred twice.To understand why, we have to examine
    the expanded code. It is this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '注意到 or 返回第一个“真值”值的实际值，因此开发人员可以在进一步的计算中使用它。因此，这返回 init 的值。我们期望它是什么？自然地，因为我们对
    init 的值取反了一次，我们期望它是 #t。但是评估它产生了 #f！这个问题不是 set! 的产物。如果我们没有内部变异，而是打印输出，那么打印将发生两次。要理解为什么，我们必须检查展开的代码。就是这个：'
- en: '| (let ([init #f]) |'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([init #f]) |'
- en: '|   (if (begin (set! init (not init)) |'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (if (begin (set! init (not init)) |'
- en: '|              init) |'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              init) |'
- en: '|       (begin (set! init (not init)) |'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (begin (set! init (not init)) |'
- en: '|              init) |'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              init) |'
- en: '|       #f)) |'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       #f)) |'
- en: Aha! Because we’ve written the output pattern as
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！因为我们将输出模式写成
- en: '| #''(if e0 |'
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| #''(if e0 |'
- en: '|       e0 |'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       e0 |'
- en: '|       ...) |'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|       ...) |'
- en: 'This looked entirely benign when we first wrote it, but it illustrates a very
    important principle when writing macros (or indeed any other program transformation
    systems): do not copy code! In our setting, a syntactic variable should never
    be repeated; if you need to repeat it in a way that might cause multiple execution
    of that code, make sure you have considered the consequences of this. Alternatively,
    if you meant to work with the value of the expression, bind it once and use the
    bound identifier’s name subsequently. This is easy to demonstrate:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次编写时，这看起来完全无害，但它展示了在编写宏（或者任何其他程序转换系统）时一个非常重要的原则：不要复制代码！在我们的设置中，一个语法变量永远不应该被重复；如果你需要以可能导致该代码多次执行的方式重复它，请确保你已经考虑了这样做的后果。或者，如果你打算使用表达式的值，那么绑定一次并随后使用绑定的标识符名称。这很容易演示：
- en: '| (define-syntax (my-or-4 x) |'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-syntax (my-or-4 x) |'
- en: '|   (syntax-case x () |'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (syntax-case x () |'
- en: '|     [(my-or-4) |'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(my-or-4) |'
- en: '|      #''#f] |'
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      #''#f] |'
- en: '|     [(my-or-4 e) |'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(my-or-4 e) |'
- en: '|      #''e] |'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      #''e] |'
- en: '|     [(my-or-4 e0 e1 ...) |'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(my-or-4 e0 e1 ...) |'
- en: '|      #''(let ([v e0]) |'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      #''(let ([v e0]) |'
- en: '|          (if v |'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|          (if v |'
- en: '|              v |'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              v |'
- en: '|              (my-or-4 e1 ...)))])) |'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              (my-or-4 e1 ...)))])) |'
- en: 'This pattern of introducing a binding creates a new potential problem: you
    may end up evaluating expressions that weren’t necessary. In fact, it creates
    a second, even more subtle one: even if it going to be evaluated, you may evaluate
    it in the wrong context! Therefore, you have to reason carefully about whether
    an expression will be evaluated, and if so, evaluate it once in just the right
    place, then store that value for subsequent use.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 引入绑定的这种模式会产生一个新的潜在问题：你可能会评估不必要的表达式。实际上，它会产生一个更加微妙的问题：即使它要被评估，你也可能在错误的上下文中评估它！因此，你必须仔细考虑一个表达式是否会被评估，如果是的话，就在恰当的地方评估一次，然后将该值存储供后续使用。
- en: 'When we repeat our previous example, that contained the set!, with my-or-4,
    we see that the result is #t, as we would have hoped.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们重复包含 set! 的先前示例，使用 my-or-4，我们看到结果是 #t，正如我们所希望的那样。'
- en: 13.4.3Hygiene
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.3 卫生
- en: Hopefully now you’re nervous about something else.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 希望现在你对另一件事感到紧张。
- en: Do Now!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在做！
- en: What?
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 什么？
- en: 'Consider the macro (let ([v #t]) (my-or-4 #f v)). What would we expect this
    to compute? Naturally, #t: the first branch is #f but the second is v, which is
    bound to #t. But let’s look at the expansion:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑一下宏 (let ([v #t]) (my-or-4 #f v))。我们期望这会计算什么？当然是 #t：第一个分支是 #f，但第二个是 v，而 v
    绑定到 #t。但是让我们来看一下展开：'
- en: '| (let ([v #t]) |'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([v #t]) |'
- en: '|   (let ([v #f]) |'
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (let ([v #f]) |'
- en: '|     (if v |'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (if v |'
- en: '|         v |'
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         v |'
- en: '|         v))) |'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|         v))) |'
- en: 'This expression, when run directly, evaluates to #f. However, (let ([v #t])
    (my-or-4 #f v)) evaluates to #t. In other words, the macro seems to magically
    produce the right value: the names of identifiers chosen in the macro seem to
    be independent of those introduced by the macro! This is unsurprising when it
    happens in a function; the macro expander enjoys a property called hygiene that
    gives it the same property.One way to think about hygiene is that it effectively
    automatically renames all bound identifiers. That is, it’s as if the program expands
    as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '这个表达式，当直接运行时，会评估为 #f。然而，(let ([v #t]) (my-or-4 #f v)) 会评估为 #t。换句话说，这个宏似乎神奇地产生了正确的值：宏中选择的标识符名称似乎与宏引入的名称无关！当它发生在函数中时，这并不奇怪；宏展开器具有称为卫生的属性，使其具有相同的属性。关于卫生的一种思考方式是，它有效地自动重命名了所有绑定的标识符。也就是说，程序的展开如下所示：'
- en: '| (let ([v #t]) |'
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([v #t]) |'
- en: '|   (or #f v)) |'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (or #f v)) |'
- en: turns into
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 转变成了
- en: '| (let ([v1 #t]) |'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([v1 #t]) |'
- en: '|   (or #f v1)) |'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (or #f v1)) |'
- en: (notice the consistent renaming of v to v1), which turns into
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意 v 的一致重命名为 v1），变成了
- en: '| (let ([v1 #t]) |'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([v1 #t]) |'
- en: '|   (let ([v #f]) |'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (let ([v #f]) |'
- en: '|        v |'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|        v |'
- en: '|        v1)) |'
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|        v1)) |'
- en: which, after renaming, becomes
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，经过重命名，变成了
- en: '| (let ([v1 #t]) |'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([v1 #t]) |'
- en: '|   (let ([v2 #f]) |'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (let ([v2 #f]) |'
- en: '|        v2 |'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|        v2 |'
- en: '|        v1)) |'
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|        v1)) |'
- en: when expansion terminates. Observe that each of the programs above, if run directly,
    will produce the correct answer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当扩展终止时。请注意，上述每个程序，如果直接运行，都将产生正确的答案。
- en: 13.5Identifier Capture
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5 标识符捕获
- en: 'Hygienic macros address a routine and important pain that creators of syntactic
    sugar confront. On rare instances, however, a developer wants to intentionally
    break hygiene. Returning to objects, consider this input program:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 卫生宏解决了创建语法糖的创作者面临的一个常规而重要的问题。但在极少数情况下，开发人员希望有意地打破卫生习惯。回到对象，考虑以下输入程序：
- en: '| (define os-1 |'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define os-1 |'
- en: '|   (object/self-1 |'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (object/self-1 |'
- en: '|    [first (x) (msg self ''second (+ x 1))] |'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    [first (x) (msg self ''second (+ x 1))] |'
- en: '|    [second (x) (+ x 1)])) |'
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    [second (x) (+ x 1)])) |'
- en: 'What does the macro look like? Here’s an obvious candidate:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏是什么样子？这是一个明显的候选人：
- en: '| (define-syntax object/self-1 |'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-syntax object/self-1 |'
- en: '|   (syntax-rules () |'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (syntax-rules () |'
- en: '|     [(object [mtd-name (var) val] ...) |'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(对象 [mtd-name (var) val] ...) |'
- en: '|      (let ([self (lambda (msg-name) |'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (let ([self (lambda (msg-name) |'
- en: '|                    (lambda (v) (error ''object "nothing here")))]) |'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    (lambda (v) (error ''object "nothing here")))]) |'
- en: '|        (begin |'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|        (begin |'
- en: '|          (set! self |'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|          (set! self |'
- en: '|                (lambda (msg) |'
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                (lambda (msg) |'
- en: '|                  (case msg |'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                  (case msg |'
- en: '|                    [(mtd-name) (lambda (var) val)] |'
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    [(mtd-name) (lambda (var) val)] |'
- en: '|                  ...))) |'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                  ...))) |'
- en: '|          self))])) |'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|          self))])) |'
- en: 'Unfortunately, this macro produces the following error:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个宏产生了以下错误：
- en: '| self: unbound identifier in module in: self |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| self: unbound identifier in module in: self |'
- en: which is referring to the self in the body of the method bound to first.Exercise
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是指向绑定到 first 方法体内的 self。练习
- en: Work through the hygienic expansion process to understand why error is the expected
    outcome.
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过卫生扩展过程来理解为什么错误是预期结果。
- en: 'Before we jump to the richer macro, let’s consider a variant of the input term
    that makes the binding explicit:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳转到更丰富的宏之前，让我们考虑一个使绑定明确的输入项的变体：
- en: '| (define os-2 |'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define os-2 |'
- en: '|   (object/self-2 self |'
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (object/self-2 self |'
- en: '|    [first (x) (msg self ''second (+ x 1))] |'
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    [first (x) (msg self ''second (+ x 1))] |'
- en: '|    [second (x) (+ x 1)])) |'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    [second (x) (+ x 1)])) |'
- en: 'The corresponding macro is a small variation on what we had before:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的宏是我们之前所说的一个小变化：
- en: '| (define-syntax object/self-2 |'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-syntax object/self-2 |'
- en: '|   (syntax-rules () |'
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (syntax-rules () |'
- en: '|     [(object self [mtd-name (var) val] ...) |'
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(object self [mtd-name (var) val] ...) |'
- en: '|      (let ([self (lambda (msg-name) |'
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (let ([self (lambda (msg-name) |'
- en: '|                    (lambda (v) (error ''object "nothing here")))]) |'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    (lambda (v) (error ''object "nothing here")))]) |'
- en: '|        (begin |'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|        (begin |'
- en: '|          (set! self |'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|          (set! self |'
- en: '|                (lambda (msg) |'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                (lambda (msg) |'
- en: '|                  (case msg |'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                  (case msg |'
- en: '|                    [(mtd-name) (lambda (var) val)] |'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    [(mtd-name) (lambda (var) val)] |'
- en: '|                  ...))) |'
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                  ...))) |'
- en: '|          self))])) |'
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|          self))])) |'
- en: This macro expands without difficulty.Exercise
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏扩展没有困难。练习
- en: Work through the expansion of this version and see what’s different.
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过扩展这个版本，看看有什么不同。
- en: 'This offers a critical insight: had the identifier that goes in the binding
    position been written by the macro user, there would have been no problem. Therefore,
    we want to be able to pretend that the introduced identifier was written by the
    user. The function datum->syntax converts the s-expression in its second argument;
    its first argument is which syntax to pretend it was a part of (in our case, the
    original macro use, which is bound to x). To introduce the result into the environment
    used for expansion, we use with-syntax to bind it in that environment:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个关键的见解：如果在绑定位置写入的标识符是��宏用户编写的，那么就不会有问题。因此，我们希望能够假装引入的标识符是由用户编写的。函数 datum->syntax
    将第二个参数中的 s 表达式转换；它的第一个参数是要假装它是哪个语法的一部分（在我们的情况下，原始宏使用，它绑定到 x）。为了将结果引入用于扩展的环境中，我们使用
    with-syntax 将其绑定在该环境中：
- en: '| (define-syntax (object/self-3 x) |'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-syntax (object/self-3 x) |'
- en: '|   (syntax-case x () |'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (syntax-case x () |'
- en: '|     [(object [mtd-name (var) val] ...) |'
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(object [mtd-name (var) val] ...) |'
- en: '|      (with-syntax ([self (datum->syntax x ''self)]) |'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (with-syntax ([self (datum->syntax x ''self)]) |'
- en: '|        #''(let ([self (lambda (msg-name) |'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|        #''(let ([self (lambda (msg-name) |'
- en: '|                        (lambda (v) (error ''object "nothing here")))]) |'
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                        (lambda (v) (error ''object "nothing here")))]) |'
- en: '|            (begin |'
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|            (begin |'
- en: '|              (set! self |'
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              (set! self |'
- en: '|                    (lambda (msg-name) |'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    (lambda (msg-name) |'
- en: '|                      (case msg-name |'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                      (case msg-name |'
- en: '|                        [(mtd-name) (lambda (var) val)] |'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                        [(mtd-name) (lambda (var) val)] |'
- en: '|                        ...))) |'
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                        ...))) |'
- en: '|              self)))])) |'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|              self)))])) |'
- en: 'With this, we can go back to having self be implicit:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以重新让 self 成为隐式的：
- en: '| (define os-3 |'
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define os-3 |'
- en: '|   (object/self-3 |'
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (object/self-3 |'
- en: '|    [first (x) (msg self ''second (+ x 1))] |'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    [first (x) (msg self ''second (+ x 1))] |'
- en: '|    [second (x) (+ x 1)])) |'
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    [second (x) (+ x 1)])) |'
- en: 13.6Influence on Compiler Design
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.6对编译器设计的影响
- en: 'The use of macros in a language’s definition has an impact on all tools, especially
    compilers. As a working example, consider let. let has the virtue that it can
    be compiled efficiently, by just extending the current environment. In contrast,
    the expansion of let into function application results in a much more expensive
    operation: the creation of a closure and its application to the argument, achieving
    effectively the same result but at the cost of more time (and often space).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在语言定义中使用宏对所有工具，特别是编译器产生影响。作为一个工作示例，考虑 let。let 的优点在于它可以通过简单地扩展当前环境来高效地编译。相比之下，将
    let 扩展为函数应用会导致一个更昂贵的操作：创建一个闭包并将其应用于参数，实际上实现了相同的结果，但以更多的时间（通常还有空间）为代价。
- en: This would seem to be an argument against using the macro. However, a smart
    compiler recognizes that this pattern occurs often, and instead internally effectively
    converts left-left-lambda [REF] back into the equivalent of let. This has two
    advantages. First, it means the language designer can freely use macros to obtain
    a smaller core language, rather than having to trade that off against the execution
    cost.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是反对使用宏的一个论点。然而，一个聪明的编译器会意识到这种模式经常出现，并且内部有效地将左-左-λ [REF]转换为等效的let。这有两个优点。首先，这意味着语言设计者可以自由地使用宏来获得一个更小的核心语言，而不必将其与执行成本相抵消。
- en: It has a second, much subtler, advantage. Because the compiler recognizes this
    pattern, other macros can also exploit it and obtain the same optimization; they
    don’t need to contort their output to insert let terms if the left-left-lambda
    pattern occurs naturally, as they would have to do otherwise. For instance, the
    left-left-lambda pattern occurs naturally when writing certain kinds of pattern-matchers,
    but it would take an extra step to convert this into a let in the expansion—<wbr>which
    is no longer necessary.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有第二个更微妙的优势。因为编译器识别了这种模式，其他宏也可以利用它并获得相同的优化；它们不需要扭曲其输出以插入let项，如果左-左-λ模式自然发生，它们就不需要这样做。例如，当编写某些类型的模式匹配器时，左-左-λ模式会自然发生，但将其转换为扩展中的let需要额外的步骤—<wbr>这不再是必要的。
- en: 13.7Desugaring in Other Languages
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.7其他语言中的解糖
- en: Many modern languages define operations via desguaring, not only Racket. In
    Python, for instance, iterating using for is simply a syntactic pattern. A developer
    who writes for x in o is
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代语言通过解糖来定义操作，不仅仅是Racket。例如，在Python中，使用for进行迭代只是一种语法模式。编写for x in o的开发人员是
- en: introducing a new identifier (call it i—<wbr>but be sure to not capture any
    other i the programmer has already defined, i.e., bind i hygienically!),
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入一个新的标识符（称之为i—<wbr>但一定不要捕获程序员已经定义的任何其他i，即要卫生地绑定i！），
- en: binding it to an iterator obtained from o, and
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其绑定到从o获得的迭代器，并
- en: creating a (potentially) infinite while loop that repeatedly invokes the .next
    method of i until the iterator raises the StopIteration exception.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个（可能）无限的while循环，重复调用i的.next方法，直到迭代器引发StopIteration异常。
- en: There are many such patterns in modern programming languages.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现代编程语言中有许多这样的模式。
