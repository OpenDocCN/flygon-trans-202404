- en: '"Why use F#?" in one page'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although F# is great for specialist areas such as scientific or data analysis,
    it is also an excellent choice for enterprise development. Here are five good
    reasons why you should consider using F# for your next project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](glyphicons_030_pencil.png) Conciseness'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# is not cluttered up with [coding "noise"](fvsc-sum-of-squares.html) such
    as curly brackets, semicolons and so on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: You almost never have to specify the type of an object, thanks to a powerful
    [type inference system](conciseness-type-inference.html).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: And, compared with C#, it generally takes [fewer lines of code](fvsc-download.html)
    to solve the same problem.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](glyphicons_343_thumbs_up.png) Convenience'
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many common programming tasks are much simpler in F#. This includes things like
    creating and using [complex type definitions](conciseness-type-definitions.html),
    doing [list processing](conciseness-extracting-boilerplate.html), [comparison
    and equality](convenience-types.html), [state machines](designing-with-types-representing-states.html),
    and much more.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: And because functions are first class objects, it is very easy to create powerful
    and reusable code by creating functions that have [other functions as parameters](conciseness-extracting-boilerplate.html),
    or that [combine existing functions](conciseness-functions-as-building-blocks.html)
    to create new functionality.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](glyphicons_150_check.png) Correctness'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# has a [powerful type system](correctness-type-checking.html) which prevents
    many common errors such as [null reference exceptions](the-option-type.html#option-is-not-null).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Values are [immutable by default](correctness-immutability.html), which prevents
    a large class of errors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you can often encode business logic using the [type system](correctness-exhaustive-pattern-matching.html)
    itself in such a way that it is actually [impossible to write incorrect code](designing-for-correctness.html)
    or mix up [units of measure](units-of-measure.html), greatly reducing the need
    for unit tests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](glyphicons_054_clock.png) Concurrency'
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# has a number of built-in libraries to help when more than one thing at a
    time is happening. Asynchronous programming is [very easy](concurrency-async-and-parallel.html),
    as is parallelism.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: F# also has a built-in [actor model](concurrency-actor-model.html), and excellent
    support for event handling and [functional reactive programming](concurrency-reactive.html).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: And of course, because data structures are immutable by default, sharing state
    and avoiding locks is much easier.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](glyphicons_280_settings.png) Completeness'
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although it is a functional language at heart, F# does support other styles
    which are not 100% pure, which makes it much easier to interact with the non-pure
    world of web sites, databases, other applications, and so on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: In particular, F# is designed as a hybrid functional/OO language, so it can
    do [virtually everything that C# can do](completeness-anything-csharp-can-do.html).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Of course, F# is [part of the .NET ecosystem](completeness-seamless-dotnet-interop.html),
    which gives you seamless access to all the third party .NET libraries and tools.
    It runs on most platforms, including Linux and smart phones (via Mono and the
    new .NET Core).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is well integrated with Visual Studio (Windows) and Xamarin (Mac),
    which means you get a great IDE with IntelliSense support, a debugger, and many
    plug-ins for unit tests, source control, and other development tasks. Or on Linux,
    you can use the MonoDevelop IDE instead.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The "Why Use F#?" series
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following series of posts demonstrates each of these F# benefits, using
    standalone snippets of F# code (and often with C# code for comparison).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[Introduction to the ''Why use F#'' series](why-use-fsharp-intro.html). An
    overview of the benefits of F#'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F# syntax in 60 seconds](fsharp-in-60-seconds.html). A very quick overview
    on how to read F# code'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Comparing F# with C#: A simple sum](fvsc-sum-of-squares.html). In which we
    attempt to sum the squares from 1 to N without using a loop'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Comparing F# with C#: Sorting](fvsc-quicksort.html). In which we see that
    F# is more declarative than C#, and we are introduced to pattern matching.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Comparing F# with C#: Downloading a web page](fvsc-download.html). In which
    we see that F# excels at callbacks, and we are introduced to the ''use'' keyword'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Four Key Concepts](key-concepts.html). The concepts that differentiate F#
    from a standard imperative language'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conciseness](conciseness-intro.html). Why is conciseness important?'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Type inference](conciseness-type-inference.html). How to avoid getting distracted
    by complex type syntax'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Low overhead type definitions](conciseness-type-definitions.html). No penalty
    for making new types'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using functions to extract boilerplate code](conciseness-extracting-boilerplate.html).
    The functional approach to the DRY principle'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using functions as building blocks](conciseness-functions-as-building-blocks.html).
    Function composition and mini-languages make code more readable'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pattern matching for conciseness](conciseness-pattern-matching.html). Pattern
    matching can match and bind in a single step'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Convenience](convenience-intro.html). Features that reduce programming drudgery
    and boilerplate code'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Out-of-the-box behavior for types](convenience-types.html). Immutability and
    built-in equality with no coding'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Functions as interfaces](convenience-functions-as-interfaces.html). OO design
    patterns can be trivial when functions are used'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Partial Application](convenience-partial-application.html). How to fix some
    of a function''s parameters'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Active patterns](convenience-active-patterns.html). Dynamic patterns for powerful
    matching'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Correctness](correctness-intro.html). How to write ''compile time unit tests'''
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Immutability](correctness-immutability.html). Making your code predictable'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exhaustive pattern matching](correctness-exhaustive-pattern-matching.html).
    A powerful technique to ensure correctness'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using the type system to ensure correct code](correctness-type-checking.html).
    In F# the type system is your friend, not your enemy'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[利用类型系统确保正确的代码](correctness-type-checking.html)。在 F# 中，类型系统是你的朋友，而不是敌人'
- en: '[Worked example: Designing for correctness](designing-for-correctness.html).
    How to make illegal states unrepresentable'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：为正确性设计](designing-for-correctness.html)。如何使非法状态不可表示'
- en: '[Concurrency](concurrency-intro.html). The next major revolution in how we
    write software?'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[并发性](concurrency-intro.html)。我们编写软件的下一个重大革命？'
- en: '[Asynchronous programming](concurrency-async-and-parallel.html). Encapsulating
    a background task with the Async class'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[异步编程](concurrency-async-and-parallel.html)。使用 Async 类封装后台任务'
- en: '[Messages and Agents](concurrency-actor-model.html). Making it easier to think
    about concurrency'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[消息和代理](concurrency-actor-model.html)。让并发思考变得更容易'
- en: '[Functional Reactive Programming](concurrency-reactive.html). Turning events
    into streams'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[函数式响应式编程](concurrency-reactive.html)。将事件转化为流'
- en: '[Completeness](completeness-intro.html). F# is part of the whole .NET ecosystem'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[完整性](completeness-intro.html)。F# 是整个 .NET 生态系统的一部分'
- en: '[Seamless interoperation with .NET libraries](completeness-seamless-dotnet-interop.html).
    Some convenient features for working with .NET libraries'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[与 .NET 库无缝互操作](completeness-seamless-dotnet-interop.html)。与 .NET 库一起工作的一些便利功能'
- en: '[Anything C# can do...](completeness-anything-csharp-can-do.html). A whirlwind
    tour of object-oriented code in F#'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C# 能做的任何事情...](completeness-anything-csharp-can-do.html)。在 F# 中进行面向对象编程的快速浏览'
- en: '[Why use F#: Conclusion](why-use-fsharp-conclusion.html).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[为什么使用 F#：结论](why-use-fsharp-conclusion.html)。'
