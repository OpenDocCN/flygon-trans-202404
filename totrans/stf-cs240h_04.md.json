["```\n    import Control.Concurrent import Control.Monad type Account = MVar Double transfer :: Double -> Account -> Account -> IO () transfer amount from to = ???\n    ```", "```\n    *Main> :load \"transfer.hs\" Ok, modules loaded: Main. *Main> main 9.0 1.0\n    ```", "```\ntype Account = MVar Double transfer :: Double -> Account -> Account -> IO () transfer amount from to = modifyMVar_ from $ \\bf -> do when (bf < amount) $ fail \"not enough money\" modifyMVar_ to $ \\bt -> return $! bt + amount return $! bf - amount\n```", "```\ntype Account = MVar Double transfer :: Double -> Account -> Account -> IO () transfer amount from to = modifyMVar_ from $ \\bf -> do when (bf < amount) $ fail \"not enough money\" modifyMVar_ to $ \\bt -> return $! bt + amount return $! bf - amount\n```", "```\n        forkIO $ transfer 1 ac1 ac2 forkIO $ transfer 1 ac2 ac1\n        ```", "```\ntransfer :: Double -> Account -> Account -> IO () transfer amount from to = do let tryTransfer = modifyMVar from $ \\ bf -> do when (bf < amount) $ fail \"not enough money\" mbt <- tryTakeMVar to case mbt of Just bt -> do putMVar to $! bt + amount return (bf - amount, True) Nothing -> return (bf, False) ok <- tryTransfer unless ok $ safetransfer (- amount) to from\n```", "```\n    newTVarIO :: a -> IO (TVar a) readTVarIO :: TVar a -> IO a readTVar :: TVar a -> STM a writeTVar :: TVar a -> a -> STM () modifyTVar :: TVar a -> (a -> a) -> STM () -- lazy modifyTVar' :: TVar a -> (a -> a) -> STM () -- strict\n    ```", "```\n    atomically :: STM a -> IO a\n    ```", "```\ntype Account = TVar Double transfer :: Double -> Account -> Account -> STM () transfer amount from to = do modifyTVar' from (subtract amount) modifyTVar' to (+ amount) main :: IO () main = do ac1 <- newTVarIO 10 ac2 <- newTVarIO 0 atomically $ transfer 1 ac1 ac2\n```", "```\nretry :: STM a orElse :: STM a -> STM a -> STM a\n```", "```\n    transfer :: Double -> Account -> Account -> STM () transfer amount from to = do bf <- readTVar from when (amount > bf) retry modifyTVar' from (subtract amount) modifyTVar' to (+ amount)\n    ```", "```\n    transfer2 :: Double -> Account -> Account -> Account -> STM () transfer2 amount from1 from2 to = atomically $ transferSTM amount from1 to `orElse` transferSTM amount from2 to\n    ```", "```\nalwaysSucceeds :: STM a -> STM ()\n```", "```\nnewAccount :: Double -> STM Account newAccount balance = do tv <- newTVar balance alwaysSucceeds $ do balance <- readTVar tv when (balance < 0) $ fail \"negative balance\" return tv bogus :: IO () bogus = do ac <- atomically $ newAccount 10 atomically $ modifyTVar ac (subtract 15)\n```", "```\n*Main> bogus *** Exception: negative balance\n```", "```\n    struct Val { unsigned long constrno; /* constructor # */ struct Val *args[]; /* flexible array */ };\n    ```", "```\ntypedef struct Val { const struct ValInfo *info; struct Val *args[]; } Val; /* Statically allocated at compile time. Only one per  * constructor (or closure-creating expression, etc.) */ struct ValInfo { struct GCInfo gcInfo; /* for garbage collector */ enum { CONSTRNO, FUNC, THUNK, IND } tag; union { unsigned int constrno; Val *(*func) (const Val *closure, const Val *arg); Exception *(*thunk) (Val *closure); }; };\n```", "```\n     Val *(*func) (const Val *closure, const Val *arg);\n    ```", "```\n     f->info->func (f, a);\n    ```", "```\n    addOne :: Int -> Int addOne x = x + 1\n    ```", "```\n    add :: Int -> (Int -> Int) add n = \\m -> addn m where addn m = n + m\n    ```", "```\n     Exception *(*thunk) (Val *closure);\n    ```", "```\n     v->info->thunk (v);\n    ```", "```\n    Exception *force (Val **vp) { for (;;) { if ((*vp)->info->tag == IND) *vp = (*vp)->arg[0]; else if ((*vp)->info->tag == THUNK) { Exception *e = (*vp)->info->thunk (*vp); if (e) return e; } else return NULL; } }\n    ```", "```\n    const3 :: a -> b -> c -> a const3 a b c = a\n    ```", "```\n     let f = const3 (superExpensive 5) -- v1, evaluated once in (f 1 2, f 3 4)\n    ```", "```\nconst3 :: a -> b -> c -> a const3 a b c = a\n```", "```\nVal *const3_1 (Val *ignored, Val *a) { v = (Val *) gc_malloc (offsetof (Val, args[1])); v->info = &const3_2_info; /* func = const3_2 */ v->args[0] = a; return v; } Val *const3_2 (Val *closure, Val *b) { v = (Val *) gc_malloc (offsetof (Val, args[2])); v->info = &const3_3_info; /* func = const3_3 */ v->args[0] = b; v->args[1] = closure; return v; } Val *const3_3 (Val *v, Val *c) { return v->args[1]->args[0]; }\n```", "```\n    union Arg { struct Val *boxed; /* most values are boxed */ unsigned long unboxed; /* \"primitive\" values */ }; typedef struct Val { const struct ValInfo *info; union Arg args[]; /* args can be boxed or unboxed */ } Val;\n    ```", "```\n    Prelude> :set -XMagicHash Prelude> :m +GHC.Types GHC.Prim Prelude GHC.Types GHC.Prim> :i Int data Int = I# Int# -- Defined in GHC.Types ... Prelude GHC.Types GHC.Prim> case 1 of I# u -> I# (u +# 2#) 3\n    ```", "```\n    {-# LANGUAGE MagicHash #-} import GHC.Prim data FastPoint = FastPoint Double# Double# -- ok fp = FastPoint 2.0## 2.0## -- ok -- Error: can't pass unboxed type to polymorphic function fp' = FastPoint 2.0## (id 2.0##) -- Error: can't use unboxed type as type parameter noInt :: Maybe Int# noInt = Nothing\n    ```", "```\n    Prelude GHC.Types GHC.Prim> :kind Int# Int# :: #\n    ```", "```\n    infiniteLoop = infiniteLoop :: Char -- loops forever seqTest1 = infiniteLoop `seq` \"Hello\" -- loops forever seqTest2 = str `seq` length str -- returns 6 where str = infiniteLoop:\"Hello\"\n    ```", "```\nconst struct ValInfo seq_info = { some_gcinfo, THUNK, .thunk = &seq_thunk }; Val *seq_2 (Val *closure, Val *b) { /* assume seq_1 put first arg of (seq a b) in closure */ c = (Val *) gc_malloc (offsetof (Val, args[2])); c->info = &seq_info; c->args[0] = closure->args[0]; c->args[1] = b; return c; } Exception *seq_thunk (Void *c) { Exception *e = force (&c->args[0]); if (!e) { c->info = &ind_info; /* ValInfo with tag = IND */ c->args[0] = c->args[1]; /* forward to b */ } return e; }\n```", "```\n    data IntWrapper = IntWrapper !Int\n    ```", "```\n         myIntWrapper.arg[0].boxed->arg[0].unboxed\n        ```", "```\n    data SMaybe a = SJust !a | SNothing -- ok, data field strictAdd :: !Int -> !Int -> !Int -- error type StrictMaybeInt = Maybe !Int -- error\n    ```", "```\n    f ('a':'b':rest) = rest f _ = \"ok\" test1 = f (undefined:[]) -- error test2 = f ('a':undefined) -- error test3 = f ('x':undefined) -- \"ok\" (didn't force tail)\n    ```", "```\n    three = (\\ ~(h:t) -> 3) undefined -- evaluates to 3\n    ```", "```\n    newtype NTInt = NTInt Int deriving (Show)\n    ```", "```\n    data SInt = SInt !Int deriving (Show)\n    ```", "```\n    uNTInt = NTInt undefined uSInt = SInt undefined\n    ```", "```\n    newtype NTInt = NTInt Int deriving (Show)\n    ```", "```\n    data SInt = SInt !Int deriving (Show)\n    ```", "```\n    newtype NTInt = NTInt Int deriving (Show) uNTInt = NTInt undefined testNT = case uNTInt of NTInt _ -> True -- returns True\n    ```", "```\n    data SInt = SInt !Int deriving (Show) uSInt = SInt undefined testS = case uSInt of SInt _ -> True -- undefined\n    ```", "```\n    data TwoInts = TwoInts !Int !Int\n    ```", "```\n        data TwoInts = TwoInts {-# UNPACK #-} !Int {-# UNPACK #-} !Int\n        ```", "```\n    import qualified Data.ByteString as S import qualified Data.ByteString.Char8 as S8\n    ```", "```\n    data ByteString = PS {-# UNPACK #-} !(ForeignPtr Word8) {-# UNPACK #-} !Int -- offset {-# UNPACK #-} !Int -- length\n    ```", "```\n    import qualified Data.ByteString.Lazy as L import qualified Data.ByteString.Lazy.Char8 as L8\n    ```", "```\n    fromChunks :: [S.ByteString] -> L.ByteString toChunks :: L.ByteString -> [S.ByteString]\n    ```", "```\n    data ByteString = Empty | Chunk {-# UNPACK #-} !S.ByteString ByteString\n    ```"]