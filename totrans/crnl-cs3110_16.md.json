["```\nmodule type SET = sig\n  type 'a set\n  val empty : 'a set\n  val mem : 'a -> 'a set -> bool\n  val add : 'a -> 'a set -> 'a set\n  val rem : 'a -> 'a set -> 'a set\n  val size: 'a set -> int\n  val union: 'a set -> 'a set -> 'a set\n  val inter: 'a set -> 'a set -> 'a set\nend\n\n```", "```\n(* Implementation of sets as lists with duplicates *)\n\nmodule Set1 : SET = struct\n  type 'a set = 'a list\n  let empty = []\n  let mem = List.mem\n  let add x l = x :: l\n  let rem x = List.filter ((<>) x)\n  let rec size l = \n    match l with\n    | [] -> 0\n    | h :: t -> size t + (if mem h t then 0 else 1)\n  let union l1 l2 = l1 @ l2\n  let inter l1 l2 = List.filter (fun h -> mem h l2) l1\nend\n\n```", "```\n(* Implementation of sets as lists without duplicates *)\n\nmodule Set2 : SET = struct\n  type 'a set = 'a list\n  let empty = []\n  let mem = List.mem\n  (* add checks if already a member *)\n  let add x l = if mem x l then l else x :: l \n  let rem x = List.filter ((<>) x)\n  let size = List.length (* size is just length if no duplicates *)\n  let union l1 l2 = (* check if already in other set *)\n    List.fold_left (fun a x -> if mem x l2 then a else x :: a) l2 l1\n  let inter l1 l2 = List.filter (fun h -> mem h l2) l1\nend\n\n```", "```\nmodule Set1 : SET = struct\n  (* Abstraction function: the list [a1; ...; an] represents the\n   * smallest set containing all the elements a1, ..., an.\n   * The list may contain duplicates.\n   * [] represents the empty set.\n   *)\n  type 'a set = 'a list\n  ...\n\n```", "```\nmodule Set2 : SET = struct\n  (* Abstraction function: the list [a1; ...; an] represents the set\n   * {a1, ..., an}.  [] represents the empty set.\n   *)\n  type 'a set = 'a list\n  ...\n\n```", "```\nlet size = List.length\n\n```", "```\nlet rec size l = \n  match l with\n  | [] -> 0\n  | h :: t -> size t + (if mem h t then 0 else 1)\n\n```", "```\nmodule Set2 : SET = struct\n  (* Abstraction function: the list [a1; ...; an] represents the set\n   * {a1, ..., an}.  [] represents the empty set.\n   *\n   * Representation invariant: the list contains no duplicates.\n   *)\n  type 'a set = 'a list\n  ...\n\n```", "```\n(* Checks whether x satisfies the representation invariant. *)\nlet repOK (x : int list) : int list = ...\n\n```", "```\nTurn on Javascript to see the program.\n\n```"]