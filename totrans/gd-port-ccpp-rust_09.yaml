- en: Compiling and Linking in More Detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compiling and Linking in More Detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your main() entry point
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust has a main function just like C/C++ which is usually called `main()`. ^([1](#fn_1))
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t take any arguments and it doesn’t return anything unlike C/C++. Let's
    see how we might do those things.
  prefs: []
  type: TYPE_NORMAL
- en: Processing command-line arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C/C++, the entry point takes argc, and argv arguments. Argc is the number
    of arguments and argv is an array of char * pointers that specify those arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Processing arguments can become inordinately complex (and buggy) so most software
    will use a function like `getopt()` or `getopt_long()` to simplify the process.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `getopt()` is not a standard C function and is not portable, e.g.
    to Windows. So immediately we see an example of problem that C/C++ forces us to
    solve.
  prefs: []
  type: TYPE_NORMAL
- en: Rust doesn't process arguments this way. Instead you access the command-line
    parameters from `std::env::args()` from anywhere in the code. That is to say,
    there is a function called `args()` under the namespace `std::env` that returns
    the strings on the command-line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `args()` returns the parameters in a string array. As with C++,
    the first element of the array at index 0 is the command itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, since `args()` returns a type called `Args` that implements
    the `Iterator` trait you can collect the arguments up into your own collection
    and process that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see some clear advantages to how Rust supplies args:'
  prefs: []
  type: TYPE_NORMAL
- en: You don't need a separate argc, parameter. You have an array that defines its
    own length.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can access arguments from anywhere in your program, not just from the `main()`.
    In C++ you would have to pass your args around from one place to another. In Rust
    you can simply ask for them from anywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a crate - easy command-line processing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rust has a number of crates for processing arguments. The most popular crate
    for processing arguments is [clap](https://crates.io/crates/clap).
  prefs: []
  type: TYPE_NORMAL
- en: It provides a very descriptive, declarative way of adding rules for processing
    arguments into the code. It is especially useful if your program takes a lot of
    arguments, including parameters and validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example we add this to `Cargo.toml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: And in our `main.rs`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code will process arguments for `-T` or `--timetowait` and ensure the value
    is one of 3 accepted. And if the user doesn't supply a value, it defaults to `10`.
    And if the user doesn't supply a valid integer it will terminate the application
    with a useful error.
  prefs: []
  type: TYPE_NORMAL
- en: The user can also provide `--help` as an argument and it will print out the
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: Exit code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to exit with a code, you set it explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When `main()` drops out, the runtime cleans up and returns the code to the environment.
    Again there is no reason the status code has to be set in `main()`, you could
    set it somewhere else and `panic!()` to cause the application to exit.
  prefs: []
  type: TYPE_NORMAL
- en: Optimized compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a typical edit / compile / debug cycle there is no need to optimize code
    and so Rust doesn't optimize unless you ask it to.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization takes longer to happen and can reorder the code so that backtraces
    and debugging may not point at the proper lines of code in the source.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to optimize your code, add a -O argument to rustc:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The act of optimization will cause Rust to invoke the LLVM optimizer prior to
    linking. This will produce faster executable code at the expense of compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Incremental compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Incremental compilation is also important for edit / compile / debug cycles.
    Incremental compilation only rebuilds those parts of the code which have changed
    through modification to minimize the amount of time it takes to rebuild the product.
  prefs: []
  type: TYPE_NORMAL
- en: Rust has a different incremental compilation model to C++.
  prefs: []
  type: TYPE_NORMAL
- en: C++ doesn't support incremental compilation per se. That function is left to
    the make / project / solution tool. Most builders will track a list of project
    files and which file depends on other files. So if file foo.h changes then the
    builder knows what other files depend on it and ensures they are rebuilt before
    relinking the target executable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Rust incremental compilation is at the crate level - that if any file in
    a crate changes then the crate as a whole has to be rebuilt. Thus larger code
    bases tend to be split up into crates to reduce the incremental build time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a recognition in the Rust community that the crate-level model can
    suck for large crates so the Rust compiler is getting [incremental per-file compilation
    support](https://blog.rust-lang.org/2016/09/08/incremental.html) in addition to
    per-crate.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this support is experimental because it is tied to refactoring
    the compiler for other reasons to improve performance and optimization but will
    eventually be enabled and supported by rustc and cargo.
  prefs: []
  type: TYPE_NORMAL
- en: Managing a project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++ we would use a `makefile` or a solution file of some kind to manage a
    real world project and build it.
  prefs: []
  type: TYPE_NORMAL
- en: For small programs we might run a script or invoke a compiler directly but as
    our program grows and takes longer to build, we would have to use a `makefile`
    to maintain our sanity.
  prefs: []
  type: TYPE_NORMAL
- en: A typical `makefile` has rules that say what files are our sources, how each
    source depends on other sources (like headers), what our final executable is and
    a bunch of other mess about compile and link flags that must be maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are lots of different makefile solutions which have cropped up over the
    years but a simple gmake might look like one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When you invoke `make`, the software will check all the dependencies of your
    target, looking at their filestamps and determine which rules need to be invoked
    and which order to rebuild your code.
  prefs: []
  type: TYPE_NORMAL
- en: Rust makes things a lot easier – there is no makefile! The source code is the
    makefile. Each file says what other files it uses via depencies on other crates,
    and on other modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this main.rs for a pacman game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If we save this file and type `rustc main.rs` the compiler will notice the reference
    to `mod pacman` and will search for a `pacman.rs` (or `pacman/mod.rs`) and compile
    that too. It will continue doing this with any other modules referenced along
    the way.
  prefs: []
  type: TYPE_NORMAL
- en: In other words you could have a project with 1000 files and compile it as simply
    as `rustc main.rs`. Anything referenced is automatically compiled and linked.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so we can call `rustc`, but what happens if our code has dependencies
    on other projects. Or if our project is meant to be exported so other projects
    can use it?
  prefs: []
  type: TYPE_NORMAL
- en: Cargo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cargo is a package manager build tool rolled into one. Cargo can fetch dependencies,
    build them, build and link your code, run unit tests, install binaries, produce
    documentation and upload versions of your project to a repository.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to create a new project in Rust is to use the `cargo` command
    to do it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creates this
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Building the project is then simply a matter of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to build for release you add a --release argument. This will invokes
    the rust compiler with optimizations enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we wanted to build and run unit tests in our code we could write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Crates and external dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cargo doesn't just take care of building our code, it also ensures that anything
    our code depends on is also downloaded and built. These external dependencies
    are defined in a `Cargo.toml` in our project root.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can edit that file to say we have a dependency on an external "crate" such
    as the `time` crate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now when we run `cargo build`, it will fetch "time" from crates.io and also
    any dependencies that "time" has itself. Then it will build each crate in turn
    automatically. It does this efficiently so iterative builds do not incur a penalty.
    External crates are download and built in your .cargo home directory.
  prefs: []
  type: TYPE_NORMAL
- en: To use our external crate we declare it in the main.rs of our code, e.g.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So the change to the `Cargo.toml` and a reference in the source is sufficient
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch the crate (and any dependencies)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the crate (and any dependencies)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and link to the crate and dependencies
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All that happened with a line in `Cargo.toml` and a line in our code to reference
    the crate. We didn't have to mess around figuring how to build the other library,
    or maintain multiple makefiles, or getting our compiler / linker flags right.
    It just happened.
  prefs: []
  type: TYPE_NORMAL
- en: Cargo.lock
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Also note that once we build, cargo creates a `Cargo.lock` file in our root
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: This file is made so that if `cargo build` is invoked again it has an exact
    list of what packages need to be pulled and compiled. It stops situations where
    the code under our feet (so to speak) moves and suddenly our project no longer
    builds. So if the lock file exists, the same dependency configuration can be reproduced
    even from a clean. If you want to force the cargo to rebuild a new lock file,
    e.g. after changing `Cargo.toml`, you can type `cargo update`.
  prefs: []
  type: TYPE_NORMAL
- en: ¹. You can change the main entry point using a special `#[start]` directive
    if you want on another function but the default is main() [↩](#reffn_1 "Jump back
    to footnote [1] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
