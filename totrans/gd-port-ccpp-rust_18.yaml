- en: Rust Cookbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust Cookbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Convert a number to a string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's say you have an integer you want to turn into a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++ you might do one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All of these have issues. Some are extensions to the standard, others may not
    be thread safe, some may break if `value` was changed to another type, e.g. `long
    long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust makes it far easier because numeric primitives implement a trait called
    ToString. The ToString trait has a to_string() function. So to convert the number
    to string is as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The same is true for a floating point number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Convert a number to a string with precision / padding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In C you would add precision of padding using printf operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++ you could use the C way (and to be honest it''s easier than what is
    written below), or you can set padding and precision through an ostream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In Rust you can use format!() [[https://doc.rust-lang.org/std/fmt/](https://doc.rust-lang.org/std/fmt/)]
    for this purpose and it is similar to printf / sprintf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Convert a number to a localized string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some locales will use dots or commas for separators. Some languages will use
    dots or commas for the decimal place. In order to format these strings we need
    to make use of the locale.
  prefs: []
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Convert a string to a number
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C / C++ a number might be converted from a string to a number in a number
    of ways
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: 'In Rust we have a &str containing a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Any type that implements a trait called FromStr can take its type from a string.
    All the standard primitive types implement FromStr so we can simply say this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note the unwrap() at the end - the FromStr::from_str() returns the value inside
    a Result<valueu0002c error="" class="hljs-meta">, to allow for the possibility
    that the string cannot be parsed. Production code should test for errors before
    calling unwrap() or it will panic.</valueu0002c>
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to get the string is to call parse() on the &str or String itself.
    In this case, you use a slightly odd looking syntax nicknamed ''turbofish'' which
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The string's implementation of parse() is a generic that works with any type
    implementing `FromStr`. So calling `parse::<i32>` is equivalent to calling `i32::from_str()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note one immediate advantage of Rust is it uses string slices. That means you
    could have a long string with many numbers separated by delimiters and parse numbers
    straight out of the middle of it without constructing intermediate copies.
  prefs: []
  type: TYPE_NORMAL
- en: Converting between numeric types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Converting between numeric types is as easy as using the "as" keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The result in i is the integer part of f.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust comes with some very powerful functions that are attached to every &str
    and String type. These mostly correspond to what you may be used to on the std::string
    class and in boost string algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Most find / match / trim / split string operations in Rust are efficient because
    they neither modify the existing string, nor return a duplicate to you. Instead
    they return slices, i.e. a pointer and a length into your existing string to denote
    the range that is the result.
  prefs: []
  type: TYPE_NORMAL
- en: It is only operations that modify the string contents themselves such as creating
    upper or lowercase versions that will return a new copy of a string.
  prefs: []
  type: TYPE_NORMAL
- en: Trimming a string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spaces, tabs and other Unicode characters defined as whitespace can be trimmed
    from a string.
  prefs: []
  type: TYPE_NORMAL
- en: All strings have access to the following functions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note the signatures of these functions - they are not mutable. The functions
    return a slice of the string that excludes the leading and / or trailing whitespace
    removed. In other words it is not duplicating the string, nor is it modifying
    the existing string. Instead it is just telling you what the trimmed range is
    within the &str you're already looking at.
  prefs: []
  type: TYPE_NORMAL
- en: So
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Also be aware that trim_left() and and trim_right() above are affected by the
    directionality of the string.
  prefs: []
  type: TYPE_NORMAL
- en: Most strings read from left-to-right, but strings in Arabic or Hebrew are read
    right-to-left and will start with a control character that sets their base direction
    right-to-left. If that character is present, trim_left() actually trims from the
    right and trim_right() trims from the left.
  prefs: []
  type: TYPE_NORMAL
- en: Get the length of a string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every &str and String has a len() function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that len() is the length in bytes. If you want the number of characters
    you need to call message.chars().count(), e.g.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Splitting a string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'String slices and String have a variety of `split` methods that return an iterable
    collection of slices on a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The standard `split()` takes a string pattern for the delimiter and returns
    a `std::str::Split` struct that is an double-ended iterator representation of
    the matching result. We could call the iterator directly if we so wished but the
    `collect()` method above puts the values of the iterator into a `Vec<&str>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A string can also be split on an index, e.g.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that index is the *byte index*! The function will panic if the index is
    in the centre of a UTF-8 codepoint.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful function is `split_whitespace` that splits on tabs, spaces, newlines
    and other Unicode whitespace. Any amount of whitespace is treated as a single
    delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Yields the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tokenizing a string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Joining strings together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Getting a substring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Converting a string between upper and lower case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Strings have these functions for converting between upper and lower case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: These functions will return a new String that contains the upper or lower case
    version of the input. Upper and lower case are defined by Unicode rules. Languages
    that have no upper or lowercase strings may return the same characters.
  prefs: []
  type: TYPE_NORMAL
- en: Doing a case insensitive compare
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Using regular expression matches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Date and Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get the current date and time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO time_rs
  prefs: []
  type: TYPE_NORMAL
- en: UTC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO explain what UTC is and why maintaining time in UTC is vital Epochs etc.
    TODO preamble about what an epoch is, the Unix epoch and other epochs
  prefs: []
  type: TYPE_NORMAL
- en: Setting a timer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO setting a timer
  prefs: []
  type: TYPE_NORMAL
- en: System time vs UTC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO the reason timers might be set in system uptime vs timers being set in
    UTC. Answer because users and NTP can change the UTC time wherease system time
    is relative to bootup. So setting a timer to run 10s from now will always work
    against system time where setting a timer to run 10s from now in UTC could fail
    if the OS sets time back by an hour.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting a date as a string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO standard date formatting UTC TODO example
  prefs: []
  type: TYPE_NORMAL
- en: Parsing a date from a string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO parsing a date from a string's TODO example
  prefs: []
  type: TYPE_NORMAL
- en: Performing date / time arithmetic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a static array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An array primitive consists of a type and a length. e.g. a 16 kilobyte array
    of bytes can be created and zeroed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The variable specifies the type and length and the assignment operator assigns
    0 to every element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type, length and values can be initialized implicitly in-place like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an array of 5 &str values. The compiler will complain if we try to
    mix types in the array. We could also declare the array and manipulate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note in this case we declared the array, each element received an empty value.
    Then our code programmatically set the new element value. The latter form would
    obviously be useful for arrays that change. The latter would be useful for arrays
    which do not.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dynamic vector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A vector is a linear array of values. Unlike an array which has a fixed length,
    a vector can grow or shrink over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A vector can be created using the vec! macro like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This creates a mutable Vec and prepopulates it with 5 values. Note how the vec!
    macro can use square brackets for its arguments. We could have used round brackets
    and it would have meant the same.
  prefs: []
  type: TYPE_NORMAL
- en: A new Vec can also be made using Vec::new() or Vec::with_capacity(size)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It is strongly recommended you use Vec::with_capacity() to create a vector with
    enough capacity for maximum number of elements you expect the vector to contain.
    It prevents the runtime from having to reallocate and copy data if you keep exceeding
    the existing capacity. It also significantly reduces heap fragmentation.
  prefs: []
  type: TYPE_NORMAL
- en: Removing values from a vector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you want to strip out values from a list which match some predicate.
    In which case there is a handy function for that purpose. TODO `.retain`
  prefs: []
  type: TYPE_NORMAL
- en: Sorting a vector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A vector can be sorted by the natural sort order of the elements it contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Sorting is done using the Ord trait and calling Ord::cmp() on the elements to
    compare them to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison can also be done through a closure and Vec::sort_by()
  prefs: []
  type: TYPE_NORMAL
- en: TODO `.sort_by` TODO `.sort_by_key`
  prefs: []
  type: TYPE_NORMAL
- en: Stripping out duplicates from a vector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assuming your vec is sorted, you can strip out consecutive duplicate entries
    using dedup(). This function won't work and the result will be undefined if your
    vector is not sorted. TODO .dedup
  prefs: []
  type: TYPE_NORMAL
- en: Creating a linked list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A linked list is more suitable than a vector when items are likely to be inserted
    or removed from either end or from points within the list.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::collections::LinkedList`'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a hash set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A hash set is a unique collection of objects. It is particularly useful for
    removing duplicates that might occur in the input. `std::collections::HashSet`
  prefs: []
  type: TYPE_NORMAL
- en: Creating a hash map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A hash map consists of a key and a value. It is used for look up operations
    `std::collections::HashMap`
  prefs: []
  type: TYPE_NORMAL
- en: Iterating collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Iterator adaptors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: An adaptor turns the iterator into a new value
  prefs: []
  type: TYPE_NORMAL
- en: '`.enum` `.map(X)` `.take(N)` `.filter(X)`'
  prefs: []
  type: TYPE_NORMAL
- en: Consuming iterators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A consumer is a convenience way of iterating a collection and producing a value
    or a set of values from the result.
  prefs: []
  type: TYPE_NORMAL
- en: '`.collect()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`.find()` will return the first matching element that matches the closure predicate.
    TODO'
  prefs: []
  type: TYPE_NORMAL
- en: '`.fold()` is a way of doing calculations on the collection. It takes a base
    value, and then calls a closure to accumulate the value upon the result of the
    last value. TODO Processing collections'
  prefs: []
  type: TYPE_NORMAL
- en: Localization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unicode considerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Externalizing strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Building strings from parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Creating a localization file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Files and streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rust comes with two standard modules:'
  prefs: []
  type: TYPE_NORMAL
- en: std::io contains various stream related traits and other functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: std::fs contains filesystem related functionality including the implementation
    of IO traits to work with files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A directory can be created with `std::fs::DirBuilder`, e.g.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: File paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Windows and Unix systems have different notation for path separators and a number
    of other differences. e.g. Windows has drive letters, long paths, and network
    paths called UNCs.
  prefs: []
  type: TYPE_NORMAL
- en: Rust provides a PathBuf struct for manipulating paths and a Path which acts
    like a slice and can be the full path or just a portion of one.
  prefs: []
  type: TYPE_NORMAL
- en: TODO simple example of a path being created
  prefs: []
  type: TYPE_NORMAL
- en: TODO simple example of a Path slice in actively
  prefs: []
  type: TYPE_NORMAL
- en: TODO simple example of relative path made absolute
  prefs: []
  type: TYPE_NORMAL
- en: Windows has a bunch of path prefixes so std::path::Prefix provides a way to
    accessing those.
  prefs: []
  type: TYPE_NORMAL
- en: TODO example of a path being made from a drive letter and path
  prefs: []
  type: TYPE_NORMAL
- en: Opening a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `File` is a reference to an open file on the filesystem. When the struct
    goes out of scope the file is closed. There are static functions for creating
    or opening a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that File::open() opens a file read-only by default. To open a file read-write,
    there is an OpenOptions struct that has methods to set the behaviour of the open
    file - read, write, create, append and truncate.
  prefs: []
  type: TYPE_NORMAL
- en: e.g. to open a file with read/write access, creating it if it does not already
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Writing to a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO simple example of opening file to write
  prefs: []
  type: TYPE_NORMAL
- en: Reading lines from a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO simple example of opening file text mode, printing contents
  prefs: []
  type: TYPE_NORMAL
- en: Threading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust actively enforces thread safety in your code. If you attempt to pass around
    data which is not marked thread safe (i.e. implements the Sync trait), you will
    get a compile error. If you use code which is implicitly not thread safe such
    as Rc<> you will get a compile error.
  prefs: []
  type: TYPE_NORMAL
- en: This enforcement means that Rust protects against data race conditions, however
    be aware it cannot protect against other forms of race conditions or deadlocks,
    e.g. thread 1 waits for resource B (held by thread 2) while thread 2 waits for
    resource A (held by thread 1).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a thread
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a thread is simple with a closure.
  prefs: []
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for a thread to complete
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Using atomic reference counting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust provides two reference counting types. Type Rc<> is for code residing on
    the same thread and so the reference counting is not atomic. Type Arc<> is for
    code that runs on different threads and the reference counting is atomic.
  prefs: []
  type: TYPE_NORMAL
- en: An Arc<> can only hold a Sync derived object. Whenever you clone an Arc<> or
    its lifetime ends, the counter is atomically incremented or decremented. The last
    decrement to zero causes the object to be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: TODO example
  prefs: []
  type: TYPE_NORMAL
- en: Locking a shared resource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Message passing is a preferable way to prevent threads from sharing state but
    its not always possible.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore Rust allows you to create a mutex and lock access to shared data.
    The guard that locks / unlocks the mutex protects the data and when the guard
    goes out of scope, the data is returned.
  prefs: []
  type: TYPE_NORMAL
- en: This style of guard is called TODO
  prefs: []
  type: TYPE_NORMAL
- en: Data race protection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rust can guarantee that protection from data races, i.e. more than one thread
    accessing / writing to the same data at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: However even Rust cannot protect against the more general problem of race conditions.
    e.g. if two threads lock each other's data, then the code will deadlock. This
    is a problem that no language can solve.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for multiple threads to finish
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Sending data to a thread
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any struct that implements the Send trait is treated safe to send to another
    thread. Of course that applies to
  prefs: []
  type: TYPE_NORMAL
- en: Receiving data from a thread
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A thread can receive messages and block until it receives one. Thus it is easy
    to create a worker thread of some kind.
  prefs: []
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Connecting to a server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Listening to a socket
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using libc functions and types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Calling a C library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generating a dynamic library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Calling Win32 functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Common design patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A singleton has one instance ever in your application. TODO
  prefs: []
  type: TYPE_NORMAL
- en: Factory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Facade
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Flyweight
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An adapter is where we present a different interface to a client calling the
    adapter than the interface the code is implemented in. This might be done to make
    some legacy code conform to a new interface, or to manage / hide complexity which
    might leak out into the client.
  prefs: []
  type: TYPE_NORMAL
- en: As Rust is a relatively new language you are most likely to use an adapter pattern
    to wrap some existing code in C. A common use for the adapter in C++ is to wrap
    up a C library in RAII classes or similar.
  prefs: []
  type: TYPE_NORMAL
- en: TODO
  prefs: []
  type: TYPE_NORMAL
