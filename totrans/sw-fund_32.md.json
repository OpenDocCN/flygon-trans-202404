["```\n\n```", "```\n\n    This optional chapter is based on chapter 12 of *Types and Programming Languages* (Pierce).  It may be useful to look at the\n    two together, as that chapter includes explanations and informal\n    proofs that are not repeated here.\n\n    In this chapter, we consider another fundamental theoretical\n    property of the simply typed lambda-calculus: the fact that the\n    evaluation of a well-typed program is guaranteed to halt in a\n    finite number of steps\u2014-i.e., every well-typed term is\n    *normalizable*.\n\n    Unlike the type-safety properties we have considered so far, the\n    normalization property does not extend to full-blown programming\n    languages, because these languages nearly always extend the simply\n    typed lambda-calculus with constructs, such as general\n    recursion (see the [MoreStlc](MoreStlc.html) chapter) or recursive types, that\n    can be used to write nonterminating programs.  However, the issue\n    of normalization reappears at the level of *types* when we\n    consider the metatheory of polymorphic versions of the lambda\n    calculus such as System F-omega: in this system, the language of\n    types effectively contains a copy of the simply typed\n    lambda-calculus, and the termination of the typechecking algorithm\n    will hinge on the fact that a \"normalization\" operation on type\n    expressions is guaranteed to terminate.\n\n    Another reason for studying normalization proofs is that they are\n    some of the most beautiful\u2014-and mind-blowing\u2014-mathematics to be\n    found in the type theory literature, often (as here) involving the\n    fundamental proof technique of *logical relations*.\n\n    The calculus we shall consider here is the simply typed\n    lambda-calculus over a single base type bool and with\n    pairs. We'll give most details of the development for the basic\n    lambda-calculus terms treating bool as an uninterpreted base\n    type, and leave the extension to the boolean operators and pairs\n    to the reader.  Even for the base calculus, normalization is not\n    entirely trivial to prove, since each reduction of a term can\n    duplicate redexes in subterms. \n\n#### Exercise: 2 starsM (norm_fail)\n\n    Where do we fail if we attempt to prove normalization by a\n    straightforward induction on the size of a well-typed term?\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 5 stars, recommended (norm)\n\n    The best ways to understand an intricate proof like this is\n    are (1) to help fill it in and (2) to extend it.  We've left out some\n    parts of the following development, including some proofs of lemmas\n    and the all the cases involving products and conditionals.  Fill them\n    in.  \u2610\n\n```", "```\n\n### Syntax and Operational Semantics\n\n```", "```\n\n### Substitution\n\n```", "```\n\n### Reduction\n\n```", "```\n\n### Typing\n\n```", "```\n\n### Context Invariance\n\n```", "```\n\n### Preservation\n\n```", "```\n\n### Determinism\n\n```", "```\n\n# Normalization\n\n    Now for the actual normalization proof.\n\n    Our goal is to prove that every well-typed term reduces to a\n    normal form.  In fact, it turns out to be convenient to prove\n    something slightly stronger, namely that every well-typed term\n    reduces to a *value*.  This follows from the weaker property\n    anyway via Progress (why?) but otherwise we don't need Progress,\n    and we didn't bother re-proving it above.\n\n    Here's the key definition:\n\n```", "```\n\n    A trivial fact:\n\n```", "```\n\n    The key issue in the normalization proof (as in many proofs by\n    induction) is finding a strong enough induction hypothesis.  To\n    this end, we begin by defining, for each type T, a set R_T of\n    closed terms of type T.  We will specify these sets using a\n    relation R and write R T t when t is in R_T. (The sets\n    R_T are sometimes called *saturated sets* or *reducibility candidates*.)\n\n    Here is the definition of R for the base language:\n\n*   R bool t iff t is a closed term of type bool and t halts in a value \n\n*   R (T[1] \u2192 T[2]) t iff t is a closed term of type T[1] \u2192 T[2] and t halts in a value *and* for any term s such that R T[1] s, we have R T[2] (t s).\n\n    This definition gives us the strengthened induction hypothesis that we\n    need.  Our primary goal is to show that all *programs* \u2014-i.e., all\n    closed terms of base type\u2014-halt.  But closed terms of base type can\n    contain subterms of functional type, so we need to know something\n    about these as well.  Moreover, it is not enough to know that these\n    subterms halt, because the application of a normalized function to a\n    normalized argument involves a substitution, which may enable more\n    reduction steps.  So we need a stronger condition for terms of\n    functional type: not only should they halt themselves, but, when\n    applied to halting arguments, they should yield halting results.\n\n    The form of R is characteristic of the *logical relations* proof\n    technique.  (Since we are just dealing with unary relations here, we\n    could perhaps more properly say *logical properties*.)  If we want to\n    prove some property P of all closed terms of type A, we proceed by\n    proving, by induction on types, that all terms of type A *possess*\n    property P, all terms of type A\u2192A *preserve* property P, all\n    terms of type (A\u2192A)->(A\u2192A) *preserve the property of preserving*\n    property P, and so on.  We do this by defining a family of\n    properties, indexed by types.  For the base type A, the property is\n    just P.  For functional types, it says that the function should map\n    values satisfying the property at the input type to values satisfying\n    the property at the output type.\n\n    When we come to formalize the definition of R in Coq, we hit a\n    problem.  The most obvious formulation would be as a parameterized\n    Inductive proposition like this:\n\n```", "```\nFixpoint R (T:ty) (t:tm) {struct T} : Prop :=\n\u00a0\u00a0has_type empty t T \u2227 halts t \u2227\n\u00a0\u00a0(match T with\n\u00a0\u00a0\u00a0| TBool  \u21d2 True\n\u00a0\u00a0\u00a0| TArrow T[1] T[2] \u21d2 (\u2200s, R T[1] s \u2192 R T[2] (tapp t s))\n\n\u00a0\u00a0\u00a0(*\u00a0...\u00a0edit\u00a0the\u00a0next\u00a0line\u00a0when\u00a0dealing\u00a0with\u00a0products\u00a0*)\n\u00a0\u00a0\u00a0| TProd T[1] T[2] \u21d2 False \n\u00a0\u00a0\u00a0end).\n\n```", "```\nLemma R_halts : \u2200{T} {t}, R T t \u2192 halts t.\n\n    Proof.\n\u00a0\u00a0intros. destruct T; unfold [R](Norm.html#R) in H; inversion H; inversion H[1];  assumption.\n    Qed.\n\nLemma R_typable_empty : \u2200{T} {t}, R T t \u2192 has_type empty t T.\n\n    Proof.\n\u00a0\u00a0intros. destruct T; unfold [R](Norm.html#R) in H; inversion H; inversion H[1]; assumption.\n    Qed.\n\n```", "```\n\n## Membership in R_T Is Invariant Under Reduction\n\n    We start with a preliminary lemma that shows a kind of strong\n    preservation property, namely that membership in R_T is *invariant*\n    under reduction. We will need this property in both directions,\n    i.e., both to show that a term in R_T stays in R_T when it takes a\n    forward step, and to show that any term that ends up in R_T after a\n    step must have been in R_T to begin with.\n\n    First of all, an easy preliminary lemma. Note that in the forward\n    direction the proof depends on the fact that our language is\n    determinstic. This lemma might still be true for nondeterministic\n    languages, but the proof would be harder!\n\n```", "```\n\n    Now the main lemma, which comes in two parts, one for each\n    direction.  Each proceeds by induction on the structure of the type\n    T. In fact, this is where we make fundamental use of the\n    structure of types.\n\n    One requirement for staying in R_T is to stay in type T. In the\n    forward direction, we get this from ordinary type Preservation.\n\n```", "```\n\n    The generalization to multiple steps is trivial:\n\n```", "```\n\n    In the reverse direction, we must add the fact that t has type\n   T before stepping as an additional hypothesis.\n\n```", "```\n\n## Closed Instances of Terms of Type t Belong to R_T\n\n    Now we proceed to show that every term of type T belongs to\n    R_T.  Here, the induction will be on typing derivations (it would be\n    surprising to see a proof about well-typed terms that did not\n    somewhere involve induction on typing derivations!).  The only\n    technical difficulty here is in dealing with the abstraction case.\n    Since we are arguing by induction, the demonstration that a term\n    tabs x T[1] t[2] belongs to R_(T[1]\u2192T[2]) should involve applying the\n    induction hypothesis to show that t[2] belongs to R_(T[2]).  But\n    R_(T[2]) is defined to be a set of *closed* terms, while t[2] may\n    contain x free, so this does not make sense.\n\n    This problem is resolved by using a standard trick to suitably\n    generalize the induction hypothesis: instead of proving a statement\n    involving a closed term, we generalize it to cover all closed\n    *instances* of an open term t.  Informally, the statement of the\n    lemma will look like this:\n\n    If x[1]:T[1],..xn:Tn \u22a2 t : T and v[1],...,vn are values such that\n    R T[1] v[1], R T[2] v[2], ..., R Tn vn, then\n    R T ([x[1]:=v[1]][x[2]:=v[2]]...[xn:=vn]t).\n\n    The proof will proceed by induction on the typing derivation\n    x[1]:T[1],..xn:Tn \u22a2 t : T; the most interesting case will be the one\n    for abstraction.\n\n```", "```\nDefinition env := list (id * tm).\n\nFixpoint msubst (ss:env) (t:tm) {struct ss} : tm :=\nmatch ss with\n| nil \u21d2 t\n| ((x,s)::ss') \u21d2 msubst ss' ([x:=s]t)\nend.\n\n```", "```\nDefinition tass := list (id * ty).\n\nFixpoint mupdate (\u0393 : context) (xts : tass) :=\n\u00a0\u00a0match xts with\n\u00a0\u00a0| nil \u21d2 \u0393\n\u00a0\u00a0| ((x,v)::xts') \u21d2 update (mupdate \u0393 xts') x v\n\u00a0\u00a0end.\n\n```", "```\nFixpoint lookup {X:Set} (k : id) (l : list (id * X)) {struct l}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: option X :=\n\u00a0\u00a0match l with\n\u00a0\u00a0\u00a0\u00a0| nil \u21d2 None\n\u00a0\u00a0\u00a0\u00a0| (j,x) :: l' \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if beq_id j k then Some x else lookup k l'\n\u00a0\u00a0end.\n\nFixpoint drop {X:Set} (n:id) (nxs:list (id * X)) {struct nxs}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: list (id * X) :=\n\u00a0\u00a0match nxs with\n\u00a0\u00a0\u00a0\u00a0| nil \u21d2 nil\n\u00a0\u00a0\u00a0\u00a0| ((n',x)::nxs') \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if beq_id n' n then drop n nxs'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else (n',x)::(drop n nxs')\n\u00a0\u00a0end.\n\n```", "```\nInductive instantiation :  tass \u2192 env \u2192 Prop :=\n| V_nil :\n\u00a0\u00a0\u00a0\u00a0instantiation nil nil\n| V_cons : \u2200x T v c e,\n\u00a0\u00a0\u00a0\u00a0value v \u2192 R T v \u2192\n\u00a0\u00a0\u00a0\u00a0instantiation c e \u2192\n\u00a0\u00a0\u00a0\u00a0instantiation ((x,T)::c) ((x,v)::e).\n\n```", "```\n\n### More Substitution Facts\n\n    First we need some additional lemmas on (ordinary) substitution.\n\n```", "```\n\n### Properties of Multi-Substitutions\n\n```", "```\n\n    Closed environments are those that contain only closed terms.\n\n```", "```\n\n    Next come a series of lemmas charcterizing how msubst of closed terms\n    distributes over subst and over each term form\n\n```", "```\n\n    You'll need similar functions for the other term constructors.\n\n```", "```\n\n### Properties of Multi-Extensions\n\n    We need to connect the behavior of type assignments with that of\n    their corresponding contexts.\n\n```", "```\n\n### Properties of Instantiations\n\n    These are strightforward.\n\n```", "```\n\n### Congruence Lemmas on Multistep\n\n    We'll need just a few of these; add them as the demand arises.\n\n```", "```\n\n### The R Lemma.\n\n    We can finally put everything together.\n\n    The key lemma about preservation of typing under substitution can\n    be lifted to multi-substitutions:\n\n```", "```\n\n    And at long last, the main lemma.\n\n```", "```\n\n### Normalization Theorem\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]