- en: More about classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far all our classes where data classes, because the compiler provides some
    nice support for these: a reasonable toString method, equality testing, and they
    can be used as elements in a set or as keys in a map.'
  prefs: []
  type: TYPE_NORMAL
- en: Data classes are meant for objects that have a number of basic attributes, like
    numbers and strings, and there are some restrictions on their definition. In this
    section we will work with general classes—we will review the differences at the
    end.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When creating objects, we are often providing arguments for the constructor,
    as for instance when we made a Date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The arguments 2012, 4, 9 correspond to the parameters year, month, and day that
    appear in parentheses after the class name in the class declaration. The constructor
    parameters can be val fields, var fields, or simply parameters for the construction
    of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an immutable Point class. Both class parameters are val fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a mutable Rect class to store an axis-parallel rectangle. The class
    parameters are var fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first class parameter is a Point object, so I should create rectangle objects
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say I don''t like this, I want to be able to create rectangles by giving
    four numbers, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'I still want to be able to store the top-left corner as a Point object, but
    because the class parameters now look different, I cannot define the corner field
    in the class parameter list. Instead I need to do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the corner field is defined in the body of the class. The class parameters
    x and y are simply parameters of the method that constructs objects of type Rect,
    they are not fields of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So every occurrence of val or var in the body of the class defines a field of
    the class. Every field has to be initialized with a starting value. This value
    is used when the object is constructed.
  prefs: []
  type: TYPE_NORMAL
- en: Privacy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let us define an Accumulator, a counter that starts with zero, and to which
    we can add a value ([accum1.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/52-objects/accum1.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The class itself has no class parameters this time, so no arguments are given
    when we create Accumulator objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: (Note that since Accumulator is not a data class, it has a rather ugly toString
    method by default. We would have to override toString to get nicer output.)
  prefs: []
  type: TYPE_NORMAL
- en: 'What is not so nice here is that we could accidentally modify the sum-field
    of the Accumulator object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The programmer using the Accumulator class made a mistake here and set acc2.sum
    back to zero—so now the final result is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example that shows the importance of privacy. A client—that is,
    code using our class— should consider an object as a black box. The client should
    not need or want to know how the object is implemented, and must only use the
    methods provided by the object to communicate with it. Our Accumulator object
    should have two operations: adding a number to the current sum, and reading out
    the current sum. It should not be possible to modify the current sum.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve this by forbidding client code to access the field that stores
    the current sum. To do so, we declare the field to be private. However, that means
    that we cannot access it at all, so we have to add a new method to be able to
    read the current value of the summation ([accum2.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/52-objects/accum2.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how we use it correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'But now see what happens when we make a mistake and try to change the sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Since sum is not a field but a method that returns a value, we cannot assign
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'And even if we tried to change the field current directly, the compiler would
    catch this programming error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, even looking at the value of current is forbidden (that''s why we
    needed the sum method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The private keyword means that the member can be accessed only from methods
    inside the class. You can use it both for fields and for methods. So a private
    method is a method that can be called only from other methods in the same class.
  prefs: []
  type: TYPE_NORMAL
- en: A Blackjack game
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To see a more interesting example, let us program a Blackjack game. We first
    need a class that represents the playing cards. Remember that there are four suits
    called clubs, spades, hearts, and diamonds, and 13 faces, namely 2 to 10, Jack,
    Queen, King, and Ace.
  prefs: []
  type: TYPE_NORMAL
- en: '![A set of playing cards](../Images/087a846aa87e996f0322a944f0bf09ea.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since this is a simple class, we should make it a data class. We override toString
    anyway to obtain a nice string representation ([blackjack1.kt](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/52-objects/blackjack1.kt)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note the value method, which returns the number of points that the card is worth.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We next need a class Deck that stores an entire deck of cards, and allows us
    to draw cards from the deck ([blackjack2.kt](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/52-objects/blackjack2.kt)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that Deck has no class parameter, so it is created simply by saying Deck()
    without any arguments. Let''s look at the first lines of the class more carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line defines a val-field named cards. This field is initialized with
    an empty mutable list. So before the Deck object can be used, this list has to
    be filled with the actual cards. This is done by the two method calls generateDeck()
    and shuffleDeck(). Both are private methods of Deck: That is, they are methods
    of Deck, but they cannot be called directly by client code. They are purely for
    internal use of the class (in our case for use in the constructor, to set up a
    properly shuffled deck of the 52 Blackjack cards). The first method generateDeck
    fills the array with the 52 cards, the second method shuffleDeck rearranges them
    into a random order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the draw method is not private: It is meant for clients of the Deck
    to draw one card from the deck.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using the Deck class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a working deck, we can write the client code, that is, we can
    implement the complete Blackjack game. Here is the main function that implements
    one game (you can download the entire program as [blackjack-game.kt](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/52-objects/blackjack-game.kt)).
    Note how easy it is to read this code, because we have hidden all the complexity
    of storing cards and shuffling and managing the deck inside the Card and Deck
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the game, we need the Date and Deck classes (from blackjack2.kt)
    and the game functions (from blackjack-game.kt), so we can compile like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We run the game through the main function in blackjack-game.kt, that is like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So what about data classes?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a [previous chapter](tutorial-data-classes.html) we have learnt about data
    classes. In this chapter we have started to talk about normal classes. So what's
    the difference?
  prefs: []
  type: TYPE_NORMAL
- en: 'The short answer is: Data classes are for small objects that have no hidden
    state. Our Deck class was an example of an object with hidden state, namely the
    current cards on the deck.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The long answer is that data classes are different from normal classes in the
    following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: For normal classes, the toString method just prints the class name and some
    string in hexadecimal. For data classes, it prints the class name and the values
    of all the fields. If we want a pretty toString method for normal classes, we
    need to override the toString method and define it ourselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For normal classes, the equality operators == and != only test if the two references
    refer to the same object. For data classes, two objects are equal if all their
    fields are equal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you want to redefine the meaning of == and != for normal classes, you have
    to define an equals method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Immutable data class objects can be used as elements of a set or as keys of
    a map. For normal classes, this will only work if you define equals and hashCode,
    but that goes beyond the scope of this tutorial.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple data class fields can be extracted in one step:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The assignment val (y, m, d) = date works because date is a data class object.
    For normal classes, you would have to define the componentX methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Data classes automatically have a copy method that allows you to make copies
    where you selectively change some field, for instance like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For normal classes you would have to define such a method by hand.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
