- en: ImpCEvalFunEvaluation Function for Imp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A Broken Evaluator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here was our first try at an evaluation function for commands,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: omitting WHILE.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we remarked in chapter [Imp](Imp.html), in a traditional functional
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: programming language like ML or Haskell we could write the WHILE
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'case as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Coq doesn''t accept such a definition (Error: Cannot guess decreasing argument
    of fix) because the function we want to'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: define is not guaranteed to terminate. Indeed, the changed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ceval_step1 function applied to the loop program from Imp.v
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: would never terminate. Since Coq is not just a functional
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: programming language, but also a consistent logic, any potentially
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: non-terminating function needs to be rejected. Here is an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: invalid(!) Coq program showing what would go wrong if Coq allowed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'non-terminating recursive functions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That is, propositions like False would become
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: provable (e.g., loop_false 0 would be a proof of False), which
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: would be a disaster for Coq's logical consistency.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Thus, because it doesn't terminate on all inputs, the full version
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of ceval_step1 cannot be written in Coq — at least not without
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: one additional trick...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint ceval_step2 (st : state) (c : com) (i : nat) : state :='
  prefs: []
  type: TYPE_NORMAL
- en: match i with
  prefs: []
  type: TYPE_NORMAL
- en: '| O ⇒ empty_state'
  prefs: []
  type: TYPE_NORMAL
- en: '| S i'' ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match c with
  prefs: []
  type: TYPE_NORMAL
- en: '| SKIP ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: st
  prefs: []
  type: TYPE_NORMAL
- en: '| l ::= a[1] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: t_update st l (aeval st a[1])
  prefs: []
  type: TYPE_NORMAL
- en: '| c[1] ;; c[2] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: let st' := ceval_step2 st c[1] i' in
  prefs: []
  type: TYPE_NORMAL
- en: ceval_step2 st' c[2] i'
  prefs: []
  type: TYPE_NORMAL
- en: '| IFB b THEN c[1] ELSE c[2] FI ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: if (beval st b)
  prefs: []
  type: TYPE_NORMAL
- en: then ceval_step2 st c[1] i'
  prefs: []
  type: TYPE_NORMAL
- en: else ceval_step2 st c[2] i'
  prefs: []
  type: TYPE_NORMAL
- en: '| WHILE b[1] DO c[1] END ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: if (beval st b[1])
  prefs: []
  type: TYPE_NORMAL
- en: then let st' := ceval_step2 st c[1] i' in
  prefs: []
  type: TYPE_NORMAL
- en: ceval_step2 st' c i'
  prefs: []
  type: TYPE_NORMAL
- en: else st
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint ceval_step3 (st : state) (c : com) (i : nat)'
  prefs: []
  type: TYPE_NORMAL
- en: ': option state :='
  prefs: []
  type: TYPE_NORMAL
- en: match i with
  prefs: []
  type: TYPE_NORMAL
- en: '| O ⇒ None'
  prefs: []
  type: TYPE_NORMAL
- en: '| S i'' ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match c with
  prefs: []
  type: TYPE_NORMAL
- en: '| SKIP ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: Some st
  prefs: []
  type: TYPE_NORMAL
- en: '| l ::= a[1] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: Some (t_update st l (aeval st a[1]))
  prefs: []
  type: TYPE_NORMAL
- en: '| c[1] ;; c[2] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match (ceval_step3 st c[1] i') with
  prefs: []
  type: TYPE_NORMAL
- en: '| Some st'' ⇒ ceval_step3 st'' c[2] i'''
  prefs: []
  type: TYPE_NORMAL
- en: '| None ⇒ None'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '| IFB b THEN c[1] ELSE c[2] FI ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: if (beval st b)
  prefs: []
  type: TYPE_NORMAL
- en: then ceval_step3 st c[1] i'
  prefs: []
  type: TYPE_NORMAL
- en: else ceval_step3 st c[2] i'
  prefs: []
  type: TYPE_NORMAL
- en: '| WHILE b[1] DO c[1] END ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: if (beval st b[1])
  prefs: []
  type: TYPE_NORMAL
- en: then match (ceval_step3 st c[1] i') with
  prefs: []
  type: TYPE_NORMAL
- en: '| Some st'' ⇒ ceval_step3 st'' c i'''
  prefs: []
  type: TYPE_NORMAL
- en: '| None ⇒ None'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: else Some st
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notation "'LETOPT' x <== e1 'IN' e2"
  prefs: []
  type: TYPE_NORMAL
- en: := (match e[1] with
  prefs: []
  type: TYPE_NORMAL
- en: '| Some x ⇒ e[2]'
  prefs: []
  type: TYPE_NORMAL
- en: '| None ⇒ None'
  prefs: []
  type: TYPE_NORMAL
- en: end)
  prefs: []
  type: TYPE_NORMAL
- en: (right associativity, at level 60).
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixpoint ceval_step (st : state) (c : com) (i : nat)'
  prefs: []
  type: TYPE_NORMAL
- en: ': option state :='
  prefs: []
  type: TYPE_NORMAL
- en: match i with
  prefs: []
  type: TYPE_NORMAL
- en: '| O ⇒ None'
  prefs: []
  type: TYPE_NORMAL
- en: '| S i'' ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match c with
  prefs: []
  type: TYPE_NORMAL
- en: '| SKIP ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: Some st
  prefs: []
  type: TYPE_NORMAL
- en: '| l ::= a[1] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: Some (t_update st l (aeval st a[1]))
  prefs: []
  type: TYPE_NORMAL
- en: '| c[1] ;; c[2] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: LETOPT st' <== ceval_step st c[1] i' IN
  prefs: []
  type: TYPE_NORMAL
- en: ceval_step st' c[2] i'
  prefs: []
  type: TYPE_NORMAL
- en: '| IFB b THEN c[1] ELSE c[2] FI ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: if (beval st b)
  prefs: []
  type: TYPE_NORMAL
- en: then ceval_step st c[1] i'
  prefs: []
  type: TYPE_NORMAL
- en: else ceval_step st c[2] i'
  prefs: []
  type: TYPE_NORMAL
- en: '| WHILE b[1] DO c[1] END ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: if (beval st b[1])
  prefs: []
  type: TYPE_NORMAL
- en: then LETOPT st' <== ceval_step st c[1] i' IN
  prefs: []
  type: TYPE_NORMAL
- en: ceval_step st' c i'
  prefs: []
  type: TYPE_NORMAL
- en: else Some st
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: Definition test_ceval (st:state) (c:com) :=
  prefs: []
  type: TYPE_NORMAL
- en: match ceval_step st c 500 with
  prefs: []
  type: TYPE_NORMAL
- en: '| None    ⇒ None'
  prefs: []
  type: TYPE_NORMAL
- en: '| Some st ⇒ Some (st X, st Y, st Z)'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: (* Compute      (test_ceval empty_state          (X ::= ANum 2;;           IFB BLe (AId X) (ANum 1)
                THEN Y ::= ANum 3             ELSE Z ::= ANum 4           FI)).    ====>
          Some (2, 0, 4)   *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition pup_to_n : com'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '(*  Example pup_to_n_1 :   test_ceval (t_update empty_state X 5) pup_to_n   = Some (0, 15, 0).
    Proof. reflexivity. Qed. *)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Relational vs. Step-Indexed Evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As for arithmetic and boolean expressions, we'd hope that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the two alternative definitions of evaluation would actually
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: amount to the same thing in the end.  This section shows that this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is the case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 4 stars (ceval_step__ceval_inf)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write an informal proof of ceval_step__ceval, following the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: usual template.  (The template for case analysis on an inductively
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: defined value should look the same as for induction, except that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: there is no induction hypothesis.)  Make your proof communicate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the main ideas to a human reader; do not simply transcribe the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: steps of the formal proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 3 stars, recommended (ceval__ceval_step)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finish the following proof.  You'll need ceval_step_more in a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: few places, as well as some basic facts about ≤ and plus.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Determinism of Evaluation Again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the fact that the relational and step-indexed definition of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: evaluation are the same, we can give a slicker proof that the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: evaluation *relation* is deterministic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
