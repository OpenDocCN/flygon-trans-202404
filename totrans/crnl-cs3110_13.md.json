["```\nmodule type STACK = \n  sig\n    (* A stack of elements of type 'a. We write \n\n    to * denote a stack whose top element is a1, with successive * elements a2, a3,...an. *) type 'a stack exception EmptyStack (* The empty stack. *) val empty : 'a stack (* Whether this stack is empty. *) val isEmpty : 'a stack -> bool (* Returns a new stack with x pushed onto the top. *) val push : ('a * 'a stack) -> 'a stack (* Returns a new stack with the top element popped off. *) val pop : 'a stack -> 'a stack (* The top element of the stack. *) val top : 'a stack -> 'a (* map(f) maps one stack into a corresponding stack, using f. *) val map : ('a -> 'b) -> 'a stack -> 'b stack (* app(f) applies f to every element of the stack, top to bottom. *) val app : ('a -> unit) -> 'a stack -> unit end\n\n```", "```\nmodule Stack : STACK = \n  struct\n    type 'a stack = 'a list\n    exception EmptyStack\n\n    let empty : 'a stack = []\n\n    let isEmpty (l : 'a stack) : bool = l = []\n\n    let push ((x : 'a), (l : 'a stack)) : 'a stack = x :: l\n\n    let pop (l : 'a stack) : 'a stack = \n       match l with \n         [] -> raise EmptyStack\n       | x :: xs -> xs\n\n    let top (l : 'a stack) : 'a = \n       match l with\n         [] -> raise EmptyStack\n       | x :: xs -> x\n\n    let map (f : 'a -> 'b) (l : 'a stack) : 'b stack = List.map f l\n    let app (f : 'a -> unit) (l : 'a stack) : unit = List.iter f l\n  end\n\n```", "```\nlet top (l : 'a stack) : 'a = List.hd l\nlet pop (l : 'a stack) : 'a stack = List.tl l\n\n```", "```\nlet top (l : 'a stack) : 'a =\n  try List.hd l with Failure _ -> raise EmptyStack\nlet pop (l : 'a stack) : 'a stack =\n  try List.tl l with Failure _ -> raise EmptyStack\n\n```", "```\ntry e with exn -> e'\n\n```", "```\nmodule type QUEUE =\n  sig\n    type 'a queue\n    exception EmptyQueue\n\n    val empty : 'a queue\n    val isEmpty : 'a queue -> bool\n\n    val enqueue : ('a * 'a queue) -> 'a queue\n    val dequeue : 'a queue -> 'a queue\n    val front : 'a queue -> 'a\n\n    val map : ('a -> 'b) -> 'a queue -> 'b queue\n    val app : ('a -> unit) -> 'a queue -> unit      \n  end\n\n```", "```\nmodule Queue : QUEUE = \n    struct\n\n      module S = Stack\n\n      type 'a queue = ('a S.stack * 'a S.stack)\n      exception EmptyQueue\n\n      let empty : 'a queue = (S.empty, S.empty)\n      let isEmpty ((s1, s2) : 'a queue) = \n        S.isEmpty s1 && S.isEmpty s2 \n\n      let enqueue ((x : 'a), ((s1, s2) : 'a queue)) : 'a queue = \n        (S.push (x, s1), s2)\n\n      let rev (s : 'a S.stack) : 'a S.stack = \n        let rec loop ((prev : 'a S.stack), (curr : 'a S.stack))\n        : 'a S.stack =\n          if S.isEmpty prev\n          then curr\n          else loop (S.pop prev, S.push (S.top prev, curr))\n      in\n        loop (s, S.empty)\n\n      let dequeue ((s1, s2) : 'a queue) : 'a queue = \n        if S.isEmpty s2\n        then try (S.empty, S.pop (rev s1)) \n             with S.EmptyStack -> raise EmptyQueue\n        else (s1, S.pop s2)\n\n      let front ((s1, s2) : 'a queue) : 'a = \n        if (S.isEmpty s2)\n        then try S.top (rev s1)\n             with S.EmptyStack -> raise EmptyQueue\n        else S.top s2\n\n      let map (f : 'a -> 'b) ((s1, s2) : 'a queue) : 'b queue = \n        (S.map f s1, S.map f s2)\n\n      let app (f : 'a -> unit) ((s1, s2) : 'a queue) : unit = \n        S.app f s2;\n        S.app f (rev s1)\n\n    end\n\n```", "```\nmodule type DICTIONARY =\n    sig\n        (* An 'a dict is a mapping from strings to 'a.\n           We write {k1->v1, k2->v2, ...} for the dictionary which\n           maps k1 to v1, k2 to v2, and so forth. *)\n        type key = string\n    type 'a dict\n\n        (* make an empty dictionary carrying 'a values *)\n        val make : unit -> 'a dict\n\n        (* insert a key and value into the dictionary *)\n        val insert : 'a dict -> key -> 'a -> 'a dict\n\n        (* Return the value that a key maps to in the dictionary.\n         * Raise NotFound if there is not mapping for the key. *)\n        val lookup : 'a dict -> key -> 'a\n        exception NotFound\n\n        (* applies a function to all the elements of a dictionary;\n           i.e., if a dictionary d maps a string s to an element a, \n           then the dictionary (map f d) will map s to f(a). *)\n        val map : ('a -> 'b) -> 'a dict -> 'b dict\n\n   end\n\n```", "```\nmodule AssocList : DICTIONARY =\n    struct\n       type key = string\n       type 'a dict = (key * 'a) list\n\n       (* AF: The list [(k1,v1), (k2,v2), ...] represents the dictionary\n        * {k1 -> v1, k2 -> v2, ...}, except that if a key occurs\n        * multiple times in the list, only the earliest one matters.\n        * RI: true.\n        *)\n\n       let make() : 'a dict = []\n\n       let insert (d : 'a dict) (k : key) (x : 'a) : 'a dict =\n           (k, x) :: d\n\n       exception NotFound\n\n       let rec lookup (d : 'a dict) (k : key) : 'a =\n         match d with\n           [] -> raise NotFound\n         | (k', x) :: rest ->\n              if k = k' then x\n              else lookup rest k\n\n       let map (f : 'a -> 'b) (d : 'a dict) =\n           List.map (fun (k, a) -> (k, f a)) d\n    end\n\n```", "```\nmodule FunctionDict : DICTIONARY =\n  struct\n    type key = string\n    type 'a dict = string -> 'a\n    (* The function f represents the mapping in which x is mapped to\n     * (f x), except for x that are not in the mapping, in which case\n     * f raises NotFound.\n     *)\n    exception NotFound\n    let make () = fun _ -> raise NotFound\n    let lookup (d : 'a dict) (key : string) : 'a = d key\n    let insert (d : 'a dict) (k : key) (x : 'a) : 'a dict =\n      fun k' -> if k = k' then x else d k'\n    let map (f : 'a -> 'b) (d : 'a dict) = fun k -> f (d k)\n  end    \n\n```", "```\nmodule SortedAssocList : DICTIONARY =\n    struct\n        type key = string\n        type 'a dict = (key * 'a) list\n\n        (* AF: The list [(k1, v1); (k2, v2); ...] represents\n         *     the dictionary {k1 -> v1, k2 -> v2, ...}\n         * RI: The list is sorted by key and each key occurs only once\n         *     in the list. *)\n\n        let make() : 'a dict = []\n\n        let rec insert (d : 'a dict) (k : key) (x : 'a) : 'a dict =\n          match d with\n            [] -> (k, x) :: []\n          | (k', x') :: rest ->\n              match String.compare k k' with\n                1 -> (k', x') :: (insert rest k x)\n              | 0 -> (k, x) :: rest\n              | -1 -> (k, x) :: (k', x') :: rest\n              | _ -> failwith \"Impossible\"\n\n        exception NotFound\n\n        let rec lookup (d : 'a dict) (k : key) : 'a =\n          match d with\n            [] -> raise NotFound\n          | (k', x) :: rest ->\n              match String.compare k k' with\n                0 -> x\n              | -1 -> raise NotFound\n              | 1 -> lookup rest k\n              | _ -> failwith \"Impossible\"\n\n        let map (f : 'a -> 'b) (d : 'a dict) =\n           List.map (fun (k,a) -> (k, f a)) d\n    end\n\n```", "```\nmodule AssocTree : DICTIONARY =\n    struct\n        type key = string\n        type 'a dict = Empty | Node of key * 'a * 'a dict * 'a dict\n\n        (* AF: Empty represents the empty mapping {}\n         *     Node (key, datum, left, right) represents the union of\n         *     the mappings {key -> datum}, AF(left), and AF(right).\n         * RI: for Nodes, data to the left have keys that\n         *     are LESS than the datum and the keys of\n         *     the data to the right. *)\n\n        let make() : 'a dict = Empty\n\n        let rec insert (d : 'a dict) (k : key) (x : 'a) : 'a dict =\n          match d with\n            Empty -> Node (k, x, Empty, Empty)\n          | Node (k', x', l, r) ->\n              match String.compare k k' with\n                0 -> Node(k, x, l, r)\n              | -1 -> Node(k', x', insert l k x, r)\n              | 1 -> Node(k', x', l, insert r k x)\n              | _ -> failwith \"Impossible\"\n\n        exception NotFound\n\n        let rec lookup (d : 'a dict) (k : key) : 'a =\n          match d with\n            Empty -> raise NotFound\n          | Node(k', x, l, r) ->\n              match String.compare k k' with\n                0 -> x\n              | -1 -> lookup l k\n              | 1 -> lookup r k\n              | _ -> failwith \"Impossible\"\n\n        let rec map (f : 'a -> 'b) (d : 'a dict) =\n          match d with\n            Empty -> Empty\n          | Node (k, x, l, r) -> Node (k, f x, map f l, map f r)\n    end\n\n```", "```\nmodule type FRACTION =\n    sig\n        (* A fraction is a rational number p/q, where q != 0.*)\n        type fraction\n        (* Returns: make n d  is n/d. Requires: d != 0\\. *)\n        val make : int -> int -> fraction\n        val numerator : fraction -> int\n        val denominator : fraction -> int\n        val toString : fraction -> string\n        val toReal : fraction -> float\n        val add : fraction -> fraction -> fraction\n        val mul : fraction -> fraction -> fraction\n   end\n\n```", "```\nmodule Fraction1 : FRACTION =\n    struct\n        type fraction = { num:int; denom:int }\n        (* AF: The record {num=n; denom=d} represents fraction (n/d) *)\n\n        let make (n : int) (d : int) = {num=n; denom=d}\n\n        let numerator (x : fraction) : int = x.num\n\n        let denominator (x : fraction) : int = x.denom\n\n        let toString (x : fraction) : string =\n            (string_of_int (numerator x)) ^ \"/\" ^\n            (string_of_int (denominator x))\n\n        let toReal (x : fraction) : float =\n            (float (numerator x)) /. (float (denominator x))\n\n        let mul (x : fraction) (y : fraction) : fraction =\n            make ((numerator x) * (numerator y))\n                 ((denominator x) * (denominator y))\n\n        let add (x : fraction) (y : fraction) : fraction =\n            make ((numerator x) * (denominator y) +\n                  (numerator y) * (denominator x))\n                 ((denominator x) * (denominator y))\n    end\n\n```", "```\nmodule Fraction2 : FRACTION =\n    struct\n        type fraction = { num:int; denom:int }\n        (* AF: represents the fraction num/denom\n         * RI:\n         *  (1) denom is always positive\n         *  (2) always in most reduced form\n         *)\n\n        (* Returns the greatest common divisor of x and y.\n         * Requires: x, y are positive.\n         * Implementation: Euclid's algorithm.\n         *)\n        let rec gcd (x : int) (y : int) : int =\n                if x = 0 then y\n                else if x < y then gcd (y - x) x\n                else gcd y (x - y)\n\n        exception BadDenominator\n\n        let make (n : int) (d : int) : fraction =\n            if d = 0 then raise BadDenominator\n            else let g = gcd (abs n) (abs d) in\n                 let n2 = n / g in\n                 let d2 = d / g\n            in\n                 if (d2 < 0) then {num = -n2; denom = -d2}\n                 else {num = n2; denom = d2}\n\n        let numerator (x : fraction) : int = x.num\n\n        let denominator (x : fraction) : int = x.denom\n\n        let toString (x : fraction) : string =\n            (string_of_int (numerator x)) ^ \"/\" ^\n            (string_of_int (denominator x))\n\n        let toReal (x : fraction) : float =\n            (float (numerator x)) /. (float (denominator x))\n\n        (* Notice that we didn't have to re-code mul or add --\n         * they automatically get reduced because we called\n         * make instead of building the data structure directly.\n         *)\n        let mul (x : fraction) (y : fraction) : fraction =\n            make ((numerator x) * (numerator y))\n                 ((denominator x) * (denominator y))\n\n        let add (x : fraction) (y : fraction) : fraction =\n            make ((numerator x) * (denominator y) +\n                  (numerator y) * (denominator x))\n                 ((denominator x) * (denominator y))\n    end\n\n```"]