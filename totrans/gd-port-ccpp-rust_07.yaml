- en: Rust Background
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rust Background
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The catalyst for Rust was the Mozilla Firefox web browser. Firefox like most
    web browsers is:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Written in C++. ^([1](#fn_1))
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex with millions of lines of code.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerable to bugs, vulnerabilities and exploits, many of which are attributable
    to the language the software is written in.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mostly single-threaded and therefore not well suited for many-core devices -
    PCs, phones, tablets etc. Implementing multi-threading to the existing engine
    would doubtless cause even more bugs and vulnerabilities than being single threaded.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust was conceived as a way to obtain C or C++ levels of performance but also
    remove entire classes of software problem that destabilize software and could
    be exploited. Code that passes the compiler phase could be guaranteed to be memory
    safe and therefore could be written in a way to take advantage of concurrency.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: So Rust began life as a research project by Graydon Hoare in 2009 for the Mozilla
    foundation to solve these issues. It progressed until the release of version 1.0
    in 2015.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The project is hosted on [GitHub](https://github.com/rust-lang/rust). The language
    has been *self-hosting* for quite some time - that is to say the Rust compiler
    is written in Rust, so compiling Rust happens from a compiler written in Rust.
    Get your head around that! But it's the same way that C and C++ compilers are
    these days too.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](#fn_1)) Read this [Mozilla internal string guide](https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Guide/Internal_strings)
    to get a flavor of the sort of problems the browser had to overcome. A browser
    obviously uses a lot of temporary strings. STL strings were too inefficient /
    flakey from one compiler to the next and so the browser sprouted an entire tree
    of string related classes to solve this issue. Similar tales are told in Qt and
    other large libraries.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Problems with C/C++
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is trivial (by accident) to write code that is in error such as causing a
    memory leak. It is easy (by malice) to exploit badly written code to force it
    into error. It easy with the best testing in the world for some of these errors
    to only manifest themselves when the code is in production.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: At best, bugs are a costly burden for developers to find and fix, not just in
    time and dollars but also their reputation. At worst, the bug could causes catastrophic
    failure but more ordinarily leaves code unstable or vulnerable to hacking.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Rust is a language that produces machine code that is comparable in performance
    as C/C++ but enforces a safe-by-design philosophy. Simply put, the language and
    the compiler try to stop errors from happening in the first place. For example
    the compiler rigorously enforces lifetime tracking on objects and generates errors
    on violations. Most of these checks and guards are done at compile time so there
    is a zero-cost at runtime.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Active Development
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Rust team releases a new version of Rust approximately every 6 weeks. This
    means Rust receives code and speed improvements over time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Rust团队大约每6周发布一次新版本。这意味着随着时间的推移，Rust会接收到代码和速度的改进。
- en: Most releases focus on marking APIs as stable, improving code optimization and
    compile times.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数发布版本侧重于将API标记为稳定，改进代码优化和编译时间。
- en: Open source and free
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开源和免费
- en: Rust is dual licensed under the Apache 2.0 and MIT open source licenses. The
    full copyright message is viewable [online](https://github.com/rust-lang/rust/blob/master/COPYRIGHT).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Rust双重许可，根据Apache 2.0和MIT开源许可证。完整的版权信息可在线查看[此处](https://github.com/rust-lang/rust/blob/master/COPYRIGHT)。
- en: Essentially the license covers your right to modify and distribute the Rust
    source code. Note that Rust generates code for LLVM so LLVM also has its own software
    license (TODO link).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，许可证涵盖您修改和分发Rust源代码的权利。请注意，Rust为LLVM生成代码，因此LLVM也有自己的软件许可证（TODO链接）。
- en: What you compile with Rust (or LLVM) is not affected by the open source license.
    So you may compile, execute and distribute proprietary code without obligation
    to these licenses.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Rust（或LLVM）编译的内容不受开源许可证的影响。因此，您可以编译、执行和分发专有代码，而无需遵守这些许可证。
- en: Is Rust for everybody?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rust适合所有人吗？
- en: No of course not. Performance and safety are only two things to consider when
    writing software.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然不是。在编写软件时，性能和安全性只是需要考虑的两个方面。
- en: Sometimes it's okay for a program to crash every so often
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时程序偶尔崩溃也是可以接受的
- en: If you have code that's written and works then why throw that away?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您已经编写并运行正常的代码，为什么要将其丢弃呢？
- en: Writing new code will always take effort and will still cause application level
    bugs of one sort or another.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写新代码总是需要努力的，仍然会导致各种应用级别的错误。
- en: Performance may not be a big deal especially for network bound code and a higher
    level language like Java, C#, Go may suit better.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于网络绑定代码，性能可能并不是一个大问题，更适合使用高级语言如Java、C#、Go。
- en: Some people will find the learning curve extremely steep.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些人会觉得学习曲线非常陡峭。
- en: Rust is still relatively immature as a language and still has some rough edges
    - compilation times, optimization, complex macros.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust作为一种语言仍然相对不成熟，仍然存在一些问题 - 编译时间、优化、复杂的宏。
- en: But you may still find there is benefit to moving some of your code to Rust.
    For example, your C++ software might work great but it has to deal with a lot
    of user-generated data so perhaps you want to reimplement that code path in Rust
    for extra safety.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但您可能仍然会发现将部分代码转移到Rust中有益处。例如，您的C++软件可能运行良好，但必须处理大量用户生成的数据，因此也许您希望在Rust中重新实现该代码路径以获得额外的安全性。
- en: Safe by design
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全设计。
- en: 'Some examples of this safe-by-design philosophy:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安全设计哲学的一些例子：
- en: Variable (binding) is immutable by default. This is the opposite of C++ where
    mutable is the default and we must explicitly say const to make something immutable.
    Immutability extends to the &self reference on struct functions.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量（绑定）默认是不可变的。这与C++相反，C++中可变是默认的，我们必须明确指定const才能使某些东西不可变。不可变性延伸到结构函数上的&self引用。
- en: Lifetime tracking. The Rust compiler will track the lifetime of objects and
    can generate code to automatically drop them when they become unused. It will
    generate errors if lifetime rules are violated.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期跟踪。Rust编译器将跟踪对象的生命周期，并可以生成代码以在不再使用时自动丢弃它们。如果违反生命周期规则，它将生成错误。
- en: Borrowing / Variable binding. Rust enforces which variable "owns" an object
    at any given time, and tracks values that are moved to other variables. It enforces
    rules about who may hold a mutable or immutable reference to it. It will generate
    errors if the code tries to use moved variables, or obtain multiple mutable references
    to it.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 借用/变量绑定。Rust强制规定哪个变量在任何给定时间“拥有”一个对象，并跟踪被移动到其他变量的值。它强制执行关于谁可以持有可变或不可变引用的规则。如果代码尝试使用已移动的变量或获取多个可变引用，则会生成错误。
- en: There is no NULL pointer in safe code. All references and pointers are valid
    because their lifetimes and borrowing are tracked.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在安全代码中没有NULL指针。所有引用和指针都是有效的，因为它们的生命周期和借用是被跟踪的。
- en: Rust uses LLVM for the backend so it generates optimized machine code.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust使用LLVM作为后端，因此生成优化的机器代码。
- en: Lint checking is builtin, e.g. style enforcement for naming conventions and
    code consistency.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lint检查是内置的，例如对命名约定和代码一致性的样式强制执行。
- en: Unit tests can be integrated into the code and run automatically
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试可以集成到代码中并自动运行。
- en: Modules (equivalent to namespaces C++) are automatic meaning we implicitly get
    them by virtue of our file structure.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't C++11 / C++14 get us this?
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yes and no. C++11 and C++14 certainly bring in some long overdue changes. Concurrency
    primitives (threads at last!), move semantics, pointer ownership and other beneficial
    things all come in with these latest standards. Conveniences such as type inference,
    lambdas et al also come in.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: And perhaps if you program the right subset of features and diligently work
    to avoid pitfalls of C++ in general then you are more likely to create safe code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: But what is the *right* subset?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: If you use someone else's library - are they using the right subset?
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If one subset is right then why does C++ still contain all the stuff that is
    outside of that?
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are all the things which are patently unsafe / dangerous still allowed?
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are certain dangerous default behaviors such as default copy constructors
    not flipped to improve code safety?
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could argue that C++ doesn't want to break existing code by introducing change
    that requires code to be modified. That's fair enough but the flip-side is that
    future code is almost certainly going to be broken by this decision. Perhaps it
    would be better to inflict a little pain for some long term gain.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Unsafe programming / C interoperability
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rust recognizes you may need to call an external libraries, e.g. in a C library
    or a system API.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Therefore it provides an `unsafe` keyword that throws some of the safety switches
    when it is necessary to talk to the outside world.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: This allows you consider the possibility of porting code partially to Rust while
    still allowing some of it to remain as C.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
