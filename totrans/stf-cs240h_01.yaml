- en: Hello, world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'm Bryan O'Sullivan.
  prefs: []
  type: TYPE_NORMAL
- en: I work at Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, I founded a company that built half its product in Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: I wrote a book about Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: I've written some Haskell libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Let's talk about testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have any profs ever talked to you about testing?
  prefs: []
  type: TYPE_NORMAL
- en: Testing in industry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few "states of the art" for testing software:'
  prefs: []
  type: TYPE_NORMAL
- en: Excel spreadsheet full of stuff to do by hand (I am not making this up)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzz tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What am I interested in?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For today, I want to talk about unit tests and their more interesting descendants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shamelessly borrowing from Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What's the problem?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Count the number of test cases below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Okay, don't. It's 7.
  prefs: []
  type: TYPE_NORMAL
- en: The limits of unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit tests are only useful up to a point.
  prefs: []
  type: TYPE_NORMAL
- en: Your patience and ability to think up nasty corner cases are VERY finite.
  prefs: []
  type: TYPE_NORMAL
- en: Best to use them wisely.
  prefs: []
  type: TYPE_NORMAL
- en: But how?
  prefs: []
  type: TYPE_NORMAL
- en: Outsourcing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For patience, we have computers.
  prefs: []
  type: TYPE_NORMAL
- en: For nasty corner cases, we have random number generators.
  prefs: []
  type: TYPE_NORMAL
- en: Let's put them to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example: UTF-16 encoding'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'UTF-16 is a Unicode encoding that:'
  prefs: []
  type: TYPE_NORMAL
- en: takes a *code point* (a Unicode character)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: turns it into 1 or 2 16-bit *code units*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variable length encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: code points below 0x10000 are encoded as a single code unit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: at and above 0x10000, two code units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding a single code point
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that `Char` represents a Unicode code point.
  prefs: []
  type: TYPE_NORMAL
- en: The `Word16` type represents a 16-bit value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What should the type signature of `encodeChar` be?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The base case is easy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can easily turn the single-code-unit case into some Haskell using a few handy
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We use `fromIntegral` to convert from `Int` to `Word16` because Haskell will
    not explicitly coerce for us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The two-code-unit case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To encode code points above 0x10000, we need some new bit-banging functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `.&.` operator gives us bitwise *and*, while `shiftR` is a right shift.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Basic testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want unit tests, `HUnit` is the package you need.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A bad test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's intentionally write a bogus test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this in `ghci`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Not pretty, but it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait: unit tests?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So I just slammed unit tests and now I'm showing you how to write them?
  prefs: []
  type: TYPE_NORMAL
- en: Well, we can generalize past the limits of unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: A proxy for a bigger picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What do we really want with this test?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We are really asserting that *every* ASCII code point encodes as a single code
    unit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Hmm: better?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What if we parameterize our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And drive it from a harness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Taking stock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is better, in that our original test is generalized.
  prefs: []
  type: TYPE_NORMAL
- en: It's also worse, because we're exhaustively enumerating every single test input.
  prefs: []
  type: TYPE_NORMAL
- en: We get away with it here because Unicode is small, and computers are fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'But it''s the *principle* of the thing: automate better!'
  prefs: []
  type: TYPE_NORMAL
- en: Enter QuickCheck
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Forget about `HUnit`, here's the package we'll focus on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In `ghci`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Why did `quickCheck` say this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*generated* 100 random values for us'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fed each one to `prop_encodeOne`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ensured that each test passed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now I have a headache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look back at our "test function":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is *very suspicious*.
  prefs: []
  type: TYPE_NORMAL
- en: We know that `encodeChar` sometimes produces lists of length 2.
  prefs: []
  type: TYPE_NORMAL
- en: So why did our 100 tests pass?
  prefs: []
  type: TYPE_NORMAL
- en: Starting small
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For most types, QuickCheck operates from the handy assumption that "small" test
    cases are more useful than big ones.
  prefs: []
  type: TYPE_NORMAL
- en: As tests pass for small random inputs, it generates "bigger" ones.
  prefs: []
  type: TYPE_NORMAL
- en: With just 100 tests, we are simply not likely to generate a code point that
    encodes as two code units.
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind the scenes: generating values'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How does QuickCheck do its thing, anyway?
  prefs: []
  type: TYPE_NORMAL
- en: It needs to be able to generate random values.
  prefs: []
  type: TYPE_NORMAL
- en: This it achieves via typeclasses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Behind the scenes: some machinery'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Behind the scenes: testable things'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The two instances above are crucial.
  prefs: []
  type: TYPE_NORMAL
- en: How does this work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's write our test function with a type signature.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And `quickCheck`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Look again
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If `quickCheck` accepts `prop_encodeOne`, then the latter must be an instance
    of `Testable`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: But how? Via these two instances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Long story short
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we pass `quickCheck` a function, then:'
  prefs: []
  type: TYPE_NORMAL
- en: provided its arguments are all instances of `Arbitrary` and `Show`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*and* provided its result is an instance of `Testable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*then* `quickCheck` can:'
  prefs: []
  type: TYPE_NORMAL
- en: '*generate* arbitrary values of *all* necessary types automatically,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: run our test on those values,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and ensure that our test always passes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So what?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We still have a broken test!
  prefs: []
  type: TYPE_NORMAL
- en: '`quickCheck` tells us that it always passes---when it shouldn''t!'
  prefs: []
  type: TYPE_NORMAL
- en: Why? We have to read the source.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Oh great, QuickCheck will only generate 8-bit characters.
  prefs: []
  type: TYPE_NORMAL
- en: Our assumption that it would eventually generate big-enough inputs was wrong
    for `Char`.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore our test can never fail.
  prefs: []
  type: TYPE_NORMAL
- en: How...unfortunate!
  prefs: []
  type: TYPE_NORMAL
- en: Writing a new Arbitrary instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So now we face a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: We want a type that is almost exactly like `Char`, but that has a different
    `Arbitrary` instance.
  prefs: []
  type: TYPE_NORMAL
- en: To create such a type, we use the `newtype` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The type is named `BigChar`; its constructor is named `Big`.
  prefs: []
  type: TYPE_NORMAL
- en: We use `deriving` to reuse the `Eq` instance of the underlying `Char` type,
    and to generate a new `Show` instance.
  prefs: []
  type: TYPE_NORMAL
- en: What next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to be able to flesh this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The highest Unicode code point is 0x10FFFF.
  prefs: []
  type: TYPE_NORMAL
- en: We want to generate values in this range.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw this earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Random values: the hard way'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to use `choose`, we must make `BigChar` an instance of `Random`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a verbose way to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Random values: easier'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to avoid the boilerplate code from the previous slide, we can use
    a trick:'
  prefs: []
  type: TYPE_NORMAL
- en: The `GeneralizedNewtypeDeriving` language extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This lets GHC automatically derive some non-standard typeclass instances for
    us, e.g. `Random`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: All we did was add `Random` to the `deriving` clause above.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the name suggests, this only works with the `newtype` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our instance, and a rerun
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An instance with a body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'A new test that unwraps a `BigChar` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Great! Not only did our broken test fail immediately...
  prefs: []
  type: TYPE_NORMAL
- en: '...but it gave us a *counterexample*, an input on which our test function reproducibly
    fails!'
  prefs: []
  type: TYPE_NORMAL
- en: The magic of QuickCheck
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The beauty here is several-fold:'
  prefs: []
  type: TYPE_NORMAL
- en: We write a simple Haskell function that accepts some inputs and returns a `Bool`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QuickCheck generates random test cases for us, and tests our function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a test case fails, it tells us what the inputs were
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So what?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unit test way:'
  prefs: []
  type: TYPE_NORMAL
- en: A pile of unit tests that are small variations on a theme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'QuickCheck way:'
  prefs: []
  type: TYPE_NORMAL
- en: One property that you expect to hold universally true
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically, randomly generated test inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counterexamples that help you pinpoint your bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What else?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s a problem with random inputs when a test fails:'
  prefs: []
  type: TYPE_NORMAL
- en: They're often *big*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Big things are difficult for humans to deal with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Big values usually take longer to look through.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Starting from a random failing input:'
  prefs: []
  type: TYPE_NORMAL
- en: We'd like to find the *smallest* input that will cause a test to fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QuickCheck calls this *shrinking*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Micro-lab: shrink a BigChar'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Grab the following source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Using `ghci` to do some spelunking, work out a body for `shrinkChar`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You have 5 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Generating vs filtering values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are two different approaches to generating test values.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, generate them directly (look at line 2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, generate any old value, but *filter* such that we get only the ones
    that make sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Generating vs filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is *usually* more efficient to generate only the values you'll need, and
    do no filtering.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it's easier to identify good values when you see them (by filtering)
    than to figure out how to generate them.
  prefs: []
  type: TYPE_NORMAL
- en: If QuickCheck has to generate too many values that fail a `suchThat` or other
    filter, it will give up and may not run as many tests as you want.
  prefs: []
  type: TYPE_NORMAL
- en: For both efficiency *and* to ensure that QuickCheck can generate enough values
    to test, it's worth trying to generate only good values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mini-lab: more code!'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Grab the following source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a definition for `decodeUtf16`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Decide on some QuickCheck tests, write them, and run them.
  prefs: []
  type: TYPE_NORMAL
- en: You have 15 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Sizing a test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Test data generators have an implicit size parameter, hidden inside the `Gen`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: QuickCheck starts by generating small test cases; it increases the size as testing
    progresses.
  prefs: []
  type: TYPE_NORMAL
- en: The meaning of "size" is specific to the needs of an `Arbitrary` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `Arbitrary` instance for lists interprets it as "the maximum length of a
    list of arbitrary values".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can find the current size using the `sized` function, and modify it locally
    using `resize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Lifting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re hopefully by now familiar with the `Functor` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This takes a pure function and "lifts" it into the functor `f`.
  prefs: []
  type: TYPE_NORMAL
- en: In general, "lifting" takes a concept and transforms it to work in a different
    (sometimes more general) setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can define lifting of functions with the `Monad` class too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: fmap and liftM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Notice the similarities between the type signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'All instances of `Monad` can possibly be instances of `Functor`. Ideally, they''d
    be defined in terms of each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'For historical reasons, the two classes are separate, so we write separate
    instances for them and just reuse the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Why the apparent digression?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It turns out that lifting pure functions into monads is really common.
  prefs: []
  type: TYPE_NORMAL
- en: So common, in fact, that `Control.Monad` defines a bunch of extra combinators
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: These combinators go all the way up to `liftM5`.
  prefs: []
  type: TYPE_NORMAL
- en: Look familiar? Useful?
  prefs: []
  type: TYPE_NORMAL
- en: A tighter Arbitrary instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'After:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Micro-lab: shrinking a Point'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: QuickCheck provides us with machinery to shrink tuples.
  prefs: []
  type: TYPE_NORMAL
- en: Make use of this machinery to shrink a `Point`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Take 3 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Testing a recursive data type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we have a tree type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an obvious `Arbitrary` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `oneof` combinator chooses a generator at random.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: What's up, Doc?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Potential trouble:'
  prefs: []
  type: TYPE_NORMAL
- en: This generator may not terminate at all!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's likely to produce *huge* trees.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the `sample` function to generate and print some arbitrary data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This helps us to explore what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: A safer instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here's where the sizing mechanism comes to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Where all this is going
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: QuickCheck is pretty great. Take the time to learn to use it.
  prefs: []
  type: TYPE_NORMAL
- en: It's a little harder to learn to use it well than unit tests, but it pays off
    big time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore:'
  prefs: []
  type: TYPE_NORMAL
- en: We really want to see you provide QuickCheck tests with future labs and your
    final projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enjoy!
  prefs: []
  type: TYPE_NORMAL
