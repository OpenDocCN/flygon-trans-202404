- en: What is Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Recursion** is a method for writing procedures that solve certain types of
    problems. These problems have solutions that depend on solutions to smaller instances
    of the same problem. Oftentimes, recursion has us repeat the same procedure over
    and over again. It looks a little like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](http://caseelse.net/wp-content/uploads/2008/05/recursionagain.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What's peculiar about recursive procedures is that in order to call the procedure,
    we'll need to have the procedure call itself, which will have to call itself,
    which will-- let's go stare at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Factorial'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In math, the factorial of a non-negative integer [mathjaxinline]n[/mathjaxinline],
    denoted by [mathjaxinline]n![/mathjaxinline], is the product of all positive integers
    less than or equal to n. For example, [mathjaxinline]3! = 3 * 2 * 1[/mathjaxinline].
    Also, by definition, [mathjaxinline]0! = 1[/mathjaxinline].
  prefs: []
  type: TYPE_NORMAL
- en: How can we write the `factorial` procedure in Racket? This presents a challenge,
    since the numbers that we would like to multiply together depends on the number
    we want to find the factorial of, the *argument*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we''ll use recursion. Let''s split it into two possible cases:'
  prefs: []
  type: TYPE_NORMAL
- en: if [mathjaxinline]n â‰¥ 1[/mathjaxinline], then [mathjaxinline]n! = n * (n-1)![/mathjaxinline]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if [mathjaxinline]n = 0[/mathjaxinline], then [mathjaxinline]n! = 1[/mathjaxinline]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion depends heavily on *conditionals*. If we've finished, return some
    value. Otherwise, continue recursing. For the factorial example, we recurse until
    we reach [mathjaxinline]n = 0[/mathjaxinline], where we then return 1\. We can
    use this to write `factorial`. Take a look at the Racket solution for `factorial`
    below and see if you can make sense of it. Try it out in the interpreter too!
    It's all right if you don't understand the code at the moment. We will go over
    recursion more explicitly in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Takeaways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is what we covered in this subsection:'
  prefs: []
  type: TYPE_NORMAL
- en: What is recursion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is factorial defined using recursion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move on to the next subsection to learn how recursion works.
  prefs: []
  type: TYPE_NORMAL
